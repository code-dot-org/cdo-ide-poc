import './style.css';
var rk = Object.defineProperty;
var ik = (t, e, r) => e in t ? rk(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var Ur = (t, e, r) => (ik(t, typeof e != "symbol" ? e + "" : e, r), r);
import Ox, { createContext as nk, useContext as sk, useMemo as xx, useState as An, useEffect as Jr, forwardRef as ak, useRef as Gf, useImperativeHandle as ok, useCallback as lk, useReducer as uk } from "react";
import { html as ck } from "@codemirror/lang-html";
import { css as hk } from "@codemirror/lang-css";
import { json as pk } from "@codemirror/lang-json";
var dk = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function fk(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var cd = { exports: {} }, Xs = {};
/** @license React v16.14.0
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $y;
function mk() {
  if ($y)
    return Xs;
  $y = 1;
  var t = Ox, e = 60103;
  if (Xs.Fragment = 60107, typeof Symbol == "function" && Symbol.for) {
    var r = Symbol.for;
    e = r("react.element"), Xs.Fragment = r("react.fragment");
  }
  var i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n = Object.prototype.hasOwnProperty, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(l, u, h) {
    var p, d = {}, m = null, y = null;
    h !== void 0 && (m = "" + h), u.key !== void 0 && (m = "" + u.key), u.ref !== void 0 && (y = u.ref);
    for (p in u)
      n.call(u, p) && !s.hasOwnProperty(p) && (d[p] = u[p]);
    if (l && l.defaultProps)
      for (p in u = l.defaultProps, u)
        d[p] === void 0 && (d[p] = u[p]);
    return { $$typeof: e, type: l, key: m, ref: y, props: d, _owner: i.current };
  }
  return Xs.jsx = a, Xs.jsxs = a, Xs;
}
var sp = {};
/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var By;
function gk() {
  return By || (By = 1, function(t) {
    process.env.NODE_ENV !== "production" && function() {
      var e = Ox, r = 60103, i = 60106;
      t.Fragment = 60107;
      var n = 60108, s = 60114, a = 60109, l = 60110, u = 60112, h = 60113, p = 60120, d = 60115, m = 60116, y = 60121, O = 60122, D = 60117, v = 60129, w = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var x = Symbol.for;
        r = x("react.element"), i = x("react.portal"), t.Fragment = x("react.fragment"), n = x("react.strict_mode"), s = x("react.profiler"), a = x("react.provider"), l = x("react.context"), u = x("react.forward_ref"), h = x("react.suspense"), p = x("react.suspense_list"), d = x("react.memo"), m = x("react.lazy"), y = x("react.block"), O = x("react.server.block"), D = x("react.fundamental"), x("react.scope"), x("react.opaque.id"), v = x("react.debug_trace_mode"), x("react.offscreen"), w = x("react.legacy_hidden");
      }
      var S = typeof Symbol == "function" && Symbol.iterator, k = "@@iterator";
      function C(L) {
        if (L === null || typeof L != "object")
          return null;
        var ne = S && L[S] || L[k];
        return typeof ne == "function" ? ne : null;
      }
      var A = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function P(L) {
        {
          for (var ne = arguments.length, pe = new Array(ne > 1 ? ne - 1 : 0), Fe = 1; Fe < ne; Fe++)
            pe[Fe - 1] = arguments[Fe];
          I("error", L, pe);
        }
      }
      function I(L, ne, pe) {
        {
          var Fe = A.ReactDebugCurrentFrame, Ve = "";
          if (ye) {
            var Ne = X(ye.type), $e = ye._owner;
            Ve += G(Ne, ye._source, $e && X($e.type));
          }
          Ve += Fe.getStackAddendum(), Ve !== "" && (ne += "%s", pe = pe.concat([Ve]));
          var ke = pe.map(function(Lt) {
            return "" + Lt;
          });
          ke.unshift("Warning: " + ne), Function.prototype.apply.call(console[L], console, ke);
        }
      }
      var B = !1;
      function _(L) {
        return !!(typeof L == "string" || typeof L == "function" || L === t.Fragment || L === s || L === v || L === n || L === h || L === p || L === w || B || typeof L == "object" && L !== null && (L.$$typeof === m || L.$$typeof === d || L.$$typeof === a || L.$$typeof === l || L.$$typeof === u || L.$$typeof === D || L.$$typeof === y || L[0] === O));
      }
      var R = /^(.*)[\\\/]/;
      function G(L, ne, pe) {
        var Fe = "";
        if (ne) {
          var Ve = ne.fileName, Ne = Ve.replace(R, "");
          if (/^index\./.test(Ne)) {
            var $e = Ve.match(R);
            if ($e) {
              var ke = $e[1];
              if (ke) {
                var Lt = ke.replace(R, "");
                Ne = Lt + "/" + Ne;
              }
            }
          }
          Fe = " (at " + Ne + ":" + ne.lineNumber + ")";
        } else
          pe && (Fe = " (created by " + pe + ")");
        return `
    in ` + (L || "Unknown") + Fe;
      }
      var J = 1;
      function Q(L) {
        return L._status === J ? L._result : null;
      }
      function q(L, ne, pe) {
        var Fe = ne.displayName || ne.name || "";
        return L.displayName || (Fe !== "" ? pe + "(" + Fe + ")" : pe);
      }
      function X(L) {
        if (L == null)
          return null;
        if (typeof L.tag == "number" && P("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof L == "function")
          return L.displayName || L.name || null;
        if (typeof L == "string")
          return L;
        switch (L) {
          case t.Fragment:
            return "Fragment";
          case i:
            return "Portal";
          case s:
            return "Profiler";
          case n:
            return "StrictMode";
          case h:
            return "Suspense";
          case p:
            return "SuspenseList";
        }
        if (typeof L == "object")
          switch (L.$$typeof) {
            case l:
              return "Context.Consumer";
            case a:
              return "Context.Provider";
            case u:
              return q(L, L.render, "ForwardRef");
            case d:
              return X(L.type);
            case y:
              return X(L.render);
            case m: {
              var ne = L, pe = Q(ne);
              if (pe)
                return X(pe);
              break;
            }
          }
        return null;
      }
      var K = {};
      A.ReactDebugCurrentFrame;
      var ye = null;
      function Ce(L) {
        ye = L;
      }
      function be(L, ne, pe, Fe, Ve) {
        {
          var Ne = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var $e in L)
            if (Ne(L, $e)) {
              var ke = void 0;
              try {
                if (typeof L[$e] != "function") {
                  var Lt = Error((Fe || "React class") + ": " + pe + " type `" + $e + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof L[$e] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Lt.name = "Invariant Violation", Lt;
                }
                ke = L[$e](ne, $e, Fe, pe, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Tr) {
                ke = Tr;
              }
              ke && !(ke instanceof Error) && (Ce(Ve), P("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Fe || "React class", pe, $e, typeof ke), Ce(null)), ke instanceof Error && !(ke.message in K) && (K[ke.message] = !0, Ce(Ve), P("Failed %s type: %s", pe, ke.message), Ce(null));
            }
        }
      }
      var Le = A.ReactCurrentOwner, Ye = Object.prototype.hasOwnProperty, Je = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Te, ht, ue;
      ue = {};
      function V(L) {
        if (Ye.call(L, "ref")) {
          var ne = Object.getOwnPropertyDescriptor(L, "ref").get;
          if (ne && ne.isReactWarning)
            return !1;
        }
        return L.ref !== void 0;
      }
      function W(L) {
        if (Ye.call(L, "key")) {
          var ne = Object.getOwnPropertyDescriptor(L, "key").get;
          if (ne && ne.isReactWarning)
            return !1;
        }
        return L.key !== void 0;
      }
      function j(L, ne) {
        if (typeof L.ref == "string" && Le.current && ne && Le.current.stateNode !== ne) {
          var pe = X(Le.current.type);
          ue[pe] || (P('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', X(Le.current.type), L.ref), ue[pe] = !0);
        }
      }
      function ve(L, ne) {
        {
          var pe = function() {
            Te || (Te = !0, P("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ne));
          };
          pe.isReactWarning = !0, Object.defineProperty(L, "key", {
            get: pe,
            configurable: !0
          });
        }
      }
      function De(L, ne) {
        {
          var pe = function() {
            ht || (ht = !0, P("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ne));
          };
          pe.isReactWarning = !0, Object.defineProperty(L, "ref", {
            get: pe,
            configurable: !0
          });
        }
      }
      var Ae = function(L, ne, pe, Fe, Ve, Ne, $e) {
        var ke = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: r,
          // Built-in properties that belong on the element
          type: L,
          key: ne,
          ref: pe,
          props: $e,
          // Record the component responsible for creating this element.
          _owner: Ne
        };
        return ke._store = {}, Object.defineProperty(ke._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(ke, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Fe
        }), Object.defineProperty(ke, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Ve
        }), Object.freeze && (Object.freeze(ke.props), Object.freeze(ke)), ke;
      };
      function Jt(L, ne, pe, Fe, Ve) {
        {
          var Ne, $e = {}, ke = null, Lt = null;
          pe !== void 0 && (ke = "" + pe), W(ne) && (ke = "" + ne.key), V(ne) && (Lt = ne.ref, j(ne, Ve));
          for (Ne in ne)
            Ye.call(ne, Ne) && !Je.hasOwnProperty(Ne) && ($e[Ne] = ne[Ne]);
          if (L && L.defaultProps) {
            var Tr = L.defaultProps;
            for (Ne in Tr)
              $e[Ne] === void 0 && ($e[Ne] = Tr[Ne]);
          }
          if (ke || Lt) {
            var ci = typeof L == "function" ? L.displayName || L.name || "Unknown" : L;
            ke && ve($e, ci), Lt && De($e, ci);
          }
          return Ae(L, ke, Lt, Ve, Fe, Le.current, $e);
        }
      }
      var Mt = A.ReactCurrentOwner;
      A.ReactDebugCurrentFrame;
      function wt(L) {
        ye = L;
      }
      var Xr;
      Xr = !1;
      function ln(L) {
        return typeof L == "object" && L !== null && L.$$typeof === r;
      }
      function ur() {
        {
          if (Mt.current) {
            var L = X(Mt.current.type);
            if (L)
              return `

Check the render method of \`` + L + "`.";
          }
          return "";
        }
      }
      function kr(L) {
        {
          if (L !== void 0) {
            var ne = L.fileName.replace(/^.*[\\\/]/, ""), pe = L.lineNumber;
            return `

Check your code at ` + ne + ":" + pe + ".";
          }
          return "";
        }
      }
      var li = {};
      function un(L) {
        {
          var ne = ur();
          if (!ne) {
            var pe = typeof L == "string" ? L : L.displayName || L.name;
            pe && (ne = `

Check the top-level render call using <` + pe + ">.");
          }
          return ne;
        }
      }
      function Qi(L, ne) {
        {
          if (!L._store || L._store.validated || L.key != null)
            return;
          L._store.validated = !0;
          var pe = un(ne);
          if (li[pe])
            return;
          li[pe] = !0;
          var Fe = "";
          L && L._owner && L._owner !== Mt.current && (Fe = " It was passed a child from " + X(L._owner.type) + "."), wt(L), P('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', pe, Fe), wt(null);
        }
      }
      function ji(L, ne) {
        {
          if (typeof L != "object")
            return;
          if (Array.isArray(L))
            for (var pe = 0; pe < L.length; pe++) {
              var Fe = L[pe];
              ln(Fe) && Qi(Fe, ne);
            }
          else if (ln(L))
            L._store && (L._store.validated = !0);
          else if (L) {
            var Ve = C(L);
            if (typeof Ve == "function" && Ve !== L.entries)
              for (var Ne = Ve.call(L), $e; !($e = Ne.next()).done; )
                ln($e.value) && Qi($e.value, ne);
          }
        }
      }
      function ui(L) {
        {
          var ne = L.type;
          if (ne == null || typeof ne == "string")
            return;
          var pe;
          if (typeof ne == "function")
            pe = ne.propTypes;
          else if (typeof ne == "object" && (ne.$$typeof === u || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          ne.$$typeof === d))
            pe = ne.propTypes;
          else
            return;
          if (pe) {
            var Fe = X(ne);
            be(pe, L.props, "prop", Fe, L);
          } else if (ne.PropTypes !== void 0 && !Xr) {
            Xr = !0;
            var Ve = X(ne);
            P("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ve || "Unknown");
          }
          typeof ne.getDefaultProps == "function" && !ne.getDefaultProps.isReactClassApproved && P("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Rs(L) {
        {
          for (var ne = Object.keys(L.props), pe = 0; pe < ne.length; pe++) {
            var Fe = ne[pe];
            if (Fe !== "children" && Fe !== "key") {
              wt(L), P("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Fe), wt(null);
              break;
            }
          }
          L.ref !== null && (wt(L), P("Invalid attribute `ref` supplied to `React.Fragment`."), wt(null));
        }
      }
      function ql(L, ne, pe, Fe, Ve, Ne) {
        {
          var $e = _(L);
          if (!$e) {
            var ke = "";
            (L === void 0 || typeof L == "object" && L !== null && Object.keys(L).length === 0) && (ke += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var Lt = kr(Ve);
            Lt ? ke += Lt : ke += ur();
            var Tr;
            L === null ? Tr = "null" : Array.isArray(L) ? Tr = "array" : L !== void 0 && L.$$typeof === r ? (Tr = "<" + (X(L.type) || "Unknown") + " />", ke = " Did you accidentally export a JSX literal instead of a component?") : Tr = typeof L, P("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Tr, ke);
          }
          var ci = Jt(L, ne, pe, Ve, Ne);
          if (ci == null)
            return ci;
          if ($e) {
            var Ri = ne.children;
            if (Ri !== void 0)
              if (Fe)
                if (Array.isArray(Ri)) {
                  for (var Ws = 0; Ws < Ri.length; Ws++)
                    ji(Ri[Ws], L);
                  Object.freeze && Object.freeze(Ri);
                } else
                  P("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                ji(Ri, L);
          }
          return L === t.Fragment ? Rs(ci) : ui(ci), ci;
        }
      }
      function Zs(L, ne, pe) {
        return ql(L, ne, pe, !0);
      }
      function Vr(L, ne, pe) {
        return ql(L, ne, pe, !1);
      }
      var Ga = Vr, Xl = Zs;
      t.jsx = Ga, t.jsxs = Xl;
    }();
  }(sp)), sp;
}
process.env.NODE_ENV === "production" ? cd.exports = mk() : cd.exports = gk();
var z = cd.exports;
const Dx = nk(null), Cr = () => {
  const t = sk(Dx);
  if (t === null)
    throw new Error("CDO IDE Context has not been provided!");
  return t;
}, yk = ({
  children: t,
  value: e
}) => /* @__PURE__ */ z.jsx(Dx.Provider, { value: e, children: t }), Ok = ["html", "css", "js", "json"], bx = (t, e = Ok) => new Set(e).has(t), cs = "0", vx = (t = [], e) => t.reduce((r, i) => {
  if (!i.length)
    return r;
  const n = Object.values(e.folders).find(
    (s) => s.name === i && s.parentId === r
  );
  if (!n) {
    if (e.required)
      throw new Error(`Could not find folder ${t.join("/")}`);
    return cs;
  }
  return n.id;
}, cs), xk = () => /* @__PURE__ */ z.jsx("div", { children: "No files are open. Choose a file from the browser to the left." }), Dk = () => /* @__PURE__ */ z.jsx("div", {}), bk = (t) => t.EmptyEditorComponent ? t.EmptyEditorComponent : t.blankEmptyEditor ? Dk : xk, GU = () => ({ files: {}, folders: {} }), wx = (t) => typeof t == "string" ? t : t instanceof Error ? t.message : "", vk = ["html", "js", "json"], Kl = (t, e = vk) => new Set(e).has(t);
var wk = Object.create, Xc = Object.defineProperty, Sk = Object.getOwnPropertyDescriptor, Ck = Object.getOwnPropertyNames, Ek = Object.getPrototypeOf, Ak = Object.prototype.hasOwnProperty, kk = (t, e) => () => (t && (e = t(t = 0)), e), Vc = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Uc = (t, e) => {
  for (var r in e)
    Xc(t, r, { get: e[r], enumerable: !0 });
}, Sx = (t, e, r, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of Ck(e))
      !Ak.call(t, n) && n !== r && Xc(t, n, { get: () => e[n], enumerable: !(i = Sk(e, n)) || i.enumerable });
  return t;
}, ml = (t, e, r) => (r = t != null ? wk(Ek(t)) : {}, Sx(e || !t || !t.__esModule ? Xc(r, "default", { value: t, enumerable: !0 }) : r, t)), Tk = (t) => Sx(Xc({}, "__esModule", { value: !0 }), t), Pk = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, Iy = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, ro = (t, e, r) => (Pk(t, e, "access private method"), r), Fk = Vc((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = e;
  function e() {
  }
  e.prototype = { diff: function(n, s) {
    var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = a.callback;
    typeof a == "function" && (l = a, a = {}), this.options = a;
    var u = this;
    function h(x) {
      return l ? (setTimeout(function() {
        l(void 0, x);
      }, 0), !0) : x;
    }
    n = this.castInput(n), s = this.castInput(s), n = this.removeEmpty(this.tokenize(n)), s = this.removeEmpty(this.tokenize(s));
    var p = s.length, d = n.length, m = 1, y = p + d;
    a.maxEditLength && (y = Math.min(y, a.maxEditLength));
    var O = [{ newPos: -1, components: [] }], D = this.extractCommon(O[0], s, n, 0);
    if (O[0].newPos + 1 >= p && D + 1 >= d)
      return h([{ value: this.join(s), count: s.length }]);
    function v() {
      for (var x = -1 * m; x <= m; x += 2) {
        var S = void 0, k = O[x - 1], C = O[x + 1], A = (C ? C.newPos : 0) - x;
        k && (O[x - 1] = void 0);
        var P = k && k.newPos + 1 < p, I = C && 0 <= A && A < d;
        if (!P && !I) {
          O[x] = void 0;
          continue;
        }
        if (!P || I && k.newPos < C.newPos ? (S = i(C), u.pushComponent(S.components, void 0, !0)) : (S = k, S.newPos++, u.pushComponent(S.components, !0, void 0)), A = u.extractCommon(S, s, n, x), S.newPos + 1 >= p && A + 1 >= d)
          return h(r(u, S.components, s, n, u.useLongestToken));
        O[x] = S;
      }
      m++;
    }
    if (l)
      (function x() {
        setTimeout(function() {
          if (m > y)
            return l();
          v() || x();
        }, 0);
      })();
    else
      for (; m <= y; ) {
        var w = v();
        if (w)
          return w;
      }
  }, pushComponent: function(n, s, a) {
    var l = n[n.length - 1];
    l && l.added === s && l.removed === a ? n[n.length - 1] = { count: l.count + 1, added: s, removed: a } : n.push({ count: 1, added: s, removed: a });
  }, extractCommon: function(n, s, a, l) {
    for (var u = s.length, h = a.length, p = n.newPos, d = p - l, m = 0; p + 1 < u && d + 1 < h && this.equals(s[p + 1], a[d + 1]); )
      p++, d++, m++;
    return m && n.components.push({ count: m }), n.newPos = p, d;
  }, equals: function(n, s) {
    return this.options.comparator ? this.options.comparator(n, s) : n === s || this.options.ignoreCase && n.toLowerCase() === s.toLowerCase();
  }, removeEmpty: function(n) {
    for (var s = [], a = 0; a < n.length; a++)
      n[a] && s.push(n[a]);
    return s;
  }, castInput: function(n) {
    return n;
  }, tokenize: function(n) {
    return n.split("");
  }, join: function(n) {
    return n.join("");
  } };
  function r(n, s, a, l, u) {
    for (var h = 0, p = s.length, d = 0, m = 0; h < p; h++) {
      var y = s[h];
      if (y.removed) {
        if (y.value = n.join(l.slice(m, m + y.count)), m += y.count, h && s[h - 1].added) {
          var O = s[h - 1];
          s[h - 1] = s[h], s[h] = O;
        }
      } else {
        if (!y.added && u) {
          var D = a.slice(d, d + y.count);
          D = D.map(function(w, x) {
            var S = l[m + x];
            return S.length > w.length ? S : w;
          }), y.value = n.join(D);
        } else
          y.value = n.join(a.slice(d, d + y.count));
        d += y.count, y.added || (m += y.count);
      }
    }
    var v = s[p - 1];
    return p > 1 && typeof v.value == "string" && (v.added || v.removed) && n.equals("", v.value) && (s[p - 2].value += v.value, s.pop()), s;
  }
  function i(n) {
    return { newPos: n.newPos, components: n.components.slice(0) };
  }
}), $k = Vc((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.diffArrays = n, t.arrayDiff = void 0;
  var e = r(Fk());
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  var i = new e.default();
  t.arrayDiff = i, i.tokenize = function(s) {
    return s.slice();
  }, i.join = i.removeEmpty = function(s) {
    return s;
  };
  function n(s, a, l) {
    return i.diff(s, a, l);
  }
}), Yc = Vc((t, e) => {
  var r = new Proxy(String, { get: () => r });
  e.exports = r;
}), Cx = {};
Uc(Cx, { default: () => Ax, shouldHighlight: () => Ex });
var Ex, Ax, Bk = kk(() => {
  Ex = () => !1, Ax = String;
}), Ik = Vc((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.codeFrameColumns = d, t.default = m;
  var e = (Bk(), Tk(Cx)), r = n(Yc(), !0);
  function i(y) {
    if (typeof WeakMap != "function")
      return null;
    var O = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap();
    return (i = function(v) {
      return v ? D : O;
    })(y);
  }
  function n(y, O) {
    if (!O && y && y.__esModule)
      return y;
    if (y === null || typeof y != "object" && typeof y != "function")
      return { default: y };
    var D = i(O);
    if (D && D.has(y))
      return D.get(y);
    var v = { __proto__: null }, w = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var x in y)
      if (x !== "default" && Object.prototype.hasOwnProperty.call(y, x)) {
        var S = w ? Object.getOwnPropertyDescriptor(y, x) : null;
        S && (S.get || S.set) ? Object.defineProperty(v, x, S) : v[x] = y[x];
      }
    return v.default = y, D && D.set(y, v), v;
  }
  var s;
  function a(y) {
    return y ? (s != null || (s = new r.default.constructor({ enabled: !0, level: 1 })), s) : r.default;
  }
  var l = !1;
  function u(y) {
    return { gutter: y.grey, marker: y.red.bold, message: y.red.bold };
  }
  var h = /\r\n|[\n\r\u2028\u2029]/;
  function p(y, O, D) {
    let v = Object.assign({ column: 0, line: -1 }, y.start), w = Object.assign({}, v, y.end), { linesAbove: x = 2, linesBelow: S = 3 } = D || {}, k = v.line, C = v.column, A = w.line, P = w.column, I = Math.max(k - (x + 1), 0), B = Math.min(O.length, A + S);
    k === -1 && (I = 0), A === -1 && (B = O.length);
    let _ = A - k, R = {};
    if (_)
      for (let G = 0; G <= _; G++) {
        let J = G + k;
        if (!C)
          R[J] = !0;
        else if (G === 0) {
          let Q = O[J - 1].length;
          R[J] = [C, Q - C + 1];
        } else if (G === _)
          R[J] = [0, P];
        else {
          let Q = O[J - G].length;
          R[J] = [0, Q];
        }
      }
    else
      C === P ? C ? R[k] = [C, 0] : R[k] = !0 : R[k] = [C, P - C];
    return { start: I, end: B, markerLines: R };
  }
  function d(y, O, D = {}) {
    let v = (D.highlightCode || D.forceColor) && (0, e.shouldHighlight)(D), w = a(D.forceColor), x = u(w), S = (R, G) => v ? R(G) : G, k = y.split(h), { start: C, end: A, markerLines: P } = p(O, k, D), I = O.start && typeof O.start.column == "number", B = String(A).length, _ = (v ? (0, e.default)(y, D) : y).split(h, A).slice(C, A).map((R, G) => {
      let J = C + 1 + G, Q = ` ${` ${J}`.slice(-B)} |`, q = P[J], X = !P[J + 1];
      if (q) {
        let K = "";
        if (Array.isArray(q)) {
          let ye = R.slice(0, Math.max(q[0] - 1, 0)).replace(/[^\t]/g, " "), Ce = q[1] || 1;
          K = [`
 `, S(x.gutter, Q.replace(/\d/g, " ")), " ", ye, S(x.marker, "^").repeat(Ce)].join(""), X && D.message && (K += " " + S(x.message, D.message));
        }
        return [S(x.marker, ">"), S(x.gutter, Q), R.length > 0 ? ` ${R}` : "", K].join("");
      } else
        return ` ${S(x.gutter, Q)}${R.length > 0 ? ` ${R}` : ""}`;
    }).join(`
`);
    return D.message && !I && (_ = `${" ".repeat(B + 1)}${D.message}
${_}`), v ? w.reset(_) : _;
  }
  function m(y, O, D, v = {}) {
    if (!l) {
      l = !0;
      let w = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      {
        let x = new Error(w);
        x.name = "DeprecationWarning", console.warn(new Error(w));
      }
    }
    return D = Math.max(D, 0), d(y, { start: { column: D, line: O } }, v);
  }
}), kx = {};
Uc(kx, { __debug: () => FF, check: () => TF, doc: () => pD, format: () => mD, formatWithCursor: () => fD, getSupportInfo: () => PF, util: () => dD, version: () => sF });
var Nk = (t, e, r, i) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, i) : r.global ? e.replace(r, i) : e.split(r).join(i);
}, zc = Nk, _k = ml($k(), 1);
function Mk(t) {
  let e = t.indexOf("\r");
  return e >= 0 ? t.charAt(e + 1) === `
` ? "crlf" : "cr" : "lf";
}
function Hf(t) {
  switch (t) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function Tx(t, e) {
  let r;
  switch (e) {
    case `
`:
      r = /\n/g;
      break;
    case "\r":
      r = /\r/g;
      break;
    case `\r
`:
      r = /\r\n/g;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(e)}.`);
  }
  let i = t.match(r);
  return i ? i.length : 0;
}
function Lk(t) {
  return zc(!1, t, /\r\n?/g, `
`);
}
var As = "string", $n = "array", ks = "cursor", Ki = "indent", en = "align", tn = "trim", sr = "group", Mr = "fill", br = "if-break", rn = "indent-if-break", nn = "line-suffix", sn = "line-suffix-boundary", It = "line", Bi = "label", Lr = "break-parent", Px = /* @__PURE__ */ new Set([ks, Ki, en, tn, sr, Mr, br, rn, nn, sn, It, Bi, Lr]);
function Qk(t) {
  if (typeof t == "string")
    return As;
  if (Array.isArray(t))
    return $n;
  if (!t)
    return;
  let { type: e } = t;
  if (Px.has(e))
    return e;
}
var Ts = Qk, jk = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function Rk(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (Ts(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let i = jk([...Px].map((n) => `'${n}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${i}.`;
}
var Zk = class extends Error {
  constructor(r) {
    super(Rk(r));
    Ur(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, Da = Zk, Ny = {};
function Wk(t, e, r, i) {
  let n = [t];
  for (; n.length > 0; ) {
    let s = n.pop();
    if (s === Ny) {
      r(n.pop());
      continue;
    }
    r && n.push(s, Ny);
    let a = Ts(s);
    if (!a)
      throw new Da(s);
    if ((e == null ? void 0 : e(s)) !== !1)
      switch (a) {
        case $n:
        case Mr: {
          let l = a === $n ? s : s.parts;
          for (let u = l.length, h = u - 1; h >= 0; --h)
            n.push(l[h]);
          break;
        }
        case br:
          n.push(s.flatContents, s.breakContents);
          break;
        case sr:
          if (i && s.expandedStates)
            for (let l = s.expandedStates.length, u = l - 1; u >= 0; --u)
              n.push(s.expandedStates[u]);
          else
            n.push(s.contents);
          break;
        case en:
        case Ki:
        case rn:
        case Bi:
        case nn:
          n.push(s.contents);
          break;
        case As:
        case ks:
        case tn:
        case sn:
        case It:
        case Lr:
          break;
        default:
          throw new Da(s);
      }
  }
}
var Jf = Wk, qk = () => {
}, Xk = qk;
function sc(t) {
  return { type: Ki, contents: t };
}
function ba(t, e) {
  return { type: en, contents: e, n: t };
}
function Fx(t, e = {}) {
  return Xk(e.expandedStates), { type: sr, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function Vk(t) {
  return ba(Number.NEGATIVE_INFINITY, t);
}
function Uk(t) {
  return ba({ type: "root" }, t);
}
function Yk(t) {
  return ba(-1, t);
}
function zk(t, e) {
  return Fx(t[0], { ...e, expandedStates: t });
}
function $x(t) {
  return { type: Mr, parts: t };
}
function Gk(t, e = "", r = {}) {
  return { type: br, breakContents: t, flatContents: e, groupId: r.groupId };
}
function Hk(t, e) {
  return { type: rn, contents: t, groupId: e.groupId, negate: e.negate };
}
function hd(t) {
  return { type: nn, contents: t };
}
var Jk = { type: sn }, Gc = { type: Lr }, Kk = { type: tn }, Kf = { type: It, hard: !0 }, Bx = { type: It, hard: !0, literal: !0 }, Ix = { type: It }, eT = { type: It, soft: !0 }, hs = [Kf, Gc], Nx = [Bx, Gc], pd = { type: ks };
function _x(t, e) {
  let r = [];
  for (let i = 0; i < e.length; i++)
    i !== 0 && r.push(t), r.push(e[i]);
  return r;
}
function Mx(t, e, r) {
  let i = t;
  if (e > 0) {
    for (let n = 0; n < Math.floor(e / r); ++n)
      i = sc(i);
    i = ba(e % r, i), i = ba(Number.NEGATIVE_INFINITY, i);
  }
  return i;
}
function tT(t, e) {
  return t ? { type: Bi, label: t, contents: e } : e;
}
function Wi(t) {
  var e;
  if (!t)
    return "";
  if (Array.isArray(t)) {
    let r = [];
    for (let i of t)
      if (Array.isArray(i))
        r.push(...Wi(i));
      else {
        let n = Wi(i);
        n !== "" && r.push(n);
      }
    return r;
  }
  return t.type === br ? { ...t, breakContents: Wi(t.breakContents), flatContents: Wi(t.flatContents) } : t.type === sr ? { ...t, contents: Wi(t.contents), expandedStates: (e = t.expandedStates) == null ? void 0 : e.map(Wi) } : t.type === Mr ? { type: "fill", parts: t.parts.map(Wi) } : t.contents ? { ...t, contents: Wi(t.contents) } : t;
}
function rT(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Set();
  return i(Wi(t));
  function i(s, a, l) {
    var u, h;
    if (typeof s == "string")
      return JSON.stringify(s);
    if (Array.isArray(s)) {
      let p = s.map(i).filter(Boolean);
      return p.length === 1 ? p[0] : `[${p.join(", ")}]`;
    }
    if (s.type === It) {
      let p = ((u = l == null ? void 0 : l[a + 1]) == null ? void 0 : u.type) === Lr;
      return s.literal ? p ? "literalline" : "literallineWithoutBreakParent" : s.hard ? p ? "hardline" : "hardlineWithoutBreakParent" : s.soft ? "softline" : "line";
    }
    if (s.type === Lr)
      return ((h = l == null ? void 0 : l[a - 1]) == null ? void 0 : h.type) === It && l[a - 1].hard ? void 0 : "breakParent";
    if (s.type === tn)
      return "trim";
    if (s.type === Ki)
      return "indent(" + i(s.contents) + ")";
    if (s.type === en)
      return s.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + i(s.contents) + ")" : s.n < 0 ? "dedent(" + i(s.contents) + ")" : s.n.type === "root" ? "markAsRoot(" + i(s.contents) + ")" : "align(" + JSON.stringify(s.n) + ", " + i(s.contents) + ")";
    if (s.type === br)
      return "ifBreak(" + i(s.breakContents) + (s.flatContents ? ", " + i(s.flatContents) : "") + (s.groupId ? (s.flatContents ? "" : ', ""') + `, { groupId: ${n(s.groupId)} }` : "") + ")";
    if (s.type === rn) {
      let p = [];
      s.negate && p.push("negate: true"), s.groupId && p.push(`groupId: ${n(s.groupId)}`);
      let d = p.length > 0 ? `, { ${p.join(", ")} }` : "";
      return `indentIfBreak(${i(s.contents)}${d})`;
    }
    if (s.type === sr) {
      let p = [];
      s.break && s.break !== "propagated" && p.push("shouldBreak: true"), s.id && p.push(`id: ${n(s.id)}`);
      let d = p.length > 0 ? `, { ${p.join(", ")} }` : "";
      return s.expandedStates ? `conditionalGroup([${s.expandedStates.map((m) => i(m)).join(",")}]${d})` : `group(${i(s.contents)}${d})`;
    }
    if (s.type === Mr)
      return `fill([${s.parts.map((p) => i(p)).join(", ")}])`;
    if (s.type === nn)
      return "lineSuffix(" + i(s.contents) + ")";
    if (s.type === sn)
      return "lineSuffixBoundary";
    if (s.type === Bi)
      return `label(${JSON.stringify(s.label)}, ${i(s.contents)})`;
    throw new Error("Unknown doc type " + s.type);
  }
  function n(s) {
    if (typeof s != "symbol")
      return JSON.stringify(String(s));
    if (s in e)
      return e[s];
    let a = s.description || "symbol";
    for (let l = 0; ; l++) {
      let u = a + (l > 0 ? ` #${l}` : "");
      if (!r.has(u))
        return r.add(u), e[s] = `Symbol.for(${JSON.stringify(u)})`;
    }
  }
}
var iT = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, Dt = iT, nT = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function sT(t) {
  return t === 12288 || t >= 65281 && t <= 65376 || t >= 65504 && t <= 65510;
}
function aT(t) {
  return t >= 4352 && t <= 4447 || t === 8986 || t === 8987 || t === 9001 || t === 9002 || t >= 9193 && t <= 9196 || t === 9200 || t === 9203 || t === 9725 || t === 9726 || t === 9748 || t === 9749 || t >= 9800 && t <= 9811 || t === 9855 || t === 9875 || t === 9889 || t === 9898 || t === 9899 || t === 9917 || t === 9918 || t === 9924 || t === 9925 || t === 9934 || t === 9940 || t === 9962 || t === 9970 || t === 9971 || t === 9973 || t === 9978 || t === 9981 || t === 9989 || t === 9994 || t === 9995 || t === 10024 || t === 10060 || t === 10062 || t >= 10067 && t <= 10069 || t === 10071 || t >= 10133 && t <= 10135 || t === 10160 || t === 10175 || t === 11035 || t === 11036 || t === 11088 || t === 11093 || t >= 11904 && t <= 11929 || t >= 11931 && t <= 12019 || t >= 12032 && t <= 12245 || t >= 12272 && t <= 12287 || t >= 12289 && t <= 12350 || t >= 12353 && t <= 12438 || t >= 12441 && t <= 12543 || t >= 12549 && t <= 12591 || t >= 12593 && t <= 12686 || t >= 12688 && t <= 12771 || t >= 12783 && t <= 12830 || t >= 12832 && t <= 12871 || t >= 12880 && t <= 19903 || t >= 19968 && t <= 42124 || t >= 42128 && t <= 42182 || t >= 43360 && t <= 43388 || t >= 44032 && t <= 55203 || t >= 63744 && t <= 64255 || t >= 65040 && t <= 65049 || t >= 65072 && t <= 65106 || t >= 65108 && t <= 65126 || t >= 65128 && t <= 65131 || t >= 94176 && t <= 94180 || t === 94192 || t === 94193 || t >= 94208 && t <= 100343 || t >= 100352 && t <= 101589 || t >= 101632 && t <= 101640 || t >= 110576 && t <= 110579 || t >= 110581 && t <= 110587 || t === 110589 || t === 110590 || t >= 110592 && t <= 110882 || t === 110898 || t >= 110928 && t <= 110930 || t === 110933 || t >= 110948 && t <= 110951 || t >= 110960 && t <= 111355 || t === 126980 || t === 127183 || t === 127374 || t >= 127377 && t <= 127386 || t >= 127488 && t <= 127490 || t >= 127504 && t <= 127547 || t >= 127552 && t <= 127560 || t === 127568 || t === 127569 || t >= 127584 && t <= 127589 || t >= 127744 && t <= 127776 || t >= 127789 && t <= 127797 || t >= 127799 && t <= 127868 || t >= 127870 && t <= 127891 || t >= 127904 && t <= 127946 || t >= 127951 && t <= 127955 || t >= 127968 && t <= 127984 || t === 127988 || t >= 127992 && t <= 128062 || t === 128064 || t >= 128066 && t <= 128252 || t >= 128255 && t <= 128317 || t >= 128331 && t <= 128334 || t >= 128336 && t <= 128359 || t === 128378 || t === 128405 || t === 128406 || t === 128420 || t >= 128507 && t <= 128591 || t >= 128640 && t <= 128709 || t === 128716 || t >= 128720 && t <= 128722 || t >= 128725 && t <= 128727 || t >= 128732 && t <= 128735 || t === 128747 || t === 128748 || t >= 128756 && t <= 128764 || t >= 128992 && t <= 129003 || t === 129008 || t >= 129292 && t <= 129338 || t >= 129340 && t <= 129349 || t >= 129351 && t <= 129535 || t >= 129648 && t <= 129660 || t >= 129664 && t <= 129672 || t >= 129680 && t <= 129725 || t >= 129727 && t <= 129733 || t >= 129742 && t <= 129755 || t >= 129760 && t <= 129768 || t >= 129776 && t <= 129784 || t >= 131072 && t <= 196605 || t >= 196608 && t <= 262141;
}
var oT = (t) => !(sT(t) || aT(t)), lT = /[^\x20-\x7F]/;
function uT(t) {
  if (!t)
    return 0;
  if (!lT.test(t))
    return t.length;
  t = t.replace(nT(), "  ");
  let e = 0;
  for (let r of t) {
    let i = r.codePointAt(0);
    i <= 31 || i >= 127 && i <= 159 || i >= 768 && i <= 879 || (e += oT(i) ? 1 : 2);
  }
  return e;
}
var em = uT, cT = (t) => {
  if (Array.isArray(t))
    return t;
  if (t.type !== Mr)
    throw new Error(`Expect doc to be 'array' or '${Mr}'.`);
  return t.parts;
};
function Hc(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return i(t);
  function i(s) {
    if (r.has(s))
      return r.get(s);
    let a = n(s);
    return r.set(s, a), a;
  }
  function n(s) {
    switch (Ts(s)) {
      case $n:
        return e(s.map(i));
      case Mr:
        return e({ ...s, parts: s.parts.map(i) });
      case br:
        return e({ ...s, breakContents: i(s.breakContents), flatContents: i(s.flatContents) });
      case sr: {
        let { expandedStates: a, contents: l } = s;
        return a ? (a = a.map(i), l = a[0]) : l = i(l), e({ ...s, contents: l, expandedStates: a });
      }
      case en:
      case Ki:
      case rn:
      case Bi:
      case nn:
        return e({ ...s, contents: i(s.contents) });
      case As:
      case ks:
      case tn:
      case sn:
      case It:
      case Lr:
        return e(s);
      default:
        throw new Da(s);
    }
  }
}
function tm(t, e, r) {
  let i = r, n = !1;
  function s(a) {
    if (n)
      return !1;
    let l = e(a);
    l !== void 0 && (n = !0, i = l);
  }
  return Jf(t, s), i;
}
function hT(t) {
  if (t.type === sr && t.break || t.type === It && t.hard || t.type === Lr)
    return !0;
}
function pT(t) {
  return tm(t, hT, !1);
}
function _y(t) {
  if (t.length > 0) {
    let e = Dt(!1, t, -1);
    !e.expandedStates && !e.break && (e.break = "propagated");
  }
  return null;
}
function dT(t) {
  let e = /* @__PURE__ */ new Set(), r = [];
  function i(s) {
    if (s.type === Lr && _y(r), s.type === sr) {
      if (r.push(s), e.has(s))
        return !1;
      e.add(s);
    }
  }
  function n(s) {
    s.type === sr && r.pop().break && _y(r);
  }
  Jf(t, i, n, !0);
}
function fT(t) {
  return t.type === It && !t.hard ? t.soft ? "" : " " : t.type === br ? t.flatContents : t;
}
function mT(t) {
  return Hc(t, fT);
}
function My(t) {
  for (t = [...t]; t.length >= 2 && Dt(!1, t, -2).type === It && Dt(!1, t, -1).type === Lr; )
    t.length -= 2;
  if (t.length > 0) {
    let e = To(Dt(!1, t, -1));
    t[t.length - 1] = e;
  }
  return t;
}
function To(t) {
  switch (Ts(t)) {
    case en:
    case Ki:
    case rn:
    case sr:
    case nn:
    case Bi: {
      let e = To(t.contents);
      return { ...t, contents: e };
    }
    case br:
      return { ...t, breakContents: To(t.breakContents), flatContents: To(t.flatContents) };
    case Mr:
      return { ...t, parts: My(t.parts) };
    case $n:
      return My(t);
    case As:
      return t.replace(/[\n\r]*$/, "");
    case ks:
    case tn:
    case sn:
    case It:
    case Lr:
      break;
    default:
      throw new Da(t);
  }
  return t;
}
function Lx(t) {
  return To(yT(t));
}
function gT(t) {
  switch (Ts(t)) {
    case Mr:
      if (t.parts.every((e) => e === ""))
        return "";
      break;
    case sr:
      if (!t.contents && !t.id && !t.break && !t.expandedStates)
        return "";
      if (t.contents.type === sr && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates)
        return t.contents;
      break;
    case en:
    case Ki:
    case rn:
    case nn:
      if (!t.contents)
        return "";
      break;
    case br:
      if (!t.flatContents && !t.breakContents)
        return "";
      break;
    case $n: {
      let e = [];
      for (let r of t) {
        if (!r)
          continue;
        let [i, ...n] = Array.isArray(r) ? r : [r];
        typeof i == "string" && typeof Dt(!1, e, -1) == "string" ? e[e.length - 1] += i : e.push(i), e.push(...n);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case As:
    case ks:
    case tn:
    case sn:
    case It:
    case Bi:
    case Lr:
      break;
    default:
      throw new Da(t);
  }
  return t;
}
function yT(t) {
  return Hc(t, (e) => gT(e));
}
function OT(t, e = Nx) {
  return Hc(t, (r) => typeof r == "string" ? _x(e, r.split(`
`)) : r);
}
function xT(t) {
  if (t.type === It)
    return !0;
}
function DT(t) {
  return tm(t, xT, !1);
}
function Qx(t, e) {
  return t.type === Bi ? { ...t, contents: e(t.contents) } : e(t);
}
var er = Symbol("MODE_BREAK"), mi = Symbol("MODE_FLAT"), Po = Symbol("cursor");
function jx() {
  return { value: "", length: 0, queue: [] };
}
function bT(t, e) {
  return dd(t, { type: "indent" }, e);
}
function vT(t, e, r) {
  return e === Number.NEGATIVE_INFINITY ? t.root || jx() : e < 0 ? dd(t, { type: "dedent" }, r) : e ? e.type === "root" ? { ...t, root: t } : dd(t, { type: typeof e == "string" ? "stringAlign" : "numberAlign", n: e }, r) : t;
}
function dd(t, e, r) {
  let i = e.type === "dedent" ? t.queue.slice(0, -1) : [...t.queue, e], n = "", s = 0, a = 0, l = 0;
  for (let O of i)
    switch (O.type) {
      case "indent":
        p(), r.useTabs ? u(1) : h(r.tabWidth);
        break;
      case "stringAlign":
        p(), n += O.n, s += O.n.length;
        break;
      case "numberAlign":
        a += 1, l += O.n;
        break;
      default:
        throw new Error(`Unexpected type '${O.type}'`);
    }
  return m(), { ...t, value: n, length: s, queue: i };
  function u(O) {
    n += "	".repeat(O), s += r.tabWidth * O;
  }
  function h(O) {
    n += " ".repeat(O), s += O;
  }
  function p() {
    r.useTabs ? d() : m();
  }
  function d() {
    a > 0 && u(a), y();
  }
  function m() {
    l > 0 && h(l), y();
  }
  function y() {
    a = 0, l = 0;
  }
}
function fd(t) {
  let e = 0, r = 0, i = t.length;
  e:
    for (; i--; ) {
      let n = t[i];
      if (n === Po) {
        r++;
        continue;
      }
      for (let s = n.length - 1; s >= 0; s--) {
        let a = n[s];
        if (a === " " || a === "	")
          e++;
        else {
          t[i] = n.slice(0, s + 1);
          break e;
        }
      }
    }
  if (e > 0 || r > 0)
    for (t.length = i + 1; r-- > 0; )
      t.push(Po);
  return e;
}
function eu(t, e, r, i, n, s) {
  if (r === Number.POSITIVE_INFINITY)
    return !0;
  let a = e.length, l = [t], u = [];
  for (; r >= 0; ) {
    if (l.length === 0) {
      if (a === 0)
        return !0;
      l.push(e[--a]);
      continue;
    }
    let { mode: h, doc: p } = l.pop();
    switch (Ts(p)) {
      case As:
        u.push(p), r -= em(p);
        break;
      case $n:
      case Mr: {
        let d = cT(p);
        for (let m = d.length - 1; m >= 0; m--)
          l.push({ mode: h, doc: d[m] });
        break;
      }
      case Ki:
      case en:
      case rn:
      case Bi:
        l.push({ mode: h, doc: p.contents });
        break;
      case tn:
        r += fd(u);
        break;
      case sr: {
        if (s && p.break)
          return !1;
        let d = p.break ? er : h, m = p.expandedStates && d === er ? Dt(!1, p.expandedStates, -1) : p.contents;
        l.push({ mode: d, doc: m });
        break;
      }
      case br: {
        let d = (p.groupId ? n[p.groupId] || mi : h) === er ? p.breakContents : p.flatContents;
        d && l.push({ mode: h, doc: d });
        break;
      }
      case It:
        if (h === er || p.hard)
          return !0;
        p.soft || (u.push(" "), r--);
        break;
      case nn:
        i = !0;
        break;
      case sn:
        if (i)
          return !1;
        break;
    }
  }
  return !1;
}
function Jc(t, e) {
  let r = {}, i = e.printWidth, n = Hf(e.endOfLine), s = 0, a = [{ ind: jx(), mode: er, doc: t }], l = [], u = !1, h = [], p = 0;
  for (dT(t); a.length > 0; ) {
    let { ind: m, mode: y, doc: O } = a.pop();
    switch (Ts(O)) {
      case As: {
        let D = n !== `
` ? zc(!1, O, `
`, n) : O;
        l.push(D), a.length > 0 && (s += em(D));
        break;
      }
      case $n:
        for (let D = O.length - 1; D >= 0; D--)
          a.push({ ind: m, mode: y, doc: O[D] });
        break;
      case ks:
        if (p >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        l.push(Po), p++;
        break;
      case Ki:
        a.push({ ind: bT(m, e), mode: y, doc: O.contents });
        break;
      case en:
        a.push({ ind: vT(m, O.n, e), mode: y, doc: O.contents });
        break;
      case tn:
        s -= fd(l);
        break;
      case sr:
        switch (y) {
          case mi:
            if (!u) {
              a.push({ ind: m, mode: O.break ? er : mi, doc: O.contents });
              break;
            }
          case er: {
            u = !1;
            let D = { ind: m, mode: mi, doc: O.contents }, v = i - s, w = h.length > 0;
            if (!O.break && eu(D, a, v, w, r))
              a.push(D);
            else if (O.expandedStates) {
              let x = Dt(!1, O.expandedStates, -1);
              if (O.break) {
                a.push({ ind: m, mode: er, doc: x });
                break;
              } else
                for (let S = 1; S < O.expandedStates.length + 1; S++)
                  if (S >= O.expandedStates.length) {
                    a.push({ ind: m, mode: er, doc: x });
                    break;
                  } else {
                    let k = O.expandedStates[S], C = { ind: m, mode: mi, doc: k };
                    if (eu(C, a, v, w, r)) {
                      a.push(C);
                      break;
                    }
                  }
            } else
              a.push({ ind: m, mode: er, doc: O.contents });
            break;
          }
        }
        O.id && (r[O.id] = Dt(!1, a, -1).mode);
        break;
      case Mr: {
        let D = i - s, { parts: v } = O;
        if (v.length === 0)
          break;
        let [w, x] = v, S = { ind: m, mode: mi, doc: w }, k = { ind: m, mode: er, doc: w }, C = eu(S, [], D, h.length > 0, r, !0);
        if (v.length === 1) {
          C ? a.push(S) : a.push(k);
          break;
        }
        let A = { ind: m, mode: mi, doc: x }, P = { ind: m, mode: er, doc: x };
        if (v.length === 2) {
          C ? a.push(A, S) : a.push(P, k);
          break;
        }
        v.splice(0, 2);
        let I = { ind: m, mode: y, doc: $x(v) }, B = v[0];
        eu({ ind: m, mode: mi, doc: [w, x, B] }, [], D, h.length > 0, r, !0) ? a.push(I, A, S) : C ? a.push(I, P, S) : a.push(I, P, k);
        break;
      }
      case br:
      case rn: {
        let D = O.groupId ? r[O.groupId] : y;
        if (D === er) {
          let v = O.type === br ? O.breakContents : O.negate ? O.contents : sc(O.contents);
          v && a.push({ ind: m, mode: y, doc: v });
        }
        if (D === mi) {
          let v = O.type === br ? O.flatContents : O.negate ? sc(O.contents) : O.contents;
          v && a.push({ ind: m, mode: y, doc: v });
        }
        break;
      }
      case nn:
        h.push({ ind: m, mode: y, doc: O.contents });
        break;
      case sn:
        h.length > 0 && a.push({ ind: m, mode: y, doc: Kf });
        break;
      case It:
        switch (y) {
          case mi:
            if (O.hard)
              u = !0;
            else {
              O.soft || (l.push(" "), s += 1);
              break;
            }
          case er:
            if (h.length > 0) {
              a.push({ ind: m, mode: y, doc: O }, ...h.reverse()), h.length = 0;
              break;
            }
            O.literal ? m.root ? (l.push(n, m.root.value), s = m.root.length) : (l.push(n), s = 0) : (s -= fd(l), l.push(n + m.value), s = m.length);
            break;
        }
        break;
      case Bi:
        a.push({ ind: m, mode: y, doc: O.contents });
        break;
      case Lr:
        break;
      default:
        throw new Da(O);
    }
    a.length === 0 && h.length > 0 && (a.push(...h.reverse()), h.length = 0);
  }
  let d = l.indexOf(Po);
  if (d !== -1) {
    let m = l.indexOf(Po, d + 1), y = l.slice(0, d).join(""), O = l.slice(d + 1, m).join(""), D = l.slice(m + 1).join("");
    return { formatted: y + O + D, cursorNodeStart: y.length, cursorNodeText: O };
  }
  return { formatted: l.join("") };
}
function wT(t, e, r = 0) {
  let i = 0;
  for (let n = r; n < t.length; ++n)
    t[n] === "	" ? i = i + e - i % e : i++;
  return i;
}
var rm = wT, Lu, md, xo, Qu, ST = class {
  constructor(e) {
    Iy(this, Lu), Iy(this, xo), this.stack = [e];
  }
  get key() {
    let { stack: e, siblings: r } = this;
    return Dt(!1, e, r === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : Dt(!1, this.stack, -2);
  }
  get node() {
    return Dt(!1, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: e } = this, r = Dt(!1, e, -3);
    return Array.isArray(r) ? r : null;
  }
  get next() {
    let { siblings: e } = this;
    return e === null ? null : e[this.index + 1];
  }
  get previous() {
    let { siblings: e } = this;
    return e === null ? null : e[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: e, index: r } = this;
    return e !== null && r === e.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...ro(this, xo, Qu).call(this)];
  }
  getName() {
    let { stack: e } = this, { length: r } = e;
    return r > 1 ? Dt(!1, e, -2) : null;
  }
  getValue() {
    return Dt(!1, this.stack, -1);
  }
  getNode(e = 0) {
    let r = ro(this, Lu, md).call(this, e);
    return r === -1 ? null : this.stack[r];
  }
  getParentNode(e = 0) {
    return this.getNode(e + 1);
  }
  call(e, ...r) {
    let { stack: i } = this, { length: n } = i, s = Dt(!1, i, -1);
    for (let a of r)
      s = s[a], i.push(a, s);
    try {
      return e(this);
    } finally {
      i.length = n;
    }
  }
  callParent(e, r = 0) {
    let i = ro(this, Lu, md).call(this, r + 1), n = this.stack.splice(i + 1);
    try {
      return e(this);
    } finally {
      this.stack.push(...n);
    }
  }
  each(e, ...r) {
    let { stack: i } = this, { length: n } = i, s = Dt(!1, i, -1);
    for (let a of r)
      s = s[a], i.push(a, s);
    try {
      for (let a = 0; a < s.length; ++a)
        i.push(a, s[a]), e(this, a, s), i.length -= 2;
    } finally {
      i.length = n;
    }
  }
  map(e, ...r) {
    let i = [];
    return this.each((n, s, a) => {
      i[s] = e(n, s, a);
    }, ...r), i;
  }
  match(...e) {
    let r = this.stack.length - 1, i = null, n = this.stack[r--];
    for (let s of e) {
      if (n === void 0)
        return !1;
      let a = null;
      if (typeof i == "number" && (a = i, i = this.stack[r--], n = this.stack[r--]), s && !s(n, i, a))
        return !1;
      i = this.stack[r--], n = this.stack[r--];
    }
    return !0;
  }
  findAncestor(e) {
    for (let r of ro(this, xo, Qu).call(this))
      if (e(r))
        return r;
  }
  hasAncestor(e) {
    for (let r of ro(this, xo, Qu).call(this))
      if (e(r))
        return !0;
    return !1;
  }
};
Lu = /* @__PURE__ */ new WeakSet(), md = function(t) {
  let { stack: e } = this;
  for (let r = e.length - 1; r >= 0; r -= 2)
    if (!Array.isArray(e[r]) && --t < 0)
      return r;
  return -1;
}, xo = /* @__PURE__ */ new WeakSet(), Qu = function* () {
  let { stack: t } = this;
  for (let e = t.length - 3; e >= 0; e -= 2) {
    let r = t[e];
    Array.isArray(r) || (yield r);
  }
};
var CT = ST, Rx = new Proxy(() => {
}, { get: () => Rx }), gd = Rx;
function ET(t) {
  return t !== null && typeof t == "object";
}
var AT = ET;
function* Zx(t, e) {
  let { getVisitorKeys: r, filter: i = () => !0 } = e, n = (s) => AT(s) && i(s);
  for (let s of r(t)) {
    let a = t[s];
    if (Array.isArray(a))
      for (let l of a)
        n(l) && (yield l);
    else
      n(a) && (yield a);
  }
}
function* kT(t, e) {
  let r = [t];
  for (let i = 0; i < r.length; i++) {
    let n = r[i];
    for (let s of Zx(n, e))
      yield s, r.push(s);
  }
}
function gl(t) {
  return (e, r, i) => {
    let n = !!(i != null && i.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, a = r;
    for (; a >= 0 && a < s; ) {
      let l = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(l))
          return a;
      } else if (!t.includes(l))
        return a;
      n ? a-- : a++;
    }
    return a === -1 || a === s ? a : !1;
  };
}
var TT = gl(/\s/), Bn = gl(" 	"), Wx = gl(",; 	"), qx = gl(/[^\n\r]/);
function PT(t, e, r) {
  let i = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let n = t.charAt(e);
  if (i) {
    if (t.charAt(e - 1) === "\r" && n === `
`)
      return e - 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e - 1;
  } else {
    if (n === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e + 1;
  }
  return e;
}
var fs = PT;
function FT(t, e, r = {}) {
  let i = Bn(t, r.backwards ? e - 1 : e, r), n = fs(t, i, r);
  return i !== n;
}
var kn = FT;
function $T(t) {
  return Array.isArray(t) && t.length > 0;
}
var BT = $T, Xx = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]), IT = (t) => Object.keys(t).filter((e) => !Xx.has(e));
function NT(t) {
  return t ? (e) => t(e, Xx) : IT;
}
var Kc = NT;
function _T(t) {
  let e = t.type || t.kind || "(unknown type)", r = String(t.name || t.id && (typeof t.id == "object" ? t.id.name : t.id) || t.key && (typeof t.key == "object" ? t.key.name : t.key) || t.value && (typeof t.value == "object" ? "" : String(t.value)) || t.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + "…"), e + (r ? " " + r : "");
}
function im(t, e) {
  (t.comments ?? (t.comments = [])).push(e), e.printed = !1, e.nodeDescription = _T(t);
}
function sa(t, e) {
  e.leading = !0, e.trailing = !1, im(t, e);
}
function es(t, e, r) {
  e.leading = !1, e.trailing = !1, r && (e.marker = r), im(t, e);
}
function aa(t, e) {
  e.leading = !1, e.trailing = !0, im(t, e);
}
var ap = /* @__PURE__ */ new WeakMap();
function nm(t, e) {
  if (ap.has(t))
    return ap.get(t);
  let { printer: { getCommentChildNodes: r, canAttachComment: i, getVisitorKeys: n }, locStart: s, locEnd: a } = e;
  if (!i)
    return [];
  let l = ((r == null ? void 0 : r(t, e)) ?? [...Zx(t, { getVisitorKeys: Kc(n) })]).flatMap((u) => i(u) ? [u] : nm(u, e));
  return l.sort((u, h) => s(u) - s(h) || a(u) - a(h)), ap.set(t, l), l;
}
function Vx(t, e, r, i) {
  let { locStart: n, locEnd: s } = r, a = n(e), l = s(e), u = nm(t, r), h, p, d = 0, m = u.length;
  for (; d < m; ) {
    let y = d + m >> 1, O = u[y], D = n(O), v = s(O);
    if (D <= a && l <= v)
      return Vx(O, e, r, O);
    if (v <= a) {
      h = O, d = y + 1;
      continue;
    }
    if (l <= D) {
      p = O, m = y;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((i == null ? void 0 : i.type) === "TemplateLiteral") {
    let { quasis: y } = i, O = lp(y, e, r);
    h && lp(y, h, r) !== O && (h = null), p && lp(y, p, r) !== O && (p = null);
  }
  return { enclosingNode: i, precedingNode: h, followingNode: p };
}
var op = () => !1;
function MT(t, e) {
  let { comments: r } = t;
  if (delete t.comments, !BT(r) || !e.printer.canAttachComment)
    return;
  let i = [], { locStart: n, locEnd: s, printer: { experimentalFeatures: { avoidAstMutation: a = !1 } = {}, handleComments: l = {} }, originalText: u } = e, { ownLine: h = op, endOfLine: p = op, remaining: d = op } = l, m = r.map((y, O) => ({ ...Vx(t, y, e), comment: y, text: u, options: e, ast: t, isLastComment: r.length - 1 === O }));
  for (let [y, O] of m.entries()) {
    let { comment: D, precedingNode: v, enclosingNode: w, followingNode: x, text: S, options: k, ast: C, isLastComment: A } = O;
    if (k.parser === "json" || k.parser === "json5" || k.parser === "jsonc" || k.parser === "__js_expression" || k.parser === "__ts_expression" || k.parser === "__vue_expression" || k.parser === "__vue_ts_expression") {
      if (n(D) - n(C) <= 0) {
        sa(C, D);
        continue;
      }
      if (s(D) - s(C) >= 0) {
        aa(C, D);
        continue;
      }
    }
    let P;
    if (a ? P = [O] : (D.enclosingNode = w, D.precedingNode = v, D.followingNode = x, P = [D, S, k, C, A]), LT(S, k, m, y))
      D.placement = "ownLine", h(...P) || (x ? sa(x, D) : v ? aa(v, D) : es(w || C, D));
    else if (QT(S, k, m, y))
      D.placement = "endOfLine", p(...P) || (v ? aa(v, D) : x ? sa(x, D) : es(w || C, D));
    else if (D.placement = "remaining", !d(...P))
      if (v && x) {
        let I = i.length;
        I > 0 && i[I - 1].followingNode !== x && Ly(i, k), i.push(O);
      } else
        v ? aa(v, D) : x ? sa(x, D) : es(w || C, D);
  }
  if (Ly(i, e), !a)
    for (let y of r)
      delete y.precedingNode, delete y.enclosingNode, delete y.followingNode;
}
var Ux = (t) => !/[\S\n\u2028\u2029]/.test(t);
function LT(t, e, r, i) {
  let { comment: n, precedingNode: s } = r[i], { locStart: a, locEnd: l } = e, u = a(n);
  if (s)
    for (let h = i - 1; h >= 0; h--) {
      let { comment: p, precedingNode: d } = r[h];
      if (d !== s || !Ux(t.slice(l(p), u)))
        break;
      u = a(p);
    }
  return kn(t, u, { backwards: !0 });
}
function QT(t, e, r, i) {
  let { comment: n, followingNode: s } = r[i], { locStart: a, locEnd: l } = e, u = l(n);
  if (s)
    for (let h = i + 1; h < r.length; h++) {
      let { comment: p, followingNode: d } = r[h];
      if (d !== s || !Ux(t.slice(u, a(p))))
        break;
      u = l(p);
    }
  return kn(t, u);
}
function Ly(t, e) {
  var r, i;
  let n = t.length;
  if (n === 0)
    return;
  let { precedingNode: s, followingNode: a } = t[0], l = e.locStart(a), u;
  for (u = n; u > 0; --u) {
    let { comment: h, precedingNode: p, followingNode: d } = t[u - 1];
    gd.strictEqual(p, s), gd.strictEqual(d, a);
    let m = e.originalText.slice(e.locEnd(h), l);
    if (((i = (r = e.printer).isGap) == null ? void 0 : i.call(r, m, e)) ?? /^[\s(]*$/.test(m))
      l = e.locStart(h);
    else
      break;
  }
  for (let [h, { comment: p }] of t.entries())
    h < u ? aa(s, p) : sa(a, p);
  for (let h of [s, a])
    h.comments && h.comments.length > 1 && h.comments.sort((p, d) => e.locStart(p) - e.locStart(d));
  t.length = 0;
}
function lp(t, e, r) {
  let i = r.locStart(e) - 1;
  for (let n = 1; n < t.length; ++n)
    if (i < r.locStart(t[n]))
      return n - 1;
  return 0;
}
function jT(t, e) {
  let r = e - 1;
  r = Bn(t, r, { backwards: !0 }), r = fs(t, r, { backwards: !0 }), r = Bn(t, r, { backwards: !0 });
  let i = fs(t, r, { backwards: !0 });
  return r !== i;
}
var sm = jT;
function Yx(t, e) {
  let r = t.node;
  return r.printed = !0, e.printer.printComment(t, e);
}
function RT(t, e) {
  var r;
  let i = t.node, n = [Yx(t, e)], { printer: s, originalText: a, locStart: l, locEnd: u } = e;
  if ((r = s.isBlockComment) != null && r.call(s, i)) {
    let p = kn(a, u(i)) ? kn(a, l(i), { backwards: !0 }) ? hs : Ix : " ";
    n.push(p);
  } else
    n.push(hs);
  let h = fs(a, Bn(a, u(i)));
  return h !== !1 && kn(a, h) && n.push(hs), n;
}
function ZT(t, e, r) {
  var i;
  let n = t.node, s = Yx(t, e), { printer: a, originalText: l, locStart: u } = e, h = (i = a.isBlockComment) == null ? void 0 : i.call(a, n);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || kn(l, u(n), { backwards: !0 })) {
    let p = sm(l, u(n));
    return { doc: hd([hs, p ? hs : "", s]), isBlock: h, hasLineSuffix: !0 };
  }
  return !h || r != null && r.hasLineSuffix ? { doc: [hd([" ", s]), Gc], isBlock: h, hasLineSuffix: !0 } : { doc: [" ", s], isBlock: h, hasLineSuffix: !1 };
}
function WT(t, e) {
  let r = t.node;
  if (!r)
    return {};
  let i = e[Symbol.for("printedComments")];
  if ((r.comments || []).filter((l) => !i.has(l)).length === 0)
    return { leading: "", trailing: "" };
  let n = [], s = [], a;
  return t.each(() => {
    let l = t.node;
    if (i != null && i.has(l))
      return;
    let { leading: u, trailing: h } = l;
    u ? n.push(RT(t, e)) : h && (a = ZT(t, e, a), s.push(a.doc));
  }, "comments"), { leading: n, trailing: s };
}
function qT(t, e, r) {
  let { leading: i, trailing: n } = WT(t, r);
  return !i && !n ? e : Qx(e, (s) => [i, s, n]);
}
function XT(t) {
  let { [Symbol.for("comments")]: e, [Symbol.for("printedComments")]: r } = t;
  for (let i of e) {
    if (!i.printed && !r.has(i))
      throw new Error('Comment "' + i.value.trim() + '" was not printed. Please report this error!');
    delete i.printed;
  }
}
var zx = class extends Error {
  constructor() {
    super(...arguments);
    Ur(this, "name", "ConfigError");
  }
}, Qy = class extends Error {
  constructor() {
    super(...arguments);
    Ur(this, "name", "UndefinedParserError");
  }
}, VT = { cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (t) => typeof t == "string" || typeof t == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }] }, plugins: { type: "path", array: !0, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (t) => typeof t == "string" || typeof t == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: !1, description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: !1, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function Gx({ plugins: t = [], showDeprecated: e = !1 } = {}) {
  let r = t.flatMap((n) => n.languages ?? []), i = [];
  for (let n of YT(Object.assign({}, ...t.map(({ options: s }) => s), VT)))
    !e && n.deprecated || (Array.isArray(n.choices) && (e || (n.choices = n.choices.filter((s) => !s.deprecated)), n.name === "parser" && (n.choices = [...n.choices, ...UT(n.choices, r, t)])), n.pluginDefaults = Object.fromEntries(t.filter((s) => {
      var a;
      return ((a = s.defaultOptions) == null ? void 0 : a[n.name]) !== void 0;
    }).map((s) => [s.name, s.defaultOptions[n.name]])), i.push(n));
  return { languages: r, options: i };
}
function* UT(t, e, r) {
  let i = new Set(t.map((n) => n.value));
  for (let n of e)
    if (n.parsers) {
      for (let s of n.parsers)
        if (!i.has(s)) {
          i.add(s);
          let a = r.find((u) => u.parsers && Object.prototype.hasOwnProperty.call(u.parsers, s)), l = n.name;
          a != null && a.name && (l += ` (plugin: ${a.name})`), yield { value: s, description: l };
        }
    }
}
function YT(t) {
  let e = [];
  for (let [r, i] of Object.entries(t)) {
    let n = { name: r, ...i };
    Array.isArray(n.default) && (n.default = Dt(!1, n.default, -1).value), e.push(n);
  }
  return e;
}
var zT = (t) => String(t).split(/[/\\]/).pop();
function jy(t, e) {
  if (!e)
    return;
  let r = zT(e).toLowerCase();
  return t.find(({ filenames: i }) => i == null ? void 0 : i.some((n) => n.toLowerCase() === r)) ?? t.find(({ extensions: i }) => i == null ? void 0 : i.some((n) => r.endsWith(n)));
}
function GT(t, e) {
  if (e)
    return t.find(({ name: r }) => r.toLowerCase() === e) ?? t.find(({ aliases: r }) => r == null ? void 0 : r.includes(e)) ?? t.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${e}`));
}
function HT(t, e) {
  let r = t.plugins.flatMap((n) => n.languages ?? []), i = GT(r, e.language) ?? jy(r, e.physicalFile) ?? jy(r, e.file) ?? (e.physicalFile, void 0);
  return i == null ? void 0 : i.parsers[0];
}
var JT = HT, oa = { key: (t) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(t) ? t : JSON.stringify(t), value(t) {
  if (t === null || typeof t != "object")
    return JSON.stringify(t);
  if (Array.isArray(t))
    return `[${t.map((r) => oa.value(r)).join(", ")}]`;
  let e = Object.keys(t);
  return e.length === 0 ? "{}" : `{ ${e.map((r) => `${oa.key(r)}: ${oa.value(t[r])}`).join(", ")} }`;
}, pair: ({ key: t, value: e }) => oa.value({ [t]: e }) }, Ry = ml(Yc(), 1), KT = (t, e, { descriptor: r }) => {
  let i = [`${Ry.default.yellow(typeof t == "string" ? r.key(t) : r.pair(t))} is deprecated`];
  return e && i.push(`we now treat it as ${Ry.default.blue(typeof e == "string" ? r.key(e) : r.pair(e))}`), i.join("; ") + ".";
}, la = ml(Yc(), 1), Hx = Symbol.for("vnopts.VALUE_NOT_EXIST"), ju = Symbol.for("vnopts.VALUE_UNCHANGED"), Zy = " ".repeat(2), eP = (t, e, r) => {
  let { text: i, list: n } = r.normalizeExpectedResult(r.schemas[t].expected(r)), s = [];
  return i && s.push(Wy(t, e, i, r.descriptor)), n && s.push([Wy(t, e, n.title, r.descriptor)].concat(n.values.map((a) => Jx(a, r.loggerPrintWidth))).join(`
`)), Kx(s, r.loggerPrintWidth);
};
function Wy(t, e, r, i) {
  return [`Invalid ${la.default.red(i.key(t))} value.`, `Expected ${la.default.blue(r)},`, `but received ${e === Hx ? la.default.gray("nothing") : la.default.red(i.value(e))}.`].join(" ");
}
function Jx({ text: t, list: e }, r) {
  let i = [];
  return t && i.push(`- ${la.default.blue(t)}`), e && i.push([`- ${la.default.blue(e.title)}:`].concat(e.values.map((n) => Jx(n, r - Zy.length).replace(/^|\n/g, `$&${Zy}`))).join(`
`)), Kx(i, r);
}
function Kx(t, e) {
  if (t.length === 1)
    return t[0];
  let [r, i] = t, [n, s] = t.map((a) => a.split(`
`, 1)[0].length);
  return n > e && n > s ? i : r;
}
var qy = ml(Yc(), 1), up = [], Xy = [];
function tP(t, e) {
  if (t === e)
    return 0;
  let r = t;
  t.length > e.length && (t = e, e = r);
  let i = t.length, n = e.length;
  for (; i > 0 && t.charCodeAt(~-i) === e.charCodeAt(~-n); )
    i--, n--;
  let s = 0;
  for (; s < i && t.charCodeAt(s) === e.charCodeAt(s); )
    s++;
  if (i -= s, n -= s, i === 0)
    return n;
  let a, l, u, h, p = 0, d = 0;
  for (; p < i; )
    Xy[p] = t.charCodeAt(s + p), up[p] = ++p;
  for (; d < n; )
    for (a = e.charCodeAt(s + d), u = d++, l = d, p = 0; p < i; p++)
      h = a === Xy[p] ? u : u + 1, u = up[p], l = up[p] = u > l ? h > l ? l + 1 : h : h > u ? u + 1 : h;
  return l;
}
var eD = (t, e, { descriptor: r, logger: i, schemas: n }) => {
  let s = [`Ignored unknown option ${qy.default.yellow(r.pair({ key: t, value: e }))}.`], a = Object.keys(n).sort().find((l) => tP(t, l) < 3);
  a && s.push(`Did you mean ${qy.default.blue(r.key(a))}?`), i.warn(s.join(" "));
}, rP = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function iP(t, e) {
  let r = new t(e), i = Object.create(r);
  for (let n of rP)
    n in e && (i[n] = nP(e[n], r, Wn.prototype[n].length));
  return i;
}
var Wn = class {
  static create(e) {
    return iP(this, e);
  }
  constructor(e) {
    this.name = e.name;
  }
  default(e) {
  }
  expected(e) {
    return "nothing";
  }
  validate(e, r) {
    return !1;
  }
  deprecated(e, r) {
    return !1;
  }
  forward(e, r) {
  }
  redirect(e, r) {
  }
  overlap(e, r, i) {
    return e;
  }
  preprocess(e, r) {
    return e;
  }
  postprocess(e, r) {
    return ju;
  }
};
function nP(t, e, r) {
  return typeof t == "function" ? (...i) => t(...i.slice(0, r - 1), e, ...i.slice(r - 1)) : () => t;
}
var sP = class extends Wn {
  constructor(e) {
    super(e), this._sourceName = e.sourceName;
  }
  expected(e) {
    return e.schemas[this._sourceName].expected(e);
  }
  validate(e, r) {
    return r.schemas[this._sourceName].validate(e, r);
  }
  redirect(e, r) {
    return this._sourceName;
  }
}, aP = class extends Wn {
  expected() {
    return "anything";
  }
  validate() {
    return !0;
  }
}, oP = class extends Wn {
  constructor({ valueSchema: e, name: r = e.name, ...i }) {
    super({ ...i, name: r }), this._valueSchema = e;
  }
  expected(e) {
    let { text: r, list: i } = e.normalizeExpectedResult(this._valueSchema.expected(e));
    return { text: r && `an array of ${r}`, list: i && { title: "an array of the following values", values: [{ list: i }] } };
  }
  validate(e, r) {
    if (!Array.isArray(e))
      return !1;
    let i = [];
    for (let n of e) {
      let s = r.normalizeValidateResult(this._valueSchema.validate(n, r), n);
      s !== !0 && i.push(s.value);
    }
    return i.length === 0 ? !0 : { value: i };
  }
  deprecated(e, r) {
    let i = [];
    for (let n of e) {
      let s = r.normalizeDeprecatedResult(this._valueSchema.deprecated(n, r), n);
      s !== !1 && i.push(...s.map(({ value: a }) => ({ value: [a] })));
    }
    return i;
  }
  forward(e, r) {
    let i = [];
    for (let n of e) {
      let s = r.normalizeForwardResult(this._valueSchema.forward(n, r), n);
      i.push(...s.map(Vy));
    }
    return i;
  }
  redirect(e, r) {
    let i = [], n = [];
    for (let s of e) {
      let a = r.normalizeRedirectResult(this._valueSchema.redirect(s, r), s);
      "remain" in a && i.push(a.remain), n.push(...a.redirect.map(Vy));
    }
    return i.length === 0 ? { redirect: n } : { redirect: n, remain: i };
  }
  overlap(e, r) {
    return e.concat(r);
  }
};
function Vy({ from: t, to: e }) {
  return { from: [t], to: e };
}
var lP = class extends Wn {
  expected() {
    return "true or false";
  }
  validate(e) {
    return typeof e == "boolean";
  }
};
function uP(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let i of t) {
    let n = i[e];
    if (r[n])
      throw new Error(`Duplicate ${e} ${JSON.stringify(n)}`);
    r[n] = i;
  }
  return r;
}
function cP(t, e) {
  let r = /* @__PURE__ */ new Map();
  for (let i of t) {
    let n = i[e];
    if (r.has(n))
      throw new Error(`Duplicate ${e} ${JSON.stringify(n)}`);
    r.set(n, i);
  }
  return r;
}
function hP() {
  let t = /* @__PURE__ */ Object.create(null);
  return (e) => {
    let r = JSON.stringify(e);
    return t[r] ? !0 : (t[r] = !0, !1);
  };
}
function pP(t, e) {
  let r = [], i = [];
  for (let n of t)
    e(n) ? r.push(n) : i.push(n);
  return [r, i];
}
function dP(t) {
  return t === Math.floor(t);
}
function fP(t, e) {
  if (t === e)
    return 0;
  let r = typeof t, i = typeof e, n = ["undefined", "object", "boolean", "number", "string"];
  return r !== i ? n.indexOf(r) - n.indexOf(i) : r !== "string" ? Number(t) - Number(e) : t.localeCompare(e);
}
function mP(t) {
  return (...e) => {
    let r = t(...e);
    return typeof r == "string" ? new Error(r) : r;
  };
}
function Uy(t) {
  return t === void 0 ? {} : t;
}
function tD(t) {
  if (typeof t == "string")
    return { text: t };
  let { text: e, list: r } = t;
  return gP((e || r) !== void 0, "Unexpected `expected` result, there should be at least one field."), r ? { text: e, list: { title: r.title, values: r.values.map(tD) } } : { text: e };
}
function Yy(t, e) {
  return t === !0 ? !0 : t === !1 ? { value: e } : t;
}
function zy(t, e, r = !1) {
  return t === !1 ? !1 : t === !0 ? r ? !0 : [{ value: e }] : "value" in t ? [t] : t.length === 0 ? !1 : t;
}
function Gy(t, e) {
  return typeof t == "string" || "key" in t ? { from: e, to: t } : "from" in t ? { from: t.from, to: t.to } : { from: e, to: t.to };
}
function yd(t, e) {
  return t === void 0 ? [] : Array.isArray(t) ? t.map((r) => Gy(r, e)) : [Gy(t, e)];
}
function Hy(t, e) {
  let r = yd(typeof t == "object" && "redirect" in t ? t.redirect : t, e);
  return r.length === 0 ? { remain: e, redirect: r } : typeof t == "object" && "remain" in t ? { remain: t.remain, redirect: r } : { redirect: r };
}
function gP(t, e) {
  if (!t)
    throw new Error(e);
}
var yP = class extends Wn {
  constructor(e) {
    super(e), this._choices = cP(e.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
  }
  expected({ descriptor: e }) {
    let r = Array.from(this._choices.keys()).map((s) => this._choices.get(s)).filter(({ hidden: s }) => !s).map((s) => s.value).sort(fP).map(e.value), i = r.slice(0, -2), n = r.slice(-2);
    return { text: i.concat(n.join(" or ")).join(", "), list: { title: "one of the following values", values: r } };
  }
  validate(e) {
    return this._choices.has(e);
  }
  deprecated(e) {
    let r = this._choices.get(e);
    return r && r.deprecated ? { value: e } : !1;
  }
  forward(e) {
    let r = this._choices.get(e);
    return r ? r.forward : void 0;
  }
  redirect(e) {
    let r = this._choices.get(e);
    return r ? r.redirect : void 0;
  }
}, OP = class extends Wn {
  expected() {
    return "a number";
  }
  validate(e, r) {
    return typeof e == "number";
  }
}, xP = class extends OP {
  expected() {
    return "an integer";
  }
  validate(e, r) {
    return r.normalizeValidateResult(super.validate(e, r), e) === !0 && dP(e);
  }
}, Jy = class extends Wn {
  expected() {
    return "a string";
  }
  validate(e) {
    return typeof e == "string";
  }
}, DP = oa, bP = eD, vP = eP, wP = KT, SP = class {
  constructor(e, r) {
    let { logger: i = console, loggerPrintWidth: n = 80, descriptor: s = DP, unknown: a = bP, invalid: l = vP, deprecated: u = wP, missing: h = () => !1, required: p = () => !1, preprocess: d = (y) => y, postprocess: m = () => ju } = r || {};
    this._utils = { descriptor: s, logger: i || { warn: () => {
    } }, loggerPrintWidth: n, schemas: uP(e, "name"), normalizeDefaultResult: Uy, normalizeExpectedResult: tD, normalizeDeprecatedResult: zy, normalizeForwardResult: yd, normalizeRedirectResult: Hy, normalizeValidateResult: Yy }, this._unknownHandler = a, this._invalidHandler = mP(l), this._deprecatedHandler = u, this._identifyMissing = (y, O) => !(y in O) || h(y, O), this._identifyRequired = p, this._preprocess = d, this._postprocess = m, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = hP();
  }
  normalize(e) {
    let r = {}, i = [this._preprocess(e, this._utils)], n = () => {
      for (; i.length !== 0; ) {
        let s = i.shift(), a = this._applyNormalization(s, r);
        i.push(...a);
      }
    };
    n();
    for (let s of Object.keys(this._utils.schemas)) {
      let a = this._utils.schemas[s];
      if (!(s in r)) {
        let l = Uy(a.default(this._utils));
        "value" in l && i.push({ [s]: l.value });
      }
    }
    n();
    for (let s of Object.keys(this._utils.schemas)) {
      if (!(s in r))
        continue;
      let a = this._utils.schemas[s], l = r[s], u = a.postprocess(l, this._utils);
      u !== ju && (this._applyValidation(u, s, a), r[s] = u);
    }
    return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
  }
  _applyNormalization(e, r) {
    let i = [], { knownKeys: n, unknownKeys: s } = this._partitionOptionKeys(e);
    for (let a of n) {
      let l = this._utils.schemas[a], u = l.preprocess(e[a], this._utils);
      this._applyValidation(u, a, l);
      let h = ({ from: m, to: y }) => {
        i.push(typeof y == "string" ? { [y]: m } : { [y.key]: y.value });
      }, p = ({ value: m, redirectTo: y }) => {
        let O = zy(l.deprecated(m, this._utils), u, !0);
        if (O !== !1)
          if (O === !0)
            this._hasDeprecationWarned(a) || this._utils.logger.warn(this._deprecatedHandler(a, y, this._utils));
          else
            for (let { value: D } of O) {
              let v = { key: a, value: D };
              if (!this._hasDeprecationWarned(v)) {
                let w = typeof y == "string" ? { key: y, value: D } : y;
                this._utils.logger.warn(this._deprecatedHandler(v, w, this._utils));
              }
            }
      };
      yd(l.forward(u, this._utils), u).forEach(h);
      let d = Hy(l.redirect(u, this._utils), u);
      if (d.redirect.forEach(h), "remain" in d) {
        let m = d.remain;
        r[a] = a in r ? l.overlap(r[a], m, this._utils) : m, p({ value: m });
      }
      for (let { from: m, to: y } of d.redirect)
        p({ value: m, redirectTo: y });
    }
    for (let a of s) {
      let l = e[a];
      this._applyUnknownHandler(a, l, r, (u, h) => {
        i.push({ [u]: h });
      });
    }
    return i;
  }
  _applyRequiredCheck(e) {
    for (let r of Object.keys(this._utils.schemas))
      if (this._identifyMissing(r, e) && this._identifyRequired(r))
        throw this._invalidHandler(r, Hx, this._utils);
  }
  _partitionOptionKeys(e) {
    let [r, i] = pP(Object.keys(e).filter((n) => !this._identifyMissing(n, e)), (n) => n in this._utils.schemas);
    return { knownKeys: r, unknownKeys: i };
  }
  _applyValidation(e, r, i) {
    let n = Yy(i.validate(e, this._utils), e);
    if (n !== !0)
      throw this._invalidHandler(r, n.value, this._utils);
  }
  _applyUnknownHandler(e, r, i, n) {
    let s = this._unknownHandler(e, r, this._utils);
    if (s)
      for (let a of Object.keys(s)) {
        if (this._identifyMissing(a, s))
          continue;
        let l = s[a];
        a in this._utils.schemas ? n(a, l) : i[a] = l;
      }
  }
  _applyPostprocess(e) {
    let r = this._postprocess(e, this._utils);
    if (r !== ju) {
      if (r.delete)
        for (let i of r.delete)
          delete e[i];
      if (r.override) {
        let { knownKeys: i, unknownKeys: n } = this._partitionOptionKeys(r.override);
        for (let s of i) {
          let a = r.override[s];
          this._applyValidation(a, s, this._utils.schemas[s]), e[s] = a;
        }
        for (let s of n) {
          let a = r.override[s];
          this._applyUnknownHandler(s, a, e, (l, u) => {
            let h = this._utils.schemas[l];
            this._applyValidation(u, l, h), e[l] = u;
          });
        }
      }
    }
  }
}, cp;
function CP(t, e, { logger: r = !1, isCLI: i = !1, passThrough: n = !1, FlagSchema: s, descriptor: a } = {}) {
  if (i) {
    if (!s)
      throw new Error("'FlagSchema' option is required.");
    if (!a)
      throw new Error("'descriptor' option is required.");
  } else
    a = oa;
  let l = n ? Array.isArray(n) ? (m, y) => n.includes(m) ? { [m]: y } : void 0 : (m, y) => ({ [m]: y }) : (m, y, O) => {
    let { _: D, ...v } = O.schemas;
    return eD(m, y, { ...O, schemas: v });
  }, u = EP(e, { isCLI: i, FlagSchema: s }), h = new SP(u, { logger: r, unknown: l, descriptor: a }), p = r !== !1;
  p && cp && (h._hasDeprecationWarned = cp);
  let d = h.normalize(t);
  return p && (cp = h._hasDeprecationWarned), d;
}
function EP(t, { isCLI: e, FlagSchema: r }) {
  let i = [];
  e && i.push(aP.create({ name: "_" }));
  for (let n of t)
    i.push(AP(n, { isCLI: e, optionInfos: t, FlagSchema: r })), n.alias && e && i.push(sP.create({ name: n.alias, sourceName: n.name }));
  return i;
}
function AP(t, { isCLI: e, optionInfos: r, FlagSchema: i }) {
  let { name: n } = t, s = { name: n }, a, l = {};
  switch (t.type) {
    case "int":
      a = xP, e && (s.preprocess = Number);
      break;
    case "string":
      a = Jy;
      break;
    case "choice":
      a = yP, s.choices = t.choices.map((u) => u != null && u.redirect ? { ...u, redirect: { to: { key: t.name, value: u.redirect } } } : u);
      break;
    case "boolean":
      a = lP;
      break;
    case "flag":
      a = i, s.flags = r.flatMap((u) => [u.alias, u.description && u.name, u.oppositeDescription && `no-${u.name}`].filter(Boolean));
      break;
    case "path":
      a = Jy;
      break;
    default:
      throw new Error(`Unexpected type ${t.type}`);
  }
  if (t.exception ? s.validate = (u, h, p) => t.exception(u) || h.validate(u, p) : s.validate = (u, h, p) => u === void 0 || h.validate(u, p), t.redirect && (l.redirect = (u) => u ? { to: { key: t.redirect.option, value: t.redirect.value } } : void 0), t.deprecated && (l.deprecated = !0), e && !t.array) {
    let u = s.preprocess || ((h) => h);
    s.preprocess = (h, p, d) => p.preprocess(u(Array.isArray(h) ? Dt(!1, h, -1) : h), d);
  }
  return t.array ? oP.create({ ...e ? { preprocess: (u) => Array.isArray(u) ? u : [u] } : {}, ...l, valueSchema: a.create(s) }) : a.create({ ...s, ...l });
}
var kP = CP, TP = (t, e, r) => {
  if (!(t && e == null)) {
    if (e.findLast)
      return e.findLast(r);
    for (let i = e.length - 1; i >= 0; i--) {
      let n = e[i];
      if (r(n, i, e))
        return n;
    }
  }
}, rD = TP;
function iD(t, e) {
  if (!e)
    throw new Error("parserName is required.");
  let r = rD(!1, t, (n) => n.parsers && Object.prototype.hasOwnProperty.call(n.parsers, e));
  if (r)
    return r;
  let i = `Couldn't resolve parser "${e}".`;
  throw i += " Plugins must be explicitly added to the standalone bundle.", new zx(i);
}
function PP(t, e) {
  if (!e)
    throw new Error("astFormat is required.");
  let r = rD(!1, t, (n) => n.printers && Object.prototype.hasOwnProperty.call(n.printers, e));
  if (r)
    return r;
  let i = `Couldn't find plugin for AST format "${e}".`;
  throw i += " Plugins must be explicitly added to the standalone bundle.", new zx(i);
}
function nD({ plugins: t, parser: e }) {
  let r = iD(t, e);
  return sD(r, e);
}
function sD(t, e) {
  let r = t.parsers[e];
  return typeof r == "function" ? r() : r;
}
function FP(t, e) {
  let r = t.printers[e];
  return typeof r == "function" ? r() : r;
}
var Ky = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
async function $P(t, e = {}) {
  var r;
  let i = { ...t };
  if (!i.parser)
    if (i.filepath) {
      if (i.parser = JT(i, { physicalFile: i.filepath }), !i.parser)
        throw new Qy(`No parser could be inferred for file "${i.filepath}".`);
    } else
      throw new Qy("No parser and no file path given, couldn't infer a parser.");
  let n = Gx({ plugins: t.plugins, showDeprecated: !0 }).options, s = { ...Ky, ...Object.fromEntries(n.filter((m) => m.default !== void 0).map((m) => [m.name, m.default])) }, a = iD(i.plugins, i.parser), l = await sD(a, i.parser);
  i.astFormat = l.astFormat, i.locEnd = l.locEnd, i.locStart = l.locStart;
  let u = (r = a.printers) != null && r[l.astFormat] ? a : PP(i.plugins, l.astFormat), h = await FP(u, l.astFormat);
  i.printer = h;
  let p = u.defaultOptions ? Object.fromEntries(Object.entries(u.defaultOptions).filter(([, m]) => m !== void 0)) : {}, d = { ...s, ...p };
  for (let [m, y] of Object.entries(d))
    (i[m] === null || i[m] === void 0) && (i[m] = y);
  return i.parser === "json" && (i.trailingComma = "none"), kP(i, n, { passThrough: Object.keys(Ky), ...e });
}
var Ba = $P, BP = ml(Ik(), 1);
async function IP(t, e) {
  let r = await nD(e), i = r.preprocess ? r.preprocess(t, e) : t;
  e.originalText = i;
  let n;
  try {
    n = await r.parse(i, e, e);
  } catch (s) {
    NP(s, t);
  }
  return { text: i, ast: n };
}
function NP(t, e) {
  let { loc: r } = t;
  if (r) {
    let i = (0, BP.codeFrameColumns)(e, r, { highlightCode: !0 });
    throw t.message += `
` + i, t.codeFrame = i, t;
  }
  throw t;
}
var yl = IP;
async function _P(t, e, r, i, n) {
  let { embeddedLanguageFormatting: s, printer: { embed: a, hasPrettierIgnore: l = () => !1, getVisitorKeys: u } } = r;
  if (!a || s !== "auto")
    return;
  if (a.length > 2)
    throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed");
  let h = Kc(a.getVisitorKeys ?? u), p = [];
  y();
  let d = t.stack;
  for (let { print: O, node: D, pathStack: v } of p)
    try {
      t.stack = v;
      let w = await O(m, e, t, r);
      w && n.set(D, w);
    } catch (w) {
      if (globalThis.PRETTIER_DEBUG)
        throw w;
    }
  t.stack = d;
  function m(O, D) {
    return MP(O, D, r, i);
  }
  function y() {
    let { node: O } = t;
    if (O === null || typeof O != "object" || l(t))
      return;
    for (let v of h(O))
      Array.isArray(O[v]) ? t.each(y, v) : t.call(y, v);
    let D = a(t, r);
    if (D) {
      if (typeof D == "function") {
        p.push({ print: D, node: O, pathStack: [...t.stack] });
        return;
      }
      n.set(O, D);
    }
  }
}
async function MP(t, e, r, i) {
  let n = await Ba({ ...r, ...e, parentParser: r.parser, originalText: t }, { passThrough: !0 }), { ast: s } = await yl(t, n), a = await i(s, n);
  return Lx(a);
}
function LP(t, e) {
  let { originalText: r, [Symbol.for("comments")]: i, locStart: n, locEnd: s, [Symbol.for("printedComments")]: a } = e, { node: l } = t, u = n(l), h = s(l);
  for (let p of i)
    n(p) >= u && s(p) <= h && a.add(p);
  return r.slice(u, h);
}
var QP = LP;
async function eh(t, e) {
  ({ ast: t } = await aD(t, e));
  let r = /* @__PURE__ */ new Map(), i = new CT(t), n = /* @__PURE__ */ new Map();
  await _P(i, a, e, eh, n);
  let s = await e0(i, e, a, void 0, n);
  return XT(e), s;
  function a(u, h) {
    return u === void 0 || u === i ? l(h) : Array.isArray(u) ? i.call(() => l(h), ...u) : i.call(() => l(h), u);
  }
  function l(u) {
    let h = i.node;
    if (h == null)
      return "";
    let p = h && typeof h == "object" && u === void 0;
    if (p && r.has(h))
      return r.get(h);
    let d = e0(i, e, a, u, n);
    return p && r.set(h, d), d;
  }
}
function e0(t, e, r, i, n) {
  var s;
  let { node: a } = t, { printer: l } = e, u;
  return (s = l.hasPrettierIgnore) != null && s.call(l, t) ? u = QP(t, e) : n.has(a) ? u = n.get(a) : u = l.print(t, e, r, i), a === e.cursorNode && (u = Qx(u, (h) => [pd, h, pd])), l.printComment && (!l.willPrintOwnComments || !l.willPrintOwnComments(t, e)) && (u = qT(t, u, e)), u;
}
async function aD(t, e) {
  let r = t.comments ?? [];
  e[Symbol.for("comments")] = r, e[Symbol.for("tokens")] = t.tokens ?? [], e[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), MT(t, e);
  let { printer: { preprocess: i } } = e;
  return t = i ? await i(t, e) : t, { ast: t, comments: r };
}
function jP(t, e) {
  let { cursorOffset: r, locStart: i, locEnd: n } = e, s = Kc(e.printer.getVisitorKeys), a = (u) => i(u) <= r && n(u) >= r, l = t;
  for (let u of kT(t, { getVisitorKeys: s, filter: a }))
    l = u;
  return l;
}
var RP = jP;
function ZP(t, e) {
  let { printer: { massageAstNode: r, getVisitorKeys: i } } = e;
  if (!r)
    return t;
  let n = Kc(i), s = r.ignoredProperties ?? /* @__PURE__ */ new Set();
  return a(t);
  function a(l, u) {
    if (!(l !== null && typeof l == "object"))
      return l;
    if (Array.isArray(l))
      return l.map((m) => a(m, u)).filter(Boolean);
    let h = {}, p = new Set(n(l));
    for (let m in l)
      !Object.prototype.hasOwnProperty.call(l, m) || s.has(m) || (p.has(m) ? h[m] = a(l[m], l) : h[m] = l[m]);
    let d = r(l, h, u);
    if (d !== null)
      return d ?? h;
  }
}
var WP = ZP, qP = ({ parser: t }) => t === "json" || t === "json5" || t === "jsonc" || t === "json-stringify";
function XP(t, e) {
  let r = [t.node, ...t.parentNodes], i = /* @__PURE__ */ new Set([e.node, ...e.parentNodes]);
  return r.find((n) => oD.has(n.type) && i.has(n));
}
function t0(t) {
  let e = t.length - 1;
  for (; ; ) {
    let r = t[e];
    if ((r == null ? void 0 : r.type) === "Program" || (r == null ? void 0 : r.type) === "File")
      e--;
    else
      break;
  }
  return t.slice(0, e + 1);
}
function VP(t, e, { locStart: r, locEnd: i }) {
  let n = t.node, s = e.node;
  if (n === s)
    return { startNode: n, endNode: s };
  let a = r(t.node);
  for (let u of t0(e.parentNodes))
    if (r(u) >= a)
      s = u;
    else
      break;
  let l = i(e.node);
  for (let u of t0(t.parentNodes)) {
    if (i(u) <= l)
      n = u;
    else
      break;
    if (n === s)
      break;
  }
  return { startNode: n, endNode: s };
}
function Od(t, e, r, i, n = [], s) {
  let { locStart: a, locEnd: l } = r, u = a(t), h = l(t);
  if (!(e > h || e < u || s === "rangeEnd" && e === u || s === "rangeStart" && e === h)) {
    for (let p of nm(t, r)) {
      let d = Od(p, e, r, i, [t, ...n], s);
      if (d)
        return d;
    }
    if (!i || i(t, n[0]))
      return { node: t, parentNodes: n };
  }
}
function UP(t, e) {
  return e !== "DeclareExportDeclaration" && t !== "TypeParameterDeclaration" && (t === "Directive" || t === "TypeAlias" || t === "TSExportAssignment" || t.startsWith("Declare") || t.startsWith("TSDeclare") || t.endsWith("Statement") || t.endsWith("Declaration"));
}
var oD = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), YP = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function r0(t, e, r) {
  if (!e)
    return !1;
  switch (t.parser) {
    case "flow":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "__babel_estree":
      return UP(e.type, r == null ? void 0 : r.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return oD.has(e.type);
    case "graphql":
      return YP.has(e.kind);
    case "vue":
      return e.tag !== "root";
  }
  return !1;
}
function zP(t, e, r) {
  let { rangeStart: i, rangeEnd: n, locStart: s, locEnd: a } = e;
  gd.ok(n > i);
  let l = t.slice(i, n).search(/\S/), u = l === -1;
  if (!u)
    for (i += l; n > i && !/\S/.test(t[n - 1]); --n)
      ;
  let h = Od(r, i, e, (y, O) => r0(e, y, O), [], "rangeStart"), p = u ? h : Od(r, n, e, (y) => r0(e, y), [], "rangeEnd");
  if (!h || !p)
    return { rangeStart: 0, rangeEnd: 0 };
  let d, m;
  if (qP(e)) {
    let y = XP(h, p);
    d = y, m = y;
  } else
    ({ startNode: d, endNode: m } = VP(h, p, e));
  return { rangeStart: Math.min(s(d), s(m)), rangeEnd: Math.max(a(d), a(m)) };
}
var lD = "\uFEFF", i0 = Symbol("cursor");
async function uD(t, e, r = 0) {
  if (!t || t.trim().length === 0)
    return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: i, text: n } = await yl(t, e);
  e.cursorOffset >= 0 && (e.cursorNode = RP(i, e));
  let s = await eh(i, e);
  r > 0 && (s = Mx([hs, s], r, e.tabWidth));
  let a = Jc(s, e);
  if (r > 0) {
    let u = a.formatted.trim();
    a.cursorNodeStart !== void 0 && (a.cursorNodeStart -= a.formatted.indexOf(u)), a.formatted = u + Hf(e.endOfLine);
  }
  let l = e[Symbol.for("comments")];
  if (e.cursorOffset >= 0) {
    let u, h, p, d, m;
    if (e.cursorNode && a.cursorNodeText ? (u = e.locStart(e.cursorNode), h = n.slice(u, e.locEnd(e.cursorNode)), p = e.cursorOffset - u, d = a.cursorNodeStart, m = a.cursorNodeText) : (u = 0, h = n, p = e.cursorOffset, d = 0, m = a.formatted), h === m)
      return { formatted: a.formatted, cursorOffset: d + p, comments: l };
    let y = h.split("");
    y.splice(p, 0, i0);
    let O = m.split(""), D = (0, _k.diffArrays)(y, O), v = d;
    for (let w of D)
      if (w.removed) {
        if (w.value.includes(i0))
          break;
      } else
        v += w.count;
    return { formatted: a.formatted, cursorOffset: v, comments: l };
  }
  return { formatted: a.formatted, cursorOffset: -1, comments: l };
}
async function GP(t, e) {
  let { ast: r, text: i } = await yl(t, e), { rangeStart: n, rangeEnd: s } = zP(i, e, r), a = i.slice(n, s), l = Math.min(n, i.lastIndexOf(`
`, n) + 1), u = i.slice(l, n).match(/^\s*/)[0], h = rm(u, e.tabWidth), p = await uD(a, { ...e, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: e.cursorOffset > n && e.cursorOffset <= s ? e.cursorOffset - n : -1, endOfLine: "lf" }, h), d = p.formatted.trimEnd(), { cursorOffset: m } = e;
  m > s ? m += d.length - a.length : p.cursorOffset >= 0 && (m = p.cursorOffset + n);
  let y = i.slice(0, n) + d + i.slice(s);
  if (e.endOfLine !== "lf") {
    let O = Hf(e.endOfLine);
    m >= 0 && O === `\r
` && (m += Tx(y.slice(0, m), `
`)), y = zc(!1, y, `
`, O);
  }
  return { formatted: y, cursorOffset: m, comments: p.comments };
}
function hp(t, e, r) {
  return typeof e != "number" || Number.isNaN(e) || e < 0 || e > t.length ? r : e;
}
function n0(t, e) {
  let { cursorOffset: r, rangeStart: i, rangeEnd: n } = e;
  return r = hp(t, r, -1), i = hp(t, i, 0), n = hp(t, n, t.length), { ...e, cursorOffset: r, rangeStart: i, rangeEnd: n };
}
function cD(t, e) {
  let { cursorOffset: r, rangeStart: i, rangeEnd: n, endOfLine: s } = n0(t, e), a = t.charAt(0) === lD;
  if (a && (t = t.slice(1), r--, i--, n--), s === "auto" && (s = Mk(t)), t.includes("\r")) {
    let l = (u) => Tx(t.slice(0, Math.max(u, 0)), `\r
`);
    r -= l(r), i -= l(i), n -= l(n), t = Lk(t);
  }
  return { hasBOM: a, text: t, options: n0(t, { ...e, cursorOffset: r, rangeStart: i, rangeEnd: n, endOfLine: s }) };
}
async function s0(t, e) {
  let r = await nD(e);
  return !r.hasPragma || r.hasPragma(t);
}
async function hD(t, e) {
  let { hasBOM: r, text: i, options: n } = cD(t, await Ba(e));
  if (n.rangeStart >= n.rangeEnd && i !== "" || n.requirePragma && !await s0(i, n))
    return { formatted: t, cursorOffset: e.cursorOffset, comments: [] };
  let s;
  return n.rangeStart > 0 || n.rangeEnd < i.length ? s = await GP(i, n) : (!n.requirePragma && n.insertPragma && n.printer.insertPragma && !await s0(i, n) && (i = n.printer.insertPragma(i)), s = await uD(i, n)), r && (s.formatted = lD + s.formatted, s.cursorOffset >= 0 && s.cursorOffset++), s;
}
async function HP(t, e, r) {
  let { text: i, options: n } = cD(t, await Ba(e)), s = await yl(i, n);
  return r && (r.preprocessForPrint && (s.ast = await aD(s.ast, n)), r.massage && (s.ast = WP(s.ast, n))), s;
}
async function JP(t, e) {
  e = await Ba(e);
  let r = await eh(t, e);
  return Jc(r, e);
}
async function KP(t, e) {
  let r = rT(t), { formatted: i } = await hD(r, { ...e, parser: "__js_expression" });
  return i;
}
async function eF(t, e) {
  e = await Ba(e);
  let { ast: r } = await yl(t, e);
  return eh(r, e);
}
async function tF(t, e) {
  return Jc(t, await Ba(e));
}
var pD = {};
Uc(pD, { builders: () => rF, printer: () => iF, utils: () => nF });
var rF = { join: _x, line: Ix, softline: eT, hardline: hs, literalline: Nx, group: Fx, conditionalGroup: zk, fill: $x, lineSuffix: hd, lineSuffixBoundary: Jk, cursor: pd, breakParent: Gc, ifBreak: Gk, trim: Kk, indent: sc, indentIfBreak: Hk, align: ba, addAlignmentToDoc: Mx, markAsRoot: Uk, dedentToRoot: Vk, dedent: Yk, hardlineWithoutBreakParent: Kf, literallineWithoutBreakParent: Bx, label: tT, concat: (t) => t }, iF = { printDocToString: Jc }, nF = { willBreak: pT, traverseDoc: Jf, findInDoc: tm, mapDoc: Hc, removeLines: mT, stripTrailingHardline: Lx, replaceEndOfLine: OT, canBreak: DT }, sF = "3.2.5", dD = {};
Uc(dD, { addDanglingComment: () => es, addLeadingComment: () => sa, addTrailingComment: () => aa, getAlignmentSize: () => rm, getIndentSize: () => hF, getMaxContinuousCount: () => fF, getNextNonSpaceNonCommentCharacter: () => gF, getNextNonSpaceNonCommentCharacterIndex: () => SF, getStringWidth: () => em, hasNewline: () => kn, hasNewlineInRange: () => OF, hasSpaces: () => DF, isNextLineEmpty: () => kF, isNextLineEmptyAfterIndex: () => um, isPreviousLineEmpty: () => EF, makeString: () => vF, skip: () => gl, skipEverythingButNewLine: () => qx, skipInlineComment: () => am, skipNewline: () => fs, skipSpaces: () => Bn, skipToLineEnd: () => Wx, skipTrailingComment: () => om, skipWhitespace: () => TT });
function aF(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var am = aF;
function oF(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? qx(t, e) : e;
}
var om = oF;
function lF(t, e) {
  let r = null, i = e;
  for (; i !== r; )
    r = i, i = Bn(t, i), i = am(t, i), i = om(t, i), i = fs(t, i);
  return i;
}
var lm = lF;
function uF(t, e) {
  let r = null, i = e;
  for (; i !== r; )
    r = i, i = Wx(t, i), i = am(t, i), i = Bn(t, i);
  return i = om(t, i), i = fs(t, i), i !== !1 && kn(t, i);
}
var um = uF;
function cF(t, e) {
  let r = t.lastIndexOf(`
`);
  return r === -1 ? 0 : rm(t.slice(r + 1).match(/^[\t ]*/)[0], e);
}
var hF = cF;
function pF(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function dF(t, e) {
  let r = t.match(new RegExp(`(${pF(e)})+`, "g"));
  return r === null ? 0 : r.reduce((i, n) => Math.max(i, n.length / e.length), 0);
}
var fF = dF;
function mF(t, e) {
  let r = lm(t, e);
  return r === !1 ? "" : t.charAt(r);
}
var gF = mF;
function yF(t, e, r) {
  for (let i = e; i < r; ++i)
    if (t.charAt(i) === `
`)
      return !0;
  return !1;
}
var OF = yF;
function xF(t, e, r = {}) {
  return Bn(t, r.backwards ? e - 1 : e, r) !== e;
}
var DF = xF;
function bF(t, e, r) {
  let i = e === '"' ? "'" : '"', n = zc(!1, t, /\\(.)|(["'])/gs, (s, a, l) => a === i ? a : l === e ? "\\" + l : l || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(a) ? a : "\\" + a));
  return e + n + e;
}
var vF = bF;
function wF(t, e, r) {
  return lm(t, r(e));
}
function SF(t, e) {
  return arguments.length === 2 || typeof e == "number" ? lm(t, e) : wF(...arguments);
}
function CF(t, e, r) {
  return sm(t, r(e));
}
function EF(t, e) {
  return arguments.length === 2 || typeof e == "number" ? sm(t, e) : CF(...arguments);
}
function AF(t, e, r) {
  return um(t, r(e));
}
function kF(t, e) {
  return arguments.length === 2 || typeof e == "number" ? um(t, e) : AF(...arguments);
}
function rs(t, e = 1) {
  return async (...r) => {
    let i = r[e] ?? {}, n = i.plugins ?? [];
    return r[e] = { ...i, plugins: Array.isArray(n) ? n : Object.values(n) }, t(...r);
  };
}
var fD = rs(hD);
async function mD(t, e) {
  let { formatted: r } = await fD(t, { ...e, cursorOffset: -1 });
  return r;
}
async function TF(t, e) {
  return await mD(t, e) === t;
}
var PF = rs(Gx, 0), FF = { parse: rs(HP), formatAST: rs(JP), formatDoc: rs(KP), printToDoc: rs(eF), printDocToString: rs(tF) }, $F = kx, BF = Object.defineProperty, gD = (t, e) => {
  for (var r in e)
    BF(t, r, { get: e[r], enumerable: !0 });
}, yD = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, dn = (t, e, r) => (yD(t, e, "read from private field"), r ? r.call(t) : e.get(t)), IF = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, NF = (t, e, r, i) => (yD(t, e, "write to private field"), i ? i.call(t, r) : e.set(t, r), r), OD = {};
gD(OD, { languages: () => DB, options: () => vB, parsers: () => JD, printers: () => A8 });
var _F = (t, e, r, i) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, i) : r.global ? e.replace(r, i) : e.split(r).join(i);
}, vr = _F, cm = "string", hm = "array", pm = "cursor", th = "indent", rh = "align", dm = "trim", Xo = "group", ih = "fill", nh = "if-break", sh = "indent-if-break", fm = "line-suffix", mm = "line-suffix-boundary", Ps = "line", gm = "label", ah = "break-parent", xD = /* @__PURE__ */ new Set([pm, th, rh, dm, Xo, ih, nh, sh, fm, mm, Ps, gm, ah]);
function MF(t) {
  if (typeof t == "string")
    return cm;
  if (Array.isArray(t))
    return hm;
  if (!t)
    return;
  let { type: e } = t;
  if (xD.has(e))
    return e;
}
var ym = MF, LF = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function QF(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (ym(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let i = LF([...xD].map((n) => `'${n}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${i}.`;
}
var jF = class extends Error {
  constructor(r) {
    super(QF(r));
    Ur(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, DD = jF, RF = () => {
}, ZF = RF;
function an(t) {
  return { type: th, contents: t };
}
function bD(t, e) {
  return { type: rh, contents: e, n: t };
}
function Wt(t, e = {}) {
  return ZF(e.expandedStates), { type: Xo, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function WF(t) {
  return bD(Number.NEGATIVE_INFINITY, t);
}
function qF(t) {
  return bD({ type: "root" }, t);
}
function vD(t) {
  return { type: ih, parts: t };
}
function ac(t, e = "", r = {}) {
  return { type: nh, breakContents: t, flatContents: e, groupId: r.groupId };
}
function XF(t, e) {
  return { type: sh, contents: t, groupId: e.groupId, negate: e.negate };
}
var Ol = { type: ah }, VF = { type: Ps, hard: !0 }, UF = { type: Ps, hard: !0, literal: !0 }, $t = { type: Ps }, Rt = { type: Ps, soft: !0 }, rt = [VF, Ol], YF = [UF, Ol];
function Ia(t, e) {
  let r = [];
  for (let i = 0; i < e.length; i++)
    i !== 0 && r.push(t), r.push(e[i]);
  return r;
}
var zF = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, xl = zF;
function Om(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return i(t);
  function i(s) {
    if (r.has(s))
      return r.get(s);
    let a = n(s);
    return r.set(s, a), a;
  }
  function n(s) {
    switch (ym(s)) {
      case hm:
        return e(s.map(i));
      case ih:
        return e({ ...s, parts: s.parts.map(i) });
      case nh:
        return e({ ...s, breakContents: i(s.breakContents), flatContents: i(s.flatContents) });
      case Xo: {
        let { expandedStates: a, contents: l } = s;
        return a ? (a = a.map(i), l = a[0]) : l = i(l), e({ ...s, contents: l, expandedStates: a });
      }
      case rh:
      case th:
      case sh:
      case gm:
      case fm:
        return e({ ...s, contents: i(s.contents) });
      case cm:
      case pm:
      case dm:
      case mm:
      case Ps:
      case ah:
        return e(s);
      default:
        throw new DD(s);
    }
  }
}
function GF(t) {
  switch (ym(t)) {
    case ih:
      if (t.parts.every((e) => e === ""))
        return "";
      break;
    case Xo:
      if (!t.contents && !t.id && !t.break && !t.expandedStates)
        return "";
      if (t.contents.type === Xo && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates)
        return t.contents;
      break;
    case rh:
    case th:
    case sh:
    case fm:
      if (!t.contents)
        return "";
      break;
    case nh:
      if (!t.flatContents && !t.breakContents)
        return "";
      break;
    case hm: {
      let e = [];
      for (let r of t) {
        if (!r)
          continue;
        let [i, ...n] = Array.isArray(r) ? r : [r];
        typeof i == "string" && typeof xl(!1, e, -1) == "string" ? e[e.length - 1] += i : e.push(i), e.push(...n);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case cm:
    case pm:
    case dm:
    case mm:
    case Ps:
    case gm:
    case ah:
      break;
    default:
      throw new DD(t);
  }
  return t;
}
function HF(t) {
  return Om(t, (e) => GF(e));
}
function ti(t, e = YF) {
  return Om(t, (r) => typeof r == "string" ? Ia(e, r.split(`
`)) : r);
}
var tu = "'", a0 = '"';
function JF(t, e) {
  let r = e === !0 || e === tu ? tu : a0, i = r === tu ? a0 : tu, n = 0, s = 0;
  for (let a of t)
    a === r ? n++ : a === i && s++;
  return n > s ? i : r;
}
var KF = JF;
function e3(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var Yr, t3 = class {
  constructor(e) {
    IF(this, Yr, void 0), NF(this, Yr, new Set(e));
  }
  getLeadingWhitespaceCount(e) {
    let r = dn(this, Yr), i = 0;
    for (let n = 0; n < e.length && r.has(e.charAt(n)); n++)
      i++;
    return i;
  }
  getTrailingWhitespaceCount(e) {
    let r = dn(this, Yr), i = 0;
    for (let n = e.length - 1; n >= 0 && r.has(e.charAt(n)); n--)
      i++;
    return i;
  }
  getLeadingWhitespace(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(0, r);
  }
  getTrailingWhitespace(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(e.length - r);
  }
  hasLeadingWhitespace(e) {
    return dn(this, Yr).has(e.charAt(0));
  }
  hasTrailingWhitespace(e) {
    return dn(this, Yr).has(xl(!1, e, -1));
  }
  trimStart(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(r);
  }
  trimEnd(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(0, e.length - r);
  }
  trim(e) {
    return this.trimEnd(this.trimStart(e));
  }
  split(e, r = !1) {
    let i = `[${e3([...dn(this, Yr)].join(""))}]+`, n = new RegExp(r ? `(${i})` : i);
    return e.split(n);
  }
  hasWhitespaceCharacter(e) {
    let r = dn(this, Yr);
    return Array.prototype.some.call(e, (i) => r.has(i));
  }
  hasNonWhitespaceCharacter(e) {
    let r = dn(this, Yr);
    return Array.prototype.some.call(e, (i) => !r.has(i));
  }
  isWhitespaceOnly(e) {
    let r = dn(this, Yr);
    return Array.prototype.every.call(e, (i) => r.has(i));
  }
};
Yr = /* @__PURE__ */ new WeakMap();
var r3 = t3, i3 = ["	", `
`, "\f", "\r", " "], n3 = new r3(i3), ki = n3, s3 = class extends Error {
  constructor(r, i, n = "type") {
    super(`Unexpected ${i} node ${n}: ${JSON.stringify(r[n])}.`);
    Ur(this, "name", "UnexpectedNodeError");
    this.node = r;
  }
}, a3 = s3;
function o3(t) {
  return (t == null ? void 0 : t.type) === "front-matter";
}
var oh = o3, l3 = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "keySpan", "tagDefinition", "tokens", "valueTokens", "switchValueSourceSpan", "expSourceSpan", "valueSourceSpan"]), u3 = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function wD(t, e) {
  var r;
  if (t.type === "text" || t.type === "comment" || oh(t) || t.type === "yaml" || t.type === "toml")
    return null;
  if (t.type === "attribute" && delete e.value, t.type === "docType" && delete e.value, t.type === "angularControlFlowBlock" && (r = e.parameters) != null && r.children)
    for (let i of e.parameters.children)
      u3.has(t.name) ? delete i.expression : i.expression = i.expression.trim();
  t.type === "angularIcuExpression" && (e.switchValue = t.switchValue.trim());
}
wD.ignoredProperties = l3;
var c3 = wD;
async function h3(t, e) {
  if (t.lang === "yaml") {
    let r = t.value.trim(), i = r ? await e(r, { parser: "yaml" }) : "";
    return qF([t.startDelimiter, rt, i, i ? rt : "", t.endDelimiter]);
  }
}
var p3 = h3;
function lh(t, e = !0) {
  return [an([Rt, t]), e ? Rt : ""];
}
function Na(t, e) {
  let r = t.type === "NGRoot" ? t.node.type === "NGMicrosyntax" && t.node.body.length === 1 && t.node.body[0].type === "NGMicrosyntaxExpression" ? t.node.body[0].expression : t.node : t.type === "JsExpressionRoot" ? t.node : t;
  return r && (r.type === "ObjectExpression" || r.type === "ArrayExpression" || (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && (r.type === "TemplateLiteral" || r.type === "StringLiteral"));
}
async function Ti(t, e, r, i) {
  r = { __isInHtmlAttribute: !0, __embeddedInHtml: !0, ...r };
  let n = !0;
  i && (r.__onHtmlBindingRoot = (a, l) => {
    n = i(a, l);
  });
  let s = await e(t, r, e);
  return n ? Wt(s) : lh(s);
}
function d3(t, e, r, i) {
  let { node: n } = r, s = i.originalText.slice(n.sourceSpan.start.offset, n.sourceSpan.end.offset);
  return /^\s*$/.test(s) ? "" : Ti(s, t, { parser: "__ng_directive", __isInHtmlAttribute: !1, trailingComma: "none" }, Na);
}
var f3 = d3, m3 = (t) => String(t).split(/[/\\]/).pop();
function o0(t, e) {
  if (!e)
    return;
  let r = m3(e).toLowerCase();
  return t.find(({ filenames: i }) => i == null ? void 0 : i.some((n) => n.toLowerCase() === r)) ?? t.find(({ extensions: i }) => i == null ? void 0 : i.some((n) => r.endsWith(n)));
}
function g3(t, e) {
  if (e)
    return t.find(({ name: r }) => r.toLowerCase() === e) ?? t.find(({ aliases: r }) => r == null ? void 0 : r.includes(e)) ?? t.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${e}`));
}
function y3(t, e) {
  let r = t.plugins.flatMap((n) => n.languages ?? []), i = g3(r, e.language) ?? o0(r, e.physicalFile) ?? o0(r, e.file) ?? (e.physicalFile, void 0);
  return i == null ? void 0 : i.parsers[0];
}
var uh = y3, O3 = "inline", x3 = { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", style: "none", template: "inline", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", dialog: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", search: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", menu: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", input: "inline-block", button: "inline-block", fieldset: "block", marquee: "inline-block", source: "block", track: "block", details: "block", summary: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, D3 = "normal", b3 = { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" };
function v3(t) {
  return t.type === "element" && !t.hasExplicitNamespace && !["html", "svg"].includes(t.namespace);
}
var Vo = v3, w3 = (t) => vr(!1, t, /^[\t\f\r ]*\n/g, ""), SD = (t) => w3(ki.trimEnd(t)), S3 = (t) => {
  let e = t, r = ki.getLeadingWhitespace(e);
  r && (e = e.slice(r.length));
  let i = ki.getTrailingWhitespace(e);
  return i && (e = e.slice(0, -i.length)), { leadingWhitespace: r, trailingWhitespace: i, text: e };
};
function CD(t, e) {
  return !!(t.type === "ieConditionalComment" && t.lastChild && !t.lastChild.isSelfClosing && !t.lastChild.endSourceSpan || t.type === "ieConditionalComment" && !t.complete || va(t) && t.children.some((r) => r.type !== "text" && r.type !== "interpolation") || Dm(t, e) && !Xi(t) && t.type !== "interpolation");
}
function ch(t) {
  return t.type === "attribute" || !t.parent || !t.prev ? !1 : C3(t.prev);
}
function C3(t) {
  return t.type === "comment" && t.value.trim() === "prettier-ignore";
}
function Fr(t) {
  return t.type === "text" || t.type === "comment";
}
function Xi(t) {
  return t.type === "element" && (t.fullName === "script" || t.fullName === "style" || t.fullName === "svg:style" || t.fullName === "svg:script" || Vo(t) && (t.name === "script" || t.name === "style"));
}
function E3(t) {
  return t.children && !Xi(t);
}
function A3(t) {
  return Xi(t) || t.type === "interpolation" || ED(t);
}
function ED(t) {
  return BD(t).startsWith("pre");
}
function k3(t, e) {
  var r, i;
  let n = s();
  if (n && !t.prev && (i = (r = t.parent) == null ? void 0 : r.tagDefinition) != null && i.ignoreFirstLf)
    return t.type === "interpolation";
  return n;
  function s() {
    return oh(t) || t.type === "angularControlFlowBlock" ? !1 : (t.type === "text" || t.type === "interpolation") && t.prev && (t.prev.type === "text" || t.prev.type === "interpolation") ? !0 : !t.parent || t.parent.cssDisplay === "none" ? !1 : va(t.parent) ? !0 : !(!t.prev && (t.parent.type === "root" || va(t) && t.parent || Xi(t.parent) || hh(t.parent, e) || !M3(t.parent.cssDisplay)) || t.prev && !j3(t.prev.cssDisplay));
  }
}
function T3(t, e) {
  return oh(t) || t.type === "angularControlFlowBlock" ? !1 : (t.type === "text" || t.type === "interpolation") && t.next && (t.next.type === "text" || t.next.type === "interpolation") ? !0 : !t.parent || t.parent.cssDisplay === "none" ? !1 : va(t.parent) ? !0 : !(!t.next && (t.parent.type === "root" || va(t) && t.parent || Xi(t.parent) || hh(t.parent, e) || !L3(t.parent.cssDisplay)) || t.next && !Q3(t.next.cssDisplay));
}
function P3(t) {
  return R3(t.cssDisplay) && !Xi(t);
}
function ru(t) {
  return oh(t) || t.next && t.sourceSpan.end && t.sourceSpan.end.line + 1 < t.next.sourceSpan.start.line;
}
function F3(t) {
  return AD(t) || t.type === "element" && t.children.length > 0 && (["body", "script", "style"].includes(t.name) || t.children.some((e) => B3(e))) || t.firstChild && t.firstChild === t.lastChild && t.firstChild.type !== "text" && TD(t.firstChild) && (!t.lastChild.isTrailingSpaceSensitive || PD(t.lastChild));
}
function AD(t) {
  return t.type === "element" && t.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(t.name) || t.cssDisplay.startsWith("table") && t.cssDisplay !== "table-cell");
}
function pp(t) {
  return FD(t) || t.prev && $3(t.prev) || kD(t);
}
function $3(t) {
  return FD(t) || t.type === "element" && t.fullName === "br" || kD(t);
}
function kD(t) {
  return TD(t) && PD(t);
}
function TD(t) {
  return t.hasLeadingSpaces && (t.prev ? t.prev.sourceSpan.end.line < t.sourceSpan.start.line : t.parent.type === "root" || t.parent.startSourceSpan.end.line < t.sourceSpan.start.line);
}
function PD(t) {
  return t.hasTrailingSpaces && (t.next ? t.next.sourceSpan.start.line > t.sourceSpan.end.line : t.parent.type === "root" || t.parent.endSourceSpan && t.parent.endSourceSpan.start.line > t.sourceSpan.end.line);
}
function FD(t) {
  switch (t.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return !0;
    case "element":
      return ["script", "select"].includes(t.name);
  }
  return !1;
}
function xm(t) {
  return t.lastChild ? xm(t.lastChild) : t;
}
function B3(t) {
  var e;
  return (e = t.children) == null ? void 0 : e.some((r) => r.type !== "text");
}
function $D(t) {
  if (t)
    switch (t) {
      case "module":
      case "text/javascript":
      case "text/babel":
      case "application/javascript":
        return "babel";
      case "application/x-typescript":
        return "typescript";
      case "text/markdown":
        return "markdown";
      case "text/html":
        return "html";
      case "text/x-handlebars-template":
        return "glimmer";
      default:
        if (t.endsWith("json") || t.endsWith("importmap") || t === "speculationrules")
          return "json";
    }
}
function I3(t, e) {
  let { name: r, attrMap: i } = t;
  if (r !== "script" || Object.prototype.hasOwnProperty.call(i, "src"))
    return;
  let { type: n, lang: s } = t.attrMap;
  return !s && !n ? "babel" : uh(e, { language: s }) ?? $D(n);
}
function N3(t, e) {
  if (!Dm(t, e))
    return;
  let { attrMap: r } = t;
  if (Object.prototype.hasOwnProperty.call(r, "src"))
    return;
  let { type: i, lang: n } = r;
  return uh(e, { language: n }) ?? $D(i);
}
function _3(t, e) {
  if (t.name !== "style")
    return;
  let { lang: r } = t.attrMap;
  return r ? uh(e, { language: r }) : "css";
}
function l0(t, e) {
  return I3(t, e) ?? _3(t, e) ?? N3(t, e);
}
function Dl(t) {
  return t === "block" || t === "list-item" || t.startsWith("table");
}
function M3(t) {
  return !Dl(t) && t !== "inline-block";
}
function L3(t) {
  return !Dl(t) && t !== "inline-block";
}
function Q3(t) {
  return !Dl(t);
}
function j3(t) {
  return !Dl(t);
}
function R3(t) {
  return !Dl(t) && t !== "inline-block";
}
function va(t) {
  return BD(t).startsWith("pre");
}
function Z3(t, e) {
  let r = t;
  for (; r; ) {
    if (e(r))
      return !0;
    r = r.parent;
  }
  return !1;
}
function W3(t, e) {
  var r;
  if (_a(t, e))
    return "block";
  if (((r = t.prev) == null ? void 0 : r.type) === "comment") {
    let n = t.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
    if (n)
      return n[1];
  }
  let i = !1;
  if (t.type === "element" && t.namespace === "svg")
    if (Z3(t, (n) => n.fullName === "svg:foreignObject"))
      i = !0;
    else
      return t.name === "svg" ? "inline-block" : "block";
  switch (e.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      return t.type === "element" && (!t.namespace || i || Vo(t)) && x3[t.name] || O3;
  }
}
function BD(t) {
  return t.type === "element" && (!t.namespace || Vo(t)) && b3[t.name] || D3;
}
function q3(t) {
  let e = Number.POSITIVE_INFINITY;
  for (let r of t.split(`
`)) {
    if (r.length === 0)
      continue;
    let i = ki.getLeadingWhitespaceCount(r);
    if (i === 0)
      return 0;
    r.length !== i && i < e && (e = i);
  }
  return e === Number.POSITIVE_INFINITY ? 0 : e;
}
function ID(t, e = q3(t)) {
  return e === 0 ? t : t.split(`
`).map((r) => r.slice(e)).join(`
`);
}
function ND(t) {
  return vr(!1, vr(!1, t, "&apos;", "'"), "&quot;", '"');
}
function qn(t) {
  return ND(t.value);
}
var X3 = /* @__PURE__ */ new Set(["template", "style", "script"]);
function hh(t, e) {
  return _a(t, e) && !X3.has(t.fullName);
}
function _a(t, e) {
  return e.parser === "vue" && t.type === "element" && t.parent.type === "root" && t.fullName.toLowerCase() !== "html";
}
function Dm(t, e) {
  return _a(t, e) && (hh(t, e) || t.attrMap.lang && t.attrMap.lang !== "html");
}
function V3(t) {
  let e = t.fullName;
  return e.charAt(0) === "#" || e === "slot-scope" || e === "v-slot" || e.startsWith("v-slot:");
}
function U3(t, e) {
  let r = t.parent;
  if (!_a(r, e))
    return !1;
  let i = r.fullName, n = t.fullName;
  return i === "script" && n === "setup" || i === "style" && n === "vars";
}
function _D(t, e = t.value) {
  return t.parent.isWhitespaceSensitive ? t.parent.isIndentationSensitive ? ti(e) : ti(ID(SD(e)), rt) : Ia($t, ki.split(e));
}
function MD(t, e) {
  return _a(t, e) && t.name === "script";
}
var LD = /{{(.+?)}}/s;
async function Y3(t, e) {
  let r = [];
  for (let [i, n] of t.split(LD).entries())
    if (i % 2 === 0)
      r.push(ti(n));
    else
      try {
        r.push(Wt(["{{", an([$t, await Ti(n, e, { parser: "__ng_interpolation", __isInHtmlInterpolation: !0, trailingComma: "none" })]), $t, "}}"]));
      } catch {
        r.push("{{", ti(n), "}}");
      }
  return r;
}
function bm({ parser: t }) {
  return (e, r, i) => Ti(qn(i.node), e, { parser: t, trailingComma: "none" }, Na);
}
var z3 = bm({ parser: "__ng_action" }), G3 = bm({ parser: "__ng_binding" }), H3 = bm({ parser: "__ng_directive" });
function J3(t, e) {
  if (e.parser !== "angular")
    return;
  let { node: r } = t, i = r.fullName;
  if (i.startsWith("(") && i.endsWith(")") || i.startsWith("on-"))
    return z3;
  if (i.startsWith("[") && i.endsWith("]") || /^bind(?:on)?-/.test(i) || /^ng-(?:if|show|hide|class|style)$/.test(i))
    return G3;
  if (i.startsWith("*"))
    return H3;
  let n = qn(r);
  if (/^i18n(?:-.+)?$/.test(i))
    return () => lh(vD(_D(r, n.trim())), !n.includes("@@"));
  if (LD.test(n))
    return (s) => Y3(n, s);
}
var K3 = J3;
function e$(t, e) {
  let { node: r } = t, i = qn(r);
  if (r.fullName === "class" && !e.parentParser && !i.includes("{{"))
    return () => i.trim().split(/\s+/).join(" ");
}
var t$ = e$;
function u0(t) {
  return t === "	" || t === `
` || t === "\f" || t === "\r" || t === " ";
}
var r$ = /^[ \t\n\r\u000c]+/, i$ = /^[, \t\n\r\u000c]+/, n$ = /^[^ \t\n\r\u000c]+/, s$ = /[,]+$/, c0 = /^\d+$/, a$ = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
function o$(t) {
  let e = t.length, r, i, n, s, a, l = 0, u;
  function h(y) {
    let O, D = y.exec(t.substring(l));
    if (D)
      return [O] = D, l += O.length, O;
  }
  let p = [];
  for (; ; ) {
    if (h(i$), l >= e) {
      if (p.length === 0)
        throw new Error("Must contain one or more image candidate strings.");
      return p;
    }
    u = l, r = h(n$), i = [], r.slice(-1) === "," ? (r = r.replace(s$, ""), m()) : d();
  }
  function d() {
    for (h(r$), n = "", s = "in descriptor"; ; ) {
      if (a = t.charAt(l), s === "in descriptor")
        if (u0(a))
          n && (i.push(n), n = "", s = "after descriptor");
        else if (a === ",") {
          l += 1, n && i.push(n), m();
          return;
        } else if (a === "(")
          n += a, s = "in parens";
        else if (a === "") {
          n && i.push(n), m();
          return;
        } else
          n += a;
      else if (s === "in parens")
        if (a === ")")
          n += a, s = "in descriptor";
        else if (a === "") {
          i.push(n), m();
          return;
        } else
          n += a;
      else if (s === "after descriptor" && !u0(a))
        if (a === "") {
          m();
          return;
        } else
          s = "in descriptor", l -= 1;
      l += 1;
    }
  }
  function m() {
    let y = !1, O, D, v, w, x = {}, S, k, C, A, P;
    for (w = 0; w < i.length; w++)
      S = i[w], k = S[S.length - 1], C = S.substring(0, S.length - 1), A = parseInt(C, 10), P = parseFloat(C), c0.test(C) && k === "w" ? ((O || D) && (y = !0), A === 0 ? y = !0 : O = A) : a$.test(C) && k === "x" ? ((O || D || v) && (y = !0), P < 0 ? y = !0 : D = P) : c0.test(C) && k === "h" ? ((v || D) && (y = !0), A === 0 ? y = !0 : v = A) : y = !0;
    if (!y)
      x.source = { value: r, startOffset: u }, O && (x.width = { value: O }), D && (x.density = { value: D }), v && (x.height = { value: v }), p.push(x);
    else
      throw new Error(`Invalid srcset descriptor found in "${t}" at "${S}".`);
  }
}
var l$ = o$;
function u$(t) {
  if (t.node.fullName === "srcset" && (t.parent.fullName === "img" || t.parent.fullName === "source"))
    return () => h$(qn(t.node));
}
var QD = { width: "w", height: "h", density: "x" }, c$ = Object.keys(QD);
function h$(t) {
  let e = l$(t), r = c$.filter((p) => e.some((d) => Object.prototype.hasOwnProperty.call(d, p)));
  if (r.length > 1)
    throw new Error("Mixed descriptor in srcset is not supported");
  let [i] = r, n = QD[i], s = e.map((p) => p.source.value), a = Math.max(...s.map((p) => p.length)), l = e.map((p) => p[i] ? String(p[i].value) : ""), u = l.map((p) => {
    let d = p.indexOf(".");
    return d === -1 ? p.length : d;
  }), h = Math.max(...u);
  return lh(Ia([",", $t], s.map((p, d) => {
    let m = [p], y = l[d];
    if (y) {
      let O = a - p.length + 1, D = h - u[d], v = " ".repeat(O + D);
      m.push(ac(v, " "), y + n);
    }
    return m;
  })));
}
var p$ = u$;
function d$(t, e) {
  let { node: r } = t, i = qn(t.node).trim();
  if (r.fullName === "style" && !e.parentParser && !i.includes("{{"))
    return async (n) => lh(await n(i, { parser: "css", __isHTMLStyleAttribute: !0 }));
}
var dp = /* @__PURE__ */ new WeakMap();
function f$(t, e) {
  let { root: r } = t;
  return dp.has(r) || dp.set(r, r.children.some((i) => MD(i, e) && ["ts", "typescript"].includes(i.attrMap.lang))), dp.get(r);
}
var vm = f$;
function m$(t, e, r) {
  let { node: i } = r, n = qn(i);
  return Ti(`type T<${n}> = any`, t, { parser: "babel-ts", __isEmbeddedTypescriptGenericParameters: !0 }, Na);
}
function g$(t, e, { parseWithTs: r }) {
  return Ti(`function _(${t}) {}`, e, { parser: r ? "babel-ts" : "babel", __isVueBindings: !0 });
}
function y$(t) {
  let e = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, r = /^[$_a-z][\w$]*(?:\.[$_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$_a-z][\w$]*])*$/i, i = t.trim();
  return e.test(i) || r.test(i);
}
async function O$(t, e, r, i) {
  let n = qn(r.node), { left: s, operator: a, right: l } = x$(n), u = vm(r, i);
  return [Wt(await Ti(`function _(${s}) {}`, t, { parser: u ? "babel-ts" : "babel", __isVueForBindingLeft: !0 })), " ", a, " ", await Ti(l, t, { parser: u ? "__ts_expression" : "__js_expression" })];
}
function x$(t) {
  let e = /(.*?)\s+(in|of)\s+(.*)/s, r = /,([^,\]}]*)(?:,([^,\]}]*))?$/, i = /^\(|\)$/g, n = t.match(e);
  if (!n)
    return;
  let s = {};
  if (s.for = n[3].trim(), !s.for)
    return;
  let a = vr(!1, n[1].trim(), i, ""), l = a.match(r);
  l ? (s.alias = a.replace(r, ""), s.iterator1 = l[1].trim(), l[2] && (s.iterator2 = l[2].trim())) : s.alias = a;
  let u = [s.alias, s.iterator1, s.iterator2];
  if (!u.some((h, p) => !h && (p === 0 || u.slice(p + 1).some(Boolean))))
    return { left: u.filter(Boolean).join(","), operator: n[2], right: s.for };
}
function D$(t, e) {
  if (e.parser !== "vue")
    return;
  let { node: r } = t, i = r.fullName;
  if (i === "v-for")
    return O$;
  if (i === "generic" && MD(r.parent, e))
    return m$;
  let n = qn(r), s = vm(t, e);
  if (V3(r) || U3(r, e))
    return (a) => g$(n, a, { parseWithTs: s });
  if (i.startsWith("@") || i.startsWith("v-on:"))
    return (a) => b$(n, a, { parseWithTs: s });
  if (i.startsWith(":") || i.startsWith("v-bind:"))
    return (a) => v$(n, a, { parseWithTs: s });
  if (i.startsWith("v-"))
    return (a) => jD(n, a, { parseWithTs: s });
}
function b$(t, e, { parseWithTs: r }) {
  return y$(t) ? jD(t, e, { parseWithTs: r }) : Ti(t, e, { parser: r ? "__vue_ts_event_binding" : "__vue_event_binding" }, Na);
}
function v$(t, e, { parseWithTs: r }) {
  return Ti(t, e, { parser: r ? "__vue_ts_expression" : "__vue_expression" }, Na);
}
function jD(t, e, { parseWithTs: r }) {
  return Ti(t, e, { parser: r ? "__ts_expression" : "__js_expression" }, Na);
}
var w$ = D$;
function S$(t, e) {
  let { node: r } = t;
  if (r.value) {
    if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(e.originalText.slice(r.valueSpan.start.offset, r.valueSpan.end.offset)) || e.parser === "lwc" && r.value.startsWith("{") && r.value.endsWith("}"))
      return [r.rawName, "=", r.value];
    for (let i of [p$, d$, t$, w$, K3]) {
      let n = i(t, e);
      if (n)
        return C$(n);
    }
  }
}
function C$(t) {
  return async (e, r, i, n) => {
    let s = await t(e, r, i, n);
    if (s)
      return s = Om(s, (a) => typeof a == "string" ? vr(!1, a, '"', "&quot;") : a), [i.node.rawName, '="', Wt(s), '"'];
  };
}
var E$ = S$, RD = new Proxy(() => {
}, { get: () => RD }), ZD = RD;
function A$(t) {
  return Array.isArray(t) && t.length > 0;
}
var wm = A$;
function ph(t) {
  return t.sourceSpan.start.offset;
}
function dh(t) {
  return t.sourceSpan.end.offset;
}
function xd(t, e) {
  return [t.isSelfClosing ? "" : k$(t, e), Fo(t, e)];
}
function k$(t, e) {
  return t.lastChild && Uo(t.lastChild) ? "" : [T$(t, e), Sm(t, e)];
}
function Fo(t, e) {
  return (t.next ? gs(t.next) : vl(t.parent)) ? "" : [bl(t, e), ms(t, e)];
}
function T$(t, e) {
  return vl(t) ? bl(t.lastChild, e) : "";
}
function ms(t, e) {
  return Uo(t) ? Sm(t.parent, e) : fh(t) ? Cm(t.next) : "";
}
function Sm(t, e) {
  if (ZD(!t.isSelfClosing), WD(t, e))
    return "";
  switch (t.type) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (t.hasHtmComponentClosingTag)
        return "<//";
    default:
      return `</${t.rawName}`;
  }
}
function bl(t, e) {
  if (WD(t, e))
    return "";
  switch (t.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "angularIcuExpression":
      return "}";
    case "element":
      if (t.isSelfClosing)
        return "/>";
    default:
      return ">";
  }
}
function WD(t, e) {
  return !t.isSelfClosing && !t.endSourceSpan && (ch(t) || CD(t.parent, e));
}
function gs(t) {
  return t.prev && t.prev.type !== "docType" && t.type !== "angularControlFlowBlock" && !Fr(t.prev) && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
}
function vl(t) {
  var e;
  return ((e = t.lastChild) == null ? void 0 : e.isTrailingSpaceSensitive) && !t.lastChild.hasTrailingSpaces && !Fr(xm(t.lastChild)) && !va(t);
}
function Uo(t) {
  return !t.next && !t.hasTrailingSpaces && t.isTrailingSpaceSensitive && Fr(xm(t));
}
function fh(t) {
  return t.next && !Fr(t.next) && Fr(t) && t.isTrailingSpaceSensitive && !t.hasTrailingSpaces;
}
function P$(t) {
  let e = t.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
  return e ? e[1] ? e[1].split(/\s+/) : !0 : !1;
}
function mh(t) {
  return !t.prev && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
}
function F$(t, e, r) {
  var i;
  let { node: n } = t;
  if (!wm(n.attrs))
    return n.isSelfClosing ? " " : "";
  let s = ((i = n.prev) == null ? void 0 : i.type) === "comment" && P$(n.prev.value), a = typeof s == "boolean" ? () => s : Array.isArray(s) ? (d) => s.includes(d.rawName) : () => !1, l = t.map(({ node: d }) => a(d) ? ti(e.originalText.slice(ph(d), dh(d))) : r(), "attrs"), u = n.type === "element" && n.fullName === "script" && n.attrs.length === 1 && n.attrs[0].fullName === "src" && n.children.length === 0, h = e.singleAttributePerLine && n.attrs.length > 1 && !_a(n, e) ? rt : $t, p = [an([u ? " " : $t, Ia(h, l)])];
  return n.firstChild && mh(n.firstChild) || n.isSelfClosing && vl(n.parent) || u ? p.push(n.isSelfClosing ? " " : "") : p.push(e.bracketSameLine ? n.isSelfClosing ? " " : "" : n.isSelfClosing ? $t : Rt), p;
}
function $$(t) {
  return t.firstChild && mh(t.firstChild) ? "" : Em(t);
}
function Dd(t, e, r) {
  let { node: i } = t;
  return [$o(i, e), F$(t, e, r), i.isSelfClosing ? "" : $$(i)];
}
function $o(t, e) {
  return t.prev && fh(t.prev) ? "" : [ys(t, e), Cm(t)];
}
function ys(t, e) {
  return mh(t) ? Em(t.parent) : gs(t) ? bl(t.prev, e) : "";
}
function Cm(t) {
  switch (t.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${t.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType":
      return t.value === "html" ? "<!doctype" : "<!DOCTYPE";
    case "angularIcuExpression":
      return "{";
    case "element":
      if (t.condition)
        return `<!--[if ${t.condition}]><!--><${t.rawName}`;
    default:
      return `<${t.rawName}`;
  }
}
function Em(t) {
  switch (ZD(!t.isSelfClosing), t.type) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (t.condition)
        return "><!--<![endif]-->";
    default:
      return ">";
  }
}
function B$(t, e) {
  if (!t.endSourceSpan)
    return "";
  let r = t.startSourceSpan.end.offset;
  t.firstChild && mh(t.firstChild) && (r -= Em(t).length);
  let i = t.endSourceSpan.start.offset;
  return t.lastChild && Uo(t.lastChild) ? i += Sm(t, e).length : vl(t) && (i -= bl(t.lastChild, e).length), e.originalText.slice(r, i);
}
var qD = B$, I$ = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function N$(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "element":
      if (Xi(r) || r.type === "interpolation")
        return;
      if (!r.isSelfClosing && Dm(r, e)) {
        let i = l0(r, e);
        return i ? async (n, s) => {
          let a = qD(r, e), l = /^\s*$/.test(a), u = "";
          return l || (u = await n(SD(a), { parser: i, __embeddedInHtml: !0 }), l = u === ""), [ys(r, e), Wt(Dd(t, e, s)), l ? "" : rt, u, l ? "" : rt, xd(r, e), ms(r, e)];
        } : void 0;
      }
      break;
    case "text":
      if (Xi(r.parent)) {
        let i = l0(r.parent, e);
        if (i)
          return async (n) => {
            let s = i === "markdown" ? ID(r.value.replace(/^[^\S\n]*\n/, "")) : r.value, a = { parser: i, __embeddedInHtml: !0 };
            if (e.parser === "html" && i === "babel") {
              let l = "script", { attrMap: u } = r.parent;
              u && (u.type === "module" || u.type === "text/babel" && u["data-type"] === "module") && (l = "module"), a.__babelSourceType = l;
            }
            return [Ol, ys(r, e), await n(s, a), ms(r, e)];
          };
      } else if (r.parent.type === "interpolation")
        return async (i) => {
          let n = { __isInHtmlInterpolation: !0, __embeddedInHtml: !0 };
          return e.parser === "angular" ? (n.parser = "__ng_interpolation", n.trailingComma = "none") : e.parser === "vue" ? n.parser = vm(t, e) ? "__vue_ts_expression" : "__vue_expression" : n.parser = "__js_expression", [an([$t, await i(r.value, n)]), r.parent.next && gs(r.parent.next) ? " " : $t];
        };
      break;
    case "attribute":
      return E$(t, e);
    case "front-matter":
      return (i) => p3(r, i);
    case "angularControlFlowBlockParameters":
      return I$.has(t.parent.name) ? f3 : void 0;
  }
}
var _$ = N$, io = null;
function Bo(t) {
  if (io !== null && typeof io.property) {
    let e = io;
    return io = Bo.prototype = null, e;
  }
  return io = Bo.prototype = t ?? /* @__PURE__ */ Object.create(null), new Bo();
}
var M$ = 10;
for (let t = 0; t <= M$; t++)
  Bo();
function L$(t) {
  return Bo(t);
}
function Q$(t, e = "type") {
  L$(t);
  function r(i) {
    let n = i[e], s = t[n];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: i });
    return s;
  }
  return r;
}
var j$ = Q$, R$ = { "front-matter": [], root: ["children"], element: ["attrs", "children"], ieConditionalComment: ["children"], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ["children"], text: ["children"], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ["children", "parameters"], angularControlFlowBlockParameters: ["children"], angularControlFlowBlockParameter: [], angularIcuExpression: ["cases"], angularIcuCase: ["expression"] }, Z$ = R$, W$ = j$(Z$), q$ = W$;
function X$(t) {
  return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(t);
}
function V$(t) {
  return `<!-- @format -->

` + t;
}
var U$ = /* @__PURE__ */ new Map([["if", /* @__PURE__ */ new Set(["else if", "else"])], ["else if", /* @__PURE__ */ new Set(["else if", "else"])], ["for", /* @__PURE__ */ new Set(["empty"])], ["defer", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["placeholder", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["error", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["loading", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])]]);
function XD(t) {
  let e = dh(t);
  return t.type === "element" && !t.endSourceSpan && wm(t.children) ? Math.max(e, XD(xl(!1, t.children, -1))) : e;
}
function no(t, e, r) {
  let i = t.node;
  if (ch(i)) {
    let n = XD(i);
    return [ys(i, e), ti(ki.trimEnd(e.originalText.slice(ph(i) + (i.prev && fh(i.prev) ? Cm(i).length : 0), n - (i.next && gs(i.next) ? bl(i, e).length : 0)))), ms(i, e)];
  }
  return r();
}
function iu(t, e) {
  return Fr(t) && Fr(e) ? t.isTrailingSpaceSensitive ? t.hasTrailingSpaces ? pp(e) ? rt : $t : "" : pp(e) ? rt : Rt : fh(t) && (ch(e) || e.firstChild || e.isSelfClosing || e.type === "element" && e.attrs.length > 0) || t.type === "element" && t.isSelfClosing && gs(e) ? "" : !e.isLeadingSpaceSensitive || pp(e) || gs(e) && t.lastChild && Uo(t.lastChild) && t.lastChild.lastChild && Uo(t.lastChild.lastChild) ? rt : e.hasLeadingSpaces ? $t : Rt;
}
function Am(t, e, r) {
  let { node: i } = t;
  if (AD(i))
    return [Ol, ...t.map((s) => {
      let a = s.node, l = a.prev ? iu(a.prev, a) : "";
      return [l ? [l, ru(a.prev) ? rt : ""] : "", no(s, e, r)];
    }, "children")];
  let n = i.children.map(() => Symbol(""));
  return t.map((s, a) => {
    let l = s.node;
    if (Fr(l)) {
      if (l.prev && Fr(l.prev)) {
        let O = iu(l.prev, l);
        if (O)
          return ru(l.prev) ? [rt, rt, no(s, e, r)] : [O, no(s, e, r)];
      }
      return no(s, e, r);
    }
    let u = [], h = [], p = [], d = [], m = l.prev ? iu(l.prev, l) : "", y = l.next ? iu(l, l.next) : "";
    return m && (ru(l.prev) ? u.push(rt, rt) : m === rt ? u.push(rt) : Fr(l.prev) ? h.push(m) : h.push(ac("", Rt, { groupId: n[a - 1] }))), y && (ru(l) ? Fr(l.next) && d.push(rt, rt) : y === rt ? Fr(l.next) && d.push(rt) : p.push(y)), [...u, Wt([...h, Wt([no(s, e, r), ...p], { id: n[a] })]), ...d];
  }, "children");
}
function Y$(t, e, r) {
  let { node: i } = t, n = [];
  z$(t) && n.push("} "), n.push("@", i.name), i.parameters && n.push(" (", Wt(r("parameters")), ")"), n.push(" {");
  let s = VD(i);
  return i.children.length > 0 ? (i.firstChild.hasLeadingSpaces = !0, i.lastChild.hasTrailingSpaces = !0, n.push(an([rt, Am(t, e, r)])), s && n.push(rt, "}")) : s && n.push("}"), Wt(n, { shouldBreak: !0 });
}
function VD(t) {
  var e, r;
  return !(((e = t.next) == null ? void 0 : e.type) === "angularControlFlowBlock" && (r = U$.get(t.name)) != null && r.has(t.next.name));
}
function z$(t) {
  let { previous: e } = t;
  return (e == null ? void 0 : e.type) === "angularControlFlowBlock" && !ch(e) && !VD(e);
}
function G$(t, e, r) {
  return [an([Rt, Ia([";", $t], t.map(r, "children"))]), Rt];
}
function H$(t, e, r) {
  let { node: i } = t;
  return [$o(i, e), Wt([i.switchValue.trim(), ", ", i.clause, i.cases.length > 0 ? [",", an([$t, Ia($t, t.map(r, "cases"))])] : "", Rt]), Fo(i, e)];
}
function J$(t, e, r) {
  let { node: i } = t;
  return [i.value, " {", Wt([an([Rt, t.map(({ node: n }) => n.type === "text" && !ki.trim(n.value) ? "" : r(), "expression")]), Rt]), "}"];
}
function K$(t, e, r) {
  let { node: i } = t;
  if (CD(i, e))
    return [ys(i, e), Wt(Dd(t, e, r)), ti(qD(i, e)), ...xd(i, e), ms(i, e)];
  let n = i.children.length === 1 && (i.firstChild.type === "interpolation" || i.firstChild.type === "angularIcuExpression") && i.firstChild.isLeadingSpaceSensitive && !i.firstChild.hasLeadingSpaces && i.lastChild.isTrailingSpaceSensitive && !i.lastChild.hasTrailingSpaces, s = Symbol("element-attr-group-id"), a = (p) => Wt([Wt(Dd(t, e, r), { id: s }), p, xd(i, e)]), l = (p) => n ? XF(p, { groupId: s }) : (Xi(i) || hh(i, e)) && i.parent.type === "root" && e.parser === "vue" && !e.vueIndentScriptAndStyle ? p : an(p), u = () => n ? ac(Rt, "", { groupId: s }) : i.firstChild.hasLeadingSpaces && i.firstChild.isLeadingSpaceSensitive ? $t : i.firstChild.type === "text" && i.isWhitespaceSensitive && i.isIndentationSensitive ? WF(Rt) : Rt, h = () => (i.next ? gs(i.next) : vl(i.parent)) ? i.lastChild.hasTrailingSpaces && i.lastChild.isTrailingSpaceSensitive ? " " : "" : n ? ac(Rt, "", { groupId: s }) : i.lastChild.hasTrailingSpaces && i.lastChild.isTrailingSpaceSensitive ? $t : (i.lastChild.type === "comment" || i.lastChild.type === "text" && i.isWhitespaceSensitive && i.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${e.tabWidth * (t.ancestors.length - 1)}}$`).test(i.lastChild.value) ? "" : Rt;
  return i.children.length === 0 ? a(i.hasDanglingSpaces && i.isDanglingSpaceSensitive ? $t : "") : a([F3(i) ? Ol : "", l([u(), Am(t, e, r)]), h()]);
}
function km(t) {
  return t >= 9 && t <= 32 || t == 160;
}
function UD(t) {
  return 48 <= t && t <= 57;
}
function Tm(t) {
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function eB(t) {
  return t >= 97 && t <= 102 || t >= 65 && t <= 70 || UD(t);
}
function YD(t) {
  return t === 10 || t === 13;
}
function h0(t) {
  return 48 <= t && t <= 55;
}
function p0(t) {
  return t === 39 || t === 34 || t === 96;
}
var tB = /-+([a-z0-9])/g;
function rB(t) {
  return t.replace(tB, (...e) => e[1].toUpperCase());
}
var bd = class zD {
  constructor(e, r, i, n) {
    this.file = e, this.offset = r, this.line = i, this.col = n;
  }
  toString() {
    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
  }
  moveBy(e) {
    let r = this.file.content, i = r.length, n = this.offset, s = this.line, a = this.col;
    for (; n > 0 && e < 0; )
      if (n--, e++, r.charCodeAt(n) == 10) {
        s--;
        let l = r.substring(0, n - 1).lastIndexOf(`
`);
        a = l > 0 ? n - l : n;
      } else
        a--;
    for (; n < i && e > 0; ) {
      let l = r.charCodeAt(n);
      n++, e--, l == 10 ? (s++, a = 0) : a++;
    }
    return new zD(this.file, n, s, a);
  }
  getContext(e, r) {
    let i = this.file.content, n = this.offset;
    if (n != null) {
      n > i.length - 1 && (n = i.length - 1);
      let s = n, a = 0, l = 0;
      for (; a < e && n > 0 && (n--, a++, !(i[n] == `
` && ++l == r)); )
        ;
      for (a = 0, l = 0; a < e && s < i.length - 1 && (s++, a++, !(i[s] == `
` && ++l == r)); )
        ;
      return { before: i.substring(n, this.offset), after: i.substring(this.offset, s + 1) };
    }
    return null;
  }
}, GD = class {
  constructor(e, r) {
    this.content = e, this.url = r;
  }
}, _e = class {
  constructor(t, e, r = t, i = null) {
    this.start = t, this.end = e, this.fullStart = r, this.details = i;
  }
  toString() {
    return this.start.file.content.substring(this.start.offset, this.end.offset);
  }
}, oc;
(function(t) {
  t[t.WARNING = 0] = "WARNING", t[t.ERROR = 1] = "ERROR";
})(oc || (oc = {}));
var HD = class {
  constructor(e, r, i = oc.ERROR) {
    this.span = e, this.msg = r, this.level = i;
  }
  contextualMessage() {
    let e = this.span.start.getContext(100, 3);
    return e ? `${this.msg} ("${e.before}[${oc[this.level]} ->]${e.after}")` : this.msg;
  }
  toString() {
    let e = this.span.details ? `, ${this.span.details}` : "";
    return `${this.contextualMessage()}: ${this.span.start}${e}`;
  }
}, iB = [sB, aB, lB, cB, hB, fB, pB, dB, mB, uB];
function nB(t, e) {
  for (let r of iB)
    r(t, e);
  return t;
}
function sB(t) {
  t.walk((e) => {
    if (e.type === "element" && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && e.children[0].type === "text" && e.children[0].value[0] === `
`) {
      let r = e.children[0];
      r.value.length === 1 ? e.removeChild(r) : r.value = r.value.slice(1);
    }
  });
}
function aB(t) {
  let e = (r) => {
    var i, n;
    return r.type === "element" && ((i = r.prev) == null ? void 0 : i.type) === "ieConditionalStartComment" && r.prev.sourceSpan.end.offset === r.startSourceSpan.start.offset && ((n = r.firstChild) == null ? void 0 : n.type) === "ieConditionalEndComment" && r.firstChild.sourceSpan.start.offset === r.startSourceSpan.end.offset;
  };
  t.walk((r) => {
    if (r.children)
      for (let i = 0; i < r.children.length; i++) {
        let n = r.children[i];
        if (!e(n))
          continue;
        let s = n.prev, a = n.firstChild;
        r.removeChild(s), i--;
        let l = new _e(s.sourceSpan.start, a.sourceSpan.end), u = new _e(l.start, n.sourceSpan.end);
        n.condition = s.condition, n.sourceSpan = u, n.startSourceSpan = l, n.removeChild(a);
      }
  });
}
function oB(t, e, r) {
  t.walk((i) => {
    if (i.children)
      for (let n = 0; n < i.children.length; n++) {
        let s = i.children[n];
        if (s.type !== "text" && !e(s))
          continue;
        s.type !== "text" && (s.type = "text", s.value = r(s));
        let a = s.prev;
        !a || a.type !== "text" || (a.value += s.value, a.sourceSpan = new _e(a.sourceSpan.start, s.sourceSpan.end), i.removeChild(s), n--);
      }
  });
}
function lB(t) {
  return oB(t, (e) => e.type === "cdata", (e) => `<![CDATA[${e.value}]]>`);
}
function uB(t) {
  let e = (r) => {
    var i, n;
    return r.type === "element" && r.attrs.length === 0 && r.children.length === 1 && r.firstChild.type === "text" && !ki.hasWhitespaceCharacter(r.children[0].value) && !r.firstChild.hasLeadingSpaces && !r.firstChild.hasTrailingSpaces && r.isLeadingSpaceSensitive && !r.hasLeadingSpaces && r.isTrailingSpaceSensitive && !r.hasTrailingSpaces && ((i = r.prev) == null ? void 0 : i.type) === "text" && ((n = r.next) == null ? void 0 : n.type) === "text";
  };
  t.walk((r) => {
    if (r.children)
      for (let i = 0; i < r.children.length; i++) {
        let n = r.children[i];
        if (!e(n))
          continue;
        let s = n.prev, a = n.next;
        s.value += `<${n.rawName}>` + n.firstChild.value + `</${n.rawName}>` + a.value, s.sourceSpan = new _e(s.sourceSpan.start, a.sourceSpan.end), s.isTrailingSpaceSensitive = a.isTrailingSpaceSensitive, s.hasTrailingSpaces = a.hasTrailingSpaces, r.removeChild(n), i--, r.removeChild(a);
      }
  });
}
function cB(t, e) {
  if (e.parser === "html")
    return;
  let r = /{{(.+?)}}/s;
  t.walk((i) => {
    if (E3(i))
      for (let n of i.children) {
        if (n.type !== "text")
          continue;
        let s = n.sourceSpan.start, a = null, l = n.value.split(r);
        for (let u = 0; u < l.length; u++, s = a) {
          let h = l[u];
          if (u % 2 === 0) {
            a = s.moveBy(h.length), h.length > 0 && i.insertChildBefore(n, { type: "text", value: h, sourceSpan: new _e(s, a) });
            continue;
          }
          a = s.moveBy(h.length + 4), i.insertChildBefore(n, { type: "interpolation", sourceSpan: new _e(s, a), children: h.length === 0 ? [] : [{ type: "text", value: h, sourceSpan: new _e(s.moveBy(2), a.moveBy(-2)) }] });
        }
        i.removeChild(n);
      }
  });
}
function hB(t) {
  t.walk((e) => {
    if (!e.children)
      return;
    if (e.children.length === 0 || e.children.length === 1 && e.children[0].type === "text" && ki.trim(e.children[0].value).length === 0) {
      e.hasDanglingSpaces = e.children.length > 0, e.children = [];
      return;
    }
    let r = A3(e), i = ED(e);
    if (!r)
      for (let n = 0; n < e.children.length; n++) {
        let s = e.children[n];
        if (s.type !== "text")
          continue;
        let { leadingWhitespace: a, text: l, trailingWhitespace: u } = S3(s.value), h = s.prev, p = s.next;
        l ? (s.value = l, s.sourceSpan = new _e(s.sourceSpan.start.moveBy(a.length), s.sourceSpan.end.moveBy(-u.length)), a && (h && (h.hasTrailingSpaces = !0), s.hasLeadingSpaces = !0), u && (s.hasTrailingSpaces = !0, p && (p.hasLeadingSpaces = !0))) : (e.removeChild(s), n--, (a || u) && (h && (h.hasTrailingSpaces = !0), p && (p.hasLeadingSpaces = !0)));
      }
    e.isWhitespaceSensitive = r, e.isIndentationSensitive = i;
  });
}
function pB(t) {
  t.walk((e) => {
    e.isSelfClosing = !e.children || e.type === "element" && (e.tagDefinition.isVoid || e.endSourceSpan && e.startSourceSpan.start === e.endSourceSpan.start && e.startSourceSpan.end === e.endSourceSpan.end);
  });
}
function dB(t, e) {
  t.walk((r) => {
    r.type === "element" && (r.hasHtmComponentClosingTag = r.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(e.originalText.slice(r.endSourceSpan.start.offset, r.endSourceSpan.end.offset)));
  });
}
function fB(t, e) {
  t.walk((r) => {
    r.cssDisplay = W3(r, e);
  });
}
function mB(t, e) {
  t.walk((r) => {
    let { children: i } = r;
    if (i) {
      if (i.length === 0) {
        r.isDanglingSpaceSensitive = P3(r);
        return;
      }
      for (let n of i)
        n.isLeadingSpaceSensitive = k3(n, e), n.isTrailingSpaceSensitive = T3(n, e);
      for (let n = 0; n < i.length; n++) {
        let s = i[n];
        s.isLeadingSpaceSensitive = (n === 0 || s.prev.isTrailingSpaceSensitive) && s.isLeadingSpaceSensitive, s.isTrailingSpaceSensitive = (n === i.length - 1 || s.next.isLeadingSpaceSensitive) && s.isTrailingSpaceSensitive;
      }
    }
  });
}
var gB = nB;
function yB(t, e, r) {
  let { node: i } = t;
  switch (i.type) {
    case "front-matter":
      return ti(i.raw);
    case "root":
      return e.__onHtmlRoot && e.__onHtmlRoot(i), [Wt(Am(t, e, r)), rt];
    case "element":
    case "ieConditionalComment":
      return K$(t, e, r);
    case "angularControlFlowBlock":
      return Y$(t, e, r);
    case "angularControlFlowBlockParameters":
      return G$(t, e, r);
    case "angularControlFlowBlockParameter":
      return ki.trim(i.expression);
    case "angularIcuExpression":
      return H$(t, e, r);
    case "angularIcuCase":
      return J$(t, e, r);
    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return [$o(i), Fo(i)];
    case "interpolation":
      return [$o(i, e), ...t.map(r, "children"), Fo(i, e)];
    case "text": {
      if (i.parent.type === "interpolation") {
        let s = /\n[^\S\n]*$/, a = s.test(i.value), l = a ? i.value.replace(s, "") : i.value;
        return [ti(l), a ? rt : ""];
      }
      let n = HF([ys(i, e), ..._D(i), ms(i, e)]);
      return Array.isArray(n) ? vD(n) : n;
    }
    case "docType":
      return [Wt([$o(i, e), " ", vr(!1, i.value.replace(/^html\b/i, "html"), /\s+/g, " ")]), Fo(i, e)];
    case "comment":
      return [ys(i, e), ti(e.originalText.slice(ph(i), dh(i))), ms(i, e)];
    case "attribute": {
      if (i.value === null)
        return i.rawName;
      let n = ND(i.value), s = KF(n, '"');
      return [i.rawName, "=", s, ti(s === '"' ? vr(!1, n, '"', "&quot;") : vr(!1, n, "'", "&apos;")), s];
    }
    case "cdata":
    default:
      throw new a3(i, "HTML");
  }
}
var OB = { preprocess: gB, print: yB, insertPragma: V$, massageAstNode: c3, embed: _$, getVisitorKeys: q$ }, xB = OB, DB = [{ linguistLanguageId: 146, name: "Angular", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".component.html"], parsers: ["angular"], vscodeLanguageIds: ["html"], filenames: [] }, { linguistLanguageId: 146, name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml", ".mjml"], parsers: ["html"], vscodeLanguageIds: ["html"] }, { linguistLanguageId: 146, name: "Lightning Web Components", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [], parsers: ["lwc"], vscodeLanguageIds: ["html"], filenames: [] }, { linguistLanguageId: 391, name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", parsers: ["vue"], vscodeLanguageIds: ["vue"] }], d0 = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, f0 = "HTML", bB = { bracketSameLine: d0.bracketSameLine, htmlWhitespaceSensitivity: { category: f0, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: d0.singleAttributePerLine, vueIndentScriptAndStyle: { category: f0, type: "boolean", default: !1, description: "Indent script and style tags in Vue files." } }, vB = bB, JD = {};
gD(JD, { angular: () => S8, html: () => w8, lwc: () => E8, vue: () => C8 });
var m0;
(function(t) {
  t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom";
})(m0 || (m0 = {}));
var g0;
(function(t) {
  t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default";
})(g0 || (g0 = {}));
var y0 = { name: "custom-elements" }, O0 = { name: "no-errors-schema" }, ss;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL";
})(ss || (ss = {}));
var x0;
(function(t) {
  t[t.Error = 0] = "Error", t[t.Warning = 1] = "Warning", t[t.Ignore = 2] = "Ignore";
})(x0 || (x0 = {}));
var ei;
(function(t) {
  t[t.RAW_TEXT = 0] = "RAW_TEXT", t[t.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", t[t.PARSABLE_DATA = 2] = "PARSABLE_DATA";
})(ei || (ei = {}));
function gh(t) {
  if (t[0] != ":")
    return [null, t];
  let e = t.indexOf(":", 1);
  if (e === -1)
    throw new Error(`Unsupported format "${t}" expecting ":namespace:name"`);
  return [t.slice(1, e), t.slice(e + 1)];
}
function D0(t) {
  return gh(t)[1] === "ng-container";
}
function b0(t) {
  return gh(t)[1] === "ng-content";
}
function Ru(t) {
  return t === null ? null : gh(t)[0];
}
function lc(t, e) {
  return t ? `:${t}:${e}` : e;
}
var Zu;
function v0() {
  return Zu || (Zu = {}, nu(ss.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), nu(ss.STYLE, ["*|style"]), nu(ss.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), nu(ss.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), Zu;
}
function nu(t, e) {
  for (let r of e)
    Zu[r.toLowerCase()] = t;
}
var wB = class {
}, SB = "boolean", CB = "number", EB = "string", AB = "object", kB = ["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|"], KD = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" })), TB = Array.from(KD).reduce((t, [e, r]) => (t.set(e, r), t), /* @__PURE__ */ new Map()), PB = class extends wB {
  constructor() {
    super(), this._schema = /* @__PURE__ */ new Map(), this._eventSchema = /* @__PURE__ */ new Map(), kB.forEach((e) => {
      let r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), [n, s] = e.split("|"), a = s.split(","), [l, u] = n.split("^");
      l.split(",").forEach((p) => {
        this._schema.set(p.toLowerCase(), r), this._eventSchema.set(p.toLowerCase(), i);
      });
      let h = u && this._schema.get(u.toLowerCase());
      if (h) {
        for (let [p, d] of h)
          r.set(p, d);
        for (let p of this._eventSchema.get(u.toLowerCase()))
          i.add(p);
      }
      a.forEach((p) => {
        if (p.length > 0)
          switch (p[0]) {
            case "*":
              i.add(p.substring(1));
              break;
            case "!":
              r.set(p.substring(1), SB);
              break;
            case "#":
              r.set(p.substring(1), CB);
              break;
            case "%":
              r.set(p.substring(1), AB);
              break;
            default:
              r.set(p, EB);
          }
      });
    });
  }
  hasProperty(e, r, i) {
    if (i.some((n) => n.name === O0.name))
      return !0;
    if (e.indexOf("-") > -1) {
      if (D0(e) || b0(e))
        return !1;
      if (i.some((n) => n.name === y0.name))
        return !0;
    }
    return (this._schema.get(e.toLowerCase()) || this._schema.get("unknown")).has(r);
  }
  hasElement(e, r) {
    return r.some((i) => i.name === O0.name) || e.indexOf("-") > -1 && (D0(e) || b0(e) || r.some((i) => i.name === y0.name)) ? !0 : this._schema.has(e.toLowerCase());
  }
  securityContext(e, r, i) {
    i && (r = this.getMappedPropName(r)), e = e.toLowerCase(), r = r.toLowerCase();
    let n = v0()[e + "|" + r];
    return n || (n = v0()["*|" + r], n || ss.NONE);
  }
  getMappedPropName(e) {
    return KD.get(e) ?? e;
  }
  getDefaultComponentElementName() {
    return "ng-component";
  }
  validateProperty(e) {
    return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...
If '${e}' is a directive input, make sure the directive is imported by the current module.` } : { error: !1 };
  }
  validateAttribute(e) {
    return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...` } : { error: !1 };
  }
  allKnownElementNames() {
    return Array.from(this._schema.keys());
  }
  allKnownAttributesOfElement(e) {
    let r = this._schema.get(e.toLowerCase()) || this._schema.get("unknown");
    return Array.from(r.keys()).map((i) => TB.get(i) ?? i);
  }
  allKnownEventsOfElement(e) {
    return Array.from(this._eventSchema.get(e.toLowerCase()) ?? []);
  }
  normalizeAnimationStyleProperty(e) {
    return rB(e);
  }
  normalizeAnimationStyleValue(e, r, i) {
    let n = "", s = i.toString().trim(), a = null;
    if (FB(e) && i !== 0 && i !== "0")
      if (typeof i == "number")
        n = "px";
      else {
        let l = i.match(/^[+-]?[\d\.]+([a-z]*)$/);
        l && l[1].length == 0 && (a = `Please provide a CSS unit value for ${r}:${i}`);
      }
    return { error: a, value: s + n };
  }
};
function FB(t) {
  switch (t) {
    case "width":
    case "height":
    case "minWidth":
    case "minHeight":
    case "maxWidth":
    case "maxHeight":
    case "left":
    case "top":
    case "bottom":
    case "right":
    case "fontSize":
    case "outlineWidth":
    case "outlineOffset":
    case "paddingTop":
    case "paddingLeft":
    case "paddingBottom":
    case "paddingRight":
    case "marginTop":
    case "marginLeft":
    case "marginBottom":
    case "marginRight":
    case "borderRadius":
    case "borderWidth":
    case "borderTopWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderBottomWidth":
    case "textIndent":
      return !0;
    default:
      return !1;
  }
}
var Se = class {
  constructor({ closedByChildren: t, implicitNamespacePrefix: e, contentType: r = ei.PARSABLE_DATA, closedByParent: i = !1, isVoid: n = !1, ignoreFirstLf: s = !1, preventNamespaceInheritance: a = !1, canSelfClose: l = !1 } = {}) {
    this.closedByChildren = {}, this.closedByParent = !1, t && t.length > 0 && t.forEach((u) => this.closedByChildren[u] = !0), this.isVoid = n, this.closedByParent = i || n, this.implicitNamespacePrefix = e || null, this.contentType = r, this.ignoreFirstLf = s, this.preventNamespaceInheritance = a, this.canSelfClose = l ?? n;
  }
  isClosedByChild(t) {
    return this.isVoid || t.toLowerCase() in this.closedByChildren;
  }
  getContentType(t) {
    return typeof this.contentType == "object" ? (t === void 0 ? void 0 : this.contentType[t]) ?? this.contentType.default : this.contentType;
  }
}, w0, so;
function vd(t) {
  return so || (w0 = new Se({ canSelfClose: !0 }), so = Object.assign(/* @__PURE__ */ Object.create(null), { base: new Se({ isVoid: !0 }), meta: new Se({ isVoid: !0 }), area: new Se({ isVoid: !0 }), embed: new Se({ isVoid: !0 }), link: new Se({ isVoid: !0 }), img: new Se({ isVoid: !0 }), input: new Se({ isVoid: !0 }), param: new Se({ isVoid: !0 }), hr: new Se({ isVoid: !0 }), br: new Se({ isVoid: !0 }), source: new Se({ isVoid: !0 }), track: new Se({ isVoid: !0 }), wbr: new Se({ isVoid: !0 }), p: new Se({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: !0 }), thead: new Se({ closedByChildren: ["tbody", "tfoot"] }), tbody: new Se({ closedByChildren: ["tbody", "tfoot"], closedByParent: !0 }), tfoot: new Se({ closedByChildren: ["tbody"], closedByParent: !0 }), tr: new Se({ closedByChildren: ["tr"], closedByParent: !0 }), td: new Se({ closedByChildren: ["td", "th"], closedByParent: !0 }), th: new Se({ closedByChildren: ["td", "th"], closedByParent: !0 }), col: new Se({ isVoid: !0 }), svg: new Se({ implicitNamespacePrefix: "svg" }), foreignObject: new Se({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: !0 }), math: new Se({ implicitNamespacePrefix: "math" }), li: new Se({ closedByChildren: ["li"], closedByParent: !0 }), dt: new Se({ closedByChildren: ["dt", "dd"] }), dd: new Se({ closedByChildren: ["dt", "dd"], closedByParent: !0 }), rb: new Se({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rt: new Se({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rtc: new Se({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: !0 }), rp: new Se({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), optgroup: new Se({ closedByChildren: ["optgroup"], closedByParent: !0 }), option: new Se({ closedByChildren: ["option", "optgroup"], closedByParent: !0 }), pre: new Se({ ignoreFirstLf: !0 }), listing: new Se({ ignoreFirstLf: !0 }), style: new Se({ contentType: ei.RAW_TEXT }), script: new Se({ contentType: ei.RAW_TEXT }), title: new Se({ contentType: { default: ei.ESCAPABLE_RAW_TEXT, svg: ei.PARSABLE_DATA } }), textarea: new Se({ contentType: ei.ESCAPABLE_RAW_TEXT, ignoreFirstLf: !0 }) }), new PB().allKnownElementNames().forEach((e) => {
    !so[e] && Ru(e) === null && (so[e] = new Se({ canSelfClose: !1 }));
  })), so[t] ?? w0;
}
var wl = class {
  constructor(e, r) {
    this.sourceSpan = e, this.i18n = r;
  }
}, $B = class extends wl {
  constructor(e, r, i, n) {
    super(r, n), this.value = e, this.tokens = i, this.type = "text";
  }
  visit(e, r) {
    return e.visitText(this, r);
  }
}, BB = class extends wl {
  constructor(e, r, i, n) {
    super(r, n), this.value = e, this.tokens = i, this.type = "cdata";
  }
  visit(e, r) {
    return e.visitCdata(this, r);
  }
}, IB = class extends wl {
  constructor(e, r, i, n, s, a) {
    super(n, a), this.switchValue = e, this.type = r, this.cases = i, this.switchValueSourceSpan = s;
  }
  visit(e, r) {
    return e.visitExpansion(this, r);
  }
}, NB = class {
  constructor(e, r, i, n, s) {
    this.value = e, this.expression = r, this.sourceSpan = i, this.valueSourceSpan = n, this.expSourceSpan = s, this.type = "expansionCase";
  }
  visit(e, r) {
    return e.visitExpansionCase(this, r);
  }
}, _B = class extends wl {
  constructor(e, r, i, n, s, a, l) {
    super(i, l), this.name = e, this.value = r, this.keySpan = n, this.valueSpan = s, this.valueTokens = a, this.type = "attribute";
  }
  visit(e, r) {
    return e.visitAttribute(this, r);
  }
  get nameSpan() {
    return this.keySpan;
  }
}, fn = class extends wl {
  constructor(e, r, i, n, s, a = null, l = null, u) {
    super(n, u), this.name = e, this.attrs = r, this.children = i, this.startSourceSpan = s, this.endSourceSpan = a, this.nameSpan = l, this.type = "element";
  }
  visit(e, r) {
    return e.visitElement(this, r);
  }
}, MB = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "comment";
  }
  visit(e, r) {
    return e.visitComment(this, r);
  }
}, LB = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "docType";
  }
  visit(e, r) {
    return e.visitDocType(this, r);
  }
}, Vs = class {
  constructor(e, r, i, n, s, a = null) {
    this.name = e, this.parameters = r, this.children = i, this.sourceSpan = n, this.startSourceSpan = s, this.endSourceSpan = a, this.type = "block";
  }
  visit(e, r) {
    return e.visitBlock(this, r);
  }
}, S0 = class {
  constructor(e, r) {
    this.expression = e, this.sourceSpan = r, this.type = "blockParameter", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e, r) {
    return e.visitBlockParameter(this, r);
  }
};
function e2(t, e, r = null) {
  let i = [], n = t.visit ? (s) => t.visit(s, r) || s.visit(t, r) : (s) => s.visit(t, r);
  return e.forEach((s) => {
    let a = n(s);
    a && i.push(a);
  }), i;
}
var QB = class {
  constructor() {
  }
  visitElement(e, r) {
    this.visitChildren(r, (i) => {
      i(e.attrs), i(e.children);
    });
  }
  visitAttribute(e, r) {
  }
  visitText(e, r) {
  }
  visitCdata(e, r) {
  }
  visitComment(e, r) {
  }
  visitDocType(e, r) {
  }
  visitExpansion(e, r) {
    return this.visitChildren(r, (i) => {
      i(e.cases);
    });
  }
  visitExpansionCase(e, r) {
  }
  visitBlock(e, r) {
    this.visitChildren(r, (i) => {
      i(e.parameters), i(e.children);
    });
  }
  visitBlockParameter(e, r) {
  }
  visitChildren(e, r) {
    let i = [], n = this;
    function s(a) {
      a && i.push(e2(n, a, e));
    }
    return r(s), Array.prototype.concat.apply([], i);
  }
}, uc = { AElig: "Æ", AMP: "&", amp: "&", Aacute: "Á", Abreve: "Ă", Acirc: "Â", Acy: "А", Afr: "𝔄", Agrave: "À", Alpha: "Α", Amacr: "Ā", And: "⩓", Aogon: "Ą", Aopf: "𝔸", ApplyFunction: "⁡", af: "⁡", Aring: "Å", angst: "Å", Ascr: "𝒜", Assign: "≔", colone: "≔", coloneq: "≔", Atilde: "Ã", Auml: "Ä", Backslash: "∖", setminus: "∖", setmn: "∖", smallsetminus: "∖", ssetmn: "∖", Barv: "⫧", Barwed: "⌆", doublebarwedge: "⌆", Bcy: "Б", Because: "∵", becaus: "∵", because: "∵", Bernoullis: "ℬ", Bscr: "ℬ", bernou: "ℬ", Beta: "Β", Bfr: "𝔅", Bopf: "𝔹", Breve: "˘", breve: "˘", Bumpeq: "≎", HumpDownHump: "≎", bump: "≎", CHcy: "Ч", COPY: "©", copy: "©", Cacute: "Ć", Cap: "⋒", CapitalDifferentialD: "ⅅ", DD: "ⅅ", Cayleys: "ℭ", Cfr: "ℭ", Ccaron: "Č", Ccedil: "Ç", Ccirc: "Ĉ", Cconint: "∰", Cdot: "Ċ", Cedilla: "¸", cedil: "¸", CenterDot: "·", centerdot: "·", middot: "·", Chi: "Χ", CircleDot: "⊙", odot: "⊙", CircleMinus: "⊖", ominus: "⊖", CirclePlus: "⊕", oplus: "⊕", CircleTimes: "⊗", otimes: "⊗", ClockwiseContourIntegral: "∲", cwconint: "∲", CloseCurlyDoubleQuote: "”", rdquo: "”", rdquor: "”", CloseCurlyQuote: "’", rsquo: "’", rsquor: "’", Colon: "∷", Proportion: "∷", Colone: "⩴", Congruent: "≡", equiv: "≡", Conint: "∯", DoubleContourIntegral: "∯", ContourIntegral: "∮", conint: "∮", oint: "∮", Copf: "ℂ", complexes: "ℂ", Coproduct: "∐", coprod: "∐", CounterClockwiseContourIntegral: "∳", awconint: "∳", Cross: "⨯", Cscr: "𝒞", Cup: "⋓", CupCap: "≍", asympeq: "≍", DDotrahd: "⤑", DJcy: "Ђ", DScy: "Ѕ", DZcy: "Џ", Dagger: "‡", ddagger: "‡", Darr: "↡", Dashv: "⫤", DoubleLeftTee: "⫤", Dcaron: "Ď", Dcy: "Д", Del: "∇", nabla: "∇", Delta: "Δ", Dfr: "𝔇", DiacriticalAcute: "´", acute: "´", DiacriticalDot: "˙", dot: "˙", DiacriticalDoubleAcute: "˝", dblac: "˝", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "˜", tilde: "˜", Diamond: "⋄", diam: "⋄", diamond: "⋄", DifferentialD: "ⅆ", dd: "ⅆ", Dopf: "𝔻", Dot: "¨", DoubleDot: "¨", die: "¨", uml: "¨", DotDot: "⃜", DotEqual: "≐", doteq: "≐", esdot: "≐", DoubleDownArrow: "⇓", Downarrow: "⇓", dArr: "⇓", DoubleLeftArrow: "⇐", Leftarrow: "⇐", lArr: "⇐", DoubleLeftRightArrow: "⇔", Leftrightarrow: "⇔", hArr: "⇔", iff: "⇔", DoubleLongLeftArrow: "⟸", Longleftarrow: "⟸", xlArr: "⟸", DoubleLongLeftRightArrow: "⟺", Longleftrightarrow: "⟺", xhArr: "⟺", DoubleLongRightArrow: "⟹", Longrightarrow: "⟹", xrArr: "⟹", DoubleRightArrow: "⇒", Implies: "⇒", Rightarrow: "⇒", rArr: "⇒", DoubleRightTee: "⊨", vDash: "⊨", DoubleUpArrow: "⇑", Uparrow: "⇑", uArr: "⇑", DoubleUpDownArrow: "⇕", Updownarrow: "⇕", vArr: "⇕", DoubleVerticalBar: "∥", par: "∥", parallel: "∥", shortparallel: "∥", spar: "∥", DownArrow: "↓", ShortDownArrow: "↓", darr: "↓", downarrow: "↓", DownArrowBar: "⤓", DownArrowUpArrow: "⇵", duarr: "⇵", DownBreve: "̑", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVector: "↽", leftharpoondown: "↽", lhard: "↽", DownLeftVectorBar: "⥖", DownRightTeeVector: "⥟", DownRightVector: "⇁", rhard: "⇁", rightharpoondown: "⇁", DownRightVectorBar: "⥗", DownTee: "⊤", top: "⊤", DownTeeArrow: "↧", mapstodown: "↧", Dscr: "𝒟", Dstrok: "Đ", ENG: "Ŋ", ETH: "Ð", Eacute: "É", Ecaron: "Ě", Ecirc: "Ê", Ecy: "Э", Edot: "Ė", Efr: "𝔈", Egrave: "È", Element: "∈", in: "∈", isin: "∈", isinv: "∈", Emacr: "Ē", EmptySmallSquare: "◻", EmptyVerySmallSquare: "▫", Eogon: "Ę", Eopf: "𝔼", Epsilon: "Ε", Equal: "⩵", EqualTilde: "≂", eqsim: "≂", esim: "≂", Equilibrium: "⇌", rightleftharpoons: "⇌", rlhar: "⇌", Escr: "ℰ", expectation: "ℰ", Esim: "⩳", Eta: "Η", Euml: "Ë", Exists: "∃", exist: "∃", ExponentialE: "ⅇ", ee: "ⅇ", exponentiale: "ⅇ", Fcy: "Ф", Ffr: "𝔉", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", blacksquare: "▪", squarf: "▪", squf: "▪", Fopf: "𝔽", ForAll: "∀", forall: "∀", Fouriertrf: "ℱ", Fscr: "ℱ", GJcy: "Ѓ", GT: ">", gt: ">", Gamma: "Γ", Gammad: "Ϝ", Gbreve: "Ğ", Gcedil: "Ģ", Gcirc: "Ĝ", Gcy: "Г", Gdot: "Ġ", Gfr: "𝔊", Gg: "⋙", ggg: "⋙", Gopf: "𝔾", GreaterEqual: "≥", ge: "≥", geq: "≥", GreaterEqualLess: "⋛", gel: "⋛", gtreqless: "⋛", GreaterFullEqual: "≧", gE: "≧", geqq: "≧", GreaterGreater: "⪢", GreaterLess: "≷", gl: "≷", gtrless: "≷", GreaterSlantEqual: "⩾", geqslant: "⩾", ges: "⩾", GreaterTilde: "≳", gsim: "≳", gtrsim: "≳", Gscr: "𝒢", Gt: "≫", NestedGreaterGreater: "≫", gg: "≫", HARDcy: "Ъ", Hacek: "ˇ", caron: "ˇ", Hat: "^", Hcirc: "Ĥ", Hfr: "ℌ", Poincareplane: "ℌ", HilbertSpace: "ℋ", Hscr: "ℋ", hamilt: "ℋ", Hopf: "ℍ", quaternions: "ℍ", HorizontalLine: "─", boxh: "─", Hstrok: "Ħ", HumpEqual: "≏", bumpe: "≏", bumpeq: "≏", IEcy: "Е", IJlig: "Ĳ", IOcy: "Ё", Iacute: "Í", Icirc: "Î", Icy: "И", Idot: "İ", Ifr: "ℑ", Im: "ℑ", image: "ℑ", imagpart: "ℑ", Igrave: "Ì", Imacr: "Ī", ImaginaryI: "ⅈ", ii: "ⅈ", Int: "∬", Integral: "∫", int: "∫", Intersection: "⋂", bigcap: "⋂", xcap: "⋂", InvisibleComma: "⁣", ic: "⁣", InvisibleTimes: "⁢", it: "⁢", Iogon: "Į", Iopf: "𝕀", Iota: "Ι", Iscr: "ℐ", imagline: "ℐ", Itilde: "Ĩ", Iukcy: "І", Iuml: "Ï", Jcirc: "Ĵ", Jcy: "Й", Jfr: "𝔍", Jopf: "𝕁", Jscr: "𝒥", Jsercy: "Ј", Jukcy: "Є", KHcy: "Х", KJcy: "Ќ", Kappa: "Κ", Kcedil: "Ķ", Kcy: "К", Kfr: "𝔎", Kopf: "𝕂", Kscr: "𝒦", LJcy: "Љ", LT: "<", lt: "<", Lacute: "Ĺ", Lambda: "Λ", Lang: "⟪", Laplacetrf: "ℒ", Lscr: "ℒ", lagran: "ℒ", Larr: "↞", twoheadleftarrow: "↞", Lcaron: "Ľ", Lcedil: "Ļ", Lcy: "Л", LeftAngleBracket: "⟨", lang: "⟨", langle: "⟨", LeftArrow: "←", ShortLeftArrow: "←", larr: "←", leftarrow: "←", slarr: "←", LeftArrowBar: "⇤", larrb: "⇤", LeftArrowRightArrow: "⇆", leftrightarrows: "⇆", lrarr: "⇆", LeftCeiling: "⌈", lceil: "⌈", LeftDoubleBracket: "⟦", lobrk: "⟦", LeftDownTeeVector: "⥡", LeftDownVector: "⇃", dharl: "⇃", downharpoonleft: "⇃", LeftDownVectorBar: "⥙", LeftFloor: "⌊", lfloor: "⌊", LeftRightArrow: "↔", harr: "↔", leftrightarrow: "↔", LeftRightVector: "⥎", LeftTee: "⊣", dashv: "⊣", LeftTeeArrow: "↤", mapstoleft: "↤", LeftTeeVector: "⥚", LeftTriangle: "⊲", vartriangleleft: "⊲", vltri: "⊲", LeftTriangleBar: "⧏", LeftTriangleEqual: "⊴", ltrie: "⊴", trianglelefteq: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVector: "↿", uharl: "↿", upharpoonleft: "↿", LeftUpVectorBar: "⥘", LeftVector: "↼", leftharpoonup: "↼", lharu: "↼", LeftVectorBar: "⥒", LessEqualGreater: "⋚", leg: "⋚", lesseqgtr: "⋚", LessFullEqual: "≦", lE: "≦", leqq: "≦", LessGreater: "≶", lessgtr: "≶", lg: "≶", LessLess: "⪡", LessSlantEqual: "⩽", leqslant: "⩽", les: "⩽", LessTilde: "≲", lesssim: "≲", lsim: "≲", Lfr: "𝔏", Ll: "⋘", Lleftarrow: "⇚", lAarr: "⇚", Lmidot: "Ŀ", LongLeftArrow: "⟵", longleftarrow: "⟵", xlarr: "⟵", LongLeftRightArrow: "⟷", longleftrightarrow: "⟷", xharr: "⟷", LongRightArrow: "⟶", longrightarrow: "⟶", xrarr: "⟶", Lopf: "𝕃", LowerLeftArrow: "↙", swarr: "↙", swarrow: "↙", LowerRightArrow: "↘", searr: "↘", searrow: "↘", Lsh: "↰", lsh: "↰", Lstrok: "Ł", Lt: "≪", NestedLessLess: "≪", ll: "≪", Map: "⤅", Mcy: "М", MediumSpace: " ", Mellintrf: "ℳ", Mscr: "ℳ", phmmat: "ℳ", Mfr: "𝔐", MinusPlus: "∓", mnplus: "∓", mp: "∓", Mopf: "𝕄", Mu: "Μ", NJcy: "Њ", Nacute: "Ń", Ncaron: "Ň", Ncedil: "Ņ", Ncy: "Н", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", ZeroWidthSpace: "​", NewLine: `
`, Nfr: "𝔑", NoBreak: "⁠", NonBreakingSpace: " ", nbsp: " ", Nopf: "ℕ", naturals: "ℕ", Not: "⫬", NotCongruent: "≢", nequiv: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", npar: "∦", nparallel: "∦", nshortparallel: "∦", nspar: "∦", NotElement: "∉", notin: "∉", notinva: "∉", NotEqual: "≠", ne: "≠", NotEqualTilde: "≂̸", nesim: "≂̸", NotExists: "∄", nexist: "∄", nexists: "∄", NotGreater: "≯", ngt: "≯", ngtr: "≯", NotGreaterEqual: "≱", nge: "≱", ngeq: "≱", NotGreaterFullEqual: "≧̸", ngE: "≧̸", ngeqq: "≧̸", NotGreaterGreater: "≫̸", nGtv: "≫̸", NotGreaterLess: "≹", ntgl: "≹", NotGreaterSlantEqual: "⩾̸", ngeqslant: "⩾̸", nges: "⩾̸", NotGreaterTilde: "≵", ngsim: "≵", NotHumpDownHump: "≎̸", nbump: "≎̸", NotHumpEqual: "≏̸", nbumpe: "≏̸", NotLeftTriangle: "⋪", nltri: "⋪", ntriangleleft: "⋪", NotLeftTriangleBar: "⧏̸", NotLeftTriangleEqual: "⋬", nltrie: "⋬", ntrianglelefteq: "⋬", NotLess: "≮", nless: "≮", nlt: "≮", NotLessEqual: "≰", nle: "≰", nleq: "≰", NotLessGreater: "≸", ntlg: "≸", NotLessLess: "≪̸", nLtv: "≪̸", NotLessSlantEqual: "⩽̸", nleqslant: "⩽̸", nles: "⩽̸", NotLessTilde: "≴", nlsim: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", NotPrecedes: "⊀", npr: "⊀", nprec: "⊀", NotPrecedesEqual: "⪯̸", npre: "⪯̸", npreceq: "⪯̸", NotPrecedesSlantEqual: "⋠", nprcue: "⋠", NotReverseElement: "∌", notni: "∌", notniva: "∌", NotRightTriangle: "⋫", nrtri: "⋫", ntriangleright: "⋫", NotRightTriangleBar: "⧐̸", NotRightTriangleEqual: "⋭", nrtrie: "⋭", ntrianglerighteq: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", nsqsube: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", nsqsupe: "⋣", NotSubset: "⊂⃒", nsubset: "⊂⃒", vnsub: "⊂⃒", NotSubsetEqual: "⊈", nsube: "⊈", nsubseteq: "⊈", NotSucceeds: "⊁", nsc: "⊁", nsucc: "⊁", NotSucceedsEqual: "⪰̸", nsce: "⪰̸", nsucceq: "⪰̸", NotSucceedsSlantEqual: "⋡", nsccue: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", nsupset: "⊃⃒", vnsup: "⊃⃒", NotSupersetEqual: "⊉", nsupe: "⊉", nsupseteq: "⊉", NotTilde: "≁", nsim: "≁", NotTildeEqual: "≄", nsime: "≄", nsimeq: "≄", NotTildeFullEqual: "≇", ncong: "≇", NotTildeTilde: "≉", nap: "≉", napprox: "≉", NotVerticalBar: "∤", nmid: "∤", nshortmid: "∤", nsmid: "∤", Nscr: "𝒩", Ntilde: "Ñ", Nu: "Ν", OElig: "Œ", Oacute: "Ó", Ocirc: "Ô", Ocy: "О", Odblac: "Ő", Ofr: "𝔒", Ograve: "Ò", Omacr: "Ō", Omega: "Ω", ohm: "Ω", Omicron: "Ο", Oopf: "𝕆", OpenCurlyDoubleQuote: "“", ldquo: "“", OpenCurlyQuote: "‘", lsquo: "‘", Or: "⩔", Oscr: "𝒪", Oslash: "Ø", Otilde: "Õ", Otimes: "⨷", Ouml: "Ö", OverBar: "‾", oline: "‾", OverBrace: "⏞", OverBracket: "⎴", tbrk: "⎴", OverParenthesis: "⏜", PartialD: "∂", part: "∂", Pcy: "П", Pfr: "𝔓", Phi: "Φ", Pi: "Π", PlusMinus: "±", plusmn: "±", pm: "±", Popf: "ℙ", primes: "ℙ", Pr: "⪻", Precedes: "≺", pr: "≺", prec: "≺", PrecedesEqual: "⪯", pre: "⪯", preceq: "⪯", PrecedesSlantEqual: "≼", prcue: "≼", preccurlyeq: "≼", PrecedesTilde: "≾", precsim: "≾", prsim: "≾", Prime: "″", Product: "∏", prod: "∏", Proportional: "∝", prop: "∝", propto: "∝", varpropto: "∝", vprop: "∝", Pscr: "𝒫", Psi: "Ψ", QUOT: '"', quot: '"', Qfr: "𝔔", Qopf: "ℚ", rationals: "ℚ", Qscr: "𝒬", RBarr: "⤐", drbkarow: "⤐", REG: "®", circledR: "®", reg: "®", Racute: "Ŕ", Rang: "⟫", Rarr: "↠", twoheadrightarrow: "↠", Rarrtl: "⤖", Rcaron: "Ř", Rcedil: "Ŗ", Rcy: "Р", Re: "ℜ", Rfr: "ℜ", real: "ℜ", realpart: "ℜ", ReverseElement: "∋", SuchThat: "∋", ni: "∋", niv: "∋", ReverseEquilibrium: "⇋", leftrightharpoons: "⇋", lrhar: "⇋", ReverseUpEquilibrium: "⥯", duhar: "⥯", Rho: "Ρ", RightAngleBracket: "⟩", rang: "⟩", rangle: "⟩", RightArrow: "→", ShortRightArrow: "→", rarr: "→", rightarrow: "→", srarr: "→", RightArrowBar: "⇥", rarrb: "⇥", RightArrowLeftArrow: "⇄", rightleftarrows: "⇄", rlarr: "⇄", RightCeiling: "⌉", rceil: "⌉", RightDoubleBracket: "⟧", robrk: "⟧", RightDownTeeVector: "⥝", RightDownVector: "⇂", dharr: "⇂", downharpoonright: "⇂", RightDownVectorBar: "⥕", RightFloor: "⌋", rfloor: "⌋", RightTee: "⊢", vdash: "⊢", RightTeeArrow: "↦", map: "↦", mapsto: "↦", RightTeeVector: "⥛", RightTriangle: "⊳", vartriangleright: "⊳", vrtri: "⊳", RightTriangleBar: "⧐", RightTriangleEqual: "⊵", rtrie: "⊵", trianglerighteq: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVector: "↾", uharr: "↾", upharpoonright: "↾", RightUpVectorBar: "⥔", RightVector: "⇀", rharu: "⇀", rightharpoonup: "⇀", RightVectorBar: "⥓", Ropf: "ℝ", reals: "ℝ", RoundImplies: "⥰", Rrightarrow: "⇛", rAarr: "⇛", Rscr: "ℛ", realine: "ℛ", Rsh: "↱", rsh: "↱", RuleDelayed: "⧴", SHCHcy: "Щ", SHcy: "Ш", SOFTcy: "Ь", Sacute: "Ś", Sc: "⪼", Scaron: "Š", Scedil: "Ş", Scirc: "Ŝ", Scy: "С", Sfr: "𝔖", ShortUpArrow: "↑", UpArrow: "↑", uarr: "↑", uparrow: "↑", Sigma: "Σ", SmallCircle: "∘", compfn: "∘", Sopf: "𝕊", Sqrt: "√", radic: "√", Square: "□", squ: "□", square: "□", SquareIntersection: "⊓", sqcap: "⊓", SquareSubset: "⊏", sqsub: "⊏", sqsubset: "⊏", SquareSubsetEqual: "⊑", sqsube: "⊑", sqsubseteq: "⊑", SquareSuperset: "⊐", sqsup: "⊐", sqsupset: "⊐", SquareSupersetEqual: "⊒", sqsupe: "⊒", sqsupseteq: "⊒", SquareUnion: "⊔", sqcup: "⊔", Sscr: "𝒮", Star: "⋆", sstarf: "⋆", Sub: "⋐", Subset: "⋐", SubsetEqual: "⊆", sube: "⊆", subseteq: "⊆", Succeeds: "≻", sc: "≻", succ: "≻", SucceedsEqual: "⪰", sce: "⪰", succeq: "⪰", SucceedsSlantEqual: "≽", sccue: "≽", succcurlyeq: "≽", SucceedsTilde: "≿", scsim: "≿", succsim: "≿", Sum: "∑", sum: "∑", Sup: "⋑", Supset: "⋑", Superset: "⊃", sup: "⊃", supset: "⊃", SupersetEqual: "⊇", supe: "⊇", supseteq: "⊇", THORN: "Þ", TRADE: "™", trade: "™", TSHcy: "Ћ", TScy: "Ц", Tab: "	", Tau: "Τ", Tcaron: "Ť", Tcedil: "Ţ", Tcy: "Т", Tfr: "𝔗", Therefore: "∴", there4: "∴", therefore: "∴", Theta: "Θ", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", Tilde: "∼", sim: "∼", thicksim: "∼", thksim: "∼", TildeEqual: "≃", sime: "≃", simeq: "≃", TildeFullEqual: "≅", cong: "≅", TildeTilde: "≈", ap: "≈", approx: "≈", asymp: "≈", thickapprox: "≈", thkap: "≈", Topf: "𝕋", TripleDot: "⃛", tdot: "⃛", Tscr: "𝒯", Tstrok: "Ŧ", Uacute: "Ú", Uarr: "↟", Uarrocir: "⥉", Ubrcy: "Ў", Ubreve: "Ŭ", Ucirc: "Û", Ucy: "У", Udblac: "Ű", Ufr: "𝔘", Ugrave: "Ù", Umacr: "Ū", UnderBar: "_", lowbar: "_", UnderBrace: "⏟", UnderBracket: "⎵", bbrk: "⎵", UnderParenthesis: "⏝", Union: "⋃", bigcup: "⋃", xcup: "⋃", UnionPlus: "⊎", uplus: "⊎", Uogon: "Ų", Uopf: "𝕌", UpArrowBar: "⤒", UpArrowDownArrow: "⇅", udarr: "⇅", UpDownArrow: "↕", updownarrow: "↕", varr: "↕", UpEquilibrium: "⥮", udhar: "⥮", UpTee: "⊥", bot: "⊥", bottom: "⊥", perp: "⊥", UpTeeArrow: "↥", mapstoup: "↥", UpperLeftArrow: "↖", nwarr: "↖", nwarrow: "↖", UpperRightArrow: "↗", nearr: "↗", nearrow: "↗", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", Uring: "Ů", Uscr: "𝒰", Utilde: "Ũ", Uuml: "Ü", VDash: "⊫", Vbar: "⫫", Vcy: "В", Vdash: "⊩", Vdashl: "⫦", Vee: "⋁", bigvee: "⋁", xvee: "⋁", Verbar: "‖", Vert: "‖", VerticalBar: "∣", mid: "∣", shortmid: "∣", smid: "∣", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "❘", VerticalTilde: "≀", wr: "≀", wreath: "≀", VeryThinSpace: " ", hairsp: " ", Vfr: "𝔙", Vopf: "𝕍", Vscr: "𝒱", Vvdash: "⊪", Wcirc: "Ŵ", Wedge: "⋀", bigwedge: "⋀", xwedge: "⋀", Wfr: "𝔚", Wopf: "𝕎", Wscr: "𝒲", Xfr: "𝔛", Xi: "Ξ", Xopf: "𝕏", Xscr: "𝒳", YAcy: "Я", YIcy: "Ї", YUcy: "Ю", Yacute: "Ý", Ycirc: "Ŷ", Ycy: "Ы", Yfr: "𝔜", Yopf: "𝕐", Yscr: "𝒴", Yuml: "Ÿ", ZHcy: "Ж", Zacute: "Ź", Zcaron: "Ž", Zcy: "З", Zdot: "Ż", Zeta: "Ζ", Zfr: "ℨ", zeetrf: "ℨ", Zopf: "ℤ", integers: "ℤ", Zscr: "𝒵", aacute: "á", abreve: "ă", ac: "∾", mstpos: "∾", acE: "∾̳", acd: "∿", acirc: "â", acy: "а", aelig: "æ", afr: "𝔞", agrave: "à", alefsym: "ℵ", aleph: "ℵ", alpha: "α", amacr: "ā", amalg: "⨿", and: "∧", wedge: "∧", andand: "⩕", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", angle: "∠", ange: "⦤", angmsd: "∡", measuredangle: "∡", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angzarr: "⍼", aogon: "ą", aopf: "𝕒", apE: "⩰", apacir: "⩯", ape: "≊", approxeq: "≊", apid: "≋", apos: "'", aring: "å", ascr: "𝒶", ast: "*", midast: "*", atilde: "ã", auml: "ä", awint: "⨑", bNot: "⫭", backcong: "≌", bcong: "≌", backepsilon: "϶", bepsi: "϶", backprime: "‵", bprime: "‵", backsim: "∽", bsim: "∽", backsimeq: "⋍", bsime: "⋍", barvee: "⊽", barwed: "⌅", barwedge: "⌅", bbrktbrk: "⎶", bcy: "б", bdquo: "„", ldquor: "„", bemptyv: "⦰", beta: "β", beth: "ℶ", between: "≬", twixt: "≬", bfr: "𝔟", bigcirc: "◯", xcirc: "◯", bigodot: "⨀", xodot: "⨀", bigoplus: "⨁", xoplus: "⨁", bigotimes: "⨂", xotime: "⨂", bigsqcup: "⨆", xsqcup: "⨆", bigstar: "★", starf: "★", bigtriangledown: "▽", xdtri: "▽", bigtriangleup: "△", xutri: "△", biguplus: "⨄", xuplus: "⨄", bkarow: "⤍", rbarr: "⤍", blacklozenge: "⧫", lozf: "⧫", blacktriangle: "▴", utrif: "▴", blacktriangledown: "▾", dtrif: "▾", blacktriangleleft: "◂", ltrif: "◂", blacktriangleright: "▸", rtrif: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bnot: "⌐", bopf: "𝕓", bowtie: "⋈", boxDL: "╗", boxDR: "╔", boxDl: "╖", boxDr: "╓", boxH: "═", boxHD: "╦", boxHU: "╩", boxHd: "╤", boxHu: "╧", boxUL: "╝", boxUR: "╚", boxUl: "╜", boxUr: "╙", boxV: "║", boxVH: "╬", boxVL: "╣", boxVR: "╠", boxVh: "╫", boxVl: "╢", boxVr: "╟", boxbox: "⧉", boxdL: "╕", boxdR: "╒", boxdl: "┐", boxdr: "┌", boxhD: "╥", boxhU: "╨", boxhd: "┬", boxhu: "┴", boxminus: "⊟", minusb: "⊟", boxplus: "⊞", plusb: "⊞", boxtimes: "⊠", timesb: "⊠", boxuL: "╛", boxuR: "╘", boxul: "┘", boxur: "└", boxv: "│", boxvH: "╪", boxvL: "╡", boxvR: "╞", boxvh: "┼", boxvl: "┤", boxvr: "├", brvbar: "¦", bscr: "𝒷", bsemi: "⁏", bsol: "\\", bsolb: "⧅", bsolhsub: "⟈", bull: "•", bullet: "•", bumpE: "⪮", cacute: "ć", cap: "∩", capand: "⩄", capbrcup: "⩉", capcap: "⩋", capcup: "⩇", capdot: "⩀", caps: "∩︀", caret: "⁁", ccaps: "⩍", ccaron: "č", ccedil: "ç", ccirc: "ĉ", ccups: "⩌", ccupssm: "⩐", cdot: "ċ", cemptyv: "⦲", cent: "¢", cfr: "𝔠", chcy: "ч", check: "✓", checkmark: "✓", chi: "χ", cir: "○", cirE: "⧃", circ: "ˆ", circeq: "≗", cire: "≗", circlearrowleft: "↺", olarr: "↺", circlearrowright: "↻", orarr: "↻", circledS: "Ⓢ", oS: "Ⓢ", circledast: "⊛", oast: "⊛", circledcirc: "⊚", ocir: "⊚", circleddash: "⊝", odash: "⊝", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", clubs: "♣", clubsuit: "♣", colon: ":", comma: ",", commat: "@", comp: "∁", complement: "∁", congdot: "⩭", copf: "𝕔", copysr: "℗", crarr: "↵", cross: "✗", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", curlyeqprec: "⋞", cuesc: "⋟", curlyeqsucc: "⋟", cularr: "↶", curvearrowleft: "↶", cularrp: "⤽", cup: "∪", cupbrcap: "⩈", cupcap: "⩆", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curvearrowright: "↷", curarrm: "⤼", curlyvee: "⋎", cuvee: "⋎", curlywedge: "⋏", cuwed: "⋏", curren: "¤", cwint: "∱", cylcty: "⌭", dHar: "⥥", dagger: "†", daleth: "ℸ", dash: "‐", hyphen: "‐", dbkarow: "⤏", rBarr: "⤏", dcaron: "ď", dcy: "д", ddarr: "⇊", downdownarrows: "⇊", ddotseq: "⩷", eDDot: "⩷", deg: "°", delta: "δ", demptyv: "⦱", dfisht: "⥿", dfr: "𝔡", diamondsuit: "♦", diams: "♦", digamma: "ϝ", gammad: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", djcy: "ђ", dlcorn: "⌞", llcorner: "⌞", dlcrop: "⌍", dollar: "$", dopf: "𝕕", doteqdot: "≑", eDot: "≑", dotminus: "∸", minusd: "∸", dotplus: "∔", plusdo: "∔", dotsquare: "⊡", sdotb: "⊡", drcorn: "⌟", lrcorner: "⌟", drcrop: "⌌", dscr: "𝒹", dscy: "ѕ", dsol: "⧶", dstrok: "đ", dtdot: "⋱", dtri: "▿", triangledown: "▿", dwangle: "⦦", dzcy: "џ", dzigrarr: "⟿", eacute: "é", easter: "⩮", ecaron: "ě", ecir: "≖", eqcirc: "≖", ecirc: "ê", ecolon: "≕", eqcolon: "≕", ecy: "э", edot: "ė", efDot: "≒", fallingdotseq: "≒", efr: "𝔢", eg: "⪚", egrave: "è", egs: "⪖", eqslantgtr: "⪖", egsdot: "⪘", el: "⪙", elinters: "⏧", ell: "ℓ", els: "⪕", eqslantless: "⪕", elsdot: "⪗", emacr: "ē", empty: "∅", emptyset: "∅", emptyv: "∅", varnothing: "∅", emsp13: " ", emsp14: " ", emsp: " ", eng: "ŋ", ensp: " ", eogon: "ę", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", epsilon: "ε", epsiv: "ϵ", straightepsilon: "ϵ", varepsilon: "ϵ", equals: "=", equest: "≟", questeq: "≟", equivDD: "⩸", eqvparsl: "⧥", erDot: "≓", risingdotseq: "≓", erarr: "⥱", escr: "ℯ", eta: "η", eth: "ð", euml: "ë", euro: "€", excl: "!", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", ffr: "𝔣", filig: "ﬁ", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", fopf: "𝕗", fork: "⋔", pitchfork: "⋔", forkv: "⫙", fpartint: "⨍", frac12: "½", half: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", sfrown: "⌢", fscr: "𝒻", gEl: "⪌", gtreqqless: "⪌", gacute: "ǵ", gamma: "γ", gap: "⪆", gtrapprox: "⪆", gbreve: "ğ", gcirc: "ĝ", gcy: "г", gdot: "ġ", gescc: "⪩", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", gfr: "𝔤", gimel: "ℷ", gjcy: "ѓ", glE: "⪒", gla: "⪥", glj: "⪤", gnE: "≩", gneqq: "≩", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gneq: "⪈", gnsim: "⋧", gopf: "𝕘", gscr: "ℊ", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gtdot: "⋗", gtrdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrarr: "⥸", gvertneqq: "≩︀", gvnE: "≩︀", hardcy: "ъ", harrcir: "⥈", harrw: "↭", leftrightsquigarrow: "↭", hbar: "ℏ", hslash: "ℏ", planck: "ℏ", plankv: "ℏ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", mldr: "…", hercon: "⊹", hfr: "𝔥", hksearow: "⤥", searhk: "⤥", hkswarow: "⤦", swarhk: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", larrhk: "↩", hookrightarrow: "↪", rarrhk: "↪", hopf: "𝕙", horbar: "―", hscr: "𝒽", hstrok: "ħ", hybull: "⁃", iacute: "í", icirc: "î", icy: "и", iecy: "е", iexcl: "¡", ifr: "𝔦", igrave: "ì", iiiint: "⨌", qint: "⨌", iiint: "∭", tint: "∭", iinfin: "⧜", iiota: "℩", ijlig: "ĳ", imacr: "ī", imath: "ı", inodot: "ı", imof: "⊷", imped: "Ƶ", incare: "℅", infin: "∞", infintie: "⧝", intcal: "⊺", intercal: "⊺", intlarhk: "⨗", intprod: "⨼", iprod: "⨼", iocy: "ё", iogon: "į", iopf: "𝕚", iota: "ι", iquest: "¿", iscr: "𝒾", isinE: "⋹", isindot: "⋵", isins: "⋴", isinsv: "⋳", itilde: "ĩ", iukcy: "і", iuml: "ï", jcirc: "ĵ", jcy: "й", jfr: "𝔧", jmath: "ȷ", jopf: "𝕛", jscr: "𝒿", jsercy: "ј", jukcy: "є", kappa: "κ", kappav: "ϰ", varkappa: "ϰ", kcedil: "ķ", kcy: "к", kfr: "𝔨", kgreen: "ĸ", khcy: "х", kjcy: "ќ", kopf: "𝕜", kscr: "𝓀", lAtail: "⤛", lBarr: "⤎", lEg: "⪋", lesseqqgtr: "⪋", lHar: "⥢", lacute: "ĺ", laemptyv: "⦴", lambda: "λ", langd: "⦑", lap: "⪅", lessapprox: "⪅", laquo: "«", larrbfs: "⤟", larrfs: "⤝", larrlp: "↫", looparrowleft: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", leftarrowtail: "↢", lat: "⪫", latail: "⤙", late: "⪭", lates: "⪭︀", lbarr: "⤌", lbbrk: "❲", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", lcaron: "ľ", lcedil: "ļ", lcy: "л", ldca: "⤶", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", leq: "≤", leftleftarrows: "⇇", llarr: "⇇", leftthreetimes: "⋋", lthree: "⋋", lescc: "⪨", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessdot: "⋖", ltdot: "⋖", lfisht: "⥼", lfr: "𝔩", lgE: "⪑", lharul: "⥪", lhblk: "▄", ljcy: "љ", llhard: "⥫", lltri: "◺", lmidot: "ŀ", lmoust: "⎰", lmoustache: "⎰", lnE: "≨", lneqq: "≨", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lneq: "⪇", lnsim: "⋦", loang: "⟬", loarr: "⇽", longmapsto: "⟼", xmap: "⟼", looparrowright: "↬", rarrlp: "↬", lopar: "⦅", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", loz: "◊", lozenge: "◊", lpar: "(", lparlt: "⦓", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", lscr: "𝓁", lsime: "⪍", lsimg: "⪏", lsquor: "‚", sbquo: "‚", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltrPar: "⦖", ltri: "◃", triangleleft: "◃", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", mDDot: "∺", macr: "¯", strns: "¯", male: "♂", malt: "✠", maltese: "✠", marker: "▮", mcomma: "⨩", mcy: "м", mdash: "—", mfr: "𝔪", mho: "℧", micro: "µ", midcir: "⫰", minus: "−", minusdu: "⨪", mlcp: "⫛", models: "⊧", mopf: "𝕞", mscr: "𝓂", mu: "μ", multimap: "⊸", mumap: "⊸", nGg: "⋙̸", nGt: "≫⃒", nLeftarrow: "⇍", nlArr: "⇍", nLeftrightarrow: "⇎", nhArr: "⇎", nLl: "⋘̸", nLt: "≪⃒", nRightarrow: "⇏", nrArr: "⇏", nVDash: "⊯", nVdash: "⊮", nacute: "ń", nang: "∠⃒", napE: "⩰̸", napid: "≋̸", napos: "ŉ", natur: "♮", natural: "♮", ncap: "⩃", ncaron: "ň", ncedil: "ņ", ncongdot: "⩭̸", ncup: "⩂", ncy: "н", ndash: "–", neArr: "⇗", nearhk: "⤤", nedot: "≐̸", nesear: "⤨", toea: "⤨", nfr: "𝔫", nharr: "↮", nleftrightarrow: "↮", nhpar: "⫲", nis: "⋼", nisd: "⋺", njcy: "њ", nlE: "≦̸", nleqq: "≦̸", nlarr: "↚", nleftarrow: "↚", nldr: "‥", nopf: "𝕟", not: "¬", notinE: "⋹̸", notindot: "⋵̸", notinvb: "⋷", notinvc: "⋶", notnivb: "⋾", notnivc: "⋽", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", nrarr: "↛", nrightarrow: "↛", nrarrc: "⤳̸", nrarrw: "↝̸", nscr: "𝓃", nsub: "⊄", nsubE: "⫅̸", nsubseteqq: "⫅̸", nsup: "⊅", nsupE: "⫆̸", nsupseteqq: "⫆̸", ntilde: "ñ", nu: "ν", num: "#", numero: "№", numsp: " ", nvDash: "⊭", nvHarr: "⤄", nvap: "≍⃒", nvdash: "⊬", nvge: "≥⃒", nvgt: ">⃒", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwArr: "⇖", nwarhk: "⤣", nwnear: "⤧", oacute: "ó", ocirc: "ô", ocy: "о", odblac: "ő", odiv: "⨸", odsold: "⦼", oelig: "œ", ofcir: "⦿", ofr: "𝔬", ogon: "˛", ograve: "ò", ogt: "⧁", ohbar: "⦵", olcir: "⦾", olcross: "⦻", olt: "⧀", omacr: "ō", omega: "ω", omicron: "ο", omid: "⦶", oopf: "𝕠", opar: "⦷", operp: "⦹", or: "∨", vee: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", oscr: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oslash: "ø", osol: "⊘", otilde: "õ", otimesas: "⨶", ouml: "ö", ovbar: "⌽", para: "¶", parsim: "⫳", parsl: "⫽", pcy: "п", percnt: "%", period: ".", permil: "‰", pertenk: "‱", pfr: "𝔭", phi: "φ", phiv: "ϕ", straightphi: "ϕ", varphi: "ϕ", phone: "☎", pi: "π", piv: "ϖ", varpi: "ϖ", planckh: "ℎ", plus: "+", plusacir: "⨣", pluscir: "⨢", plusdu: "⨥", pluse: "⩲", plussim: "⨦", plustwo: "⨧", pointint: "⨕", popf: "𝕡", pound: "£", prE: "⪳", prap: "⪷", precapprox: "⪷", precnapprox: "⪹", prnap: "⪹", precneqq: "⪵", prnE: "⪵", precnsim: "⋨", prnsim: "⋨", prime: "′", profalar: "⌮", profline: "⌒", profsurf: "⌓", prurel: "⊰", pscr: "𝓅", psi: "ψ", puncsp: " ", qfr: "𝔮", qopf: "𝕢", qprime: "⁗", qscr: "𝓆", quatint: "⨖", quest: "?", rAtail: "⤜", rHar: "⥤", race: "∽̱", racute: "ŕ", raemptyv: "⦳", rangd: "⦒", range: "⦥", raquo: "»", rarrap: "⥵", rarrbfs: "⤠", rarrc: "⤳", rarrfs: "⤞", rarrpl: "⥅", rarrsim: "⥴", rarrtl: "↣", rightarrowtail: "↣", rarrw: "↝", rightsquigarrow: "↝", ratail: "⤚", ratio: "∶", rbbrk: "❳", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", rcaron: "ř", rcedil: "ŗ", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdsh: "↳", rect: "▭", rfisht: "⥽", rfr: "𝔯", rharul: "⥬", rho: "ρ", rhov: "ϱ", varrho: "ϱ", rightrightarrows: "⇉", rrarr: "⇉", rightthreetimes: "⋌", rthree: "⋌", ring: "˚", rlm: "‏", rmoust: "⎱", rmoustache: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", ropar: "⦆", ropf: "𝕣", roplus: "⨮", rotimes: "⨵", rpar: ")", rpargt: "⦔", rppolint: "⨒", rsaquo: "›", rscr: "𝓇", rtimes: "⋊", rtri: "▹", triangleright: "▹", rtriltri: "⧎", ruluhar: "⥨", rx: "℞", sacute: "ś", scE: "⪴", scap: "⪸", succapprox: "⪸", scaron: "š", scedil: "ş", scirc: "ŝ", scnE: "⪶", succneqq: "⪶", scnap: "⪺", succnapprox: "⪺", scnsim: "⋩", succnsim: "⋩", scpolint: "⨓", scy: "с", sdot: "⋅", sdote: "⩦", seArr: "⇘", sect: "§", semi: ";", seswar: "⤩", tosa: "⤩", sext: "✶", sfr: "𝔰", sharp: "♯", shchcy: "щ", shcy: "ш", shy: "­", sigma: "σ", sigmaf: "ς", sigmav: "ς", varsigma: "ς", simdot: "⩪", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", smashp: "⨳", smeparsl: "⧤", smile: "⌣", ssmile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", softcy: "ь", sol: "/", solb: "⧄", solbar: "⌿", sopf: "𝕤", spades: "♠", spadesuit: "♠", sqcaps: "⊓︀", sqcups: "⊔︀", sscr: "𝓈", star: "☆", sub: "⊂", subset: "⊂", subE: "⫅", subseteqq: "⫅", subdot: "⪽", subedot: "⫃", submult: "⫁", subnE: "⫋", subsetneqq: "⫋", subne: "⊊", subsetneq: "⊊", subplus: "⪿", subrarr: "⥹", subsim: "⫇", subsub: "⫕", subsup: "⫓", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", supE: "⫆", supseteqq: "⫆", supdot: "⪾", supdsub: "⫘", supedot: "⫄", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supsetneqq: "⫌", supne: "⊋", supsetneq: "⊋", supplus: "⫀", supsim: "⫈", supsub: "⫔", supsup: "⫖", swArr: "⇙", swnwar: "⤪", szlig: "ß", target: "⌖", tau: "τ", tcaron: "ť", tcedil: "ţ", tcy: "т", telrec: "⌕", tfr: "𝔱", theta: "θ", thetasym: "ϑ", thetav: "ϑ", vartheta: "ϑ", thorn: "þ", times: "×", timesbar: "⨱", timesd: "⨰", topbot: "⌶", topcir: "⫱", topf: "𝕥", topfork: "⫚", tprime: "‴", triangle: "▵", utri: "▵", triangleq: "≜", trie: "≜", tridot: "◬", triminus: "⨺", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", tscr: "𝓉", tscy: "ц", tshcy: "ћ", tstrok: "ŧ", uHar: "⥣", uacute: "ú", ubrcy: "ў", ubreve: "ŭ", ucirc: "û", ucy: "у", udblac: "ű", ufisht: "⥾", ufr: "𝔲", ugrave: "ù", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", umacr: "ū", uogon: "ų", uopf: "𝕦", upsi: "υ", upsilon: "υ", upuparrows: "⇈", uuarr: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", uring: "ů", urtri: "◹", uscr: "𝓊", utdot: "⋰", utilde: "ũ", uuml: "ü", uwangle: "⦧", vBar: "⫨", vBarv: "⫩", vangrt: "⦜", varsubsetneq: "⊊︀", vsubne: "⊊︀", varsubsetneqq: "⫋︀", vsubnE: "⫋︀", varsupsetneq: "⊋︀", vsupne: "⊋︀", varsupsetneqq: "⫌︀", vsupnE: "⫌︀", vcy: "в", veebar: "⊻", veeeq: "≚", vellip: "⋮", vfr: "𝔳", vopf: "𝕧", vscr: "𝓋", vzigzag: "⦚", wcirc: "ŵ", wedbar: "⩟", wedgeq: "≙", weierp: "℘", wp: "℘", wfr: "𝔴", wopf: "𝕨", wscr: "𝓌", xfr: "𝔵", xi: "ξ", xnis: "⋻", xopf: "𝕩", xscr: "𝓍", yacute: "ý", yacy: "я", ycirc: "ŷ", ycy: "ы", yen: "¥", yfr: "𝔶", yicy: "ї", yopf: "𝕪", yscr: "𝓎", yucy: "ю", yuml: "ÿ", zacute: "ź", zcaron: "ž", zcy: "з", zdot: "ż", zeta: "ζ", zfr: "𝔷", zhcy: "ж", zigrarr: "⇝", zopf: "𝕫", zscr: "𝓏", zwj: "‍", zwnj: "‌" }, jB = "";
uc.ngsp = jB;
var RB = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
function ZB(t, e) {
  if (e != null && !(Array.isArray(e) && e.length == 2))
    throw new Error(`Expected '${t}' to be an array, [start, end].`);
  if (e != null) {
    let r = e[0], i = e[1];
    RB.forEach((n) => {
      if (n.test(r) || n.test(i))
        throw new Error(`['${r}', '${i}'] contains unusable interpolation symbol.`);
    });
  }
}
var WB = class t2 {
  static fromArray(e) {
    return e ? (ZB("interpolation", e), new t2(e[0], e[1])) : r2;
  }
  constructor(e, r) {
    this.start = e, this.end = r;
  }
}, r2 = new WB("{{", "}}"), fp = class extends HD {
  constructor(e, r, i) {
    super(i, e), this.tokenType = r;
  }
}, qB = class {
  constructor(e, r, i) {
    this.tokens = e, this.errors = r, this.nonNormalizedIcuExpressions = i;
  }
};
function XB(t, e, r, i = {}) {
  let n = new YB(new GD(t, e), r, i);
  return n.tokenize(), new qB(e8(n.tokens), n.errors, n.nonNormalizedIcuExpressions);
}
var VB = /\r\n?/g;
function Us(t) {
  return `Unexpected character "${t === 0 ? "EOF" : String.fromCharCode(t)}"`;
}
function C0(t) {
  return `Unknown entity "${t}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
}
function UB(t, e) {
  return `Unable to parse entity "${e}" - ${t} character reference entities must end with ";"`;
}
var cc;
(function(t) {
  t.HEX = "hexadecimal", t.DEC = "decimal";
})(cc || (cc = {}));
var mp = class {
  constructor(e) {
    this.error = e;
  }
}, YB = class {
  constructor(e, r, i) {
    this._getTagContentType = r, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = !1, this._fullNameStack = [], this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = i.tokenizeExpansionForms || !1, this._interpolationConfig = i.interpolationConfig || r2, this._leadingTriviaCodePoints = i.leadingTriviaChars && i.leadingTriviaChars.map((s) => s.codePointAt(0) || 0), this._canSelfClose = i.canSelfClose || !1, this._allowHtmComponentClosingTags = i.allowHtmComponentClosingTags || !1;
    let n = i.range || { endPos: e.content.length, startPos: 0, startLine: 0, startCol: 0 };
    this._cursor = i.escapedString ? new t8(e, n) : new i2(e, n), this._preserveLineEndings = i.preserveLineEndings || !1, this._i18nNormalizeLineEndingsInICUs = i.i18nNormalizeLineEndingsInICUs || !1, this._tokenizeBlocks = i.tokenizeBlocks ?? !0;
    try {
      this._cursor.init();
    } catch (s) {
      this.handleError(s);
    }
  }
  _processCarriageReturns(e) {
    return this._preserveLineEndings ? e : e.replace(VB, `
`);
  }
  tokenize() {
    for (; this._cursor.peek() !== 0; ) {
      let e = this._cursor.clone();
      try {
        if (this._attemptCharCode(60))
          if (this._attemptCharCode(33))
            this._attemptStr("[CDATA[") ? this._consumeCdata(e) : this._attemptStr("--") ? this._consumeComment(e) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e) : this._consumeBogusComment(e);
          else if (this._attemptCharCode(47))
            this._consumeTagClose(e);
          else {
            let r = this._cursor.clone();
            this._attemptCharCode(63) ? (this._cursor = r, this._consumeBogusComment(e)) : this._consumeTagOpen(e);
          }
        else
          this._tokenizeBlocks && this._attemptCharCode(64) ? this._consumeBlockStart(e) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(125) ? this._consumeBlockEnd(e) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
      } catch (r) {
        this.handleError(r);
      }
    }
    this._beginToken(30), this._endToken([]);
  }
  _getBlockName() {
    let e = !1, r = this._cursor.clone();
    return this._attemptCharCodeUntilFn((i) => km(i) ? !e : k0(i) ? (e = !0, !1) : !0), this._cursor.getChars(r).trim();
  }
  _consumeBlockStart(e) {
    this._beginToken(25, e);
    let r = this._endToken([this._getBlockName()]);
    if (this._cursor.peek() === 40)
      if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(St), this._attemptCharCode(41))
        this._attemptCharCodeUntilFn(St);
      else {
        r.type = 29;
        return;
      }
    this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : r.type = 29;
  }
  _consumeBlockEnd(e) {
    this._beginToken(27, e), this._endToken([]);
  }
  _consumeBlockParameters() {
    for (this._attemptCharCodeUntilFn(T0); this._cursor.peek() !== 41 && this._cursor.peek() !== 0; ) {
      this._beginToken(28);
      let e = this._cursor.clone(), r = null, i = 0;
      for (; this._cursor.peek() !== 59 && this._cursor.peek() !== 0 || r !== null; ) {
        let n = this._cursor.peek();
        if (n === 92)
          this._cursor.advance();
        else if (n === r)
          r = null;
        else if (r === null && p0(n))
          r = n;
        else if (n === 40 && r === null)
          i++;
        else if (n === 41 && r === null) {
          if (i === 0)
            break;
          i > 0 && i--;
        }
        this._cursor.advance();
      }
      this._endToken([this._cursor.getChars(e)]), this._attemptCharCodeUntilFn(T0);
    }
  }
  _tokenizeExpansionForm() {
    if (this.isExpansionFormStart())
      return this._consumeExpansionFormStart(), !0;
    if (JB(this._cursor.peek()) && this._isInExpansionForm())
      return this._consumeExpansionCaseStart(), !0;
    if (this._cursor.peek() === 125) {
      if (this._isInExpansionCase())
        return this._consumeExpansionCaseEnd(), !0;
      if (this._isInExpansionForm())
        return this._consumeExpansionFormEnd(), !0;
    }
    return !1;
  }
  _beginToken(e, r = this._cursor.clone()) {
    this._currentTokenStart = r, this._currentTokenType = e;
  }
  _endToken(e, r) {
    if (this._currentTokenStart === null)
      throw new fp("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(r));
    if (this._currentTokenType === null)
      throw new fp("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
    let i = { type: this._currentTokenType, parts: e, sourceSpan: (r ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
    return this.tokens.push(i), this._currentTokenStart = null, this._currentTokenType = null, i;
  }
  _createError(e, r) {
    this._isInExpansionForm() && (e += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
    let i = new fp(e, this._currentTokenType, r);
    return this._currentTokenStart = null, this._currentTokenType = null, new mp(i);
  }
  handleError(e) {
    if (e instanceof Pm && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), e instanceof mp)
      this.errors.push(e.error);
    else
      throw e;
  }
  _attemptCharCode(e) {
    return this._cursor.peek() === e ? (this._cursor.advance(), !0) : !1;
  }
  _attemptCharCodeCaseInsensitive(e) {
    return KB(this._cursor.peek(), e) ? (this._cursor.advance(), !0) : !1;
  }
  _requireCharCode(e) {
    let r = this._cursor.clone();
    if (!this._attemptCharCode(e))
      throw this._createError(Us(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptStr(e) {
    let r = e.length;
    if (this._cursor.charsLeft() < r)
      return !1;
    let i = this._cursor.clone();
    for (let n = 0; n < r; n++)
      if (!this._attemptCharCode(e.charCodeAt(n)))
        return this._cursor = i, !1;
    return !0;
  }
  _attemptStrCaseInsensitive(e) {
    for (let r = 0; r < e.length; r++)
      if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(r)))
        return !1;
    return !0;
  }
  _requireStr(e) {
    let r = this._cursor.clone();
    if (!this._attemptStr(e))
      throw this._createError(Us(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _requireStrCaseInsensitive(e) {
    let r = this._cursor.clone();
    if (!this._attemptStrCaseInsensitive(e))
      throw this._createError(Us(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptCharCodeUntilFn(e) {
    for (; !e(this._cursor.peek()); )
      this._cursor.advance();
  }
  _requireCharCodeUntilFn(e, r) {
    let i = this._cursor.clone();
    if (this._attemptCharCodeUntilFn(e), this._cursor.diff(i) < r)
      throw this._createError(Us(this._cursor.peek()), this._cursor.getSpan(i));
  }
  _attemptUntilChar(e) {
    for (; this._cursor.peek() !== e; )
      this._cursor.advance();
  }
  _readChar() {
    let e = String.fromCodePoint(this._cursor.peek());
    return this._cursor.advance(), e;
  }
  _consumeEntity(e) {
    this._beginToken(9);
    let r = this._cursor.clone();
    if (this._cursor.advance(), this._attemptCharCode(35)) {
      let i = this._attemptCharCode(120) || this._attemptCharCode(88), n = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(GB), this._cursor.peek() != 59) {
        this._cursor.advance();
        let a = i ? cc.HEX : cc.DEC;
        throw this._createError(UB(a, this._cursor.getChars(r)), this._cursor.getSpan());
      }
      let s = this._cursor.getChars(n);
      this._cursor.advance();
      try {
        let a = parseInt(s, i ? 16 : 10);
        this._endToken([String.fromCharCode(a), this._cursor.getChars(r)]);
      } catch {
        throw this._createError(C0(this._cursor.getChars(r)), this._cursor.getSpan());
      }
    } else {
      let i = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(HB), this._cursor.peek() != 59)
        this._beginToken(e, r), this._cursor = i, this._endToken(["&"]);
      else {
        let n = this._cursor.getChars(i);
        this._cursor.advance();
        let s = uc[n];
        if (!s)
          throw this._createError(C0(n), this._cursor.getSpan(r));
        this._endToken([s, `&${n};`]);
      }
    }
  }
  _consumeRawText(e, r) {
    this._beginToken(e ? 6 : 7);
    let i = [];
    for (; ; ) {
      let n = this._cursor.clone(), s = r();
      if (this._cursor = n, s)
        break;
      e && this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(i.join(""))]), i.length = 0, this._consumeEntity(6), this._beginToken(6)) : i.push(this._readChar());
    }
    this._endToken([this._processCarriageReturns(i.join(""))]);
  }
  _consumeComment(e) {
    this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("-->")), this._beginToken(11), this._requireStr("-->"), this._endToken([]);
  }
  _consumeBogusComment(e) {
    this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._cursor.peek() === 62), this._beginToken(11), this._cursor.advance(), this._endToken([]);
  }
  _consumeCdata(e) {
    this._beginToken(12, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]);
  }
  _consumeDocType(e) {
    this._beginToken(18, e), this._endToken([]), this._consumeRawText(!1, () => this._cursor.peek() === 62), this._beginToken(19), this._cursor.advance(), this._endToken([]);
  }
  _consumePrefixAndName() {
    let e = this._cursor.clone(), r = "";
    for (; this._cursor.peek() !== 58 && !zB(this._cursor.peek()); )
      this._cursor.advance();
    let i;
    this._cursor.peek() === 58 ? (r = this._cursor.getChars(e), this._cursor.advance(), i = this._cursor.clone()) : i = e, this._requireCharCodeUntilFn(E0, r === "" ? 0 : 1);
    let n = this._cursor.getChars(i);
    return [r, n];
  }
  _consumeTagOpen(e) {
    let r, i, n, s = [];
    try {
      if (!Tm(this._cursor.peek()))
        throw this._createError(Us(this._cursor.peek()), this._cursor.getSpan(e));
      for (n = this._consumeTagOpenStart(e), i = n.parts[0], r = n.parts[1], this._attemptCharCodeUntilFn(St); this._cursor.peek() !== 47 && this._cursor.peek() !== 62 && this._cursor.peek() !== 60 && this._cursor.peek() !== 0; ) {
        let [l, u] = this._consumeAttributeName();
        if (this._attemptCharCodeUntilFn(St), this._attemptCharCode(61)) {
          this._attemptCharCodeUntilFn(St);
          let h = this._consumeAttributeValue();
          s.push({ prefix: l, name: u, value: h });
        } else
          s.push({ prefix: l, name: u });
        this._attemptCharCodeUntilFn(St);
      }
      this._consumeTagOpenEnd();
    } catch (l) {
      if (l instanceof mp) {
        n ? n.type = 4 : (this._beginToken(5, e), this._endToken(["<"]));
        return;
      }
      throw l;
    }
    if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === 2)
      return;
    let a = this._getTagContentType(r, i, this._fullNameStack.length > 0, s);
    this._handleFullNameStackForTagOpen(i, r), a === ei.RAW_TEXT ? this._consumeRawTextWithTagClose(i, r, !1) : a === ei.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(i, r, !0);
  }
  _consumeRawTextWithTagClose(e, r, i) {
    this._consumeRawText(i, () => !this._attemptCharCode(60) || !this._attemptCharCode(47) || (this._attemptCharCodeUntilFn(St), !this._attemptStrCaseInsensitive(e ? `${e}:${r}` : r)) ? !1 : (this._attemptCharCodeUntilFn(St), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((n) => n === 62, 3), this._cursor.advance(), this._endToken([e, r]), this._handleFullNameStackForTagClose(e, r);
  }
  _consumeTagOpenStart(e) {
    this._beginToken(0, e);
    let r = this._consumePrefixAndName();
    return this._endToken(r);
  }
  _consumeAttributeName() {
    let e = this._cursor.peek();
    if (e === 39 || e === 34)
      throw this._createError(Us(e), this._cursor.getSpan());
    this._beginToken(14);
    let r = this._consumePrefixAndName();
    return this._endToken(r), r;
  }
  _consumeAttributeValue() {
    let e;
    if (this._cursor.peek() === 39 || this._cursor.peek() === 34) {
      let r = this._cursor.peek();
      this._consumeQuote(r);
      let i = () => this._cursor.peek() === r;
      e = this._consumeWithInterpolation(16, 17, i, i), this._consumeQuote(r);
    } else {
      let r = () => E0(this._cursor.peek());
      e = this._consumeWithInterpolation(16, 17, r, r);
    }
    return e;
  }
  _consumeQuote(e) {
    this._beginToken(15), this._requireCharCode(e), this._endToken([String.fromCodePoint(e)]);
  }
  _consumeTagOpenEnd() {
    let e = this._attemptCharCode(47) ? 2 : 1;
    this._beginToken(e), this._requireCharCode(62), this._endToken([]);
  }
  _consumeTagClose(e) {
    if (this._beginToken(3, e), this._attemptCharCodeUntilFn(St), this._allowHtmComponentClosingTags && this._attemptCharCode(47))
      this._attemptCharCodeUntilFn(St), this._requireCharCode(62), this._endToken([]);
    else {
      let [r, i] = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(St), this._requireCharCode(62), this._endToken([r, i]), this._handleFullNameStackForTagClose(r, i);
    }
  }
  _consumeExpansionFormStart() {
    this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
    let e = this._readUntil(44), r = this._processCarriageReturns(e);
    if (this._i18nNormalizeLineEndingsInICUs)
      this._endToken([r]);
    else {
      let n = this._endToken([e]);
      r !== e && this.nonNormalizedIcuExpressions.push(n);
    }
    this._requireCharCode(44), this._attemptCharCodeUntilFn(St), this._beginToken(7);
    let i = this._readUntil(44);
    this._endToken([i]), this._requireCharCode(44), this._attemptCharCodeUntilFn(St);
  }
  _consumeExpansionCaseStart() {
    this._beginToken(21);
    let e = this._readUntil(123).trim();
    this._endToken([e]), this._attemptCharCodeUntilFn(St), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(St), this._expansionCaseStack.push(22);
  }
  _consumeExpansionCaseEnd() {
    this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(St), this._expansionCaseStack.pop();
  }
  _consumeExpansionFormEnd() {
    this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
  }
  _consumeWithInterpolation(e, r, i, n) {
    this._beginToken(e);
    let s = [];
    for (; !i(); ) {
      let l = this._cursor.clone();
      this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(s.join(""))], l), s.length = 0, this._consumeInterpolation(r, l, n), this._beginToken(e)) : this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(s.join(""))]), s.length = 0, this._consumeEntity(e), this._beginToken(e)) : s.push(this._readChar());
    }
    this._inInterpolation = !1;
    let a = this._processCarriageReturns(s.join(""));
    return this._endToken([a]), a;
  }
  _consumeInterpolation(e, r, i) {
    let n = [];
    this._beginToken(e, r), n.push(this._interpolationConfig.start);
    let s = this._cursor.clone(), a = null, l = !1;
    for (; this._cursor.peek() !== 0 && (i === null || !i()); ) {
      let u = this._cursor.clone();
      if (this._isTagStart()) {
        this._cursor = u, n.push(this._getProcessedChars(s, u)), this._endToken(n);
        return;
      }
      if (a === null)
        if (this._attemptStr(this._interpolationConfig.end)) {
          n.push(this._getProcessedChars(s, u)), n.push(this._interpolationConfig.end), this._endToken(n);
          return;
        } else
          this._attemptStr("//") && (l = !0);
      let h = this._cursor.peek();
      this._cursor.advance(), h === 92 ? this._cursor.advance() : h === a ? a = null : !l && a === null && p0(h) && (a = h);
    }
    n.push(this._getProcessedChars(s, this._cursor)), this._endToken(n);
  }
  _getProcessedChars(e, r) {
    return this._processCarriageReturns(r.getChars(e));
  }
  _isTextEnd() {
    return !!(this._isTagStart() || this._cursor.peek() === 0 || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === 125 && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._cursor.peek() === 125));
  }
  _isTagStart() {
    if (this._cursor.peek() === 60) {
      let e = this._cursor.clone();
      e.advance();
      let r = e.peek();
      if (97 <= r && r <= 122 || 65 <= r && r <= 90 || r === 47 || r === 33)
        return !0;
    }
    return !1;
  }
  _isBlockStart() {
    if (this._tokenizeBlocks && this._cursor.peek() === 64) {
      let e = this._cursor.clone();
      if (e.advance(), k0(e.peek()))
        return !0;
    }
    return !1;
  }
  _readUntil(e) {
    let r = this._cursor.clone();
    return this._attemptUntilChar(e), this._cursor.getChars(r);
  }
  _isInExpansion() {
    return this._isInExpansionCase() || this._isInExpansionForm();
  }
  _isInExpansionCase() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 22;
  }
  _isInExpansionForm() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 20;
  }
  isExpansionFormStart() {
    if (this._cursor.peek() !== 123)
      return !1;
    if (this._interpolationConfig) {
      let e = this._cursor.clone(), r = this._attemptStr(this._interpolationConfig.start);
      return this._cursor = e, !r;
    }
    return !0;
  }
  _handleFullNameStackForTagOpen(e, r) {
    let i = lc(e, r);
    (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === i) && this._fullNameStack.push(i);
  }
  _handleFullNameStackForTagClose(e, r) {
    let i = lc(e, r);
    this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === i && this._fullNameStack.pop();
  }
};
function St(t) {
  return !km(t) || t === 0;
}
function E0(t) {
  return km(t) || t === 62 || t === 60 || t === 47 || t === 39 || t === 34 || t === 61 || t === 0;
}
function zB(t) {
  return (t < 97 || 122 < t) && (t < 65 || 90 < t) && (t < 48 || t > 57);
}
function GB(t) {
  return t === 59 || t === 0 || !eB(t);
}
function HB(t) {
  return t === 59 || t === 0 || !Tm(t);
}
function JB(t) {
  return t !== 125;
}
function KB(t, e) {
  return A0(t) === A0(e);
}
function A0(t) {
  return t >= 97 && t <= 122 ? t - 97 + 65 : t;
}
function k0(t) {
  return Tm(t) || UD(t) || t === 95;
}
function T0(t) {
  return t !== 59 && St(t);
}
function e8(t) {
  let e = [], r;
  for (let i = 0; i < t.length; i++) {
    let n = t[i];
    r && r.type === 5 && n.type === 5 || r && r.type === 16 && n.type === 16 ? (r.parts[0] += n.parts[0], r.sourceSpan.end = n.sourceSpan.end) : (r = n, e.push(r));
  }
  return e;
}
var i2 = class wd {
  constructor(e, r) {
    if (e instanceof wd) {
      this.file = e.file, this.input = e.input, this.end = e.end;
      let i = e.state;
      this.state = { peek: i.peek, offset: i.offset, line: i.line, column: i.column };
    } else {
      if (!r)
        throw new Error("Programming error: the range argument must be provided with a file argument.");
      this.file = e, this.input = e.content, this.end = r.endPos, this.state = { peek: -1, offset: r.startPos, line: r.startLine, column: r.startCol };
    }
  }
  clone() {
    return new wd(this);
  }
  peek() {
    return this.state.peek;
  }
  charsLeft() {
    return this.end - this.state.offset;
  }
  diff(e) {
    return this.state.offset - e.state.offset;
  }
  advance() {
    this.advanceState(this.state);
  }
  init() {
    this.updatePeek(this.state);
  }
  getSpan(e, r) {
    e = e || this;
    let i = e;
    if (r)
      for (; this.diff(e) > 0 && r.indexOf(e.peek()) !== -1; )
        i === e && (e = e.clone()), e.advance();
    let n = this.locationFromCursor(e), s = this.locationFromCursor(this), a = i !== e ? this.locationFromCursor(i) : n;
    return new _e(n, s, a);
  }
  getChars(e) {
    return this.input.substring(e.state.offset, this.state.offset);
  }
  charAt(e) {
    return this.input.charCodeAt(e);
  }
  advanceState(e) {
    if (e.offset >= this.end)
      throw this.state = e, new Pm('Unexpected character "EOF"', this);
    let r = this.charAt(e.offset);
    r === 10 ? (e.line++, e.column = 0) : YD(r) || e.column++, e.offset++, this.updatePeek(e);
  }
  updatePeek(e) {
    e.peek = e.offset >= this.end ? 0 : this.charAt(e.offset);
  }
  locationFromCursor(e) {
    return new bd(e.file, e.state.offset, e.state.line, e.state.column);
  }
}, t8 = class Sd extends i2 {
  constructor(e, r) {
    e instanceof Sd ? (super(e), this.internalState = { ...e.internalState }) : (super(e, r), this.internalState = this.state);
  }
  advance() {
    this.state = this.internalState, super.advance(), this.processEscapeSequence();
  }
  init() {
    super.init(), this.processEscapeSequence();
  }
  clone() {
    return new Sd(this);
  }
  getChars(e) {
    let r = e.clone(), i = "";
    for (; r.internalState.offset < this.internalState.offset; )
      i += String.fromCodePoint(r.peek()), r.advance();
    return i;
  }
  processEscapeSequence() {
    let e = () => this.internalState.peek;
    if (e() === 92)
      if (this.internalState = { ...this.state }, this.advanceState(this.internalState), e() === 110)
        this.state.peek = 10;
      else if (e() === 114)
        this.state.peek = 13;
      else if (e() === 118)
        this.state.peek = 11;
      else if (e() === 116)
        this.state.peek = 9;
      else if (e() === 98)
        this.state.peek = 8;
      else if (e() === 102)
        this.state.peek = 12;
      else if (e() === 117)
        if (this.advanceState(this.internalState), e() === 123) {
          this.advanceState(this.internalState);
          let r = this.clone(), i = 0;
          for (; e() !== 125; )
            this.advanceState(this.internalState), i++;
          this.state.peek = this.decodeHexDigits(r, i);
        } else {
          let r = this.clone();
          this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 4);
        }
      else if (e() === 120) {
        this.advanceState(this.internalState);
        let r = this.clone();
        this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 2);
      } else if (h0(e())) {
        let r = "", i = 0, n = this.clone();
        for (; h0(e()) && i < 3; )
          n = this.clone(), r += String.fromCodePoint(e()), this.advanceState(this.internalState), i++;
        this.state.peek = parseInt(r, 8), this.internalState = n.internalState;
      } else
        YD(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
  }
  decodeHexDigits(e, r) {
    let i = this.input.slice(e.internalState.offset, e.internalState.offset + r), n = parseInt(i, 16);
    if (isNaN(n))
      throw e.state = e.internalState, new Pm("Invalid hexadecimal escape sequence", e);
    return n;
  }
}, Pm = class {
  constructor(e, r) {
    this.msg = e, this.cursor = r;
  }
}, Pr = class n2 extends HD {
  static create(e, r, i) {
    return new n2(e, r, i);
  }
  constructor(e, r, i) {
    super(r, i), this.elementName = e;
  }
}, r8 = class {
  constructor(e, r) {
    this.rootNodes = e, this.errors = r;
  }
}, i8 = class {
  constructor(e) {
    this.getTagDefinition = e;
  }
  parse(e, r, i, n = !1, s) {
    let a = (O) => (D, ...v) => O(D.toLowerCase(), ...v), l = n ? this.getTagDefinition : a(this.getTagDefinition), u = (O) => l(O).getContentType(), h = n ? s : a(s), p = XB(e, r, s ? (O, D, v, w) => {
      let x = h(O, D, v, w);
      return x !== void 0 ? x : u(O);
    } : u, i), d = i && i.canSelfClose || !1, m = i && i.allowHtmComponentClosingTags || !1, y = new n8(p.tokens, l, d, m, n);
    return y.build(), new r8(y.rootNodes, p.errors.concat(y.errors));
  }
}, n8 = class s2 {
  constructor(e, r, i, n, s) {
    this.tokens = e, this.getTagDefinition = r, this.canSelfClose = i, this.allowHtmComponentClosingTags = n, this.isTagNameCaseSensitive = s, this._index = -1, this._containerStack = [], this.rootNodes = [], this.errors = [], this._advance();
  }
  build() {
    for (; this._peek.type !== 30; )
      this._peek.type === 0 || this._peek.type === 4 ? this._consumeStartTag(this._advance()) : this._peek.type === 3 ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === 12 ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === 10 ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6 ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === 20 ? this._consumeExpansion(this._advance()) : this._peek.type === 25 ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === 27 ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === 29 ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === 18 ? this._consumeDocType(this._advance()) : this._advance();
    for (let e of this._containerStack)
      e instanceof Vs && this.errors.push(Pr.create(e.name, e.sourceSpan, `Unclosed block "${e.name}"`));
  }
  _advance() {
    let e = this._peek;
    return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e;
  }
  _advanceIf(e) {
    return this._peek.type === e ? this._advance() : null;
  }
  _consumeCdata(e) {
    let r = this._advance(), i = this._getText(r), n = this._advanceIf(13);
    this._addToParent(new BB(i, new _e(e.sourceSpan.start, (n || r).sourceSpan.end), [r]));
  }
  _consumeComment(e) {
    let r = this._advanceIf(7), i = this._advanceIf(11), n = r != null ? r.parts[0].trim() : null, s = new _e(e.sourceSpan.start, (i || r || e).sourceSpan.end);
    this._addToParent(new MB(n, s));
  }
  _consumeDocType(e) {
    let r = this._advanceIf(7), i = this._advanceIf(19), n = r != null ? r.parts[0].trim() : null, s = new _e(e.sourceSpan.start, (i || r || e).sourceSpan.end);
    this._addToParent(new LB(n, s));
  }
  _consumeExpansion(e) {
    let r = this._advance(), i = this._advance(), n = [];
    for (; this._peek.type === 21; ) {
      let a = this._parseExpansionCase();
      if (!a)
        return;
      n.push(a);
    }
    if (this._peek.type !== 24) {
      this.errors.push(Pr.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      return;
    }
    let s = new _e(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart);
    this._addToParent(new IB(r.parts[0], i.parts[0], n, s, r.sourceSpan)), this._advance();
  }
  _parseExpansionCase() {
    let e = this._advance();
    if (this._peek.type !== 22)
      return this.errors.push(Pr.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
    let r = this._advance(), i = this._collectExpansionExpTokens(r);
    if (!i)
      return null;
    let n = this._advance();
    i.push({ type: 30, parts: [], sourceSpan: n.sourceSpan });
    let s = new s2(i, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
    if (s.build(), s.errors.length > 0)
      return this.errors = this.errors.concat(s.errors), null;
    let a = new _e(e.sourceSpan.start, n.sourceSpan.end, e.sourceSpan.fullStart), l = new _e(r.sourceSpan.start, n.sourceSpan.end, r.sourceSpan.fullStart);
    return new NB(e.parts[0], s.rootNodes, a, e.sourceSpan, l);
  }
  _collectExpansionExpTokens(e) {
    let r = [], i = [22];
    for (; ; ) {
      if ((this._peek.type === 20 || this._peek.type === 22) && i.push(this._peek.type), this._peek.type === 23)
        if (P0(i, 22)) {
          if (i.pop(), i.length === 0)
            return r;
        } else
          return this.errors.push(Pr.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 24)
        if (P0(i, 20))
          i.pop();
        else
          return this.errors.push(Pr.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 30)
        return this.errors.push(Pr.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      r.push(this._advance());
    }
  }
  _getText(e) {
    let r = e.parts[0];
    if (r.length > 0 && r[0] == `
`) {
      let i = this._getClosestParentElement();
      i != null && i.children.length == 0 && this.getTagDefinition(i.name).ignoreFirstLf && (r = r.substring(1));
    }
    return r;
  }
  _consumeText(e) {
    let r = [e], i = e.sourceSpan, n = e.parts[0];
    if (n.length > 0 && n[0] === `
`) {
      let s = this._getContainer();
      s != null && s.children.length === 0 && this.getTagDefinition(s.name).ignoreFirstLf && (n = n.substring(1), r[0] = { type: e.type, sourceSpan: e.sourceSpan, parts: [n] });
    }
    for (; this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9; )
      e = this._advance(), r.push(e), e.type === 8 ? n += e.parts.join("").replace(/&([^;]+);/g, F0) : e.type === 9 ? n += e.parts[0] : n += e.parts.join("");
    if (n.length > 0) {
      let s = e.sourceSpan;
      this._addToParent(new $B(n, new _e(i.start, s.end, i.fullStart, i.details), r));
    }
  }
  _closeVoidElement() {
    let e = this._getContainer();
    e instanceof fn && this.getTagDefinition(e.name).isVoid && this._containerStack.pop();
  }
  _consumeStartTag(e) {
    let [r, i] = e.parts, n = [];
    for (; this._peek.type === 14; )
      n.push(this._consumeAttr(this._advance()));
    let s = this._getElementFullName(r, i, this._getClosestParentElement()), a = !1;
    if (this._peek.type === 2) {
      this._advance(), a = !0;
      let y = this.getTagDefinition(s);
      this.canSelfClose || y.canSelfClose || Ru(s) !== null || y.isVoid || this.errors.push(Pr.create(s, e.sourceSpan, `Only void, custom and foreign elements can be self closed "${e.parts[1]}"`));
    } else
      this._peek.type === 1 && (this._advance(), a = !1);
    let l = this._peek.sourceSpan.fullStart, u = new _e(e.sourceSpan.start, l, e.sourceSpan.fullStart), h = new _e(e.sourceSpan.start, l, e.sourceSpan.fullStart), p = new _e(e.sourceSpan.start.moveBy(1), e.sourceSpan.end), d = new fn(s, n, [], u, h, void 0, p), m = this._getContainer();
    this._pushContainer(d, m instanceof fn && this.getTagDefinition(m.name).isClosedByChild(d.name)), a ? this._popContainer(s, fn, u) : e.type === 4 && (this._popContainer(s, fn, null), this.errors.push(Pr.create(s, u, `Opening tag "${s}" not terminated.`)));
  }
  _pushContainer(e, r) {
    r && this._containerStack.pop(), this._addToParent(e), this._containerStack.push(e);
  }
  _consumeEndTag(e) {
    let r = this.allowHtmComponentClosingTags && e.parts.length === 0 ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getClosestParentElement());
    if (r && this.getTagDefinition(r).isVoid)
      this.errors.push(Pr.create(r, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
    else if (!this._popContainer(r, fn, e.sourceSpan)) {
      let i = `Unexpected closing tag "${r}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
      this.errors.push(Pr.create(r, e.sourceSpan, i));
    }
  }
  _popContainer(e, r, i) {
    let n = !1;
    for (let s = this._containerStack.length - 1; s >= 0; s--) {
      let a = this._containerStack[s];
      if (Ru(a.name) ? a.name === e : (e == null || a.name.toLowerCase() === e.toLowerCase()) && a instanceof r)
        return a.endSourceSpan = i, a.sourceSpan.end = i !== null ? i.end : a.sourceSpan.end, this._containerStack.splice(s, this._containerStack.length - s), !n;
      (a instanceof Vs || a instanceof fn && !this.getTagDefinition(a.name).closedByParent) && (n = !0);
    }
    return !1;
  }
  _consumeAttr(e) {
    let r = lc(e.parts[0], e.parts[1]), i = e.sourceSpan.end, n;
    this._peek.type === 15 && (n = this._advance());
    let s = "", a = [], l, u;
    if (this._peek.type === 16)
      for (l = this._peek.sourceSpan, u = this._peek.sourceSpan.end; this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9; ) {
        let p = this._advance();
        a.push(p), p.type === 17 ? s += p.parts.join("").replace(/&([^;]+);/g, F0) : p.type === 9 ? s += p.parts[0] : s += p.parts.join(""), u = i = p.sourceSpan.end;
      }
    this._peek.type === 15 && (u = i = this._advance().sourceSpan.end);
    let h = l && u && new _e((n == null ? void 0 : n.sourceSpan.start) ?? l.start, u, (n == null ? void 0 : n.sourceSpan.fullStart) ?? l.fullStart);
    return new _B(r, s, new _e(e.sourceSpan.start, i, e.sourceSpan.fullStart), e.sourceSpan, h, a.length > 0 ? a : void 0, void 0);
  }
  _consumeBlockOpen(e) {
    let r = [];
    for (; this._peek.type === 28; ) {
      let l = this._advance();
      r.push(new S0(l.parts[0], l.sourceSpan));
    }
    this._peek.type === 26 && this._advance();
    let i = this._peek.sourceSpan.fullStart, n = new _e(e.sourceSpan.start, i, e.sourceSpan.fullStart), s = new _e(e.sourceSpan.start, i, e.sourceSpan.fullStart), a = new Vs(e.parts[0], r, [], n, s);
    this._pushContainer(a, !1);
  }
  _consumeBlockClose(e) {
    this._popContainer(null, Vs, e.sourceSpan) || this.errors.push(Pr.create(null, e.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
  }
  _consumeIncompleteBlock(e) {
    let r = [];
    for (; this._peek.type === 28; ) {
      let l = this._advance();
      r.push(new S0(l.parts[0], l.sourceSpan));
    }
    let i = this._peek.sourceSpan.fullStart, n = new _e(e.sourceSpan.start, i, e.sourceSpan.fullStart), s = new _e(e.sourceSpan.start, i, e.sourceSpan.fullStart), a = new Vs(e.parts[0], r, [], n, s);
    this._pushContainer(a, !1), this._popContainer(null, Vs, null), this.errors.push(Pr.create(e.parts[0], n, `Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
  }
  _getContainer() {
    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
  }
  _getClosestParentElement() {
    for (let e = this._containerStack.length - 1; e > -1; e--)
      if (this._containerStack[e] instanceof fn)
        return this._containerStack[e];
    return null;
  }
  _addToParent(e) {
    let r = this._getContainer();
    r === null ? this.rootNodes.push(e) : r.children.push(e);
  }
  _getElementFullName(e, r, i) {
    if (e === "" && (e = this.getTagDefinition(r).implicitNamespacePrefix || "", e === "" && i != null)) {
      let n = gh(i.name)[1];
      this.getTagDefinition(n).preventNamespaceInheritance || (e = Ru(i.name));
    }
    return lc(e, r);
  }
};
function P0(t, e) {
  return t.length > 0 && t[t.length - 1] === e;
}
function F0(t, e) {
  return uc[e] !== void 0 ? uc[e] || t : /^#x[a-f0-9]+$/i.test(e) ? String.fromCodePoint(parseInt(e.slice(2), 16)) : /^#\d+$/.test(e) ? String.fromCodePoint(parseInt(e.slice(1), 10)) : t;
}
var s8 = class extends i8 {
  constructor() {
    super(vd);
  }
  parse(e, r, i, n = !1, s) {
    return super.parse(e, r, i, n, s);
  }
}, gp = null, a8 = () => (gp || (gp = new s8()), gp);
function $0(t, e = {}) {
  let { canSelfClose: r = !1, allowHtmComponentClosingTags: i = !1, isTagNameCaseSensitive: n = !1, getTagContentType: s, tokenizeAngularBlocks: a = !1 } = e;
  return a8().parse(t, "angular-html-parser", { tokenizeExpansionForms: a, interpolationConfig: void 0, canSelfClose: r, allowHtmComponentClosingTags: i, tokenizeBlocks: a }, n, s);
}
function o8(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var l8 = o8, u8 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
function c8(t) {
  let e = t.match(u8);
  if (!e)
    return { content: t };
  let { startDelimiter: r, language: i, value: n = "", endDelimiter: s } = e.groups, a = i.trim() || "yaml";
  if (r === "+++" && (a = "toml"), a !== "yaml" && r !== s)
    return { content: t };
  let [l] = e;
  return { frontMatter: { type: "front-matter", lang: a, value: n, startDelimiter: r, endDelimiter: s, raw: l.replace(/\n$/, "") }, content: vr(!1, l, /[^\n]/g, " ") + t.slice(l.length) };
}
var h8 = c8, su = { attrs: !0, children: !0, cases: !0, expression: !0 }, B0 = /* @__PURE__ */ new Set(["parent"]), p8 = class Do {
  constructor(e = {}) {
    for (let r of /* @__PURE__ */ new Set([...B0, ...Object.keys(e)]))
      this.setProperty(r, e[r]);
  }
  setProperty(e, r) {
    if (this[e] !== r) {
      if (e in su && (r = r.map((i) => this.createChild(i))), !B0.has(e)) {
        this[e] = r;
        return;
      }
      Object.defineProperty(this, e, { value: r, enumerable: !1, configurable: !0 });
    }
  }
  map(e) {
    let r;
    for (let i in su) {
      let n = this[i];
      if (n) {
        let s = d8(n, (a) => a.map(e));
        r !== n && (r || (r = new Do({ parent: this.parent })), r.setProperty(i, s));
      }
    }
    if (r)
      for (let i in this)
        i in su || (r[i] = this[i]);
    return e(r || this);
  }
  walk(e) {
    for (let r in su) {
      let i = this[r];
      if (i)
        for (let n = 0; n < i.length; n++)
          i[n].walk(e);
    }
    e(this);
  }
  createChild(e) {
    let r = e instanceof Do ? e.clone() : new Do(e);
    return r.setProperty("parent", this), r;
  }
  insertChildBefore(e, r) {
    this.children.splice(this.children.indexOf(e), 0, this.createChild(r));
  }
  removeChild(e) {
    this.children.splice(this.children.indexOf(e), 1);
  }
  replaceChild(e, r) {
    this.children[this.children.indexOf(e)] = this.createChild(r);
  }
  clone() {
    return new Do(this);
  }
  get firstChild() {
    var e;
    return (e = this.children) == null ? void 0 : e[0];
  }
  get lastChild() {
    var e;
    return (e = this.children) == null ? void 0 : e[this.children.length - 1];
  }
  get prev() {
    var e, r;
    return (r = (e = this.parent) == null ? void 0 : e.children) == null ? void 0 : r[this.parent.children.indexOf(this) - 1];
  }
  get next() {
    var e, r;
    return (r = (e = this.parent) == null ? void 0 : e.children) == null ? void 0 : r[this.parent.children.indexOf(this) + 1];
  }
  get rawName() {
    return this.hasExplicitNamespace ? this.fullName : this.name;
  }
  get fullName() {
    return this.namespace ? this.namespace + ":" + this.name : this.name;
  }
  get attrMap() {
    return Object.fromEntries(this.attrs.map((e) => [e.fullName, e.value]));
  }
};
function d8(t, e) {
  let r = t.map(e);
  return r.some((i, n) => i !== t[n]) ? r : t;
}
var f8 = [{ regex: /^(\[if([^\]]*)]>)(.*?)<!\s*\[endif]$/s, parse: g8 }, { regex: /^\[if([^\]]*)]><!$/, parse: y8 }, { regex: /^<!\s*\[endif]$/, parse: O8 }];
function m8(t, e) {
  if (t.value)
    for (let { regex: r, parse: i } of f8) {
      let n = t.value.match(r);
      if (n)
        return i(t, e, n);
    }
  return null;
}
function g8(t, e, r) {
  let [, i, n, s] = r, a = 4 + i.length, l = t.sourceSpan.start.moveBy(a), u = l.moveBy(s.length), [h, p] = (() => {
    try {
      return [!0, e(s, l).children];
    } catch {
      return [!1, [{ type: "text", value: s, sourceSpan: new _e(l, u) }]];
    }
  })();
  return { type: "ieConditionalComment", complete: h, children: p, condition: vr(!1, n.trim(), /\s+/g, " "), sourceSpan: t.sourceSpan, startSourceSpan: new _e(t.sourceSpan.start, l), endSourceSpan: new _e(u, t.sourceSpan.end) };
}
function y8(t, e, r) {
  let [, i] = r;
  return { type: "ieConditionalStartComment", condition: vr(!1, i.trim(), /\s+/g, " "), sourceSpan: t.sourceSpan };
}
function O8(t) {
  return { type: "ieConditionalEndComment", sourceSpan: t.sourceSpan };
}
var yp = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set(["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "slot", "spellcheck", "style", "tabindex", "title", "translate"])], ["a", /* @__PURE__ */ new Set(["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"])], ["applet", /* @__PURE__ */ new Set(["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"])], ["area", /* @__PURE__ */ new Set(["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"])], ["audio", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"])], ["base", /* @__PURE__ */ new Set(["href", "target"])], ["basefont", /* @__PURE__ */ new Set(["color", "face", "size"])], ["blockquote", /* @__PURE__ */ new Set(["cite"])], ["body", /* @__PURE__ */ new Set(["alink", "background", "bgcolor", "link", "text", "vlink"])], ["br", /* @__PURE__ */ new Set(["clear"])], ["button", /* @__PURE__ */ new Set(["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "popovertarget", "popovertargetaction", "type", "value"])], ["canvas", /* @__PURE__ */ new Set(["height", "width"])], ["caption", /* @__PURE__ */ new Set(["align"])], ["col", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["colgroup", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["data", /* @__PURE__ */ new Set(["value"])], ["del", /* @__PURE__ */ new Set(["cite", "datetime"])], ["details", /* @__PURE__ */ new Set(["name", "open"])], ["dialog", /* @__PURE__ */ new Set(["open"])], ["dir", /* @__PURE__ */ new Set(["compact"])], ["div", /* @__PURE__ */ new Set(["align"])], ["dl", /* @__PURE__ */ new Set(["compact"])], ["embed", /* @__PURE__ */ new Set(["height", "src", "type", "width"])], ["fieldset", /* @__PURE__ */ new Set(["disabled", "form", "name"])], ["font", /* @__PURE__ */ new Set(["color", "face", "size"])], ["form", /* @__PURE__ */ new Set(["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"])], ["frame", /* @__PURE__ */ new Set(["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"])], ["frameset", /* @__PURE__ */ new Set(["cols", "rows"])], ["h1", /* @__PURE__ */ new Set(["align"])], ["h2", /* @__PURE__ */ new Set(["align"])], ["h3", /* @__PURE__ */ new Set(["align"])], ["h4", /* @__PURE__ */ new Set(["align"])], ["h5", /* @__PURE__ */ new Set(["align"])], ["h6", /* @__PURE__ */ new Set(["align"])], ["head", /* @__PURE__ */ new Set(["profile"])], ["hr", /* @__PURE__ */ new Set(["align", "noshade", "size", "width"])], ["html", /* @__PURE__ */ new Set(["manifest", "version"])], ["iframe", /* @__PURE__ */ new Set(["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"])], ["img", /* @__PURE__ */ new Set(["align", "alt", "border", "crossorigin", "decoding", "fetchpriority", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"])], ["input", /* @__PURE__ */ new Set(["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "popovertarget", "popovertargetaction", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"])], ["ins", /* @__PURE__ */ new Set(["cite", "datetime"])], ["isindex", /* @__PURE__ */ new Set(["prompt"])], ["label", /* @__PURE__ */ new Set(["for", "form"])], ["legend", /* @__PURE__ */ new Set(["align"])], ["li", /* @__PURE__ */ new Set(["type", "value"])], ["link", /* @__PURE__ */ new Set(["as", "blocking", "charset", "color", "crossorigin", "disabled", "fetchpriority", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"])], ["map", /* @__PURE__ */ new Set(["name"])], ["menu", /* @__PURE__ */ new Set(["compact"])], ["meta", /* @__PURE__ */ new Set(["charset", "content", "http-equiv", "media", "name", "scheme"])], ["meter", /* @__PURE__ */ new Set(["high", "low", "max", "min", "optimum", "value"])], ["object", /* @__PURE__ */ new Set(["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"])], ["ol", /* @__PURE__ */ new Set(["compact", "reversed", "start", "type"])], ["optgroup", /* @__PURE__ */ new Set(["disabled", "label"])], ["option", /* @__PURE__ */ new Set(["disabled", "label", "selected", "value"])], ["output", /* @__PURE__ */ new Set(["for", "form", "name"])], ["p", /* @__PURE__ */ new Set(["align"])], ["param", /* @__PURE__ */ new Set(["name", "type", "value", "valuetype"])], ["pre", /* @__PURE__ */ new Set(["width"])], ["progress", /* @__PURE__ */ new Set(["max", "value"])], ["q", /* @__PURE__ */ new Set(["cite"])], ["script", /* @__PURE__ */ new Set(["async", "blocking", "charset", "crossorigin", "defer", "fetchpriority", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"])], ["select", /* @__PURE__ */ new Set(["autocomplete", "disabled", "form", "multiple", "name", "required", "size"])], ["slot", /* @__PURE__ */ new Set(["name"])], ["source", /* @__PURE__ */ new Set(["height", "media", "sizes", "src", "srcset", "type", "width"])], ["style", /* @__PURE__ */ new Set(["blocking", "media", "type"])], ["table", /* @__PURE__ */ new Set(["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"])], ["tbody", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["td", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["template", /* @__PURE__ */ new Set(["shadowrootdelegatesfocus", "shadowrootmode"])], ["textarea", /* @__PURE__ */ new Set(["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"])], ["tfoot", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["th", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["thead", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["time", /* @__PURE__ */ new Set(["datetime"])], ["tr", /* @__PURE__ */ new Set(["align", "bgcolor", "char", "charoff", "valign"])], ["track", /* @__PURE__ */ new Set(["default", "kind", "label", "src", "srclang"])], ["ul", /* @__PURE__ */ new Set(["compact", "type"])], ["video", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"])]]), x8 = /* @__PURE__ */ new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
function D8(t) {
  if (t.type === "block") {
    if (t.name = vr(!1, t.name.toLowerCase(), /\s+/g, " ").trim(), t.type = "angularControlFlowBlock", !wm(t.parameters)) {
      delete t.parameters;
      return;
    }
    for (let e of t.parameters)
      e.type = "angularControlFlowBlockParameter";
    t.parameters = { type: "angularControlFlowBlockParameters", children: t.parameters, sourceSpan: new _e(t.parameters[0].sourceSpan.start, xl(!1, t.parameters, -1).sourceSpan.end) };
  }
}
function b8(t) {
  (t.type === "plural" || t.type === "select") && (t.clause = t.type, t.type = "angularIcuExpression"), t.type === "expansionCase" && (t.type = "angularIcuCase");
}
function a2(t, e, r) {
  let { name: i, canSelfClose: n = !0, normalizeTagName: s = !1, normalizeAttributeName: a = !1, allowHtmComponentClosingTags: l = !1, isTagNameCaseSensitive: u = !1, shouldParseAsRawText: h } = e, { rootNodes: p, errors: d } = $0(t, { canSelfClose: n, allowHtmComponentClosingTags: l, isTagNameCaseSensitive: u, getTagContentType: h ? (...x) => h(...x) ? ei.RAW_TEXT : void 0 : void 0, tokenizeAngularBlocks: i === "angular" ? !0 : void 0 });
  if (i === "vue") {
    if (p.some((C) => C.type === "docType" && C.value === "html" || C.type === "element" && C.name.toLowerCase() === "html"))
      return a2(t, l2, r);
    let x, S = () => x ?? (x = $0(t, { canSelfClose: n, allowHtmComponentClosingTags: l, isTagNameCaseSensitive: u })), k = (C) => S().rootNodes.find(({ startSourceSpan: A }) => A && A.start.offset === C.startSourceSpan.start.offset) ?? C;
    for (let [C, A] of p.entries()) {
      let { endSourceSpan: P, startSourceSpan: I } = A;
      if (P === null)
        d = S().errors, p[C] = k(A);
      else if (v8(A, r)) {
        let B = S().errors.find((_) => _.span.start.offset > I.start.offset && _.span.start.offset < P.end.offset);
        B && I0(B), p[C] = k(A);
      }
    }
  }
  d.length > 0 && I0(d[0]);
  let m = (x) => {
    let S = x.name.startsWith(":") ? x.name.slice(1).split(":")[0] : null, k = x.nameSpan.toString(), C = S !== null && k.startsWith(`${S}:`), A = C ? k.slice(S.length + 1) : k;
    x.name = A, x.namespace = S, x.hasExplicitNamespace = C;
  }, y = (x) => {
    switch (x.type) {
      case "element":
        m(x);
        for (let S of x.attrs)
          m(S), S.valueSpan ? (S.value = S.valueSpan.toString(), /["']/.test(S.value[0]) && (S.value = S.value.slice(1, -1))) : S.value = null;
        break;
      case "comment":
        x.value = x.sourceSpan.toString().slice(4, -3);
        break;
      case "text":
        x.value = x.sourceSpan.toString();
        break;
    }
  }, O = (x, S) => {
    let k = x.toLowerCase();
    return S(k) ? k : x;
  }, D = (x) => {
    if (x.type === "element" && (s && (!x.namespace || x.namespace === x.tagDefinition.implicitNamespacePrefix || Vo(x)) && (x.name = O(x.name, (S) => x8.has(S))), a))
      for (let S of x.attrs)
        S.namespace || (S.name = O(S.name, (k) => yp.has(x.name) && (yp.get("*").has(k) || yp.get(x.name).has(k))));
  }, v = (x) => {
    x.sourceSpan && x.endSourceSpan && (x.sourceSpan = new _e(x.sourceSpan.start, x.endSourceSpan.end));
  }, w = (x) => {
    if (x.type === "element") {
      let S = vd(u ? x.name : x.name.toLowerCase());
      !x.namespace || x.namespace === S.implicitNamespacePrefix || Vo(x) ? x.tagDefinition = S : x.tagDefinition = vd("");
    }
  };
  return e2(new class extends QB {
    visitExpansionCase(x, S) {
      i === "angular" && this.visitChildren(S, (k) => {
        k(x.expression);
      });
    }
    visit(x) {
      y(x), w(x), D(x), v(x);
    }
  }(), p), p;
}
function v8(t, e) {
  var r;
  if (t.type !== "element" || t.name !== "template")
    return !1;
  let i = (r = t.attrs.find((n) => n.name === "lang")) == null ? void 0 : r.value;
  return !i || uh(e, { language: i }) === "html";
}
function I0(t) {
  let { msg: e, span: { start: r, end: i } } = t;
  throw l8(e, { loc: { start: { line: r.line + 1, column: r.col + 1 }, end: { line: i.line + 1, column: i.col + 1 } }, cause: t });
}
function o2(t, e, r = {}, i = !0) {
  let { frontMatter: n, content: s } = i ? h8(t) : { frontMatter: null, content: t }, a = new GD(t, r.filepath), l = new bd(a, 0, 0, 0), u = l.moveBy(t.length), h = { type: "root", sourceSpan: new _e(l, u), children: a2(s, e, r) };
  if (n) {
    let m = new bd(a, 0, 0, 0), y = m.moveBy(n.raw.length);
    n.sourceSpan = new _e(m, y), h.children.unshift(n);
  }
  let p = new p8(h), d = (m, y) => {
    let { offset: O } = y, D = vr(!1, t.slice(0, O), /[^\n\r]/g, " "), v = o2(D + m, e, r, !1);
    v.sourceSpan = new _e(y, xl(!1, v.children, -1).sourceSpan.end);
    let w = v.children[0];
    return w.length === O ? v.children.shift() : (w.sourceSpan = new _e(w.sourceSpan.start.moveBy(O), w.sourceSpan.end), w.value = w.value.slice(O)), v;
  };
  return p.walk((m) => {
    if (m.type === "comment") {
      let y = m8(m, d);
      y && m.parent.replaceChild(m, y);
    }
    D8(m), b8(m);
  }), p;
}
function yh(t) {
  return { parse: (e, r) => o2(e, t, r), hasPragma: X$, astFormat: "html", locStart: ph, locEnd: dh };
}
var l2 = { name: "html", normalizeTagName: !0, normalizeAttributeName: !0, allowHtmComponentClosingTags: !0 }, w8 = yh(l2), S8 = yh({ name: "angular" }), C8 = yh({ name: "vue", isTagNameCaseSensitive: !0, shouldParseAsRawText(t, e, r, i) {
  return t.toLowerCase() !== "html" && !r && (t !== "template" || i.some(({ name: n, value: s }) => n === "lang" && s !== "html" && s !== "" && s !== void 0));
} }), E8 = yh({ name: "lwc", canSelfClose: !1 }), A8 = { html: xB }, k8 = OD, T8 = Object.create, Fm = Object.defineProperty, P8 = Object.getOwnPropertyDescriptor, F8 = Object.getOwnPropertyNames, $8 = Object.getPrototypeOf, B8 = Object.prototype.hasOwnProperty, re = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), u2 = (t, e) => {
  for (var r in e)
    Fm(t, r, { get: e[r], enumerable: !0 });
}, I8 = (t, e, r, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of F8(e))
      !B8.call(t, n) && n !== r && Fm(t, n, { get: () => e[n], enumerable: !(i = P8(e, n)) || i.enumerable });
  return t;
}, Fs = (t, e, r) => (r = t != null ? T8($8(t)) : {}, I8(e || !t || !t.__esModule ? Fm(r, "default", { value: t, enumerable: !0 }) : r, t)), N8 = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = p, t.parse = m, t.parseWithComments = y, t.print = O, t.strip = d;
  var e = /\*\/$/, r = /^\/\*\*?/, i = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, n = /(^|\s+)\/\/([^\r\n]*)/g, s = /^(\r?\n)+/, a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, l = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, u = /(\r?\n|^) *\* ?/g, h = [];
  function p(v) {
    let w = v.match(i);
    return w ? w[0].trimLeft() : "";
  }
  function d(v) {
    let w = v.match(i);
    return w && w[0] ? v.substring(w[0].length) : v;
  }
  function m(v) {
    return y(v).pragmas;
  }
  function y(v) {
    let w = `
`;
    v = v.replace(r, "").replace(e, "").replace(u, "$1");
    let x = "";
    for (; x !== v; )
      x = v, v = v.replace(a, `${w}$1 $2${w}`);
    v = v.replace(s, "").trimRight();
    let S = /* @__PURE__ */ Object.create(null), k = v.replace(l, "").replace(s, "").trimRight(), C;
    for (; C = l.exec(v); ) {
      let A = C[2].replace(n, "");
      typeof S[C[1]] == "string" || Array.isArray(S[C[1]]) ? S[C[1]] = h.concat(S[C[1]], A) : S[C[1]] = A;
    }
    return { comments: k, pragmas: S };
  }
  function O({ comments: v = "", pragmas: w = {} }) {
    let x = `
`, S = "/**", k = " *", C = " */", A = Object.keys(w), P = A.flatMap((B) => D(B, w[B])).map((B) => `${k} ${B}${x}`).join("");
    if (!v) {
      if (A.length === 0)
        return "";
      if (A.length === 1 && !Array.isArray(w[A[0]])) {
        let B = w[A[0]];
        return `${S} ${D(A[0], B)[0]}${C}`;
      }
    }
    let I = v.split(x).map((B) => `${k} ${B}`).join(x) + x;
    return S + x + (v ? I : "") + (v && A.length ? k + x : "") + P + C;
  }
  function D(v, w) {
    return h.concat(w).map((x) => `@${v} ${x}`.trim());
  }
}), $m = re((t, e) => {
  e.exports.isClean = Symbol("isClean"), e.exports.my = Symbol("my");
}), _8 = re((t, e) => {
  var r = String, i = function() {
    return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r };
  };
  e.exports = i(), e.exports.createColors = i;
}), c2 = re(() => {
}), Bm = re((t, e) => {
  var r = _8(), i = c2(), n = class h2 extends Error {
    constructor(a, l, u, h, p, d) {
      super(a), this.name = "CssSyntaxError", this.reason = a, p && (this.file = p), h && (this.source = h), d && (this.plugin = d), typeof l < "u" && typeof u < "u" && (typeof l == "number" ? (this.line = l, this.column = u) : (this.line = l.line, this.column = l.column, this.endLine = u.line, this.endColumn = u.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, h2);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(a) {
      if (!this.source)
        return "";
      let l = this.source;
      a == null && (a = r.isColorSupported), i && a && (l = i(l));
      let u = l.split(/\r?\n/), h = Math.max(this.line - 3, 0), p = Math.min(this.line + 2, u.length), d = String(p).length, m, y;
      if (a) {
        let { bold: O, gray: D, red: v } = r.createColors(!0);
        m = (w) => O(v(w)), y = (w) => D(w);
      } else
        m = y = (O) => O;
      return u.slice(h, p).map((O, D) => {
        let v = h + 1 + D, w = " " + (" " + v).slice(-d) + " | ";
        if (v === this.line) {
          let x = y(w.replace(/\d/g, " ")) + O.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return m(">") + y(w) + O + `
 ` + x + m("^");
        }
        return " " + y(w) + O;
      }).join(`
`);
    }
    toString() {
      let a = this.showSourceCode();
      return a && (a = `

` + a + `
`), this.name + ": " + this.message + a;
    }
  };
  e.exports = n, n.default = n;
}), Im = re((t, e) => {
  var r = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: !1 };
  function i(s) {
    return s[0].toUpperCase() + s.slice(1);
  }
  var n = class {
    constructor(s) {
      this.builder = s;
    }
    atrule(s, a) {
      let l = "@" + s.name, u = s.params ? this.rawValue(s, "params") : "";
      if (typeof s.raws.afterName < "u" ? l += s.raws.afterName : u && (l += " "), s.nodes)
        this.block(s, l + u);
      else {
        let h = (s.raws.between || "") + (a ? ";" : "");
        this.builder(l + u + h, s);
      }
    }
    beforeAfter(s, a) {
      let l;
      s.type === "decl" ? l = this.raw(s, null, "beforeDecl") : s.type === "comment" ? l = this.raw(s, null, "beforeComment") : a === "before" ? l = this.raw(s, null, "beforeRule") : l = this.raw(s, null, "beforeClose");
      let u = s.parent, h = 0;
      for (; u && u.type !== "root"; )
        h += 1, u = u.parent;
      if (l.includes(`
`)) {
        let p = this.raw(s, null, "indent");
        if (p.length)
          for (let d = 0; d < h; d++)
            l += p;
      }
      return l;
    }
    block(s, a) {
      let l = this.raw(s, "between", "beforeOpen");
      this.builder(a + l + "{", s, "start");
      let u;
      s.nodes && s.nodes.length ? (this.body(s), u = this.raw(s, "after")) : u = this.raw(s, "after", "emptyBody"), u && this.builder(u), this.builder("}", s, "end");
    }
    body(s) {
      let a = s.nodes.length - 1;
      for (; a > 0 && s.nodes[a].type === "comment"; )
        a -= 1;
      let l = this.raw(s, "semicolon");
      for (let u = 0; u < s.nodes.length; u++) {
        let h = s.nodes[u], p = this.raw(h, "before");
        p && this.builder(p), this.stringify(h, a !== u || l);
      }
    }
    comment(s) {
      let a = this.raw(s, "left", "commentLeft"), l = this.raw(s, "right", "commentRight");
      this.builder("/*" + a + s.text + l + "*/", s);
    }
    decl(s, a) {
      let l = this.raw(s, "between", "colon"), u = s.prop + l + this.rawValue(s, "value");
      s.important && (u += s.raws.important || " !important"), a && (u += ";"), this.builder(u, s);
    }
    document(s) {
      this.body(s);
    }
    raw(s, a, l) {
      let u;
      if (l || (l = a), a && (u = s.raws[a], typeof u < "u"))
        return u;
      let h = s.parent;
      if (l === "before" && (!h || h.type === "root" && h.first === s || h && h.type === "document"))
        return "";
      if (!h)
        return r[l];
      let p = s.root();
      if (p.rawCache || (p.rawCache = {}), typeof p.rawCache[l] < "u")
        return p.rawCache[l];
      if (l === "before" || l === "after")
        return this.beforeAfter(s, l);
      {
        let d = "raw" + i(l);
        this[d] ? u = this[d](p, s) : p.walk((m) => {
          if (u = m.raws[a], typeof u < "u")
            return !1;
        });
      }
      return typeof u > "u" && (u = r[l]), p.rawCache[l] = u, u;
    }
    rawBeforeClose(s) {
      let a;
      return s.walk((l) => {
        if (l.nodes && l.nodes.length > 0 && typeof l.raws.after < "u")
          return a = l.raws.after, a.includes(`
`) && (a = a.replace(/[^\n]+$/, "")), !1;
      }), a && (a = a.replace(/\S/g, "")), a;
    }
    rawBeforeComment(s, a) {
      let l;
      return s.walkComments((u) => {
        if (typeof u.raws.before < "u")
          return l = u.raws.before, l.includes(`
`) && (l = l.replace(/[^\n]+$/, "")), !1;
      }), typeof l > "u" ? l = this.raw(a, null, "beforeDecl") : l && (l = l.replace(/\S/g, "")), l;
    }
    rawBeforeDecl(s, a) {
      let l;
      return s.walkDecls((u) => {
        if (typeof u.raws.before < "u")
          return l = u.raws.before, l.includes(`
`) && (l = l.replace(/[^\n]+$/, "")), !1;
      }), typeof l > "u" ? l = this.raw(a, null, "beforeRule") : l && (l = l.replace(/\S/g, "")), l;
    }
    rawBeforeOpen(s) {
      let a;
      return s.walk((l) => {
        if (l.type !== "decl" && (a = l.raws.between, typeof a < "u"))
          return !1;
      }), a;
    }
    rawBeforeRule(s) {
      let a;
      return s.walk((l) => {
        if (l.nodes && (l.parent !== s || s.first !== l) && typeof l.raws.before < "u")
          return a = l.raws.before, a.includes(`
`) && (a = a.replace(/[^\n]+$/, "")), !1;
      }), a && (a = a.replace(/\S/g, "")), a;
    }
    rawColon(s) {
      let a;
      return s.walkDecls((l) => {
        if (typeof l.raws.between < "u")
          return a = l.raws.between.replace(/[^\s:]/g, ""), !1;
      }), a;
    }
    rawEmptyBody(s) {
      let a;
      return s.walk((l) => {
        if (l.nodes && l.nodes.length === 0 && (a = l.raws.after, typeof a < "u"))
          return !1;
      }), a;
    }
    rawIndent(s) {
      if (s.raws.indent)
        return s.raws.indent;
      let a;
      return s.walk((l) => {
        let u = l.parent;
        if (u && u !== s && u.parent && u.parent === s && typeof l.raws.before < "u") {
          let h = l.raws.before.split(`
`);
          return a = h[h.length - 1], a = a.replace(/\S/g, ""), !1;
        }
      }), a;
    }
    rawSemicolon(s) {
      let a;
      return s.walk((l) => {
        if (l.nodes && l.nodes.length && l.last.type === "decl" && (a = l.raws.semicolon, typeof a < "u"))
          return !1;
      }), a;
    }
    rawValue(s, a) {
      let l = s[a], u = s.raws[a];
      return u && u.value === l ? u.raw : l;
    }
    root(s) {
      this.body(s), s.raws.after && this.builder(s.raws.after);
    }
    rule(s) {
      this.block(s, this.rawValue(s, "selector")), s.raws.ownSemicolon && this.builder(s.raws.ownSemicolon, s, "end");
    }
    stringify(s, a) {
      if (!this[s.type])
        throw new Error("Unknown AST node type " + s.type + ". Maybe you need to change PostCSS stringifier.");
      this[s.type](s, a);
    }
  };
  e.exports = n, n.default = n;
}), Oh = re((t, e) => {
  var r = Im();
  function i(n, s) {
    new r(s).stringify(n);
  }
  e.exports = i, i.default = i;
}), xh = re((t, e) => {
  var { isClean: r, my: i } = $m(), n = Bm(), s = Im(), a = Oh();
  function l(h, p) {
    let d = new h.constructor();
    for (let m in h) {
      if (!Object.prototype.hasOwnProperty.call(h, m) || m === "proxyCache")
        continue;
      let y = h[m], O = typeof y;
      m === "parent" && O === "object" ? p && (d[m] = p) : m === "source" ? d[m] = y : Array.isArray(y) ? d[m] = y.map((D) => l(D, d)) : (O === "object" && y !== null && (y = l(y)), d[m] = y);
    }
    return d;
  }
  var u = class {
    constructor(h = {}) {
      this.raws = {}, this[r] = !1, this[i] = !0;
      for (let p in h)
        if (p === "nodes") {
          this.nodes = [];
          for (let d of h[p])
            typeof d.clone == "function" ? this.append(d.clone()) : this.append(d);
        } else
          this[p] = h[p];
    }
    addToError(h) {
      if (h.postcssNode = this, h.stack && this.source && /\n\s{4}at /.test(h.stack)) {
        let p = this.source;
        h.stack = h.stack.replace(/\n\s{4}at /, `$&${p.input.from}:${p.start.line}:${p.start.column}$&`);
      }
      return h;
    }
    after(h) {
      return this.parent.insertAfter(this, h), this;
    }
    assign(h = {}) {
      for (let p in h)
        this[p] = h[p];
      return this;
    }
    before(h) {
      return this.parent.insertBefore(this, h), this;
    }
    cleanRaws(h) {
      delete this.raws.before, delete this.raws.after, h || delete this.raws.between;
    }
    clone(h = {}) {
      let p = l(this);
      for (let d in h)
        p[d] = h[d];
      return p;
    }
    cloneAfter(h = {}) {
      let p = this.clone(h);
      return this.parent.insertAfter(this, p), p;
    }
    cloneBefore(h = {}) {
      let p = this.clone(h);
      return this.parent.insertBefore(this, p), p;
    }
    error(h, p = {}) {
      if (this.source) {
        let { end: d, start: m } = this.rangeBy(p);
        return this.source.input.error(h, { column: m.column, line: m.line }, { column: d.column, line: d.line }, p);
      }
      return new n(h);
    }
    getProxyProcessor() {
      return { get(h, p) {
        return p === "proxyOf" ? h : p === "root" ? () => h.root().toProxy() : h[p];
      }, set(h, p, d) {
        return h[p] === d || (h[p] = d, (p === "prop" || p === "value" || p === "name" || p === "params" || p === "important" || p === "text") && h.markDirty()), !0;
      } };
    }
    markDirty() {
      if (this[r]) {
        this[r] = !1;
        let h = this;
        for (; h = h.parent; )
          h[r] = !1;
      }
    }
    next() {
      if (!this.parent)
        return;
      let h = this.parent.index(this);
      return this.parent.nodes[h + 1];
    }
    positionBy(h, p) {
      let d = this.source.start;
      if (h.index)
        d = this.positionInside(h.index, p);
      else if (h.word) {
        p = this.toString();
        let m = p.indexOf(h.word);
        m !== -1 && (d = this.positionInside(m, p));
      }
      return d;
    }
    positionInside(h, p) {
      let d = p || this.toString(), m = this.source.start.column, y = this.source.start.line;
      for (let O = 0; O < h; O++)
        d[O] === `
` ? (m = 1, y += 1) : m += 1;
      return { column: m, line: y };
    }
    prev() {
      if (!this.parent)
        return;
      let h = this.parent.index(this);
      return this.parent.nodes[h - 1];
    }
    rangeBy(h) {
      let p = { column: this.source.start.column, line: this.source.start.line }, d = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: p.column + 1, line: p.line };
      if (h.word) {
        let m = this.toString(), y = m.indexOf(h.word);
        y !== -1 && (p = this.positionInside(y, m), d = this.positionInside(y + h.word.length, m));
      } else
        h.start ? p = { column: h.start.column, line: h.start.line } : h.index && (p = this.positionInside(h.index)), h.end ? d = { column: h.end.column, line: h.end.line } : h.endIndex ? d = this.positionInside(h.endIndex) : h.index && (d = this.positionInside(h.index + 1));
      return (d.line < p.line || d.line === p.line && d.column <= p.column) && (d = { column: p.column + 1, line: p.line }), { end: d, start: p };
    }
    raw(h, p) {
      return new s().raw(this, h, p);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith(...h) {
      if (this.parent) {
        let p = this, d = !1;
        for (let m of h)
          m === this ? d = !0 : d ? (this.parent.insertAfter(p, m), p = m) : this.parent.insertBefore(p, m);
        d || this.remove();
      }
      return this;
    }
    root() {
      let h = this;
      for (; h.parent && h.parent.type !== "document"; )
        h = h.parent;
      return h;
    }
    toJSON(h, p) {
      let d = {}, m = p == null;
      p = p || /* @__PURE__ */ new Map();
      let y = 0;
      for (let O in this) {
        if (!Object.prototype.hasOwnProperty.call(this, O) || O === "parent" || O === "proxyCache")
          continue;
        let D = this[O];
        if (Array.isArray(D))
          d[O] = D.map((v) => typeof v == "object" && v.toJSON ? v.toJSON(null, p) : v);
        else if (typeof D == "object" && D.toJSON)
          d[O] = D.toJSON(null, p);
        else if (O === "source") {
          let v = p.get(D.input);
          v == null && (v = y, p.set(D.input, y), y++), d[O] = { end: D.end, inputId: v, start: D.start };
        } else
          d[O] = D;
      }
      return m && (d.inputs = [...p.keys()].map((O) => O.toJSON())), d;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(h = a) {
      h.stringify && (h = h.stringify);
      let p = "";
      return h(this, (d) => {
        p += d;
      }), p;
    }
    warn(h, p, d) {
      let m = { node: this };
      for (let y in d)
        m[y] = d[y];
      return h.warn(p, m);
    }
    get proxyOf() {
      return this;
    }
  };
  e.exports = u, u.default = u;
}), Dh = re((t, e) => {
  var r = xh(), i = class extends r {
    constructor(n) {
      n && typeof n.value < "u" && typeof n.value != "string" && (n = { ...n, value: String(n.value) }), super(n), this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
  };
  e.exports = i, i.default = i;
}), Sl = re((t, e) => {
  var r = xh(), i = class extends r {
    constructor(n) {
      super(n), this.type = "comment";
    }
  };
  e.exports = i, i.default = i;
}), $s = re((t, e) => {
  var { isClean: r, my: i } = $m(), n = Dh(), s = Sl(), a = xh(), l, u, h, p;
  function d(O) {
    return O.map((D) => (D.nodes && (D.nodes = d(D.nodes)), delete D.source, D));
  }
  function m(O) {
    if (O[r] = !1, O.proxyOf.nodes)
      for (let D of O.proxyOf.nodes)
        m(D);
  }
  var y = class p2 extends a {
    append(...D) {
      for (let v of D) {
        let w = this.normalize(v, this.last);
        for (let x of w)
          this.proxyOf.nodes.push(x);
      }
      return this.markDirty(), this;
    }
    cleanRaws(D) {
      if (super.cleanRaws(D), this.nodes)
        for (let v of this.nodes)
          v.cleanRaws(D);
    }
    each(D) {
      if (!this.proxyOf.nodes)
        return;
      let v = this.getIterator(), w, x;
      for (; this.indexes[v] < this.proxyOf.nodes.length && (w = this.indexes[v], x = D(this.proxyOf.nodes[w], w), x !== !1); )
        this.indexes[v] += 1;
      return delete this.indexes[v], x;
    }
    every(D) {
      return this.nodes.every(D);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let D = this.lastEach;
      return this.indexes[D] = 0, D;
    }
    getProxyProcessor() {
      return { get(D, v) {
        return v === "proxyOf" ? D : D[v] ? v === "each" || typeof v == "string" && v.startsWith("walk") ? (...w) => D[v](...w.map((x) => typeof x == "function" ? (S, k) => x(S.toProxy(), k) : x)) : v === "every" || v === "some" ? (w) => D[v]((x, ...S) => w(x.toProxy(), ...S)) : v === "root" ? () => D.root().toProxy() : v === "nodes" ? D.nodes.map((w) => w.toProxy()) : v === "first" || v === "last" ? D[v].toProxy() : D[v] : D[v];
      }, set(D, v, w) {
        return D[v] === w || (D[v] = w, (v === "name" || v === "params" || v === "selector") && D.markDirty()), !0;
      } };
    }
    index(D) {
      return typeof D == "number" ? D : (D.proxyOf && (D = D.proxyOf), this.proxyOf.nodes.indexOf(D));
    }
    insertAfter(D, v) {
      let w = this.index(D), x = this.normalize(v, this.proxyOf.nodes[w]).reverse();
      w = this.index(D);
      for (let k of x)
        this.proxyOf.nodes.splice(w + 1, 0, k);
      let S;
      for (let k in this.indexes)
        S = this.indexes[k], w < S && (this.indexes[k] = S + x.length);
      return this.markDirty(), this;
    }
    insertBefore(D, v) {
      let w = this.index(D), x = w === 0 ? "prepend" : !1, S = this.normalize(v, this.proxyOf.nodes[w], x).reverse();
      w = this.index(D);
      for (let C of S)
        this.proxyOf.nodes.splice(w, 0, C);
      let k;
      for (let C in this.indexes)
        k = this.indexes[C], w <= k && (this.indexes[C] = k + S.length);
      return this.markDirty(), this;
    }
    normalize(D, v) {
      if (typeof D == "string")
        D = d(l(D).nodes);
      else if (Array.isArray(D)) {
        D = D.slice(0);
        for (let w of D)
          w.parent && w.parent.removeChild(w, "ignore");
      } else if (D.type === "root" && this.type !== "document") {
        D = D.nodes.slice(0);
        for (let w of D)
          w.parent && w.parent.removeChild(w, "ignore");
      } else if (D.type)
        D = [D];
      else if (D.prop) {
        if (typeof D.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof D.value != "string" && (D.value = String(D.value)), D = [new n(D)];
      } else if (D.selector)
        D = [new u(D)];
      else if (D.name)
        D = [new h(D)];
      else if (D.text)
        D = [new s(D)];
      else
        throw new Error("Unknown node type in node creation");
      return D.map((w) => (w[i] || p2.rebuild(w), w = w.proxyOf, w.parent && w.parent.removeChild(w), w[r] && m(w), typeof w.raws.before > "u" && v && typeof v.raws.before < "u" && (w.raws.before = v.raws.before.replace(/\S/g, "")), w.parent = this.proxyOf, w));
    }
    prepend(...D) {
      D = D.reverse();
      for (let v of D) {
        let w = this.normalize(v, this.first, "prepend").reverse();
        for (let x of w)
          this.proxyOf.nodes.unshift(x);
        for (let x in this.indexes)
          this.indexes[x] = this.indexes[x] + w.length;
      }
      return this.markDirty(), this;
    }
    push(D) {
      return D.parent = this, this.proxyOf.nodes.push(D), this;
    }
    removeAll() {
      for (let D of this.proxyOf.nodes)
        D.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(D) {
      D = this.index(D), this.proxyOf.nodes[D].parent = void 0, this.proxyOf.nodes.splice(D, 1);
      let v;
      for (let w in this.indexes)
        v = this.indexes[w], v >= D && (this.indexes[w] = v - 1);
      return this.markDirty(), this;
    }
    replaceValues(D, v, w) {
      return w || (w = v, v = {}), this.walkDecls((x) => {
        v.props && !v.props.includes(x.prop) || v.fast && !x.value.includes(v.fast) || (x.value = x.value.replace(D, w));
      }), this.markDirty(), this;
    }
    some(D) {
      return this.nodes.some(D);
    }
    walk(D) {
      return this.each((v, w) => {
        let x;
        try {
          x = D(v, w);
        } catch (S) {
          throw v.addToError(S);
        }
        return x !== !1 && v.walk && (x = v.walk(D)), x;
      });
    }
    walkAtRules(D, v) {
      return v ? D instanceof RegExp ? this.walk((w, x) => {
        if (w.type === "atrule" && D.test(w.name))
          return v(w, x);
      }) : this.walk((w, x) => {
        if (w.type === "atrule" && w.name === D)
          return v(w, x);
      }) : (v = D, this.walk((w, x) => {
        if (w.type === "atrule")
          return v(w, x);
      }));
    }
    walkComments(D) {
      return this.walk((v, w) => {
        if (v.type === "comment")
          return D(v, w);
      });
    }
    walkDecls(D, v) {
      return v ? D instanceof RegExp ? this.walk((w, x) => {
        if (w.type === "decl" && D.test(w.prop))
          return v(w, x);
      }) : this.walk((w, x) => {
        if (w.type === "decl" && w.prop === D)
          return v(w, x);
      }) : (v = D, this.walk((w, x) => {
        if (w.type === "decl")
          return v(w, x);
      }));
    }
    walkRules(D, v) {
      return v ? D instanceof RegExp ? this.walk((w, x) => {
        if (w.type === "rule" && D.test(w.selector))
          return v(w, x);
      }) : this.walk((w, x) => {
        if (w.type === "rule" && w.selector === D)
          return v(w, x);
      }) : (v = D, this.walk((w, x) => {
        if (w.type === "rule")
          return v(w, x);
      }));
    }
    get first() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
  };
  y.registerParse = (O) => {
    l = O;
  }, y.registerRule = (O) => {
    u = O;
  }, y.registerAtRule = (O) => {
    h = O;
  }, y.registerRoot = (O) => {
    p = O;
  }, e.exports = y, y.default = y, y.rebuild = (O) => {
    O.type === "atrule" ? Object.setPrototypeOf(O, h.prototype) : O.type === "rule" ? Object.setPrototypeOf(O, u.prototype) : O.type === "decl" ? Object.setPrototypeOf(O, n.prototype) : O.type === "comment" ? Object.setPrototypeOf(O, s.prototype) : O.type === "root" && Object.setPrototypeOf(O, p.prototype), O[i] = !0, O.nodes && O.nodes.forEach((D) => {
      y.rebuild(D);
    });
  };
}), Nm = re((t, e) => {
  var r = /[\t\n\f\r "#'()/;[\\\]{}]/g, i = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, n = /.[\r\n"'(/\\]/, s = /[\da-f]/i;
  e.exports = function(a, l = {}) {
    let u = a.css.valueOf(), h = l.ignoreErrors, p, d, m, y, O, D, v, w, x, S, k = u.length, C = 0, A = [], P = [];
    function I() {
      return C;
    }
    function B(J) {
      throw a.error("Unclosed " + J, C);
    }
    function _() {
      return P.length === 0 && C >= k;
    }
    function R(J) {
      if (P.length)
        return P.pop();
      if (C >= k)
        return;
      let Q = J ? J.ignoreUnclosed : !1;
      switch (p = u.charCodeAt(C), p) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12: {
          d = C;
          do
            d += 1, p = u.charCodeAt(d);
          while (p === 32 || p === 10 || p === 9 || p === 13 || p === 12);
          S = ["space", u.slice(C, d)], C = d - 1;
          break;
        }
        case 91:
        case 93:
        case 123:
        case 125:
        case 58:
        case 59:
        case 41: {
          let q = String.fromCharCode(p);
          S = [q, q, C];
          break;
        }
        case 40: {
          if (w = A.length ? A.pop()[1] : "", x = u.charCodeAt(C + 1), w === "url" && x !== 39 && x !== 34 && x !== 32 && x !== 10 && x !== 9 && x !== 12 && x !== 13) {
            d = C;
            do {
              if (D = !1, d = u.indexOf(")", d + 1), d === -1)
                if (h || Q) {
                  d = C;
                  break;
                } else
                  B("bracket");
              for (v = d; u.charCodeAt(v - 1) === 92; )
                v -= 1, D = !D;
            } while (D);
            S = ["brackets", u.slice(C, d + 1), C, d], C = d;
          } else
            d = u.indexOf(")", C + 1), y = u.slice(C, d + 1), d === -1 || n.test(y) ? S = ["(", "(", C] : (S = ["brackets", y, C, d], C = d);
          break;
        }
        case 39:
        case 34: {
          m = p === 39 ? "'" : '"', d = C;
          do {
            if (D = !1, d = u.indexOf(m, d + 1), d === -1)
              if (h || Q) {
                d = C + 1;
                break;
              } else
                B("string");
            for (v = d; u.charCodeAt(v - 1) === 92; )
              v -= 1, D = !D;
          } while (D);
          S = ["string", u.slice(C, d + 1), C, d], C = d;
          break;
        }
        case 64: {
          r.lastIndex = C + 1, r.test(u), r.lastIndex === 0 ? d = u.length - 1 : d = r.lastIndex - 2, S = ["at-word", u.slice(C, d + 1), C, d], C = d;
          break;
        }
        case 92: {
          for (d = C, O = !0; u.charCodeAt(d + 1) === 92; )
            d += 1, O = !O;
          if (p = u.charCodeAt(d + 1), O && p !== 47 && p !== 32 && p !== 10 && p !== 9 && p !== 13 && p !== 12 && (d += 1, s.test(u.charAt(d)))) {
            for (; s.test(u.charAt(d + 1)); )
              d += 1;
            u.charCodeAt(d + 1) === 32 && (d += 1);
          }
          S = ["word", u.slice(C, d + 1), C, d], C = d;
          break;
        }
        default: {
          p === 47 && u.charCodeAt(C + 1) === 42 ? (d = u.indexOf("*/", C + 2) + 1, d === 0 && (h || Q ? d = u.length : B("comment")), S = ["comment", u.slice(C, d + 1), C, d], C = d) : (i.lastIndex = C + 1, i.test(u), i.lastIndex === 0 ? d = u.length - 1 : d = i.lastIndex - 2, S = ["word", u.slice(C, d + 1), C, d], A.push(S), C = d);
          break;
        }
      }
      return C++, S;
    }
    function G(J) {
      P.push(J);
    }
    return { back: G, endOfFile: _, nextToken: R, position: I };
  };
}), _m = re((t, e) => {
  var r = $s(), i = class extends r {
    constructor(n) {
      super(n), this.type = "atrule";
    }
    append(...n) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...n);
    }
    prepend(...n) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...n);
    }
  };
  e.exports = i, i.default = i, r.registerAtRule(i);
}), Cl = re((t, e) => {
  var r = $s(), i, n, s = class extends r {
    constructor(a) {
      super(a), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(a, l, u) {
      let h = super.normalize(a);
      if (l) {
        if (u === "prepend")
          this.nodes.length > 1 ? l.raws.before = this.nodes[1].raws.before : delete l.raws.before;
        else if (this.first !== l)
          for (let p of h)
            p.raws.before = l.raws.before;
      }
      return h;
    }
    removeChild(a, l) {
      let u = this.index(a);
      return !l && u === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[u].raws.before), super.removeChild(a);
    }
    toResult(a = {}) {
      return new i(new n(), this, a).stringify();
    }
  };
  s.registerLazyResult = (a) => {
    i = a;
  }, s.registerProcessor = (a) => {
    n = a;
  }, e.exports = s, s.default = s, r.registerRoot(s);
}), d2 = re((t, e) => {
  var r = { comma(i) {
    return r.split(i, [","], !0);
  }, space(i) {
    let n = [" ", `
`, "	"];
    return r.split(i, n);
  }, split(i, n, s) {
    let a = [], l = "", u = !1, h = 0, p = !1, d = "", m = !1;
    for (let y of i)
      m ? m = !1 : y === "\\" ? m = !0 : p ? y === d && (p = !1) : y === '"' || y === "'" ? (p = !0, d = y) : y === "(" ? h += 1 : y === ")" ? h > 0 && (h -= 1) : h === 0 && n.includes(y) && (u = !0), u ? (l !== "" && a.push(l.trim()), l = "", u = !1) : l += y;
    return (s || l !== "") && a.push(l.trim()), a;
  } };
  e.exports = r, r.default = r;
}), Mm = re((t, e) => {
  var r = $s(), i = d2(), n = class extends r {
    constructor(s) {
      super(s), this.type = "rule", this.nodes || (this.nodes = []);
    }
    get selectors() {
      return i.comma(this.selector);
    }
    set selectors(s) {
      let a = this.selector ? this.selector.match(/,\s*/) : null, l = a ? a[0] : "," + this.raw("between", "beforeOpen");
      this.selector = s.join(l);
    }
  };
  e.exports = n, n.default = n, r.registerRule(n);
}), Lm = re((t, e) => {
  var r = Dh(), i = Nm(), n = Sl(), s = _m(), a = Cl(), l = Mm(), u = { empty: !0, space: !0 };
  function h(d) {
    for (let m = d.length - 1; m >= 0; m--) {
      let y = d[m], O = y[3] || y[2];
      if (O)
        return O;
    }
  }
  var p = class {
    constructor(d) {
      this.input = d, this.root = new a(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.customProperty = !1, this.createTokenizer(), this.root.source = { input: d, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(d) {
      let m = new s();
      m.name = d[1].slice(1), m.name === "" && this.unnamedAtrule(m, d), this.init(m, d[2]);
      let y, O, D, v = !1, w = !1, x = [], S = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (d = this.tokenizer.nextToken(), y = d[0], y === "(" || y === "[" ? S.push(y === "(" ? ")" : "]") : y === "{" && S.length > 0 ? S.push("}") : y === S[S.length - 1] && S.pop(), S.length === 0)
          if (y === ";") {
            m.source.end = this.getPosition(d[2]), m.source.end.offset++, this.semicolon = !0;
            break;
          } else if (y === "{") {
            w = !0;
            break;
          } else if (y === "}") {
            if (x.length > 0) {
              for (D = x.length - 1, O = x[D]; O && O[0] === "space"; )
                O = x[--D];
              O && (m.source.end = this.getPosition(O[3] || O[2]), m.source.end.offset++);
            }
            this.end(d);
            break;
          } else
            x.push(d);
        else
          x.push(d);
        if (this.tokenizer.endOfFile()) {
          v = !0;
          break;
        }
      }
      m.raws.between = this.spacesAndCommentsFromEnd(x), x.length ? (m.raws.afterName = this.spacesAndCommentsFromStart(x), this.raw(m, "params", x), v && (d = x[x.length - 1], m.source.end = this.getPosition(d[3] || d[2]), m.source.end.offset++, this.spaces = m.raws.between, m.raws.between = "")) : (m.raws.afterName = "", m.params = ""), w && (m.nodes = [], this.current = m);
    }
    checkMissedSemicolon(d) {
      let m = this.colon(d);
      if (m === !1)
        return;
      let y = 0, O;
      for (let D = m - 1; D >= 0 && (O = d[D], !(O[0] !== "space" && (y += 1, y === 2))); D--)
        ;
      throw this.input.error("Missed semicolon", O[0] === "word" ? O[3] + 1 : O[2]);
    }
    colon(d) {
      let m = 0, y, O, D;
      for (let [v, w] of d.entries()) {
        if (y = w, O = y[0], O === "(" && (m += 1), O === ")" && (m -= 1), m === 0 && O === ":")
          if (!D)
            this.doubleColon(y);
          else {
            if (D[0] === "word" && D[1] === "progid")
              continue;
            return v;
          }
        D = y;
      }
      return !1;
    }
    comment(d) {
      let m = new n();
      this.init(m, d[2]), m.source.end = this.getPosition(d[3] || d[2]), m.source.end.offset++;
      let y = d[1].slice(2, -2);
      if (/^\s*$/.test(y))
        m.text = "", m.raws.left = y, m.raws.right = "";
      else {
        let O = y.match(/^(\s*)([^]*\S)(\s*)$/);
        m.text = O[2], m.raws.left = O[1], m.raws.right = O[3];
      }
    }
    createTokenizer() {
      this.tokenizer = i(this.input);
    }
    decl(d, m) {
      let y = new r();
      this.init(y, d[0][2]);
      let O = d[d.length - 1];
      for (O[0] === ";" && (this.semicolon = !0, d.pop()), y.source.end = this.getPosition(O[3] || O[2] || h(d)), y.source.end.offset++; d[0][0] !== "word"; )
        d.length === 1 && this.unknownWord(d), y.raws.before += d.shift()[1];
      for (y.source.start = this.getPosition(d[0][2]), y.prop = ""; d.length; ) {
        let x = d[0][0];
        if (x === ":" || x === "space" || x === "comment")
          break;
        y.prop += d.shift()[1];
      }
      y.raws.between = "";
      let D;
      for (; d.length; )
        if (D = d.shift(), D[0] === ":") {
          y.raws.between += D[1];
          break;
        } else
          D[0] === "word" && /\w/.test(D[1]) && this.unknownWord([D]), y.raws.between += D[1];
      (y.prop[0] === "_" || y.prop[0] === "*") && (y.raws.before += y.prop[0], y.prop = y.prop.slice(1));
      let v = [], w;
      for (; d.length && (w = d[0][0], !(w !== "space" && w !== "comment")); )
        v.push(d.shift());
      this.precheckMissedSemicolon(d);
      for (let x = d.length - 1; x >= 0; x--) {
        if (D = d[x], D[1].toLowerCase() === "!important") {
          y.important = !0;
          let S = this.stringFrom(d, x);
          S = this.spacesFromEnd(d) + S, S !== " !important" && (y.raws.important = S);
          break;
        } else if (D[1].toLowerCase() === "important") {
          let S = d.slice(0), k = "";
          for (let C = x; C > 0; C--) {
            let A = S[C][0];
            if (k.trim().indexOf("!") === 0 && A !== "space")
              break;
            k = S.pop()[1] + k;
          }
          k.trim().indexOf("!") === 0 && (y.important = !0, y.raws.important = k, d = S);
        }
        if (D[0] !== "space" && D[0] !== "comment")
          break;
      }
      d.some((x) => x[0] !== "space" && x[0] !== "comment") && (y.raws.between += v.map((x) => x[1]).join(""), v = []), this.raw(y, "value", v.concat(d), m), y.value.includes(":") && !m && this.checkMissedSemicolon(d);
    }
    doubleColon(d) {
      throw this.input.error("Double colon", { offset: d[2] }, { offset: d[2] + d[1].length });
    }
    emptyRule(d) {
      let m = new l();
      this.init(m, d[2]), m.selector = "", m.raws.between = "", this.current = m;
    }
    end(d) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(d[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(d);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(d) {
      if (this.spaces += d[1], this.current.nodes) {
        let m = this.current.nodes[this.current.nodes.length - 1];
        m && m.type === "rule" && !m.raws.ownSemicolon && (m.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }
    getPosition(d) {
      let m = this.input.fromOffset(d);
      return { column: m.col, line: m.line, offset: d };
    }
    init(d, m) {
      this.current.push(d), d.source = { input: this.input, start: this.getPosition(m) }, d.raws.before = this.spaces, this.spaces = "", d.type !== "comment" && (this.semicolon = !1);
    }
    other(d) {
      let m = !1, y = null, O = !1, D = null, v = [], w = d[1].startsWith("--"), x = [], S = d;
      for (; S; ) {
        if (y = S[0], x.push(S), y === "(" || y === "[")
          D || (D = S), v.push(y === "(" ? ")" : "]");
        else if (w && O && y === "{")
          D || (D = S), v.push("}");
        else if (v.length === 0)
          if (y === ";")
            if (O) {
              this.decl(x, w);
              return;
            } else
              break;
          else if (y === "{") {
            this.rule(x);
            return;
          } else if (y === "}") {
            this.tokenizer.back(x.pop()), m = !0;
            break;
          } else
            y === ":" && (O = !0);
        else
          y === v[v.length - 1] && (v.pop(), v.length === 0 && (D = null));
        S = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (m = !0), v.length > 0 && this.unclosedBracket(D), m && O) {
        if (!w)
          for (; x.length && (S = x[x.length - 1][0], !(S !== "space" && S !== "comment")); )
            this.tokenizer.back(x.pop());
        this.decl(x, w);
      } else
        this.unknownWord(x);
    }
    parse() {
      let d;
      for (; !this.tokenizer.endOfFile(); )
        switch (d = this.tokenizer.nextToken(), d[0]) {
          case "space":
            this.spaces += d[1];
            break;
          case ";":
            this.freeSemicolon(d);
            break;
          case "}":
            this.end(d);
            break;
          case "comment":
            this.comment(d);
            break;
          case "at-word":
            this.atrule(d);
            break;
          case "{":
            this.emptyRule(d);
            break;
          default:
            this.other(d);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(d, m, y, O) {
      let D, v, w = y.length, x = "", S = !0, k, C;
      for (let A = 0; A < w; A += 1)
        D = y[A], v = D[0], v === "space" && A === w - 1 && !O ? S = !1 : v === "comment" ? (C = y[A - 1] ? y[A - 1][0] : "empty", k = y[A + 1] ? y[A + 1][0] : "empty", !u[C] && !u[k] ? x.slice(-1) === "," ? S = !1 : x += D[1] : S = !1) : x += D[1];
      if (!S) {
        let A = y.reduce((P, I) => P + I[1], "");
        d.raws[m] = { raw: A, value: x };
      }
      d[m] = x;
    }
    rule(d) {
      d.pop();
      let m = new l();
      this.init(m, d[0][2]), m.raws.between = this.spacesAndCommentsFromEnd(d), this.raw(m, "selector", d), this.current = m;
    }
    spacesAndCommentsFromEnd(d) {
      let m, y = "";
      for (; d.length && (m = d[d.length - 1][0], !(m !== "space" && m !== "comment")); )
        y = d.pop()[1] + y;
      return y;
    }
    spacesAndCommentsFromStart(d) {
      let m, y = "";
      for (; d.length && (m = d[0][0], !(m !== "space" && m !== "comment")); )
        y += d.shift()[1];
      return y;
    }
    spacesFromEnd(d) {
      let m, y = "";
      for (; d.length && (m = d[d.length - 1][0], m === "space"); )
        y = d.pop()[1] + y;
      return y;
    }
    stringFrom(d, m) {
      let y = "";
      for (let O = m; O < d.length; O++)
        y += d[O][1];
      return d.splice(m, d.length - m), y;
    }
    unclosedBlock() {
      let d = this.current.source.start;
      throw this.input.error("Unclosed block", d.line, d.column);
    }
    unclosedBracket(d) {
      throw this.input.error("Unclosed bracket", { offset: d[2] }, { offset: d[2] + 1 });
    }
    unexpectedClose(d) {
      throw this.input.error("Unexpected }", { offset: d[2] }, { offset: d[2] + 1 });
    }
    unknownWord(d) {
      throw this.input.error("Unknown word", { offset: d[0][2] }, { offset: d[0][2] + d[0][1].length });
    }
    unnamedAtrule(d, m) {
      throw this.input.error("At-rule without name", { offset: m[2] }, { offset: m[2] + m[1].length });
    }
  };
  e.exports = p;
}), M8 = re(() => {
}), L8 = re((t, e) => {
  var r = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", i = (s, a = 21) => (l = a) => {
    let u = "", h = l;
    for (; h--; )
      u += s[Math.random() * s.length | 0];
    return u;
  }, n = (s = 21) => {
    let a = "", l = s;
    for (; l--; )
      a += r[Math.random() * 64 | 0];
    return a;
  };
  e.exports = { nanoid: n, customAlphabet: i };
}), f2 = re((t, e) => {
  e.exports = class {
  };
}), El = re((t, e) => {
  var { SourceMapConsumer: r, SourceMapGenerator: i } = M8(), { fileURLToPath: n, pathToFileURL: s } = {}, { isAbsolute: a, resolve: l } = {}, { nanoid: u } = L8(), h = c2(), p = Bm(), d = f2(), m = Symbol("fromOffsetCache"), y = !!(r && i), O = !!(l && a), D = class {
    constructor(v, w = {}) {
      if (v === null || typeof v > "u" || typeof v == "object" && !v.toString)
        throw new Error(`PostCSS received ${v} instead of CSS string`);
      if (this.css = v.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, w.from && (!O || /^\w+:\/\//.test(w.from) || a(w.from) ? this.file = w.from : this.file = l(w.from)), O && y) {
        let x = new d(this.css, w);
        if (x.text) {
          this.map = x;
          let S = x.consumer().file;
          !this.file && S && (this.file = this.mapResolve(S));
        }
      }
      this.file || (this.id = "<input css " + u(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(v, w, x, S = {}) {
      let k, C, A;
      if (w && typeof w == "object") {
        let I = w, B = x;
        if (typeof I.offset == "number") {
          let _ = this.fromOffset(I.offset);
          w = _.line, x = _.col;
        } else
          w = I.line, x = I.column;
        if (typeof B.offset == "number") {
          let _ = this.fromOffset(B.offset);
          C = _.line, A = _.col;
        } else
          C = B.line, A = B.column;
      } else if (!x) {
        let I = this.fromOffset(w);
        w = I.line, x = I.col;
      }
      let P = this.origin(w, x, C, A);
      return P ? k = new p(v, P.endLine === void 0 ? P.line : { column: P.column, line: P.line }, P.endLine === void 0 ? P.column : { column: P.endColumn, line: P.endLine }, P.source, P.file, S.plugin) : k = new p(v, C === void 0 ? w : { column: x, line: w }, C === void 0 ? x : { column: A, line: C }, this.css, this.file, S.plugin), k.input = { column: x, endColumn: A, endLine: C, line: w, source: this.css }, this.file && (s && (k.input.url = s(this.file).toString()), k.input.file = this.file), k;
    }
    fromOffset(v) {
      let w, x;
      if (this[m])
        x = this[m];
      else {
        let k = this.css.split(`
`);
        x = new Array(k.length);
        let C = 0;
        for (let A = 0, P = k.length; A < P; A++)
          x[A] = C, C += k[A].length + 1;
        this[m] = x;
      }
      w = x[x.length - 1];
      let S = 0;
      if (v >= w)
        S = x.length - 1;
      else {
        let k = x.length - 2, C;
        for (; S < k; )
          if (C = S + (k - S >> 1), v < x[C])
            k = C - 1;
          else if (v >= x[C + 1])
            S = C + 1;
          else {
            S = C;
            break;
          }
      }
      return { col: v - x[S] + 1, line: S + 1 };
    }
    mapResolve(v) {
      return /^\w+:\/\//.test(v) ? v : l(this.map.consumer().sourceRoot || this.map.root || ".", v);
    }
    origin(v, w, x, S) {
      if (!this.map)
        return !1;
      let k = this.map.consumer(), C = k.originalPositionFor({ column: w, line: v });
      if (!C.source)
        return !1;
      let A;
      typeof x == "number" && (A = k.originalPositionFor({ column: S, line: x }));
      let P;
      a(C.source) ? P = s(C.source) : P = new URL(C.source, this.map.consumer().sourceRoot || s(this.map.mapFile));
      let I = { column: C.column, endColumn: A && A.column, endLine: A && A.line, line: C.line, url: P.toString() };
      if (P.protocol === "file:")
        if (n)
          I.file = n(P);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let B = k.sourceContentFor(C.source);
      return B && (I.source = B), I;
    }
    toJSON() {
      let v = {};
      for (let w of ["hasBOM", "css", "file", "id"])
        this[w] != null && (v[w] = this[w]);
      return this.map && (v.map = { ...this.map }, v.map.consumerCache && (v.map.consumerCache = void 0)), v;
    }
    get from() {
      return this.file || this.id;
    }
  };
  e.exports = D, D.default = D, h && h.registerInput && h.registerInput(D);
}), bh = re((t, e) => {
  var r = $s(), i = Lm(), n = El();
  function s(a, l) {
    let u = new n(a, l), h = new i(u);
    try {
      h.parse();
    } catch (p) {
      throw p;
    }
    return h.root;
  }
  e.exports = s, s.default = s, r.registerParse(s);
}), Q8 = re((t, e) => {
  var r = Nm(), i = El();
  e.exports = { isInlineComment(n) {
    if (n[0] === "word" && n[1].slice(0, 2) === "//") {
      let s = n, a = [], l, u;
      for (; n; ) {
        if (/\r?\n/.test(n[1])) {
          if (/['"].*\r?\n/.test(n[1])) {
            a.push(n[1].substring(0, n[1].indexOf(`
`))), u = n[1].substring(n[1].indexOf(`
`));
            let p = this.input.css.valueOf().substring(this.tokenizer.position());
            u += p, l = n[3] + p.length - u.length;
          } else
            this.tokenizer.back(n);
          break;
        }
        a.push(n[1]), l = n[2], n = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
      }
      let h = ["comment", a.join(""), s[2], l];
      return this.inlineComment(h), u && (this.input = new i(u), this.tokenizer = r(this.input)), !0;
    } else if (n[1] === "/") {
      let s = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
      if (s[0] === "comment" && /^\/\*/.test(s[1]))
        return s[0] = "word", s[1] = s[1].slice(1), n[1] = "//", this.tokenizer.back(s), e.exports.isInlineComment.bind(this)(n);
    }
    return !1;
  } };
}), j8 = re((t, e) => {
  e.exports = { interpolation(r) {
    let i = [r, this.tokenizer.nextToken()], n = ["word", "}"];
    if (i[0][1].length > 1 || i[1][0] !== "{")
      return this.tokenizer.back(i[1]), !1;
    for (r = this.tokenizer.nextToken(); r && n.includes(r[0]); )
      i.push(r), r = this.tokenizer.nextToken();
    let s = i.map((h) => h[1]), [a] = i, l = i.pop(), u = ["word", s.join(""), a[2], l[2]];
    return this.tokenizer.back(r), this.tokenizer.back(u), !0;
  } };
}), R8 = re((t, e) => {
  var r = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, i = /\.[0-9]/, n = (s) => {
    let [, a] = s, [l] = a;
    return (l === "." || l === "#") && r.test(a) === !1 && i.test(a) === !1;
  };
  e.exports = { isMixinToken: n };
}), Z8 = re((t, e) => {
  var r = Nm(), i = /^url\((.+)\)/;
  e.exports = (n) => {
    let { name: s, params: a = "" } = n;
    if (s === "import" && a.length) {
      n.import = !0;
      let l = r({ css: a });
      for (n.filename = a.replace(i, "$1"); !l.endOfFile(); ) {
        let [u, h] = l.nextToken();
        if (u === "word" && h === "url")
          return;
        if (u === "brackets") {
          n.options = h, n.filename = a.replace(h, "").trim();
          break;
        }
      }
    }
  };
}), W8 = re((t, e) => {
  var r = /:$/, i = /^:(\s+)?/;
  e.exports = (n) => {
    let { name: s, params: a = "" } = n;
    if (n.name.slice(-1) === ":") {
      if (r.test(s)) {
        let [l] = s.match(r);
        n.name = s.replace(l, ""), n.raws.afterName = l + (n.raws.afterName || ""), n.variable = !0, n.value = n.params;
      }
      if (i.test(a)) {
        let [l] = a.match(i);
        n.value = a.replace(l, ""), n.raws.afterName = (n.raws.afterName || "") + l, n.variable = !0;
      }
    }
  };
}), q8 = re((t, e) => {
  var r = Sl(), i = Lm(), { isInlineComment: n } = Q8(), { interpolation: s } = j8(), { isMixinToken: a } = R8(), l = Z8(), u = W8(), h = /(!\s*important)$/i;
  e.exports = class extends i {
    constructor(...p) {
      super(...p), this.lastNode = null;
    }
    atrule(p) {
      s.bind(this)(p) || (super.atrule(p), l(this.lastNode), u(this.lastNode));
    }
    decl(...p) {
      super.decl(...p), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = !0);
    }
    each(p) {
      p[0][1] = ` ${p[0][1]}`;
      let d = p.findIndex((D) => D[0] === "("), m = p.reverse().find((D) => D[0] === ")"), y = p.reverse().indexOf(m), O = p.splice(d, y).map((D) => D[1]).join("");
      for (let D of p.reverse())
        this.tokenizer.back(D);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.function = !0, this.lastNode.params = O;
    }
    init(p, d, m) {
      super.init(p, d, m), this.lastNode = p;
    }
    inlineComment(p) {
      let d = new r(), m = p[1].slice(2);
      if (this.init(d, p[2]), d.source.end = this.getPosition(p[3] || p[2]), d.inline = !0, d.raws.begin = "//", /^\s*$/.test(m))
        d.text = "", d.raws.left = m, d.raws.right = "";
      else {
        let y = m.match(/^(\s*)([^]*[^\s])(\s*)$/);
        [, d.raws.left, d.text, d.raws.right] = y;
      }
    }
    mixin(p) {
      let [d] = p, m = d[1].slice(0, 1), y = p.findIndex((x) => x[0] === "brackets"), O = p.findIndex((x) => x[0] === "("), D = "";
      if ((y < 0 || y > 3) && O > 0) {
        let x = p.reduce((R, G, J) => G[0] === ")" ? J : R), S = p.slice(O, x + O).map((R) => R[1]).join(""), [k] = p.slice(O), C = [k[2], k[3]], [A] = p.slice(x, x + 1), P = [A[2], A[3]], I = ["brackets", S].concat(C, P), B = p.slice(0, O), _ = p.slice(x + 1);
        p = B, p.push(I), p = p.concat(_);
      }
      let v = [];
      for (let x of p)
        if ((x[1] === "!" || v.length) && v.push(x), x[1] === "important")
          break;
      if (v.length) {
        let [x] = v, S = p.indexOf(x), k = v[v.length - 1], C = [x[2], x[3]], A = [k[4], k[5]], P = ["word", v.map((I) => I[1]).join("")].concat(C, A);
        p.splice(S, v.length, P);
      }
      let w = p.findIndex((x) => h.test(x[1]));
      w > 0 && ([, D] = p[w], p.splice(w, 1));
      for (let x of p.reverse())
        this.tokenizer.back(x);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = !0, this.lastNode.raws.identifier = m, D && (this.lastNode.important = !0, this.lastNode.raws.important = D);
    }
    other(p) {
      n.bind(this)(p) || super.other(p);
    }
    rule(p) {
      let d = p[p.length - 1], m = p[p.length - 2];
      if (m[0] === "at-word" && d[0] === "{" && (this.tokenizer.back(d), s.bind(this)(m))) {
        let y = this.tokenizer.nextToken();
        p = p.slice(0, p.length - 2).concat([y]);
        for (let O of p.reverse())
          this.tokenizer.back(O);
        return;
      }
      super.rule(p), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = !0);
    }
    unknownWord(p) {
      let [d] = p;
      if (p[0][1] === "each" && p[1][0] === "(") {
        this.each(p);
        return;
      }
      if (a(d)) {
        this.mixin(p);
        return;
      }
      super.unknownWord(p);
    }
  };
}), X8 = re((t, e) => {
  var r = Im();
  e.exports = class extends r {
    atrule(i, n) {
      if (!i.mixin && !i.variable && !i.function) {
        super.atrule(i, n);
        return;
      }
      let s = `${i.function ? "" : i.raws.identifier || "@"}${i.name}`, a = i.params ? this.rawValue(i, "params") : "", l = i.raws.important || "";
      if (i.variable && (a = i.value), typeof i.raws.afterName < "u" ? s += i.raws.afterName : a && (s += " "), i.nodes)
        this.block(i, s + a + l);
      else {
        let u = (i.raws.between || "") + l + (n ? ";" : "");
        this.builder(s + a + u, i);
      }
    }
    comment(i) {
      if (i.inline) {
        let n = this.raw(i, "left", "commentLeft"), s = this.raw(i, "right", "commentRight");
        this.builder(`//${n}${i.text}${s}`, i);
      } else
        super.comment(i);
    }
  };
}), V8 = re((t, e) => {
  var r = El(), i = q8(), n = X8();
  e.exports = { parse(s, a) {
    let l = new r(s, a), u = new i(l);
    return u.parse(), u.root.walk((h) => {
      let p = l.css.lastIndexOf(h.source.input.css);
      if (p === 0)
        return;
      if (p + h.source.input.css.length !== l.css.length)
        throw new Error("Invalid state detected in postcss-less");
      let d = p + h.source.start.offset, m = l.fromOffset(p + h.source.start.offset);
      if (h.source.start = { offset: d, line: m.line, column: m.col }, h.source.end) {
        let y = p + h.source.end.offset, O = l.fromOffset(p + h.source.end.offset);
        h.source.end = { offset: y, line: O.line, column: O.col };
      }
    }), u.root;
  }, stringify(s, a) {
    new n(a).stringify(s);
  }, nodeToString(s) {
    let a = "";
    return e.exports.stringify(s, (l) => {
      a += l;
    }), a;
  } };
}), m2 = re((t, e) => {
  e.exports = class {
    generate() {
    }
  };
}), Qm = re((t, e) => {
  var r = $s(), i, n, s = class extends r {
    constructor(a) {
      super({ type: "document", ...a }), this.nodes || (this.nodes = []);
    }
    toResult(a = {}) {
      return new i(new n(), this, a).stringify();
    }
  };
  s.registerLazyResult = (a) => {
    i = a;
  }, s.registerProcessor = (a) => {
    n = a;
  }, e.exports = s, s.default = s;
}), g2 = re((t, e) => {
  var r = {};
  e.exports = function(i) {
    r[i] || (r[i] = !0, typeof console < "u" && console.warn && console.warn(i));
  };
}), y2 = re((t, e) => {
  var r = class {
    constructor(i, n = {}) {
      if (this.type = "warning", this.text = i, n.node && n.node.source) {
        let s = n.node.rangeBy(n);
        this.line = s.start.line, this.column = s.start.column, this.endLine = s.end.line, this.endColumn = s.end.column;
      }
      for (let s in n)
        this[s] = n[s];
    }
    toString() {
      return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  };
  e.exports = r, r.default = r;
}), jm = re((t, e) => {
  var r = y2(), i = class {
    constructor(n, s, a) {
      this.processor = n, this.messages = [], this.root = s, this.opts = a, this.css = void 0, this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(n, s = {}) {
      s.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (s.plugin = this.lastPlugin.postcssPlugin);
      let a = new r(n, s);
      return this.messages.push(a), a;
    }
    warnings() {
      return this.messages.filter((n) => n.type === "warning");
    }
    get content() {
      return this.css;
    }
  };
  e.exports = i, i.default = i;
}), O2 = re((t, e) => {
  var { isClean: r, my: i } = $m(), n = m2(), s = Oh(), a = $s(), l = Qm();
  g2();
  var u = jm(), h = bh(), p = Cl(), d = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, m = { AtRule: !0, AtRuleExit: !0, Comment: !0, CommentExit: !0, Declaration: !0, DeclarationExit: !0, Document: !0, DocumentExit: !0, Once: !0, OnceExit: !0, postcssPlugin: !0, prepare: !0, Root: !0, RootExit: !0, Rule: !0, RuleExit: !0 }, y = { Once: !0, postcssPlugin: !0, prepare: !0 }, O = 0;
  function D(C) {
    return typeof C == "object" && typeof C.then == "function";
  }
  function v(C) {
    let A = !1, P = d[C.type];
    return C.type === "decl" ? A = C.prop.toLowerCase() : C.type === "atrule" && (A = C.name.toLowerCase()), A && C.append ? [P, P + "-" + A, O, P + "Exit", P + "Exit-" + A] : A ? [P, P + "-" + A, P + "Exit", P + "Exit-" + A] : C.append ? [P, O, P + "Exit"] : [P, P + "Exit"];
  }
  function w(C) {
    let A;
    return C.type === "document" ? A = ["Document", O, "DocumentExit"] : C.type === "root" ? A = ["Root", O, "RootExit"] : A = v(C), { eventIndex: 0, events: A, iterator: 0, node: C, visitorIndex: 0, visitors: [] };
  }
  function x(C) {
    return C[r] = !1, C.nodes && C.nodes.forEach((A) => x(A)), C;
  }
  var S = {}, k = class x2 {
    constructor(A, P, I) {
      this.stringified = !1, this.processed = !1;
      let B;
      if (typeof P == "object" && P !== null && (P.type === "root" || P.type === "document"))
        B = x(P);
      else if (P instanceof x2 || P instanceof u)
        B = x(P.root), P.map && (typeof I.map > "u" && (I.map = {}), I.map.inline || (I.map.inline = !1), I.map.prev = P.map);
      else {
        let _ = h;
        I.syntax && (_ = I.syntax.parse), I.parser && (_ = I.parser), _.parse && (_ = _.parse);
        try {
          B = _(P, I);
        } catch (R) {
          this.processed = !0, this.error = R;
        }
        B && !B[i] && a.rebuild(B);
      }
      this.result = new u(A, B, I), this.helpers = { ...S, postcss: S, result: this.result }, this.plugins = this.processor.plugins.map((_) => typeof _ == "object" && _.prepare ? { ..._, ..._.prepare(this.result) } : _);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(A) {
      return this.async().catch(A);
    }
    finally(A) {
      return this.async().then(A, A);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(A, P) {
      let I = this.result.lastPlugin;
      try {
        P && P.addToError(A), this.error = A, A.name === "CssSyntaxError" && !A.plugin ? (A.plugin = I.postcssPlugin, A.setMessage()) : I.postcssVersion;
      } catch (B) {
        console && console.error && console.error(B);
      }
      return A;
    }
    prepareVisitors() {
      this.listeners = {};
      let A = (P, I, B) => {
        this.listeners[I] || (this.listeners[I] = []), this.listeners[I].push([P, B]);
      };
      for (let P of this.plugins)
        if (typeof P == "object")
          for (let I in P) {
            if (!m[I] && /^[A-Z]/.test(I))
              throw new Error(`Unknown event ${I} in ${P.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
            if (!y[I])
              if (typeof P[I] == "object")
                for (let B in P[I])
                  B === "*" ? A(P, I, P[I][B]) : A(P, I + "-" + B.toLowerCase(), P[I][B]);
              else
                typeof P[I] == "function" && A(P, I, P[I]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let A = 0; A < this.plugins.length; A++) {
        let P = this.plugins[A], I = this.runOnRoot(P);
        if (D(I))
          try {
            await I;
          } catch (B) {
            throw this.handleError(B);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let A = this.result.root;
        for (; !A[r]; ) {
          A[r] = !0;
          let P = [w(A)];
          for (; P.length > 0; ) {
            let I = this.visitTick(P);
            if (D(I))
              try {
                await I;
              } catch (B) {
                let _ = P[P.length - 1].node;
                throw this.handleError(B, _);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [P, I] of this.listeners.OnceExit) {
            this.result.lastPlugin = P;
            try {
              if (A.type === "document") {
                let B = A.nodes.map((_) => I(_, this.helpers));
                await Promise.all(B);
              } else
                await I(A, this.helpers);
            } catch (B) {
              throw this.handleError(B);
            }
          }
      }
      return this.processed = !0, this.stringify();
    }
    runOnRoot(A) {
      this.result.lastPlugin = A;
      try {
        if (typeof A == "object" && A.Once) {
          if (this.result.root.type === "document") {
            let P = this.result.root.nodes.map((I) => A.Once(I, this.helpers));
            return D(P[0]) ? Promise.all(P) : P;
          }
          return A.Once(this.result.root, this.helpers);
        } else if (typeof A == "function")
          return A(this.result.root, this.result);
      } catch (P) {
        throw this.handleError(P);
      }
    }
    stringify() {
      if (this.error)
        throw this.error;
      if (this.stringified)
        return this.result;
      this.stringified = !0, this.sync();
      let A = this.result.opts, P = s;
      A.syntax && (P = A.syntax.stringify), A.stringifier && (P = A.stringifier), P.stringify && (P = P.stringify);
      let I = new n(P, this.result.root, this.result.opts).generate();
      return this.result.css = I[0], this.result.map = I[1], this.result;
    }
    sync() {
      if (this.error)
        throw this.error;
      if (this.processed)
        return this.result;
      if (this.processed = !0, this.processing)
        throw this.getAsyncError();
      for (let A of this.plugins) {
        let P = this.runOnRoot(A);
        if (D(P))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let A = this.result.root;
        for (; !A[r]; )
          A[r] = !0, this.walkSync(A);
        if (this.listeners.OnceExit)
          if (A.type === "document")
            for (let P of A.nodes)
              this.visitSync(this.listeners.OnceExit, P);
          else
            this.visitSync(this.listeners.OnceExit, A);
      }
      return this.result;
    }
    then(A, P) {
      return this.async().then(A, P);
    }
    toString() {
      return this.css;
    }
    visitSync(A, P) {
      for (let [I, B] of A) {
        this.result.lastPlugin = I;
        let _;
        try {
          _ = B(P, this.helpers);
        } catch (R) {
          throw this.handleError(R, P.proxyOf);
        }
        if (P.type !== "root" && P.type !== "document" && !P.parent)
          return !0;
        if (D(_))
          throw this.getAsyncError();
      }
    }
    visitTick(A) {
      let P = A[A.length - 1], { node: I, visitors: B } = P;
      if (I.type !== "root" && I.type !== "document" && !I.parent) {
        A.pop();
        return;
      }
      if (B.length > 0 && P.visitorIndex < B.length) {
        let [R, G] = B[P.visitorIndex];
        P.visitorIndex += 1, P.visitorIndex === B.length && (P.visitors = [], P.visitorIndex = 0), this.result.lastPlugin = R;
        try {
          return G(I.toProxy(), this.helpers);
        } catch (J) {
          throw this.handleError(J, I);
        }
      }
      if (P.iterator !== 0) {
        let R = P.iterator, G;
        for (; G = I.nodes[I.indexes[R]]; )
          if (I.indexes[R] += 1, !G[r]) {
            G[r] = !0, A.push(w(G));
            return;
          }
        P.iterator = 0, delete I.indexes[R];
      }
      let _ = P.events;
      for (; P.eventIndex < _.length; ) {
        let R = _[P.eventIndex];
        if (P.eventIndex += 1, R === O) {
          I.nodes && I.nodes.length && (I[r] = !0, P.iterator = I.getIterator());
          return;
        } else if (this.listeners[R]) {
          P.visitors = this.listeners[R];
          return;
        }
      }
      A.pop();
    }
    walkSync(A) {
      A[r] = !0;
      let P = v(A);
      for (let I of P)
        if (I === O)
          A.nodes && A.each((B) => {
            B[r] || this.walkSync(B);
          });
        else {
          let B = this.listeners[I];
          if (B && this.visitSync(B, A.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
  };
  k.registerPostcss = (C) => {
    S = C;
  }, e.exports = k, k.default = k, p.registerLazyResult(k), l.registerLazyResult(k);
}), U8 = re((t, e) => {
  var r = m2(), i = Oh();
  g2();
  var n = bh(), s = jm(), a = class {
    constructor(l, u, h) {
      u = u.toString(), this.stringified = !1, this._processor = l, this._css = u, this._opts = h, this._map = void 0;
      let p, d = i;
      this.result = new s(this._processor, p, this._opts), this.result.css = u;
      let m = this;
      Object.defineProperty(this.result, "root", { get() {
        return m.root;
      } });
      let y = new r(d, p, this._opts, u);
      if (y.isMap()) {
        let [O, D] = y.generate();
        O && (this.result.css = O), D && (this.result.map = D);
      } else
        y.clearAnnotation(), this.result.css = y.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(l) {
      return this.async().catch(l);
    }
    finally(l) {
      return this.async().then(l, l);
    }
    sync() {
      if (this.error)
        throw this.error;
      return this.result;
    }
    then(l, u) {
      return this.async().then(l, u);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let l, u = n;
      try {
        l = u(this._css, this._opts);
      } catch (h) {
        this.error = h;
      }
      if (this.error)
        throw this.error;
      return this._root = l, l;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
  };
  e.exports = a, a.default = a;
}), Y8 = re((t, e) => {
  var r = U8(), i = O2(), n = Qm(), s = Cl(), a = class {
    constructor(l = []) {
      this.version = "8.4.33", this.plugins = this.normalize(l);
    }
    normalize(l) {
      let u = [];
      for (let h of l)
        if (h.postcss === !0 ? h = h() : h.postcss && (h = h.postcss), typeof h == "object" && Array.isArray(h.plugins))
          u = u.concat(h.plugins);
        else if (typeof h == "object" && h.postcssPlugin)
          u.push(h);
        else if (typeof h == "function")
          u.push(h);
        else if (!(typeof h == "object" && (h.parse || h.stringify)))
          throw new Error(h + " is not a PostCSS plugin");
      return u;
    }
    process(l, u = {}) {
      return !this.plugins.length && !u.parser && !u.stringifier && !u.syntax ? new r(this, l, u) : new i(this, l, u);
    }
    use(l) {
      return this.plugins = this.plugins.concat(this.normalize([l])), this;
    }
  };
  e.exports = a, a.default = a, s.registerProcessor(a), n.registerProcessor(a);
}), z8 = re((t, e) => {
  var r = Dh(), i = f2(), n = Sl(), s = _m(), a = El(), l = Cl(), u = Mm();
  function h(p, d) {
    if (Array.isArray(p))
      return p.map((O) => h(O));
    let { inputs: m, ...y } = p;
    if (m) {
      d = [];
      for (let O of m) {
        let D = { ...O, __proto__: a.prototype };
        D.map && (D.map = { ...D.map, __proto__: i.prototype }), d.push(D);
      }
    }
    if (y.nodes && (y.nodes = p.nodes.map((O) => h(O, d))), y.source) {
      let { inputId: O, ...D } = y.source;
      y.source = D, O != null && (y.source.input = d[O]);
    }
    if (y.type === "root")
      return new l(y);
    if (y.type === "decl")
      return new r(y);
    if (y.type === "rule")
      return new u(y);
    if (y.type === "comment")
      return new n(y);
    if (y.type === "atrule")
      return new s(y);
    throw new Error("Unknown node type: " + p.type);
  }
  e.exports = h, h.default = h;
}), Rm = re((t, e) => {
  var r = Bm(), i = Dh(), n = O2(), s = $s(), a = Y8(), l = Oh(), u = z8(), h = Qm(), p = y2(), d = Sl(), m = _m(), y = jm(), O = El(), D = bh(), v = d2(), w = Mm(), x = Cl(), S = xh();
  function k(...C) {
    return C.length === 1 && Array.isArray(C[0]) && (C = C[0]), new a(C);
  }
  k.plugin = function(C, A) {
    let P = !1;
    function I(..._) {
      console && console.warn && !P && (P = !0, console.warn(C + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`));
      let R = A(..._);
      return R.postcssPlugin = C, R.postcssVersion = new a().version, R;
    }
    let B;
    return Object.defineProperty(I, "postcss", { get() {
      return B || (B = I()), B;
    } }), I.process = function(_, R, G) {
      return k([I(G)]).process(_, R);
    }, I;
  }, k.stringify = l, k.parse = D, k.fromJSON = u, k.list = v, k.comment = (C) => new d(C), k.atRule = (C) => new m(C), k.decl = (C) => new i(C), k.rule = (C) => new w(C), k.root = (C) => new x(C), k.document = (C) => new h(C), k.CssSyntaxError = r, k.Declaration = i, k.Container = s, k.Processor = a, k.Document = h, k.Comment = d, k.Warning = p, k.AtRule = m, k.Result = y, k.Input = O, k.Rule = w, k.Root = x, k.Node = S, n.registerPostcss(k), e.exports = k, k.default = k;
}), G8 = re((t, e) => {
  var { Container: r } = Rm(), i = class extends r {
    constructor(n) {
      super(n), this.type = "decl", this.isNested = !0, this.nodes || (this.nodes = []);
    }
  };
  e.exports = i;
}), H8 = re((t, e) => {
  var r = /[\t\n\f\r "#'()/;[\\\]{}]/g, i = /[,\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, n = /.[\r\n"'(/\\]/, s = /[\da-f]/i, a = /[\n\f\r]/g;
  e.exports = function(l, u = {}) {
    let h = l.css.valueOf(), p = u.ignoreErrors, d, m, y, O, D, v, w, x, S, k = h.length, C = 0, A = [], P = [], I;
    function B() {
      return C;
    }
    function _(q) {
      throw l.error("Unclosed " + q, C);
    }
    function R() {
      return P.length === 0 && C >= k;
    }
    function G() {
      let q = 1, X = !1, K = !1;
      for (; q > 0; )
        m += 1, h.length <= m && _("interpolation"), d = h.charCodeAt(m), x = h.charCodeAt(m + 1), X ? !K && d === X ? (X = !1, K = !1) : d === 92 ? K = !K : K && (K = !1) : d === 39 || d === 34 ? X = d : d === 125 ? q -= 1 : d === 35 && x === 123 && (q += 1);
    }
    function J(q) {
      if (P.length)
        return P.pop();
      if (C >= k)
        return;
      let X = q ? q.ignoreUnclosed : !1;
      switch (d = h.charCodeAt(C), d) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12: {
          m = C;
          do
            m += 1, d = h.charCodeAt(m);
          while (d === 32 || d === 10 || d === 9 || d === 13 || d === 12);
          S = ["space", h.slice(C, m)], C = m - 1;
          break;
        }
        case 91:
        case 93:
        case 123:
        case 125:
        case 58:
        case 59:
        case 41: {
          let K = String.fromCharCode(d);
          S = [K, K, C];
          break;
        }
        case 44: {
          S = ["word", ",", C, C + 1];
          break;
        }
        case 40: {
          if (w = A.length ? A.pop()[1] : "", x = h.charCodeAt(C + 1), w === "url" && x !== 39 && x !== 34) {
            for (I = 1, v = !1, m = C + 1; m <= h.length - 1; ) {
              if (x = h.charCodeAt(m), x === 92)
                v = !v;
              else if (x === 40)
                I += 1;
              else if (x === 41 && (I -= 1, I === 0))
                break;
              m += 1;
            }
            O = h.slice(C, m + 1), S = ["brackets", O, C, m], C = m;
          } else
            m = h.indexOf(")", C + 1), O = h.slice(C, m + 1), m === -1 || n.test(O) ? S = ["(", "(", C] : (S = ["brackets", O, C, m], C = m);
          break;
        }
        case 39:
        case 34: {
          for (y = d, m = C, v = !1; m < k && (m++, m === k && _("string"), d = h.charCodeAt(m), x = h.charCodeAt(m + 1), !(!v && d === y)); )
            d === 92 ? v = !v : v ? v = !1 : d === 35 && x === 123 && G();
          S = ["string", h.slice(C, m + 1), C, m], C = m;
          break;
        }
        case 64: {
          r.lastIndex = C + 1, r.test(h), r.lastIndex === 0 ? m = h.length - 1 : m = r.lastIndex - 2, S = ["at-word", h.slice(C, m + 1), C, m], C = m;
          break;
        }
        case 92: {
          for (m = C, D = !0; h.charCodeAt(m + 1) === 92; )
            m += 1, D = !D;
          if (d = h.charCodeAt(m + 1), D && d !== 47 && d !== 32 && d !== 10 && d !== 9 && d !== 13 && d !== 12 && (m += 1, s.test(h.charAt(m)))) {
            for (; s.test(h.charAt(m + 1)); )
              m += 1;
            h.charCodeAt(m + 1) === 32 && (m += 1);
          }
          S = ["word", h.slice(C, m + 1), C, m], C = m;
          break;
        }
        default:
          x = h.charCodeAt(C + 1), d === 35 && x === 123 ? (m = C, G(), O = h.slice(C, m + 1), S = ["word", O, C, m], C = m) : d === 47 && x === 42 ? (m = h.indexOf("*/", C + 2) + 1, m === 0 && (p || X ? m = h.length : _("comment")), S = ["comment", h.slice(C, m + 1), C, m], C = m) : d === 47 && x === 47 ? (a.lastIndex = C + 1, a.test(h), a.lastIndex === 0 ? m = h.length - 1 : m = a.lastIndex - 2, O = h.slice(C, m + 1), S = ["comment", O, C, m, "inline"], C = m) : (i.lastIndex = C + 1, i.test(h), i.lastIndex === 0 ? m = h.length - 1 : m = i.lastIndex - 2, S = ["word", h.slice(C, m + 1), C, m], A.push(S), C = m);
          break;
      }
      return C++, S;
    }
    function Q(q) {
      P.push(q);
    }
    return { back: Q, endOfFile: R, nextToken: J, position: B };
  };
}), J8 = re((t, e) => {
  var { Comment: r } = Rm(), i = Lm(), n = G8(), s = H8(), a = class extends i {
    atrule(l) {
      let u = l[1], h = l;
      for (; !this.tokenizer.endOfFile(); ) {
        let p = this.tokenizer.nextToken();
        if (p[0] === "word" && p[2] === h[3] + 1)
          u += p[1], h = p;
        else {
          this.tokenizer.back(p);
          break;
        }
      }
      super.atrule(["at-word", u, l[2], h[3]]);
    }
    comment(l) {
      if (l[4] === "inline") {
        let u = new r();
        this.init(u, l[2]), u.raws.inline = !0;
        let h = this.input.fromOffset(l[3]);
        u.source.end = { column: h.col, line: h.line, offset: l[3] + 1 };
        let p = l[1].slice(2);
        if (/^\s*$/.test(p))
          u.text = "", u.raws.left = p, u.raws.right = "";
        else {
          let d = p.match(/^(\s*)([^]*\S)(\s*)$/), m = d[2].replace(/(\*\/|\/\*)/g, "*//*");
          u.text = m, u.raws.left = d[1], u.raws.right = d[3], u.raws.text = d[2];
        }
      } else
        super.comment(l);
    }
    createTokenizer() {
      this.tokenizer = s(this.input);
    }
    raw(l, u, h, p) {
      if (super.raw(l, u, h, p), l.raws[u]) {
        let d = l.raws[u].raw;
        l.raws[u].raw = h.reduce((m, y) => {
          if (y[0] === "comment" && y[4] === "inline") {
            let O = y[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*");
            return m + "/*" + O + "*/";
          } else
            return m + y[1];
        }, ""), d !== l.raws[u].raw && (l.raws[u].scss = d);
      }
    }
    rule(l) {
      let u = !1, h = 0, p = "";
      for (let d of l)
        if (u)
          d[0] !== "comment" && d[0] !== "{" && (p += d[1]);
        else {
          if (d[0] === "space" && d[1].includes(`
`))
            break;
          d[0] === "(" ? h += 1 : d[0] === ")" ? h -= 1 : h === 0 && d[0] === ":" && (u = !0);
        }
      if (!u || p.trim() === "" || /^[#:A-Za-z-]/.test(p))
        super.rule(l);
      else {
        l.pop();
        let d = new n();
        this.init(d, l[0][2]);
        let m;
        for (let O = l.length - 1; O >= 0; O--)
          if (l[O][0] !== "space") {
            m = l[O];
            break;
          }
        if (m[3]) {
          let O = this.input.fromOffset(m[3]);
          d.source.end = { column: O.col, line: O.line, offset: m[3] + 1 };
        } else {
          let O = this.input.fromOffset(m[2]);
          d.source.end = { column: O.col, line: O.line, offset: m[2] + 1 };
        }
        for (; l[0][0] !== "word"; )
          d.raws.before += l.shift()[1];
        if (l[0][2]) {
          let O = this.input.fromOffset(l[0][2]);
          d.source.start = { column: O.col, line: O.line, offset: l[0][2] };
        }
        for (d.prop = ""; l.length; ) {
          let O = l[0][0];
          if (O === ":" || O === "space" || O === "comment")
            break;
          d.prop += l.shift()[1];
        }
        d.raws.between = "";
        let y;
        for (; l.length; )
          if (y = l.shift(), y[0] === ":") {
            d.raws.between += y[1];
            break;
          } else
            d.raws.between += y[1];
        (d.prop[0] === "_" || d.prop[0] === "*") && (d.raws.before += d.prop[0], d.prop = d.prop.slice(1)), d.raws.between += this.spacesAndCommentsFromStart(l), this.precheckMissedSemicolon(l);
        for (let O = l.length - 1; O > 0; O--) {
          if (y = l[O], y[1] === "!important") {
            d.important = !0;
            let D = this.stringFrom(l, O);
            D = this.spacesFromEnd(l) + D, D !== " !important" && (d.raws.important = D);
            break;
          } else if (y[1] === "important") {
            let D = l.slice(0), v = "";
            for (let w = O; w > 0; w--) {
              let x = D[w][0];
              if (v.trim().indexOf("!") === 0 && x !== "space")
                break;
              v = D.pop()[1] + v;
            }
            v.trim().indexOf("!") === 0 && (d.important = !0, d.raws.important = v, l = D);
          }
          if (y[0] !== "space" && y[0] !== "comment")
            break;
        }
        this.raw(d, "value", l), d.value.includes(":") && this.checkMissedSemicolon(l), this.current = d;
      }
    }
  };
  e.exports = a;
}), K8 = re((t, e) => {
  var { Input: r } = Rm(), i = J8();
  e.exports = function(n, s) {
    let a = new r(n, s), l = new i(a);
    return l.parse(), l.root;
  };
}), D2 = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(r) {
    this.after = r.after, this.before = r.before, this.type = r.type, this.value = r.value, this.sourceIndex = r.sourceIndex;
  }
  t.default = e;
}), b2 = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = D2(), r = i(e);
  function i(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function n(s) {
    var a = this;
    this.constructor(s), this.nodes = s.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(l) {
      l.parent = a;
    });
  }
  n.prototype = Object.create(r.default.prototype), n.constructor = r.default, n.prototype.walk = function(s, a) {
    for (var l = typeof s == "string" || s instanceof RegExp, u = l ? a : s, h = typeof s == "string" ? new RegExp(s) : s, p = 0; p < this.nodes.length; p++) {
      var d = this.nodes[p], m = l ? h.test(d.type) : !0;
      if (m && u && u(d, p, this.nodes) === !1 || d.nodes && d.walk(s, a) === !1)
        return !1;
    }
    return !0;
  }, n.prototype.each = function() {
    for (var s = arguments.length <= 0 || arguments[0] === void 0 ? function() {
    } : arguments[0], a = 0; a < this.nodes.length; a++) {
      var l = this.nodes[a];
      if (s(l, a, this.nodes) === !1)
        return !1;
    }
    return !0;
  }, t.default = n;
}), eI = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.parseMediaFeature = a, t.parseMediaQuery = l, t.parseMediaList = u;
  var e = D2(), r = s(e), i = b2(), n = s(i);
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h) {
    var p = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], d = [{ mode: "normal", character: null }], m = [], y = 0, O = "", D = null, v = null, w = p, x = h;
    h[0] === "(" && h[h.length - 1] === ")" && (x = h.substring(1, h.length - 1), w++);
    for (var S = 0; S < x.length; S++) {
      var k = x[S];
      if ((k === "'" || k === '"') && (d[y].isCalculationEnabled === !0 ? (d.push({ mode: "string", isCalculationEnabled: !1, character: k }), y++) : d[y].mode === "string" && d[y].character === k && x[S - 1] !== "\\" && (d.pop(), y--)), k === "{" ? (d.push({ mode: "interpolation", isCalculationEnabled: !0 }), y++) : k === "}" && (d.pop(), y--), d[y].mode === "normal" && k === ":") {
        var C = x.substring(S + 1);
        v = { type: "value", before: /^(\s*)/.exec(C)[1], after: /(\s*)$/.exec(C)[1], value: C.trim() }, v.sourceIndex = v.before.length + S + 1 + w, D = { type: "colon", sourceIndex: S + w, after: v.before, value: ":" };
        break;
      }
      O += k;
    }
    return O = { type: "media-feature", before: /^(\s*)/.exec(O)[1], after: /(\s*)$/.exec(O)[1], value: O.trim() }, O.sourceIndex = O.before.length + w, m.push(O), D !== null && (D.before = O.after, m.push(D)), v !== null && m.push(v), m;
  }
  function l(h) {
    var p = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], d = [], m = 0, y = !1, O = void 0;
    function D() {
      return { before: "", after: "", value: "" };
    }
    O = D();
    for (var v = 0; v < h.length; v++) {
      var w = h[v];
      y ? (O.value += w, (w === "{" || w === "(") && m++, (w === ")" || w === "}") && m--) : w.search(/\s/) !== -1 ? O.before += w : (w === "(" && (O.type = "media-feature-expression", m++), O.value = w, O.sourceIndex = p + v, y = !0), y && m === 0 && (w === ")" || v === h.length - 1 || h[v + 1].search(/\s/) !== -1) && (["not", "only", "and"].indexOf(O.value) !== -1 && (O.type = "keyword"), O.type === "media-feature-expression" && (O.nodes = a(O.value, O.sourceIndex)), d.push(Array.isArray(O.nodes) ? new n.default(O) : new r.default(O)), O = D(), y = !1);
    }
    for (var x = 0; x < d.length; x++)
      if (O = d[x], x > 0 && (d[x - 1].after = O.before), O.type === void 0) {
        if (x > 0) {
          if (d[x - 1].type === "media-feature-expression") {
            O.type = "keyword";
            continue;
          }
          if (d[x - 1].value === "not" || d[x - 1].value === "only") {
            O.type = "media-type";
            continue;
          }
          if (d[x - 1].value === "and") {
            O.type = "media-feature-expression";
            continue;
          }
          d[x - 1].type === "media-type" && (d[x + 1] ? O.type = d[x + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : O.type = "media-feature-expression");
        }
        if (x === 0) {
          if (!d[x + 1]) {
            O.type = "media-type";
            continue;
          }
          if (d[x + 1] && (d[x + 1].type === "media-feature-expression" || d[x + 1].type === "keyword")) {
            O.type = "media-type";
            continue;
          }
          if (d[x + 2]) {
            if (d[x + 2].type === "media-feature-expression") {
              O.type = "media-type", d[x + 1].type = "keyword";
              continue;
            }
            if (d[x + 2].type === "keyword") {
              O.type = "keyword", d[x + 1].type = "media-type";
              continue;
            }
          }
          if (d[x + 3] && d[x + 3].type === "media-feature-expression") {
            O.type = "keyword", d[x + 1].type = "media-type", d[x + 2].type = "keyword";
            continue;
          }
        }
      }
    return d;
  }
  function u(h) {
    var p = [], d = 0, m = 0, y = /^(\s*)url\s*\(/.exec(h);
    if (y !== null) {
      for (var O = y[0].length, D = 1; D > 0; ) {
        var v = h[O];
        v === "(" && D++, v === ")" && D--, O++;
      }
      p.unshift(new r.default({ type: "url", value: h.substring(0, O).trim(), sourceIndex: y[1].length, before: y[1], after: /^(\s*)/.exec(h.substring(O))[1] })), d = O;
    }
    for (var w = d; w < h.length; w++) {
      var x = h[w];
      if (x === "(" && m++, x === ")" && m--, m === 0 && x === ",") {
        var S = h.substring(d, w), k = /^(\s*)/.exec(S)[1];
        p.push(new n.default({ type: "media-query", value: S.trim(), sourceIndex: d + k.length, nodes: l(S, d), before: k, after: /(\s*)$/.exec(S)[1] })), d = w + 1;
      }
    }
    var C = h.substring(d), A = /^(\s*)/.exec(C)[1];
    return p.push(new n.default({ type: "media-query", value: C.trim(), sourceIndex: d + A.length, nodes: l(C, d), before: A, after: /(\s*)$/.exec(C)[1] })), p;
  }
}), tI = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = s;
  var e = b2(), r = n(e), i = eI();
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function s(a) {
    return new r.default({ nodes: (0, i.parseMediaList)(a), type: "media-query-list", value: a.trim() });
  }
}), v2 = re((t, e) => {
  e.exports = function(r, i) {
    if (i = typeof i == "number" ? i : 1 / 0, !i)
      return Array.isArray(r) ? r.map(function(s) {
        return s;
      }) : r;
    return n(r, 1);
    function n(s, a) {
      return s.reduce(function(l, u) {
        return Array.isArray(u) && a < i ? l.concat(n(u, a + 1)) : l.concat(u);
      }, []);
    }
  };
}), w2 = re((t, e) => {
  e.exports = function(r, i) {
    for (var n = -1, s = []; (n = r.indexOf(i, n + 1)) !== -1; )
      s.push(n);
    return s;
  };
}), S2 = re((t, e) => {
  function r(s, a) {
    for (var l = 1, u = s.length, h = s[0], p = s[0], d = 1; d < u; ++d)
      if (p = h, h = s[d], a(h, p)) {
        if (d === l) {
          l++;
          continue;
        }
        s[l++] = h;
      }
    return s.length = l, s;
  }
  function i(s) {
    for (var a = 1, l = s.length, u = s[0], h = s[0], p = 1; p < l; ++p, h = u)
      if (h = u, u = s[p], u !== h) {
        if (p === a) {
          a++;
          continue;
        }
        s[a++] = u;
      }
    return s.length = a, s;
  }
  function n(s, a, l) {
    return s.length === 0 ? s : a ? (l || s.sort(a), r(s, a)) : (l || s.sort(), i(s));
  }
  e.exports = n;
}), Ma = re((t, e) => {
  t.__esModule = !0;
  var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
    return typeof a;
  } : function(a) {
    return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
  };
  function i(a, l) {
    if (!(a instanceof l))
      throw new TypeError("Cannot call a class as a function");
  }
  var n = function a(l, u) {
    if ((typeof l > "u" ? "undefined" : r(l)) !== "object")
      return l;
    var h = new l.constructor();
    for (var p in l)
      if (l.hasOwnProperty(p)) {
        var d = l[p], m = typeof d > "u" ? "undefined" : r(d);
        p === "parent" && m === "object" ? u && (h[p] = u) : d instanceof Array ? h[p] = d.map(function(y) {
          return a(y, h);
        }) : h[p] = a(d, h);
      }
    return h;
  }, s = function() {
    function a() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      i(this, a);
      for (var u in l)
        this[u] = l[u];
      var h = l.spaces;
      h = h === void 0 ? {} : h;
      var p = h.before, d = p === void 0 ? "" : p, m = h.after, y = m === void 0 ? "" : m;
      this.spaces = { before: d, after: y };
    }
    return a.prototype.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, a.prototype.replaceWith = function() {
      if (this.parent) {
        for (var l in arguments)
          this.parent.insertBefore(this, arguments[l]);
        this.remove();
      }
      return this;
    }, a.prototype.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, a.prototype.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, a.prototype.clone = function() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = n(this);
      for (var h in l)
        u[h] = l[h];
      return u;
    }, a.prototype.toString = function() {
      return [this.spaces.before, String(this.value), this.spaces.after].join("");
    }, a;
  }();
  t.default = s, e.exports = t.default;
}), lr = re((t) => {
  t.__esModule = !0, t.TAG = "tag", t.STRING = "string", t.SELECTOR = "selector", t.ROOT = "root", t.PSEUDO = "pseudo", t.NESTING = "nesting", t.ID = "id", t.COMMENT = "comment", t.COMBINATOR = "combinator", t.CLASS = "class", t.ATTRIBUTE = "attribute", t.UNIVERSAL = "universal";
}), Zm = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function y(O, D) {
      for (var v = 0; v < D.length; v++) {
        var w = D[v];
        w.enumerable = w.enumerable || !1, w.configurable = !0, "value" in w && (w.writable = !0), Object.defineProperty(O, w.key, w);
      }
    }
    return function(O, D, v) {
      return D && y(O.prototype, D), v && y(O, v), O;
    };
  }(), i = Ma(), n = u(i), s = lr(), a = l(s);
  function l(y) {
    if (y && y.__esModule)
      return y;
    var O = {};
    if (y != null)
      for (var D in y)
        Object.prototype.hasOwnProperty.call(y, D) && (O[D] = y[D]);
    return O.default = y, O;
  }
  function u(y) {
    return y && y.__esModule ? y : { default: y };
  }
  function h(y, O) {
    if (!(y instanceof O))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(y, O) {
    if (!y)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return O && (typeof O == "object" || typeof O == "function") ? O : y;
  }
  function d(y, O) {
    if (typeof O != "function" && O !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof O);
    y.prototype = Object.create(O && O.prototype, { constructor: { value: y, enumerable: !1, writable: !0, configurable: !0 } }), O && (Object.setPrototypeOf ? Object.setPrototypeOf(y, O) : y.__proto__ = O);
  }
  var m = function(y) {
    d(O, y);
    function O(D) {
      h(this, O);
      var v = p(this, y.call(this, D));
      return v.nodes || (v.nodes = []), v;
    }
    return O.prototype.append = function(D) {
      return D.parent = this, this.nodes.push(D), this;
    }, O.prototype.prepend = function(D) {
      return D.parent = this, this.nodes.unshift(D), this;
    }, O.prototype.at = function(D) {
      return this.nodes[D];
    }, O.prototype.index = function(D) {
      return typeof D == "number" ? D : this.nodes.indexOf(D);
    }, O.prototype.removeChild = function(D) {
      D = this.index(D), this.at(D).parent = void 0, this.nodes.splice(D, 1);
      var v = void 0;
      for (var w in this.indexes)
        v = this.indexes[w], v >= D && (this.indexes[w] = v - 1);
      return this;
    }, O.prototype.removeAll = function() {
      for (var w = this.nodes, D = Array.isArray(w), v = 0, w = D ? w : w[Symbol.iterator](); ; ) {
        var x;
        if (D) {
          if (v >= w.length)
            break;
          x = w[v++];
        } else {
          if (v = w.next(), v.done)
            break;
          x = v.value;
        }
        var S = x;
        S.parent = void 0;
      }
      return this.nodes = [], this;
    }, O.prototype.empty = function() {
      return this.removeAll();
    }, O.prototype.insertAfter = function(D, v) {
      var w = this.index(D);
      this.nodes.splice(w + 1, 0, v);
      var x = void 0;
      for (var S in this.indexes)
        x = this.indexes[S], w <= x && (this.indexes[S] = x + this.nodes.length);
      return this;
    }, O.prototype.insertBefore = function(D, v) {
      var w = this.index(D);
      this.nodes.splice(w, 0, v);
      var x = void 0;
      for (var S in this.indexes)
        x = this.indexes[S], w <= x && (this.indexes[S] = x + this.nodes.length);
      return this;
    }, O.prototype.each = function(D) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var v = this.lastEach;
      if (this.indexes[v] = 0, !!this.length) {
        for (var w = void 0, x = void 0; this.indexes[v] < this.length && (w = this.indexes[v], x = D(this.at(w), w), x !== !1); )
          this.indexes[v] += 1;
        if (delete this.indexes[v], x === !1)
          return !1;
      }
    }, O.prototype.walk = function(D) {
      return this.each(function(v, w) {
        var x = D(v, w);
        if (x !== !1 && v.length && (x = v.walk(D)), x === !1)
          return !1;
      });
    }, O.prototype.walkAttributes = function(D) {
      var v = this;
      return this.walk(function(w) {
        if (w.type === a.ATTRIBUTE)
          return D.call(v, w);
      });
    }, O.prototype.walkClasses = function(D) {
      var v = this;
      return this.walk(function(w) {
        if (w.type === a.CLASS)
          return D.call(v, w);
      });
    }, O.prototype.walkCombinators = function(D) {
      var v = this;
      return this.walk(function(w) {
        if (w.type === a.COMBINATOR)
          return D.call(v, w);
      });
    }, O.prototype.walkComments = function(D) {
      var v = this;
      return this.walk(function(w) {
        if (w.type === a.COMMENT)
          return D.call(v, w);
      });
    }, O.prototype.walkIds = function(D) {
      var v = this;
      return this.walk(function(w) {
        if (w.type === a.ID)
          return D.call(v, w);
      });
    }, O.prototype.walkNesting = function(D) {
      var v = this;
      return this.walk(function(w) {
        if (w.type === a.NESTING)
          return D.call(v, w);
      });
    }, O.prototype.walkPseudos = function(D) {
      var v = this;
      return this.walk(function(w) {
        if (w.type === a.PSEUDO)
          return D.call(v, w);
      });
    }, O.prototype.walkTags = function(D) {
      var v = this;
      return this.walk(function(w) {
        if (w.type === a.TAG)
          return D.call(v, w);
      });
    }, O.prototype.walkUniversals = function(D) {
      var v = this;
      return this.walk(function(w) {
        if (w.type === a.UNIVERSAL)
          return D.call(v, w);
      });
    }, O.prototype.split = function(D) {
      var v = this, w = [];
      return this.reduce(function(x, S, k) {
        var C = D.call(v, S);
        return w.push(S), C ? (x.push(w), w = []) : k === v.length - 1 && x.push(w), x;
      }, []);
    }, O.prototype.map = function(D) {
      return this.nodes.map(D);
    }, O.prototype.reduce = function(D, v) {
      return this.nodes.reduce(D, v);
    }, O.prototype.every = function(D) {
      return this.nodes.every(D);
    }, O.prototype.some = function(D) {
      return this.nodes.some(D);
    }, O.prototype.filter = function(D) {
      return this.nodes.filter(D);
    }, O.prototype.sort = function(D) {
      return this.nodes.sort(D);
    }, O.prototype.toString = function() {
      return this.map(String).join("");
    }, r(O, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), O;
  }(n.default);
  t.default = m, e.exports = t.default;
}), rI = re((t, e) => {
  t.__esModule = !0;
  var r = Zm(), i = s(r), n = lr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function a(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      a(this, d);
      var y = l(this, p.call(this, m));
      return y.type = n.ROOT, y;
    }
    return d.prototype.toString = function() {
      var m = this.reduce(function(y, O) {
        var D = String(O);
        return D ? y + D + "," : "";
      }, "").slice(0, -1);
      return this.trailingComma ? m + "," : m;
    }, d;
  }(i.default);
  t.default = h, e.exports = t.default;
}), iI = re((t, e) => {
  t.__esModule = !0;
  var r = Zm(), i = s(r), n = lr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function a(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      a(this, d);
      var y = l(this, p.call(this, m));
      return y.type = n.SELECTOR, y;
    }
    return d;
  }(i.default);
  t.default = h, e.exports = t.default;
}), Al = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function p(d, m) {
      for (var y = 0; y < m.length; y++) {
        var O = m[y];
        O.enumerable = O.enumerable || !1, O.configurable = !0, "value" in O && (O.writable = !0), Object.defineProperty(d, O.key, O);
      }
    }
    return function(d, m, y) {
      return m && p(d.prototype, m), y && p(d, y), d;
    };
  }(), i = Ma(), n = s(i);
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function a(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d() {
      return a(this, d), l(this, p.apply(this, arguments));
    }
    return d.prototype.toString = function() {
      return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
    }, r(d, [{ key: "ns", get: function() {
      var m = this.namespace;
      return m ? (typeof m == "string" ? m : "") + "|" : "";
    } }]), d;
  }(n.default);
  t.default = h, e.exports = t.default;
}), nI = re((t, e) => {
  t.__esModule = !0;
  var r = Al(), i = s(r), n = lr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function a(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      a(this, d);
      var y = l(this, p.call(this, m));
      return y.type = n.CLASS, y;
    }
    return d.prototype.toString = function() {
      return [this.spaces.before, this.ns, "." + this.value, this.spaces.after].join("");
    }, d;
  }(i.default);
  t.default = h, e.exports = t.default;
}), sI = re((t, e) => {
  t.__esModule = !0;
  var r = Ma(), i = s(r), n = lr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function a(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      a(this, d);
      var y = l(this, p.call(this, m));
      return y.type = n.COMMENT, y;
    }
    return d;
  }(i.default);
  t.default = h, e.exports = t.default;
}), aI = re((t, e) => {
  t.__esModule = !0;
  var r = Al(), i = s(r), n = lr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function a(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      a(this, d);
      var y = l(this, p.call(this, m));
      return y.type = n.ID, y;
    }
    return d.prototype.toString = function() {
      return [this.spaces.before, this.ns, "#" + this.value, this.spaces.after].join("");
    }, d;
  }(i.default);
  t.default = h, e.exports = t.default;
}), oI = re((t, e) => {
  t.__esModule = !0;
  var r = Al(), i = s(r), n = lr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function a(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      a(this, d);
      var y = l(this, p.call(this, m));
      return y.type = n.TAG, y;
    }
    return d;
  }(i.default);
  t.default = h, e.exports = t.default;
}), lI = re((t, e) => {
  t.__esModule = !0;
  var r = Ma(), i = s(r), n = lr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function a(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      a(this, d);
      var y = l(this, p.call(this, m));
      return y.type = n.STRING, y;
    }
    return d;
  }(i.default);
  t.default = h, e.exports = t.default;
}), uI = re((t, e) => {
  t.__esModule = !0;
  var r = Zm(), i = s(r), n = lr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function a(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      a(this, d);
      var y = l(this, p.call(this, m));
      return y.type = n.PSEUDO, y;
    }
    return d.prototype.toString = function() {
      var m = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.spaces.before, String(this.value), m, this.spaces.after].join("");
    }, d;
  }(i.default);
  t.default = h, e.exports = t.default;
}), cI = re((t, e) => {
  t.__esModule = !0;
  var r = Al(), i = s(r), n = lr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function a(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      a(this, d);
      var y = l(this, p.call(this, m));
      return y.type = n.ATTRIBUTE, y.raws = {}, y;
    }
    return d.prototype.toString = function() {
      var m = [this.spaces.before, "[", this.ns, this.attribute];
      return this.operator && m.push(this.operator), this.value && m.push(this.value), this.raws.insensitive ? m.push(this.raws.insensitive) : this.insensitive && m.push(" i"), m.push("]"), m.concat(this.spaces.after).join("");
    }, d;
  }(i.default);
  t.default = h, e.exports = t.default;
}), hI = re((t, e) => {
  t.__esModule = !0;
  var r = Al(), i = s(r), n = lr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function a(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      a(this, d);
      var y = l(this, p.call(this, m));
      return y.type = n.UNIVERSAL, y.value = "*", y;
    }
    return d;
  }(i.default);
  t.default = h, e.exports = t.default;
}), pI = re((t, e) => {
  t.__esModule = !0;
  var r = Ma(), i = s(r), n = lr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function a(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      a(this, d);
      var y = l(this, p.call(this, m));
      return y.type = n.COMBINATOR, y;
    }
    return d;
  }(i.default);
  t.default = h, e.exports = t.default;
}), dI = re((t, e) => {
  t.__esModule = !0;
  var r = Ma(), i = s(r), n = lr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function a(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      a(this, d);
      var y = l(this, p.call(this, m));
      return y.type = n.NESTING, y.value = "&", y;
    }
    return d;
  }(i.default);
  t.default = h, e.exports = t.default;
}), fI = re((t, e) => {
  t.__esModule = !0, t.default = r;
  function r(i) {
    return i.sort(function(n, s) {
      return n - s;
    });
  }
  e.exports = t.default;
}), mI = re((t, e) => {
  t.__esModule = !0, t.default = R;
  var r = 39, i = 34, n = 92, s = 47, a = 10, l = 32, u = 12, h = 9, p = 13, d = 43, m = 62, y = 126, O = 124, D = 44, v = 40, w = 41, x = 91, S = 93, k = 59, C = 42, A = 58, P = 38, I = 64, B = /[ \n\t\r\{\(\)'"\\;/]/g, _ = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
  function R(G) {
    for (var J = [], Q = G.css.valueOf(), q = void 0, X = void 0, K = void 0, ye = void 0, Ce = void 0, be = void 0, Le = void 0, Ye = void 0, Je = void 0, Te = void 0, ht = void 0, ue = Q.length, V = -1, W = 1, j = 0, ve = function(De, Ae) {
      if (G.safe)
        Q += Ae, X = Q.length - 1;
      else
        throw G.error("Unclosed " + De, W, j - V, j);
    }; j < ue; ) {
      switch (q = Q.charCodeAt(j), q === a && (V = j, W += 1), q) {
        case a:
        case l:
        case h:
        case p:
        case u:
          X = j;
          do
            X += 1, q = Q.charCodeAt(X), q === a && (V = X, W += 1);
          while (q === l || q === a || q === h || q === p || q === u);
          J.push(["space", Q.slice(j, X), W, j - V, j]), j = X - 1;
          break;
        case d:
        case m:
        case y:
        case O:
          X = j;
          do
            X += 1, q = Q.charCodeAt(X);
          while (q === d || q === m || q === y || q === O);
          J.push(["combinator", Q.slice(j, X), W, j - V, j]), j = X - 1;
          break;
        case C:
          J.push(["*", "*", W, j - V, j]);
          break;
        case P:
          J.push(["&", "&", W, j - V, j]);
          break;
        case D:
          J.push([",", ",", W, j - V, j]);
          break;
        case x:
          J.push(["[", "[", W, j - V, j]);
          break;
        case S:
          J.push(["]", "]", W, j - V, j]);
          break;
        case A:
          J.push([":", ":", W, j - V, j]);
          break;
        case k:
          J.push([";", ";", W, j - V, j]);
          break;
        case v:
          J.push(["(", "(", W, j - V, j]);
          break;
        case w:
          J.push([")", ")", W, j - V, j]);
          break;
        case r:
        case i:
          K = q === r ? "'" : '"', X = j;
          do
            for (Te = !1, X = Q.indexOf(K, X + 1), X === -1 && ve("quote", K), ht = X; Q.charCodeAt(ht - 1) === n; )
              ht -= 1, Te = !Te;
          while (Te);
          J.push(["string", Q.slice(j, X + 1), W, j - V, W, X - V, j]), j = X;
          break;
        case I:
          B.lastIndex = j + 1, B.test(Q), B.lastIndex === 0 ? X = Q.length - 1 : X = B.lastIndex - 2, J.push(["at-word", Q.slice(j, X + 1), W, j - V, W, X - V, j]), j = X;
          break;
        case n:
          for (X = j, Le = !0; Q.charCodeAt(X + 1) === n; )
            X += 1, Le = !Le;
          q = Q.charCodeAt(X + 1), Le && q !== s && q !== l && q !== a && q !== h && q !== p && q !== u && (X += 1), J.push(["word", Q.slice(j, X + 1), W, j - V, W, X - V, j]), j = X;
          break;
        default:
          q === s && Q.charCodeAt(j + 1) === C ? (X = Q.indexOf("*/", j + 2) + 1, X === 0 && ve("comment", "*/"), be = Q.slice(j, X + 1), ye = be.split(`
`), Ce = ye.length - 1, Ce > 0 ? (Ye = W + Ce, Je = X - ye[Ce].length) : (Ye = W, Je = V), J.push(["comment", be, W, j - V, Ye, X - Je, j]), V = Je, W = Ye, j = X) : (_.lastIndex = j + 1, _.test(Q), _.lastIndex === 0 ? X = Q.length - 1 : X = _.lastIndex - 2, J.push(["word", Q.slice(j, X + 1), W, j - V, W, X - V, j]), j = X);
          break;
      }
      j++;
    }
    return J;
  }
  e.exports = t.default;
}), gI = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function V(W, j) {
      for (var ve = 0; ve < j.length; ve++) {
        var De = j[ve];
        De.enumerable = De.enumerable || !1, De.configurable = !0, "value" in De && (De.writable = !0), Object.defineProperty(W, De.key, De);
      }
    }
    return function(W, j, ve) {
      return j && V(W.prototype, j), ve && V(W, ve), W;
    };
  }(), i = v2(), n = Te(i), s = w2(), a = Te(s), l = S2(), u = Te(l), h = rI(), p = Te(h), d = iI(), m = Te(d), y = nI(), O = Te(y), D = sI(), v = Te(D), w = aI(), x = Te(w), S = oI(), k = Te(S), C = lI(), A = Te(C), P = uI(), I = Te(P), B = cI(), _ = Te(B), R = hI(), G = Te(R), J = pI(), Q = Te(J), q = dI(), X = Te(q), K = fI(), ye = Te(K), Ce = mI(), be = Te(Ce), Le = lr(), Ye = Je(Le);
  function Je(V) {
    if (V && V.__esModule)
      return V;
    var W = {};
    if (V != null)
      for (var j in V)
        Object.prototype.hasOwnProperty.call(V, j) && (W[j] = V[j]);
    return W.default = V, W;
  }
  function Te(V) {
    return V && V.__esModule ? V : { default: V };
  }
  function ht(V, W) {
    if (!(V instanceof W))
      throw new TypeError("Cannot call a class as a function");
  }
  var ue = function() {
    function V(W) {
      ht(this, V), this.input = W, this.lossy = W.options.lossless === !1, this.position = 0, this.root = new p.default();
      var j = new m.default();
      return this.root.append(j), this.current = j, this.lossy ? this.tokens = (0, be.default)({ safe: W.safe, css: W.css.trim() }) : this.tokens = (0, be.default)(W), this.loop();
    }
    return V.prototype.attribute = function() {
      var W = "", j = void 0, ve = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; )
        W += this.tokens[this.position][1], this.position++;
      this.position === this.tokens.length && !~W.indexOf("]") && this.error("Expected a closing square bracket.");
      var De = W.split(/((?:[*~^$|]?=))([^]*)/), Ae = De[0].split(/(\|)/g), Jt = { operator: De[1], value: De[2], source: { start: { line: ve[2], column: ve[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: ve[4] };
      if (Ae.length > 1 ? (Ae[0] === "" && (Ae[0] = !0), Jt.attribute = this.parseValue(Ae[2]), Jt.namespace = this.parseNamespace(Ae[0])) : Jt.attribute = this.parseValue(De[0]), j = new _.default(Jt), De[2]) {
        var Mt = De[2].split(/(\s+i\s*?)$/), wt = Mt[0].trim();
        j.value = this.lossy ? wt : Mt[0], Mt[1] && (j.insensitive = !0, this.lossy || (j.raws.insensitive = Mt[1])), j.quoted = wt[0] === "'" || wt[0] === '"', j.raws.unquoted = j.quoted ? wt.slice(1, -1) : wt;
      }
      this.newNode(j), this.position++;
    }, V.prototype.combinator = function() {
      if (this.currToken[1] === "|")
        return this.namespace();
      for (var W = new Q.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); )
        this.nextToken && this.nextToken[0] === "combinator" ? (W.spaces.before = this.parseSpace(this.currToken[1]), W.source.start.line = this.nextToken[2], W.source.start.column = this.nextToken[3], W.source.end.column = this.nextToken[3], W.source.end.line = this.nextToken[2], W.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? W.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? W.value = this.currToken[1] : this.currToken[0] === "space" && (W.value = this.parseSpace(this.currToken[1], " ")), this.position++;
      return this.newNode(W);
    }, V.prototype.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = !0, this.position++;
        return;
      }
      var W = new m.default();
      this.current.parent.append(W), this.current = W, this.position++;
    }, V.prototype.comment = function() {
      var W = new v.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
      this.newNode(W), this.position++;
    }, V.prototype.error = function(W) {
      throw new this.input.error(W);
    }, V.prototype.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.");
    }, V.prototype.missingParenthesis = function() {
      return this.error("Expected opening parenthesis.");
    }, V.prototype.missingSquareBracket = function() {
      return this.error("Expected opening square bracket.");
    }, V.prototype.namespace = function() {
      var W = this.prevToken && this.prevToken[1] || !0;
      if (this.nextToken[0] === "word")
        return this.position++, this.word(W);
      if (this.nextToken[0] === "*")
        return this.position++, this.universal(W);
    }, V.prototype.nesting = function() {
      this.newNode(new X.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
    }, V.prototype.parentheses = function() {
      var W = this.current.last;
      if (W && W.type === Ye.PSEUDO) {
        var j = new m.default(), ve = this.current;
        W.append(j), this.current = j;
        var De = 1;
        for (this.position++; this.position < this.tokens.length && De; )
          this.currToken[0] === "(" && De++, this.currToken[0] === ")" && De--, De ? this.parse() : (j.parent.source.end.line = this.currToken[2], j.parent.source.end.column = this.currToken[3], this.position++);
        De && this.error("Expected closing parenthesis."), this.current = ve;
      } else {
        var Ae = 1;
        for (this.position++, W.value += "("; this.position < this.tokens.length && Ae; )
          this.currToken[0] === "(" && Ae++, this.currToken[0] === ")" && Ae--, W.value += this.parseParenthesisToken(this.currToken), this.position++;
        Ae && this.error("Expected closing parenthesis.");
      }
    }, V.prototype.pseudo = function() {
      for (var W = this, j = "", ve = this.currToken; this.currToken && this.currToken[0] === ":"; )
        j += this.currToken[1], this.position++;
      if (!this.currToken)
        return this.error("Expected pseudo-class or pseudo-element");
      if (this.currToken[0] === "word") {
        var De = void 0;
        this.splitWord(!1, function(Ae, Jt) {
          j += Ae, De = new I.default({ value: j, source: { start: { line: ve[2], column: ve[3] }, end: { line: W.currToken[4], column: W.currToken[5] } }, sourceIndex: ve[4] }), W.newNode(De), Jt > 1 && W.nextToken && W.nextToken[0] === "(" && W.error("Misplaced parenthesis.");
        });
      } else
        this.error('Unexpected "' + this.currToken[0] + '" found.');
    }, V.prototype.space = function() {
      var W = this.currToken;
      this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(W[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(W[1]), this.position++) : this.combinator();
    }, V.prototype.string = function() {
      var W = this.currToken;
      this.newNode(new A.default({ value: this.currToken[1], source: { start: { line: W[2], column: W[3] }, end: { line: W[4], column: W[5] } }, sourceIndex: W[6] })), this.position++;
    }, V.prototype.universal = function(W) {
      var j = this.nextToken;
      if (j && j[1] === "|")
        return this.position++, this.namespace();
      this.newNode(new G.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), W), this.position++;
    }, V.prototype.splitWord = function(W, j) {
      for (var ve = this, De = this.nextToken, Ae = this.currToken[1]; De && De[0] === "word"; ) {
        this.position++;
        var Jt = this.currToken[1];
        if (Ae += Jt, Jt.lastIndexOf("\\") === Jt.length - 1) {
          var Mt = this.nextToken;
          Mt && Mt[0] === "space" && (Ae += this.parseSpace(Mt[1], " "), this.position++);
        }
        De = this.nextToken;
      }
      var wt = (0, a.default)(Ae, "."), Xr = (0, a.default)(Ae, "#"), ln = (0, a.default)(Ae, "#{");
      ln.length && (Xr = Xr.filter(function(kr) {
        return !~ln.indexOf(kr);
      }));
      var ur = (0, ye.default)((0, u.default)((0, n.default)([[0], wt, Xr])));
      ur.forEach(function(kr, li) {
        var un = ur[li + 1] || Ae.length, Qi = Ae.slice(kr, un);
        if (li === 0 && j)
          return j.call(ve, Qi, ur.length);
        var ji = void 0;
        ~wt.indexOf(kr) ? ji = new O.default({ value: Qi.slice(1), source: { start: { line: ve.currToken[2], column: ve.currToken[3] + kr }, end: { line: ve.currToken[4], column: ve.currToken[3] + (un - 1) } }, sourceIndex: ve.currToken[6] + ur[li] }) : ~Xr.indexOf(kr) ? ji = new x.default({ value: Qi.slice(1), source: { start: { line: ve.currToken[2], column: ve.currToken[3] + kr }, end: { line: ve.currToken[4], column: ve.currToken[3] + (un - 1) } }, sourceIndex: ve.currToken[6] + ur[li] }) : ji = new k.default({ value: Qi, source: { start: { line: ve.currToken[2], column: ve.currToken[3] + kr }, end: { line: ve.currToken[4], column: ve.currToken[3] + (un - 1) } }, sourceIndex: ve.currToken[6] + ur[li] }), ve.newNode(ji, W);
      }), this.position++;
    }, V.prototype.word = function(W) {
      var j = this.nextToken;
      return j && j[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(W);
    }, V.prototype.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(!0);
      return this.root;
    }, V.prototype.parse = function(W) {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parentheses();
          break;
        case ")":
          W && this.missingParenthesis();
          break;
        case "[":
          this.attribute();
          break;
        case "]":
          this.missingSquareBracket();
          break;
        case "at-word":
        case "word":
          this.word();
          break;
        case ":":
          this.pseudo();
          break;
        case ";":
          this.missingBackslash();
          break;
        case ",":
          this.comma();
          break;
        case "*":
          this.universal();
          break;
        case "&":
          this.nesting();
          break;
        case "combinator":
          this.combinator();
          break;
        case "string":
          this.string();
          break;
      }
    }, V.prototype.parseNamespace = function(W) {
      if (this.lossy && typeof W == "string") {
        var j = W.trim();
        return j.length ? j : !0;
      }
      return W;
    }, V.prototype.parseSpace = function(W, j) {
      return this.lossy ? j || "" : W;
    }, V.prototype.parseValue = function(W) {
      return this.lossy && W && typeof W == "string" ? W.trim() : W;
    }, V.prototype.parseParenthesisToken = function(W) {
      return this.lossy ? W[0] === "space" ? this.parseSpace(W[1], " ") : this.parseValue(W[1]) : W[1];
    }, V.prototype.newNode = function(W, j) {
      return j && (W.namespace = this.parseNamespace(j)), this.spaces && (W.spaces.before = this.spaces, this.spaces = ""), this.current.append(W);
    }, r(V, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), V;
  }();
  t.default = ue, e.exports = t.default;
}), yI = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function u(h, p) {
      for (var d = 0; d < p.length; d++) {
        var m = p[d];
        m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(h, m.key, m);
      }
    }
    return function(h, p, d) {
      return p && u(h.prototype, p), d && u(h, d), h;
    };
  }(), i = gI(), n = s(i);
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function a(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  var l = function() {
    function u(h) {
      return a(this, u), this.func = h || function() {
      }, this;
    }
    return u.prototype.process = function(h) {
      var p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, d = new n.default({ css: h, error: function(m) {
        throw new Error(m);
      }, options: p });
      return this.res = d, this.func(d), this;
    }, r(u, [{ key: "result", get: function() {
      return String(this.res);
    } }]), u;
  }();
  t.default = l, e.exports = t.default;
}), Ii = re((t, e) => {
  var r = function(i, n) {
    let s = new i.constructor();
    for (let a in i) {
      if (!i.hasOwnProperty(a))
        continue;
      let l = i[a], u = typeof l;
      a === "parent" && u === "object" ? n && (s[a] = n) : a === "source" ? s[a] = l : l instanceof Array ? s[a] = l.map((h) => r(h, s)) : a !== "before" && a !== "after" && a !== "between" && a !== "semicolon" && (u === "object" && l !== null && (l = r(l)), s[a] = l);
    }
    return s;
  };
  e.exports = class {
    constructor(i) {
      i = i || {}, this.raws = { before: "", after: "" };
      for (let n in i)
        this[n] = i[n];
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    toString() {
      return [this.raws.before, String(this.value), this.raws.after].join("");
    }
    clone(i) {
      i = i || {};
      let n = r(this);
      for (let s in i)
        n[s] = i[s];
      return n;
    }
    cloneBefore(i) {
      i = i || {};
      let n = this.clone(i);
      return this.parent.insertBefore(this, n), n;
    }
    cloneAfter(i) {
      i = i || {};
      let n = this.clone(i);
      return this.parent.insertAfter(this, n), n;
    }
    replaceWith() {
      let i = Array.prototype.slice.call(arguments);
      if (this.parent) {
        for (let n of i)
          this.parent.insertBefore(this, n);
        this.remove();
      }
      return this;
    }
    moveTo(i) {
      return this.cleanRaws(this.root() === i.root()), this.remove(), i.append(this), this;
    }
    moveBefore(i) {
      return this.cleanRaws(this.root() === i.root()), this.remove(), i.parent.insertBefore(i, this), this;
    }
    moveAfter(i) {
      return this.cleanRaws(this.root() === i.root()), this.remove(), i.parent.insertAfter(i, this), this;
    }
    next() {
      let i = this.parent.index(this);
      return this.parent.nodes[i + 1];
    }
    prev() {
      let i = this.parent.index(this);
      return this.parent.nodes[i - 1];
    }
    toJSON() {
      let i = {};
      for (let n in this) {
        if (!this.hasOwnProperty(n) || n === "parent")
          continue;
        let s = this[n];
        s instanceof Array ? i[n] = s.map((a) => typeof a == "object" && a.toJSON ? a.toJSON() : a) : typeof s == "object" && s.toJSON ? i[n] = s.toJSON() : i[n] = s;
      }
      return i;
    }
    root() {
      let i = this;
      for (; i.parent; )
        i = i.parent;
      return i;
    }
    cleanRaws(i) {
      delete this.raws.before, delete this.raws.after, i || delete this.raws.between;
    }
    positionInside(i) {
      let n = this.toString(), s = this.source.start.column, a = this.source.start.line;
      for (let l = 0; l < i; l++)
        n[l] === `
` ? (s = 1, a += 1) : s += 1;
      return { line: a, column: s };
    }
    positionBy(i) {
      let n = this.source.start;
      if (Object(i).index)
        n = this.positionInside(i.index);
      else if (Object(i).word) {
        let s = this.toString().indexOf(i.word);
        s !== -1 && (n = this.positionInside(s));
      }
      return n;
    }
  };
}), Er = re((t, e) => {
  var r = Ii(), i = class extends r {
    constructor(n) {
      super(n), this.nodes || (this.nodes = []);
    }
    push(n) {
      return n.parent = this, this.nodes.push(n), this;
    }
    each(n) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let s = this.lastEach, a, l;
      if (this.indexes[s] = 0, !!this.nodes) {
        for (; this.indexes[s] < this.nodes.length && (a = this.indexes[s], l = n(this.nodes[a], a), l !== !1); )
          this.indexes[s] += 1;
        return delete this.indexes[s], l;
      }
    }
    walk(n) {
      return this.each((s, a) => {
        let l = n(s, a);
        return l !== !1 && s.walk && (l = s.walk(n)), l;
      });
    }
    walkType(n, s) {
      if (!n || !s)
        throw new Error("Parameters {type} and {callback} are required.");
      let a = typeof n == "function";
      return this.walk((l, u) => {
        if (a && l instanceof n || !a && l.type === n)
          return s.call(this, l, u);
      });
    }
    append(n) {
      return n.parent = this, this.nodes.push(n), this;
    }
    prepend(n) {
      return n.parent = this, this.nodes.unshift(n), this;
    }
    cleanRaws(n) {
      if (super.cleanRaws(n), this.nodes)
        for (let s of this.nodes)
          s.cleanRaws(n);
    }
    insertAfter(n, s) {
      let a = this.index(n), l;
      this.nodes.splice(a + 1, 0, s);
      for (let u in this.indexes)
        l = this.indexes[u], a <= l && (this.indexes[u] = l + this.nodes.length);
      return this;
    }
    insertBefore(n, s) {
      let a = this.index(n), l;
      this.nodes.splice(a, 0, s);
      for (let u in this.indexes)
        l = this.indexes[u], a <= l && (this.indexes[u] = l + this.nodes.length);
      return this;
    }
    removeChild(n) {
      n = this.index(n), this.nodes[n].parent = void 0, this.nodes.splice(n, 1);
      let s;
      for (let a in this.indexes)
        s = this.indexes[a], s >= n && (this.indexes[a] = s - 1);
      return this;
    }
    removeAll() {
      for (let n of this.nodes)
        n.parent = void 0;
      return this.nodes = [], this;
    }
    every(n) {
      return this.nodes.every(n);
    }
    some(n) {
      return this.nodes.some(n);
    }
    index(n) {
      return typeof n == "number" ? n : this.nodes.indexOf(n);
    }
    get first() {
      if (this.nodes)
        return this.nodes[0];
    }
    get last() {
      if (this.nodes)
        return this.nodes[this.nodes.length - 1];
    }
    toString() {
      let n = this.nodes.map(String).join("");
      return this.value && (n = this.value + n), this.raws.before && (n = this.raws.before + n), this.raws.after && (n += this.raws.after), n;
    }
  };
  i.registerWalker = (n) => {
    let s = "walk" + n.name;
    s.lastIndexOf("s") !== s.length - 1 && (s += "s"), !i.prototype[s] && (i.prototype[s] = function(a) {
      return this.walkType(n, a);
    });
  }, e.exports = i;
}), OI = re((t, e) => {
  var r = Er();
  e.exports = class extends r {
    constructor(i) {
      super(i), this.type = "root";
    }
  };
}), xI = re((t, e) => {
  var r = Er();
  e.exports = class extends r {
    constructor(i) {
      super(i), this.type = "value", this.unbalanced = 0;
    }
  };
}), DI = re((t, e) => {
  var r = Er(), i = class extends r {
    constructor(n) {
      super(n), this.type = "atword";
    }
    toString() {
      return this.quoted && this.raws.quote, [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
    }
  };
  r.registerWalker(i), e.exports = i;
}), bI = re((t, e) => {
  var r = Er(), i = Ii(), n = class extends i {
    constructor(s) {
      super(s), this.type = "colon";
    }
  };
  r.registerWalker(n), e.exports = n;
}), vI = re((t, e) => {
  var r = Er(), i = Ii(), n = class extends i {
    constructor(s) {
      super(s), this.type = "comma";
    }
  };
  r.registerWalker(n), e.exports = n;
}), wI = re((t, e) => {
  var r = Er(), i = Ii(), n = class extends i {
    constructor(s) {
      super(s), this.type = "comment", this.inline = Object(s).inline || !1;
    }
    toString() {
      return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
    }
  };
  r.registerWalker(n), e.exports = n;
}), SI = re((t, e) => {
  var r = Er(), i = class extends r {
    constructor(n) {
      super(n), this.type = "func", this.unbalanced = -1;
    }
  };
  r.registerWalker(i), e.exports = i;
}), CI = re((t, e) => {
  var r = Er(), i = Ii(), n = class extends i {
    constructor(s) {
      super(s), this.type = "number", this.unit = Object(s).unit || "";
    }
    toString() {
      return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
    }
  };
  r.registerWalker(n), e.exports = n;
}), EI = re((t, e) => {
  var r = Er(), i = Ii(), n = class extends i {
    constructor(s) {
      super(s), this.type = "operator";
    }
  };
  r.registerWalker(n), e.exports = n;
}), AI = re((t, e) => {
  var r = Er(), i = Ii(), n = class extends i {
    constructor(s) {
      super(s), this.type = "paren", this.parenType = "";
    }
  };
  r.registerWalker(n), e.exports = n;
}), kI = re((t, e) => {
  var r = Er(), i = Ii(), n = class extends i {
    constructor(s) {
      super(s), this.type = "string";
    }
    toString() {
      let s = this.quoted ? this.raws.quote : "";
      return [this.raws.before, s, this.value + "", s, this.raws.after].join("");
    }
  };
  r.registerWalker(n), e.exports = n;
}), TI = re((t, e) => {
  var r = Er(), i = Ii(), n = class extends i {
    constructor(s) {
      super(s), this.type = "word";
    }
  };
  r.registerWalker(n), e.exports = n;
}), PI = re((t, e) => {
  var r = Er(), i = Ii(), n = class extends i {
    constructor(s) {
      super(s), this.type = "unicode-range";
    }
  };
  r.registerWalker(n), e.exports = n;
}), FI = re((t, e) => {
  var r = class extends Error {
    constructor(i) {
      super(i), this.name = this.constructor.name, this.message = i || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(i).stack;
    }
  };
  e.exports = r;
}), $I = re((t, e) => {
  var r = /[ \n\t\r\{\(\)'"\\;,/]/g, i = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, n = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, s = /^[a-z0-9]/i, a = /^[a-f0-9?\-]/i, l = FI();
  e.exports = function(u, h) {
    h = h || {};
    let p = [], d = u.valueOf(), m = d.length, y = -1, O = 1, D = 0, v = 0, w = null, x, S, k, C, A, P, I, B, _, R, G;
    function J(Q) {
      let q = `Unclosed ${Q} at line: ${O}, column: ${D - y}, token: ${D}`;
      throw new l(q);
    }
    for (; D < m; ) {
      switch (x = d.charCodeAt(D), x === 10 && (y = D, O += 1), x) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12:
          S = D;
          do
            S += 1, x = d.charCodeAt(S), x === 10 && (y = S, O += 1);
          while (x === 32 || x === 10 || x === 9 || x === 13 || x === 12);
          p.push(["space", d.slice(D, S), O, D - y, O, S - y, D]), D = S - 1;
          break;
        case 58:
          S = D + 1, p.push(["colon", d.slice(D, S), O, D - y, O, S - y, D]), D = S - 1;
          break;
        case 44:
          S = D + 1, p.push(["comma", d.slice(D, S), O, D - y, O, S - y, D]), D = S - 1;
          break;
        case 123:
          p.push(["{", "{", O, D - y, O, S - y, D]);
          break;
        case 125:
          p.push(["}", "}", O, D - y, O, S - y, D]);
          break;
        case 40:
          v++, w = !w && v === 1 && p.length > 0 && p[p.length - 1][0] === "word" && p[p.length - 1][1] === "url", p.push(["(", "(", O, D - y, O, S - y, D]);
          break;
        case 41:
          v--, w = w && v > 0, p.push([")", ")", O, D - y, O, S - y, D]);
          break;
        case 39:
        case 34:
          k = x === 39 ? "'" : '"', S = D;
          do
            for (_ = !1, S = d.indexOf(k, S + 1), S === -1 && J("quote"), R = S; d.charCodeAt(R - 1) === 92; )
              R -= 1, _ = !_;
          while (_);
          p.push(["string", d.slice(D, S + 1), O, D - y, O, S - y, D]), D = S;
          break;
        case 64:
          r.lastIndex = D + 1, r.test(d), r.lastIndex === 0 ? S = d.length - 1 : S = r.lastIndex - 2, p.push(["atword", d.slice(D, S + 1), O, D - y, O, S - y, D]), D = S;
          break;
        case 92:
          S = D, x = d.charCodeAt(S + 1), p.push(["word", d.slice(D, S + 1), O, D - y, O, S - y, D]), D = S;
          break;
        case 43:
        case 45:
        case 42:
          if (S = D + 1, G = d.slice(D + 1, S + 1), d.slice(D - 1, D), x === 45 && G.charCodeAt(0) === 45) {
            S++, p.push(["word", d.slice(D, S), O, D - y, O, S - y, D]), D = S - 1;
            break;
          }
          p.push(["operator", d.slice(D, S), O, D - y, O, S - y, D]), D = S - 1;
          break;
        default:
          if (x === 47 && (d.charCodeAt(D + 1) === 42 || h.loose && !w && d.charCodeAt(D + 1) === 47)) {
            if (d.charCodeAt(D + 1) === 42)
              S = d.indexOf("*/", D + 2) + 1, S === 0 && J("comment");
            else {
              let Q = d.indexOf(`
`, D + 2);
              S = Q !== -1 ? Q - 1 : m;
            }
            P = d.slice(D, S + 1), C = P.split(`
`), A = C.length - 1, A > 0 ? (I = O + A, B = S - C[A].length) : (I = O, B = y), p.push(["comment", P, O, D - y, I, S - B, D]), y = B, O = I, D = S;
          } else if (x === 35 && !s.test(d.slice(D + 1, D + 2)))
            S = D + 1, p.push(["#", d.slice(D, S), O, D - y, O, S - y, D]), D = S - 1;
          else if ((x === 117 || x === 85) && d.charCodeAt(D + 1) === 43) {
            S = D + 2;
            do
              S += 1, x = d.charCodeAt(S);
            while (S < m && a.test(d.slice(S, S + 1)));
            p.push(["unicoderange", d.slice(D, S), O, D - y, O, S - y, D]), D = S - 1;
          } else if (x === 47)
            S = D + 1, p.push(["operator", d.slice(D, S), O, D - y, O, S - y, D]), D = S - 1;
          else {
            let Q = i;
            if (x >= 48 && x <= 57 && (Q = n), Q.lastIndex = D + 1, Q.test(d), Q.lastIndex === 0 ? S = d.length - 1 : S = Q.lastIndex - 2, Q === n || x === 46) {
              let q = d.charCodeAt(S), X = d.charCodeAt(S + 1), K = d.charCodeAt(S + 2);
              (q === 101 || q === 69) && (X === 45 || X === 43) && K >= 48 && K <= 57 && (n.lastIndex = S + 2, n.test(d), n.lastIndex === 0 ? S = d.length - 1 : S = n.lastIndex - 2);
            }
            p.push(["word", d.slice(D, S + 1), O, D - y, O, S - y, D]), D = S;
          }
          break;
      }
      D++;
    }
    return p;
  };
}), BI = re((t, e) => {
  var r = class extends Error {
    constructor(i) {
      super(i), this.name = this.constructor.name, this.message = i || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(i).stack;
    }
  };
  e.exports = r;
}), II = re((t, e) => {
  var r = OI(), i = xI(), n = DI(), s = bI(), a = vI(), l = wI(), u = SI(), h = CI(), p = EI(), d = AI(), m = kI(), y = TI(), O = PI(), D = $I(), v = v2(), w = w2(), x = S2(), S = BI();
  function k(C) {
    return C.sort((A, P) => A - P);
  }
  e.exports = class {
    constructor(C, A) {
      let P = { loose: !1 };
      this.cache = [], this.input = C, this.options = Object.assign({}, P, A), this.position = 0, this.unbalanced = 0, this.root = new r();
      let I = new i();
      this.root.append(I), this.current = I, this.tokens = D(C, this.options);
    }
    parse() {
      return this.loop();
    }
    colon() {
      let C = this.currToken;
      this.newNode(new s({ value: C[1], source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6] })), this.position++;
    }
    comma() {
      let C = this.currToken;
      this.newNode(new a({ value: C[1], source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6] })), this.position++;
    }
    comment() {
      let C = !1, A = this.currToken[1].replace(/\/\*|\*\//g, ""), P;
      this.options.loose && A.startsWith("//") && (A = A.substring(2), C = !0), P = new l({ value: A, inline: C, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] }), this.newNode(P), this.position++;
    }
    error(C, A) {
      throw new S(C + ` at line: ${A[2]}, column ${A[3]}`);
    }
    loop() {
      for (; this.position < this.tokens.length; )
        this.parseTokens();
      return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
    }
    operator() {
      let C = this.currToken[1], A;
      if (C === "+" || C === "-") {
        if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? this.prevToken[0] !== "space" && this.prevToken[0] !== "(" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "word" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(" && this.error("Syntax Error", this.currToken) : (this.nextToken[0] === "space" || this.nextToken[0] === "operator" || this.prevToken[0] === "operator") && this.error("Syntax Error", this.currToken)), this.options.loose) {
          if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word")
            return this.word();
        } else if (this.nextToken[0] === "word")
          return this.word();
      }
      return A = new p({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), this.position++, this.newNode(A);
    }
    parseTokens() {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "colon":
          this.colon();
          break;
        case "comma":
          this.comma();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parenOpen();
          break;
        case ")":
          this.parenClose();
          break;
        case "atword":
        case "word":
          this.word();
          break;
        case "operator":
          this.operator();
          break;
        case "string":
          this.string();
          break;
        case "unicoderange":
          this.unicodeRange();
          break;
        default:
          this.word();
          break;
      }
    }
    parenOpen() {
      let C = 1, A = this.position + 1, P = this.currToken, I;
      for (; A < this.tokens.length && C; ) {
        let B = this.tokens[A];
        B[0] === "(" && C++, B[0] === ")" && C--, A++;
      }
      if (C && this.error("Expected closing parenthesis", P), I = this.current.last, I && I.type === "func" && I.unbalanced < 0 && (I.unbalanced = 0, this.current = I), this.current.unbalanced++, this.newNode(new d({ value: P[1], source: { start: { line: P[2], column: P[3] }, end: { line: P[4], column: P[5] } }, sourceIndex: P[6] })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
        let B = this.nextToken, _ = this.currToken[1], R = { line: this.currToken[2], column: this.currToken[3] };
        for (; B && B[0] !== ")" && this.current.unbalanced; )
          this.position++, _ += this.currToken[1], B = this.nextToken;
        this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new y({ value: _, source: { start: R, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
      }
    }
    parenClose() {
      let C = this.currToken;
      this.newNode(new d({ value: C[1], source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6] })), this.position++, !(this.position >= this.tokens.length - 1 && !this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", C), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
    }
    space() {
      let C = this.currToken;
      this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += C[1], this.position++) : (this.spaces = C[1], this.position++);
    }
    unicodeRange() {
      let C = this.currToken;
      this.newNode(new O({ value: C[1], source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6] })), this.position++;
    }
    splitWord() {
      let C = this.nextToken, A = this.currToken[1], P = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/, I = /^(?!\#([a-z0-9]+))[\#\{\}]/gi, B, _;
      if (!I.test(A))
        for (; C && C[0] === "word"; ) {
          this.position++;
          let R = this.currToken[1];
          A += R, C = this.nextToken;
        }
      B = w(A, "@"), _ = k(x(v([[0], B]))), _.forEach((R, G) => {
        let J = _[G + 1] || A.length, Q = A.slice(R, J), q;
        if (~B.indexOf(R))
          q = new n({ value: Q.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + R }, end: { line: this.currToken[4], column: this.currToken[3] + (J - 1) } }, sourceIndex: this.currToken[6] + _[G] });
        else if (P.test(this.currToken[1])) {
          let X = Q.replace(P, "");
          q = new h({ value: Q.replace(X, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + R }, end: { line: this.currToken[4], column: this.currToken[3] + (J - 1) } }, sourceIndex: this.currToken[6] + _[G], unit: X });
        } else
          q = new (C && C[0] === "(" ? u : y)({ value: Q, source: { start: { line: this.currToken[2], column: this.currToken[3] + R }, end: { line: this.currToken[4], column: this.currToken[3] + (J - 1) } }, sourceIndex: this.currToken[6] + _[G] }), q.type === "word" ? (q.isHex = /^#(.+)/.test(Q), q.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(Q)) : this.cache.push(this.current);
        this.newNode(q);
      }), this.position++;
    }
    string() {
      let C = this.currToken, A = this.currToken[1], P = /^(\"|\')/, I = P.test(A), B = "", _;
      I && (B = A.match(P)[0], A = A.slice(1, A.length - 1)), _ = new m({ value: A, source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6], quoted: I }), _.raws.quote = B, this.newNode(_), this.position++;
    }
    word() {
      return this.splitWord();
    }
    newNode(C) {
      return this.spaces && (C.raws.before += this.spaces, this.spaces = ""), this.current.append(C);
    }
    get currToken() {
      return this.tokens[this.position];
    }
    get nextToken() {
      return this.tokens[this.position + 1];
    }
    get prevToken() {
      return this.tokens[this.position - 1];
    }
  };
}), C2 = {};
u2(C2, { languages: () => E5, options: () => T5, parsers: () => tb, printers: () => u7 });
var NI = (t, e, r, i) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, i) : r.global ? e.replace(r, i) : e.split(r).join(i);
}, kt = NI, E2 = "string", A2 = "array", k2 = "cursor", Wm = "indent", qm = "align", T2 = "trim", Xm = "group", Yo = "fill", vh = "if-break", P2 = "indent-if-break", F2 = "line-suffix", $2 = "line-suffix-boundary", La = "line", B2 = "label", Vm = "break-parent", I2 = /* @__PURE__ */ new Set([k2, Wm, qm, T2, Xm, Yo, vh, P2, F2, $2, La, B2, Vm]);
function _I(t) {
  if (typeof t == "string")
    return E2;
  if (Array.isArray(t))
    return A2;
  if (!t)
    return;
  let { type: e } = t;
  if (I2.has(e))
    return e;
}
var N2 = _I, MI = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function LI(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (N2(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let i = MI([...I2].map((n) => `'${n}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${i}.`;
}
var QI = class extends Error {
  constructor(r) {
    super(LI(r));
    Ur(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, jI = QI, RI = () => {
}, ZI = RI;
function dr(t) {
  return { type: Wm, contents: t };
}
function _2(t, e) {
  return { type: qm, contents: e, n: t };
}
function $r(t, e = {}) {
  return ZI(e.expandedStates), { type: Xm, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function WI(t) {
  return _2({ type: "root" }, t);
}
function hc(t) {
  return _2(-1, t);
}
function Cd(t) {
  return { type: Yo, parts: t };
}
function M2(t, e = "", r = {}) {
  return { type: vh, breakContents: t, flatContents: e, groupId: r.groupId };
}
var Um = { type: Vm }, qI = { type: La, hard: !0 }, Vt = { type: La }, Gr = { type: La, soft: !0 }, ot = [qI, Um];
function as(t, e) {
  let r = [];
  for (let i = 0; i < e.length; i++)
    i !== 0 && r.push(t), r.push(e[i]);
  return r;
}
var XI = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, zo = XI, VI = (t) => {
  if (Array.isArray(t))
    return t;
  if (t.type !== Yo)
    throw new Error(`Expect doc to be 'array' or '${Yo}'.`);
  return t.parts;
};
function UI(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return i(t);
  function i(s) {
    if (r.has(s))
      return r.get(s);
    let a = n(s);
    return r.set(s, a), a;
  }
  function n(s) {
    switch (N2(s)) {
      case A2:
        return e(s.map(i));
      case Yo:
        return e({ ...s, parts: s.parts.map(i) });
      case vh:
        return e({ ...s, breakContents: i(s.breakContents), flatContents: i(s.flatContents) });
      case Xm: {
        let { expandedStates: a, contents: l } = s;
        return a ? (a = a.map(i), l = a[0]) : l = i(l), e({ ...s, contents: l, expandedStates: a });
      }
      case qm:
      case Wm:
      case P2:
      case B2:
      case F2:
        return e({ ...s, contents: i(s.contents) });
      case E2:
      case k2:
      case T2:
      case $2:
      case La:
      case Vm:
        return e(s);
      default:
        throw new jI(s);
    }
  }
}
function YI(t) {
  return t.type === La && !t.hard ? t.soft ? "" : " " : t.type === vh ? t.flatContents : t;
}
function zI(t) {
  return UI(t, YI);
}
function GI(t) {
  return Array.isArray(t) && t.length > 0;
}
var wh = GI, au = "'", N0 = '"';
function HI(t, e) {
  let r = e === !0 || e === au ? au : N0, i = r === au ? N0 : au, n = 0, s = 0;
  for (let a of t)
    a === r ? n++ : a === i && s++;
  return n > s ? i : r;
}
var JI = HI;
function KI(t, e, r) {
  let i = e === '"' ? "'" : '"', n = kt(!1, t, /\\(.)|(["'])/gs, (s, a, l) => a === i ? a : l === e ? "\\" + l : l || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(a) ? a : "\\" + a));
  return e + n + e;
}
var eN = KI;
function tN(t, e) {
  let r = t.slice(1, -1), i = e.parser === "json" || e.parser === "jsonc" || e.parser === "json5" && e.quoteProps === "preserve" && !e.singleQuote ? '"' : e.__isInHtmlAttribute ? "'" : JI(r, e.singleQuote);
  return eN(r, i, !(e.parser === "css" || e.parser === "less" || e.parser === "scss" || e.__embeddedInHtml));
}
var L2 = tN, rN = class extends Error {
  constructor(r, i, n = "type") {
    super(`Unexpected ${i} node ${n}: ${JSON.stringify(r[n])}.`);
    Ur(this, "name", "UnexpectedNodeError");
    this.node = r;
  }
}, iN = rN;
function nN(t) {
  return (t == null ? void 0 : t.type) === "front-matter";
}
var pc = nN, sN = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma", "spaces"]);
function Q2(t, e, r) {
  if (pc(t) && t.lang === "yaml" && delete e.value, t.type === "css-comment" && r.type === "css-root" && r.nodes.length > 0 && ((r.nodes[0] === t || pc(r.nodes[0]) && r.nodes[1] === t) && (delete e.text, /^\*\s*@(?:format|prettier)\s*$/.test(t.text)) || r.type === "css-root" && zo(!1, r.nodes, -1) === t))
    return null;
  if (t.type === "value-root" && delete e.text, (t.type === "media-query" || t.type === "media-query-list" || t.type === "media-feature-expression") && delete e.value, t.type === "css-rule" && delete e.params, t.type === "selector-combinator" && (e.value = kt(!1, e.value, /\s+/g, " ")), t.type === "media-feature" && (e.value = kt(!1, e.value, " ", "")), (t.type === "value-word" && (t.isColor && t.isHex || ["initial", "inherit", "unset", "revert"].includes(e.value.toLowerCase())) || t.type === "media-feature" || t.type === "selector-root-invalid" || t.type === "selector-pseudo") && (e.value = e.value.toLowerCase()), t.type === "css-decl" && (e.prop = e.prop.toLowerCase()), (t.type === "css-atrule" || t.type === "css-import") && (e.name = e.name.toLowerCase()), t.type === "value-number" && (e.unit = e.unit.toLowerCase()), t.type === "value-unknown" && (e.value = kt(!1, e.value, /;$/g, "")), (t.type === "media-feature" || t.type === "media-keyword" || t.type === "media-type" || t.type === "media-unknown" || t.type === "media-url" || t.type === "media-value" || t.type === "selector-attribute" || t.type === "selector-string" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "value-string") && e.value && (e.value = aN(e.value)), t.type === "selector-attribute" && (e.attribute = e.attribute.trim(), e.namespace && typeof e.namespace == "string" && (e.namespace = e.namespace.trim(), e.namespace.length === 0 && (e.namespace = !0)), e.value && (e.value = kt(!1, e.value.trim(), /^["']|["']$/g, ""), delete e.quoted)), (t.type === "media-value" || t.type === "media-type" || t.type === "value-number" || t.type === "selector-root-invalid" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "selector-tag") && e.value && (e.value = kt(!1, e.value, /([\d+.e-]+)([a-z]*)/gi, (i, n, s) => {
    let a = Number(n);
    return Number.isNaN(a) ? i : a + s.toLowerCase();
  })), t.type === "selector-tag") {
    let i = t.value.toLowerCase();
    ["from", "to"].includes(i) && (e.value = i);
  }
  if (t.type === "css-atrule" && t.name.toLowerCase() === "supports" && delete e.value, t.type === "selector-unknown" && delete e.value, t.type === "value-comma_group") {
    let i = t.groups.findIndex((n) => n.type === "value-number" && n.unit === "...");
    i !== -1 && (e.groups[i].unit = "", e.groups.splice(i + 1, 0, { type: "value-word", value: "...", isColor: !1, isHex: !1 }));
  }
  if (t.type === "value-comma_group" && t.groups.some((i) => i.type === "value-atword" && i.value.endsWith("[") || i.type === "value-word" && i.value.startsWith("]")))
    return { type: "value-atword", value: t.groups.map((i) => i.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
}
Q2.ignoredProperties = sN;
function aN(t) {
  return kt(!1, kt(!1, t, "'", '"'), /\\([^\da-f])/gi, "$1");
}
var oN = Q2;
async function lN(t, e) {
  if (t.lang === "yaml") {
    let r = t.value.trim(), i = r ? await e(r, { parser: "yaml" }) : "";
    return WI([t.startDelimiter, ot, i, i ? ot : "", t.endDelimiter]);
  }
}
var uN = lN;
function j2(t) {
  let { node: e } = t;
  if (e.type === "front-matter")
    return async (r) => {
      let i = await uN(e, r);
      return i ? [i, ot] : void 0;
    };
}
j2.getVisitorKeys = (t) => t.type === "css-root" ? ["frontMatter"] : [];
var cN = j2, ao = null;
function Io(t) {
  if (ao !== null && typeof ao.property) {
    let e = ao;
    return ao = Io.prototype = null, e;
  }
  return ao = Io.prototype = t ?? /* @__PURE__ */ Object.create(null), new Io();
}
var hN = 10;
for (let t = 0; t <= hN; t++)
  Io();
function pN(t) {
  return Io(t);
}
function dN(t, e = "type") {
  pN(t);
  function r(i) {
    let n = i[e], s = t[n];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: i });
    return s;
  }
  return r;
}
var fN = dN, mN = { "front-matter": [], "css-root": ["frontMatter", "nodes"], "css-comment": [], "css-rule": ["selector", "nodes"], "css-decl": ["value", "selector", "nodes"], "css-atrule": ["selector", "params", "value", "nodes"], "media-query-list": ["nodes"], "media-query": ["nodes"], "media-type": [], "media-feature-expression": ["nodes"], "media-feature": [], "media-colon": [], "media-value": [], "media-keyword": [], "media-url": [], "media-unknown": [], "selector-root": ["nodes"], "selector-selector": ["nodes"], "selector-comment": [], "selector-string": [], "selector-tag": [], "selector-id": [], "selector-class": [], "selector-attribute": [], "selector-combinator": ["nodes"], "selector-universal": [], "selector-pseudo": ["nodes"], "selector-nesting": [], "selector-unknown": [], "value-value": ["group"], "value-root": ["group"], "value-comment": [], "value-comma_group": ["groups"], "value-paren_group": ["open", "groups", "close"], "value-func": ["group"], "value-paren": [], "value-number": [], "value-operator": [], "value-word": [], "value-colon": [], "value-comma": [], "value-string": [], "value-atword": [], "value-unicode-range": [], "value-unknown": [] }, gN = mN, yN = fN(gN), ON = yN;
function xN(t, e) {
  let r = 0;
  for (let i = 0; i < t.line - 1; ++i)
    r = e.indexOf(`
`, r) + 1;
  return r + t.column;
}
var R2 = xN;
function Ym(t) {
  return (e, r, i) => {
    let n = !!(i != null && i.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, a = r;
    for (; a >= 0 && a < s; ) {
      let l = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(l))
          return a;
      } else if (!t.includes(l))
        return a;
      n ? a-- : a++;
    }
    return a === -1 || a === s ? a : !1;
  };
}
var Z2 = Ym(" 	"), DN = Ym(",; 	"), W2 = Ym(/[^\n\r]/);
function q2(t, e) {
  var r, i, n;
  if (typeof ((i = (r = t.source) == null ? void 0 : r.start) == null ? void 0 : i.offset) == "number")
    return t.source.start.offset;
  if (typeof t.sourceIndex == "number")
    return t.sourceIndex;
  if ((n = t.source) != null && n.start)
    return R2(t.source.start, e);
  throw Object.assign(new Error("Can not locate node."), { node: t });
}
function zm(t, e) {
  var r, i;
  if (t.type === "css-comment" && t.inline)
    return W2(e, t.source.startOffset);
  if (typeof ((i = (r = t.source) == null ? void 0 : r.end) == null ? void 0 : i.offset) == "number")
    return t.source.end.offset;
  if (t.source) {
    if (t.source.end)
      return R2(t.source.end, e);
    if (wh(t.nodes))
      return zm(zo(!1, t.nodes, -1), e);
  }
  return null;
}
function X2(t, e) {
  t.source && (t.source.startOffset = q2(t, e), t.source.endOffset = zm(t, e));
  for (let r in t) {
    let i = t[r];
    r === "source" || !i || typeof i != "object" || (i.type === "value-root" || i.type === "value-unknown" ? V2(i, bN(t), i.text || i.value) : X2(i, e));
  }
}
function V2(t, e, r) {
  t.source && (t.source.startOffset = q2(t, r) + e, t.source.endOffset = zm(t, r) + e);
  for (let i in t) {
    let n = t[i];
    i === "source" || !n || typeof n != "object" || V2(n, e, r);
  }
}
function bN(t) {
  var e;
  let r = t.source.startOffset;
  return typeof t.prop == "string" && (r += t.prop.length), t.type === "css-atrule" && typeof t.name == "string" && (r += 1 + t.name.length + t.raws.afterName.match(/^\s*:?\s*/)[0].length), t.type !== "css-atrule" && typeof ((e = t.raws) == null ? void 0 : e.between) == "string" && (r += t.raws.between.length), r;
}
function vN(t) {
  let e = "initial", r = "initial", i, n = !1, s = [];
  for (let a = 0; a < t.length; a++) {
    let l = t[a];
    switch (e) {
      case "initial":
        if (l === "'") {
          e = "single-quotes";
          continue;
        }
        if (l === '"') {
          e = "double-quotes";
          continue;
        }
        if ((l === "u" || l === "U") && t.slice(a, a + 4).toLowerCase() === "url(") {
          e = "url", a += 3;
          continue;
        }
        if (l === "*" && t[a - 1] === "/") {
          e = "comment-block";
          continue;
        }
        if (l === "/" && t[a - 1] === "/") {
          e = "comment-inline", i = a - 1;
          continue;
        }
        continue;
      case "single-quotes":
        if (l === "'" && t[a - 1] !== "\\" && (e = r, r = "initial"), l === `
` || l === "\r")
          return t;
        continue;
      case "double-quotes":
        if (l === '"' && t[a - 1] !== "\\" && (e = r, r = "initial"), l === `
` || l === "\r")
          return t;
        continue;
      case "url":
        if (l === ")" && (e = "initial"), l === `
` || l === "\r")
          return t;
        if (l === "'") {
          e = "single-quotes", r = "url";
          continue;
        }
        if (l === '"') {
          e = "double-quotes", r = "url";
          continue;
        }
        continue;
      case "comment-block":
        l === "/" && t[a - 1] === "*" && (e = "initial");
        continue;
      case "comment-inline":
        (l === '"' || l === "'" || l === "*") && (n = !0), (l === `
` || l === "\r") && (n && s.push([i, a]), e = "initial", n = !1);
        continue;
    }
  }
  for (let [a, l] of s)
    t = t.slice(0, a) + kt(!1, t.slice(a, l), /["'*]/g, " ") + t.slice(l);
  return t;
}
function Or(t) {
  var e;
  return (e = t.source) == null ? void 0 : e.startOffset;
}
function gr(t) {
  var e;
  return (e = t.source) == null ? void 0 : e.endOffset;
}
var dc = Fs(N8(), 1);
function wN(t) {
  if (!t.startsWith("#!"))
    return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var SN = wN;
function U2(t) {
  let e = SN(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, dc.extract)(t), { pragmas: i, comments: n } = (0, dc.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: i, comments: n };
}
function CN(t) {
  let { pragmas: e } = U2(t);
  return Object.prototype.hasOwnProperty.call(e, "prettier") || Object.prototype.hasOwnProperty.call(e, "format");
}
function EN(t) {
  let { shebang: e, text: r, pragmas: i, comments: n } = U2(t), s = (0, dc.strip)(r), a = (0, dc.print)({ pragmas: { format: "", ...i }, comments: n.trimStart() });
  return (e ? `${e}
` : "") + a + (s.startsWith(`
`) ? `
` : `

`) + s;
}
var AN = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
function kN(t) {
  let e = t.match(AN);
  if (!e)
    return { content: t };
  let { startDelimiter: r, language: i, value: n = "", endDelimiter: s } = e.groups, a = i.trim() || "yaml";
  if (r === "+++" && (a = "toml"), a !== "yaml" && r !== s)
    return { content: t };
  let [l] = e;
  return { frontMatter: { type: "front-matter", lang: a, value: n, startDelimiter: r, endDelimiter: s, raw: l.replace(/\n$/, "") }, content: kt(!1, l, /[^\n]/g, " ") + t.slice(l.length) };
}
var Gm = kN;
function TN(t) {
  return CN(Gm(t).content);
}
function PN(t) {
  let { frontMatter: e, content: r } = Gm(t);
  return (e ? e.raw + `

` : "") + EN(r);
}
var FN = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
function $N(t) {
  var e, r;
  return (r = (e = t.findAncestor((i) => i.type === "css-decl")) == null ? void 0 : e.prop) == null ? void 0 : r.toLowerCase();
}
var BN = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
function IN(t) {
  return BN.has(t.toLowerCase());
}
function NN(t, e) {
  var r;
  let i = t.findAncestor((n) => n.type === "css-atrule");
  return ((r = i == null ? void 0 : i.name) == null ? void 0 : r.toLowerCase().endsWith("keyframes")) && ["from", "to"].includes(e.toLowerCase());
}
function Ks(t) {
  return t.includes("$") || t.includes("@") || t.includes("#") || t.startsWith("%") || t.startsWith("--") || t.startsWith(":--") || t.includes("(") && t.includes(")") ? t : t.toLowerCase();
}
function Wu(t, e) {
  var r;
  let i = t.findAncestor((n) => n.type === "value-func");
  return ((r = i == null ? void 0 : i.value) == null ? void 0 : r.toLowerCase()) === e;
}
function _N(t) {
  var e;
  let r = t.findAncestor((n) => n.type === "css-rule"), i = (e = r == null ? void 0 : r.raws) == null ? void 0 : e.selector;
  return i && (i.startsWith(":import") || i.startsWith(":export"));
}
function qu(t, e) {
  let r = Array.isArray(e) ? e : [e], i = t.findAncestor((n) => n.type === "css-atrule");
  return i && r.includes(i.name.toLowerCase());
}
function MN(t) {
  var e;
  let { node: r } = t;
  return r.groups[0].value === "url" && r.groups.length === 2 && ((e = t.findAncestor((i) => i.type === "css-atrule")) == null ? void 0 : e.name) === "import";
}
function LN(t) {
  return t.type === "value-func" && t.value.toLowerCase() === "url";
}
function QN(t) {
  return t.type === "value-func" && t.value.toLowerCase() === "var";
}
function Op(t, e) {
  var r;
  let i = (r = t.parent) == null ? void 0 : r.nodes;
  return i && i.indexOf(e) === i.length - 1;
}
function jN(t) {
  let { selector: e } = t;
  return e ? typeof e == "string" && /^@.+:.*$/.test(e) || e.value && /^@.+:.*$/.test(e.value) : !1;
}
function RN(t) {
  return t.type === "value-word" && ["from", "through", "end"].includes(t.value);
}
function ZN(t) {
  return t.type === "value-word" && ["and", "or", "not"].includes(t.value);
}
function WN(t) {
  return t.type === "value-word" && t.value === "in";
}
function Ed(t) {
  return t.type === "value-operator" && t.value === "*";
}
function Xu(t) {
  return t.type === "value-operator" && t.value === "/";
}
function yn(t) {
  return t.type === "value-operator" && t.value === "+";
}
function ea(t) {
  return t.type === "value-operator" && t.value === "-";
}
function qN(t) {
  return t.type === "value-operator" && t.value === "%";
}
function xp(t) {
  return Ed(t) || Xu(t) || yn(t) || ea(t) || qN(t);
}
function XN(t) {
  return t.type === "value-word" && ["==", "!="].includes(t.value);
}
function VN(t) {
  return t.type === "value-word" && ["<", ">", "<=", ">="].includes(t.value);
}
function Ad(t, e) {
  return e.parser === "scss" && t.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(t.name);
}
function _0(t) {
  var e;
  return ((e = t.raws) == null ? void 0 : e.params) && /^\(\s*\)$/.test(t.raws.params);
}
function Dp(t) {
  return t.name.startsWith("prettier-placeholder");
}
function UN(t) {
  return t.prop.startsWith("@prettier-placeholder");
}
function YN(t, e) {
  return t.value === "$$" && t.type === "value-func" && (e == null ? void 0 : e.type) === "value-word" && !e.raws.before;
}
function zN(t) {
  var e, r;
  return ((e = t.value) == null ? void 0 : e.type) === "value-root" && ((r = t.value.group) == null ? void 0 : r.type) === "value-value" && t.prop.toLowerCase() === "composes";
}
function GN(t) {
  var e, r, i;
  return ((i = (r = (e = t.value) == null ? void 0 : e.group) == null ? void 0 : r.group) == null ? void 0 : i.type) === "value-paren_group" && t.value.group.group.open !== null && t.value.group.group.close !== null;
}
function Ys(t) {
  var e;
  return ((e = t.raws) == null ? void 0 : e.before) === "";
}
function Hm(t) {
  var e, r;
  return t.type === "value-comma_group" && ((r = (e = t.groups) == null ? void 0 : e[1]) == null ? void 0 : r.type) === "value-colon";
}
function bp(t) {
  var e;
  return t.type === "value-paren_group" && ((e = t.groups) == null ? void 0 : e[0]) && Hm(t.groups[0]);
}
function Y2(t, e) {
  var r;
  if (e.parser !== "scss")
    return !1;
  let { node: i } = t;
  if (i.groups.length === 0)
    return !1;
  let n = t.grandparent;
  if (!bp(i) && !(n && bp(n)))
    return !1;
  let s = t.findAncestor((a) => a.type === "css-decl");
  return !!((r = s == null ? void 0 : s.prop) != null && r.startsWith("$") || bp(n) || n.type === "value-func");
}
function M0(t) {
  return t.type === "value-comment" && t.inline;
}
function vp(t) {
  return t.type === "value-word" && t.value === "#";
}
function L0(t) {
  return t.type === "value-word" && t.value === "{";
}
function wp(t) {
  return t.type === "value-word" && t.value === "}";
}
function ou(t) {
  return ["value-word", "value-atword"].includes(t.type);
}
function kd(t) {
  return (t == null ? void 0 : t.type) === "value-colon";
}
function HN(t, e) {
  if (!Hm(e))
    return !1;
  let { groups: r } = e, i = r.indexOf(t);
  return i === -1 ? !1 : kd(r[i + 1]);
}
function JN(t) {
  return t.value && ["not", "and", "or"].includes(t.value.toLowerCase());
}
function KN(t) {
  return t.type !== "value-func" ? !1 : FN.has(t.value.toLowerCase());
}
function oo(t) {
  return /\/\//.test(t.split(/[\n\r]/).pop());
}
function lu(t) {
  return (t == null ? void 0 : t.type) === "value-atword" && t.value.startsWith("prettier-placeholder-");
}
function e5(t, e) {
  var r, i;
  if (((r = t.open) == null ? void 0 : r.value) !== "(" || ((i = t.close) == null ? void 0 : i.value) !== ")" || t.groups.some((n) => n.type !== "value-comma_group"))
    return !1;
  if (e.type === "value-comma_group") {
    let n = e.groups.indexOf(t) - 1, s = e.groups[n];
    if ((s == null ? void 0 : s.type) === "value-word" && s.value === "with")
      return !0;
  }
  return !1;
}
function uu(t) {
  var e, r;
  return t.type === "value-paren_group" && ((e = t.open) == null ? void 0 : e.value) === "(" && ((r = t.close) == null ? void 0 : r.value) === ")";
}
function t5(t, e, r) {
  var i;
  let { node: n } = t, s = t.parent, a = t.grandparent, l = $N(t), u = l && s.type === "value-value" && (l === "grid" || l.startsWith("grid-template")), h = t.findAncestor((w) => w.type === "css-atrule"), p = h && Ad(h, e), d = n.groups.some((w) => M0(w)), m = t.map(r, "groups"), y = [], O = Wu(t, "url"), D = !1, v = !1;
  for (let w = 0; w < n.groups.length; ++w) {
    y.push(m[w]);
    let x = n.groups[w - 1], S = n.groups[w], k = n.groups[w + 1], C = n.groups[w + 2];
    if (O) {
      (k && yn(k) || yn(S)) && y.push(" ");
      continue;
    }
    if (qu(t, "forward") && S.type === "value-word" && S.value && x !== void 0 && x.type === "value-word" && x.value === "as" && k.type === "value-operator" && k.value === "*" || !k || S.type === "value-word" && S.value.endsWith("-") && lu(k))
      continue;
    if (S.type === "value-string" && S.quoted) {
      let R = S.value.lastIndexOf("#{"), G = S.value.lastIndexOf("}");
      R !== -1 && G !== -1 ? D = R > G : R !== -1 ? D = !0 : G !== -1 && (D = !1);
    }
    if (D || kd(S) || kd(k) || S.type === "value-atword" && (S.value === "" || S.value.endsWith("[")) || k.type === "value-word" && k.value.startsWith("]") || S.value === "~" || S.type !== "value-string" && S.value && S.value.includes("\\") && k && k.type !== "value-comment" || x != null && x.value && x.value.indexOf("\\") === x.value.length - 1 && S.type === "value-operator" && S.value === "/" || S.value === "\\" || YN(S, k) || vp(S) || L0(S) || wp(k) || L0(k) && Ys(k) || wp(S) && Ys(k) || S.value === "--" && vp(k))
      continue;
    let A = xp(S), P = xp(k);
    if ((A && vp(k) || P && wp(S)) && Ys(k) || !x && Xu(S) || Wu(t, "calc") && (yn(S) || yn(k) || ea(S) || ea(k)) && Ys(k))
      continue;
    let I = (yn(S) || ea(S)) && w === 0 && (k.type === "value-number" || k.isHex) && a && KN(a) && !Ys(k), B = (C == null ? void 0 : C.type) === "value-func" || C && ou(C) || S.type === "value-func" || ou(S), _ = k.type === "value-func" || ou(k) || (x == null ? void 0 : x.type) === "value-func" || x && ou(x);
    if (e.parser === "scss" && A && S.value === "-" && k.type === "value-func" && gr(S) !== Or(k)) {
      y.push(" ");
      continue;
    }
    if (!(!(Ed(k) || Ed(S)) && !Wu(t, "calc") && !I && (Xu(k) && !B || Xu(S) && !_ || yn(k) && !B || yn(S) && !_ || ea(k) || ea(S)) && (Ys(k) || A && (!x || x && xp(x)))) && !((e.parser === "scss" || e.parser === "less") && A && S.value === "-" && uu(k) && gr(S) === Or(k.open) && k.open.value === "(")) {
      if (M0(S)) {
        if (s.type === "value-paren_group") {
          y.push(hc(ot));
          continue;
        }
        y.push(ot);
        continue;
      }
      if (p && (XN(k) || VN(k) || ZN(k) || WN(S) || RN(S))) {
        y.push(" ");
        continue;
      }
      if (h && h.name.toLowerCase() === "namespace") {
        y.push(" ");
        continue;
      }
      if (u) {
        S.source && k.source && S.source.start.line !== k.source.start.line ? (y.push(ot), v = !0) : y.push(" ");
        continue;
      }
      if (P) {
        y.push(" ");
        continue;
      }
      if ((k == null ? void 0 : k.value) !== "..." && !(lu(S) && lu(k) && gr(S) === Or(k))) {
        if (lu(S) && uu(k) && gr(S) === Or(k.open)) {
          y.push(Gr);
          continue;
        }
        if (S.value === "with" && uu(k)) {
          y.push(" ");
          continue;
        }
        (i = S.value) != null && i.endsWith("#") && k.value === "{" && uu(k.group) || y.push(Vt);
      }
    }
  }
  return d && y.push(Um), v && y.unshift(ot), p ? $r(dr(y)) : MN(t) ? $r(Cd(y)) : $r(dr(Cd(y)));
}
var r5 = t5;
function i5(t) {
  return t.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
}
var n5 = i5, Q0 = /* @__PURE__ */ new Map([["em", "em"], ["rem", "rem"], ["ex", "ex"], ["rex", "rex"], ["cap", "cap"], ["rcap", "rcap"], ["ch", "ch"], ["rch", "rch"], ["ic", "ic"], ["ric", "ric"], ["lh", "lh"], ["rlh", "rlh"], ["vw", "vw"], ["svw", "svw"], ["lvw", "lvw"], ["dvw", "dvw"], ["vh", "vh"], ["svh", "svh"], ["lvh", "lvh"], ["dvh", "dvh"], ["vi", "vi"], ["svi", "svi"], ["lvi", "lvi"], ["dvi", "dvi"], ["vb", "vb"], ["svb", "svb"], ["lvb", "lvb"], ["dvb", "dvb"], ["vmin", "vmin"], ["svmin", "svmin"], ["lvmin", "lvmin"], ["dvmin", "dvmin"], ["vmax", "vmax"], ["svmax", "svmax"], ["lvmax", "lvmax"], ["dvmax", "dvmax"], ["cm", "cm"], ["mm", "mm"], ["q", "Q"], ["in", "in"], ["pt", "pt"], ["pc", "pc"], ["px", "px"], ["deg", "deg"], ["grad", "grad"], ["rad", "rad"], ["turn", "turn"], ["s", "s"], ["ms", "ms"], ["hz", "Hz"], ["khz", "kHz"], ["dpi", "dpi"], ["dpcm", "dpcm"], ["dppx", "dppx"], ["x", "x"], ["cqw", "cqw"], ["cqh", "cqh"], ["cqi", "cqi"], ["cqb", "cqb"], ["cqmin", "cqmin"], ["cqmax", "cqmax"]]);
function s5(t) {
  let e = t.toLowerCase();
  return Q0.has(e) ? Q0.get(e) : t;
}
var z2 = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, a5 = /(?:\d*\.\d+|\d+\.?)(?:e[+-]?\d+)?/gi, o5 = /[a-z]+/gi, l5 = /[$@]?[_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/gi, u5 = new RegExp(z2.source + `|(${l5.source})?(${a5.source})(${o5.source})?`, "gi");
function hi(t, e) {
  return kt(!1, t, z2, (r) => L2(r, e));
}
function c5(t, e) {
  let r = e.singleQuote ? "'" : '"';
  return t.includes('"') || t.includes("'") ? t : r + t + r;
}
function zs(t) {
  return kt(!1, t, u5, (e, r, i, n, s) => !i && n ? G2(n) + Ks(s || "") : e);
}
function G2(t) {
  return n5(t).replace(/\.0(?=$|e)/, "");
}
function h5(t) {
  return t.trailingComma === "es5" || t.trailingComma === "all";
}
function p5(t, e, r) {
  let i = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let n = t.charAt(e);
  if (i) {
    if (t.charAt(e - 1) === "\r" && n === `
`)
      return e - 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e - 1;
  } else {
    if (n === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e + 1;
  }
  return e;
}
var H2 = p5;
function d5(t, e, r = {}) {
  let i = Z2(t, r.backwards ? e - 1 : e, r), n = H2(t, i, r);
  return i !== n;
}
var J2 = d5;
function f5(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var m5 = f5;
function g5(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? W2(t, e) : e;
}
var y5 = g5;
function O5(t, e) {
  let r = null, i = e;
  for (; i !== r; )
    r = i, i = DN(t, i), i = m5(t, i), i = Z2(t, i);
  return i = y5(t, i), i = H2(t, i), i !== !1 && J2(t, i);
}
var K2 = O5;
function x5({ node: t, parent: e }, r) {
  return !!(t.source && r.originalText.slice(Or(t), Or(e.close)).trimEnd().endsWith(","));
}
function D5(t, e) {
  return QN(t.grandparent) && x5(t, e) ? "," : t.node.type !== "value-comment" && !(t.node.type === "value-comma_group" && t.node.groups.every((r) => r.type === "value-comment")) && h5(e) && t.callParent(() => Y2(t, e)) ? M2(",") : "";
}
function b5(t, e, r) {
  let { node: i, parent: n } = t, s = t.map(({ node: y }) => typeof y == "string" ? y : r(), "groups");
  if (n && LN(n) && (i.groups.length === 1 || i.groups.length > 0 && i.groups[0].type === "value-comma_group" && i.groups[0].groups.length > 0 && i.groups[0].groups[0].type === "value-word" && i.groups[0].groups[0].value.startsWith("data:")))
    return [i.open ? r("open") : "", as(",", s), i.close ? r("close") : ""];
  if (!i.open) {
    let y = eb(t), O = as([",", y ? ot : Vt], s);
    return dr(y ? [ot, O] : $r(Cd(O)));
  }
  let a = t.map(({ node: y, isLast: O, index: D }) => {
    var v;
    let w = s[D];
    if (Hm(y) && y.type === "value-comma_group" && y.groups && y.groups[0].type !== "value-paren_group" && ((v = y.groups[2]) == null ? void 0 : v.type) === "value-paren_group") {
      let S = VI(w.contents.contents);
      S[1] = $r(S[1]), w = $r(hc(w));
    }
    let x = [w, O ? D5(t, e) : ","];
    if (!O && y.type === "value-comma_group" && wh(y.groups)) {
      let S = zo(!1, y.groups, -1);
      !S.source && S.close && (S = S.close), S.source && K2(e.originalText, gr(S)) && x.push(ot);
    }
    return x;
  }, "groups"), l = HN(i, n), u = e5(i, n), h = Y2(t, e), p = u || h && !l, d = u || l, m = $r([i.open ? r("open") : "", dr([Gr, as(Vt, a)]), Gr, i.close ? r("close") : ""], { shouldBreak: p });
  return d ? hc(m) : m;
}
function eb(t) {
  return t.match((e) => e.type === "value-paren_group" && !e.open && e.groups.some((r) => r.type === "value-comma_group"), (e, r) => r === "group" && e.type === "value-value", (e, r) => r === "group" && e.type === "value-root", (e, r) => r === "value" && (e.type === "css-decl" && !e.prop.startsWith("--") || e.type === "css-atrule" && e.variable));
}
function v5(t, e, r) {
  let i = [];
  return t.each(() => {
    let { node: n, previous: s } = t;
    if ((s == null ? void 0 : s.type) === "css-comment" && s.text.trim() === "prettier-ignore" ? i.push(e.originalText.slice(Or(n), gr(n))) : i.push(r()), t.isLast)
      return;
    let { next: a } = t;
    a.type === "css-comment" && !J2(e.originalText, Or(a), { backwards: !0 }) && !pc(n) || a.type === "css-atrule" && a.name === "else" && n.type !== "css-comment" ? i.push(" ") : (i.push(e.__isHTMLStyleAttribute ? Vt : ot), K2(e.originalText, gr(n)) && !pc(n) && i.push(ot));
  }, "nodes"), i;
}
var lo = v5;
function w5(t, e, r) {
  var i, n, s, a, l, u;
  let { node: h } = t;
  switch (h.type) {
    case "front-matter":
      return [h.raw, ot];
    case "css-root": {
      let p = lo(t, e, r), d = h.raws.after.trim();
      return d.startsWith(";") && (d = d.slice(1).trim()), [h.frontMatter ? [r("frontMatter"), ot] : "", p, d ? ` ${d}` : "", h.nodes.length > 0 ? ot : ""];
    }
    case "css-comment": {
      let p = h.inline || h.raws.inline, d = e.originalText.slice(Or(h), gr(h));
      return p ? d.trimEnd() : d;
    }
    case "css-rule":
      return [r("selector"), h.important ? " !important" : "", h.nodes ? [((i = h.selector) == null ? void 0 : i.type) === "selector-unknown" && oo(h.selector.value) ? Vt : h.selector ? " " : "", "{", h.nodes.length > 0 ? dr([ot, lo(t, e, r)]) : "", ot, "}", jN(h) ? ";" : ""] : ";"];
    case "css-decl": {
      let p = t.parent, { between: d } = h.raws, m = d.trim(), y = m === ":", O = typeof h.value == "string" && /^ *$/.test(h.value), D = typeof h.value == "string" ? h.value : r("value");
      return D = zN(h) ? zI(D) : D, !y && oo(m) && !((s = (n = h.value) == null ? void 0 : n.group) != null && s.group && t.call(() => eb(t), "value", "group", "group")) && (D = dr([ot, hc(D)])), [kt(!1, h.raws.before, /[\s;]/g, ""), p.type === "css-atrule" && p.variable || _N(t) ? h.prop : Ks(h.prop), m.startsWith("//") ? " " : "", m, h.extend || O ? "" : " ", e.parser === "less" && h.extend && h.selector ? ["extend(", r("selector"), ")"] : "", D, h.raws.important ? h.raws.important.replace(/\s*!\s*important/i, " !important") : h.important ? " !important" : "", h.raws.scssDefault ? h.raws.scssDefault.replace(/\s*!default/i, " !default") : h.scssDefault ? " !default" : "", h.raws.scssGlobal ? h.raws.scssGlobal.replace(/\s*!global/i, " !global") : h.scssGlobal ? " !global" : "", h.nodes ? [" {", dr([Gr, lo(t, e, r)]), Gr, "}"] : UN(h) && !p.raws.semicolon && e.originalText[gr(h) - 1] !== ";" ? "" : e.__isHTMLStyleAttribute && Op(t, h) ? M2(";") : ";"];
    }
    case "css-atrule": {
      let p = t.parent, d = Dp(h) && !p.raws.semicolon && e.originalText[gr(h) - 1] !== ";";
      if (e.parser === "less") {
        if (h.mixin)
          return [r("selector"), h.important ? " !important" : "", d ? "" : ";"];
        if (h.function)
          return [h.name, typeof h.params == "string" ? h.params : r("params"), d ? "" : ";"];
        if (h.variable)
          return ["@", h.name, ": ", h.value ? r("value") : "", h.raws.between.trim() ? h.raws.between.trim() + " " : "", h.nodes ? ["{", dr([h.nodes.length > 0 ? Gr : "", lo(t, e, r)]), Gr, "}"] : "", d ? "" : ";"];
      }
      let m = h.name === "import" && ((a = h.params) == null ? void 0 : a.type) === "value-unknown" && h.params.value.endsWith(";");
      return ["@", _0(h) || h.name.endsWith(":") || Dp(h) ? h.name : Ks(h.name), h.params ? [_0(h) ? "" : Dp(h) ? h.raws.afterName === "" ? "" : h.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(h.raws.afterName) ? [ot, ot] : /^\s*\n/.test(h.raws.afterName) ? ot : " " : " ", typeof h.params == "string" ? h.params : r("params")] : "", h.selector ? dr([" ", r("selector")]) : "", h.value ? $r([" ", r("value"), Ad(h, e) ? GN(h) ? " " : Vt : ""]) : h.name === "else" ? " " : "", h.nodes ? [Ad(h, e) ? "" : h.selector && !h.selector.nodes && typeof h.selector.value == "string" && oo(h.selector.value) || !h.selector && typeof h.params == "string" && oo(h.params) ? Vt : " ", "{", dr([h.nodes.length > 0 ? Gr : "", lo(t, e, r)]), Gr, "}"] : d || m ? "" : ";"];
    }
    case "media-query-list": {
      let p = [];
      return t.each(({ node: d }) => {
        d.type === "media-query" && d.value === "" || p.push(r());
      }, "nodes"), $r(dr(as(Vt, p)));
    }
    case "media-query":
      return [as(" ", t.map(r, "nodes")), Op(t, h) ? "" : ","];
    case "media-type":
      return zs(hi(h.value, e));
    case "media-feature-expression":
      return h.nodes ? ["(", ...t.map(r, "nodes"), ")"] : h.value;
    case "media-feature":
      return Ks(hi(kt(!1, h.value, / +/g, " "), e));
    case "media-colon":
      return [h.value, " "];
    case "media-value":
      return zs(hi(h.value, e));
    case "media-keyword":
      return hi(h.value, e);
    case "media-url":
      return hi(kt(!1, kt(!1, h.value, /^url\(\s+/gi, "url("), /\s+\)$/g, ")"), e);
    case "media-unknown":
      return h.value;
    case "selector-root":
      return $r([qu(t, "custom-selector") ? [t.findAncestor((p) => p.type === "css-atrule").customSelector, Vt] : "", as([",", qu(t, ["extend", "custom-selector", "nest"]) ? Vt : ot], t.map(r, "nodes"))]);
    case "selector-selector":
      return $r(dr(t.map(r, "nodes")));
    case "selector-comment":
      return h.value;
    case "selector-string":
      return hi(h.value, e);
    case "selector-tag":
      return [h.namespace ? [h.namespace === !0 ? "" : h.namespace.trim(), "|"] : "", ((l = t.previous) == null ? void 0 : l.type) === "selector-nesting" ? h.value : zs(NN(t, h.value) ? h.value.toLowerCase() : h.value)];
    case "selector-id":
      return ["#", h.value];
    case "selector-class":
      return [".", zs(hi(h.value, e))];
    case "selector-attribute":
      return ["[", h.namespace ? [h.namespace === !0 ? "" : h.namespace.trim(), "|"] : "", h.attribute.trim(), h.operator ?? "", h.value ? c5(hi(h.value.trim(), e), e) : "", h.insensitive ? " i" : "", "]"];
    case "selector-combinator": {
      if (h.value === "+" || h.value === ">" || h.value === "~" || h.value === ">>>") {
        let m = t.parent;
        return [m.type === "selector-selector" && m.nodes[0] === h ? "" : Vt, h.value, Op(t, h) ? "" : " "];
      }
      let p = h.value.trim().startsWith("(") ? Vt : "", d = zs(hi(h.value.trim(), e)) || Vt;
      return [p, d];
    }
    case "selector-universal":
      return [h.namespace ? [h.namespace === !0 ? "" : h.namespace.trim(), "|"] : "", h.value];
    case "selector-pseudo":
      return [Ks(h.value), wh(h.nodes) ? $r(["(", dr([Gr, as([",", Vt], t.map(r, "nodes"))]), Gr, ")"]) : ""];
    case "selector-nesting":
      return h.value;
    case "selector-unknown": {
      let p = t.findAncestor((y) => y.type === "css-rule");
      if (p != null && p.isSCSSNesterProperty)
        return zs(hi(Ks(h.value), e));
      let d = t.parent;
      if ((u = d.raws) != null && u.selector) {
        let y = Or(d), O = y + d.raws.selector.length;
        return e.originalText.slice(y, O).trim();
      }
      let m = t.grandparent;
      if (d.type === "value-paren_group" && (m == null ? void 0 : m.type) === "value-func" && m.value === "selector") {
        let y = gr(d.open) + 1, O = Or(d.close), D = e.originalText.slice(y, O).trim();
        return oo(D) ? [Um, D] : D;
      }
      return h.value;
    }
    case "value-value":
    case "value-root":
      return r("group");
    case "value-comment":
      return e.originalText.slice(Or(h), gr(h));
    case "value-comma_group":
      return r5(t, e, r);
    case "value-paren_group":
      return b5(t, e, r);
    case "value-func":
      return [h.value, qu(t, "supports") && JN(h) ? " " : "", r("group")];
    case "value-paren":
      return h.value;
    case "value-number":
      return [G2(h.value), s5(h.unit)];
    case "value-operator":
      return h.value;
    case "value-word":
      return h.isColor && h.isHex || IN(h.value) ? h.value.toLowerCase() : h.value;
    case "value-colon": {
      let { previous: p } = t;
      return [h.value, typeof (p == null ? void 0 : p.value) == "string" && p.value.endsWith("\\") || Wu(t, "url") ? "" : Vt];
    }
    case "value-string":
      return L2(h.raws.quote + h.value + h.raws.quote, e);
    case "value-atword":
      return ["@", h.value];
    case "value-unicode-range":
      return h.value;
    case "value-unknown":
      return h.value;
    case "value-comma":
    default:
      throw new iN(h, "PostCSS");
  }
}
var S5 = { print: w5, embed: cN, insertPragma: PN, massageAstNode: oN, getVisitorKeys: ON }, C5 = S5, E5 = [{ linguistLanguageId: 50, name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css", ".wxss"], parsers: ["css"], vscodeLanguageIds: ["css"] }, { linguistLanguageId: 262764437, name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", parsers: ["css"], vscodeLanguageIds: ["postcss"] }, { linguistLanguageId: 198, name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", parsers: ["less"], vscodeLanguageIds: ["less"] }, { linguistLanguageId: 329, name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], parsers: ["scss"], vscodeLanguageIds: ["scss"] }], A5 = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, k5 = { singleQuote: A5.singleQuote }, T5 = k5, tb = {};
u2(tb, { css: () => a7, less: () => o7, scss: () => l7 });
var P5 = Fs(bh(), 1), F5 = Fs(V8(), 1), $5 = Fs(K8(), 1);
function B5(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var I5 = B5, N5 = Fs(tI(), 1);
function kl(t, e, r) {
  if (t && typeof t == "object") {
    delete t.parent;
    for (let i in t)
      kl(t[i], e, r), i === "type" && typeof t[i] == "string" && !t[i].startsWith(e) && (!r || !r.test(t[i])) && (t[i] = e + t[i]);
  }
  return t;
}
function rb(t) {
  if (t && typeof t == "object") {
    delete t.parent;
    for (let e in t)
      rb(t[e]);
    !Array.isArray(t) && t.value && !t.type && (t.type = "unknown");
  }
  return t;
}
var _5 = N5.default.default;
function M5(t) {
  let e;
  try {
    e = _5(t);
  } catch {
    return { type: "selector-unknown", value: t };
  }
  return kl(rb(e), "media-");
}
var L5 = M5, Q5 = Fs(yI(), 1);
function j5(t) {
  if (/\/\/|\/\*/.test(t))
    return { type: "selector-unknown", value: t.trim() };
  let e;
  try {
    new Q5.default((r) => {
      e = r;
    }).process(t);
  } catch {
    return { type: "selector-unknown", value: t };
  }
  return kl(e, "selector-");
}
var ts = j5, R5 = Fs(II(), 1), Z5 = (t) => {
  for (; t.parent; )
    t = t.parent;
  return t;
}, ib = Z5;
function W5(t) {
  return ib(t).text.slice(t.group.open.sourceIndex + 1, t.group.close.sourceIndex).trim();
}
var q5 = W5;
function X5(t) {
  if (wh(t)) {
    for (let e = t.length - 1; e > 0; e--)
      if (t[e].type === "word" && t[e].value === "{" && t[e - 1].type === "word" && t[e - 1].value.endsWith("#"))
        return !0;
  }
  return !1;
}
var V5 = X5;
function U5(t) {
  return t.some((e) => e.type === "string" || e.type === "func" && !e.value.endsWith("\\"));
}
var Y5 = U5;
function z5(t, e) {
  return !!(e.parser === "scss" && (t == null ? void 0 : t.type) === "word" && t.value.startsWith("$"));
}
var G5 = z5;
function H5(t, e) {
  var r;
  let { nodes: i } = t, n = { open: null, close: null, groups: [], type: "paren_group" }, s = [n], a = n, l = { groups: [], type: "comma_group" }, u = [l];
  for (let h = 0; h < i.length; ++h) {
    let p = i[h];
    if (e.parser === "scss" && p.type === "number" && p.unit === ".." && p.value.endsWith(".") && (p.value = p.value.slice(0, -1), p.unit = "..."), p.type === "func" && p.value === "selector" && (p.group.groups = [ts(ib(t).text.slice(p.group.open.sourceIndex + 1, p.group.close.sourceIndex))]), p.type === "func" && p.value === "url") {
      let d = ((r = p.group) == null ? void 0 : r.groups) ?? [], m = [];
      for (let y = 0; y < d.length; y++) {
        let O = d[y];
        O.type === "comma_group" ? m = [...m, ...O.groups] : m.push(O);
      }
      (V5(m) || !Y5(m) && !G5(m[0], e)) && (p.group.groups = [q5(p)]);
    }
    if (p.type === "paren" && p.value === "(")
      n = { open: p, close: null, groups: [], type: "paren_group" }, s.push(n), l = { groups: [], type: "comma_group" }, u.push(l);
    else if (p.type === "paren" && p.value === ")") {
      if (l.groups.length > 0 && n.groups.push(l), n.close = p, u.length === 1)
        throw new Error("Unbalanced parenthesis");
      u.pop(), l = zo(!1, u, -1), l.groups.push(n), s.pop(), n = zo(!1, s, -1);
    } else
      p.type === "comma" ? (n.groups.push(l), l = { groups: [], type: "comma_group" }, u[u.length - 1] = l) : l.groups.push(p);
  }
  return l.groups.length > 0 && n.groups.push(l), a;
}
function Td(t) {
  return t.type === "paren_group" && !t.open && !t.close && t.groups.length === 1 || t.type === "comma_group" && t.groups.length === 1 ? Td(t.groups[0]) : t.type === "paren_group" || t.type === "comma_group" ? { ...t, groups: t.groups.map(Td) } : t;
}
function nb(t, e) {
  if (t && typeof t == "object")
    for (let r in t)
      r !== "parent" && (nb(t[r], e), r === "nodes" && (t.group = Td(H5(t, e)), delete t[r]));
  return t;
}
function J5(t, e) {
  if (e.parser === "less" && t.startsWith("~`"))
    return { type: "value-unknown", value: t };
  let r = null;
  try {
    r = new R5.default(t, { loose: !0 }).parse();
  } catch {
    return { type: "value-unknown", value: t };
  }
  r.text = t;
  let i = nb(r, e);
  return kl(i, "value-", /^selector-/);
}
var Hn = J5, K5 = /* @__PURE__ */ new Set(["import", "use", "forward"]);
function e7(t) {
  return K5.has(t);
}
var t7 = e7;
function r7(t, e) {
  return e.parser !== "scss" || !t.selector ? !1 : t.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*\n/, "").trim().endsWith(":");
}
var i7 = r7, n7 = /(\s*)(!default).*$/, s7 = /(\s*)(!global).*$/;
function sb(t, e) {
  var r, i;
  if (t && typeof t == "object") {
    delete t.parent;
    for (let l in t)
      sb(t[l], e);
    if (!t.type)
      return t;
    if (t.raws ?? (t.raws = {}), t.type === "css-decl" && typeof t.prop == "string" && t.prop.startsWith("--") && typeof t.value == "string" && t.value.startsWith("{")) {
      let l;
      if (t.value.trimEnd().endsWith("}")) {
        let u = e.originalText.slice(0, t.source.start.offset), h = "a".repeat(t.prop.length) + e.originalText.slice(t.source.start.offset + t.prop.length, t.source.end.offset), p = kt(!1, u, /[^\n]/g, " ") + h, d;
        e.parser === "scss" ? d = lb : e.parser === "less" ? d = ob : d = ab;
        let m;
        try {
          m = d(p, { ...e });
        } catch {
        }
        ((r = m == null ? void 0 : m.nodes) == null ? void 0 : r.length) === 1 && m.nodes[0].type === "css-rule" && (l = m.nodes[0].nodes);
      }
      return l ? t.value = { type: "css-rule", nodes: l } : t.value = { type: "value-unknown", value: t.raws.value.raw }, t;
    }
    let n = "";
    typeof t.selector == "string" && (n = t.raws.selector ? t.raws.selector.scss ?? t.raws.selector.raw : t.selector, t.raws.between && t.raws.between.trim().length > 0 && (n += t.raws.between), t.raws.selector = n);
    let s = "";
    typeof t.value == "string" && (s = t.raws.value ? t.raws.value.scss ?? t.raws.value.raw : t.value, s = s.trim(), t.raws.value = s);
    let a = "";
    if (typeof t.params == "string" && (a = t.raws.params ? t.raws.params.scss ?? t.raws.params.raw : t.params, t.raws.afterName && t.raws.afterName.trim().length > 0 && (a = t.raws.afterName + a), t.raws.between && t.raws.between.trim().length > 0 && (a = a + t.raws.between), a = a.trim(), t.raws.params = a), n.trim().length > 0)
      return n.startsWith("@") && n.endsWith(":") ? t : t.mixin ? (t.selector = Hn(n, e), t) : (i7(t, e) && (t.isSCSSNesterProperty = !0), t.selector = ts(n), t);
    if (s.length > 0) {
      let l = s.match(n7);
      l && (s = s.slice(0, l.index), t.scssDefault = !0, l[0].trim() !== "!default" && (t.raws.scssDefault = l[0]));
      let u = s.match(s7);
      if (u && (s = s.slice(0, u.index), t.scssGlobal = !0, u[0].trim() !== "!global" && (t.raws.scssGlobal = u[0])), s.startsWith("progid:"))
        return { type: "value-unknown", value: s };
      t.value = Hn(s, e);
    }
    if (e.parser === "less" && t.type === "css-decl" && s.startsWith("extend(") && (t.extend || (t.extend = t.raws.between === ":"), t.extend && !t.selector && (delete t.value, t.selector = ts(s.slice(7, -1)))), t.type === "css-atrule") {
      if (e.parser === "less") {
        if (t.mixin) {
          let l = t.raws.identifier + t.name + t.raws.afterName + t.raws.params;
          return t.selector = ts(l), delete t.params, t;
        }
        if (t.function)
          return t;
      }
      if (e.parser === "css" && t.name === "custom-selector") {
        let l = t.params.match(/:--\S+\s+/)[0].trim();
        return t.customSelector = l, t.selector = ts(t.params.slice(l.length).trim()), delete t.params, t;
      }
      if (e.parser === "less") {
        if (t.name.includes(":") && !t.params) {
          t.variable = !0;
          let l = t.name.split(":");
          t.name = l[0], t.value = Hn(l.slice(1).join(":"), e);
        }
        if (!["page", "nest", "keyframes"].includes(t.name) && ((i = t.params) == null ? void 0 : i[0]) === ":") {
          t.variable = !0;
          let l = t.params.slice(1);
          l && (t.value = Hn(l, e)), t.raws.afterName += ":";
        }
        if (t.variable)
          return delete t.params, t.value || delete t.value, t;
      }
    }
    if (t.type === "css-atrule" && a.length > 0) {
      let { name: l } = t, u = t.name.toLowerCase();
      return l === "warn" || l === "error" ? (t.params = { type: "media-unknown", value: a }, t) : l === "extend" || l === "nest" ? (t.selector = ts(a), delete t.params, t) : l === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(a) ? t.params = Hn(a, e) : (t.selector = ts(a), delete t.params), t) : t7(u) ? (t.import = !0, delete t.filename, t.params = Hn(a, e), t) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(l) ? (a = a.replace(/(\$\S+?)(\s+)?\.{3}/, "$1...$2"), a = a.replace(/^(?!if)(\S+)(\s+)\(/, "$1($2"), t.value = Hn(a, e), delete t.params, t) : ["media", "custom-media"].includes(u) ? a.includes("#{") ? { type: "media-unknown", value: a } : (t.params = L5(a), t) : (t.params = a, t);
    }
  }
  return t;
}
function Jm(t, e, r) {
  let i = Gm(e), { frontMatter: n } = i;
  e = i.content;
  let s;
  try {
    s = t(e, { map: !1 });
  } catch (a) {
    let { name: l, reason: u, line: h, column: p } = a;
    throw typeof h != "number" ? a : I5(`${l}: ${u}`, { loc: { start: { line: h, column: p } }, cause: a });
  }
  return r.originalText = e, s = sb(kl(s, "css-"), r), X2(s, e), n && (n.source = { startOffset: 0, endOffset: n.raw.length }, s.frontMatter = n), s;
}
function ab(t, e = {}) {
  return Jm(P5.default.default, t, e);
}
function ob(t, e = {}) {
  return Jm((r) => F5.default.parse(vN(r)), t, e);
}
function lb(t, e = {}) {
  return Jm($5.default, t, e);
}
var Km = { astFormat: "postcss", hasPragma: TN, locStart: Or, locEnd: gr }, a7 = { ...Km, parse: ab }, o7 = { ...Km, parse: ob }, l7 = { ...Km, parse: lb }, u7 = { postcss: C5 }, c7 = C2, h7 = Object.create, eg = Object.defineProperty, p7 = Object.getOwnPropertyDescriptor, d7 = Object.getOwnPropertyNames, f7 = Object.getPrototypeOf, m7 = Object.prototype.hasOwnProperty, g7 = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Sh = (t, e) => {
  for (var r in e)
    eg(t, r, { get: e[r], enumerable: !0 });
}, y7 = (t, e, r, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of d7(e))
      !m7.call(t, n) && n !== r && eg(t, n, { get: () => e[n], enumerable: !(i = p7(e, n)) || i.enumerable });
  return t;
}, O7 = (t, e, r) => (r = t != null ? h7(f7(t)) : {}, y7(e || !t || !t.__esModule ? eg(r, "default", { value: t, enumerable: !0 }) : r, t)), ub = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, mn = (t, e, r) => (ub(t, e, "read from private field"), r ? r.call(t) : e.get(t)), x7 = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, D7 = (t, e, r, i) => (ub(t, e, "write to private field"), i ? i.call(t, r) : e.set(t, r), r), b7 = g7((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = p, t.parse = m, t.parseWithComments = y, t.print = O, t.strip = d;
  var e = /\*\/$/, r = /^\/\*\*?/, i = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, n = /(^|\s+)\/\/([^\r\n]*)/g, s = /^(\r?\n)+/, a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, l = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, u = /(\r?\n|^) *\* ?/g, h = [];
  function p(v) {
    let w = v.match(i);
    return w ? w[0].trimLeft() : "";
  }
  function d(v) {
    let w = v.match(i);
    return w && w[0] ? v.substring(w[0].length) : v;
  }
  function m(v) {
    return y(v).pragmas;
  }
  function y(v) {
    let w = `
`;
    v = v.replace(r, "").replace(e, "").replace(u, "$1");
    let x = "";
    for (; x !== v; )
      x = v, v = v.replace(a, `${w}$1 $2${w}`);
    v = v.replace(s, "").trimRight();
    let S = /* @__PURE__ */ Object.create(null), k = v.replace(l, "").replace(s, "").trimRight(), C;
    for (; C = l.exec(v); ) {
      let A = C[2].replace(n, "");
      typeof S[C[1]] == "string" || Array.isArray(S[C[1]]) ? S[C[1]] = h.concat(S[C[1]], A) : S[C[1]] = A;
    }
    return { comments: k, pragmas: S };
  }
  function O({ comments: v = "", pragmas: w = {} }) {
    let x = `
`, S = "/**", k = " *", C = " */", A = Object.keys(w), P = A.flatMap((B) => D(B, w[B])).map((B) => `${k} ${B}${x}`).join("");
    if (!v) {
      if (A.length === 0)
        return "";
      if (A.length === 1 && !Array.isArray(w[A[0]])) {
        let B = w[A[0]];
        return `${S} ${D(A[0], B)[0]}${C}`;
      }
    }
    let I = v.split(x).map((B) => `${k} ${B}`).join(x) + x;
    return S + x + (v ? I : "") + (v && A.length ? k + x : "") + P + C;
  }
  function D(v, w) {
    return h.concat(w).map((x) => `@${v} ${x}`.trim());
  }
}), cb = {};
Sh(cb, { languages: () => nL, options: () => rL, printers: () => iL });
var v7 = [{ linguistLanguageId: 183, name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib", ".wxs"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell", "zx"], parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"] }, { linguistLanguageId: 183, name: "Flow", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: [], extensions: [".js.flow"], filenames: [], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"] }, { linguistLanguageId: 183, name: "JSX", type: "programming", tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0, aliases: void 0, extensions: [".jsx"], filenames: void 0, interpreters: void 0, parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], group: "JavaScript" }, { linguistLanguageId: 378, name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] }, { linguistLanguageId: 94901924, name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] }], hb = {};
Sh(hb, { canAttachComment: () => T4, embed: () => g6, experimentalFeatures: () => UM, getCommentChildNodes: () => P4, getVisitorKeys: () => fb, handleComments: () => Qb, insertPragma: () => D6, isBlockComment: () => Wr, isGap: () => F4, massageAstNode: () => T_, print: () => VM, printComment: () => Y_, willPrintOwnComments: () => zb });
var w7 = (t, e, r, i) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, i) : r.global ? e.replace(r, i) : e.split(r).join(i);
}, xr = w7, S7 = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, We = S7, C7 = /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/, E7 = (t) => C7.test(t), A7 = E7;
function k7(t) {
  return t !== null && typeof t == "object";
}
var T7 = k7;
function* P7(t, e) {
  let { getVisitorKeys: r, filter: i = () => !0 } = e, n = (s) => T7(s) && i(s);
  for (let s of r(t)) {
    let a = t[s];
    if (Array.isArray(a))
      for (let l of a)
        n(l) && (yield l);
    else
      n(a) && (yield a);
  }
}
function* F7(t, e) {
  let r = [t];
  for (let i = 0; i < r.length; i++) {
    let n = r[i];
    for (let s of P7(n, e))
      yield s, r.push(s);
  }
}
function $7(t, { getVisitorKeys: e, predicate: r }) {
  for (let i of F7(t, { getVisitorKeys: e }))
    if (r(i))
      return !0;
  return !1;
}
var B7 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function I7(t) {
  return t === 12288 || t >= 65281 && t <= 65376 || t >= 65504 && t <= 65510;
}
function N7(t) {
  return t >= 4352 && t <= 4447 || t === 8986 || t === 8987 || t === 9001 || t === 9002 || t >= 9193 && t <= 9196 || t === 9200 || t === 9203 || t === 9725 || t === 9726 || t === 9748 || t === 9749 || t >= 9800 && t <= 9811 || t === 9855 || t === 9875 || t === 9889 || t === 9898 || t === 9899 || t === 9917 || t === 9918 || t === 9924 || t === 9925 || t === 9934 || t === 9940 || t === 9962 || t === 9970 || t === 9971 || t === 9973 || t === 9978 || t === 9981 || t === 9989 || t === 9994 || t === 9995 || t === 10024 || t === 10060 || t === 10062 || t >= 10067 && t <= 10069 || t === 10071 || t >= 10133 && t <= 10135 || t === 10160 || t === 10175 || t === 11035 || t === 11036 || t === 11088 || t === 11093 || t >= 11904 && t <= 11929 || t >= 11931 && t <= 12019 || t >= 12032 && t <= 12245 || t >= 12272 && t <= 12287 || t >= 12289 && t <= 12350 || t >= 12353 && t <= 12438 || t >= 12441 && t <= 12543 || t >= 12549 && t <= 12591 || t >= 12593 && t <= 12686 || t >= 12688 && t <= 12771 || t >= 12783 && t <= 12830 || t >= 12832 && t <= 12871 || t >= 12880 && t <= 19903 || t >= 19968 && t <= 42124 || t >= 42128 && t <= 42182 || t >= 43360 && t <= 43388 || t >= 44032 && t <= 55203 || t >= 63744 && t <= 64255 || t >= 65040 && t <= 65049 || t >= 65072 && t <= 65106 || t >= 65108 && t <= 65126 || t >= 65128 && t <= 65131 || t >= 94176 && t <= 94180 || t === 94192 || t === 94193 || t >= 94208 && t <= 100343 || t >= 100352 && t <= 101589 || t >= 101632 && t <= 101640 || t >= 110576 && t <= 110579 || t >= 110581 && t <= 110587 || t === 110589 || t === 110590 || t >= 110592 && t <= 110882 || t === 110898 || t >= 110928 && t <= 110930 || t === 110933 || t >= 110948 && t <= 110951 || t >= 110960 && t <= 111355 || t === 126980 || t === 127183 || t === 127374 || t >= 127377 && t <= 127386 || t >= 127488 && t <= 127490 || t >= 127504 && t <= 127547 || t >= 127552 && t <= 127560 || t === 127568 || t === 127569 || t >= 127584 && t <= 127589 || t >= 127744 && t <= 127776 || t >= 127789 && t <= 127797 || t >= 127799 && t <= 127868 || t >= 127870 && t <= 127891 || t >= 127904 && t <= 127946 || t >= 127951 && t <= 127955 || t >= 127968 && t <= 127984 || t === 127988 || t >= 127992 && t <= 128062 || t === 128064 || t >= 128066 && t <= 128252 || t >= 128255 && t <= 128317 || t >= 128331 && t <= 128334 || t >= 128336 && t <= 128359 || t === 128378 || t === 128405 || t === 128406 || t === 128420 || t >= 128507 && t <= 128591 || t >= 128640 && t <= 128709 || t === 128716 || t >= 128720 && t <= 128722 || t >= 128725 && t <= 128727 || t >= 128732 && t <= 128735 || t === 128747 || t === 128748 || t >= 128756 && t <= 128764 || t >= 128992 && t <= 129003 || t === 129008 || t >= 129292 && t <= 129338 || t >= 129340 && t <= 129349 || t >= 129351 && t <= 129535 || t >= 129648 && t <= 129660 || t >= 129664 && t <= 129672 || t >= 129680 && t <= 129725 || t >= 129727 && t <= 129733 || t >= 129742 && t <= 129755 || t >= 129760 && t <= 129768 || t >= 129776 && t <= 129784 || t >= 131072 && t <= 196605 || t >= 196608 && t <= 262141;
}
var _7 = (t) => !(I7(t) || N7(t)), M7 = /[^\x20-\x7F]/;
function L7(t) {
  if (!t)
    return 0;
  if (!M7.test(t))
    return t.length;
  t = t.replace(B7(), "  ");
  let e = 0;
  for (let r of t) {
    let i = r.codePointAt(0);
    i <= 31 || i >= 127 && i <= 159 || i >= 768 && i <= 879 || (e += _7(i) ? 1 : 2);
  }
  return e;
}
var wa = L7;
function tg(t) {
  return (e, r, i) => {
    let n = !!(i != null && i.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, a = r;
    for (; a >= 0 && a < s; ) {
      let l = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(l))
          return a;
      } else if (!t.includes(l))
        return a;
      n ? a-- : a++;
    }
    return a === -1 || a === s ? a : !1;
  };
}
var Sa = tg(" 	"), Q7 = tg(",; 	"), j7 = tg(/[^\n\r]/);
function R7(t, e, r) {
  let i = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let n = t.charAt(e);
  if (i) {
    if (t.charAt(e - 1) === "\r" && n === `
`)
      return e - 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e - 1;
  } else {
    if (n === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e + 1;
  }
  return e;
}
var Ca = R7;
function Z7(t, e, r = {}) {
  let i = Sa(t, r.backwards ? e - 1 : e, r), n = Ca(t, i, r);
  return i !== n;
}
var wr = Z7;
function W7(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var rg = W7;
function q7(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? j7(t, e) : e;
}
var ig = q7;
function X7(t, e) {
  let r = null, i = e;
  for (; i !== r; )
    r = i, i = Q7(t, i), i = rg(t, i), i = Sa(t, i);
  return i = ig(t, i), i = Ca(t, i), i !== !1 && wr(t, i);
}
var ng = X7;
function V7(t) {
  return Array.isArray(t) && t.length > 0;
}
var Re = V7, cu = "'", j0 = '"';
function U7(t, e) {
  let r = e === !0 || e === cu ? cu : j0, i = r === cu ? j0 : cu, n = 0, s = 0;
  for (let a of t)
    a === r ? n++ : a === i && s++;
  return n > s ? i : r;
}
var pb = U7;
function Y7(t, e, r) {
  let i = e === '"' ? "'" : '"', n = xr(!1, t, /\\(.)|(["'])/gs, (s, a, l) => a === i ? a : l === e ? "\\" + l : l || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(a) ? a : "\\" + a));
  return e + n + e;
}
var z7 = Y7;
function G7(t, e) {
  let r = t.slice(1, -1), i = e.parser === "json" || e.parser === "jsonc" || e.parser === "json5" && e.quoteProps === "preserve" && !e.singleQuote ? '"' : e.__isInHtmlAttribute ? "'" : pb(r, e.singleQuote);
  return z7(r, i, !(e.parser === "css" || e.parser === "less" || e.parser === "scss" || e.__embeddedInHtml));
}
var Go = G7;
function st(t) {
  var e, r, i;
  let n = ((e = t.range) == null ? void 0 : e[0]) ?? t.start, s = (i = ((r = t.declaration) == null ? void 0 : r.decorators) ?? t.decorators) == null ? void 0 : i[0];
  return s ? Math.min(st(s), n) : n;
}
function Ze(t) {
  var e;
  return ((e = t.range) == null ? void 0 : e[1]) ?? t.end;
}
function Ch(t, e) {
  let r = st(t);
  return Number.isInteger(r) && r === st(e);
}
function H7(t, e) {
  let r = Ze(t);
  return Number.isInteger(r) && r === Ze(e);
}
function J7(t, e) {
  return Ch(t, e) && H7(t, e);
}
var uo = null;
function No(t) {
  if (uo !== null && typeof uo.property) {
    let e = uo;
    return uo = No.prototype = null, e;
  }
  return uo = No.prototype = t ?? /* @__PURE__ */ Object.create(null), new No();
}
var K7 = 10;
for (let t = 0; t <= K7; t++)
  No();
function e_(t) {
  return No(t);
}
function t_(t, e = "type") {
  e_(t);
  function r(i) {
    let n = i[e], s = t[n];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: i });
    return s;
  }
  return r;
}
var db = t_, r_ = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value", "optional", "static", "method"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareEnum: ["id", "body"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], AsConstExpression: ["expression"], SatisfiesExpression: ["expression", "typeAnnotation"] }, i_ = db(r_), fb = i_;
function n_(t) {
  let e = new Set(t);
  return (r) => e.has(r == null ? void 0 : r.type);
}
var Ue = n_, s_ = Ue(["Block", "CommentBlock", "MultiLine"]), Wr = s_, a_ = Ue(["AnyTypeAnnotation", "ThisTypeAnnotation", "NumberTypeAnnotation", "VoidTypeAnnotation", "BooleanTypeAnnotation", "BigIntTypeAnnotation", "SymbolTypeAnnotation", "StringTypeAnnotation", "NeverTypeAnnotation", "UndefinedTypeAnnotation", "UnknownTypeAnnotation", "EmptyTypeAnnotation", "MixedTypeAnnotation"]), mb = a_;
function o_(t, e) {
  let r = e.split(".");
  for (let i = r.length - 1; i >= 0; i--) {
    let n = r[i];
    if (i === 0)
      return t.type === "Identifier" && t.name === n;
    if (t.type !== "MemberExpression" || t.optional || t.computed || t.property.type !== "Identifier" || t.property.name !== n)
      return !1;
    t = t.object;
  }
}
function l_(t, e) {
  return e.some((r) => o_(t, r));
}
var u_ = l_;
function c_({ type: t }) {
  return t.startsWith("TS") && t.endsWith("Keyword");
}
var gb = c_;
function Pd(t, e) {
  return e(t) || $7(t, { getVisitorKeys: fb, predicate: e });
}
function sg(t) {
  return t.type === "AssignmentExpression" || t.type === "BinaryExpression" || t.type === "LogicalExpression" || t.type === "NGPipeExpression" || t.type === "ConditionalExpression" || Qe(t) || nt(t) || t.type === "SequenceExpression" || t.type === "TaggedTemplateExpression" || t.type === "BindExpression" || t.type === "UpdateExpression" && !t.prefix || bi(t) || t.type === "TSNonNullExpression" || t.type === "ChainExpression";
}
function h_(t) {
  return t.expressions ? t.expressions[0] : t.left ?? t.test ?? t.callee ?? t.object ?? t.tag ?? t.argument ?? t.expression;
}
function yb(t) {
  if (t.expressions)
    return ["expressions", 0];
  if (t.left)
    return ["left"];
  if (t.test)
    return ["test"];
  if (t.object)
    return ["object"];
  if (t.callee)
    return ["callee"];
  if (t.tag)
    return ["tag"];
  if (t.argument)
    return ["argument"];
  if (t.expression)
    return ["expression"];
  throw new Error("Unexpected node has no left side.");
}
var Eh = Ue(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose", "Hashbang", "InterpreterDirective"]), p_ = Ue(["ExportDefaultDeclaration", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "DeclareExportAllDeclaration"]), Nt = Ue(["ArrayExpression", "TupleExpression"]), ni = Ue(["ObjectExpression", "RecordExpression"]);
function In(t) {
  return t.type === "NumericLiteral" || t.type === "Literal" && typeof t.value == "number";
}
function Ob(t) {
  return t.type === "UnaryExpression" && (t.operator === "+" || t.operator === "-") && In(t.argument);
}
function ar(t) {
  return t.type === "StringLiteral" || t.type === "Literal" && typeof t.value == "string";
}
function xb(t) {
  return t.type === "RegExpLiteral" || t.type === "Literal" && !!t.regex;
}
var Ah = Ue(["Literal", "BooleanLiteral", "BigIntLiteral", "DecimalLiteral", "DirectiveLiteral", "NullLiteral", "NumericLiteral", "RegExpLiteral", "StringLiteral"]), Db = Ue(["Identifier", "ThisExpression", "Super", "PrivateName", "PrivateIdentifier", "Import"]), Nn = Ue(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), Ho = Ue(["FunctionExpression", "ArrowFunctionExpression"]);
function d_(t) {
  return t.type === "FunctionExpression" || t.type === "ArrowFunctionExpression" && t.body.type === "BlockStatement";
}
function Sp(t) {
  return Qe(t) && t.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(t.callee.name);
}
var bt = Ue(["JSXElement", "JSXFragment"]);
function kh(t) {
  return t.method && t.kind === "init" || t.kind === "get" || t.kind === "set";
}
function bb(t) {
  return (t.type === "ObjectTypeProperty" || t.type === "ObjectTypeInternalSlot") && !t.static && !t.method && t.kind !== "get" && t.kind !== "set" && t.value.type === "FunctionTypeAnnotation";
}
function f_(t) {
  return (t.type === "TypeAnnotation" || t.type === "TSTypeAnnotation") && t.typeAnnotation.type === "FunctionTypeAnnotation" && !t.static && !Ch(t, t.typeAnnotation);
}
var Vi = Ue(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
function ta(t) {
  return nt(t) || t.type === "BindExpression" && !!t.object;
}
var m_ = Ue(["TSThisType", "NullLiteralTypeAnnotation", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType"]);
function ag(t) {
  return gb(t) || mb(t) || m_(t) || (t.type === "GenericTypeAnnotation" || t.type === "TSTypeReference") && !t.typeParameters;
}
function g_(t) {
  let e = /^(?:before|after)(?:Each|All)$/;
  return t.callee.type === "Identifier" && t.arguments.length === 1 && e.test(t.callee.name);
}
var y_ = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
function O_(t) {
  return u_(t, y_);
}
function Th(t, e) {
  if (t.type !== "CallExpression")
    return !1;
  if (t.arguments.length === 1) {
    if (Sp(t) && e && Th(e))
      return Ho(t.arguments[0]);
    if (g_(t))
      return Sp(t.arguments[0]);
  } else if ((t.arguments.length === 2 || t.arguments.length === 3) && (t.arguments[0].type === "TemplateLiteral" || ar(t.arguments[0])) && O_(t.callee))
    return t.arguments[2] && !In(t.arguments[2]) ? !1 : (t.arguments.length === 2 ? Ho(t.arguments[1]) : d_(t.arguments[1]) && qt(t.arguments[1]).length <= 1) || Sp(t.arguments[1]);
  return !1;
}
var vb = (t) => (e) => ((e == null ? void 0 : e.type) === "ChainExpression" && (e = e.expression), t(e)), Qe = vb(Ue(["CallExpression", "OptionalCallExpression"])), nt = vb(Ue(["MemberExpression", "OptionalMemberExpression"]));
function x_(t) {
  let e = "expressions";
  t.type === "TSTemplateLiteralType" && (e = "types");
  let r = t[e];
  return r.length === 0 ? !1 : r.every((i) => {
    if (Fd(i) || wb(i))
      return !0;
  });
}
function wb(t, { maxDepth: e = Number.POSITIVE_INFINITY } = {}) {
  if (se(t))
    return !1;
  if (t.type === "ChainExpression")
    return wb(t.expression, { maxDepth: e });
  if (!nt(t))
    return !1;
  let r = t, i = 0;
  for (; nt(r) && i++ <= e; )
    if (!Fd(r.property) || (r = r.object, se(r)))
      return !1;
  return Fd(r);
}
function Fd(t) {
  return se(t) ? !1 : Ah(t) || Db(t);
}
function R0(t, e = 5) {
  return Sb(t, e) <= e;
}
function Sb(t, e) {
  let r = 0;
  for (let i in t) {
    let n = t[i];
    if (n && typeof n == "object" && typeof n.type == "string" && (r++, r += Sb(n, e - r)), r > e)
      return r;
  }
  return r;
}
var D_ = 0.25;
function og(t, e) {
  let { printWidth: r } = e;
  if (se(t))
    return !1;
  let i = r * D_;
  if (t.type === "ThisExpression" || t.type === "Identifier" && t.name.length <= i || Ob(t) && !se(t.argument))
    return !0;
  let n = t.type === "Literal" && "regex" in t && t.regex.pattern || t.type === "RegExpLiteral" && t.pattern;
  return n ? n.length <= i : ar(t) ? Go(Qr(t), e).length <= i : t.type === "TemplateLiteral" ? t.expressions.length === 0 && t.quasis[0].value.raw.length <= i && !t.quasis[0].value.raw.includes(`
`) : t.type === "UnaryExpression" ? og(t.argument, { printWidth: r }) : t.type === "CallExpression" && t.arguments.length === 0 && t.callee.type === "Identifier" ? t.callee.name.length <= i - 2 : Ah(t);
}
function Os(t, e) {
  return bt(e) ? Ph(e) : se(e, de.Leading, (r) => wr(t, Ze(r)));
}
function Z0(t, e) {
  return e.parser !== "json" && e.parser !== "jsonc" && ar(t.key) && Qr(t.key).slice(1, -1) === t.key.value && (A7(t.key.value) && !(e.parser === "babel-ts" && t.type === "ClassProperty" || e.parser === "typescript" && t.type === "PropertyDefinition") || Cb(t.key.value) && String(Number(t.key.value)) === t.key.value && (e.parser === "babel" || e.parser === "acorn" || e.parser === "espree" || e.parser === "meriyah" || e.parser === "__babel_estree"));
}
function Cb(t) {
  return /^(?:\d+|\d+\.\d+)$/.test(t);
}
function W0(t) {
  return t.quasis.some((e) => e.value.raw.includes(`
`));
}
function Eb(t, e) {
  return (t.type === "TemplateLiteral" && W0(t) || t.type === "TaggedTemplateExpression" && W0(t.quasi)) && !wr(e, st(t), { backwards: !0 });
}
function Ab(t) {
  if (!se(t))
    return !1;
  let e = We(!1, pa(t, de.Dangling), -1);
  return e && !Wr(e);
}
function b_(t) {
  if (t.length <= 1)
    return !1;
  let e = 0;
  for (let r of t)
    if (Ho(r)) {
      if (e += 1, e > 1)
        return !0;
    } else if (Qe(r)) {
      for (let i of jr(r))
        if (Ho(i))
          return !0;
    }
  return !1;
}
function kb(t) {
  let { node: e, parent: r, key: i } = t;
  return i === "callee" && Qe(e) && Qe(r) && r.arguments.length > 0 && e.arguments.length > r.arguments.length;
}
var v_ = /* @__PURE__ */ new Set(["!", "-", "+", "~"]);
function Kr(t, e = 2) {
  if (e <= 0)
    return !1;
  if (t.type === "ChainExpression" || t.type === "TSNonNullExpression")
    return Kr(t.expression, e);
  let r = (i) => Kr(i, e - 1);
  if (xb(t))
    return wa(t.pattern ?? t.regex.pattern) <= 5;
  if (Ah(t) || Db(t) || t.type === "ArgumentPlaceholder")
    return !0;
  if (t.type === "TemplateLiteral")
    return t.quasis.every((i) => !i.value.raw.includes(`
`)) && t.expressions.every(r);
  if (ni(t))
    return t.properties.every((i) => !i.computed && (i.shorthand || i.value && r(i.value)));
  if (Nt(t))
    return t.elements.every((i) => i === null || r(i));
  if (Ea(t)) {
    if (t.type === "ImportExpression" || Kr(t.callee, e)) {
      let i = jr(t);
      return i.length <= e && i.every(r);
    }
    return !1;
  }
  return nt(t) ? Kr(t.object, e) && Kr(t.property, e) : t.type === "UnaryExpression" && v_.has(t.operator) || t.type === "UpdateExpression" ? Kr(t.argument, e) : !1;
}
function Qr(t) {
  var e;
  return ((e = t.extra) == null ? void 0 : e.raw) ?? t.raw;
}
function w_(t) {
  return t;
}
function Xn(t, e = "es5") {
  return t.trailingComma === "es5" && e === "es5" || t.trailingComma === "all" && (e === "all" || e === "es5");
}
function Ut(t, e) {
  switch (t.type) {
    case "BinaryExpression":
    case "LogicalExpression":
    case "AssignmentExpression":
    case "NGPipeExpression":
      return Ut(t.left, e);
    case "MemberExpression":
    case "OptionalMemberExpression":
      return Ut(t.object, e);
    case "TaggedTemplateExpression":
      return t.tag.type === "FunctionExpression" ? !1 : Ut(t.tag, e);
    case "CallExpression":
    case "OptionalCallExpression":
      return t.callee.type === "FunctionExpression" ? !1 : Ut(t.callee, e);
    case "ConditionalExpression":
      return Ut(t.test, e);
    case "UpdateExpression":
      return !t.prefix && Ut(t.argument, e);
    case "BindExpression":
      return t.object && Ut(t.object, e);
    case "SequenceExpression":
      return Ut(t.expressions[0], e);
    case "ChainExpression":
    case "TSSatisfiesExpression":
    case "TSAsExpression":
    case "TSNonNullExpression":
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
      return Ut(t.expression, e);
    default:
      return e(t);
  }
}
var q0 = { "==": !0, "!=": !0, "===": !0, "!==": !0 }, hu = { "*": !0, "/": !0, "%": !0 }, $d = { ">>": !0, ">>>": !0, "<<": !0 };
function lg(t, e) {
  return !(fc(e) !== fc(t) || t === "**" || q0[t] && q0[e] || e === "%" && hu[t] || t === "%" && hu[e] || e !== t && hu[e] && hu[t] || $d[t] && $d[e]);
}
var S_ = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((t, e) => t.map((r) => [r, e])));
function fc(t) {
  return S_.get(t);
}
function C_(t) {
  return !!$d[t] || t === "|" || t === "^" || t === "&";
}
function E_(t) {
  var e;
  if (t.rest)
    return !0;
  let r = qt(t);
  return ((e = We(!1, r, -1)) == null ? void 0 : e.type) === "RestElement";
}
var Cp = /* @__PURE__ */ new WeakMap();
function qt(t) {
  if (Cp.has(t))
    return Cp.get(t);
  let e = [];
  return t.this && e.push(t.this), Array.isArray(t.parameters) ? e.push(...t.parameters) : Array.isArray(t.params) && e.push(...t.params), t.rest && e.push(t.rest), Cp.set(t, e), e;
}
function A_(t, e) {
  let { node: r } = t, i = 0, n = (s) => e(s, i++);
  r.this && t.call(n, "this"), Array.isArray(r.parameters) ? t.each(n, "parameters") : Array.isArray(r.params) && t.each(n, "params"), r.rest && t.call(n, "rest");
}
var Ep = /* @__PURE__ */ new WeakMap();
function jr(t) {
  if (Ep.has(t))
    return Ep.get(t);
  if (t.type === "ChainExpression")
    return jr(t.expression);
  let e = t.arguments;
  return t.type === "ImportExpression" && (e = [t.source], t.attributes && e.push(t.attributes), t.options && e.push(t.options)), Ep.set(t, e), e;
}
function ug(t, e) {
  let { node: r } = t;
  if (r.type === "ChainExpression")
    return t.call(() => ug(t, e), "expression");
  r.type === "ImportExpression" ? (t.call((i) => e(i, 0), "source"), r.attributes && t.call((i) => e(i, 1), "attributes"), r.options && t.call((i) => e(i, 1), "options")) : t.each(e, "arguments");
}
function X0(t, e) {
  let r = [];
  if (t.type === "ChainExpression" && r.push("expression"), t.type === "ImportExpression") {
    if (e === 0 || e === (t.attributes || t.options ? -2 : -1))
      return [...r, "source"];
    if (t.attributes && (e === 1 || e === -1))
      return [...r, "attributes"];
    if (t.options && (e === 1 || e === -1))
      return [...r, "options"];
    throw new RangeError("Invalid argument index");
  }
  if (e < 0 && (e = t.arguments.length + e), e < 0 || e >= t.arguments.length)
    throw new RangeError("Invalid argument index");
  return [...r, "arguments", e];
}
function mc(t) {
  return t.value.trim() === "prettier-ignore" && !t.unignore;
}
function Ph(t) {
  return (t == null ? void 0 : t.prettierIgnore) || se(t, de.PrettierIgnore);
}
var de = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, Tb = (t, e) => {
  if (typeof t == "function" && (e = t, t = 0), t || e)
    return (r, i, n) => !(t & de.Leading && !r.leading || t & de.Trailing && !r.trailing || t & de.Dangling && (r.leading || r.trailing) || t & de.Block && !Wr(r) || t & de.Line && !Eh(r) || t & de.First && i !== 0 || t & de.Last && i !== n.length - 1 || t & de.PrettierIgnore && !mc(r) || e && !e(r));
};
function se(t, e, r) {
  if (!Re(t == null ? void 0 : t.comments))
    return !1;
  let i = Tb(e, r);
  return i ? t.comments.some(i) : !0;
}
function pa(t, e, r) {
  if (!Array.isArray(t == null ? void 0 : t.comments))
    return [];
  let i = Tb(e, r);
  return i ? t.comments.filter(i) : t.comments;
}
var Vn = (t, { originalText: e }) => ng(e, Ze(t));
function Ea(t) {
  return Qe(t) || t.type === "NewExpression" || t.type === "ImportExpression";
}
function on(t) {
  return t && (t.type === "ObjectProperty" || t.type === "Property" && !kh(t));
}
var bi = Ue(["TSAsExpression", "TSSatisfiesExpression", "AsExpression", "AsConstExpression", "SatisfiesExpression"]), xs = Ue(["UnionTypeAnnotation", "TSUnionType"]), Pb = Ue(["IntersectionTypeAnnotation", "TSIntersectionType"]), k_ = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), Gs = (t) => {
  for (let e of t.quasis)
    delete e.value;
};
function Fb(t, e, r) {
  var i, n;
  if (t.type === "Program" && delete e.sourceType, (t.type === "BigIntLiteral" || t.type === "BigIntLiteralTypeAnnotation") && e.value && (e.value = e.value.toLowerCase()), (t.type === "BigIntLiteral" || t.type === "Literal") && e.bigint && (e.bigint = e.bigint.toLowerCase()), t.type === "DecimalLiteral" && (e.value = Number(e.value)), t.type === "Literal" && e.decimal && (e.decimal = Number(e.decimal)), t.type === "EmptyStatement" || t.type === "JSXText" || t.type === "JSXExpressionContainer" && (t.expression.type === "Literal" || t.expression.type === "StringLiteral") && t.expression.value === " ")
    return null;
  if ((t.type === "Property" || t.type === "ObjectProperty" || t.type === "MethodDefinition" || t.type === "ClassProperty" || t.type === "ClassMethod" || t.type === "PropertyDefinition" || t.type === "TSDeclareMethod" || t.type === "TSPropertySignature" || t.type === "ObjectTypeProperty") && typeof t.key == "object" && t.key && (t.key.type === "Literal" || t.key.type === "NumericLiteral" || t.key.type === "StringLiteral" || t.key.type === "Identifier") && delete e.key, t.type === "JSXElement" && t.openingElement.name.name === "style" && t.openingElement.attributes.some((a) => a.type === "JSXAttribute" && a.name.name === "jsx"))
    for (let { type: a, expression: l } of e.children)
      a === "JSXExpressionContainer" && l.type === "TemplateLiteral" && Gs(l);
  t.type === "JSXAttribute" && t.name.name === "css" && t.value.type === "JSXExpressionContainer" && t.value.expression.type === "TemplateLiteral" && Gs(e.value.expression), t.type === "JSXAttribute" && ((i = t.value) == null ? void 0 : i.type) === "Literal" && /["']|&quot;|&apos;/.test(t.value.value) && (e.value.value = xr(!1, e.value.value, /["']|&quot;|&apos;/g, '"'));
  let s = t.expression || t.callee;
  if (t.type === "Decorator" && s.type === "CallExpression" && s.callee.name === "Component" && s.arguments.length === 1) {
    let a = t.expression.arguments[0].properties;
    for (let [l, u] of e.expression.arguments[0].properties.entries())
      switch (a[l].key.name) {
        case "styles":
          Nt(u.value) && Gs(u.value.elements[0]);
          break;
        case "template":
          u.value.type === "TemplateLiteral" && Gs(u.value);
          break;
      }
  }
  if (t.type === "TaggedTemplateExpression" && (t.tag.type === "MemberExpression" || t.tag.type === "Identifier" && (t.tag.name === "gql" || t.tag.name === "graphql" || t.tag.name === "css" || t.tag.name === "md" || t.tag.name === "markdown" || t.tag.name === "html") || t.tag.type === "CallExpression") && Gs(e.quasi), t.type === "TemplateLiteral" && ((n = t.leadingComments) != null && n.some((a) => Wr(a) && ["GraphQL", "HTML"].some((l) => a.value === ` ${l} `)) || r.type === "CallExpression" && r.callee.name === "graphql" || !t.leadingComments) && Gs(e), (t.type === "TSIntersectionType" || t.type === "TSUnionType") && t.types.length === 1)
    return e.types[0];
  t.type === "ChainExpression" && t.expression.type === "TSNonNullExpression" && ([e.type, e.expression.type] = [e.expression.type, e.type]);
}
Fb.ignoredProperties = k_;
var T_ = Fb, Qa = "string", Ds = "array", ja = "cursor", Bs = "indent", Is = "align", Ra = "trim", Rr = "group", Pi = "fill", Ci = "if-break", Ns = "indent-if-break", _s = "line-suffix", Ms = "line-suffix-boundary", Ar = "line", Un = "label", Yn = "break-parent", $b = /* @__PURE__ */ new Set([ja, Bs, Is, Ra, Rr, Pi, Ci, Ns, _s, Ms, Ar, Un, Yn]);
function P_(t) {
  if (typeof t == "string")
    return Qa;
  if (Array.isArray(t))
    return Ds;
  if (!t)
    return;
  let { type: e } = t;
  if ($b.has(e))
    return e;
}
var Za = P_, F_ = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function $_(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (Za(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let i = F_([...$b].map((n) => `'${n}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${i}.`;
}
var B_ = class extends Error {
  constructor(e) {
    super($_(e));
    Ur(this, "name", "InvalidDocError");
    this.doc = e;
  }
}, Jo = B_, V0 = {};
function I_(t, e, r, i) {
  let n = [t];
  for (; n.length > 0; ) {
    let s = n.pop();
    if (s === V0) {
      r(n.pop());
      continue;
    }
    r && n.push(s, V0);
    let a = Za(s);
    if (!a)
      throw new Jo(s);
    if ((e == null ? void 0 : e(s)) !== !1)
      switch (a) {
        case Ds:
        case Pi: {
          let l = a === Ds ? s : s.parts;
          for (let u = l.length, h = u - 1; h >= 0; --h)
            n.push(l[h]);
          break;
        }
        case Ci:
          n.push(s.flatContents, s.breakContents);
          break;
        case Rr:
          if (i && s.expandedStates)
            for (let l = s.expandedStates.length, u = l - 1; u >= 0; --u)
              n.push(s.expandedStates[u]);
          else
            n.push(s.contents);
          break;
        case Is:
        case Bs:
        case Ns:
        case Un:
        case _s:
          n.push(s.contents);
          break;
        case Qa:
        case ja:
        case Ra:
        case Ms:
        case Ar:
        case Yn:
          break;
        default:
          throw new Jo(s);
      }
  }
}
var Bb = I_, N_ = () => {
}, __ = N_;
function te(t) {
  return { type: Bs, contents: t };
}
function Fi(t, e) {
  return { type: Is, contents: e, n: t };
}
function Z(t, e = {}) {
  return __(e.expandedStates), { type: Rr, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function M_(t) {
  return Fi(Number.NEGATIVE_INFINITY, t);
}
function Ib(t) {
  return Fi(-1, t);
}
function os(t, e) {
  return Z(t[0], { ...e, expandedStates: t });
}
function cg(t) {
  return { type: Pi, parts: t };
}
function Ee(t, e = "", r = {}) {
  return { type: Ci, breakContents: t, flatContents: e, groupId: r.groupId };
}
function Fh(t, e) {
  return { type: Ns, contents: t, groupId: e.groupId, negate: e.negate };
}
function U0(t) {
  return { type: _s, contents: t };
}
var Ui = { type: Ms }, $i = { type: Yn }, Nb = { type: Ar, hard: !0 }, L_ = { type: Ar, hard: !0, literal: !0 }, he = { type: Ar }, H = { type: Ar, soft: !0 }, ee = [Nb, $i], _b = [L_, $i], Y0 = { type: ja };
function Ie(t, e) {
  let r = [];
  for (let i = 0; i < e.length; i++)
    i !== 0 && r.push(t), r.push(e[i]);
  return r;
}
function Q_(t, e, r) {
  let i = t;
  if (e > 0) {
    for (let n = 0; n < Math.floor(e / r); ++n)
      i = te(i);
    i = Fi(e % r, i), i = Fi(Number.NEGATIVE_INFINITY, i);
  }
  return i;
}
function Tl(t, e) {
  return t ? { type: Un, label: t, contents: e } : e;
}
var Mb = (t) => {
  if (Array.isArray(t))
    return t;
  if (t.type !== Pi)
    throw new Error(`Expect doc to be 'array' or '${Pi}'.`);
  return t.parts;
};
function Wa(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return i(t);
  function i(s) {
    if (r.has(s))
      return r.get(s);
    let a = n(s);
    return r.set(s, a), a;
  }
  function n(s) {
    switch (Za(s)) {
      case Ds:
        return e(s.map(i));
      case Pi:
        return e({ ...s, parts: s.parts.map(i) });
      case Ci:
        return e({ ...s, breakContents: i(s.breakContents), flatContents: i(s.flatContents) });
      case Rr: {
        let { expandedStates: a, contents: l } = s;
        return a ? (a = a.map(i), l = a[0]) : l = i(l), e({ ...s, contents: l, expandedStates: a });
      }
      case Is:
      case Bs:
      case Ns:
      case Un:
      case _s:
        return e({ ...s, contents: i(s.contents) });
      case Qa:
      case ja:
      case Ra:
      case Ms:
      case Ar:
      case Yn:
        return e(s);
      default:
        throw new Jo(s);
    }
  }
}
function Lb(t, e, r) {
  let i = r, n = !1;
  function s(a) {
    if (n)
      return !1;
    let l = e(a);
    l !== void 0 && (n = !0, i = l);
  }
  return Bb(t, s), i;
}
function j_(t) {
  if (t.type === Rr && t.break || t.type === Ar && t.hard || t.type === Yn)
    return !0;
}
function Yt(t) {
  return Lb(t, j_, !1);
}
function z0(t) {
  if (t.length > 0) {
    let e = We(!1, t, -1);
    !e.expandedStates && !e.break && (e.break = "propagated");
  }
  return null;
}
function R_(t) {
  let e = /* @__PURE__ */ new Set(), r = [];
  function i(s) {
    if (s.type === Yn && z0(r), s.type === Rr) {
      if (r.push(s), e.has(s))
        return !1;
      e.add(s);
    }
  }
  function n(s) {
    s.type === Rr && r.pop().break && z0(r);
  }
  Bb(t, i, n, !0);
}
function Z_(t) {
  return t.type === Ar && !t.hard ? t.soft ? "" : " " : t.type === Ci ? t.flatContents : t;
}
function Bd(t) {
  return Wa(t, Z_);
}
function W_(t) {
  switch (Za(t)) {
    case Pi:
      if (t.parts.every((e) => e === ""))
        return "";
      break;
    case Rr:
      if (!t.contents && !t.id && !t.break && !t.expandedStates)
        return "";
      if (t.contents.type === Rr && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates)
        return t.contents;
      break;
    case Is:
    case Bs:
    case Ns:
    case _s:
      if (!t.contents)
        return "";
      break;
    case Ci:
      if (!t.flatContents && !t.breakContents)
        return "";
      break;
    case Ds: {
      let e = [];
      for (let r of t) {
        if (!r)
          continue;
        let [i, ...n] = Array.isArray(r) ? r : [r];
        typeof i == "string" && typeof We(!1, e, -1) == "string" ? e[e.length - 1] += i : e.push(i), e.push(...n);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case Qa:
    case ja:
    case Ra:
    case Ms:
    case Ar:
    case Un:
    case Yn:
      break;
    default:
      throw new Jo(t);
  }
  return t;
}
function hg(t) {
  return Wa(t, (e) => W_(e));
}
function bs(t, e = _b) {
  return Wa(t, (r) => typeof r == "string" ? Ie(e, r.split(`
`)) : r);
}
function q_(t) {
  if (t.type === Ar)
    return !0;
}
function X_(t) {
  return Lb(t, q_, !1);
}
function Id(t, e) {
  return t.type === Un ? { ...t, contents: e(t.contents) } : e(t);
}
function V_(t) {
  let e = `*${t.value}*`.split(`
`);
  return e.length > 1 && e.every((r) => r.trimStart()[0] === "*");
}
var U_ = V_;
function Y_(t, e) {
  let r = t.node;
  if (Eh(r))
    return e.originalText.slice(st(r), Ze(r)).trimEnd();
  if (Wr(r))
    return U_(r) ? z_(r) : ["/*", bs(r.value), "*/"];
  throw new Error("Not a comment: " + JSON.stringify(r));
}
function z_(t) {
  let e = t.value.split(`
`);
  return ["/*", Ie(ee, e.map((r, i) => i === 0 ? r.trimEnd() : " " + (i < e.length - 1 ? r.trim() : r.trimStart()))), "*/"];
}
var Qb = {};
Sh(Qb, { endOfLine: () => i4, ownLine: () => r4, remaining: () => n4 });
function G_(t) {
  let e = t.type || t.kind || "(unknown type)", r = String(t.name || t.id && (typeof t.id == "object" ? t.id.name : t.id) || t.key && (typeof t.key == "object" ? t.key.name : t.key) || t.value && (typeof t.value == "object" ? "" : String(t.value)) || t.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + "…"), e + (r ? " " + r : "");
}
function pg(t, e) {
  (t.comments ?? (t.comments = [])).push(e), e.printed = !1, e.nodeDescription = G_(t);
}
function _t(t, e) {
  e.leading = !0, e.trailing = !1, pg(t, e);
}
function Sr(t, e, r) {
  e.leading = !1, e.trailing = !1, r && (e.marker = r), pg(t, e);
}
function ut(t, e) {
  e.leading = !1, e.trailing = !0, pg(t, e);
}
function H_(t, e) {
  let r = null, i = e;
  for (; i !== r; )
    r = i, i = Sa(t, i), i = rg(t, i), i = ig(t, i), i = Ca(t, i);
  return i;
}
var Pl = H_;
function J_(t, e) {
  let r = Pl(t, e);
  return r === !1 ? "" : t.charAt(r);
}
var Yi = J_;
function K_(t, e, r) {
  for (let i = e; i < r; ++i)
    if (t.charAt(i) === `
`)
      return !0;
  return !1;
}
var _n = K_;
function e4(t) {
  return Wr(t) && t.value[0] === "*" && /@(?:type|satisfies)\b/.test(t.value);
}
var t4 = e4;
function r4(t) {
  return [Ub, Rb, qb, a4, dg, fg, jb, Zb, O4, g4, gg, Vb, x4, Wb, Xb, mg, o4, A4].some((e) => e(t));
}
function i4(t) {
  return [s4, qb, Rb, Vb, dg, fg, jb, Zb, Xb, m4, y4, gg, v4, mg, C4, E4].some((e) => e(t));
}
function n4(t) {
  return [Ub, dg, fg, l4, f4, Wb, gg, d4, p4, S4, mg, w4].some((e) => e(t));
}
function Ls(t, e) {
  let r = (t.body || t.properties).find(({ type: i }) => i !== "EmptyStatement");
  r ? _t(r, e) : Sr(t, e);
}
function Nd(t, e) {
  t.type === "BlockStatement" ? Ls(t, e) : _t(t, e);
}
function s4({ comment: t, followingNode: e }) {
  return e && t4(t) ? (_t(e, t), !0) : !1;
}
function dg({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i, text: n }) {
  if ((r == null ? void 0 : r.type) !== "IfStatement" || !i)
    return !1;
  if (Yi(n, Ze(t)) === ")")
    return ut(e, t), !0;
  if (e === r.consequent && i === r.alternate) {
    if (e.type === "BlockStatement")
      ut(e, t);
    else {
      let s = Eh(t) || t.loc.start.line === t.loc.end.line, a = t.loc.start.line === e.loc.start.line;
      s && a ? ut(e, t) : Sr(r, t);
    }
    return !0;
  }
  return i.type === "BlockStatement" ? (Ls(i, t), !0) : i.type === "IfStatement" ? (Nd(i.consequent, t), !0) : r.consequent === i ? (_t(i, t), !0) : !1;
}
function fg({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i, text: n }) {
  return (r == null ? void 0 : r.type) !== "WhileStatement" || !i ? !1 : Yi(n, Ze(t)) === ")" ? (ut(e, t), !0) : i.type === "BlockStatement" ? (Ls(i, t), !0) : r.body === i ? (_t(i, t), !0) : !1;
}
function jb({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i }) {
  return (r == null ? void 0 : r.type) !== "TryStatement" && (r == null ? void 0 : r.type) !== "CatchClause" || !i ? !1 : r.type === "CatchClause" && e ? (ut(e, t), !0) : i.type === "BlockStatement" ? (Ls(i, t), !0) : i.type === "TryStatement" ? (Nd(i.finalizer, t), !0) : i.type === "CatchClause" ? (Nd(i.body, t), !0) : !1;
}
function a4({ comment: t, enclosingNode: e, followingNode: r }) {
  return nt(e) && (r == null ? void 0 : r.type) === "Identifier" ? (_t(e, t), !0) : !1;
}
function o4({ comment: t, enclosingNode: e, followingNode: r, options: i }) {
  return !i.experimentalTernaries || !((e == null ? void 0 : e.type) === "ConditionalExpression" || (e == null ? void 0 : e.type) === "ConditionalTypeAnnotation" || (e == null ? void 0 : e.type) === "TSConditionalType") ? !1 : (r == null ? void 0 : r.type) === "ConditionalExpression" || (r == null ? void 0 : r.type) === "ConditionalTypeAnnotation" || (r == null ? void 0 : r.type) === "TSConditionalType" ? (Sr(e, t), !0) : !1;
}
function Rb({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i, text: n, options: s }) {
  let a = e && !_n(n, Ze(e), st(t));
  return (!e || !a) && ((r == null ? void 0 : r.type) === "ConditionalExpression" || (r == null ? void 0 : r.type) === "ConditionalTypeAnnotation" || (r == null ? void 0 : r.type) === "TSConditionalType") && i ? s.experimentalTernaries && r.alternate === i && !(Wr(t) && !_n(s.originalText, st(t), Ze(t))) ? (Sr(r, t), !0) : (_t(i, t), !0) : !1;
}
function l4({ comment: t, precedingNode: e, enclosingNode: r }) {
  return on(r) && r.shorthand && r.key === e && r.value.type === "AssignmentPattern" ? (ut(r.value.left, t), !0) : !1;
}
var u4 = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
function Zb({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i }) {
  if (u4.has(r == null ? void 0 : r.type)) {
    if (Re(r.decorators) && (i == null ? void 0 : i.type) !== "Decorator")
      return ut(We(!1, r.decorators, -1), t), !0;
    if (r.body && i === r.body)
      return Ls(r.body, t), !0;
    if (i) {
      if (r.superClass && i === r.superClass && e && (e === r.id || e === r.typeParameters))
        return ut(e, t), !0;
      for (let n of ["implements", "extends", "mixins"])
        if (r[n] && i === r[n][0])
          return e && (e === r.id || e === r.typeParameters || e === r.superClass) ? ut(e, t) : Sr(r, t, n), !0;
    }
  }
  return !1;
}
var c4 = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
function Wb({ comment: t, precedingNode: e, enclosingNode: r, text: i }) {
  return r && e && Yi(i, Ze(t)) === "(" && (r.type === "Property" || r.type === "TSDeclareMethod" || r.type === "TSAbstractMethodDefinition") && e.type === "Identifier" && r.key === e && Yi(i, Ze(e)) !== ":" || (e == null ? void 0 : e.type) === "Decorator" && c4.has(r == null ? void 0 : r.type) ? (ut(e, t), !0) : !1;
}
var h4 = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
function p4({ comment: t, precedingNode: e, enclosingNode: r, text: i }) {
  return Yi(i, Ze(t)) !== "(" ? !1 : e && h4.has(r == null ? void 0 : r.type) ? (ut(e, t), !0) : !1;
}
function d4({ comment: t, enclosingNode: e, text: r }) {
  if ((e == null ? void 0 : e.type) !== "ArrowFunctionExpression")
    return !1;
  let i = Pl(r, Ze(t));
  return i !== !1 && r.slice(i, i + 2) === "=>" ? (Sr(e, t), !0) : !1;
}
function f4({ comment: t, enclosingNode: e, text: r }) {
  return Yi(r, Ze(t)) !== ")" ? !1 : e && (Yb(e) && qt(e).length === 0 || Ea(e) && jr(e).length === 0) ? (Sr(e, t), !0) : ((e == null ? void 0 : e.type) === "MethodDefinition" || (e == null ? void 0 : e.type) === "TSAbstractMethodDefinition") && qt(e.value).length === 0 ? (Sr(e.value, t), !0) : !1;
}
function qb({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i, text: n }) {
  return (e == null ? void 0 : e.type) === "FunctionTypeParam" && (r == null ? void 0 : r.type) === "FunctionTypeAnnotation" && (i == null ? void 0 : i.type) !== "FunctionTypeParam" || ((e == null ? void 0 : e.type) === "Identifier" || (e == null ? void 0 : e.type) === "AssignmentPattern" || (e == null ? void 0 : e.type) === "ObjectPattern" || (e == null ? void 0 : e.type) === "ArrayPattern" || (e == null ? void 0 : e.type) === "RestElement" || (e == null ? void 0 : e.type) === "TSParameterProperty") && Yb(r) && Yi(n, Ze(t)) === ")" ? (ut(e, t), !0) : !Wr(t) && ((r == null ? void 0 : r.type) === "FunctionDeclaration" || (r == null ? void 0 : r.type) === "FunctionExpression" || (r == null ? void 0 : r.type) === "ObjectMethod") && (i == null ? void 0 : i.type) === "BlockStatement" && r.body === i && Pl(n, Ze(t)) === st(i) ? (Ls(i, t), !0) : !1;
}
function Xb({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "LabeledStatement" ? (_t(e, t), !0) : !1;
}
function mg({ comment: t, enclosingNode: e }) {
  return ((e == null ? void 0 : e.type) === "ContinueStatement" || (e == null ? void 0 : e.type) === "BreakStatement") && !e.label ? (ut(e, t), !0) : !1;
}
function m4({ comment: t, precedingNode: e, enclosingNode: r }) {
  return Qe(r) && e && r.callee === e && r.arguments.length > 0 ? (_t(r.arguments[0], t), !0) : !1;
}
function g4({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i }) {
  return xs(r) ? (mc(t) && (i.prettierIgnore = !0, t.unignore = !0), e ? (ut(e, t), !0) : !1) : (xs(i) && mc(t) && (i.types[0].prettierIgnore = !0, t.unignore = !0), !1);
}
function y4({ comment: t, enclosingNode: e }) {
  return on(e) ? (_t(e, t), !0) : !1;
}
function gg({ comment: t, enclosingNode: e, followingNode: r, ast: i, isLastComment: n }) {
  var s;
  return ((s = i == null ? void 0 : i.body) == null ? void 0 : s.length) === 0 ? (n ? Sr(i, t) : _t(i, t), !0) : (e == null ? void 0 : e.type) === "Program" && e.body.length === 0 && !Re(e.directives) ? (n ? Sr(e, t) : _t(e, t), !0) : (r == null ? void 0 : r.type) === "Program" && r.body.length === 0 && (e == null ? void 0 : e.type) === "ModuleExpression" ? (Sr(r, t), !0) : !1;
}
function O4({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "ForInStatement" || (e == null ? void 0 : e.type) === "ForOfStatement" ? (_t(e, t), !0) : !1;
}
function Vb({ comment: t, precedingNode: e, enclosingNode: r, text: i }) {
  if ((r == null ? void 0 : r.type) === "ImportSpecifier" || (r == null ? void 0 : r.type) === "ExportSpecifier")
    return _t(r, t), !0;
  let n = (e == null ? void 0 : e.type) === "ImportSpecifier" && (r == null ? void 0 : r.type) === "ImportDeclaration", s = (e == null ? void 0 : e.type) === "ExportSpecifier" && (r == null ? void 0 : r.type) === "ExportNamedDeclaration";
  return (n || s) && wr(i, Ze(t)) ? (ut(e, t), !0) : !1;
}
function x4({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "AssignmentPattern" ? (_t(e, t), !0) : !1;
}
var D4 = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), b4 = /* @__PURE__ */ new Set(["ObjectExpression", "RecordExpression", "ArrayExpression", "TupleExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
function v4({ comment: t, enclosingNode: e, followingNode: r }) {
  return D4.has(e == null ? void 0 : e.type) && r && (b4.has(r.type) || Wr(t)) ? (_t(r, t), !0) : !1;
}
function w4({ comment: t, enclosingNode: e, followingNode: r, text: i }) {
  return !r && ((e == null ? void 0 : e.type) === "TSMethodSignature" || (e == null ? void 0 : e.type) === "TSDeclareFunction" || (e == null ? void 0 : e.type) === "TSAbstractMethodDefinition") && Yi(i, Ze(t)) === ";" ? (ut(e, t), !0) : !1;
}
function Ub({ comment: t, enclosingNode: e, followingNode: r }) {
  if (mc(t) && (e == null ? void 0 : e.type) === "TSMappedType" && (r == null ? void 0 : r.type) === "TSTypeParameter" && r.constraint)
    return e.prettierIgnore = !0, t.unignore = !0, !0;
}
function S4({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i }) {
  return (r == null ? void 0 : r.type) !== "TSMappedType" ? !1 : (i == null ? void 0 : i.type) === "TSTypeParameter" && i.name ? (_t(i.name, t), !0) : (e == null ? void 0 : e.type) === "TSTypeParameter" && e.constraint ? (ut(e.constraint, t), !0) : !1;
}
function C4({ comment: t, enclosingNode: e, followingNode: r }) {
  return !e || e.type !== "SwitchCase" || e.test || !r || r !== e.consequent[0] ? !1 : (r.type === "BlockStatement" && Eh(t) ? Ls(r, t) : Sr(e, t), !0);
}
function E4({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i }) {
  return xs(e) && ((r.type === "TSArrayType" || r.type === "ArrayTypeAnnotation") && !i || Pb(r)) ? (ut(We(!1, e.types, -1), t), !0) : !1;
}
function A4({ comment: t, enclosingNode: e, precedingNode: r, followingNode: i }) {
  if (((e == null ? void 0 : e.type) === "ObjectPattern" || (e == null ? void 0 : e.type) === "ArrayPattern") && (i == null ? void 0 : i.type) === "TSTypeAnnotation")
    return r ? ut(r, t) : Sr(e, t), !0;
}
var Yb = Ue(["ArrowFunctionExpression", "FunctionExpression", "FunctionDeclaration", "ObjectMethod", "ClassMethod", "TSDeclareFunction", "TSCallSignatureDeclaration", "TSConstructSignatureDeclaration", "TSMethodSignature", "TSConstructorType", "TSFunctionType", "TSDeclareMethod"]), k4 = /* @__PURE__ */ new Set(["EmptyStatement", "TemplateElement", "Import", "TSEmptyBodyFunctionExpression", "ChainExpression"]);
function T4(t) {
  return !k4.has(t.type);
}
function P4(t, e) {
  var r;
  if ((e.parser === "typescript" || e.parser === "flow" || e.parser === "acorn" || e.parser === "espree" || e.parser === "meriyah" || e.parser === "__babel_estree") && t.type === "MethodDefinition" && ((r = t.value) == null ? void 0 : r.type) === "FunctionExpression" && qt(t.value).length === 0 && !t.value.returnType && !Re(t.value.typeParameters) && t.value.body)
    return [...t.decorators || [], t.key, t.value.body];
}
function zb(t) {
  let { node: e, parent: r } = t;
  return (bt(e) || r && (r.type === "JSXSpreadAttribute" || r.type === "JSXSpreadChild" || xs(r) || (r.type === "ClassDeclaration" || r.type === "ClassExpression") && r.superClass === e)) && (!Ph(e) || xs(r));
}
function F4(t, { parser: e }) {
  if (e === "flow" || e === "babel-flow")
    return t = xr(!1, t, /[\s(]/g, ""), t === "" || t === "/*" || t === "/*::";
}
function $4(t) {
  switch (t) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
var tr = Symbol("MODE_BREAK"), gi = Symbol("MODE_FLAT"), _o = Symbol("cursor");
function Gb() {
  return { value: "", length: 0, queue: [] };
}
function B4(t, e) {
  return _d(t, { type: "indent" }, e);
}
function I4(t, e, r) {
  return e === Number.NEGATIVE_INFINITY ? t.root || Gb() : e < 0 ? _d(t, { type: "dedent" }, r) : e ? e.type === "root" ? { ...t, root: t } : _d(t, { type: typeof e == "string" ? "stringAlign" : "numberAlign", n: e }, r) : t;
}
function _d(t, e, r) {
  let i = e.type === "dedent" ? t.queue.slice(0, -1) : [...t.queue, e], n = "", s = 0, a = 0, l = 0;
  for (let O of i)
    switch (O.type) {
      case "indent":
        p(), r.useTabs ? u(1) : h(r.tabWidth);
        break;
      case "stringAlign":
        p(), n += O.n, s += O.n.length;
        break;
      case "numberAlign":
        a += 1, l += O.n;
        break;
      default:
        throw new Error(`Unexpected type '${O.type}'`);
    }
  return m(), { ...t, value: n, length: s, queue: i };
  function u(O) {
    n += "	".repeat(O), s += r.tabWidth * O;
  }
  function h(O) {
    n += " ".repeat(O), s += O;
  }
  function p() {
    r.useTabs ? d() : m();
  }
  function d() {
    a > 0 && u(a), y();
  }
  function m() {
    l > 0 && h(l), y();
  }
  function y() {
    a = 0, l = 0;
  }
}
function Md(t) {
  let e = 0, r = 0, i = t.length;
  e:
    for (; i--; ) {
      let n = t[i];
      if (n === _o) {
        r++;
        continue;
      }
      for (let s = n.length - 1; s >= 0; s--) {
        let a = n[s];
        if (a === " " || a === "	")
          e++;
        else {
          t[i] = n.slice(0, s + 1);
          break e;
        }
      }
    }
  if (e > 0 || r > 0)
    for (t.length = i + 1; r-- > 0; )
      t.push(_o);
  return e;
}
function pu(t, e, r, i, n, s) {
  if (r === Number.POSITIVE_INFINITY)
    return !0;
  let a = e.length, l = [t], u = [];
  for (; r >= 0; ) {
    if (l.length === 0) {
      if (a === 0)
        return !0;
      l.push(e[--a]);
      continue;
    }
    let { mode: h, doc: p } = l.pop();
    switch (Za(p)) {
      case Qa:
        u.push(p), r -= wa(p);
        break;
      case Ds:
      case Pi: {
        let d = Mb(p);
        for (let m = d.length - 1; m >= 0; m--)
          l.push({ mode: h, doc: d[m] });
        break;
      }
      case Bs:
      case Is:
      case Ns:
      case Un:
        l.push({ mode: h, doc: p.contents });
        break;
      case Ra:
        r += Md(u);
        break;
      case Rr: {
        if (s && p.break)
          return !1;
        let d = p.break ? tr : h, m = p.expandedStates && d === tr ? We(!1, p.expandedStates, -1) : p.contents;
        l.push({ mode: d, doc: m });
        break;
      }
      case Ci: {
        let d = (p.groupId ? n[p.groupId] || gi : h) === tr ? p.breakContents : p.flatContents;
        d && l.push({ mode: h, doc: d });
        break;
      }
      case Ar:
        if (h === tr || p.hard)
          return !0;
        p.soft || (u.push(" "), r--);
        break;
      case _s:
        i = !0;
        break;
      case Ms:
        if (i)
          return !1;
        break;
    }
  }
  return !1;
}
function Ld(t, e) {
  let r = {}, i = e.printWidth, n = $4(e.endOfLine), s = 0, a = [{ ind: Gb(), mode: tr, doc: t }], l = [], u = !1, h = [], p = 0;
  for (R_(t); a.length > 0; ) {
    let { ind: m, mode: y, doc: O } = a.pop();
    switch (Za(O)) {
      case Qa: {
        let D = n !== `
` ? xr(!1, O, `
`, n) : O;
        l.push(D), a.length > 0 && (s += wa(D));
        break;
      }
      case Ds:
        for (let D = O.length - 1; D >= 0; D--)
          a.push({ ind: m, mode: y, doc: O[D] });
        break;
      case ja:
        if (p >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        l.push(_o), p++;
        break;
      case Bs:
        a.push({ ind: B4(m, e), mode: y, doc: O.contents });
        break;
      case Is:
        a.push({ ind: I4(m, O.n, e), mode: y, doc: O.contents });
        break;
      case Ra:
        s -= Md(l);
        break;
      case Rr:
        switch (y) {
          case gi:
            if (!u) {
              a.push({ ind: m, mode: O.break ? tr : gi, doc: O.contents });
              break;
            }
          case tr: {
            u = !1;
            let D = { ind: m, mode: gi, doc: O.contents }, v = i - s, w = h.length > 0;
            if (!O.break && pu(D, a, v, w, r))
              a.push(D);
            else if (O.expandedStates) {
              let x = We(!1, O.expandedStates, -1);
              if (O.break) {
                a.push({ ind: m, mode: tr, doc: x });
                break;
              } else
                for (let S = 1; S < O.expandedStates.length + 1; S++)
                  if (S >= O.expandedStates.length) {
                    a.push({ ind: m, mode: tr, doc: x });
                    break;
                  } else {
                    let k = O.expandedStates[S], C = { ind: m, mode: gi, doc: k };
                    if (pu(C, a, v, w, r)) {
                      a.push(C);
                      break;
                    }
                  }
            } else
              a.push({ ind: m, mode: tr, doc: O.contents });
            break;
          }
        }
        O.id && (r[O.id] = We(!1, a, -1).mode);
        break;
      case Pi: {
        let D = i - s, { parts: v } = O;
        if (v.length === 0)
          break;
        let [w, x] = v, S = { ind: m, mode: gi, doc: w }, k = { ind: m, mode: tr, doc: w }, C = pu(S, [], D, h.length > 0, r, !0);
        if (v.length === 1) {
          C ? a.push(S) : a.push(k);
          break;
        }
        let A = { ind: m, mode: gi, doc: x }, P = { ind: m, mode: tr, doc: x };
        if (v.length === 2) {
          C ? a.push(A, S) : a.push(P, k);
          break;
        }
        v.splice(0, 2);
        let I = { ind: m, mode: y, doc: cg(v) }, B = v[0];
        pu({ ind: m, mode: gi, doc: [w, x, B] }, [], D, h.length > 0, r, !0) ? a.push(I, A, S) : C ? a.push(I, P, S) : a.push(I, P, k);
        break;
      }
      case Ci:
      case Ns: {
        let D = O.groupId ? r[O.groupId] : y;
        if (D === tr) {
          let v = O.type === Ci ? O.breakContents : O.negate ? O.contents : te(O.contents);
          v && a.push({ ind: m, mode: y, doc: v });
        }
        if (D === gi) {
          let v = O.type === Ci ? O.flatContents : O.negate ? te(O.contents) : O.contents;
          v && a.push({ ind: m, mode: y, doc: v });
        }
        break;
      }
      case _s:
        h.push({ ind: m, mode: y, doc: O.contents });
        break;
      case Ms:
        h.length > 0 && a.push({ ind: m, mode: y, doc: Nb });
        break;
      case Ar:
        switch (y) {
          case gi:
            if (O.hard)
              u = !0;
            else {
              O.soft || (l.push(" "), s += 1);
              break;
            }
          case tr:
            if (h.length > 0) {
              a.push({ ind: m, mode: y, doc: O }, ...h.reverse()), h.length = 0;
              break;
            }
            O.literal ? m.root ? (l.push(n, m.root.value), s = m.root.length) : (l.push(n), s = 0) : (s -= Md(l), l.push(n + m.value), s = m.length);
            break;
        }
        break;
      case Un:
        a.push({ ind: m, mode: y, doc: O.contents });
        break;
      case Yn:
        break;
      default:
        throw new Jo(O);
    }
    a.length === 0 && h.length > 0 && (a.push(...h.reverse()), h.length = 0);
  }
  let d = l.indexOf(_o);
  if (d !== -1) {
    let m = l.indexOf(_o, d + 1), y = l.slice(0, d).join(""), O = l.slice(d + 1, m).join(""), D = l.slice(m + 1).join("");
    return { formatted: y + O + D, cursorNodeStart: y.length, cursorNodeText: O };
  }
  return { formatted: l.join("") };
}
function N4(t, e, r = 0) {
  let i = 0;
  for (let n = r; n < t.length; ++n)
    t[n] === "	" ? i = i + e - i % e : i++;
  return i;
}
var _4 = N4;
function M4(t, e) {
  let r = t.lastIndexOf(`
`);
  return r === -1 ? 0 : _4(t.slice(r + 1).match(/^[\t ]*/)[0], e);
}
var L4 = M4;
function Hb(t, e, r) {
  let { node: i } = t;
  if (i.type === "TemplateLiteral" && Z4(t)) {
    let h = j4(t, r, e);
    if (h)
      return h;
  }
  let n = "expressions";
  i.type === "TSTemplateLiteralType" && (n = "types");
  let s = [], a = t.map(e, n), l = x_(i);
  l && (a = a.map((h) => Ld(h, { ...r, printWidth: Number.POSITIVE_INFINITY }).formatted)), s.push(Ui, "`");
  let u = 0;
  return t.each(({ index: h, node: p }) => {
    if (s.push(e()), p.tail)
      return;
    let { tabWidth: d } = r, m = p.value.raw, y = m.includes(`
`) ? L4(m, d) : u;
    u = y;
    let O = a[h];
    if (!l) {
      let v = i[n][h], w = _n(r.originalText, Ze(p), st(i.quasis[h + 1]));
      if (!w) {
        let x = Ld(O, { ...r, printWidth: Number.POSITIVE_INFINITY }).formatted;
        x.includes(`
`) ? w = !0 : O = x;
      }
      w && (se(v) || nt(v) || v.type === "ConditionalExpression" || v.type === "SequenceExpression" || bi(v) || Vi(v)) && (O = [te([H, O]), H]);
    }
    let D = y === 0 && m.endsWith(`
`) ? Fi(Number.NEGATIVE_INFINITY, O) : Q_(O, y, d);
    s.push(Z(["${", D, Ui, "}"]));
  }, "quasis"), s.push("`"), s;
}
function Q4(t) {
  let e = t("quasi");
  return Tl(e.label && { tagged: !0, ...e.label }, [t("tag"), t("typeParameters"), Ui, e]);
}
function j4(t, e, r) {
  let { node: i } = t, n = i.quasis[0].value.raw.trim().split(/\s*\|\s*/);
  if (n.length > 1 || n.some((s) => s.length > 0)) {
    e.__inJestEach = !0;
    let s = t.map(r, "expressions");
    e.__inJestEach = !1;
    let a = [], l = s.map((m) => "${" + Ld(m, { ...e, printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" }).formatted + "}"), u = [{ hasLineBreak: !1, cells: [] }];
    for (let m = 1; m < i.quasis.length; m++) {
      let y = We(!1, u, -1), O = l[m - 1];
      y.cells.push(O), O.includes(`
`) && (y.hasLineBreak = !0), i.quasis[m].value.raw.includes(`
`) && u.push({ hasLineBreak: !1, cells: [] });
    }
    let h = Math.max(n.length, ...u.map((m) => m.cells.length)), p = Array.from({ length: h }).fill(0), d = [{ cells: n }, ...u.filter((m) => m.cells.length > 0)];
    for (let { cells: m } of d.filter((y) => !y.hasLineBreak))
      for (let [y, O] of m.entries())
        p[y] = Math.max(p[y], wa(O));
    return a.push(Ui, "`", te([ee, Ie(ee, d.map((m) => Ie(" | ", m.cells.map((y, O) => m.hasLineBreak ? y : y + " ".repeat(p[O] - wa(y))))))]), ee, "`"), a;
  }
}
function R4(t, e) {
  let { node: r } = t, i = e();
  return se(r) && (i = Z([te([H, i]), H])), ["${", i, Ui, "}"];
}
function yg(t, e) {
  return t.map((r) => R4(r, e), "expressions");
}
function Jb(t, e) {
  return Wa(t, (r) => typeof r == "string" ? e ? xr(!1, r, /(\\*)`/g, "$1$1\\`") : Kb(r) : r);
}
function Kb(t) {
  return xr(!1, t, /([\\`]|\${)/g, "\\$1");
}
function Z4({ node: t, parent: e }) {
  let r = /^[fx]?(?:describe|it|test)$/;
  return e.type === "TaggedTemplateExpression" && e.quasi === t && e.tag.type === "MemberExpression" && e.tag.property.type === "Identifier" && e.tag.property.name === "each" && (e.tag.object.type === "Identifier" && r.test(e.tag.object.name) || e.tag.object.type === "MemberExpression" && e.tag.object.property.type === "Identifier" && (e.tag.object.property.name === "only" || e.tag.object.property.name === "skip") && e.tag.object.object.type === "Identifier" && r.test(e.tag.object.object.name));
}
var Qd = [(t, e) => t.type === "ObjectExpression" && e === "properties", (t, e) => t.type === "CallExpression" && t.callee.type === "Identifier" && t.callee.name === "Component" && e === "arguments", (t, e) => t.type === "Decorator" && e === "expression"];
function W4(t) {
  let e = (i) => i.type === "TemplateLiteral", r = (i, n) => on(i) && !i.computed && i.key.type === "Identifier" && i.key.name === "styles" && n === "value";
  return t.match(e, (i, n) => Nt(i) && n === "elements", r, ...Qd) || t.match(e, r, ...Qd);
}
function q4(t) {
  return t.match((e) => e.type === "TemplateLiteral", (e, r) => on(e) && !e.computed && e.key.type === "Identifier" && e.key.name === "template" && r === "value", ...Qd);
}
function G0(t, e) {
  return se(t, de.Block | de.Leading, ({ value: r }) => r === ` ${e} `);
}
function ev({ node: t, parent: e }, r) {
  return G0(t, r) || X4(e) && G0(e, r);
}
function X4(t) {
  return t.type === "AsConstExpression" || t.type === "TSAsExpression" && t.typeAnnotation.type === "TSTypeReference" && t.typeAnnotation.typeName.type === "Identifier" && t.typeAnnotation.typeName.name === "const";
}
async function V4(t, e, r) {
  let { node: i } = r, n = i.quasis.map((p) => p.value.raw), s = 0, a = n.reduce((p, d, m) => m === 0 ? d : p + "@prettier-placeholder-" + s++ + "-id" + d, ""), l = await t(a, { parser: "scss" }), u = yg(r, e), h = U4(l, u);
  if (!h)
    throw new Error("Couldn't insert all the expressions");
  return ["`", te([ee, h]), H, "`"];
}
function U4(t, e) {
  if (!Re(e))
    return t;
  let r = 0, i = Wa(hg(t), (n) => typeof n != "string" || !n.includes("@prettier-placeholder") ? n : n.split(/@prettier-placeholder-(\d+)-id/).map((s, a) => a % 2 === 0 ? bs(s) : (r++, e[s])));
  return e.length === r ? i : null;
}
function Y4({ node: t, parent: e, grandparent: r }) {
  return r && t.quasis && e.type === "JSXExpressionContainer" && r.type === "JSXElement" && r.openingElement.name.name === "style" && r.openingElement.attributes.some((i) => i.type === "JSXAttribute" && i.name.name === "jsx") || (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && e.tag.type === "Identifier" && e.tag.name === "css" || (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && e.tag.type === "MemberExpression" && e.tag.object.name === "css" && (e.tag.property.name === "global" || e.tag.property.name === "resolve");
}
function du(t) {
  return t.type === "Identifier" && t.name === "styled";
}
function H0(t) {
  return /^[A-Z]/.test(t.object.name) && t.property.name === "extend";
}
function z4({ parent: t }) {
  if (!t || t.type !== "TaggedTemplateExpression")
    return !1;
  let e = t.tag.type === "ParenthesizedExpression" ? t.tag.expression : t.tag;
  switch (e.type) {
    case "MemberExpression":
      return du(e.object) || H0(e);
    case "CallExpression":
      return du(e.callee) || e.callee.type === "MemberExpression" && (e.callee.object.type === "MemberExpression" && (du(e.callee.object.object) || H0(e.callee.object)) || e.callee.object.type === "CallExpression" && du(e.callee.object.callee));
    case "Identifier":
      return e.name === "css";
    default:
      return !1;
  }
}
function G4({ parent: t, grandparent: e }) {
  return (e == null ? void 0 : e.type) === "JSXAttribute" && t.type === "JSXExpressionContainer" && e.name.type === "JSXIdentifier" && e.name.name === "css";
}
function H4(t) {
  if (Y4(t) || z4(t) || G4(t) || W4(t))
    return V4;
}
var J4 = H4;
async function K4(t, e, r) {
  let { node: i } = r, n = i.quasis.length, s = yg(r, e), a = [];
  for (let l = 0; l < n; l++) {
    let u = i.quasis[l], h = l === 0, p = l === n - 1, d = u.value.cooked, m = d.split(`
`), y = m.length, O = s[l], D = y > 2 && m[0].trim() === "" && m[1].trim() === "", v = y > 2 && m[y - 1].trim() === "" && m[y - 2].trim() === "", w = m.every((S) => /^\s*(?:#[^\n\r]*)?$/.test(S));
    if (!p && /#[^\n\r]*$/.test(m[y - 1]))
      return null;
    let x = null;
    w ? x = e6(m) : x = await t(d, { parser: "graphql" }), x ? (x = Jb(x, !1), !h && D && a.push(""), a.push(x), !p && v && a.push("")) : !h && !p && D && a.push(""), O && a.push(O);
  }
  return ["`", te([ee, Ie(ee, a)]), ee, "`"];
}
function e6(t) {
  let e = [], r = !1, i = t.map((n) => n.trim());
  for (let [n, s] of i.entries())
    s !== "" && (i[n - 1] === "" && r ? e.push([ee, s]) : e.push(s), r = !0);
  return e.length === 0 ? null : Ie(ee, e);
}
function t6({ node: t, parent: e }) {
  return ev({ node: t, parent: e }, "GraphQL") || e && (e.type === "TaggedTemplateExpression" && (e.tag.type === "MemberExpression" && e.tag.object.name === "graphql" && e.tag.property.name === "experimental" || e.tag.type === "Identifier" && (e.tag.name === "gql" || e.tag.name === "graphql")) || e.type === "CallExpression" && e.callee.type === "Identifier" && e.callee.name === "graphql");
}
function r6(t) {
  if (t6(t))
    return K4;
}
var i6 = r6, Ap = 0;
async function tv(t, e, r, i, n) {
  let { node: s } = i, a = Ap;
  Ap = Ap + 1 >>> 0;
  let l = (w) => `PRETTIER_HTML_PLACEHOLDER_${w}_${a}_IN_JS`, u = s.quasis.map((w, x, S) => x === S.length - 1 ? w.value.cooked : w.value.cooked + l(x)).join(""), h = yg(i, r), p = new RegExp(l("(\\d+)"), "g"), d = 0, m = await e(u, { parser: t, __onHtmlRoot(w) {
    d = w.children.length;
  } }), y = Wa(m, (w) => {
    if (typeof w != "string")
      return w;
    let x = [], S = w.split(p);
    for (let k = 0; k < S.length; k++) {
      let C = S[k];
      if (k % 2 === 0) {
        C && (C = Kb(C), n.__embeddedInHtml && (C = xr(!1, C, /<\/(?=script\b)/gi, "<\\/")), x.push(C));
        continue;
      }
      let A = Number(C);
      x.push(h[A]);
    }
    return x;
  }), O = /^\s/.test(u) ? " " : "", D = /\s$/.test(u) ? " " : "", v = n.htmlWhitespaceSensitivity === "ignore" ? ee : O && D ? he : null;
  return v ? Z(["`", te([v, Z(y)]), v, "`"]) : Tl({ hug: !1 }, Z(["`", O, d > 1 ? te(Z(y)) : Z(y), D, "`"]));
}
function n6(t) {
  return ev(t, "HTML") || t.match((e) => e.type === "TemplateLiteral", (e, r) => e.type === "TaggedTemplateExpression" && e.tag.type === "Identifier" && e.tag.name === "html" && r === "quasi");
}
var s6 = tv.bind(void 0, "html"), a6 = tv.bind(void 0, "angular");
function o6(t) {
  if (n6(t))
    return s6;
  if (q4(t))
    return a6;
}
var l6 = o6;
async function u6(t, e, r) {
  let { node: i } = r, n = xr(!1, i.quasis[0].value.raw, /((?:\\\\)*)\\`/g, (u, h) => "\\".repeat(h.length / 2) + "`"), s = c6(n), a = s !== "";
  a && (n = xr(!1, n, new RegExp(`^${s}`, "gm"), ""));
  let l = Jb(await t(n, { parser: "markdown", __inJsTemplate: !0 }), !0);
  return ["`", a ? te([H, l]) : [_b, M_(l)], H, "`"];
}
function c6(t) {
  let e = t.match(/^([^\S\n]*)\S/m);
  return e === null ? "" : e[1];
}
function h6(t) {
  if (p6(t))
    return u6;
}
function p6({ node: t, parent: e }) {
  return (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && t.quasis.length === 1 && e.tag.type === "Identifier" && (e.tag.name === "md" || e.tag.name === "markdown");
}
var d6 = h6;
function f6(t) {
  let { node: e } = t;
  if (e.type !== "TemplateLiteral" || m6(e))
    return;
  let r;
  for (let i of [J4, i6, l6, d6])
    if (r = i(t), !!r)
      return e.quasis.length === 1 && e.quasis[0].value.raw.trim() === "" ? "``" : async (...n) => {
        let s = await r(...n);
        return s && Tl({ embed: !0, ...s.label }, s);
      };
}
function m6({ quasis: t }) {
  return t.some(({ value: { cooked: e } }) => e === null);
}
var g6 = f6, gc = O7(b7(), 1);
function y6(t) {
  if (!t.startsWith("#!"))
    return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var O6 = y6;
function x6(t) {
  let e = O6(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, gc.extract)(t), { pragmas: i, comments: n } = (0, gc.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: i, comments: n };
}
function D6(t) {
  let { shebang: e, text: r, pragmas: i, comments: n } = x6(t), s = (0, gc.strip)(r), a = (0, gc.print)({ pragmas: { format: "", ...i }, comments: n.trimStart() });
  return (e ? `${e}
` : "") + a + (s.startsWith(`
`) ? `
` : `

`) + s;
}
function b6(t, e) {
  let { originalText: r, [Symbol.for("comments")]: i, locStart: n, locEnd: s, [Symbol.for("printedComments")]: a } = e, { node: l } = t, u = n(l), h = s(l);
  for (let p of i)
    n(p) >= u && s(p) <= h && a.add(p);
  return r.slice(u, h);
}
var v6 = b6;
function jd(t, e) {
  var r, i, n, s, a, l, u;
  if (t.isRoot)
    return !1;
  let { node: h, key: p, parent: d } = t;
  if (e.__isInHtmlInterpolation && !e.bracketSpacing && E6(h) && bo(t))
    return !0;
  if (w6(h))
    return !1;
  if (h.type === "Identifier") {
    if ((r = h.extra) != null && r.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(h.name) || p === "left" && (h.name === "async" && !d.await || h.name === "let") && d.type === "ForOfStatement")
      return !0;
    if (h.name === "let") {
      let m = (i = t.findAncestor((y) => y.type === "ForOfStatement")) == null ? void 0 : i.left;
      if (m && Ut(m, (y) => y === h))
        return !0;
    }
    if (p === "object" && h.name === "let" && d.type === "MemberExpression" && d.computed && !d.optional) {
      let m = t.findAncestor((O) => O.type === "ExpressionStatement" || O.type === "ForStatement" || O.type === "ForInStatement"), y = m ? m.type === "ExpressionStatement" ? m.expression : m.type === "ForStatement" ? m.init : m.left : void 0;
      if (y && Ut(y, (O) => O === h))
        return !0;
    }
    if (p === "expression")
      switch (h.name) {
        case "await":
        case "interface":
        case "module":
        case "using":
        case "yield":
        case "let":
        case "type": {
          let m = t.findAncestor((y) => !bi(y));
          if (m !== d && m.type === "ExpressionStatement")
            return !0;
        }
      }
    return !1;
  }
  if (h.type === "ObjectExpression" || h.type === "FunctionExpression" || h.type === "ClassExpression" || h.type === "DoExpression") {
    let m = (n = t.findAncestor((y) => y.type === "ExpressionStatement")) == null ? void 0 : n.expression;
    if (m && Ut(m, (y) => y === h))
      return !0;
  }
  if (h.type === "ObjectExpression") {
    let m = (s = t.findAncestor((y) => y.type === "ArrowFunctionExpression")) == null ? void 0 : s.body;
    if (m && m.type !== "SequenceExpression" && m.type !== "AssignmentExpression" && Ut(m, (y) => y === h))
      return !0;
  }
  switch (d.type) {
    case "ParenthesizedExpression":
      return !1;
    case "ClassDeclaration":
    case "ClassExpression":
      if (p === "superClass" && (h.type === "ArrowFunctionExpression" || h.type === "AssignmentExpression" || h.type === "AwaitExpression" || h.type === "BinaryExpression" || h.type === "ConditionalExpression" || h.type === "LogicalExpression" || h.type === "NewExpression" || h.type === "ObjectExpression" || h.type === "SequenceExpression" || h.type === "TaggedTemplateExpression" || h.type === "UnaryExpression" || h.type === "UpdateExpression" || h.type === "YieldExpression" || h.type === "TSNonNullExpression" || h.type === "ClassExpression" && Re(h.decorators)))
        return !0;
      break;
    case "ExportDefaultDeclaration":
      return rv(t, e) || h.type === "SequenceExpression";
    case "Decorator":
      if (p === "expression") {
        if (nt(h) && h.computed)
          return !0;
        let m = !1, y = !1, O = h;
        for (; O; )
          switch (O.type) {
            case "MemberExpression":
              y = !0, O = O.object;
              break;
            case "CallExpression":
              if (y || m)
                return e.parser !== "typescript";
              m = !0, O = O.callee;
              break;
            case "Identifier":
              return !1;
            case "TaggedTemplateExpression":
              return e.parser !== "typescript";
            default:
              return !0;
          }
        return !0;
      }
      break;
    case "TypeAnnotation":
      if (t.match(void 0, void 0, (m, y) => y === "returnType" && m.type === "ArrowFunctionExpression") && C6(h))
        return !0;
      break;
    case "BinaryExpression":
      if (p === "left" && (d.operator === "in" || d.operator === "instanceof") && h.type === "UnaryExpression")
        return !0;
      break;
  }
  switch (h.type) {
    case "UpdateExpression":
      if (d.type === "UnaryExpression")
        return h.prefix && (h.operator === "++" && d.operator === "+" || h.operator === "--" && d.operator === "-");
    case "UnaryExpression":
      switch (d.type) {
        case "UnaryExpression":
          return h.operator === d.operator && (h.operator === "+" || h.operator === "-");
        case "BindExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return p === "object";
        case "TaggedTemplateExpression":
          return !0;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return p === "callee";
        case "BinaryExpression":
          return p === "left" && d.operator === "**";
        case "TSNonNullExpression":
          return !0;
        default:
          return !1;
      }
    case "BinaryExpression":
      if (d.type === "UpdateExpression" || h.operator === "in" && S6(t))
        return !0;
      if (h.operator === "|>" && (a = h.extra) != null && a.parenthesized) {
        let m = t.grandparent;
        if (m.type === "BinaryExpression" && m.operator === "|>")
          return !0;
      }
    case "TSTypeAssertion":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
    case "LogicalExpression":
      switch (d.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
          return !bi(h);
        case "ConditionalExpression":
          return bi(h);
        case "CallExpression":
        case "NewExpression":
        case "OptionalCallExpression":
          return p === "callee";
        case "ClassExpression":
        case "ClassDeclaration":
          return p === "superClass";
        case "TSTypeAssertion":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "JSXSpreadAttribute":
        case "SpreadElement":
        case "BindExpression":
        case "AwaitExpression":
        case "TSNonNullExpression":
        case "UpdateExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return p === "object";
        case "AssignmentExpression":
        case "AssignmentPattern":
          return p === "left" && (h.type === "TSTypeAssertion" || bi(h));
        case "LogicalExpression":
          if (h.type === "LogicalExpression")
            return d.operator !== h.operator;
        case "BinaryExpression": {
          let { operator: m, type: y } = h;
          if (!m && y !== "TSTypeAssertion")
            return !0;
          let O = fc(m), D = d.operator, v = fc(D);
          return v > O || p === "right" && v === O || v === O && !lg(D, m) ? !0 : v < O && m === "%" ? D === "+" || D === "-" : !!C_(D);
        }
        default:
          return !1;
      }
    case "SequenceExpression":
      switch (d.type) {
        case "ReturnStatement":
          return !1;
        case "ForStatement":
          return !1;
        case "ExpressionStatement":
          return p !== "expression";
        case "ArrowFunctionExpression":
          return p !== "body";
        default:
          return !0;
      }
    case "YieldExpression":
      if (d.type === "AwaitExpression")
        return !0;
    case "AwaitExpression":
      switch (d.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "SpreadElement":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "BindExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return p === "object";
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return p === "callee";
        case "ConditionalExpression":
          return p === "test";
        case "BinaryExpression":
          return !(!h.argument && d.operator === "|>");
        default:
          return !1;
      }
    case "TSFunctionType":
      if (t.match((m) => m.type === "TSFunctionType", (m, y) => y === "typeAnnotation" && m.type === "TSTypeAnnotation", (m, y) => y === "returnType" && m.type === "ArrowFunctionExpression"))
        return !0;
    case "TSConditionalType":
    case "TSConstructorType":
      if (p === "extendsType" && d.type === "TSConditionalType") {
        if (h.type === "TSConditionalType")
          return !0;
        let { typeAnnotation: m } = h.returnType || h.typeAnnotation;
        if (m.type === "TSTypePredicate" && m.typeAnnotation && (m = m.typeAnnotation.typeAnnotation), m.type === "TSInferType" && m.typeParameter.constraint)
          return !0;
      }
      if (p === "checkType" && d.type === "TSConditionalType")
        return !0;
    case "TSUnionType":
    case "TSIntersectionType":
      if ((d.type === "TSUnionType" || d.type === "TSIntersectionType") && d.types.length > 1 && (!h.types || h.types.length > 1))
        return !0;
    case "TSInferType":
      if (h.type === "TSInferType" && d.type === "TSRestType")
        return !1;
    case "TSTypeOperator":
      return d.type === "TSArrayType" || d.type === "TSOptionalType" || d.type === "TSRestType" || p === "objectType" && d.type === "TSIndexedAccessType" || d.type === "TSTypeOperator" || d.type === "TSTypeAnnotation" && t.grandparent.type.startsWith("TSJSDoc");
    case "TSTypeQuery":
      return p === "objectType" && d.type === "TSIndexedAccessType" || p === "elementType" && d.type === "TSArrayType";
    case "TypeofTypeAnnotation":
      return p === "objectType" && (d.type === "IndexedAccessType" || d.type === "OptionalIndexedAccessType") || p === "elementType" && d.type === "ArrayTypeAnnotation";
    case "ArrayTypeAnnotation":
      return d.type === "NullableTypeAnnotation";
    case "IntersectionTypeAnnotation":
    case "UnionTypeAnnotation":
      return d.type === "ArrayTypeAnnotation" || d.type === "NullableTypeAnnotation" || d.type === "IntersectionTypeAnnotation" || d.type === "UnionTypeAnnotation" || p === "objectType" && (d.type === "IndexedAccessType" || d.type === "OptionalIndexedAccessType");
    case "InferTypeAnnotation":
    case "NullableTypeAnnotation":
      return d.type === "ArrayTypeAnnotation" || p === "objectType" && (d.type === "IndexedAccessType" || d.type === "OptionalIndexedAccessType");
    case "FunctionTypeAnnotation": {
      if (t.match(void 0, (y, O) => O === "typeAnnotation" && y.type === "TypeAnnotation", (y, O) => O === "returnType" && y.type === "ArrowFunctionExpression") || t.match(void 0, (y, O) => O === "typeAnnotation" && y.type === "TypePredicate", (y, O) => O === "typeAnnotation" && y.type === "TypeAnnotation", (y, O) => O === "returnType" && y.type === "ArrowFunctionExpression"))
        return !0;
      let m = d.type === "NullableTypeAnnotation" ? t.grandparent : d;
      return m.type === "UnionTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "ArrayTypeAnnotation" || p === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType") || p === "checkType" && d.type === "ConditionalTypeAnnotation" || p === "extendsType" && d.type === "ConditionalTypeAnnotation" && h.returnType.type === "InferTypeAnnotation" && h.returnType.typeParameter.bound || m.type === "NullableTypeAnnotation" || d.type === "FunctionTypeParam" && d.name === null && qt(h).some((y) => {
        var O;
        return ((O = y.typeAnnotation) == null ? void 0 : O.type) === "NullableTypeAnnotation";
      });
    }
    case "ConditionalTypeAnnotation":
      if (p === "extendsType" && d.type === "ConditionalTypeAnnotation" && h.type === "ConditionalTypeAnnotation" || p === "checkType" && d.type === "ConditionalTypeAnnotation")
        return !0;
    case "OptionalIndexedAccessType":
      return p === "objectType" && d.type === "IndexedAccessType";
    case "StringLiteral":
    case "NumericLiteral":
    case "Literal":
      if (typeof h.value == "string" && d.type === "ExpressionStatement" && !d.directive) {
        let m = t.grandparent;
        return m.type === "Program" || m.type === "BlockStatement";
      }
      return p === "object" && d.type === "MemberExpression" && typeof h.value == "number";
    case "AssignmentExpression": {
      let m = t.grandparent;
      return p === "body" && d.type === "ArrowFunctionExpression" ? !0 : p === "key" && (d.type === "ClassProperty" || d.type === "PropertyDefinition") && d.computed || (p === "init" || p === "update") && d.type === "ForStatement" ? !1 : d.type === "ExpressionStatement" ? h.left.type === "ObjectPattern" : !(p === "key" && d.type === "TSPropertySignature" || d.type === "AssignmentExpression" || d.type === "SequenceExpression" && m.type === "ForStatement" && (m.init === d || m.update === d) || p === "value" && d.type === "Property" && m.type === "ObjectPattern" && m.properties.includes(d) || d.type === "NGChainedExpression");
    }
    case "ConditionalExpression":
      switch (d.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "BinaryExpression":
        case "LogicalExpression":
        case "NGPipeExpression":
        case "ExportDefaultDeclaration":
        case "AwaitExpression":
        case "JSXSpreadAttribute":
        case "TSTypeAssertion":
        case "TypeCastExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "TSNonNullExpression":
          return !0;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return p === "callee";
        case "ConditionalExpression":
          return e.experimentalTernaries ? !1 : p === "test";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return p === "object";
        default:
          return !1;
      }
    case "FunctionExpression":
      switch (d.type) {
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return p === "callee";
        case "TaggedTemplateExpression":
          return !0;
        default:
          return !1;
      }
    case "ArrowFunctionExpression":
      switch (d.type) {
        case "BinaryExpression":
          return d.operator !== "|>" || ((l = h.extra) == null ? void 0 : l.parenthesized);
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return p === "callee";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return p === "object";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "TSNonNullExpression":
        case "BindExpression":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "AwaitExpression":
        case "TSTypeAssertion":
          return !0;
        case "ConditionalExpression":
          return p === "test";
        default:
          return !1;
      }
    case "ClassExpression":
      switch (d.type) {
        case "NewExpression":
          return p === "callee";
        default:
          return !1;
      }
    case "OptionalMemberExpression":
    case "OptionalCallExpression":
    case "CallExpression":
    case "MemberExpression":
      if (A6(t))
        return !0;
    case "TaggedTemplateExpression":
    case "TSNonNullExpression":
      if (p === "callee" && (d.type === "BindExpression" || d.type === "NewExpression")) {
        let m = h;
        for (; m; )
          switch (m.type) {
            case "CallExpression":
            case "OptionalCallExpression":
              return !0;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "BindExpression":
              m = m.object;
              break;
            case "TaggedTemplateExpression":
              m = m.tag;
              break;
            case "TSNonNullExpression":
              m = m.expression;
              break;
            default:
              return !1;
          }
      }
      return !1;
    case "BindExpression":
      return p === "callee" && (d.type === "BindExpression" || d.type === "NewExpression") || p === "object" && nt(d);
    case "NGPipeExpression":
      return !(d.type === "NGRoot" || d.type === "NGMicrosyntaxExpression" || d.type === "ObjectProperty" && !((u = h.extra) != null && u.parenthesized) || Nt(d) || p === "arguments" && Qe(d) || p === "right" && d.type === "NGPipeExpression" || p === "property" && d.type === "MemberExpression" || d.type === "AssignmentExpression");
    case "JSXFragment":
    case "JSXElement":
      return p === "callee" || p === "left" && d.type === "BinaryExpression" && d.operator === "<" || !Nt(d) && d.type !== "ArrowFunctionExpression" && d.type !== "AssignmentExpression" && d.type !== "AssignmentPattern" && d.type !== "BinaryExpression" && d.type !== "NewExpression" && d.type !== "ConditionalExpression" && d.type !== "ExpressionStatement" && d.type !== "JsExpressionRoot" && d.type !== "JSXAttribute" && d.type !== "JSXElement" && d.type !== "JSXExpressionContainer" && d.type !== "JSXFragment" && d.type !== "LogicalExpression" && !Qe(d) && !on(d) && d.type !== "ReturnStatement" && d.type !== "ThrowStatement" && d.type !== "TypeCastExpression" && d.type !== "VariableDeclarator" && d.type !== "YieldExpression";
    case "TSInstantiationExpression":
      return p === "object" && nt(d);
  }
  return !1;
}
var w6 = Ue(["BlockStatement", "BreakStatement", "ClassBody", "ClassDeclaration", "ClassMethod", "ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ContinueStatement", "DebuggerStatement", "DeclareClass", "DeclareExportAllDeclaration", "DeclareExportDeclaration", "DeclareFunction", "DeclareInterface", "DeclareModule", "DeclareModuleExports", "DeclareVariable", "DeclareEnum", "DoWhileStatement", "EnumDeclaration", "ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FunctionDeclaration", "IfStatement", "ImportDeclaration", "InterfaceDeclaration", "LabeledStatement", "MethodDefinition", "ReturnStatement", "SwitchStatement", "ThrowStatement", "TryStatement", "TSDeclareFunction", "TSEnumDeclaration", "TSImportEqualsDeclaration", "TSInterfaceDeclaration", "TSModuleDeclaration", "TSNamespaceExportDeclaration", "TypeAlias", "VariableDeclaration", "WhileStatement", "WithStatement"]);
function S6(t) {
  let e = 0, { node: r } = t;
  for (; r; ) {
    let i = t.getParentNode(e++);
    if ((i == null ? void 0 : i.type) === "ForStatement" && i.init === r)
      return !0;
    r = i;
  }
  return !1;
}
function C6(t) {
  return Pd(t, (e) => e.type === "ObjectTypeAnnotation" && Pd(e, (r) => r.type === "FunctionTypeAnnotation"));
}
function E6(t) {
  return ni(t);
}
function bo(t) {
  let { parent: e, key: r } = t;
  switch (e.type) {
    case "NGPipeExpression":
      if (r === "arguments" && t.isLast)
        return t.callParent(bo);
      break;
    case "ObjectProperty":
      if (r === "value")
        return t.callParent(() => t.key === "properties" && t.isLast);
      break;
    case "BinaryExpression":
    case "LogicalExpression":
      if (r === "right")
        return t.callParent(bo);
      break;
    case "ConditionalExpression":
      if (r === "alternate")
        return t.callParent(bo);
      break;
    case "UnaryExpression":
      if (e.prefix)
        return t.callParent(bo);
      break;
  }
  return !1;
}
function rv(t, e) {
  let { node: r, parent: i } = t;
  return r.type === "FunctionExpression" || r.type === "ClassExpression" ? i.type === "ExportDefaultDeclaration" || !jd(t, e) : !sg(r) || i.type !== "ExportDefaultDeclaration" && jd(t, e) ? !1 : t.call(() => rv(t, e), ...yb(r));
}
function A6(t) {
  let { node: e, parent: r, grandparent: i, key: n } = t;
  return !!((e.type === "OptionalMemberExpression" || e.type === "OptionalCallExpression") && (n === "object" && r.type === "MemberExpression" || n === "callee" && (r.type === "CallExpression" || r.type === "NewExpression") || r.type === "TSNonNullExpression" && i.type === "MemberExpression" && i.object === r) || t.match(() => e.type === "CallExpression" || e.type === "MemberExpression", (s, a) => a === "expression" && s.type === "ChainExpression") && (t.match(void 0, void 0, (s, a) => a === "callee" && (s.type === "CallExpression" && !s.optional || s.type === "NewExpression") || a === "object" && s.type === "MemberExpression" && !s.optional) || t.match(void 0, void 0, (s, a) => a === "expression" && s.type === "TSNonNullExpression", (s, a) => a === "object" && s.type === "MemberExpression")) || t.match(() => e.type === "CallExpression" || e.type === "MemberExpression", (s, a) => a === "expression" && s.type === "TSNonNullExpression", (s, a) => a === "expression" && s.type === "ChainExpression", (s, a) => a === "object" && s.type === "MemberExpression"));
}
var Qs = jd;
function k6(t, e) {
  let r = e - 1;
  r = Sa(t, r, { backwards: !0 }), r = Ca(t, r, { backwards: !0 }), r = Sa(t, r, { backwards: !0 });
  let i = Ca(t, r, { backwards: !0 });
  return r !== i;
}
var T6 = k6, P6 = () => !0;
function Og(t, e) {
  let r = t.node;
  return r.printed = !0, e.printer.printComment(t, e);
}
function F6(t, e) {
  var r;
  let i = t.node, n = [Og(t, e)], { printer: s, originalText: a, locStart: l, locEnd: u } = e;
  if ((r = s.isBlockComment) != null && r.call(s, i)) {
    let p = wr(a, u(i)) ? wr(a, l(i), { backwards: !0 }) ? ee : he : " ";
    n.push(p);
  } else
    n.push(ee);
  let h = Ca(a, Sa(a, u(i)));
  return h !== !1 && wr(a, h) && n.push(ee), n;
}
function $6(t, e, r) {
  var i;
  let n = t.node, s = Og(t, e), { printer: a, originalText: l, locStart: u } = e, h = (i = a.isBlockComment) == null ? void 0 : i.call(a, n);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || wr(l, u(n), { backwards: !0 })) {
    let p = T6(l, u(n));
    return { doc: U0([ee, p ? ee : "", s]), isBlock: h, hasLineSuffix: !0 };
  }
  return !h || r != null && r.hasLineSuffix ? { doc: [U0([" ", s]), $i], isBlock: h, hasLineSuffix: !0 } : { doc: [" ", s], isBlock: h, hasLineSuffix: !1 };
}
function at(t, e, r = {}) {
  let { node: i } = t;
  if (!Re(i == null ? void 0 : i.comments))
    return "";
  let { indent: n = !1, marker: s, filter: a = P6 } = r, l = [];
  if (t.each(({ node: h }) => {
    h.leading || h.trailing || h.marker !== s || !a(h) || l.push(Og(t, e));
  }, "comments"), l.length === 0)
    return "";
  let u = Ie(ee, l);
  return n ? te([ee, u]) : u;
}
function iv(t, e) {
  let r = t.node;
  if (!r)
    return {};
  let i = e[Symbol.for("printedComments")];
  if ((r.comments || []).filter((l) => !i.has(l)).length === 0)
    return { leading: "", trailing: "" };
  let n = [], s = [], a;
  return t.each(() => {
    let l = t.node;
    if (i != null && i.has(l))
      return;
    let { leading: u, trailing: h } = l;
    u ? n.push(F6(t, e)) : h && (a = $6(t, e, a), s.push(a.doc));
  }, "comments"), { leading: n, trailing: s };
}
function ii(t, e, r) {
  let { leading: i, trailing: n } = iv(t, r);
  return !i && !n ? e : Id(e, (s) => [i, s, n]);
}
var B6 = class extends Error {
  constructor(r, i, n = "type") {
    super(`Unexpected ${i} node ${n}: ${JSON.stringify(r[n])}.`);
    Ur(this, "name", "UnexpectedNodeError");
    this.node = r;
  }
}, qa = B6;
function I6(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var zr, N6 = class {
  constructor(e) {
    x7(this, zr, void 0), D7(this, zr, new Set(e));
  }
  getLeadingWhitespaceCount(e) {
    let r = mn(this, zr), i = 0;
    for (let n = 0; n < e.length && r.has(e.charAt(n)); n++)
      i++;
    return i;
  }
  getTrailingWhitespaceCount(e) {
    let r = mn(this, zr), i = 0;
    for (let n = e.length - 1; n >= 0 && r.has(e.charAt(n)); n--)
      i++;
    return i;
  }
  getLeadingWhitespace(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(0, r);
  }
  getTrailingWhitespace(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(e.length - r);
  }
  hasLeadingWhitespace(e) {
    return mn(this, zr).has(e.charAt(0));
  }
  hasTrailingWhitespace(e) {
    return mn(this, zr).has(We(!1, e, -1));
  }
  trimStart(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(r);
  }
  trimEnd(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(0, e.length - r);
  }
  trim(e) {
    return this.trimEnd(this.trimStart(e));
  }
  split(e, r = !1) {
    let i = `[${I6([...mn(this, zr)].join(""))}]+`, n = new RegExp(r ? `(${i})` : i);
    return e.split(n);
  }
  hasWhitespaceCharacter(e) {
    let r = mn(this, zr);
    return Array.prototype.some.call(e, (i) => r.has(i));
  }
  hasNonWhitespaceCharacter(e) {
    let r = mn(this, zr);
    return Array.prototype.some.call(e, (i) => !r.has(i));
  }
  isWhitespaceOnly(e) {
    let r = mn(this, zr);
    return Array.prototype.every.call(e, (i) => r.has(i));
  }
};
zr = /* @__PURE__ */ new WeakMap();
var _6 = N6, Vu = new _6(` 
\r	`), kp = (t) => t === "" || t === he || t === ee || t === H;
function M6(t, e, r) {
  var i, n, s;
  let { node: a } = t;
  if (a.type === "JSXElement" && J6(a))
    return [r("openingElement"), r("closingElement")];
  let l = a.type === "JSXElement" ? r("openingElement") : r("openingFragment"), u = a.type === "JSXElement" ? r("closingElement") : r("closingFragment");
  if (a.children.length === 1 && a.children[0].type === "JSXExpressionContainer" && (a.children[0].expression.type === "TemplateLiteral" || a.children[0].expression.type === "TaggedTemplateExpression"))
    return [l, ...t.map(r, "children"), u];
  a.children = a.children.map((A) => K6(A) ? { type: "JSXText", value: " ", raw: " " } : A);
  let h = a.children.some(bt), p = a.children.filter((A) => A.type === "JSXExpressionContainer").length > 1, d = a.type === "JSXElement" && a.openingElement.attributes.length > 1, m = Yt(l) || h || d || p, y = t.parent.rootMarker === "mdx", O = e.singleQuote ? "{' '}" : '{" "}', D = y ? " " : Ee([O, H], " "), v = ((n = (i = a.openingElement) == null ? void 0 : i.name) == null ? void 0 : n.name) === "fbt", w = L6(t, e, r, D, v), x = a.children.some((A) => Ko(A));
  for (let A = w.length - 2; A >= 0; A--) {
    let P = w[A] === "" && w[A + 1] === "", I = w[A] === ee && w[A + 1] === "" && w[A + 2] === ee, B = (w[A] === H || w[A] === ee) && w[A + 1] === "" && w[A + 2] === D, _ = w[A] === D && w[A + 1] === "" && (w[A + 2] === H || w[A + 2] === ee), R = w[A] === D && w[A + 1] === "" && w[A + 2] === D, G = w[A] === H && w[A + 1] === "" && w[A + 2] === ee || w[A] === ee && w[A + 1] === "" && w[A + 2] === H;
    I && x || P || B || R || G ? w.splice(A, 2) : _ && w.splice(A + 1, 2);
  }
  for (; w.length > 0 && kp(We(!1, w, -1)); )
    w.pop();
  for (; w.length > 1 && kp(w[0]) && kp(w[1]); )
    w.shift(), w.shift();
  let S = [];
  for (let [A, P] of w.entries()) {
    if (P === D) {
      if (A === 1 && w[A - 1] === "") {
        if (w.length === 2) {
          S.push(O);
          continue;
        }
        S.push([O, ee]);
        continue;
      } else if (A === w.length - 1) {
        S.push(O);
        continue;
      } else if (w[A - 1] === "" && w[A - 2] === ee) {
        S.push(O);
        continue;
      }
    }
    S.push(P), Yt(P) && (m = !0);
  }
  let k = x ? cg(S) : Z(S, { shouldBreak: !0 });
  if (((s = e.cursorNode) == null ? void 0 : s.type) === "JSXText" && a.children.includes(e.cursorNode) && (k = [Y0, k, Y0]), y)
    return k;
  let C = Z([l, te([ee, k]), ee, u]);
  return m ? C : os([Z([l, ...w, u]), C]);
}
function L6(t, e, r, i, n) {
  let s = [];
  return t.each(({ node: a, next: l }) => {
    if (a.type === "JSXText") {
      let u = Qr(a);
      if (Ko(a)) {
        let h = Vu.split(u, !0);
        h[0] === "" && (s.push(""), h.shift(), /\n/.test(h[0]) ? s.push(K0(n, h[1], a, l)) : s.push(i), h.shift());
        let p;
        if (We(!1, h, -1) === "" && (h.pop(), p = h.pop()), h.length === 0)
          return;
        for (let [d, m] of h.entries())
          d % 2 === 1 ? s.push(he) : s.push(m);
        p !== void 0 ? /\n/.test(p) ? s.push(K0(n, We(!1, s, -1), a, l)) : s.push(i) : s.push(J0(n, We(!1, s, -1), a, l));
      } else
        /\n/.test(u) ? u.match(/\n/g).length > 1 && s.push("", ee) : s.push("", i);
    } else {
      let u = r();
      if (s.push(u), l && Ko(l)) {
        let h = Vu.trim(Qr(l)), [p] = Vu.split(h);
        s.push(J0(n, p, a, l));
      } else
        s.push(ee);
    }
  }, "children"), s;
}
function J0(t, e, r, i) {
  return t ? "" : r.type === "JSXElement" && !r.closingElement || (i == null ? void 0 : i.type) === "JSXElement" && !i.closingElement ? e.length === 1 ? H : ee : H;
}
function K0(t, e, r, i) {
  return t ? ee : e.length === 1 ? r.type === "JSXElement" && !r.closingElement || (i == null ? void 0 : i.type) === "JSXElement" && !i.closingElement ? ee : H : ee;
}
var Q6 = /* @__PURE__ */ new Set(["ArrayExpression", "TupleExpression", "JSXAttribute", "JSXElement", "JSXExpressionContainer", "JSXFragment", "ExpressionStatement", "CallExpression", "OptionalCallExpression", "ConditionalExpression", "JsExpressionRoot"]);
function j6(t, e, r) {
  let { parent: i } = t;
  if (Q6.has(i.type))
    return e;
  let n = t.match(void 0, (a) => a.type === "ArrowFunctionExpression", Qe, (a) => a.type === "JSXExpressionContainer"), s = Qs(t, r);
  return Z([s ? "" : Ee("("), te([H, e]), H, s ? "" : Ee(")")], { shouldBreak: n });
}
function R6(t, e, r) {
  let { node: i } = t, n = [];
  if (n.push(r("name")), i.value) {
    let s;
    if (ar(i.value)) {
      let a = Qr(i.value), l = xr(!1, xr(!1, a.slice(1, -1), "&apos;", "'"), "&quot;", '"'), u = pb(l, e.jsxSingleQuote);
      l = u === '"' ? xr(!1, l, '"', "&quot;") : xr(!1, l, "'", "&apos;"), s = t.call(() => ii(t, bs(u + l + u), e), "value");
    } else
      s = r("value");
    n.push("=", s);
  }
  return n;
}
function Z6(t, e, r) {
  let { node: i } = t, n = (s, a) => s.type === "JSXEmptyExpression" || !se(s) && (Nt(s) || ni(s) || s.type === "ArrowFunctionExpression" || s.type === "AwaitExpression" && (n(s.argument, s) || s.argument.type === "JSXElement") || Qe(s) || s.type === "ChainExpression" && Qe(s.expression) || s.type === "FunctionExpression" || s.type === "TemplateLiteral" || s.type === "TaggedTemplateExpression" || s.type === "DoExpression" || bt(a) && (s.type === "ConditionalExpression" || Vi(s)));
  return n(i.expression, t.parent) ? Z(["{", r("expression"), Ui, "}"]) : Z(["{", te([H, r("expression")]), H, Ui, "}"]);
}
function W6(t, e, r) {
  var i, n;
  let { node: s } = t, a = se(s.name) || se(s.typeParameters) || se(s.typeArguments);
  if (s.selfClosing && s.attributes.length === 0 && !a)
    return ["<", r("name"), s.typeArguments ? r("typeArguments") : r("typeParameters"), " />"];
  if (((i = s.attributes) == null ? void 0 : i.length) === 1 && s.attributes[0].value && ar(s.attributes[0].value) && !s.attributes[0].value.value.includes(`
`) && !a && !se(s.attributes[0]))
    return Z(["<", r("name"), s.typeArguments ? r("typeArguments") : r("typeParameters"), " ", ...t.map(r, "attributes"), s.selfClosing ? " />" : ">"]);
  let l = (n = s.attributes) == null ? void 0 : n.some((h) => h.value && ar(h.value) && h.value.value.includes(`
`)), u = e.singleAttributePerLine && s.attributes.length > 1 ? ee : he;
  return Z(["<", r("name"), s.typeArguments ? r("typeArguments") : r("typeParameters"), te(t.map(() => [u, r()], "attributes")), ...q6(s, e, a)], { shouldBreak: l });
}
function q6(t, e, r) {
  return t.selfClosing ? [he, "/>"] : X6(t, e, r) ? [">"] : [H, ">"];
}
function X6(t, e, r) {
  let i = t.attributes.length > 0 && se(We(!1, t.attributes, -1), de.Trailing);
  return t.attributes.length === 0 && !r || (e.bracketSameLine || e.jsxBracketSameLine) && (!r || t.attributes.length > 0) && !i;
}
function V6(t, e, r) {
  let { node: i } = t, n = [];
  n.push("</");
  let s = r("name");
  return se(i.name, de.Leading | de.Line) ? n.push(te([ee, s]), ee) : se(i.name, de.Leading | de.Block) ? n.push(" ", s) : n.push(s), n.push(">"), n;
}
function U6(t, e) {
  let { node: r } = t, i = se(r), n = se(r, de.Line), s = r.type === "JSXOpeningFragment";
  return [s ? "<" : "</", te([n ? ee : i && !s ? " " : "", at(t, e)]), n ? ee : "", ">"];
}
function Y6(t, e, r) {
  let i = ii(t, M6(t, e, r), e);
  return j6(t, i, e);
}
function z6(t, e) {
  let { node: r } = t, i = se(r, de.Line);
  return [at(t, e, { indent: i }), i ? ee : ""];
}
function G6(t, e, r) {
  let { node: i } = t;
  return ["{", t.call(({ node: n }) => {
    let s = ["...", r()];
    return !se(n) || !zb(t) ? s : [te([H, ii(t, s, e)]), H];
  }, i.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
}
function H6(t, e, r) {
  let { node: i } = t;
  if (i.type.startsWith("JSX"))
    switch (i.type) {
      case "JSXAttribute":
        return R6(t, e, r);
      case "JSXIdentifier":
        return i.name;
      case "JSXNamespacedName":
        return Ie(":", [r("namespace"), r("name")]);
      case "JSXMemberExpression":
        return Ie(".", [r("object"), r("property")]);
      case "JSXSpreadAttribute":
      case "JSXSpreadChild":
        return G6(t, e, r);
      case "JSXExpressionContainer":
        return Z6(t, e, r);
      case "JSXFragment":
      case "JSXElement":
        return Y6(t, e, r);
      case "JSXOpeningElement":
        return W6(t, e, r);
      case "JSXClosingElement":
        return V6(t, e, r);
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        return U6(t, e);
      case "JSXEmptyExpression":
        return z6(t, e);
      case "JSXText":
        throw new Error("JSXText should be handled by JSXElement");
      default:
        throw new qa(i, "JSX");
    }
}
function J6(t) {
  if (t.children.length === 0)
    return !0;
  if (t.children.length > 1)
    return !1;
  let e = t.children[0];
  return e.type === "JSXText" && !Ko(e);
}
function Ko(t) {
  return t.type === "JSXText" && (Vu.hasNonWhitespaceCharacter(Qr(t)) || !/\n/.test(Qr(t)));
}
function K6(t) {
  return t.type === "JSXExpressionContainer" && ar(t.expression) && t.expression.value === " " && !se(t.expression);
}
function e9(t) {
  let { node: e, parent: r } = t;
  if (!bt(e) || !bt(r))
    return !1;
  let { index: i, siblings: n } = t, s;
  for (let a = i; a > 0; a--) {
    let l = n[a - 1];
    if (!(l.type === "JSXText" && !Ko(l))) {
      s = l;
      break;
    }
  }
  return (s == null ? void 0 : s.type) === "JSXExpressionContainer" && s.expression.type === "JSXEmptyExpression" && Ph(s.expression);
}
function t9(t) {
  return Ph(t.node) || e9(t);
}
var nv = t9, r9 = 0;
function sv(t, e, r) {
  var i;
  let { node: n, parent: s, grandparent: a, key: l } = t, u = l !== "body" && (s.type === "IfStatement" || s.type === "WhileStatement" || s.type === "SwitchStatement" || s.type === "DoWhileStatement"), h = n.operator === "|>" && ((i = t.root.extra) == null ? void 0 : i.__isUsingHackPipeline), p = Rd(t, r, e, !1, u);
  if (u)
    return p;
  if (h)
    return Z(p);
  if (Qe(s) && s.callee === n || s.type === "UnaryExpression" || nt(s) && !s.computed)
    return Z([te([H, ...p]), H]);
  let d = s.type === "ReturnStatement" || s.type === "ThrowStatement" || s.type === "JSXExpressionContainer" && a.type === "JSXAttribute" || n.operator !== "|" && s.type === "JsExpressionRoot" || n.type !== "NGPipeExpression" && (s.type === "NGRoot" && e.parser === "__ng_binding" || s.type === "NGMicrosyntaxExpression" && a.type === "NGMicrosyntax" && a.body.length === 1) || n === s.body && s.type === "ArrowFunctionExpression" || n !== s.body && s.type === "ForStatement" || s.type === "ConditionalExpression" && a.type !== "ReturnStatement" && a.type !== "ThrowStatement" && !Qe(a) || s.type === "TemplateLiteral", m = s.type === "AssignmentExpression" || s.type === "VariableDeclarator" || s.type === "ClassProperty" || s.type === "PropertyDefinition" || s.type === "TSAbstractPropertyDefinition" || s.type === "ClassPrivateProperty" || on(s), y = Vi(n.left) && lg(n.operator, n.left.operator);
  if (d || el(n) && !y || !el(n) && m)
    return Z(p);
  if (p.length === 0)
    return "";
  let O = bt(n.right), D = p.findIndex((C) => typeof C != "string" && !Array.isArray(C) && C.type === Rr), v = p.slice(0, D === -1 ? 1 : D + 1), w = p.slice(v.length, O ? -1 : void 0), x = Symbol("logicalChain-" + ++r9), S = Z([...v, te(w)], { id: x });
  if (!O)
    return S;
  let k = We(!1, p, -1);
  return Z([S, Fh(k, { groupId: x })]);
}
function Rd(t, e, r, i, n) {
  var s;
  let { node: a } = t;
  if (!Vi(a))
    return [Z(e())];
  let l = [];
  lg(a.operator, a.left.operator) ? l = t.call((v) => Rd(v, e, r, !0, n), "left") : l.push(Z(e("left")));
  let u = el(a), h = (a.operator === "|>" || a.type === "NGPipeExpression" || i9(t, r)) && !Os(r.originalText, a.right), p = a.type === "NGPipeExpression" ? "|" : a.operator, d = a.type === "NGPipeExpression" && a.arguments.length > 0 ? Z(te([H, ": ", Ie([he, ": "], t.map(() => Fi(2, Z(e())), "arguments"))])) : "", m;
  if (u)
    m = [p, " ", e("right"), d];
  else {
    let v = p === "|>" && ((s = t.root.extra) != null && s.__isUsingHackPipeline) ? t.call((w) => Rd(w, e, r, !0, n), "right") : e("right");
    m = [h ? he : "", p, h ? " " : he, v, d];
  }
  let { parent: y } = t, O = se(a.left, de.Trailing | de.Line), D = O || !(n && a.type === "LogicalExpression") && y.type !== a.type && a.left.type !== a.type && a.right.type !== a.type;
  if (l.push(h ? "" : " ", D ? Z(m, { shouldBreak: O }) : m), i && se(a)) {
    let v = hg(ii(t, l, r));
    return Array.isArray(v) || v.type === Pi ? Mb(v) : [v];
  }
  return l;
}
function el(t) {
  return t.type !== "LogicalExpression" ? !1 : !!(ni(t.right) && t.right.properties.length > 0 || Nt(t.right) && t.right.elements.length > 0 || bt(t.right));
}
var e1 = (t) => t.type === "BinaryExpression" && t.operator === "|";
function i9(t, e) {
  return (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && e1(t.node) && !t.hasAncestor((r) => !e1(r) && r.type !== "JsExpressionRoot");
}
function n9(t, e, r) {
  let { node: i } = t;
  if (i.type.startsWith("NG"))
    switch (i.type) {
      case "NGRoot":
        return [r("node"), se(i.node) ? " //" + pa(i.node)[0].value.trimEnd() : ""];
      case "NGPipeExpression":
        return sv(t, e, r);
      case "NGChainedExpression":
        return Z(Ie([";", he], t.map(() => a9(t) ? r() : ["(", r(), ")"], "expressions")));
      case "NGEmptyExpression":
        return "";
      case "NGMicrosyntax":
        return t.map(() => [t.isFirst ? "" : t1(t) ? " " : [";", he], r()], "body");
      case "NGMicrosyntaxKey":
        return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(i.name) ? i.name : JSON.stringify(i.name);
      case "NGMicrosyntaxExpression":
        return [r("expression"), i.alias === null ? "" : [" as ", r("alias")]];
      case "NGMicrosyntaxKeyedExpression": {
        let { index: n, parent: s } = t, a = t1(t) || (n === 1 && (i.key.name === "then" || i.key.name === "else" || i.key.name === "as") || (n === 2 || n === 3) && (i.key.name === "else" && s.body[n - 1].type === "NGMicrosyntaxKeyedExpression" && s.body[n - 1].key.name === "then" || i.key.name === "track")) && s.body[0].type === "NGMicrosyntaxExpression";
        return [r("key"), a ? " " : ": ", r("expression")];
      }
      case "NGMicrosyntaxLet":
        return ["let ", r("key"), i.value === null ? "" : [" = ", r("value")]];
      case "NGMicrosyntaxAs":
        return [r("key"), " as ", r("alias")];
      default:
        throw new qa(i, "Angular");
    }
}
function t1({ node: t, index: e }) {
  return t.type === "NGMicrosyntaxKeyedExpression" && t.key.name === "of" && e === 1;
}
var s9 = Ue(["CallExpression", "OptionalCallExpression", "AssignmentExpression"]);
function a9({ node: t }) {
  return Pd(t, s9);
}
function av(t, e, r) {
  let { node: i } = t;
  return Z([Ie(he, t.map(r, "decorators")), ov(i, e) ? ee : he]);
}
function o9(t, e, r) {
  return lv(t.node) ? [Ie(ee, t.map(r, "declaration", "decorators")), ee] : "";
}
function l9(t, e, r) {
  let { node: i, parent: n } = t, { decorators: s } = i;
  if (!Re(s) || lv(n) || nv(t))
    return "";
  let a = i.type === "ClassExpression" || i.type === "ClassDeclaration" || ov(i, e);
  return [t.key === "declaration" && p_(n) ? ee : a ? $i : "", Ie(he, t.map(r, "decorators")), he];
}
function ov(t, e) {
  return t.decorators.some((r) => wr(e.originalText, Ze(r)));
}
function lv(t) {
  var e;
  if (t.type !== "ExportDefaultDeclaration" && t.type !== "ExportNamedDeclaration" && t.type !== "DeclareExportDeclaration")
    return !1;
  let r = (e = t.declaration) == null ? void 0 : e.decorators;
  return Re(r) && Ch(t, r[0]);
}
var yc = class extends Error {
  constructor() {
    super(...arguments);
    Ur(this, "name", "ArgExpansionBailout");
  }
};
function u9(t, e, r) {
  let { node: i } = t, n = jr(i);
  if (n.length === 0)
    return ["(", at(t, e), ")"];
  if (p9(n))
    return ["(", r(["arguments", 0]), ", ", r(["arguments", 1]), ")"];
  let s = !1, a = n.length - 1, l = [];
  ug(t, ({ node: d }, m) => {
    let y = r();
    m === a || (Vn(d, e) ? (s = !0, y = [y, ",", ee, ee]) : y = [y, ",", he]), l.push(y);
  });
  let u = !(i.type === "ImportExpression" || i.callee.type === "Import") && Xn(e, "all") ? "," : "";
  function h() {
    return Z(["(", te([he, ...l]), u, he, ")"], { shouldBreak: !0 });
  }
  if (s || t.parent.type !== "Decorator" && b_(n))
    return h();
  if (h9(n)) {
    let d = l.slice(1);
    if (d.some(Yt))
      return h();
    let m;
    try {
      m = r(X0(i, 0), { expandFirstArg: !0 });
    } catch (y) {
      if (y instanceof yc)
        return h();
      throw y;
    }
    return Yt(m) ? [$i, os([["(", Z(m, { shouldBreak: !0 }), ", ", ...d, ")"], h()])] : os([["(", m, ", ", ...d, ")"], ["(", Z(m, { shouldBreak: !0 }), ", ", ...d, ")"], h()]);
  }
  if (c9(n, l, e)) {
    let d = l.slice(0, -1);
    if (d.some(Yt))
      return h();
    let m;
    try {
      m = r(X0(i, -1), { expandLastArg: !0 });
    } catch (y) {
      if (y instanceof yc)
        return h();
      throw y;
    }
    return Yt(m) ? [$i, os([["(", ...d, Z(m, { shouldBreak: !0 }), ")"], h()])] : os([["(", ...d, m, ")"], ["(", ...d, Z(m, { shouldBreak: !0 }), ")"], h()]);
  }
  let p = ["(", te([H, ...l]), Ee(u), H, ")"];
  return kb(t) ? p : Z(p, { shouldBreak: l.some(Yt) || s });
}
function Mo(t, e = !1) {
  return ni(t) && (t.properties.length > 0 || se(t)) || Nt(t) && (t.elements.length > 0 || se(t)) || t.type === "TSTypeAssertion" && Mo(t.expression) || bi(t) && Mo(t.expression) || t.type === "FunctionExpression" || t.type === "ArrowFunctionExpression" && (!t.returnType || !t.returnType.typeAnnotation || t.returnType.typeAnnotation.type !== "TSTypeReference" || d9(t.body)) && (t.body.type === "BlockStatement" || t.body.type === "ArrowFunctionExpression" && Mo(t.body, !0) || ni(t.body) || Nt(t.body) || !e && (Qe(t.body) || t.body.type === "ConditionalExpression") || bt(t.body)) || t.type === "DoExpression" || t.type === "ModuleExpression";
}
function c9(t, e, r) {
  var i, n;
  let s = We(!1, t, -1);
  if (t.length === 1) {
    let l = We(!1, e, -1);
    if ((i = l.label) != null && i.embed && ((n = l.label) == null ? void 0 : n.hug) !== !1)
      return !0;
  }
  let a = We(!1, t, -2);
  return !se(s, de.Leading) && !se(s, de.Trailing) && Mo(s) && (!a || a.type !== s.type) && (t.length !== 2 || a.type !== "ArrowFunctionExpression" || !Nt(s)) && !(t.length > 1 && Iv(s, r));
}
function h9(t) {
  if (t.length !== 2)
    return !1;
  let [e, r] = t;
  return e.type === "ModuleExpression" && f9(r) ? !0 : !se(e) && (e.type === "FunctionExpression" || e.type === "ArrowFunctionExpression" && e.body.type === "BlockStatement") && r.type !== "FunctionExpression" && r.type !== "ArrowFunctionExpression" && r.type !== "ConditionalExpression" && uv(r) && !Mo(r);
}
function uv(t) {
  var e;
  if (t.type === "ParenthesizedExpression")
    return uv(t.expression);
  if (bi(t) || t.type === "TypeCastExpression") {
    let { typeAnnotation: r } = t;
    return r.type === "TypeAnnotation" && (r = r.typeAnnotation), r.type === "TSArrayType" && (r = r.elementType, r.type === "TSArrayType" && (r = r.elementType)), (r.type === "GenericTypeAnnotation" || r.type === "TSTypeReference") && ((e = r.typeParameters) == null ? void 0 : e.params.length) === 1 && (r = r.typeParameters.params[0]), ag(r) && Kr(t.expression, 1);
  }
  return Ea(t) && jr(t).length > 1 ? !1 : Vi(t) ? Kr(t.left, 1) && Kr(t.right, 1) : xb(t) || Kr(t);
}
function p9(t) {
  return t.length === 2 && t[0].type === "ArrowFunctionExpression" && qt(t[0]).length === 0 && t[0].body.type === "BlockStatement" && t[1].type === "ArrayExpression" && !t.some((e) => se(e));
}
function d9(t) {
  return t.type === "BlockStatement" && (t.body.some((e) => e.type !== "EmptyStatement") || se(t, de.Dangling));
}
function f9(t) {
  return t.type === "ObjectExpression" && t.properties.length === 1 && on(t.properties[0]) && t.properties[0].key.type === "Identifier" && t.properties[0].key.name === "type" && ar(t.properties[0].value) && t.properties[0].value.value === "module";
}
var Zd = u9, m9 = (t) => ((t.type === "ChainExpression" || t.type === "TSNonNullExpression") && (t = t.expression), Qe(t) && jr(t).length > 0);
function g9(t, e, r) {
  var i;
  let n = r("object"), s = cv(t, e, r), { node: a } = t, l = t.findAncestor((p) => !(nt(p) || p.type === "TSNonNullExpression")), u = t.findAncestor((p) => !(p.type === "ChainExpression" || p.type === "TSNonNullExpression")), h = l && (l.type === "NewExpression" || l.type === "BindExpression" || l.type === "AssignmentExpression" && l.left.type !== "Identifier") || a.computed || a.object.type === "Identifier" && a.property.type === "Identifier" && !nt(u) || (u.type === "AssignmentExpression" || u.type === "VariableDeclarator") && (m9(a.object) || ((i = n.label) == null ? void 0 : i.memberChain));
  return Tl(n.label, [n, h ? s : Z(te([H, s]))]);
}
function cv(t, e, r) {
  let i = r("property"), { node: n } = t, s = zt(t);
  return n.computed ? !n.property || In(n.property) ? [s, "[", i, "]"] : Z([s, "[", te([H, i]), H, "]"]) : [s, ".", i];
}
function hv(t, e, r) {
  if (t.node.type === "ChainExpression")
    return t.call(() => hv(t, e, r), "expression");
  let { parent: i } = t, n = !i || i.type === "ExpressionStatement", s = [];
  function a(Q) {
    let { originalText: q } = e, X = Pl(q, Ze(Q));
    return q.charAt(X) === ")" ? X !== !1 && ng(q, X + 1) : Vn(Q, e);
  }
  function l(Q) {
    let { node: q } = Q;
    if (q.type === "ChainExpression")
      return Q.call(() => l(Q), "expression");
    if (Qe(q) && (ta(q.callee) || Qe(q.callee))) {
      let X = a(q);
      s.unshift({ node: q, hasTrailingEmptyLine: X, printed: [ii(Q, [zt(Q), vs(Q, e, r), Zd(Q, e, r)], e), X ? ee : ""] }), Q.call((K) => l(K), "callee");
    } else
      ta(q) ? (s.unshift({ node: q, needsParens: Qs(Q, e), printed: ii(Q, nt(q) ? cv(Q, e, r) : $v(Q, e, r), e) }), Q.call((X) => l(X), "object")) : q.type === "TSNonNullExpression" ? (s.unshift({ node: q, printed: ii(Q, "!", e) }), Q.call((X) => l(X), "expression")) : s.unshift({ node: q, printed: r() });
  }
  let { node: u } = t;
  s.unshift({ node: u, printed: [zt(t), vs(t, e, r), Zd(t, e, r)] }), u.callee && t.call((Q) => l(Q), "callee");
  let h = [], p = [s[0]], d = 1;
  for (; d < s.length && (s[d].node.type === "TSNonNullExpression" || Qe(s[d].node) || nt(s[d].node) && s[d].node.computed && In(s[d].node.property)); ++d)
    p.push(s[d]);
  if (!Qe(s[0].node))
    for (; d + 1 < s.length && ta(s[d].node) && ta(s[d + 1].node); ++d)
      p.push(s[d]);
  h.push(p), p = [];
  let m = !1;
  for (; d < s.length; ++d) {
    if (m && ta(s[d].node)) {
      if (s[d].node.computed && In(s[d].node.property)) {
        p.push(s[d]);
        continue;
      }
      h.push(p), p = [], m = !1;
    }
    (Qe(s[d].node) || s[d].node.type === "ImportExpression") && (m = !0), p.push(s[d]), se(s[d].node, de.Trailing) && (h.push(p), p = [], m = !1);
  }
  p.length > 0 && h.push(p);
  function y(Q) {
    return /^[A-Z]|^[$_]+$/.test(Q);
  }
  function O(Q) {
    return Q.length <= e.tabWidth;
  }
  function D(Q) {
    var q;
    let X = (q = Q[1][0]) == null ? void 0 : q.node.computed;
    if (Q[0].length === 1) {
      let ye = Q[0][0].node;
      return ye.type === "ThisExpression" || ye.type === "Identifier" && (y(ye.name) || n && O(ye.name) || X);
    }
    let K = We(!1, Q[0], -1).node;
    return nt(K) && K.property.type === "Identifier" && (y(K.property.name) || X);
  }
  let v = h.length >= 2 && !se(h[1][0].node) && D(h);
  function w(Q) {
    let q = Q.map((X) => X.printed);
    return Q.length > 0 && We(!1, Q, -1).needsParens ? ["(", ...q, ")"] : q;
  }
  function x(Q) {
    return Q.length === 0 ? "" : te([ee, Ie(ee, Q.map(w))]);
  }
  let S = h.map(w), k = S, C = v ? 3 : 2, A = h.flat(), P = A.slice(1, -1).some((Q) => se(Q.node, de.Leading)) || A.slice(0, -1).some((Q) => se(Q.node, de.Trailing)) || h[C] && se(h[C][0].node, de.Leading);
  if (h.length <= C && !P && !h.some((Q) => We(!1, Q, -1).hasTrailingEmptyLine))
    return kb(t) ? k : Z(k);
  let I = We(!1, h[v ? 1 : 0], -1).node, B = !Qe(I) && a(I), _ = [w(h[0]), v ? h.slice(1, 2).map(w) : "", B ? ee : "", x(h.slice(v ? 2 : 1))], R = s.map(({ node: Q }) => Q).filter(Qe);
  function G() {
    let Q = We(!1, We(!1, h, -1), -1).node, q = We(!1, S, -1);
    return Qe(Q) && Yt(q) && R.slice(0, -1).some((X) => X.arguments.some(Ho));
  }
  let J;
  return P || R.length > 2 && R.some((Q) => !Q.arguments.every((q) => Kr(q))) || S.slice(0, -1).some(Yt) || G() ? J = Z(_) : J = [Yt(k) || B ? $i : "", os([k, _])], Tl({ memberChain: !0 }, J);
}
var y9 = hv;
function pv(t, e, r) {
  var i;
  let { node: n, parent: s } = t, a = n.type === "NewExpression", l = n.type === "ImportExpression", u = zt(t), h = jr(n), p = h.length === 1 && Eb(h[0], e.originalText);
  if (p || h.length > 0 && !a && !l && (x9(n, s) || Th(n, s))) {
    let m = [];
    if (ug(t, () => {
      m.push(r());
    }), !(p && (i = m[0].label) != null && i.embed))
      return [a ? "new " : "", r("callee"), u, vs(t, e, r), "(", Ie(", ", m), ")"];
  }
  if (!l && !a && ta(n.callee) && !t.call((m) => Qs(m, e), "callee", ...n.callee.type === "ChainExpression" ? ["expression"] : []))
    return y9(t, e, r);
  let d = [a ? "new " : "", l ? O9(n) : r("callee"), u, vs(t, e, r), Zd(t, e, r)];
  return l || Qe(n.callee) ? Z(d) : d;
}
function O9(t) {
  return t.phase ? `import.${t.phase}` : "import";
}
function x9(t, e) {
  if (t.callee.type !== "Identifier")
    return !1;
  if (t.callee.name === "require") {
    let r = jr(t);
    return r.length === 1 && ar(r[0]) || r.length > 1;
  }
  if (t.callee.name === "define") {
    let r = jr(t);
    return e.type === "ExpressionStatement" && (r.length === 1 || r.length === 2 && r[0].type === "ArrayExpression" || r.length === 3 && ar(r[0]) && r[1].type === "ArrayExpression");
  }
  return !1;
}
function Fl(t, e, r, i, n, s) {
  let a = v9(t, e, r, i, s), l = s ? r(s, { assignmentLayout: a }) : "";
  switch (a) {
    case "break-after-operator":
      return Z([Z(i), n, Z(te([he, l]))]);
    case "never-break-after-operator":
      return Z([Z(i), n, " ", l]);
    case "fluid": {
      let u = Symbol("assignment");
      return Z([Z(i), n, Z(te(he), { id: u }), Ui, Fh(l, { groupId: u })]);
    }
    case "break-lhs":
      return Z([i, n, " ", Z(l)]);
    case "chain":
      return [Z(i), n, he, l];
    case "chain-tail":
      return [Z(i), n, te([he, l])];
    case "chain-tail-arrow-chain":
      return [Z(i), n, l];
    case "only-left":
      return i;
  }
}
function D9(t, e, r) {
  let { node: i } = t;
  return Fl(t, e, r, r("left"), [" ", i.operator], "right");
}
function b9(t, e, r) {
  return Fl(t, e, r, r("id"), " =", "init");
}
function v9(t, e, r, i, n) {
  let { node: s } = t, a = s[n];
  if (!a)
    return "only-left";
  let l = !Uu(a);
  if (t.match(Uu, dv, (p) => !l || p.type !== "ExpressionStatement" && p.type !== "VariableDeclaration"))
    return l ? a.type === "ArrowFunctionExpression" && a.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
  if (!l && Uu(a.right) || Os(e.originalText, a))
    return "break-after-operator";
  if (a.type === "CallExpression" && a.callee.name === "require" || e.parser === "json5" || e.parser === "jsonc" || e.parser === "json")
    return "never-break-after-operator";
  let u = X_(i);
  if (S9(s) || k9(s) || fv(s) && u)
    return "break-lhs";
  let h = P9(s, i, e);
  return t.call(() => w9(t, e, r, h), n) ? "break-after-operator" : C9(s) ? "break-lhs" : !u && (h || a.type === "TemplateLiteral" || a.type === "TaggedTemplateExpression" || a.type === "BooleanLiteral" || In(a) || a.type === "ClassExpression") ? "never-break-after-operator" : "fluid";
}
function w9(t, e, r, i) {
  let n = t.node;
  if (Vi(n) && !el(n))
    return !0;
  switch (n.type) {
    case "StringLiteralTypeAnnotation":
    case "SequenceExpression":
      return !0;
    case "TSConditionalType":
    case "ConditionalTypeAnnotation":
      if (!e.experimentalTernaries && !B9(n))
        break;
      return !0;
    case "ConditionalExpression": {
      if (!e.experimentalTernaries) {
        let { test: h } = n;
        return Vi(h) && !el(h);
      }
      let { consequent: l, alternate: u } = n;
      return l.type === "ConditionalExpression" || u.type === "ConditionalExpression";
    }
    case "ClassExpression":
      return Re(n.decorators);
  }
  if (i)
    return !1;
  let s = n, a = [];
  for (; ; )
    if (s.type === "UnaryExpression" || s.type === "AwaitExpression" || s.type === "YieldExpression" && s.argument !== null)
      s = s.argument, a.push("argument");
    else if (s.type === "TSNonNullExpression")
      s = s.expression, a.push("expression");
    else
      break;
  return !!(ar(s) || t.call(() => mv(t, e, r), ...a));
}
function S9(t) {
  if (dv(t)) {
    let e = t.left || t.id;
    return e.type === "ObjectPattern" && e.properties.length > 2 && e.properties.some((r) => {
      var i;
      return on(r) && (!r.shorthand || ((i = r.value) == null ? void 0 : i.type) === "AssignmentPattern");
    });
  }
  return !1;
}
function Uu(t) {
  return t.type === "AssignmentExpression";
}
function dv(t) {
  return Uu(t) || t.type === "VariableDeclarator";
}
function C9(t) {
  let e = A9(t);
  if (Re(e)) {
    let r = t.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
    if (e.length > 1 && e.some((i) => i[r] || i.default))
      return !0;
  }
  return !1;
}
var E9 = Ue(["TSTypeAliasDeclaration", "TypeAlias"]);
function A9(t) {
  var e;
  if (E9(t))
    return (e = t.typeParameters) == null ? void 0 : e.params;
}
function k9(t) {
  if (t.type !== "VariableDeclarator")
    return !1;
  let { typeAnnotation: e } = t.id;
  if (!e || !e.typeAnnotation)
    return !1;
  let r = r1(e.typeAnnotation);
  return Re(r) && r.length > 1 && r.some((i) => Re(r1(i)) || i.type === "TSConditionalType");
}
function fv(t) {
  var e;
  return t.type === "VariableDeclarator" && ((e = t.init) == null ? void 0 : e.type) === "ArrowFunctionExpression";
}
var T9 = Ue(["TSTypeReference", "GenericTypeAnnotation"]);
function r1(t) {
  var e;
  if (T9(t))
    return (e = t.typeParameters) == null ? void 0 : e.params;
}
function mv(t, e, r, i = !1) {
  var n;
  let { node: s } = t, a = () => mv(t, e, r, !0);
  if (s.type === "ChainExpression" || s.type === "TSNonNullExpression")
    return t.call(a, "expression");
  if (Qe(s)) {
    if ((n = pv(t, e, r).label) != null && n.memberChain)
      return !1;
    let l = jr(s);
    return !(l.length === 0 || l.length === 1 && og(l[0], e)) || F9(s, r) ? !1 : t.call(a, "callee");
  }
  return nt(s) ? t.call(a, "object") : i && (s.type === "Identifier" || s.type === "ThisExpression");
}
function P9(t, e, r) {
  return on(t) ? (e = hg(e), typeof e == "string" && wa(e) < r.tabWidth + 3) : !1;
}
function F9(t, e) {
  let r = $9(t);
  if (Re(r)) {
    if (r.length > 1)
      return !0;
    if (r.length === 1) {
      let n = r[0];
      if (xs(n) || Pb(n) || n.type === "TSTypeLiteral" || n.type === "ObjectTypeAnnotation")
        return !0;
    }
    let i = t.typeParameters ? "typeParameters" : "typeArguments";
    if (Yt(e(i)))
      return !0;
  }
  return !1;
}
function $9(t) {
  var e;
  return (e = t.typeParameters ?? t.typeArguments) == null ? void 0 : e.params;
}
function B9(t) {
  function e(r) {
    switch (r.type) {
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "TSFunctionType":
      case "TSTypeReference":
        return !!r.typeParameters;
      default:
        return !1;
    }
  }
  return e(t.checkType) || e(t.extendsType);
}
function $l(t, e, r, i, n) {
  let s = t.node, a = qt(s), l = n ? vs(t, r, e) : "";
  if (a.length === 0)
    return [l, "(", at(t, r, { filter: (y) => Yi(r.originalText, Ze(y)) === ")" }), ")"];
  let { parent: u } = t, h = Th(u), p = gv(s), d = [];
  if (A_(t, (y, O) => {
    let D = O === a.length - 1;
    D && s.rest && d.push("..."), d.push(e()), !D && (d.push(","), h || p ? d.push(" ") : Vn(a[O], r) ? d.push(ee, ee) : d.push(he));
  }), i && !N9(t)) {
    if (Yt(l) || Yt(d))
      throw new yc();
    return Z([Bd(l), "(", Bd(d), ")"]);
  }
  let m = a.every((y) => !Re(y.decorators));
  return p && m ? [l, "(", ...d, ")"] : h ? [l, "(", ...d, ")"] : (bb(u) || f_(u) || u.type === "TypeAlias" || u.type === "UnionTypeAnnotation" || u.type === "IntersectionTypeAnnotation" || u.type === "FunctionTypeAnnotation" && u.returnType === s) && a.length === 1 && a[0].name === null && s.this !== a[0] && a[0].typeAnnotation && s.typeParameters === null && ag(a[0].typeAnnotation) && !s.rest ? r.arrowParens === "always" ? ["(", ...d, ")"] : d : [l, "(", te([H, ...d]), Ee(!E_(s) && Xn(r, "all") ? "," : ""), H, ")"];
}
function gv(t) {
  if (!t)
    return !1;
  let e = qt(t);
  if (e.length !== 1)
    return !1;
  let [r] = e;
  return !se(r) && (r.type === "ObjectPattern" || r.type === "ArrayPattern" || r.type === "Identifier" && r.typeAnnotation && (r.typeAnnotation.type === "TypeAnnotation" || r.typeAnnotation.type === "TSTypeAnnotation") && Nn(r.typeAnnotation.typeAnnotation) || r.type === "FunctionTypeParam" && Nn(r.typeAnnotation) && r !== t.rest || r.type === "AssignmentPattern" && (r.left.type === "ObjectPattern" || r.left.type === "ArrayPattern") && (r.right.type === "Identifier" || ni(r.right) && r.right.properties.length === 0 || Nt(r.right) && r.right.elements.length === 0));
}
function I9(t) {
  let e;
  return t.returnType ? (e = t.returnType, e.typeAnnotation && (e = e.typeAnnotation)) : t.typeAnnotation && (e = t.typeAnnotation), e;
}
function $h(t, e) {
  var r;
  let i = I9(t);
  if (!i)
    return !1;
  let n = (r = t.typeParameters) == null ? void 0 : r.params;
  if (n) {
    if (n.length > 1)
      return !1;
    if (n.length === 1) {
      let s = n[0];
      if (s.constraint || s.default)
        return !1;
    }
  }
  return qt(t).length === 1 && (Nn(i) || Yt(e));
}
function N9(t) {
  return t.match((e) => e.type === "ArrowFunctionExpression" && e.body.type === "BlockStatement", (e, r) => {
    if (e.type === "CallExpression" && r === "arguments" && e.arguments.length === 1 && e.callee.type === "CallExpression") {
      let i = e.callee.callee;
      return i.type === "Identifier" || i.type === "MemberExpression" && !i.computed && i.object.type === "Identifier" && i.property.type === "Identifier";
    }
    return !1;
  }, (e, r) => e.type === "VariableDeclarator" && r === "init" || e.type === "ExportDefaultDeclaration" && r === "declaration" || e.type === "TSExportAssignment" && r === "expression" || e.type === "AssignmentExpression" && r === "right" && e.left.type === "MemberExpression" && e.left.object.type === "Identifier" && e.left.object.name === "module" && e.left.property.type === "Identifier" && e.left.property.name === "exports", (e) => e.type !== "VariableDeclaration" || e.kind === "const" && e.declarations.length === 1);
}
function _9(t) {
  let e = qt(t);
  return e.length > 1 && e.some((r) => r.type === "TSParameterProperty");
}
var M9 = Ue(["VoidTypeAnnotation", "TSVoidKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword"]), L9 = Ue(["ObjectTypeAnnotation", "TSTypeLiteral", "GenericTypeAnnotation", "TSTypeReference"]);
function Q9(t) {
  let { types: e } = t;
  if (e.some((i) => se(i)))
    return !1;
  let r = e.find((i) => L9(i));
  return r ? e.every((i) => i === r || M9(i)) : !1;
}
function yv(t) {
  return ag(t) || Nn(t) ? !0 : xs(t) ? Q9(t) : !1;
}
function j9(t, e, r) {
  let i = e.semi ? ";" : "", { node: n } = t, s = [Zr(t), "opaque type ", r("id"), r("typeParameters")];
  return n.supertype && s.push(": ", r("supertype")), n.impltype && s.push(" = ", r("impltype")), s.push(i), s;
}
function Ov(t, e, r) {
  let i = e.semi ? ";" : "", { node: n } = t, s = [Zr(t)];
  s.push("type ", r("id"), r("typeParameters"));
  let a = n.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
  return [Fl(t, e, r, s, " =", a), i];
}
function xv(t, e, r) {
  let i = !1;
  return Z(t.map(({ isFirst: n, previous: s, node: a, index: l }) => {
    let u = r();
    if (n)
      return u;
    let h = Nn(a), p = Nn(s);
    return p && h ? [" & ", i ? te(u) : u] : !p && !h ? te([" &", he, u]) : (l > 1 && (i = !0), [" & ", l > 1 ? te(u) : u]);
  }, "types"));
}
function Dv(t, e, r) {
  let { node: i } = t, { parent: n } = t, s = n.type !== "TypeParameterInstantiation" && (n.type !== "TSConditionalType" || !e.experimentalTernaries) && (n.type !== "ConditionalTypeAnnotation" || !e.experimentalTernaries) && n.type !== "TSTypeParameterInstantiation" && n.type !== "GenericTypeAnnotation" && n.type !== "TSTypeReference" && n.type !== "TSTypeAssertion" && n.type !== "TupleTypeAnnotation" && n.type !== "TSTupleType" && !(n.type === "FunctionTypeParam" && !n.name && t.grandparent.this !== n) && !((n.type === "TypeAlias" || n.type === "VariableDeclarator" || n.type === "TSTypeAliasDeclaration") && Os(e.originalText, i)), a = yv(i), l = t.map((p) => {
    let d = r();
    return a || (d = Fi(2, d)), ii(p, d, e);
  }, "types");
  if (a)
    return Ie(" | ", l);
  let u = s && !Os(e.originalText, i), h = [Ee([u ? he : "", "| "]), Ie([he, "| "], l)];
  return Qs(t, e) ? Z([te(h), H]) : (n.type === "TupleTypeAnnotation" || n.type === "TSTupleType") && n[n.type === "TupleTypeAnnotation" && n.types ? "types" : "elementTypes"].length > 1 ? Z([te([Ee(["(", H]), h]), H, Ee(")")]) : Z(s ? te(h) : h);
}
function R9(t) {
  var e;
  let { node: r, parent: i } = t;
  return r.type === "FunctionTypeAnnotation" && (bb(i) || !((i.type === "ObjectTypeProperty" || i.type === "ObjectTypeInternalSlot") && !i.variance && !i.optional && Ch(i, r) || i.type === "ObjectTypeCallProperty" || ((e = t.getParentNode(2)) == null ? void 0 : e.type) === "DeclareFunction"));
}
function bv(t, e, r) {
  let { node: i } = t, n = [Bh(t)];
  (i.type === "TSConstructorType" || i.type === "TSConstructSignatureDeclaration") && n.push("new ");
  let s = $l(t, r, e, !1, !0), a = [];
  return i.type === "FunctionTypeAnnotation" ? a.push(R9(t) ? " => " : ": ", r("returnType")) : a.push(Bt(t, r, i.returnType ? "returnType" : "typeAnnotation")), $h(i, a) && (s = Z(s)), n.push(s, a), Z(n);
}
function vv(t, e, r) {
  return [r("objectType"), zt(t), "[", r("indexType"), "]"];
}
function wv(t, e, r) {
  return ["infer ", r("typeParameter")];
}
function i1(t, e, r) {
  let { node: i } = t;
  return [i.postfix ? "" : r, Bt(t, e), i.postfix ? r : ""];
}
function Sv(t, e, r) {
  let { node: i } = t;
  return ["...", ...i.type === "TupleTypeSpreadElement" && i.label ? [r("label"), ": "] : [], r("typeAnnotation")];
}
function Cv(t, e, r) {
  let { node: i } = t;
  return [i.variance ? r("variance") : "", r("label"), i.optional ? "?" : "", ": ", r("elementType")];
}
var Z9 = /* @__PURE__ */ new WeakSet();
function Bt(t, e, r = "typeAnnotation") {
  let { node: { [r]: i } } = t;
  if (!i)
    return "";
  let n = !1;
  if (i.type === "TSTypeAnnotation" || i.type === "TypeAnnotation") {
    let s = t.call(Ev, r);
    (s === "=>" || s === ":" && se(i, de.Leading)) && (n = !0), Z9.add(i);
  }
  return n ? [" ", e(r)] : e(r);
}
var Ev = (t) => t.match((e) => e.type === "TSTypeAnnotation", (e, r) => (r === "returnType" || r === "typeAnnotation") && (e.type === "TSFunctionType" || e.type === "TSConstructorType")) ? "=>" : t.match((e) => e.type === "TSTypeAnnotation", (e, r) => r === "typeAnnotation" && (e.type === "TSJSDocNullableType" || e.type === "TSJSDocNonNullableType" || e.type === "TSTypePredicate")) || t.match((e) => e.type === "TypeAnnotation", (e, r) => r === "typeAnnotation" && e.type === "Identifier", (e, r) => r === "id" && e.type === "DeclareFunction") || t.match((e) => e.type === "TypeAnnotation", (e, r) => r === "bound" && e.type === "TypeParameter" && e.usesExtendsBound) ? "" : ":";
function Av(t, e, r) {
  let i = Ev(t);
  return i ? [i, " ", r("typeAnnotation")] : r("typeAnnotation");
}
function kv(t) {
  return [t("elementType"), "[]"];
}
function Tv({ node: t }, e) {
  let r = t.type === "TSTypeQuery" ? "exprName" : "argument", i = t.type === "TSTypeQuery" ? "typeParameters" : "typeArguments";
  return ["typeof ", e(r), e(i)];
}
function Pv(t, e) {
  let { node: r } = t;
  return [r.asserts ? "asserts " : "", e("parameterName"), r.typeAnnotation ? [" is ", Bt(t, e)] : ""];
}
function zt(t) {
  let { node: e } = t;
  return !e.optional || e.type === "Identifier" && e === t.parent.key ? "" : Qe(e) || nt(e) && e.computed || e.type === "OptionalIndexedAccessType" ? "?." : "?";
}
function Fv(t) {
  return t.node.definite || t.match(void 0, (e, r) => r === "id" && e.type === "VariableDeclarator" && e.definite) ? "!" : "";
}
var W9 = /* @__PURE__ */ new Set(["DeclareClass", "DeclareFunction", "DeclareVariable", "DeclareExportDeclaration", "DeclareExportAllDeclaration", "DeclareOpaqueType", "DeclareTypeAlias", "DeclareEnum", "DeclareInterface"]);
function Zr(t) {
  let { node: e } = t;
  return e.declare || W9.has(e.type) && t.parent.type !== "DeclareExportDeclaration" ? "declare " : "";
}
var q9 = /* @__PURE__ */ new Set(["TSAbstractMethodDefinition", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
function Bh({ node: t }) {
  return t.abstract || q9.has(t.type) ? "abstract " : "";
}
function vs(t, e, r) {
  let i = t.node;
  return i.typeArguments ? r("typeArguments") : i.typeParameters ? r("typeParameters") : "";
}
function $v(t, e, r) {
  return ["::", r("callee")];
}
function gn(t, e, r) {
  return t.type === "EmptyStatement" ? ";" : t.type === "BlockStatement" || r ? [" ", e] : te([he, e]);
}
function Bv(t, e) {
  return ["...", e("argument"), Bt(t, e)];
}
function Oc(t) {
  return t.accessibility ? t.accessibility + " " : "";
}
function X9(t, e, r, i) {
  let { node: n } = t;
  return se(n, de.Dangling) ? Z([r, at(t, e, { indent: !0 }), H, i]) : [r, i];
}
function xg(t, e, r) {
  let { node: i } = t, n = [], s = i.type === "TupleExpression" ? "#[" : "[", a = "]", l = i.type === "TupleTypeAnnotation" && i.types ? "types" : i.type === "TSTupleType" || i.type === "TupleTypeAnnotation" ? "elementTypes" : "elements", u = i[l];
  if (u.length === 0)
    n.push(X9(t, e, s, a));
  else {
    let h = We(!1, u, -1), p = (h == null ? void 0 : h.type) !== "RestElement", d = h === null, m = Symbol("array"), y = !e.__inJestEach && u.length > 1 && u.every((v, w, x) => {
      let S = v == null ? void 0 : v.type;
      if (!Nt(v) && !ni(v))
        return !1;
      let k = x[w + 1];
      if (k && S !== k.type)
        return !1;
      let C = Nt(v) ? "elements" : "properties";
      return v[C] && v[C].length > 1;
    }), O = Iv(i, e), D = p ? d ? "," : Xn(e) ? O ? Ee(",", "", { groupId: m }) : Ee(",") : "" : "";
    n.push(Z([s, te([H, O ? U9(t, e, r, D) : [V9(t, e, l, r), D], at(t, e)]), H, a], { shouldBreak: y, id: m }));
  }
  return n.push(zt(t), Bt(t, r)), n;
}
function Iv(t, e) {
  return Nt(t) && t.elements.length > 1 && t.elements.every((r) => r && (In(r) || Ob(r) && !se(r.argument)) && !se(r, de.Trailing | de.Line, (i) => !wr(e.originalText, st(i), { backwards: !0 })));
}
function Nv({ node: t }, { originalText: e }) {
  let r = (n) => rg(e, ig(e, n)), i = (n) => e[n] === "," ? n : i(r(n + 1));
  return ng(e, i(Ze(t)));
}
function V9(t, e, r, i) {
  let n = [];
  return t.each(({ node: s, isLast: a }) => {
    n.push(s ? Z(i()) : ""), a || n.push([",", he, s && Nv(t, e) ? H : ""]);
  }, r), n;
}
function U9(t, e, r, i) {
  let n = [];
  return t.each(({ isLast: s, next: a }) => {
    n.push([r(), s ? i : ","]), s || n.push(Nv(t, e) ? [ee, ee] : se(a, de.Leading | de.Line) ? ee : he);
  }, "elements"), cg(n);
}
var _v = new Proxy(() => {
}, { get: () => _v }), Mv = _v;
function Y9(t) {
  return t.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
}
var wn = Y9, fu = /* @__PURE__ */ new WeakMap();
function Bl(t, e, r) {
  let { node: i } = t;
  if (i.computed)
    return ["[", r("key"), "]"];
  let { parent: n } = t, { key: s } = i;
  if (e.quoteProps === "consistent" && !fu.has(n)) {
    let a = (n.properties || n.body || n.members).some((l) => !l.computed && l.key && ar(l.key) && !Z0(l, e));
    fu.set(n, a);
  }
  if ((s.type === "Identifier" || In(s) && Cb(wn(Qr(s))) && String(s.value) === wn(Qr(s)) && !(e.parser === "typescript" || e.parser === "babel-ts")) && (e.parser === "json" || e.parser === "jsonc" || e.quoteProps === "consistent" && fu.get(n))) {
    let a = Go(JSON.stringify(s.type === "Identifier" ? s.name : s.value.toString()), e);
    return t.call((l) => ii(l, a, e), "key");
  }
  return Z0(i, e) && (e.quoteProps === "as-needed" || e.quoteProps === "consistent" && !fu.get(n)) ? t.call((a) => ii(a, /^\d/.test(s.value) ? wn(s.value) : s.value, e), "key") : r("key");
}
function n1(t, e, r) {
  let { node: i } = t;
  return i.shorthand ? r("value") : Fl(t, e, r, Bl(t, e, r), ":", "value");
}
var z9 = ({ node: t, key: e, parent: r }) => e === "value" && t.type === "FunctionExpression" && (r.type === "ObjectMethod" || r.type === "ClassMethod" || r.type === "ClassPrivateMethod" || r.type === "MethodDefinition" || r.type === "TSAbstractMethodDefinition" || r.type === "TSDeclareMethod" || r.type === "Property" && kh(r));
function Lv(t, e, r, i) {
  if (z9(t))
    return Dg(t, r, e);
  let { node: n } = t, s = !1;
  if ((n.type === "FunctionDeclaration" || n.type === "FunctionExpression") && i != null && i.expandLastArg) {
    let { parent: p } = t;
    Qe(p) && (jr(p).length > 1 || qt(n).every((d) => d.type === "Identifier" && !d.typeAnnotation)) && (s = !0);
  }
  let a = [Zr(t), n.async ? "async " : "", `function${n.generator ? "*" : ""} `, n.id ? e("id") : ""], l = $l(t, e, r, s), u = bg(t, e), h = $h(n, u);
  return a.push(vs(t, r, e), Z([h ? Z(l) : l, u]), n.body ? " " : "", e("body")), r.semi && (n.declare || !n.body) && a.push(";"), a;
}
function Wd(t, e, r) {
  let { node: i } = t, { kind: n } = i, s = i.value || i, a = [];
  return !n || n === "init" || n === "method" || n === "constructor" ? s.async && a.push("async ") : (Mv.ok(n === "get" || n === "set"), a.push(n, " ")), s.generator && a.push("*"), a.push(Bl(t, e, r), i.optional || i.key.optional ? "?" : "", i === s ? Dg(t, e, r) : r("value")), a;
}
function Dg(t, e, r) {
  let { node: i } = t, n = $l(t, r, e), s = bg(t, r), a = _9(i), l = $h(i, s), u = [vs(t, e, r), Z([a ? Z(n, { shouldBreak: !0 }) : l ? Z(n) : n, s])];
  return i.body ? u.push(" ", r("body")) : u.push(e.semi ? ";" : ""), u;
}
function G9(t) {
  let e = qt(t);
  return e.length === 1 && !t.typeParameters && !se(t, de.Dangling) && e[0].type === "Identifier" && !e[0].typeAnnotation && !se(e[0]) && !e[0].optional && !t.predicate && !t.returnType;
}
function Qv(t, e) {
  if (e.arrowParens === "always")
    return !1;
  if (e.arrowParens === "avoid") {
    let { node: r } = t;
    return G9(r);
  }
  return !1;
}
function bg(t, e) {
  let { node: r } = t, i = [Bt(t, e, "returnType")];
  return r.predicate && i.push(e("predicate")), i;
}
function jv(t, e, r) {
  let { node: i } = t, n = e.semi ? ";" : "", s = [];
  if (i.argument) {
    let u = r("argument");
    K9(e, i.argument) ? u = ["(", te([ee, u]), ee, ")"] : (Vi(i.argument) || i.argument.type === "SequenceExpression" || e.experimentalTernaries && i.argument.type === "ConditionalExpression" && (i.argument.consequent.type === "ConditionalExpression" || i.argument.alternate.type === "ConditionalExpression")) && (u = Z([Ee("("), te([H, u]), H, Ee(")")])), s.push(" ", u);
  }
  let a = se(i, de.Dangling), l = n && a && se(i, de.Last | de.Line);
  return l && s.push(n), a && s.push(" ", at(t, e)), l || s.push(n), s;
}
function H9(t, e, r) {
  return ["return", jv(t, e, r)];
}
function J9(t, e, r) {
  return ["throw", jv(t, e, r)];
}
function K9(t, e) {
  if (Os(t.originalText, e) || se(e, de.Leading, (r) => _n(t.originalText, st(r), Ze(r))) && !bt(e))
    return !0;
  if (sg(e)) {
    let r = e, i;
    for (; i = h_(r); )
      if (r = i, Os(t.originalText, r))
        return !0;
  }
  return !1;
}
var Tp = /* @__PURE__ */ new WeakMap();
function Rv(t) {
  return Tp.has(t) || Tp.set(t, t.type === "ConditionalExpression" && !Ut(t, (e) => e.type === "ObjectExpression")), Tp.get(t);
}
var Zv = (t) => t.type === "SequenceExpression";
function eM(t, e, r, i = {}) {
  let n = [], s, a = [], l = !1, u = !i.expandLastArg && t.node.body.type === "ArrowFunctionExpression", h;
  (function v() {
    let { node: w } = t, x = tM(t, e, r, i);
    if (n.length === 0)
      n.push(x);
    else {
      let { leading: S, trailing: k } = iv(t, e);
      n.push([S, x]), a.unshift(k);
    }
    u && (l || (l = w.returnType && qt(w).length > 0 || w.typeParameters || qt(w).some((S) => S.type !== "Identifier"))), !u || w.body.type !== "ArrowFunctionExpression" ? (s = r("body", i), h = w.body) : t.call(v, "body");
  })();
  let p = !Os(e.originalText, h) && (Zv(h) || rM(h, s, e) || !l && Rv(h)), d = t.key === "callee" && Ea(t.parent), m = Symbol("arrow-chain"), y = iM(t, i, { signatureDocs: n, shouldBreak: l }), O, D = !1;
  return u && (d || i.assignmentLayout) && (D = !0, O = i.assignmentLayout === "chain-tail-arrow-chain" || d && !p), s = nM(t, e, i, { bodyDoc: s, bodyComments: a, functionBody: h, shouldPutBodyOnSameLine: p }), Z([Z(D ? te([H, y]) : y, { shouldBreak: O, id: m }), " =>", u ? Fh(s, { groupId: m }) : Z(s), u && d ? Ee(H, "", { groupId: m }) : ""]);
}
function tM(t, e, r, i) {
  let { node: n } = t, s = [];
  if (n.async && s.push("async "), Qv(t, e))
    s.push(r(["params", 0]));
  else {
    let l = i.expandLastArg || i.expandFirstArg, u = bg(t, r);
    if (l) {
      if (Yt(u))
        throw new yc();
      u = Z(Bd(u));
    }
    s.push(Z([$l(t, r, e, l, !0), u]));
  }
  let a = at(t, e, { filter(l) {
    let u = Pl(e.originalText, Ze(l));
    return u !== !1 && e.originalText.slice(u, u + 2) === "=>";
  } });
  return a && s.push(" ", a), s;
}
function rM(t, e, r) {
  var i, n;
  return Nt(t) || ni(t) || t.type === "ArrowFunctionExpression" || t.type === "DoExpression" || t.type === "BlockStatement" || bt(t) || ((i = e.label) == null ? void 0 : i.hug) !== !1 && (((n = e.label) == null ? void 0 : n.embed) || Eb(t, r.originalText));
}
function iM(t, e, { signatureDocs: r, shouldBreak: i }) {
  if (r.length === 1)
    return r[0];
  let { parent: n, key: s } = t;
  return s !== "callee" && Ea(n) || Vi(n) ? Z([r[0], " =>", te([he, Ie([" =>", he], r.slice(1))])], { shouldBreak: i }) : s === "callee" && Ea(n) || e.assignmentLayout ? Z(Ie([" =>", he], r), { shouldBreak: i }) : Z(te(Ie([" =>", he], r)), { shouldBreak: i });
}
function nM(t, e, r, { bodyDoc: i, bodyComments: n, functionBody: s, shouldPutBodyOnSameLine: a }) {
  let { node: l, parent: u } = t, h = r.expandLastArg && Xn(e, "all") ? Ee(",") : "", p = (r.expandLastArg || u.type === "JSXExpressionContainer") && !se(l) ? H : "";
  return a && Rv(s) ? [" ", Z([Ee("", "("), te([H, i]), Ee("", ")"), h, p]), n] : (Zv(s) && (i = Z(["(", te([H, i]), H, ")"])), a ? [" ", i, n] : [te([he, i, n]), h, p]);
}
var sM = (t, e, r) => {
  if (!(t && e == null)) {
    if (e.findLast)
      return e.findLast(r);
    for (let i = e.length - 1; i >= 0; i--) {
      let n = e[i];
      if (r(n, i, e))
        return n;
    }
  }
}, aM = sM;
function qd(t, e, r, i) {
  let { node: n } = t, s = [], a = aM(!1, n[i], (l) => l.type !== "EmptyStatement");
  return t.each(({ node: l }) => {
    l.type !== "EmptyStatement" && (s.push(r()), l !== a && (s.push(ee), Vn(l, e) && s.push(ee)));
  }, i), s;
}
function Wv(t, e, r) {
  let { node: i } = t, n = [];
  i.type === "StaticBlock" && n.push("static "), n.push("{");
  let s = qv(t, e, r);
  if (s)
    n.push(te([ee, s]), ee);
  else {
    let { parent: a } = t, l = t.grandparent;
    a.type === "ArrowFunctionExpression" || a.type === "FunctionExpression" || a.type === "FunctionDeclaration" || a.type === "ObjectMethod" || a.type === "ClassMethod" || a.type === "ClassPrivateMethod" || a.type === "ForStatement" || a.type === "WhileStatement" || a.type === "DoWhileStatement" || a.type === "DoExpression" || a.type === "CatchClause" && !l.finalizer || a.type === "TSModuleDeclaration" || a.type === "TSDeclareFunction" || i.type === "StaticBlock" || n.push(ee);
  }
  return n.push("}"), n;
}
function qv(t, e, r) {
  var i;
  let { node: n } = t, s = Re(n.directives), a = n.body.some((h) => h.type !== "EmptyStatement"), l = se(n, de.Dangling);
  if (!s && !a && !l)
    return "";
  let u = [];
  return s && (u.push(qd(t, e, r, "directives")), (a || l) && (u.push(ee), Vn(We(!1, n.directives, -1), e) && u.push(ee))), a && u.push(qd(t, e, r, "body")), l && u.push(at(t, e)), n.type === "Program" && ((i = t.parent) == null ? void 0 : i.type) !== "ModuleExpression" && u.push(ee), u;
}
function oM(t) {
  let e = /* @__PURE__ */ new WeakMap();
  return function(r) {
    return e.has(r) || e.set(r, Symbol(t)), e.get(r);
  };
}
var Xv = oM;
function lM(t) {
  switch (t) {
    case null:
      return "";
    case "PlusOptional":
      return "+?";
    case "MinusOptional":
      return "-?";
    case "Optional":
      return "?";
  }
}
function uM(t, e, r) {
  let { node: i } = t;
  return Z([i.variance ? r("variance") : "", "[", te([r("keyTparam"), " in ", r("sourceType")]), "]", lM(i.optional), ": ", r("propType")]);
}
function Vv(t, e) {
  return t === "+" || t === "-" ? t + e : e;
}
function cM(t, e, r) {
  let { node: i } = t, n = _n(e.originalText, st(i), st(i.typeParameter));
  return Z(["{", te([e.bracketSpacing ? he : H, Z([r("typeParameter"), i.optional ? Vv(i.optional, "?") : "", i.typeAnnotation ? ": " : "", r("typeAnnotation")]), e.semi ? Ee(";") : ""]), at(t, e), e.bracketSpacing ? he : H, "}"], { shouldBreak: n });
}
var vg = Xv("typeParameters");
function hM(t, e, r) {
  let { node: i } = t;
  return qt(i).length === 1 && i.type.startsWith("TS") && !i[r][0].constraint && t.parent.type === "ArrowFunctionExpression" && !(e.filepath && /\.ts$/.test(e.filepath));
}
function Lo(t, e, r, i) {
  let { node: n } = t;
  if (!n[i])
    return "";
  if (!Array.isArray(n[i]))
    return r(i);
  let s = t.getNode(2), a = s && Th(s), l = t.match((h) => !(h[i].length === 1 && Nn(h[i][0])), void 0, (h, p) => p === "typeAnnotation", (h) => h.type === "Identifier", fv);
  if (n[i].length === 0 || !l && (a || n[i].length === 1 && (n[i][0].type === "NullableTypeAnnotation" || yv(n[i][0]))))
    return ["<", Ie(", ", t.map(r, i)), pM(t, e), ">"];
  let u = n.type === "TSTypeParameterInstantiation" ? "" : hM(t, e, i) ? "," : Xn(e) ? Ee(",") : "";
  return Z(["<", te([H, Ie([",", he], t.map(r, i))]), u, H, ">"], { id: vg(n) });
}
function pM(t, e) {
  let { node: r } = t;
  if (!se(r, de.Dangling))
    return "";
  let i = !se(r, de.Line), n = at(t, e, { indent: !i });
  return i ? n : [n, ee];
}
function Uv(t, e, r) {
  let { node: i, parent: n } = t, s = [i.type === "TSTypeParameter" && i.const ? "const " : ""], a = i.type === "TSTypeParameter" ? r("name") : i.name;
  if (n.type === "TSMappedType")
    return n.readonly && s.push(Vv(n.readonly, "readonly"), " "), s.push("[", a), i.constraint && s.push(" in ", r("constraint")), n.nameType && s.push(" as ", t.callParent(() => r("nameType"))), s.push("]"), s;
  if (i.variance && s.push(r("variance")), i.in && s.push("in "), i.out && s.push("out "), s.push(a), i.bound && (i.usesExtendsBound && s.push(" extends "), s.push(Bt(t, r, "bound"))), i.constraint) {
    let l = Symbol("constraint");
    s.push(" extends", Z(te(he), { id: l }), Ui, Fh(r("constraint"), { groupId: l }));
  }
  return i.default && s.push(" = ", r("default")), Z(s);
}
var Yv = Ue(["ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
function zv(t, e, r) {
  let { node: i } = t, n = [Zr(t), Bh(t), "class"], s = se(i.id, de.Trailing) || se(i.typeParameters, de.Trailing) || se(i.superClass) || Re(i.extends) || Re(i.mixins) || Re(i.implements), a = [], l = [];
  if (i.id && a.push(" ", r("id")), a.push(r("typeParameters")), i.superClass) {
    let u = [fM(t, e, r), r("superTypeParameters")], h = t.call((p) => ["extends ", ii(p, u, e)], "superClass");
    s ? l.push(he, Z(h)) : l.push(" ", h);
  } else
    l.push(Pp(t, e, r, "extends"));
  if (l.push(Pp(t, e, r, "mixins"), Pp(t, e, r, "implements")), s) {
    let u;
    Jv(i) ? u = [...a, te(l)] : u = te([...a, l]), n.push(Z(u, { id: Gv(i) }));
  } else
    n.push(...a, ...l);
  return n.push(" ", r("body")), n;
}
var Gv = Xv("heritageGroup");
function Hv(t) {
  return Ee(ee, "", { groupId: Gv(t) });
}
function dM(t) {
  return ["extends", "mixins", "implements"].reduce((e, r) => e + (Array.isArray(t[r]) ? t[r].length : 0), t.superClass ? 1 : 0) > 1;
}
function Jv(t) {
  return t.typeParameters && !se(t.typeParameters, de.Trailing | de.Line) && !dM(t);
}
function Pp(t, e, r, i) {
  let { node: n } = t;
  if (!Re(n[i]))
    return "";
  let s = at(t, e, { marker: i });
  return [Jv(n) ? Ee(" ", he, { groupId: vg(n.typeParameters) }) : he, s, s && ee, i, Z(te([he, Ie([",", he], t.map(r, i))]))];
}
function fM(t, e, r) {
  let i = r("superClass"), { parent: n } = t;
  return n.type === "AssignmentExpression" ? Z(Ee(["(", te([H, i]), H, ")"], i)) : i;
}
function Kv(t, e, r) {
  let { node: i } = t, n = [];
  return Re(i.decorators) && n.push(av(t, e, r)), n.push(Oc(i)), i.static && n.push("static "), n.push(Bh(t)), i.override && n.push("override "), n.push(Wd(t, e, r)), n;
}
function ew(t, e, r) {
  let { node: i } = t, n = [], s = e.semi ? ";" : "";
  Re(i.decorators) && n.push(av(t, e, r)), n.push(Oc(i), Zr(t)), i.static && n.push("static "), n.push(Bh(t)), i.override && n.push("override "), i.readonly && n.push("readonly "), i.variance && n.push(r("variance")), (i.type === "ClassAccessorProperty" || i.type === "AccessorProperty" || i.type === "TSAbstractAccessorProperty") && n.push("accessor "), n.push(Bl(t, e, r), zt(t), Fv(t), Bt(t, r));
  let a = i.type === "TSAbstractPropertyDefinition" || i.type === "TSAbstractAccessorProperty";
  return [Fl(t, e, r, n, " =", a ? void 0 : "value"), s];
}
function mM(t, e, r) {
  let { node: i } = t, n = [];
  return t.each(({ node: s, next: a, isLast: l }) => {
    n.push(r()), !e.semi && Yv(s) && gM(s, a) && n.push(";"), l || (n.push(ee), Vn(s, e) && n.push(ee));
  }, "body"), se(i, de.Dangling) && n.push(at(t, e)), [Re(i.body) ? Hv(t.parent) : "", "{", n.length > 0 ? [te([ee, n]), ee] : "", "}"];
}
function gM(t, e) {
  var r;
  let { type: i, name: n } = t.key;
  if (!t.computed && i === "Identifier" && (n === "static" || n === "get" || n === "set") && !t.value && !t.typeAnnotation)
    return !0;
  if (!e || e.static || e.accessibility)
    return !1;
  if (!e.computed) {
    let s = (r = e.key) == null ? void 0 : r.name;
    if (s === "in" || s === "instanceof")
      return !0;
  }
  if (Yv(e) && e.variance && !e.static && !e.declare)
    return !0;
  switch (e.type) {
    case "ClassProperty":
    case "PropertyDefinition":
    case "TSAbstractPropertyDefinition":
      return e.computed;
    case "MethodDefinition":
    case "TSAbstractMethodDefinition":
    case "ClassMethod":
    case "ClassPrivateMethod": {
      if ((e.value ? e.value.async : e.async) || e.kind === "get" || e.kind === "set")
        return !1;
      let s = e.value ? e.value.generator : e.generator;
      return !!(e.computed || s);
    }
    case "TSIndexSignature":
      return !0;
  }
  return !1;
}
function yM(t, e) {
  if (e.semi || rw(t, e) || nw(t, e))
    return !1;
  let { node: r, key: i, parent: n } = t;
  return !!(r.type === "ExpressionStatement" && (i === "body" && (n.type === "Program" || n.type === "BlockStatement" || n.type === "StaticBlock" || n.type === "TSModuleBlock") || i === "consequent" && n.type === "SwitchCase") && t.call(() => tw(t, e), "expression"));
}
function tw(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "ParenthesizedExpression":
    case "TypeCastExpression":
    case "ArrayExpression":
    case "ArrayPattern":
    case "TemplateLiteral":
    case "TemplateElement":
    case "RegExpLiteral":
      return !0;
    case "ArrowFunctionExpression":
      if (!Qv(t, e))
        return !0;
      break;
    case "UnaryExpression": {
      let { prefix: i, operator: n } = r;
      if (i && (n === "+" || n === "-"))
        return !0;
      break;
    }
    case "BindExpression":
      if (!r.object)
        return !0;
      break;
    case "Literal":
      if (r.regex)
        return !0;
      break;
    default:
      if (bt(r))
        return !0;
  }
  return Qs(t, e) ? !0 : sg(r) ? t.call(() => tw(t, e), ...yb(r)) : !1;
}
function rw({ node: t, parent: e }, r) {
  return (r.parentParser === "markdown" || r.parentParser === "mdx") && t.type === "ExpressionStatement" && bt(t.expression) && e.type === "Program" && e.body.length === 1;
}
function iw(t) {
  switch (t.type) {
    case "MemberExpression":
      switch (t.property.type) {
        case "Identifier":
        case "NumericLiteral":
        case "StringLiteral":
          return iw(t.object);
      }
      return !1;
    case "Identifier":
      return !0;
    default:
      return !1;
  }
}
function nw({ node: t, parent: e }, r) {
  return (r.parser === "__vue_event_binding" || r.parser === "__vue_ts_event_binding") && t.type === "ExpressionStatement" && e.type === "Program" && e.body.length === 1;
}
function OM(t, e, r) {
  let i = [r("expression")];
  return nw(t, e) ? iw(t.node.expression) && i.push(";") : rw(t, e) || e.semi && i.push(";"), i;
}
function xM(t, e, r) {
  if (e.__isVueBindings || e.__isVueForBindingLeft) {
    let i = t.map(r, "program", "body", 0, "params");
    if (i.length === 1)
      return i[0];
    let n = Ie([",", he], i);
    return e.__isVueForBindingLeft ? ["(", te([H, Z(n)]), H, ")"] : n;
  }
  if (e.__isEmbeddedTypescriptGenericParameters) {
    let i = t.map(r, "program", "body", 0, "typeParameters", "params");
    return Ie([",", he], i);
  }
}
function DM(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "RegExpLiteral":
      return s1(r);
    case "BigIntLiteral":
      return Xd(r.extra.raw);
    case "NumericLiteral":
      return wn(r.extra.raw);
    case "StringLiteral":
      return bs(Go(r.extra.raw, e));
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return String(r.value);
    case "DecimalLiteral":
      return wn(r.value) + "m";
    case "DirectiveLiteral":
      return a1(r.extra.raw, e);
    case "Literal": {
      if (r.regex)
        return s1(r.regex);
      if (r.bigint)
        return Xd(r.raw);
      if (r.decimal)
        return wn(r.decimal) + "m";
      let { value: i } = r;
      return typeof i == "number" ? wn(r.raw) : typeof i == "string" ? bM(t) ? a1(r.raw, e) : bs(Go(r.raw, e)) : String(i);
    }
  }
}
function bM(t) {
  if (t.key !== "expression")
    return;
  let { parent: e } = t;
  return e.type === "ExpressionStatement" && e.directive;
}
function Xd(t) {
  return t.toLowerCase();
}
function s1({ pattern: t, flags: e }) {
  return e = [...e].sort().join(""), `/${t}/${e}`;
}
function a1(t, e) {
  let r = t.slice(1, -1);
  if (r.includes('"') || r.includes("'"))
    return t;
  let i = e.singleQuote ? "'" : '"';
  return i + r + i;
}
function vM(t, e, r) {
  let i = t.originalText.slice(e, r);
  for (let n of t[Symbol.for("comments")]) {
    let s = st(n);
    if (s > r)
      break;
    let a = Ze(n);
    if (a < e)
      continue;
    let l = a - s;
    i = i.slice(0, s - e) + " ".repeat(l) + i.slice(a - e);
  }
  return i;
}
var wg = vM;
function wM(t, e, r) {
  let { node: i } = t;
  return ["import", i.module ? " module" : "", i.phase ? ` ${i.phase}` : "", ow(i), uw(t, e, r), lw(t, e, r), hw(t, e, r), e.semi ? ";" : ""];
}
var sw = (t) => t.type === "ExportDefaultDeclaration" || t.type === "DeclareExportDeclaration" && t.default;
function aw(t, e, r) {
  let { node: i } = t, n = [o9(t, e, r), Zr(t), "export", sw(i) ? " default" : ""], { declaration: s, exported: a } = i;
  return se(i, de.Dangling) && (n.push(" ", at(t, e)), Ab(i) && n.push(ee)), s ? n.push(" ", r("declaration")) : (n.push(EM(i)), i.type === "ExportAllDeclaration" || i.type === "DeclareExportAllDeclaration" ? (n.push(" *"), a && n.push(" as ", r("exported"))) : n.push(uw(t, e, r)), n.push(lw(t, e, r), hw(t, e, r))), n.push(CM(i, e)), n;
}
var SM = Ue(["ClassDeclaration", "FunctionDeclaration", "TSInterfaceDeclaration", "DeclareClass", "DeclareFunction", "TSDeclareFunction", "EnumDeclaration"]);
function CM(t, e) {
  return e.semi && (!t.declaration || sw(t) && !SM(t.declaration)) ? ";" : "";
}
function Sg(t, e = !0) {
  return t && t !== "value" ? `${e ? " " : ""}${t}${e ? "" : " "}` : "";
}
function ow(t, e) {
  return Sg(t.importKind, e);
}
function EM(t) {
  return Sg(t.exportKind);
}
function lw(t, e, r) {
  let { node: i } = t;
  if (!i.source)
    return "";
  let n = [];
  return cw(i, e) && n.push(" from"), n.push(" ", r("source")), n;
}
function uw(t, e, r) {
  let { node: i } = t;
  if (!cw(i, e))
    return "";
  let n = [" "];
  if (Re(i.specifiers)) {
    let s = [], a = [];
    t.each(() => {
      let l = t.node.type;
      if (l === "ExportNamespaceSpecifier" || l === "ExportDefaultSpecifier" || l === "ImportNamespaceSpecifier" || l === "ImportDefaultSpecifier")
        s.push(r());
      else if (l === "ExportSpecifier" || l === "ImportSpecifier")
        a.push(r());
      else
        throw new qa(i, "specifier");
    }, "specifiers"), n.push(Ie(", ", s)), a.length > 0 && (s.length > 0 && n.push(", "), a.length > 1 || s.length > 0 || i.specifiers.some((l) => se(l)) ? n.push(Z(["{", te([e.bracketSpacing ? he : H, Ie([",", he], a)]), Ee(Xn(e) ? "," : ""), e.bracketSpacing ? he : H, "}"])) : n.push(["{", e.bracketSpacing ? " " : "", ...a, e.bracketSpacing ? " " : "", "}"]));
  } else
    n.push("{}");
  return n;
}
function cw(t, e) {
  return t.type !== "ImportDeclaration" || Re(t.specifiers) || t.importKind === "type" ? !0 : wg(e, st(t), st(t.source)).trimEnd().endsWith("from");
}
function AM(t, e) {
  var r, i;
  if ((r = t.extra) != null && r.deprecatedAssertSyntax)
    return "assert";
  let n = wg(e, Ze(t.source), (i = t.attributes) != null && i[0] ? st(t.attributes[0]) : Ze(t)).trimStart();
  return n.startsWith("assert") ? "assert" : n.startsWith("with") || Re(t.attributes) ? "with" : void 0;
}
function hw(t, e, r) {
  let { node: i } = t;
  if (!i.source)
    return "";
  let n = AM(i, e);
  if (!n)
    return "";
  let s = [` ${n} {`];
  return Re(i.attributes) && (e.bracketSpacing && s.push(" "), s.push(Ie(", ", t.map(r, "attributes"))), e.bracketSpacing && s.push(" ")), s.push("}"), s;
}
function kM(t, e, r) {
  let { node: i } = t, { type: n } = i, s = n.startsWith("Import"), a = s ? "imported" : "local", l = s ? "local" : "exported", u = i[a], h = i[l], p = "", d = "";
  return n === "ExportNamespaceSpecifier" || n === "ImportNamespaceSpecifier" ? p = "*" : u && (p = r(a)), h && !TM(i) && (d = r(l)), [Sg(n === "ImportSpecifier" ? i.importKind : i.exportKind, !1), p, p && d ? " as " : "", d];
}
function TM(t) {
  if (t.type !== "ImportSpecifier" && t.type !== "ExportSpecifier")
    return !1;
  let { local: e, [t.type === "ImportSpecifier" ? "imported" : "exported"]: r } = t;
  if (e.type !== r.type || !J7(e, r))
    return !1;
  if (ar(e))
    return e.value === r.value && Qr(e) === Qr(r);
  switch (e.type) {
    case "Identifier":
      return e.name === r.name;
    default:
      return !1;
  }
}
function Ih(t, e, r) {
  var i;
  let n = e.semi ? ";" : "", { node: s } = t, a = s.type === "ObjectTypeAnnotation", l = s.type === "TSEnumDeclaration" || s.type === "EnumBooleanBody" || s.type === "EnumNumberBody" || s.type === "EnumStringBody" || s.type === "EnumSymbolBody", u = [s.type === "TSTypeLiteral" || l ? "members" : s.type === "TSInterfaceBody" ? "body" : "properties"];
  a && u.push("indexers", "callProperties", "internalSlots");
  let h = u.flatMap((A) => t.map(({ node: P }) => ({ node: P, printed: r(), loc: st(P) }), A));
  u.length > 1 && h.sort((A, P) => A.loc - P.loc);
  let { parent: p, key: d } = t, m = a && d === "body" && (p.type === "InterfaceDeclaration" || p.type === "DeclareInterface" || p.type === "DeclareClass"), y = s.type === "TSInterfaceBody" || l || m || s.type === "ObjectPattern" && p.type !== "FunctionDeclaration" && p.type !== "FunctionExpression" && p.type !== "ArrowFunctionExpression" && p.type !== "ObjectMethod" && p.type !== "ClassMethod" && p.type !== "ClassPrivateMethod" && p.type !== "AssignmentPattern" && p.type !== "CatchClause" && s.properties.some((A) => A.value && (A.value.type === "ObjectPattern" || A.value.type === "ArrayPattern")) || s.type !== "ObjectPattern" && h.length > 0 && _n(e.originalText, st(s), h[0].loc), O = m ? ";" : s.type === "TSInterfaceBody" || s.type === "TSTypeLiteral" ? Ee(n, ";") : ",", D = s.type === "RecordExpression" ? "#{" : s.exact ? "{|" : "{", v = s.exact ? "|}" : "}", w = [], x = h.map((A) => {
    let P = [...w, Z(A.printed)];
    return w = [O, he], (A.node.type === "TSPropertySignature" || A.node.type === "TSMethodSignature" || A.node.type === "TSConstructSignatureDeclaration" || A.node.type === "TSCallSignatureDeclaration") && se(A.node, de.PrettierIgnore) && w.shift(), Vn(A.node, e) && w.push(ee), P;
  });
  if (s.inexact || s.hasUnknownMembers) {
    let A;
    if (se(s, de.Dangling)) {
      let P = se(s, de.Line);
      A = [at(t, e), P || wr(e.originalText, Ze(We(!1, pa(s), -1))) ? ee : he, "..."];
    } else
      A = ["..."];
    x.push([...w, ...A]);
  }
  let S = (i = We(!1, h, -1)) == null ? void 0 : i.node, k = !(s.inexact || s.hasUnknownMembers || S && (S.type === "RestElement" || (S.type === "TSPropertySignature" || S.type === "TSCallSignatureDeclaration" || S.type === "TSMethodSignature" || S.type === "TSConstructSignatureDeclaration") && se(S, de.PrettierIgnore))), C;
  if (x.length === 0) {
    if (!se(s, de.Dangling))
      return [D, v, Bt(t, r)];
    C = Z([D, at(t, e, { indent: !0 }), H, v, zt(t), Bt(t, r)]);
  } else
    C = [m && Re(s.properties) ? Hv(p) : "", D, te([e.bracketSpacing ? he : H, ...x]), Ee(k && (O !== "," || Xn(e)) ? O : ""), e.bracketSpacing ? he : H, v, zt(t), Bt(t, r)];
  return t.match((A) => A.type === "ObjectPattern" && !Re(A.decorators), Fp) || Nn(s) && (t.match(void 0, (A, P) => P === "typeAnnotation", (A, P) => P === "typeAnnotation", Fp) || t.match(void 0, (A, P) => A.type === "FunctionTypeParam" && P === "typeAnnotation", Fp)) || !y && t.match((A) => A.type === "ObjectPattern", (A) => A.type === "AssignmentExpression" || A.type === "VariableDeclarator") ? C : Z(C, { shouldBreak: y });
}
function Fp(t, e) {
  return (e === "params" || e === "parameters" || e === "this" || e === "rest") && gv(t);
}
function PM(t) {
  let e = [t];
  for (let r = 0; r < e.length; r++) {
    let i = e[r];
    for (let n of ["test", "consequent", "alternate"]) {
      let s = i[n];
      if (bt(s))
        return !0;
      s.type === "ConditionalExpression" && e.push(s);
    }
  }
  return !1;
}
function FM(t, e, r) {
  let { node: i } = t, n = i.type === "ConditionalExpression", s = n ? "alternate" : "falseType", { parent: a } = t, l = n ? r("test") : [r("checkType"), " ", "extends", " ", r("extendsType")];
  return a.type === i.type && a[s] === i ? Fi(2, l) : l;
}
var $M = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
function BM(t) {
  let { node: e } = t;
  if (e.type !== "ConditionalExpression")
    return !1;
  let r, i = e;
  for (let n = 0; !r; n++) {
    let s = t.getParentNode(n);
    if (s.type === "ChainExpression" && s.expression === i || Qe(s) && s.callee === i || nt(s) && s.object === i || s.type === "TSNonNullExpression" && s.expression === i) {
      i = s;
      continue;
    }
    s.type === "NewExpression" && s.callee === i || bi(s) && s.expression === i ? (r = t.getParentNode(n + 1), i = s) : r = s;
  }
  return i === e ? !1 : r[$M.get(r.type)] === i;
}
function IM(t, e, r) {
  let { node: i } = t, n = i.type === "ConditionalExpression", s = n ? "consequent" : "trueType", a = n ? "alternate" : "falseType", l = n ? ["test"] : ["checkType", "extendsType"], u = i[s], h = i[a], p = [], d = !1, { parent: m } = t, y = m.type === i.type && l.some((B) => m[B] === i), O = m.type === i.type && !y, D, v, w = 0;
  do
    v = D || i, D = t.getParentNode(w), w++;
  while (D && D.type === i.type && l.every((B) => D[B] !== v));
  let x = D || m, S = v;
  if (n && (bt(i[l[0]]) || bt(u) || bt(h) || PM(S))) {
    d = !0, O = !0;
    let B = (R) => [Ee("("), te([H, R]), H, Ee(")")], _ = (R) => R.type === "NullLiteral" || R.type === "Literal" && R.value === null || R.type === "Identifier" && R.name === "undefined";
    p.push(" ? ", _(u) ? r(s) : B(r(s)), " : ", h.type === i.type || _(h) ? r(a) : B(r(a)));
  } else {
    let B = (R) => e.useTabs ? te(r(R)) : Fi(2, r(R)), _ = [he, "? ", u.type === i.type ? Ee("", "(") : "", B(s), u.type === i.type ? Ee("", ")") : "", he, ": ", B(a)];
    p.push(m.type !== i.type || m[a] === i || y ? _ : e.useTabs ? Ib(te(_)) : Fi(Math.max(0, e.tabWidth - 2), _));
  }
  let k = [s, a, ...l].some((B) => se(i[B], (_) => Wr(_) && _n(e.originalText, st(_), Ze(_)))), C = (B) => m === x ? Z(B, { shouldBreak: k }) : k ? [B, $i] : B, A = !d && (nt(m) || m.type === "NGPipeExpression" && m.left === i) && !m.computed, P = BM(t), I = C([FM(t, e, r), O ? p : te(p), n && A && !P ? H : ""]);
  return y || P ? Z([te([H, I]), H]) : I;
}
function NM(t, e) {
  return (nt(e) || e.type === "NGPipeExpression" && e.left === t) && !e.computed;
}
function _M(t, e, r, i) {
  return [...t.map((n) => pa(n)), pa(e), pa(r)].flat().some((n) => Wr(n) && _n(i.originalText, st(n), Ze(n)));
}
var MM = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
function LM(t) {
  let { node: e } = t;
  if (e.type !== "ConditionalExpression")
    return !1;
  let r, i = e;
  for (let n = 0; !r; n++) {
    let s = t.getParentNode(n);
    if (s.type === "ChainExpression" && s.expression === i || Qe(s) && s.callee === i || nt(s) && s.object === i || s.type === "TSNonNullExpression" && s.expression === i) {
      i = s;
      continue;
    }
    s.type === "NewExpression" && s.callee === i || bi(s) && s.expression === i ? (r = t.getParentNode(n + 1), i = s) : r = s;
  }
  return i === e ? !1 : r[MM.get(r.type)] === i;
}
var $p = (t) => [Ee("("), te([H, t]), H, Ee(")")];
function Cg(t, e, r, i) {
  if (!e.experimentalTernaries)
    return IM(t, e, r);
  let { node: n } = t, s = n.type === "ConditionalExpression", a = n.type === "TSConditionalType" || n.type === "ConditionalTypeAnnotation", l = s ? "consequent" : "trueType", u = s ? "alternate" : "falseType", h = s ? ["test"] : ["checkType", "extendsType"], p = n[l], d = n[u], m = h.map((Ae) => n[Ae]), { parent: y } = t, O = y.type === n.type, D = O && h.some((Ae) => y[Ae] === n), v = O && y[u] === n, w = p.type === n.type, x = d.type === n.type, S = x || v, k = e.tabWidth > 2 || e.useTabs, C, A, P = 0;
  do
    A = C || n, C = t.getParentNode(P), P++;
  while (C && C.type === n.type && h.every((Ae) => C[Ae] !== A));
  let I = C || y, B = i && i.assignmentLayout && i.assignmentLayout !== "break-after-operator" && (y.type === "AssignmentExpression" || y.type === "VariableDeclarator" || y.type === "ClassProperty" || y.type === "PropertyDefinition" || y.type === "ClassPrivateProperty" || y.type === "ObjectProperty" || y.type === "Property"), _ = (y.type === "ReturnStatement" || y.type === "ThrowStatement") && !(w || x), R = s && I.type === "JSXExpressionContainer" && t.grandparent.type !== "JSXAttribute", G = LM(t), J = NM(n, y), Q = a && Qs(t, e), q = k ? e.useTabs ? "	" : " ".repeat(e.tabWidth - 1) : "", X = _M(m, p, d, e) || w || x, K = !S && !O && !a && (R ? p.type === "NullLiteral" || p.type === "Literal" && p.value === null : og(p, e) && R0(n.test, 3)), ye = S || v || a && !O || O && s && R0(n.test, 1) || K, Ce = [];
  !w && se(p, de.Dangling) && t.call((Ae) => {
    Ce.push(at(Ae, e), ee);
  }, "consequent");
  let be = [];
  se(n.test, de.Dangling) && t.call((Ae) => {
    be.push(at(Ae, e));
  }, "test"), !x && se(d, de.Dangling) && t.call((Ae) => {
    be.push(at(Ae, e));
  }, "alternate"), se(n, de.Dangling) && be.push(at(t, e));
  let Le = Symbol("test"), Ye = Symbol("consequent"), Je = Symbol("test-and-consequent"), Te = s ? [$p(r("test")), n.test.type === "ConditionalExpression" ? $i : ""] : [r("checkType"), " ", "extends", " ", n.extendsType.type === "TSConditionalType" || n.extendsType.type === "ConditionalTypeAnnotation" || n.extendsType.type === "TSMappedType" ? r("extendsType") : Z($p(r("extendsType")))], ht = Z([Te, " ?"], { id: Le }), ue = r(l), V = te([w || R && (bt(p) || O || S) ? ee : he, Ce, ue]), W = ye ? Z([ht, S ? V : Ee(V, Z(V, { id: Ye }), { groupId: Le })], { id: Je }) : [ht, V], j = r(u), ve = K ? Ee(j, Ib($p(j)), { groupId: Je }) : j, De = [W, be.length > 0 ? [te([ee, be]), ee] : x ? ee : K ? Ee(he, " ", { groupId: Je }) : he, ":", x ? " " : k ? ye ? Ee(q, Ee(S || K ? " " : q, " "), { groupId: Je }) : Ee(q, " ") : " ", x ? ve : Z([te(ve), R && !K ? H : ""]), J && !G ? H : "", X ? $i : ""];
  return B && !X ? Z(te([H, Z(De)])) : B || _ ? Z(te(De)) : G || a && D ? Z([te([H, De]), Q ? H : ""]) : y === I ? Z(De) : De;
}
function QM(t, e, r, i) {
  let { node: n } = t;
  if (Ah(n))
    return DM(t, e);
  let s = e.semi ? ";" : "", a = [];
  switch (n.type) {
    case "JsExpressionRoot":
      return r("node");
    case "JsonRoot":
      return [r("node"), ee];
    case "File":
      return xM(t, e, r) ?? r("program");
    case "Program":
      return qv(t, e, r);
    case "EmptyStatement":
      return "";
    case "ExpressionStatement":
      return OM(t, e, r);
    case "ChainExpression":
      return r("expression");
    case "ParenthesizedExpression":
      return !se(n.expression) && (ni(n.expression) || Nt(n.expression)) ? ["(", r("expression"), ")"] : Z(["(", te([H, r("expression")]), H, ")"]);
    case "AssignmentExpression":
      return D9(t, e, r);
    case "VariableDeclarator":
      return b9(t, e, r);
    case "BinaryExpression":
    case "LogicalExpression":
      return sv(t, e, r);
    case "AssignmentPattern":
      return [r("left"), " = ", r("right")];
    case "OptionalMemberExpression":
    case "MemberExpression":
      return g9(t, e, r);
    case "MetaProperty":
      return [r("meta"), ".", r("property")];
    case "BindExpression":
      return n.object && a.push(r("object")), a.push(Z(te([H, $v(t, e, r)]))), a;
    case "Identifier":
      return [n.name, zt(t), Fv(t), Bt(t, r)];
    case "V8IntrinsicIdentifier":
      return ["%", n.name];
    case "SpreadElement":
    case "SpreadElementPattern":
    case "SpreadPropertyPattern":
    case "RestElement":
      return Bv(t, r);
    case "FunctionDeclaration":
    case "FunctionExpression":
      return Lv(t, r, e, i);
    case "ArrowFunctionExpression":
      return eM(t, e, r, i);
    case "YieldExpression":
      return a.push("yield"), n.delegate && a.push("*"), n.argument && a.push(" ", r("argument")), a;
    case "AwaitExpression":
      if (a.push("await"), n.argument) {
        a.push(" ", r("argument"));
        let { parent: l } = t;
        if (Qe(l) && l.callee === n || nt(l) && l.object === n) {
          a = [te([H, ...a]), H];
          let u = t.findAncestor((h) => h.type === "AwaitExpression" || h.type === "BlockStatement");
          if ((u == null ? void 0 : u.type) !== "AwaitExpression" || !Ut(u.argument, (h) => h === n))
            return Z(a);
        }
      }
      return a;
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ExportAllDeclaration":
      return aw(t, e, r);
    case "ImportDeclaration":
      return wM(t, e, r);
    case "ImportSpecifier":
    case "ExportSpecifier":
    case "ImportNamespaceSpecifier":
    case "ExportNamespaceSpecifier":
    case "ImportDefaultSpecifier":
    case "ExportDefaultSpecifier":
      return kM(t, e, r);
    case "ImportAttribute":
      return [r("key"), ": ", r("value")];
    case "Import":
      return "import";
    case "BlockStatement":
    case "StaticBlock":
      return Wv(t, e, r);
    case "ClassBody":
      return mM(t, e, r);
    case "ThrowStatement":
      return J9(t, e, r);
    case "ReturnStatement":
      return H9(t, e, r);
    case "NewExpression":
    case "ImportExpression":
    case "OptionalCallExpression":
    case "CallExpression":
      return pv(t, e, r);
    case "ObjectExpression":
    case "ObjectPattern":
    case "RecordExpression":
      return Ih(t, e, r);
    case "Property":
      return kh(n) ? Wd(t, e, r) : n1(t, e, r);
    case "ObjectProperty":
      return n1(t, e, r);
    case "ObjectMethod":
      return Wd(t, e, r);
    case "Decorator":
      return ["@", r("expression")];
    case "ArrayExpression":
    case "ArrayPattern":
    case "TupleExpression":
      return xg(t, e, r);
    case "SequenceExpression": {
      let { parent: l } = t;
      if (l.type === "ExpressionStatement" || l.type === "ForStatement") {
        let u = [];
        return t.each(({ isFirst: h }) => {
          h ? u.push(r()) : u.push(",", te([he, r()]));
        }, "expressions"), Z(u);
      }
      return Z(Ie([",", he], t.map(r, "expressions")));
    }
    case "ThisExpression":
      return "this";
    case "Super":
      return "super";
    case "Directive":
      return [r("value"), s];
    case "UnaryExpression":
      return a.push(n.operator), /[a-z]$/.test(n.operator) && a.push(" "), se(n.argument) ? a.push(Z(["(", te([H, r("argument")]), H, ")"])) : a.push(r("argument")), a;
    case "UpdateExpression":
      return a.push(r("argument"), n.operator), n.prefix && a.reverse(), a;
    case "ConditionalExpression":
      return Cg(t, e, r, i);
    case "VariableDeclaration": {
      let l = t.map(r, "declarations"), u = t.parent, h = u.type === "ForStatement" || u.type === "ForInStatement" || u.type === "ForOfStatement", p = n.declarations.some((m) => m.init), d;
      return l.length === 1 && !se(n.declarations[0]) ? d = l[0] : l.length > 0 && (d = te(l[0])), a = [Zr(t), n.kind, d ? [" ", d] : "", te(l.slice(1).map((m) => [",", p && !h ? ee : he, m]))], h && u.body !== n || a.push(s), Z(a);
    }
    case "WithStatement":
      return Z(["with (", r("object"), ")", gn(n.body, r("body"))]);
    case "IfStatement": {
      let l = gn(n.consequent, r("consequent")), u = Z(["if (", Z([te([H, r("test")]), H]), ")", l]);
      if (a.push(u), n.alternate) {
        let h = se(n.consequent, de.Trailing | de.Line) || Ab(n), p = n.consequent.type === "BlockStatement" && !h;
        a.push(p ? " " : ee), se(n, de.Dangling) && a.push(at(t, e), h ? ee : " "), a.push("else", Z(gn(n.alternate, r("alternate"), n.alternate.type === "IfStatement")));
      }
      return a;
    }
    case "ForStatement": {
      let l = gn(n.body, r("body")), u = at(t, e), h = u ? [u, H] : "";
      return !n.init && !n.test && !n.update ? [h, Z(["for (;;)", l])] : [h, Z(["for (", Z([te([H, r("init"), ";", he, r("test"), ";", he, r("update")]), H]), ")", l])];
    }
    case "WhileStatement":
      return Z(["while (", Z([te([H, r("test")]), H]), ")", gn(n.body, r("body"))]);
    case "ForInStatement":
      return Z(["for (", r("left"), " in ", r("right"), ")", gn(n.body, r("body"))]);
    case "ForOfStatement":
      return Z(["for", n.await ? " await" : "", " (", r("left"), " of ", r("right"), ")", gn(n.body, r("body"))]);
    case "DoWhileStatement": {
      let l = gn(n.body, r("body"));
      return a = [Z(["do", l])], n.body.type === "BlockStatement" ? a.push(" ") : a.push(ee), a.push("while (", Z([te([H, r("test")]), H]), ")", s), a;
    }
    case "DoExpression":
      return [n.async ? "async " : "", "do ", r("body")];
    case "BreakStatement":
    case "ContinueStatement":
      return a.push(n.type === "BreakStatement" ? "break" : "continue"), n.label && a.push(" ", r("label")), a.push(s), a;
    case "LabeledStatement":
      return n.body.type === "EmptyStatement" ? [r("label"), ":;"] : [r("label"), ": ", r("body")];
    case "TryStatement":
      return ["try ", r("block"), n.handler ? [" ", r("handler")] : "", n.finalizer ? [" finally ", r("finalizer")] : ""];
    case "CatchClause":
      if (n.param) {
        let l = se(n.param, (h) => !Wr(h) || h.leading && wr(e.originalText, Ze(h)) || h.trailing && wr(e.originalText, st(h), { backwards: !0 })), u = r("param");
        return ["catch ", l ? ["(", te([H, u]), H, ") "] : ["(", u, ") "], r("body")];
      }
      return ["catch ", r("body")];
    case "SwitchStatement":
      return [Z(["switch (", te([H, r("discriminant")]), H, ")"]), " {", n.cases.length > 0 ? te([ee, Ie(ee, t.map(({ node: l, isLast: u }) => [r(), !u && Vn(l, e) ? ee : ""], "cases"))]) : "", ee, "}"];
    case "SwitchCase": {
      n.test ? a.push("case ", r("test"), ":") : a.push("default:"), se(n, de.Dangling) && a.push(" ", at(t, e));
      let l = n.consequent.filter((u) => u.type !== "EmptyStatement");
      if (l.length > 0) {
        let u = qd(t, e, r, "consequent");
        a.push(l.length === 1 && l[0].type === "BlockStatement" ? [" ", u] : te([ee, u]));
      }
      return a;
    }
    case "DebuggerStatement":
      return ["debugger", s];
    case "ClassDeclaration":
    case "ClassExpression":
      return zv(t, e, r);
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "MethodDefinition":
      return Kv(t, e, r);
    case "ClassProperty":
    case "PropertyDefinition":
    case "ClassPrivateProperty":
    case "ClassAccessorProperty":
    case "AccessorProperty":
      return ew(t, e, r);
    case "TemplateElement":
      return bs(n.value.raw);
    case "TemplateLiteral":
      return Hb(t, r, e);
    case "TaggedTemplateExpression":
      return Q4(r);
    case "PrivateIdentifier":
      return ["#", n.name];
    case "PrivateName":
      return ["#", r("id")];
    case "TopicReference":
      return "%";
    case "ArgumentPlaceholder":
      return "?";
    case "ModuleExpression": {
      a.push("module {");
      let l = r("body");
      return l && a.push(te([ee, l]), ee), a.push("}"), a;
    }
    case "InterpreterDirective":
    default:
      throw new qa(n, "ESTree");
  }
}
function pw(t, e, r) {
  let { parent: i, node: n, key: s } = t, a = [r("expression")];
  switch (n.type) {
    case "AsConstExpression":
      a.push(" as const");
      break;
    case "AsExpression":
    case "TSAsExpression":
      a.push(" as ", r("typeAnnotation"));
      break;
    case "SatisfiesExpression":
    case "TSSatisfiesExpression":
      a.push(" satisfies ", r("typeAnnotation"));
      break;
  }
  return s === "callee" && Qe(i) || s === "object" && nt(i) ? Z([te([H, ...a]), H]) : a;
}
function dw(t, e, r) {
  return Ih(t, r, e);
}
function fw(t, e) {
  let { node: r } = t, i = e("id");
  r.computed && (i = ["[", i, "]"]);
  let n = "";
  return r.initializer && (n = e("initializer")), r.init && (n = e("init")), n ? [i, " = ", n] : i;
}
function jM(t, e, r) {
  let { node: i } = t, n;
  if (i.type === "EnumSymbolBody" || i.explicitType)
    switch (i.type) {
      case "EnumBooleanBody":
        n = "boolean";
        break;
      case "EnumNumberBody":
        n = "number";
        break;
      case "EnumStringBody":
        n = "string";
        break;
      case "EnumSymbolBody":
        n = "symbol";
        break;
    }
  return [n ? `of ${n} ` : "", dw(t, e, r)];
}
function mw(t, e, r) {
  let { node: i } = t;
  return [Zr(t), i.const ? "const " : "", "enum ", e("id"), " ", i.type === "TSEnumDeclaration" ? dw(t, e, r) : e("body")];
}
function gw(t, e, r) {
  let { node: i } = t, n = [Zr(t), "interface"], s = [], a = [];
  i.type !== "InterfaceTypeAnnotation" && s.push(" ", r("id"), r("typeParameters"));
  let l = i.typeParameters && !se(i.typeParameters, de.Trailing | de.Line);
  return Re(i.extends) && a.push(l ? Ee(" ", he, { groupId: vg(i.typeParameters) }) : he, "extends ", (i.extends.length === 1 ? w_ : te)(Ie([",", he], t.map(r, "extends")))), se(i.id, de.Trailing) || Re(i.extends) ? l ? n.push(Z([...s, te(a)])) : n.push(Z(te([...s, ...a]))) : n.push(...s, ...a), n.push(" ", r("body")), Z(n);
}
function RM(t, e, r) {
  let { node: i } = t;
  if (mb(i))
    return i.type.slice(0, -14).toLowerCase();
  let n = e.semi ? ";" : "";
  switch (i.type) {
    case "DeclareClass":
      return zv(t, e, r);
    case "DeclareFunction":
      return [Zr(t), "function ", r("id"), r("predicate"), n];
    case "DeclareModule":
      return ["declare module ", r("id"), " ", r("body")];
    case "DeclareModuleExports":
      return ["declare module.exports", Bt(t, r), n];
    case "DeclareVariable":
      return [Zr(t), i.kind ?? "var", " ", r("id"), n];
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
      return aw(t, e, r);
    case "DeclareOpaqueType":
    case "OpaqueType":
      return j9(t, e, r);
    case "DeclareTypeAlias":
    case "TypeAlias":
      return Ov(t, e, r);
    case "IntersectionTypeAnnotation":
      return xv(t, e, r);
    case "UnionTypeAnnotation":
      return Dv(t, e, r);
    case "ConditionalTypeAnnotation":
      return Cg(t, e, r);
    case "InferTypeAnnotation":
      return wv(t, e, r);
    case "FunctionTypeAnnotation":
      return bv(t, e, r);
    case "TupleTypeAnnotation":
      return xg(t, e, r);
    case "TupleTypeLabeledElement":
      return Cv(t, e, r);
    case "TupleTypeSpreadElement":
      return Sv(t, e, r);
    case "GenericTypeAnnotation":
      return [r("id"), Lo(t, e, r, "typeParameters")];
    case "IndexedAccessType":
    case "OptionalIndexedAccessType":
      return vv(t, e, r);
    case "TypeAnnotation":
      return Av(t, e, r);
    case "TypeParameter":
      return Uv(t, e, r);
    case "TypeofTypeAnnotation":
      return Tv(t, r);
    case "ExistsTypeAnnotation":
      return "*";
    case "ArrayTypeAnnotation":
      return kv(r);
    case "DeclareEnum":
    case "EnumDeclaration":
      return mw(t, r, e);
    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
      return jM(t, r, e);
    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumStringMember":
    case "EnumDefaultedMember":
      return fw(t, r);
    case "FunctionTypeParam": {
      let s = i.name ? r("name") : t.parent.this === i ? "this" : "";
      return [s, zt(t), s ? ": " : "", r("typeAnnotation")];
    }
    case "DeclareInterface":
    case "InterfaceDeclaration":
    case "InterfaceTypeAnnotation":
      return gw(t, e, r);
    case "ClassImplements":
    case "InterfaceExtends":
      return [r("id"), r("typeParameters")];
    case "NullableTypeAnnotation":
      return ["?", r("typeAnnotation")];
    case "Variance": {
      let { kind: s } = i;
      return Mv.ok(s === "plus" || s === "minus"), s === "plus" ? "+" : "-";
    }
    case "KeyofTypeAnnotation":
      return ["keyof ", r("argument")];
    case "ObjectTypeCallProperty":
      return [i.static ? "static " : "", r("value")];
    case "ObjectTypeMappedTypeProperty":
      return uM(t, e, r);
    case "ObjectTypeIndexer":
      return [i.static ? "static " : "", i.variance ? r("variance") : "", "[", r("id"), i.id ? ": " : "", r("key"), "]: ", r("value")];
    case "ObjectTypeProperty": {
      let s = "";
      return i.proto ? s = "proto " : i.static && (s = "static "), [s, i.kind !== "init" ? i.kind + " " : "", i.variance ? r("variance") : "", Bl(t, e, r), zt(t), kh(i) ? "" : ": ", r("value")];
    }
    case "ObjectTypeAnnotation":
      return Ih(t, e, r);
    case "ObjectTypeInternalSlot":
      return [i.static ? "static " : "", "[[", r("id"), "]]", zt(t), i.method ? "" : ": ", r("value")];
    case "ObjectTypeSpreadProperty":
      return Bv(t, r);
    case "QualifiedTypeofIdentifier":
    case "QualifiedTypeIdentifier":
      return [r("qualification"), ".", r("id")];
    case "NullLiteralTypeAnnotation":
      return "null";
    case "BooleanLiteralTypeAnnotation":
      return String(i.value);
    case "StringLiteralTypeAnnotation":
      return bs(Go(Qr(i), e));
    case "NumberLiteralTypeAnnotation":
      return wn(i.raw ?? i.extra.raw);
    case "BigIntLiteralTypeAnnotation":
      return Xd(i.raw ?? i.extra.raw);
    case "TypeCastExpression":
      return ["(", r("expression"), Bt(t, r), ")"];
    case "TypePredicate":
      return Pv(t, r);
    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation":
      return Lo(t, e, r, "params");
    case "InferredPredicate":
    case "DeclaredPredicate":
      return [t.key === "predicate" && t.parent.type !== "DeclareFunction" && !t.parent.returnType ? ": " : " ", "%checks", ...i.type === "DeclaredPredicate" ? ["(", r("value"), ")"] : []];
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
      return pw(t, e, r);
  }
}
function ZM(t, e, r) {
  var i;
  let { node: n } = t;
  if (!n.type.startsWith("TS"))
    return;
  if (gb(n))
    return n.type.slice(2, -7).toLowerCase();
  let s = e.semi ? ";" : "", a = [];
  switch (n.type) {
    case "TSThisType":
      return "this";
    case "TSTypeAssertion": {
      let l = !(Nt(n.expression) || ni(n.expression)), u = Z(["<", te([H, r("typeAnnotation")]), H, ">"]), h = [Ee("("), te([H, r("expression")]), H, Ee(")")];
      return l ? os([[u, r("expression")], [u, Z(h, { shouldBreak: !0 })], [u, r("expression")]]) : Z([u, r("expression")]);
    }
    case "TSDeclareFunction":
      return Lv(t, r, e);
    case "TSExportAssignment":
      return ["export = ", r("expression"), s];
    case "TSModuleBlock":
      return Wv(t, e, r);
    case "TSInterfaceBody":
    case "TSTypeLiteral":
      return Ih(t, e, r);
    case "TSTypeAliasDeclaration":
      return Ov(t, e, r);
    case "TSQualifiedName":
      return [r("left"), ".", r("right")];
    case "TSAbstractMethodDefinition":
    case "TSDeclareMethod":
      return Kv(t, e, r);
    case "TSAbstractAccessorProperty":
    case "TSAbstractPropertyDefinition":
      return ew(t, e, r);
    case "TSInterfaceHeritage":
    case "TSClassImplements":
    case "TSExpressionWithTypeArguments":
    case "TSInstantiationExpression":
      return [r("expression"), r("typeParameters")];
    case "TSTemplateLiteralType":
      return Hb(t, r, e);
    case "TSNamedTupleMember":
      return Cv(t, e, r);
    case "TSRestType":
      return Sv(t, e, r);
    case "TSOptionalType":
      return [r("typeAnnotation"), "?"];
    case "TSInterfaceDeclaration":
      return gw(t, e, r);
    case "TSTypeParameterDeclaration":
    case "TSTypeParameterInstantiation":
      return Lo(t, e, r, "params");
    case "TSTypeParameter":
      return Uv(t, e, r);
    case "TSAsExpression":
    case "TSSatisfiesExpression":
      return pw(t, e, r);
    case "TSArrayType":
      return kv(r);
    case "TSPropertySignature":
      return [n.readonly ? "readonly " : "", Bl(t, e, r), zt(t), Bt(t, r)];
    case "TSParameterProperty":
      return [Oc(n), n.static ? "static " : "", n.override ? "override " : "", n.readonly ? "readonly " : "", r("parameter")];
    case "TSTypeQuery":
      return Tv(t, r);
    case "TSIndexSignature": {
      let l = n.parameters.length > 1 ? Ee(Xn(e) ? "," : "") : "", u = Z([te([H, Ie([", ", H], t.map(r, "parameters"))]), l, H]), h = t.parent.type === "ClassBody" && t.key === "body";
      return [h && n.static ? "static " : "", n.readonly ? "readonly " : "", "[", n.parameters ? u : "", "]", Bt(t, r), h ? s : ""];
    }
    case "TSTypePredicate":
      return Pv(t, r);
    case "TSNonNullExpression":
      return [r("expression"), "!"];
    case "TSImportType":
      return [n.isTypeOf ? "typeof " : "", "import(", r("argument"), ")", n.qualifier ? [".", r("qualifier")] : "", Lo(t, e, r, n.typeArguments ? "typeArguments" : "typeParameters")];
    case "TSLiteralType":
      return r("literal");
    case "TSIndexedAccessType":
      return vv(t, e, r);
    case "TSTypeOperator":
      return [n.operator, " ", r("typeAnnotation")];
    case "TSMappedType":
      return cM(t, e, r);
    case "TSMethodSignature": {
      let l = n.kind && n.kind !== "method" ? `${n.kind} ` : "";
      a.push(Oc(n), l, n.computed ? "[" : "", r("key"), n.computed ? "]" : "", zt(t));
      let u = $l(t, r, e, !1, !0), h = n.returnType ? "returnType" : "typeAnnotation", p = n[h], d = p ? Bt(t, r, h) : "", m = $h(n, d);
      return a.push(m ? Z(u) : u), p && a.push(Z(d)), Z(a);
    }
    case "TSNamespaceExportDeclaration":
      return ["export as namespace ", r("id"), e.semi ? ";" : ""];
    case "TSEnumDeclaration":
      return mw(t, r, e);
    case "TSEnumMember":
      return fw(t, r);
    case "TSImportEqualsDeclaration":
      return [n.isExport ? "export " : "", "import ", ow(n, !1), r("id"), " = ", r("moduleReference"), e.semi ? ";" : ""];
    case "TSExternalModuleReference":
      return ["require(", r("expression"), ")"];
    case "TSModuleDeclaration": {
      let { parent: l } = t, u = l.type === "TSModuleDeclaration", h = ((i = n.body) == null ? void 0 : i.type) === "TSModuleDeclaration";
      if (u)
        a.push(".");
      else if (a.push(Zr(t)), !(n.kind === "global" || n.global)) {
        let p = n.kind ?? (ar(n.id) || wg(e, st(n), st(n.id)).trim().endsWith("module") ? "module" : "namespace");
        a.push(p, " ");
      }
      return a.push(r("id")), h ? a.push(r("body")) : n.body ? a.push(" ", Z(r("body"))) : a.push(s), a;
    }
    case "TSConditionalType":
      return Cg(t, e, r);
    case "TSInferType":
      return wv(t, e, r);
    case "TSIntersectionType":
      return xv(t, e, r);
    case "TSUnionType":
      return Dv(t, e, r);
    case "TSFunctionType":
    case "TSCallSignatureDeclaration":
    case "TSConstructorType":
    case "TSConstructSignatureDeclaration":
      return bv(t, e, r);
    case "TSTupleType":
      return xg(t, e, r);
    case "TSTypeReference":
      return [r("typeName"), Lo(t, e, r, "typeParameters")];
    case "TSTypeAnnotation":
      return Av(t, e, r);
    case "TSEmptyBodyFunctionExpression":
      return Dg(t, e, r);
    case "TSJSDocAllType":
      return "*";
    case "TSJSDocUnknownType":
      return "?";
    case "TSJSDocNullableType":
      return i1(t, r, "?");
    case "TSJSDocNonNullableType":
      return i1(t, r, "!");
    case "TSParenthesizedType":
    default:
      throw new qa(n, "TypeScript");
  }
}
function WM(t, e, r, i) {
  if (nv(t))
    return v6(t, e);
  for (let n of [n9, H6, RM, ZM, QM]) {
    let s = n(t, e, r, i);
    if (s !== void 0)
      return s;
  }
}
var qM = Ue(["ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "ClassPrivateProperty", "MethodDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod"]);
function XM(t, e, r, i) {
  var n;
  t.isRoot && ((n = e.__onHtmlBindingRoot) == null || n.call(e, t.node, e));
  let s = WM(t, e, r, i);
  if (!s)
    return "";
  let { node: a } = t;
  if (qM(a))
    return s;
  let l = Re(a.decorators), u = l9(t, e, r), h = a.type === "ClassExpression";
  if (l && !h)
    return Id(s, (m) => Z([u, m]));
  let p = Qs(t, e), d = yM(t, e);
  return !u && !p && !d ? s : Id(s, (m) => [d ? ";" : "", p ? "(" : "", p && h && l ? [te([he, u, m]), he] : [u, m], p ? ")" : ""]);
}
var VM = XM, UM = { avoidAstMutation: !0 }, YM = [{ linguistLanguageId: 174, name: "JSON.stringify", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"], parsers: ["json-stringify"], vscodeLanguageIds: ["json"] }, { linguistLanguageId: 174, name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".all-contributorsrc", ".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "flake.lock", "mcmod.info", ".babelrc", ".jscsrc", ".jshintrc", ".jslintrc", ".swcrc"], parsers: ["json"], vscodeLanguageIds: ["json"] }, { linguistLanguageId: 423, name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".code-workspace", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [], parsers: ["jsonc"], vscodeLanguageIds: ["jsonc"] }, { linguistLanguageId: 175, name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", parsers: ["json5"], vscodeLanguageIds: ["json5"] }], yw = {};
Sh(yw, { getVisitorKeys: () => JM, massageAstNode: () => Ow, print: () => KM });
var zM = { JsonRoot: ["node"], ArrayExpression: ["elements"], ObjectExpression: ["properties"], ObjectProperty: ["key", "value"], UnaryExpression: ["argument"], NullLiteral: [], BooleanLiteral: [], StringLiteral: [], NumericLiteral: [], Identifier: [], TemplateLiteral: ["quasis"], TemplateElement: [] }, GM = zM, HM = db(GM), JM = HM;
function KM(t, e, r) {
  let { node: i } = t;
  switch (i.type) {
    case "JsonRoot":
      return [r("node"), ee];
    case "ArrayExpression": {
      if (i.elements.length === 0)
        return "[]";
      let n = t.map(() => t.node === null ? "null" : r(), "elements");
      return ["[", te([ee, Ie([",", ee], n)]), ee, "]"];
    }
    case "ObjectExpression":
      return i.properties.length === 0 ? "{}" : ["{", te([ee, Ie([",", ee], t.map(r, "properties"))]), ee, "}"];
    case "ObjectProperty":
      return [r("key"), ": ", r("value")];
    case "UnaryExpression":
      return [i.operator === "+" ? "" : i.operator, r("argument")];
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return i.value ? "true" : "false";
    case "StringLiteral":
      return JSON.stringify(i.value);
    case "NumericLiteral":
      return o1(t) ? JSON.stringify(String(i.value)) : JSON.stringify(i.value);
    case "Identifier":
      return o1(t) ? JSON.stringify(i.name) : i.name;
    case "TemplateLiteral":
      return r(["quasis", 0]);
    case "TemplateElement":
      return JSON.stringify(i.value.cooked);
    default:
      throw new qa(i, "JSON");
  }
}
function o1(t) {
  return t.key === "key" && t.parent.type === "ObjectProperty";
}
var eL = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
function Ow(t, e) {
  let { type: r } = t;
  if (r === "ObjectProperty") {
    let { key: i } = t;
    i.type === "Identifier" ? e.key = { type: "StringLiteral", value: i.name } : i.type === "NumericLiteral" && (e.key = { type: "StringLiteral", value: String(i.value) });
    return;
  }
  if (r === "UnaryExpression" && t.operator === "+")
    return e.argument;
  if (r === "ArrayExpression") {
    for (let [i, n] of t.elements.entries())
      n === null && e.elements.splice(i, 0, { type: "NullLiteral" });
    return;
  }
  if (r === "TemplateLiteral")
    return { type: "StringLiteral", value: t.quasis[0].value.cooked };
}
Ow.ignoredProperties = eL;
var mu = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, Jn = "JavaScript", tL = { arrowParens: { category: Jn, type: "choice", default: "always", description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: mu.bracketSameLine, bracketSpacing: mu.bracketSpacing, jsxBracketSameLine: { category: Jn, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { category: Jn, type: "boolean", default: !0, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, experimentalTernaries: { category: Jn, type: "boolean", default: !1, description: "Use curious ternaries, with the question mark after the condition.", oppositeDescription: "Default behavior of ternaries; keep question marks on the same line as the consequent." }, singleQuote: mu.singleQuote, jsxSingleQuote: { category: Jn, type: "boolean", default: !1, description: "Use single quotes in JSX." }, quoteProps: { category: Jn, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { category: Jn, type: "choice", default: "all", description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "all", description: "Trailing commas wherever possible (including function arguments)." }, { value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }] }, singleAttributePerLine: mu.singleAttributePerLine }, rL = tL, iL = { estree: hb, "estree-json": yw }, nL = [...v7, ...YM], sL = cb, aL = Object.create, Eg = Object.defineProperty, oL = Object.getOwnPropertyDescriptor, lL = Object.getOwnPropertyNames, uL = Object.getPrototypeOf, cL = Object.prototype.hasOwnProperty, xw = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), hL = (t, e) => {
  for (var r in e)
    Eg(t, r, { get: e[r], enumerable: !0 });
}, pL = (t, e, r, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of lL(e))
      !cL.call(t, n) && n !== r && Eg(t, n, { get: () => e[n], enumerable: !(i = oL(e, n)) || i.enumerable });
  return t;
}, Ag = (t, e, r) => (r = t != null ? aL(uL(t)) : {}, pL(e || !t || !t.__esModule ? Eg(r, "default", { value: t, enumerable: !0 }) : r, t)), Dw = xw((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(c, o) {
    if (c == null)
      return {};
    var f = {}, g = Object.keys(c), b, E;
    for (E = 0; E < g.length; E++)
      b = g[E], !(o.indexOf(b) >= 0) && (f[b] = c[b]);
    return f;
  }
  var r = class {
    constructor(c, o, f) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = c, this.column = o, this.index = f;
    }
  }, i = class {
    constructor(c, o) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = c, this.end = o;
    }
  };
  function n(c, o) {
    let { line: f, column: g, index: b } = c;
    return new r(f, g + o, b + o);
  }
  var s = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", a = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: s }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: s } }, l = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, u = ({ type: c, prefix: o }) => c === "UpdateExpression" ? l.UpdateExpression[String(o)] : l[c], h = { AccessorIsGenerator: ({ kind: c }) => `A ${c}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: c }) => `Missing initializer in ${c} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: c }) => `\`${c}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", DynamicImportPhaseRequiresImportExpressions: ({ phase: c }) => `'import.${c}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: c, exportName: o }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${c}' as '${o}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: c }) => `'${c === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: c }) => `Unsyntactic ${c === "BreakStatement" ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: ({ importName: c }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${c}" as foo }\`?`, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: ({ maxArgumentCount: c }) => `\`import()\` requires exactly ${c === 1 ? "one argument" : "one or two arguments"}.`, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: c }) => `Expected number in radix ${c}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: c }) => `Escape sequence in keyword ${c}.`, InvalidIdentifier: ({ identifierName: c }) => `Invalid identifier ${c}.`, InvalidLhs: ({ ancestor: c }) => `Invalid left-hand side in ${u(c)}.`, InvalidLhsBinding: ({ ancestor: c }) => `Binding invalid left-hand side in ${u(c)}.`, InvalidLhsOptionalChaining: ({ ancestor: c }) => `Invalid optional chaining in the left-hand side of ${u(c)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: c }) => `Unexpected character '${c}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: c }) => `Private name #${c} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: c }) => `Label '${c}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: c }) => `This experimental syntax requires enabling the parser plugin: ${c.map((o) => JSON.stringify(o)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: c }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${c.map((o) => JSON.stringify(o)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: c }) => `Duplicate key "${c}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: c }) => `An export name cannot include a lone surrogate, found '\\u${c.toString(16)}'.`, ModuleExportUndefined: ({ localName: c }) => `Export '${c}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: c }) => `Private names are only allowed in property accesses (\`obj.#${c}\`) or in \`in\` expressions (\`#${c} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: c }) => `Duplicate private name #${c}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: c }) => `Unexpected keyword '${c}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: c }) => `Unexpected reserved word '${c}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: c, unexpected: o }) => `Unexpected token${o ? ` '${o}'.` : ""}${c ? `, expected "${c}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: c, onlyValidPropertyName: o }) => `The only valid meta property for ${c} is ${c}.${o}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: c }) => `Identifier '${c}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, p = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: c }) => `Assigning to '${c}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: c }) => `Binding '${c}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, d = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), m = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: c }) => `Invalid topic token ${c}. In order to use ${c} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${c}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: c }) => `Hack-style pipe body cannot be an unparenthesized ${u({ type: c })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }, y = ["toMessage"], O = ["message"];
  function D(c, o, f) {
    Object.defineProperty(c, o, { enumerable: !1, configurable: !0, value: f });
  }
  function v(c) {
    let { toMessage: o } = c, f = e(c, y);
    return function g(b, E) {
      let T = new SyntaxError();
      return Object.assign(T, f, { loc: b, pos: b.index }), "missingPlugin" in E && Object.assign(T, { missingPlugin: E.missingPlugin }), D(T, "clone", function(F = {}) {
        var N;
        let { line: $, column: U, index: ie } = (N = F.loc) != null ? N : b;
        return g(new r($, U, ie), Object.assign({}, E, F.details));
      }), D(T, "details", E), Object.defineProperty(T, "message", { configurable: !0, get() {
        let F = `${o(E)} (${b.line}:${b.column})`;
        return this.message = F, F;
      }, set(F) {
        Object.defineProperty(this, "message", { value: F, writable: !0 });
      } }), T;
    };
  }
  function w(c, o) {
    if (Array.isArray(c))
      return (g) => w(g, c[0]);
    let f = {};
    for (let g of Object.keys(c)) {
      let b = c[g], E = typeof b == "string" ? { message: () => b } : typeof b == "function" ? { message: b } : b, { message: T } = E, F = e(E, O), N = typeof T == "string" ? () => T : T;
      f[g] = v(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: g, toMessage: N }, o ? { syntaxPlugin: o } : {}, F));
    }
    return f;
  }
  var x = Object.assign({}, w(a), w(h), w(p), w`pipelineOperator`(m)), { defineProperty: S } = Object, k = (c, o) => S(c, o, { enumerable: !1, value: c[o] });
  function C(c) {
    return c.loc.start && k(c.loc.start, "index"), c.loc.end && k(c.loc.end, "index"), c;
  }
  var A = (c) => class extends c {
    parse() {
      let o = C(super.parse());
      return this.options.tokens && (o.tokens = o.tokens.map(C)), o;
    }
    parseRegExpLiteral({ pattern: o, flags: f }) {
      let g = null;
      try {
        g = new RegExp(o, f);
      } catch {
      }
      let b = this.estreeParseLiteral(g);
      return b.regex = { pattern: o, flags: f }, b;
    }
    parseBigIntLiteral(o) {
      let f;
      try {
        f = BigInt(o);
      } catch {
        f = null;
      }
      let g = this.estreeParseLiteral(f);
      return g.bigint = String(g.value || o), g;
    }
    parseDecimalLiteral(o) {
      let f = this.estreeParseLiteral(null);
      return f.decimal = String(f.value || o), f;
    }
    estreeParseLiteral(o) {
      return this.parseLiteral(o, "Literal");
    }
    parseStringLiteral(o) {
      return this.estreeParseLiteral(o);
    }
    parseNumericLiteral(o) {
      return this.estreeParseLiteral(o);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(o) {
      return this.estreeParseLiteral(o);
    }
    directiveToStmt(o) {
      let f = o.value;
      delete o.value, f.type = "Literal", f.raw = f.extra.raw, f.value = f.extra.expressionValue;
      let g = o;
      return g.type = "ExpressionStatement", g.expression = f, g.directive = f.extra.rawValue, delete f.extra, g;
    }
    initFunction(o, f) {
      super.initFunction(o, f), o.expression = !1;
    }
    checkDeclaration(o) {
      o != null && this.isObjectProperty(o) ? this.checkDeclaration(o.value) : super.checkDeclaration(o);
    }
    getObjectOrClassMethodParams(o) {
      return o.value.params;
    }
    isValidDirective(o) {
      var f;
      return o.type === "ExpressionStatement" && o.expression.type === "Literal" && typeof o.expression.value == "string" && !((f = o.expression.extra) != null && f.parenthesized);
    }
    parseBlockBody(o, f, g, b, E) {
      super.parseBlockBody(o, f, g, b, E);
      let T = o.directives.map((F) => this.directiveToStmt(F));
      o.body = T.concat(o.body), delete o.directives;
    }
    pushClassMethod(o, f, g, b, E, T) {
      this.parseMethod(f, g, b, E, T, "ClassMethod", !0), f.typeParameters && (f.value.typeParameters = f.typeParameters, delete f.typeParameters), o.body.push(f);
    }
    parsePrivateName() {
      let o = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(o) : o;
    }
    convertPrivateNameToPrivateIdentifier(o) {
      let f = super.getPrivateNameSV(o);
      return o = o, delete o.id, o.name = f, o.type = "PrivateIdentifier", o;
    }
    isPrivateName(o) {
      return this.getPluginOption("estree", "classFeatures") ? o.type === "PrivateIdentifier" : super.isPrivateName(o);
    }
    getPrivateNameSV(o) {
      return this.getPluginOption("estree", "classFeatures") ? o.name : super.getPrivateNameSV(o);
    }
    parseLiteral(o, f) {
      let g = super.parseLiteral(o, f);
      return g.raw = g.extra.raw, delete g.extra, g;
    }
    parseFunctionBody(o, f, g = !1) {
      super.parseFunctionBody(o, f, g), o.expression = o.body.type !== "BlockStatement";
    }
    parseMethod(o, f, g, b, E, T, F = !1) {
      let N = this.startNode();
      return N.kind = o.kind, N = super.parseMethod(N, f, g, b, E, T, F), N.type = "FunctionExpression", delete N.kind, o.value = N, T === "ClassPrivateMethod" && (o.computed = !1), this.finishNode(o, "MethodDefinition");
    }
    parseClassProperty(...o) {
      let f = super.parseClassProperty(...o);
      return this.getPluginOption("estree", "classFeatures") && (f.type = "PropertyDefinition"), f;
    }
    parseClassPrivateProperty(...o) {
      let f = super.parseClassPrivateProperty(...o);
      return this.getPluginOption("estree", "classFeatures") && (f.type = "PropertyDefinition", f.computed = !1), f;
    }
    parseObjectMethod(o, f, g, b, E) {
      let T = super.parseObjectMethod(o, f, g, b, E);
      return T && (T.type = "Property", T.kind === "method" && (T.kind = "init"), T.shorthand = !1), T;
    }
    parseObjectProperty(o, f, g, b) {
      let E = super.parseObjectProperty(o, f, g, b);
      return E && (E.kind = "init", E.type = "Property"), E;
    }
    isValidLVal(o, f, g) {
      return o === "Property" ? "value" : super.isValidLVal(o, f, g);
    }
    isAssignable(o, f) {
      return o != null && this.isObjectProperty(o) ? this.isAssignable(o.value, f) : super.isAssignable(o, f);
    }
    toAssignable(o, f = !1) {
      if (o != null && this.isObjectProperty(o)) {
        let { key: g, value: b } = o;
        this.isPrivateName(g) && this.classScope.usePrivateName(this.getPrivateNameSV(g), g.loc.start), this.toAssignable(b, f);
      } else
        super.toAssignable(o, f);
    }
    toAssignableObjectExpressionProp(o, f, g) {
      o.kind === "get" || o.kind === "set" ? this.raise(x.PatternHasAccessor, o.key) : o.method ? this.raise(x.PatternHasMethod, o.key) : super.toAssignableObjectExpressionProp(o, f, g);
    }
    finishCallExpression(o, f) {
      let g = super.finishCallExpression(o, f);
      if (g.callee.type === "Import") {
        if (g.type = "ImportExpression", g.source = g.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var b, E;
          g.options = (b = g.arguments[1]) != null ? b : null, g.attributes = (E = g.arguments[1]) != null ? E : null;
        }
        delete g.arguments, delete g.callee;
      }
      return g;
    }
    toReferencedArguments(o) {
      o.type !== "ImportExpression" && super.toReferencedArguments(o);
    }
    parseExport(o, f) {
      let g = this.state.lastTokStartLoc, b = super.parseExport(o, f);
      switch (b.type) {
        case "ExportAllDeclaration":
          b.exported = null;
          break;
        case "ExportNamedDeclaration":
          b.specifiers.length === 1 && b.specifiers[0].type === "ExportNamespaceSpecifier" && (b.type = "ExportAllDeclaration", b.exported = b.specifiers[0].exported, delete b.specifiers);
        case "ExportDefaultDeclaration":
          {
            var E;
            let { declaration: T } = b;
            (T == null ? void 0 : T.type) === "ClassDeclaration" && ((E = T.decorators) == null ? void 0 : E.length) > 0 && T.start === b.start && this.resetStartLocation(b, g);
          }
          break;
      }
      return b;
    }
    parseSubscript(o, f, g, b) {
      let E = super.parseSubscript(o, f, g, b);
      if (b.optionalChainMember) {
        if ((E.type === "OptionalMemberExpression" || E.type === "OptionalCallExpression") && (E.type = E.type.substring(8)), b.stop) {
          let T = this.startNodeAtNode(E);
          return T.expression = E, this.finishNode(T, "ChainExpression");
        }
      } else
        (E.type === "MemberExpression" || E.type === "CallExpression") && (E.optional = !1);
      return E;
    }
    isOptionalMemberExpression(o) {
      return o.type === "ChainExpression" ? o.expression.type === "MemberExpression" : super.isOptionalMemberExpression(o);
    }
    hasPropertyAsPrivateName(o) {
      return o.type === "ChainExpression" && (o = o.expression), super.hasPropertyAsPrivateName(o);
    }
    isObjectProperty(o) {
      return o.type === "Property" && o.kind === "init" && !o.method;
    }
    isObjectMethod(o) {
      return o.method || o.kind === "get" || o.kind === "set";
    }
    finishNodeAt(o, f, g) {
      return C(super.finishNodeAt(o, f, g));
    }
    resetStartLocation(o, f) {
      super.resetStartLocation(o, f), C(o);
    }
    resetEndLocation(o, f = this.state.lastTokEndLoc) {
      super.resetEndLocation(o, f), C(o);
    }
  }, P = class {
    constructor(c, o) {
      this.token = void 0, this.preserveSpace = void 0, this.token = c, this.preserveSpace = !!o;
    }
  }, I = { brace: new P("{"), j_oTag: new P("<tag"), j_cTag: new P("</tag"), j_expr: new P("<tag>...</tag>", !0) };
  I.template = new P("`", !0);
  var B = !0, _ = !0, R = !0, G = !0, J = !0, Q = !0, q = class {
    constructor(c, o = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = c, this.keyword = o.keyword, this.beforeExpr = !!o.beforeExpr, this.startsExpr = !!o.startsExpr, this.rightAssociative = !!o.rightAssociative, this.isLoop = !!o.isLoop, this.isAssign = !!o.isAssign, this.prefix = !!o.prefix, this.postfix = !!o.postfix, this.binop = o.binop != null ? o.binop : null, this.updateContext = null;
    }
  }, X = /* @__PURE__ */ new Map();
  function K(c, o = {}) {
    o.keyword = c;
    let f = ue(c, o);
    return X.set(c, f), f;
  }
  function ye(c, o) {
    return ue(c, { beforeExpr: B, binop: o });
  }
  var Ce = -1, be = [], Le = [], Ye = [], Je = [], Te = [], ht = [];
  function ue(c, o = {}) {
    var f, g, b, E;
    return ++Ce, Le.push(c), Ye.push((f = o.binop) != null ? f : -1), Je.push((g = o.beforeExpr) != null ? g : !1), Te.push((b = o.startsExpr) != null ? b : !1), ht.push((E = o.prefix) != null ? E : !1), be.push(new q(c, o)), Ce;
  }
  function V(c, o = {}) {
    var f, g, b, E;
    return ++Ce, X.set(c, Ce), Le.push(c), Ye.push((f = o.binop) != null ? f : -1), Je.push((g = o.beforeExpr) != null ? g : !1), Te.push((b = o.startsExpr) != null ? b : !1), ht.push((E = o.prefix) != null ? E : !1), be.push(new q("name", o)), Ce;
  }
  var W = { bracketL: ue("[", { beforeExpr: B, startsExpr: _ }), bracketHashL: ue("#[", { beforeExpr: B, startsExpr: _ }), bracketBarL: ue("[|", { beforeExpr: B, startsExpr: _ }), bracketR: ue("]"), bracketBarR: ue("|]"), braceL: ue("{", { beforeExpr: B, startsExpr: _ }), braceBarL: ue("{|", { beforeExpr: B, startsExpr: _ }), braceHashL: ue("#{", { beforeExpr: B, startsExpr: _ }), braceR: ue("}"), braceBarR: ue("|}"), parenL: ue("(", { beforeExpr: B, startsExpr: _ }), parenR: ue(")"), comma: ue(",", { beforeExpr: B }), semi: ue(";", { beforeExpr: B }), colon: ue(":", { beforeExpr: B }), doubleColon: ue("::", { beforeExpr: B }), dot: ue("."), question: ue("?", { beforeExpr: B }), questionDot: ue("?."), arrow: ue("=>", { beforeExpr: B }), template: ue("template"), ellipsis: ue("...", { beforeExpr: B }), backQuote: ue("`", { startsExpr: _ }), dollarBraceL: ue("${", { beforeExpr: B, startsExpr: _ }), templateTail: ue("...`", { startsExpr: _ }), templateNonTail: ue("...${", { beforeExpr: B, startsExpr: _ }), at: ue("@"), hash: ue("#", { startsExpr: _ }), interpreterDirective: ue("#!..."), eq: ue("=", { beforeExpr: B, isAssign: G }), assign: ue("_=", { beforeExpr: B, isAssign: G }), slashAssign: ue("_=", { beforeExpr: B, isAssign: G }), xorAssign: ue("_=", { beforeExpr: B, isAssign: G }), moduloAssign: ue("_=", { beforeExpr: B, isAssign: G }), incDec: ue("++/--", { prefix: J, postfix: Q, startsExpr: _ }), bang: ue("!", { beforeExpr: B, prefix: J, startsExpr: _ }), tilde: ue("~", { beforeExpr: B, prefix: J, startsExpr: _ }), doubleCaret: ue("^^", { startsExpr: _ }), doubleAt: ue("@@", { startsExpr: _ }), pipeline: ye("|>", 0), nullishCoalescing: ye("??", 1), logicalOR: ye("||", 1), logicalAND: ye("&&", 2), bitwiseOR: ye("|", 3), bitwiseXOR: ye("^", 4), bitwiseAND: ye("&", 5), equality: ye("==/!=/===/!==", 6), lt: ye("</>/<=/>=", 7), gt: ye("</>/<=/>=", 7), relational: ye("</>/<=/>=", 7), bitShift: ye("<</>>/>>>", 8), bitShiftL: ye("<</>>/>>>", 8), bitShiftR: ye("<</>>/>>>", 8), plusMin: ue("+/-", { beforeExpr: B, binop: 9, prefix: J, startsExpr: _ }), modulo: ue("%", { binop: 10, startsExpr: _ }), star: ue("*", { binop: 10 }), slash: ye("/", 10), exponent: ue("**", { beforeExpr: B, binop: 11, rightAssociative: !0 }), _in: K("in", { beforeExpr: B, binop: 7 }), _instanceof: K("instanceof", { beforeExpr: B, binop: 7 }), _break: K("break"), _case: K("case", { beforeExpr: B }), _catch: K("catch"), _continue: K("continue"), _debugger: K("debugger"), _default: K("default", { beforeExpr: B }), _else: K("else", { beforeExpr: B }), _finally: K("finally"), _function: K("function", { startsExpr: _ }), _if: K("if"), _return: K("return", { beforeExpr: B }), _switch: K("switch"), _throw: K("throw", { beforeExpr: B, prefix: J, startsExpr: _ }), _try: K("try"), _var: K("var"), _const: K("const"), _with: K("with"), _new: K("new", { beforeExpr: B, startsExpr: _ }), _this: K("this", { startsExpr: _ }), _super: K("super", { startsExpr: _ }), _class: K("class", { startsExpr: _ }), _extends: K("extends", { beforeExpr: B }), _export: K("export"), _import: K("import", { startsExpr: _ }), _null: K("null", { startsExpr: _ }), _true: K("true", { startsExpr: _ }), _false: K("false", { startsExpr: _ }), _typeof: K("typeof", { beforeExpr: B, prefix: J, startsExpr: _ }), _void: K("void", { beforeExpr: B, prefix: J, startsExpr: _ }), _delete: K("delete", { beforeExpr: B, prefix: J, startsExpr: _ }), _do: K("do", { isLoop: R, beforeExpr: B }), _for: K("for", { isLoop: R }), _while: K("while", { isLoop: R }), _as: V("as", { startsExpr: _ }), _assert: V("assert", { startsExpr: _ }), _async: V("async", { startsExpr: _ }), _await: V("await", { startsExpr: _ }), _defer: V("defer", { startsExpr: _ }), _from: V("from", { startsExpr: _ }), _get: V("get", { startsExpr: _ }), _let: V("let", { startsExpr: _ }), _meta: V("meta", { startsExpr: _ }), _of: V("of", { startsExpr: _ }), _sent: V("sent", { startsExpr: _ }), _set: V("set", { startsExpr: _ }), _source: V("source", { startsExpr: _ }), _static: V("static", { startsExpr: _ }), _using: V("using", { startsExpr: _ }), _yield: V("yield", { startsExpr: _ }), _asserts: V("asserts", { startsExpr: _ }), _checks: V("checks", { startsExpr: _ }), _exports: V("exports", { startsExpr: _ }), _global: V("global", { startsExpr: _ }), _implements: V("implements", { startsExpr: _ }), _intrinsic: V("intrinsic", { startsExpr: _ }), _infer: V("infer", { startsExpr: _ }), _is: V("is", { startsExpr: _ }), _mixins: V("mixins", { startsExpr: _ }), _proto: V("proto", { startsExpr: _ }), _require: V("require", { startsExpr: _ }), _satisfies: V("satisfies", { startsExpr: _ }), _keyof: V("keyof", { startsExpr: _ }), _readonly: V("readonly", { startsExpr: _ }), _unique: V("unique", { startsExpr: _ }), _abstract: V("abstract", { startsExpr: _ }), _declare: V("declare", { startsExpr: _ }), _enum: V("enum", { startsExpr: _ }), _module: V("module", { startsExpr: _ }), _namespace: V("namespace", { startsExpr: _ }), _interface: V("interface", { startsExpr: _ }), _type: V("type", { startsExpr: _ }), _opaque: V("opaque", { startsExpr: _ }), name: ue("name", { startsExpr: _ }), string: ue("string", { startsExpr: _ }), num: ue("num", { startsExpr: _ }), bigint: ue("bigint", { startsExpr: _ }), decimal: ue("decimal", { startsExpr: _ }), regexp: ue("regexp", { startsExpr: _ }), privateName: ue("#name", { startsExpr: _ }), eof: ue("eof"), jsxName: ue("jsxName"), jsxText: ue("jsxText", { beforeExpr: !0 }), jsxTagStart: ue("jsxTagStart", { startsExpr: !0 }), jsxTagEnd: ue("jsxTagEnd"), placeholder: ue("%%", { startsExpr: !0 }) };
  function j(c) {
    return c >= 93 && c <= 132;
  }
  function ve(c) {
    return c <= 92;
  }
  function De(c) {
    return c >= 58 && c <= 132;
  }
  function Ae(c) {
    return c >= 58 && c <= 136;
  }
  function Jt(c) {
    return Je[c];
  }
  function Mt(c) {
    return Te[c];
  }
  function wt(c) {
    return c >= 29 && c <= 33;
  }
  function Xr(c) {
    return c >= 129 && c <= 131;
  }
  function ln(c) {
    return c >= 90 && c <= 92;
  }
  function ur(c) {
    return c >= 58 && c <= 92;
  }
  function kr(c) {
    return c >= 39 && c <= 59;
  }
  function li(c) {
    return c === 34;
  }
  function un(c) {
    return ht[c];
  }
  function Qi(c) {
    return c >= 121 && c <= 123;
  }
  function ji(c) {
    return c >= 124 && c <= 130;
  }
  function ui(c) {
    return Le[c];
  }
  function Rs(c) {
    return Ye[c];
  }
  function ql(c) {
    return c === 57;
  }
  function Zs(c) {
    return c >= 24 && c <= 25;
  }
  function Vr(c) {
    return be[c];
  }
  be[8].updateContext = (c) => {
    c.pop();
  }, be[5].updateContext = be[7].updateContext = be[23].updateContext = (c) => {
    c.push(I.brace);
  }, be[22].updateContext = (c) => {
    c[c.length - 1] === I.template ? c.pop() : c.push(I.template);
  }, be[142].updateContext = (c) => {
    c.push(I.j_expr, I.j_oTag);
  };
  var Ga = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", Xl = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", L = new RegExp("[" + Ga + "]"), ne = new RegExp("[" + Ga + Xl + "]");
  Ga = Xl = null;
  var pe = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], Fe = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Ve(c, o) {
    let f = 65536;
    for (let g = 0, b = o.length; g < b; g += 2) {
      if (f += o[g], f > c)
        return !1;
      if (f += o[g + 1], f >= c)
        return !0;
    }
    return !1;
  }
  function Ne(c) {
    return c < 65 ? c === 36 : c <= 90 ? !0 : c < 97 ? c === 95 : c <= 122 ? !0 : c <= 65535 ? c >= 170 && L.test(String.fromCharCode(c)) : Ve(c, pe);
  }
  function $e(c) {
    return c < 48 ? c === 36 : c < 58 ? !0 : c < 65 ? !1 : c <= 90 ? !0 : c < 97 ? c === 95 : c <= 122 ? !0 : c <= 65535 ? c >= 170 && ne.test(String.fromCharCode(c)) : Ve(c, pe) || Ve(c, Fe);
  }
  var ke = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, Lt = new Set(ke.keyword), Tr = new Set(ke.strict), ci = new Set(ke.strictBind);
  function Ri(c, o) {
    return o && c === "await" || c === "enum";
  }
  function Ws(c, o) {
    return Ri(c, o) || Tr.has(c);
  }
  function ly(c) {
    return ci.has(c);
  }
  function uy(c, o) {
    return Ws(c, o) || ly(c);
  }
  function YE(c) {
    return Lt.has(c);
  }
  function zE(c, o, f) {
    return c === 64 && o === 64 && Ne(f);
  }
  var GE = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function HE(c) {
    return GE.has(c);
  }
  var zh = class {
    constructor(c) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = c;
    }
  }, Gh = class {
    constructor(c, o) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = c, this.inModule = o;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let c = this.currentThisScopeFlags();
      return (c & 64) > 0 && (c & 2) === 0;
    }
    get inStaticBlock() {
      for (let c = this.scopeStack.length - 1; ; c--) {
        let { flags: o } = this.scopeStack[c];
        if (o & 128)
          return !0;
        if (o & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(c) {
      return new zh(c);
    }
    enter(c) {
      this.scopeStack.push(this.createScope(c));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(c) {
      return !!(c.flags & 130 || !this.parser.inModule && c.flags & 1);
    }
    declareName(c, o, f) {
      let g = this.currentScope();
      if (o & 8 || o & 16) {
        this.checkRedeclarationInScope(g, c, o, f);
        let b = g.names.get(c) || 0;
        o & 16 ? b = b | 4 : (g.firstLexicalName || (g.firstLexicalName = c), b = b | 2), g.names.set(c, b), o & 8 && this.maybeExportDefined(g, c);
      } else if (o & 4)
        for (let b = this.scopeStack.length - 1; b >= 0 && (g = this.scopeStack[b], this.checkRedeclarationInScope(g, c, o, f), g.names.set(c, (g.names.get(c) || 0) | 1), this.maybeExportDefined(g, c), !(g.flags & 387)); --b)
          ;
      this.parser.inModule && g.flags & 1 && this.undefinedExports.delete(c);
    }
    maybeExportDefined(c, o) {
      this.parser.inModule && c.flags & 1 && this.undefinedExports.delete(o);
    }
    checkRedeclarationInScope(c, o, f, g) {
      this.isRedeclaredInScope(c, o, f) && this.parser.raise(x.VarRedeclaration, g, { identifierName: o });
    }
    isRedeclaredInScope(c, o, f) {
      if (!(f & 1))
        return !1;
      if (f & 8)
        return c.names.has(o);
      let g = c.names.get(o);
      return f & 16 ? (g & 2) > 0 || !this.treatFunctionsAsVarInScope(c) && (g & 1) > 0 : (g & 2) > 0 && !(c.flags & 8 && c.firstLexicalName === o) || !this.treatFunctionsAsVarInScope(c) && (g & 4) > 0;
    }
    checkLocalExport(c) {
      let { name: o } = c;
      this.scopeStack[0].names.has(o) || this.undefinedExports.set(o, c.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let c = this.scopeStack.length - 1; ; c--) {
        let { flags: o } = this.scopeStack[c];
        if (o & 387)
          return o;
      }
    }
    currentThisScopeFlags() {
      for (let c = this.scopeStack.length - 1; ; c--) {
        let { flags: o } = this.scopeStack[c];
        if (o & 451 && !(o & 4))
          return o;
      }
    }
  }, JE = class extends zh {
    constructor(...c) {
      super(...c), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, KE = class extends Gh {
    createScope(c) {
      return new JE(c);
    }
    declareName(c, o, f) {
      let g = this.currentScope();
      if (o & 2048) {
        this.checkRedeclarationInScope(g, c, o, f), this.maybeExportDefined(g, c), g.declareFunctions.add(c);
        return;
      }
      super.declareName(c, o, f);
    }
    isRedeclaredInScope(c, o, f) {
      if (super.isRedeclaredInScope(c, o, f))
        return !0;
      if (f & 2048 && !c.declareFunctions.has(o)) {
        let g = c.names.get(o);
        return (g & 4) > 0 || (g & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(c) {
      this.scopeStack[0].declareFunctions.has(c.name) || super.checkLocalExport(c);
    }
  }, eA = class {
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(c) {
      if (typeof c == "string")
        return this.plugins.has(c);
      {
        let [o, f] = c;
        if (!this.hasPlugin(o))
          return !1;
        let g = this.plugins.get(o);
        for (let b of Object.keys(f))
          if ((g == null ? void 0 : g[b]) !== f[b])
            return !1;
        return !0;
      }
    }
    getPluginOption(c, o) {
      var f;
      return (f = this.plugins.get(c)) == null ? void 0 : f[o];
    }
  };
  function cy(c, o) {
    c.trailingComments === void 0 ? c.trailingComments = o : c.trailingComments.unshift(...o);
  }
  function tA(c, o) {
    c.leadingComments === void 0 ? c.leadingComments = o : c.leadingComments.unshift(...o);
  }
  function Ha(c, o) {
    c.innerComments === void 0 ? c.innerComments = o : c.innerComments.unshift(...o);
  }
  function Ja(c, o, f) {
    let g = null, b = o.length;
    for (; g === null && b > 0; )
      g = o[--b];
    g === null || g.start > f.start ? Ha(c, f.comments) : cy(g, f.comments);
  }
  var rA = class extends eA {
    addComment(c) {
      this.filename && (c.loc.filename = this.filename);
      let { commentsLen: o } = this.state;
      this.comments.length != o && (this.comments.length = o), this.comments.push(c), this.state.commentsLen++;
    }
    processComment(c) {
      let { commentStack: o } = this.state, f = o.length;
      if (f === 0)
        return;
      let g = f - 1, b = o[g];
      b.start === c.end && (b.leadingNode = c, g--);
      let { start: E } = c;
      for (; g >= 0; g--) {
        let T = o[g], F = T.end;
        if (F > E)
          T.containingNode = c, this.finalizeComment(T), o.splice(g, 1);
        else {
          F === E && (T.trailingNode = c);
          break;
        }
      }
    }
    finalizeComment(c) {
      let { comments: o } = c;
      if (c.leadingNode !== null || c.trailingNode !== null)
        c.leadingNode !== null && cy(c.leadingNode, o), c.trailingNode !== null && tA(c.trailingNode, o);
      else {
        let { containingNode: f, start: g } = c;
        if (this.input.charCodeAt(g - 1) === 44)
          switch (f.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Ja(f, f.properties, c);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Ja(f, f.arguments, c);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Ja(f, f.params, c);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Ja(f, f.elements, c);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Ja(f, f.specifiers, c);
              break;
            default:
              Ha(f, o);
          }
        else
          Ha(f, o);
      }
    }
    finalizeRemainingComments() {
      let { commentStack: c } = this.state;
      for (let o = c.length - 1; o >= 0; o--)
        this.finalizeComment(c[o]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(c) {
      let { commentStack: o } = this.state, { length: f } = o;
      if (f === 0)
        return;
      let g = o[f - 1];
      g.leadingNode === c && (g.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(c) {
      let { commentStack: o } = this.state, { length: f } = o;
      f !== 0 && (o[f - 1].trailingNode === c ? o[f - 1].trailingNode = null : f >= 2 && o[f - 2].trailingNode === c && (o[f - 2].trailingNode = null));
    }
    takeSurroundingComments(c, o, f) {
      let { commentStack: g } = this.state, b = g.length;
      if (b === 0)
        return;
      let E = b - 1;
      for (; E >= 0; E--) {
        let T = g[E], F = T.end;
        if (T.start === f)
          T.leadingNode = c;
        else if (F === o)
          T.trailingNode = c;
        else if (F < o)
          break;
      }
    }
  }, hy = /\r\n?|[\n\u2028\u2029]/, Vl = new RegExp(hy.source, "g");
  function Ka(c) {
    switch (c) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  var Hh = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Ul = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, py = new RegExp("(?=(" + Ul.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function iA(c) {
    switch (c) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  var nA = class bw {
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [I.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(o) {
      o ? this.flags |= 1 : this.flags &= -2;
    }
    init({ strictMode: o, sourceType: f, startLine: g, startColumn: b }) {
      this.strict = o === !1 ? !1 : o === !0 ? !0 : f === "module", this.curLine = g, this.lineStart = -b, this.startLoc = this.endLoc = new r(g, b, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(o) {
      o ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(o) {
      o ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(o) {
      o ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(o) {
      o ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(o) {
      o ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(o) {
      o ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(o) {
      o ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(o) {
      o ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(o) {
      o ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(o) {
      o ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(o) {
      o ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new r(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      let o = new bw();
      return o.flags = this.flags, o.curLine = this.curLine, o.lineStart = this.lineStart, o.startLoc = this.startLoc, o.endLoc = this.endLoc, o.errors = this.errors.slice(), o.potentialArrowAt = this.potentialArrowAt, o.noArrowAt = this.noArrowAt.slice(), o.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), o.topicContext = this.topicContext, o.labels = this.labels.slice(), o.commentsLen = this.commentsLen, o.commentStack = this.commentStack.slice(), o.pos = this.pos, o.type = this.type, o.value = this.value, o.start = this.start, o.end = this.end, o.lastTokEndLoc = this.lastTokEndLoc, o.lastTokStartLoc = this.lastTokStartLoc, o.context = this.context.slice(), o.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, o.strictErrors = this.strictErrors, o.tokensLength = this.tokensLength, o;
    }
  }, sA = function(c) {
    return c >= 48 && c <= 57;
  }, dy = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Yl = { bin: (c) => c === 48 || c === 49, oct: (c) => c >= 48 && c <= 55, dec: (c) => c >= 48 && c <= 57, hex: (c) => c >= 48 && c <= 57 || c >= 65 && c <= 70 || c >= 97 && c <= 102 };
  function fy(c, o, f, g, b, E) {
    let T = f, F = g, N = b, $ = "", U = null, ie = f, { length: ce } = o;
    for (; ; ) {
      if (f >= ce) {
        E.unterminated(T, F, N), $ += o.slice(ie, f);
        break;
      }
      let oe = o.charCodeAt(f);
      if (aA(c, oe, o, f)) {
        $ += o.slice(ie, f);
        break;
      }
      if (oe === 92) {
        $ += o.slice(ie, f);
        let Xe = oA(o, f, g, b, c === "template", E);
        Xe.ch === null && !U ? U = { pos: f, lineStart: g, curLine: b } : $ += Xe.ch, { pos: f, lineStart: g, curLine: b } = Xe, ie = f;
      } else
        oe === 8232 || oe === 8233 ? (++f, ++b, g = f) : oe === 10 || oe === 13 ? c === "template" ? ($ += o.slice(ie, f) + `
`, ++f, oe === 13 && o.charCodeAt(f) === 10 && ++f, ++b, ie = g = f) : E.unterminated(T, F, N) : ++f;
    }
    return { pos: f, str: $, firstInvalidLoc: U, lineStart: g, curLine: b, containsInvalid: !!U };
  }
  function aA(c, o, f, g) {
    return c === "template" ? o === 96 || o === 36 && f.charCodeAt(g + 1) === 123 : o === (c === "double" ? 34 : 39);
  }
  function oA(c, o, f, g, b, E) {
    let T = !b;
    o++;
    let F = ($) => ({ pos: o, ch: $, lineStart: f, curLine: g }), N = c.charCodeAt(o++);
    switch (N) {
      case 110:
        return F(`
`);
      case 114:
        return F("\r");
      case 120: {
        let $;
        return { code: $, pos: o } = Jh(c, o, f, g, 2, !1, T, E), F($ === null ? null : String.fromCharCode($));
      }
      case 117: {
        let $;
        return { code: $, pos: o } = gy(c, o, f, g, T, E), F($ === null ? null : String.fromCodePoint($));
      }
      case 116:
        return F("	");
      case 98:
        return F("\b");
      case 118:
        return F("\v");
      case 102:
        return F("\f");
      case 13:
        c.charCodeAt(o) === 10 && ++o;
      case 10:
        f = o, ++g;
      case 8232:
      case 8233:
        return F("");
      case 56:
      case 57:
        if (b)
          return F(null);
        E.strictNumericEscape(o - 1, f, g);
      default:
        if (N >= 48 && N <= 55) {
          let $ = o - 1, U = c.slice($, o + 2).match(/^[0-7]+/)[0], ie = parseInt(U, 8);
          ie > 255 && (U = U.slice(0, -1), ie = parseInt(U, 8)), o += U.length - 1;
          let ce = c.charCodeAt(o);
          if (U !== "0" || ce === 56 || ce === 57) {
            if (b)
              return F(null);
            E.strictNumericEscape($, f, g);
          }
          return F(String.fromCharCode(ie));
        }
        return F(String.fromCharCode(N));
    }
  }
  function Jh(c, o, f, g, b, E, T, F) {
    let N = o, $;
    return { n: $, pos: o } = my(c, o, f, g, 16, b, E, !1, F, !T), $ === null && (T ? F.invalidEscapeSequence(N, f, g) : o = N - 1), { code: $, pos: o };
  }
  function my(c, o, f, g, b, E, T, F, N, $) {
    let U = o, ie = b === 16 ? dy.hex : dy.decBinOct, ce = b === 16 ? Yl.hex : b === 10 ? Yl.dec : b === 8 ? Yl.oct : Yl.bin, oe = !1, Xe = 0;
    for (let qe = 0, mt = E ?? 1 / 0; qe < mt; ++qe) {
      let Qt = c.charCodeAt(o), cr;
      if (Qt === 95 && F !== "bail") {
        let ip = c.charCodeAt(o - 1), np = c.charCodeAt(o + 1);
        if (F) {
          if (Number.isNaN(np) || !ce(np) || ie.has(ip) || ie.has(np)) {
            if ($)
              return { n: null, pos: o };
            N.unexpectedNumericSeparator(o, f, g);
          }
        } else {
          if ($)
            return { n: null, pos: o };
          N.numericSeparatorInEscapeSequence(o, f, g);
        }
        ++o;
        continue;
      }
      if (Qt >= 97 ? cr = Qt - 97 + 10 : Qt >= 65 ? cr = Qt - 65 + 10 : sA(Qt) ? cr = Qt - 48 : cr = 1 / 0, cr >= b) {
        if (cr <= 9 && $)
          return { n: null, pos: o };
        if (cr <= 9 && N.invalidDigit(o, f, g, b))
          cr = 0;
        else if (T)
          cr = 0, oe = !0;
        else
          break;
      }
      ++o, Xe = Xe * b + cr;
    }
    return o === U || E != null && o - U !== E || oe ? { n: null, pos: o } : { n: Xe, pos: o };
  }
  function gy(c, o, f, g, b, E) {
    let T = c.charCodeAt(o), F;
    if (T === 123) {
      if (++o, { code: F, pos: o } = Jh(c, o, f, g, c.indexOf("}", o) - o, !0, b, E), ++o, F !== null && F > 1114111)
        if (b)
          E.invalidCodePoint(o, f, g);
        else
          return { code: null, pos: o };
    } else
      ({ code: F, pos: o } = Jh(c, o, f, g, 4, !1, b, E));
    return { code: F, pos: o };
  }
  function eo(c, o, f) {
    return new r(f, c - o, c);
  }
  var lA = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), cn = class {
    constructor(c) {
      this.type = c.type, this.value = c.value, this.start = c.start, this.end = c.end, this.loc = new i(c.startLoc, c.endLoc);
    }
  }, uA = class extends rA {
    constructor(c, o) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (f, g, b, E) => this.options.errorRecovery ? (this.raise(x.InvalidDigit, eo(f, g, b), { radix: E }), !0) : !1, numericSeparatorInEscapeSequence: this.errorBuilder(x.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(x.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(x.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(x.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (f, g, b) => {
        this.recordStrictModeErrors(x.StrictNumericEscape, eo(f, g, b));
      }, unterminated: (f, g, b) => {
        throw this.raise(x.UnterminatedString, eo(f - 1, g, b));
      } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(x.StrictNumericEscape), unterminated: (f, g, b) => {
        throw this.raise(x.UnterminatedTemplate, eo(f, g, b));
      } }), this.state = new nA(), this.state.init(c), this.input = o, this.length = o.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(c) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(c), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new cn(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(c) {
      return this.match(c) ? (this.next(), !0) : !1;
    }
    match(c) {
      return this.state.type === c;
    }
    createLookaheadState(c) {
      return { pos: c.pos, value: null, type: c.type, start: c.start, end: c.end, context: [this.curContext()], inType: c.inType, startLoc: c.startLoc, lastTokEndLoc: c.lastTokEndLoc, curLine: c.curLine, lineStart: c.lineStart, curPosition: c.curPosition };
    }
    lookahead() {
      let c = this.state;
      this.state = this.createLookaheadState(c), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let o = this.state;
      return this.state = c, o;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(c) {
      return Hh.lastIndex = c, Hh.test(this.input) ? Hh.lastIndex : c;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(c) {
      return Ul.lastIndex = c, Ul.test(this.input) ? Ul.lastIndex : c;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(c) {
      let o = this.input.charCodeAt(c);
      if ((o & 64512) === 55296 && ++c < this.input.length) {
        let f = this.input.charCodeAt(c);
        (f & 64512) === 56320 && (o = 65536 + ((o & 1023) << 10) + (f & 1023));
      }
      return o;
    }
    setStrict(c) {
      this.state.strict = c, c && (this.state.strictErrors.forEach(([o, f]) => this.raise(o, f)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(c) {
      let o;
      this.isLookahead || (o = this.state.curPosition());
      let f = this.state.pos, g = this.input.indexOf(c, f + 2);
      if (g === -1)
        throw this.raise(x.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = g + c.length, Vl.lastIndex = f + 2; Vl.test(this.input) && Vl.lastIndex <= g; )
        ++this.state.curLine, this.state.lineStart = Vl.lastIndex;
      if (this.isLookahead)
        return;
      let b = { type: "CommentBlock", value: this.input.slice(f + 2, g), start: f, end: g + c.length, loc: new i(o, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(b), b;
    }
    skipLineComment(c) {
      let o = this.state.pos, f;
      this.isLookahead || (f = this.state.curPosition());
      let g = this.input.charCodeAt(this.state.pos += c);
      if (this.state.pos < this.length)
        for (; !Ka(g) && ++this.state.pos < this.length; )
          g = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead)
        return;
      let b = this.state.pos, E = { type: "CommentLine", value: this.input.slice(o + c, b), start: o, end: b, loc: new i(f, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(E), E;
    }
    skipSpace() {
      let c = this.state.pos, o = [];
      e:
        for (; this.state.pos < this.length; ) {
          let f = this.input.charCodeAt(this.state.pos);
          switch (f) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  let g = this.skipBlockComment("*/");
                  g !== void 0 && (this.addComment(g), this.options.attachComment && o.push(g));
                  break;
                }
                case 47: {
                  let g = this.skipLineComment(2);
                  g !== void 0 && (this.addComment(g), this.options.attachComment && o.push(g));
                  break;
                }
                default:
                  break e;
              }
              break;
            default:
              if (iA(f))
                ++this.state.pos;
              else if (f === 45 && !this.inModule && this.options.annexB) {
                let g = this.state.pos;
                if (this.input.charCodeAt(g + 1) === 45 && this.input.charCodeAt(g + 2) === 62 && (c === 0 || this.state.lineStart > c)) {
                  let b = this.skipLineComment(3);
                  b !== void 0 && (this.addComment(b), this.options.attachComment && o.push(b));
                } else
                  break e;
              } else if (f === 60 && !this.inModule && this.options.annexB) {
                let g = this.state.pos;
                if (this.input.charCodeAt(g + 1) === 33 && this.input.charCodeAt(g + 2) === 45 && this.input.charCodeAt(g + 3) === 45) {
                  let b = this.skipLineComment(4);
                  b !== void 0 && (this.addComment(b), this.options.attachComment && o.push(b));
                } else
                  break e;
              } else
                break e;
          }
        }
      if (o.length > 0) {
        let f = this.state.pos, g = { start: c, end: f, comments: o, leadingNode: null, trailingNode: null, containingNode: null };
        this.state.commentStack.push(g);
      }
    }
    finishToken(c, o) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let f = this.state.type;
      this.state.type = c, this.state.value = o, this.isLookahead || this.updateContext(f);
    }
    replaceToken(c) {
      this.state.type = c, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let c = this.state.pos + 1, o = this.codePointAtPos(c);
      if (o >= 48 && o <= 57)
        throw this.raise(x.UnexpectedDigitAfterHash, this.state.curPosition());
      if (o === 123 || o === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(o === 123 ? x.RecordExpressionHashIncorrectStartSyntaxType : x.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        this.state.pos += 2, o === 123 ? this.finishToken(7) : this.finishToken(1);
      } else
        Ne(o) ? (++this.state.pos, this.finishToken(138, this.readWord1(o))) : o === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let c = this.input.charCodeAt(this.state.pos + 1);
      if (c >= 48 && c <= 57) {
        this.readNumber(!0);
        return;
      }
      c === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return !1;
      let c = this.input.charCodeAt(this.state.pos + 1);
      if (c !== 33)
        return !1;
      let o = this.state.pos;
      for (this.state.pos += 1; !Ka(c) && ++this.state.pos < this.length; )
        c = this.input.charCodeAt(this.state.pos);
      let f = this.input.slice(o + 2, this.state.pos);
      return this.finishToken(28, f), !0;
    }
    readToken_mult_modulo(c) {
      let o = c === 42 ? 55 : 54, f = 1, g = this.input.charCodeAt(this.state.pos + 1);
      c === 42 && g === 42 && (f++, g = this.input.charCodeAt(this.state.pos + 2), o = 57), g === 61 && !this.state.inType && (f++, o = c === 37 ? 33 : 30), this.finishOp(o, f);
    }
    readToken_pipe_amp(c) {
      let o = this.input.charCodeAt(this.state.pos + 1);
      if (o === c) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(c === 124 ? 41 : 42, 2);
        return;
      }
      if (c === 124) {
        if (o === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && o === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(x.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && o === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(x.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (o === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(c === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let c = this.input.charCodeAt(this.state.pos + 1);
      c === 61 && !this.state.inType ? this.finishOp(32, 2) : c === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(c) {
      let o = this.input.charCodeAt(this.state.pos + 1);
      if (o === c) {
        this.finishOp(34, 2);
        return;
      }
      o === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let { pos: c } = this.state, o = this.input.charCodeAt(c + 1);
      if (o === 60) {
        if (this.input.charCodeAt(c + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (o === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let { pos: c } = this.state, o = this.input.charCodeAt(c + 1);
      if (o === 62) {
        let f = this.input.charCodeAt(c + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(c + f) === 61) {
          this.finishOp(30, f + 1);
          return;
        }
        this.finishOp(52, f);
        return;
      }
      if (o === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(c) {
      let o = this.input.charCodeAt(this.state.pos + 1);
      if (o === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (c === 61 && o === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(c === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let c = this.input.charCodeAt(this.state.pos + 1), o = this.input.charCodeAt(this.state.pos + 2);
      c === 63 ? o === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : c === 46 && !(o >= 48 && o <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(c) {
      switch (c) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(x.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(x.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let o = this.input.charCodeAt(this.state.pos + 1);
          if (o === 120 || o === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (o === 111 || o === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (o === 98 || o === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(c);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(c);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(c);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(c);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(c);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Ne(c)) {
            this.readWord(c);
            return;
          }
      }
      throw this.raise(x.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(c) });
    }
    finishOp(c, o) {
      let f = this.input.slice(this.state.pos, this.state.pos + o);
      this.state.pos += o, this.finishToken(c, f);
    }
    readRegexp() {
      let c = this.state.startLoc, o = this.state.start + 1, f, g, { pos: b } = this.state;
      for (; ; ++b) {
        if (b >= this.length)
          throw this.raise(x.UnterminatedRegExp, n(c, 1));
        let N = this.input.charCodeAt(b);
        if (Ka(N))
          throw this.raise(x.UnterminatedRegExp, n(c, 1));
        if (f)
          f = !1;
        else {
          if (N === 91)
            g = !0;
          else if (N === 93 && g)
            g = !1;
          else if (N === 47 && !g)
            break;
          f = N === 92;
        }
      }
      let E = this.input.slice(o, b);
      ++b;
      let T = "", F = () => n(c, b + 2 - o);
      for (; b < this.length; ) {
        let N = this.codePointAtPos(b), $ = String.fromCharCode(N);
        if (lA.has(N))
          N === 118 ? T.includes("u") && this.raise(x.IncompatibleRegExpUVFlags, F()) : N === 117 && T.includes("v") && this.raise(x.IncompatibleRegExpUVFlags, F()), T.includes($) && this.raise(x.DuplicateRegExpFlags, F());
        else if ($e(N) || N === 92)
          this.raise(x.MalformedRegExpFlags, F());
        else
          break;
        ++b, T += $;
      }
      this.state.pos = b, this.finishToken(137, { pattern: E, flags: T });
    }
    readInt(c, o, f = !1, g = !0) {
      let { n: b, pos: E } = my(this.input, this.state.pos, this.state.lineStart, this.state.curLine, c, o, f, g, this.errorHandlers_readInt, !1);
      return this.state.pos = E, b;
    }
    readRadixNumber(c) {
      let o = this.state.curPosition(), f = !1;
      this.state.pos += 2;
      let g = this.readInt(c);
      g == null && this.raise(x.InvalidDigit, n(o, 2), { radix: c });
      let b = this.input.charCodeAt(this.state.pos);
      if (b === 110)
        ++this.state.pos, f = !0;
      else if (b === 109)
        throw this.raise(x.InvalidDecimal, o);
      if (Ne(this.codePointAtPos(this.state.pos)))
        throw this.raise(x.NumberIdentifier, this.state.curPosition());
      if (f) {
        let E = this.input.slice(o.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, E);
        return;
      }
      this.finishToken(134, g);
    }
    readNumber(c) {
      let o = this.state.pos, f = this.state.curPosition(), g = !1, b = !1, E = !1, T = !1, F = !1;
      !c && this.readInt(10) === null && this.raise(x.InvalidNumber, this.state.curPosition());
      let N = this.state.pos - o >= 2 && this.input.charCodeAt(o) === 48;
      if (N) {
        let ce = this.input.slice(o, this.state.pos);
        if (this.recordStrictModeErrors(x.StrictOctalLiteral, f), !this.state.strict) {
          let oe = ce.indexOf("_");
          oe > 0 && this.raise(x.ZeroDigitNumericSeparator, n(f, oe));
        }
        F = N && !/[89]/.test(ce);
      }
      let $ = this.input.charCodeAt(this.state.pos);
      if ($ === 46 && !F && (++this.state.pos, this.readInt(10), g = !0, $ = this.input.charCodeAt(this.state.pos)), ($ === 69 || $ === 101) && !F && ($ = this.input.charCodeAt(++this.state.pos), ($ === 43 || $ === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(x.InvalidOrMissingExponent, f), g = !0, T = !0, $ = this.input.charCodeAt(this.state.pos)), $ === 110 && ((g || N) && this.raise(x.InvalidBigIntLiteral, f), ++this.state.pos, b = !0), $ === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (T || N) && this.raise(x.InvalidDecimal, f), ++this.state.pos, E = !0), Ne(this.codePointAtPos(this.state.pos)))
        throw this.raise(x.NumberIdentifier, this.state.curPosition());
      let U = this.input.slice(o, this.state.pos).replace(/[_mn]/g, "");
      if (b) {
        this.finishToken(135, U);
        return;
      }
      if (E) {
        this.finishToken(136, U);
        return;
      }
      let ie = F ? parseInt(U, 8) : parseFloat(U);
      this.finishToken(134, ie);
    }
    readCodePoint(c) {
      let { code: o, pos: f } = gy(this.input, this.state.pos, this.state.lineStart, this.state.curLine, c, this.errorHandlers_readCodePoint);
      return this.state.pos = f, o;
    }
    readString(c) {
      let { str: o, pos: f, curLine: g, lineStart: b } = fy(c === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = f + 1, this.state.lineStart = b, this.state.curLine = g, this.finishToken(133, o);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let c = this.input[this.state.pos], { str: o, firstInvalidLoc: f, pos: g, curLine: b, lineStart: E } = fy("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = g + 1, this.state.lineStart = E, this.state.curLine = b, f && (this.state.firstInvalidTemplateEscapePos = new r(f.curLine, f.pos - f.lineStart, f.pos)), this.input.codePointAt(g) === 96 ? this.finishToken(24, f ? null : c + o + "`") : (this.state.pos++, this.finishToken(25, f ? null : c + o + "${"));
    }
    recordStrictModeErrors(c, o) {
      let f = o.index;
      this.state.strict && !this.state.strictErrors.has(f) ? this.raise(c, o) : this.state.strictErrors.set(f, [c, o]);
    }
    readWord1(c) {
      this.state.containsEsc = !1;
      let o = "", f = this.state.pos, g = this.state.pos;
      for (c !== void 0 && (this.state.pos += c <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let b = this.codePointAtPos(this.state.pos);
        if ($e(b))
          this.state.pos += b <= 65535 ? 1 : 2;
        else if (b === 92) {
          this.state.containsEsc = !0, o += this.input.slice(g, this.state.pos);
          let E = this.state.curPosition(), T = this.state.pos === f ? Ne : $e;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(x.MissingUnicodeEscape, this.state.curPosition()), g = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let F = this.readCodePoint(!0);
          F !== null && (T(F) || this.raise(x.EscapedCharNotAnIdentifier, E), o += String.fromCodePoint(F)), g = this.state.pos;
        } else
          break;
      }
      return o + this.input.slice(g, this.state.pos);
    }
    readWord(c) {
      let o = this.readWord1(c), f = X.get(o);
      f !== void 0 ? this.finishToken(f, ui(f)) : this.finishToken(132, o);
    }
    checkKeywordEscapes() {
      let { type: c } = this.state;
      ur(c) && this.state.containsEsc && this.raise(x.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: ui(c) });
    }
    raise(c, o, f = {}) {
      let g = o instanceof r ? o : o.loc.start, b = c(g, f);
      if (!this.options.errorRecovery)
        throw b;
      return this.isLookahead || this.state.errors.push(b), b;
    }
    raiseOverwrite(c, o, f = {}) {
      let g = o instanceof r ? o : o.loc.start, b = g.index, E = this.state.errors;
      for (let T = E.length - 1; T >= 0; T--) {
        let F = E[T];
        if (F.loc.index === b)
          return E[T] = c(g, f);
        if (F.loc.index < b)
          break;
      }
      return this.raise(c, o, f);
    }
    updateContext(c) {
    }
    unexpected(c, o) {
      throw this.raise(x.UnexpectedToken, c ?? this.state.startLoc, { expected: o ? ui(o) : null });
    }
    expectPlugin(c, o) {
      if (this.hasPlugin(c))
        return !0;
      throw this.raise(x.MissingPlugin, o ?? this.state.startLoc, { missingPlugin: [c] });
    }
    expectOnePlugin(c) {
      if (!c.some((o) => this.hasPlugin(o)))
        throw this.raise(x.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: c });
    }
    errorBuilder(c) {
      return (o, f, g) => {
        this.raise(c, eo(o, f, g));
      };
    }
  }, cA = class {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, hA = class {
    constructor(c) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = c;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new cA());
    }
    exit() {
      let c = this.stack.pop(), o = this.current();
      for (let [f, g] of Array.from(c.undefinedPrivateNames))
        o ? o.undefinedPrivateNames.has(f) || o.undefinedPrivateNames.set(f, g) : this.parser.raise(x.InvalidPrivateFieldResolution, g, { identifierName: f });
    }
    declarePrivateName(c, o, f) {
      let { privateNames: g, loneAccessors: b, undefinedPrivateNames: E } = this.current(), T = g.has(c);
      if (o & 3) {
        let F = T && b.get(c);
        if (F) {
          let N = F & 4, $ = o & 4, U = F & 3, ie = o & 3;
          T = U === ie || N !== $, T || b.delete(c);
        } else
          T || b.set(c, o);
      }
      T && this.parser.raise(x.PrivateNameRedeclaration, f, { identifierName: c }), g.add(c), E.delete(c);
    }
    usePrivateName(c, o) {
      let f;
      for (f of this.stack)
        if (f.privateNames.has(c))
          return;
      f ? f.undefinedPrivateNames.set(c, o) : this.parser.raise(x.InvalidPrivateFieldResolution, o, { identifierName: c });
    }
  }, zl = class {
    constructor(c = 0) {
      this.type = c;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, yy = class extends zl {
    constructor(c) {
      super(c), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(c, o) {
      let f = o.index;
      this.declarationErrors.set(f, [c, o]);
    }
    clearDeclarationError(c) {
      this.declarationErrors.delete(c);
    }
    iterateErrors(c) {
      this.declarationErrors.forEach(c);
    }
  }, pA = class {
    constructor(c) {
      this.parser = void 0, this.stack = [new zl()], this.parser = c;
    }
    enter(c) {
      this.stack.push(c);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(c, o) {
      let f = o.loc.start, { stack: g } = this, b = g.length - 1, E = g[b];
      for (; !E.isCertainlyParameterDeclaration(); ) {
        if (E.canBeArrowParameterDeclaration())
          E.recordDeclarationError(c, f);
        else
          return;
        E = g[--b];
      }
      this.parser.raise(c, f);
    }
    recordArrowParameterBindingError(c, o) {
      let { stack: f } = this, g = f[f.length - 1], b = o.loc.start;
      if (g.isCertainlyParameterDeclaration())
        this.parser.raise(c, b);
      else if (g.canBeArrowParameterDeclaration())
        g.recordDeclarationError(c, b);
      else
        return;
    }
    recordAsyncArrowParametersError(c) {
      let { stack: o } = this, f = o.length - 1, g = o[f];
      for (; g.canBeArrowParameterDeclaration(); )
        g.type === 2 && g.recordDeclarationError(x.AwaitBindingIdentifier, c), g = o[--f];
    }
    validateAsPattern() {
      let { stack: c } = this, o = c[c.length - 1];
      o.canBeArrowParameterDeclaration() && o.iterateErrors(([f, g]) => {
        this.parser.raise(f, g);
        let b = c.length - 2, E = c[b];
        for (; E.canBeArrowParameterDeclaration(); )
          E.clearDeclarationError(g.index), E = c[--b];
      });
    }
  };
  function dA() {
    return new zl(3);
  }
  function fA() {
    return new yy(1);
  }
  function mA() {
    return new yy(2);
  }
  function Oy() {
    return new zl();
  }
  var gA = class {
    constructor() {
      this.stacks = [];
    }
    enter(c) {
      this.stacks.push(c);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function Gl(c, o) {
    return (c ? 2 : 0) | (o ? 1 : 0);
  }
  var yA = class extends uA {
    addExtra(c, o, f, g = !0) {
      if (!c)
        return;
      let b = c.extra = c.extra || {};
      g ? b[o] = f : Object.defineProperty(b, o, { enumerable: g, value: f });
    }
    isContextual(c) {
      return this.state.type === c && !this.state.containsEsc;
    }
    isUnparsedContextual(c, o) {
      let f = c + o.length;
      if (this.input.slice(c, f) === o) {
        let g = this.input.charCodeAt(f);
        return !($e(g) || (g & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(c) {
      let o = this.nextTokenStart();
      return this.isUnparsedContextual(o, c);
    }
    eatContextual(c) {
      return this.isContextual(c) ? (this.next(), !0) : !1;
    }
    expectContextual(c, o) {
      if (!this.eatContextual(c)) {
        if (o != null)
          throw this.raise(o, this.state.startLoc);
        this.unexpected(null, c);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return hy.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return py.lastIndex = this.state.end, py.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(c = !0) {
      (c ? this.isLineTerminator() : this.eat(13)) || this.raise(x.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(c, o) {
      this.eat(c) || this.unexpected(o, c);
    }
    tryParse(c, o = this.state.clone()) {
      let f = { node: null };
      try {
        let g = c((b = null) => {
          throw f.node = b, f;
        });
        if (this.state.errors.length > o.errors.length) {
          let b = this.state;
          return this.state = o, this.state.tokensLength = b.tokensLength, { node: g, error: b.errors[o.errors.length], thrown: !1, aborted: !1, failState: b };
        }
        return { node: g, error: null, thrown: !1, aborted: !1, failState: null };
      } catch (g) {
        let b = this.state;
        if (this.state = o, g instanceof SyntaxError)
          return { node: null, error: g, thrown: !0, aborted: !1, failState: b };
        if (g === f)
          return { node: f.node, error: null, thrown: !1, aborted: !0, failState: b };
        throw g;
      }
    }
    checkExpressionErrors(c, o) {
      if (!c)
        return !1;
      let { shorthandAssignLoc: f, doubleProtoLoc: g, privateKeyLoc: b, optionalParametersLoc: E } = c, T = !!f || !!g || !!E || !!b;
      if (!o)
        return T;
      f != null && this.raise(x.InvalidCoverInitializedName, f), g != null && this.raise(x.DuplicateProto, g), b != null && this.raise(x.UnexpectedPrivateField, b), E != null && this.unexpected(E);
    }
    isLiteralPropertyName() {
      return Ae(this.state.type);
    }
    isPrivateName(c) {
      return c.type === "PrivateName";
    }
    getPrivateNameSV(c) {
      return c.id.name;
    }
    hasPropertyAsPrivateName(c) {
      return (c.type === "MemberExpression" || c.type === "OptionalMemberExpression") && this.isPrivateName(c.property);
    }
    isObjectProperty(c) {
      return c.type === "ObjectProperty";
    }
    isObjectMethod(c) {
      return c.type === "ObjectMethod";
    }
    initializeScopes(c = this.options.sourceType === "module") {
      let o = this.state.labels;
      this.state.labels = [];
      let f = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let g = this.inModule;
      this.inModule = c;
      let b = this.scope, E = this.getScopeHandler();
      this.scope = new E(this, c);
      let T = this.prodParam;
      this.prodParam = new gA();
      let F = this.classScope;
      this.classScope = new hA(this);
      let N = this.expressionScope;
      return this.expressionScope = new pA(this), () => {
        this.state.labels = o, this.exportedIdentifiers = f, this.inModule = g, this.scope = b, this.prodParam = T, this.classScope = F, this.expressionScope = N;
      };
    }
    enterInitialScopes() {
      let c = 0;
      this.inModule && (c |= 2), this.scope.enter(1), this.prodParam.enter(c);
    }
    checkDestructuringPrivate(c) {
      let { privateKeyLoc: o } = c;
      o !== null && this.expectPlugin("destructuringPrivate", o);
    }
  }, Hl = class {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, Jl = class {
    constructor(c, o, f) {
      this.type = "", this.start = o, this.end = 0, this.loc = new i(f), c != null && c.options.ranges && (this.range = [o, 0]), c != null && c.filename && (this.loc.filename = c.filename);
    }
  }, Kh = Jl.prototype;
  Kh.__clone = function() {
    let c = new Jl(void 0, this.start, this.loc.start), o = Object.keys(this);
    for (let f = 0, g = o.length; f < g; f++) {
      let b = o[f];
      b !== "leadingComments" && b !== "trailingComments" && b !== "innerComments" && (c[b] = this[b]);
    }
    return c;
  };
  function OA(c) {
    return Zi(c);
  }
  function Zi(c) {
    let { type: o, start: f, end: g, loc: b, range: E, extra: T, name: F } = c, N = Object.create(Kh);
    return N.type = o, N.start = f, N.end = g, N.loc = b, N.range = E, N.extra = T, N.name = F, o === "Placeholder" && (N.expectedNode = c.expectedNode), N;
  }
  function xA(c) {
    let { type: o, start: f, end: g, loc: b, range: E, extra: T } = c;
    if (o === "Placeholder")
      return OA(c);
    let F = Object.create(Kh);
    return F.type = o, F.start = f, F.end = g, F.loc = b, F.range = E, c.raw !== void 0 ? F.raw = c.raw : F.extra = T, F.value = c.value, F;
  }
  var DA = class extends yA {
    startNode() {
      let c = this.state.startLoc;
      return new Jl(this, c.index, c);
    }
    startNodeAt(c) {
      return new Jl(this, c.index, c);
    }
    startNodeAtNode(c) {
      return this.startNodeAt(c.loc.start);
    }
    finishNode(c, o) {
      return this.finishNodeAt(c, o, this.state.lastTokEndLoc);
    }
    finishNodeAt(c, o, f) {
      return c.type = o, c.end = f.index, c.loc.end = f, this.options.ranges && (c.range[1] = f.index), this.options.attachComment && this.processComment(c), c;
    }
    resetStartLocation(c, o) {
      c.start = o.index, c.loc.start = o, this.options.ranges && (c.range[0] = o.index);
    }
    resetEndLocation(c, o = this.state.lastTokEndLoc) {
      c.end = o.index, c.loc.end = o, this.options.ranges && (c.range[1] = o.index);
    }
    resetStartLocationFromNode(c, o) {
      this.resetStartLocation(c, o.loc.start);
    }
  }, bA = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), xe = w`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: c }) => `Cannot overwrite reserved type ${c}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: c, enumName: o }) => `Boolean enum members need to be initialized. Use either \`${c} = true,\` or \`${c} = false,\` in enum \`${o}\`.`, EnumDuplicateMemberName: ({ memberName: c, enumName: o }) => `Enum member names need to be unique, but the name \`${c}\` has already been used before in enum \`${o}\`.`, EnumInconsistentMemberValues: ({ enumName: c }) => `Enum \`${c}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: c, enumName: o }) => `Enum type \`${c}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${o}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: c }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${c}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: c, memberName: o, explicitType: f }) => `Enum \`${c}\` has type \`${f}\`, so the initializer of \`${o}\` needs to be a ${f} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: c, memberName: o }) => `Symbol enum members cannot be initialized. Use \`${o},\` in enum \`${c}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: c, memberName: o }) => `The enum member initializer for \`${o}\` needs to be a literal (either a boolean, number, or string) in enum \`${c}\`.`, EnumInvalidMemberName: ({ enumName: c, memberName: o, suggestion: f }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${o}\`, consider using \`${f}\`, in enum \`${c}\`.`, EnumNumberMemberNotInitialized: ({ enumName: c, memberName: o }) => `Number enum members need to be initialized, e.g. \`${o} = 1\` in enum \`${c}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: c }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${c}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: c }) => `Unexpected reserved type ${c}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: c, suggestion: o }) => `\`declare export ${c}\` is not supported. Use \`${o}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
  function vA(c) {
    return c.type === "DeclareExportAllDeclaration" || c.type === "DeclareExportDeclaration" && (!c.declaration || c.declaration.type !== "TypeAlias" && c.declaration.type !== "InterfaceDeclaration");
  }
  function xy(c) {
    return c.importKind === "type" || c.importKind === "typeof";
  }
  var wA = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
  function SA(c, o) {
    let f = [], g = [];
    for (let b = 0; b < c.length; b++)
      (o(c[b], b, c) ? f : g).push(c[b]);
    return [f, g];
  }
  var CA = /\*?\s*@((?:no)?flow)\b/, EA = (c) => class extends c {
    constructor(...o) {
      super(...o), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return KE;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(o, f) {
      o !== 133 && o !== 13 && o !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(o, f);
    }
    addComment(o) {
      if (this.flowPragma === void 0) {
        let f = CA.exec(o.value);
        if (f)
          if (f[1] === "flow")
            this.flowPragma = "flow";
          else if (f[1] === "noflow")
            this.flowPragma = "noflow";
          else
            throw new Error("Unexpected flow pragma");
      }
      super.addComment(o);
    }
    flowParseTypeInitialiser(o) {
      let f = this.state.inType;
      this.state.inType = !0, this.expect(o || 14);
      let g = this.flowParseType();
      return this.state.inType = f, g;
    }
    flowParsePredicate() {
      let o = this.startNode(), f = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > f.index + 1 && this.raise(xe.UnexpectedSpaceBetweenModuloChecks, f), this.eat(10) ? (o.value = super.parseExpression(), this.expect(11), this.finishNode(o, "DeclaredPredicate")) : this.finishNode(o, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let o = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let f = null, g = null;
      return this.match(54) ? (this.state.inType = o, g = this.flowParsePredicate()) : (f = this.flowParseType(), this.state.inType = o, this.match(54) && (g = this.flowParsePredicate())), [f, g];
    }
    flowParseDeclareClass(o) {
      return this.next(), this.flowParseInterfaceish(o, !0), this.finishNode(o, "DeclareClass");
    }
    flowParseDeclareFunction(o) {
      this.next();
      let f = o.id = this.parseIdentifier(), g = this.startNode(), b = this.startNode();
      this.match(47) ? g.typeParameters = this.flowParseTypeParameterDeclaration() : g.typeParameters = null, this.expect(10);
      let E = this.flowParseFunctionTypeParams();
      return g.params = E.params, g.rest = E.rest, g.this = E._this, this.expect(11), [g.returnType, o.predicate] = this.flowParseTypeAndPredicateInitialiser(), b.typeAnnotation = this.finishNode(g, "FunctionTypeAnnotation"), f.typeAnnotation = this.finishNode(b, "TypeAnnotation"), this.resetEndLocation(f), this.semicolon(), this.scope.declareName(o.id.name, 2048, o.id.loc.start), this.finishNode(o, "DeclareFunction");
    }
    flowParseDeclare(o, f) {
      if (this.match(80))
        return this.flowParseDeclareClass(o);
      if (this.match(68))
        return this.flowParseDeclareFunction(o);
      if (this.match(74))
        return this.flowParseDeclareVariable(o);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(o) : (f && this.raise(xe.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(o));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(o);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(o);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(o);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(o, f);
      this.unexpected();
    }
    flowParseDeclareVariable(o) {
      return this.next(), o.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(o.id.name, 5, o.id.loc.start), this.semicolon(), this.finishNode(o, "DeclareVariable");
    }
    flowParseDeclareModule(o) {
      this.scope.enter(0), this.match(133) ? o.id = super.parseExprAtom() : o.id = this.parseIdentifier();
      let f = o.body = this.startNode(), g = f.body = [];
      for (this.expect(5); !this.match(8); ) {
        let T = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(xe.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(T)) : (this.expectContextual(125, xe.UnsupportedStatementInDeclareModule), T = this.flowParseDeclare(T, !0)), g.push(T);
      }
      this.scope.exit(), this.expect(8), this.finishNode(f, "BlockStatement");
      let b = null, E = !1;
      return g.forEach((T) => {
        vA(T) ? (b === "CommonJS" && this.raise(xe.AmbiguousDeclareModuleKind, T), b = "ES") : T.type === "DeclareModuleExports" && (E && this.raise(xe.DuplicateDeclareModuleExports, T), b === "ES" && this.raise(xe.AmbiguousDeclareModuleKind, T), b = "CommonJS", E = !0);
      }), o.kind = b || "CommonJS", this.finishNode(o, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(o, f) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? o.declaration = this.flowParseDeclare(this.startNode()) : (o.declaration = this.flowParseType(), this.semicolon()), o.default = !0, this.finishNode(o, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !f) {
        let g = this.state.value;
        throw this.raise(xe.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: g, suggestion: wA[g] });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return o.declaration = this.flowParseDeclare(this.startNode()), o.default = !1, this.finishNode(o, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return o = this.parseExport(o, null), o.type === "ExportNamedDeclaration" && (o.type = "ExportDeclaration", o.default = !1, delete o.exportKind), o.type = "Declare" + o.type, o;
      this.unexpected();
    }
    flowParseDeclareModuleExports(o) {
      return this.next(), this.expectContextual(111), o.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(o, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(o) {
      this.next();
      let f = this.flowParseTypeAlias(o);
      return f.type = "DeclareTypeAlias", f;
    }
    flowParseDeclareOpaqueType(o) {
      this.next();
      let f = this.flowParseOpaqueType(o, !0);
      return f.type = "DeclareOpaqueType", f;
    }
    flowParseDeclareInterface(o) {
      return this.next(), this.flowParseInterfaceish(o, !1), this.finishNode(o, "DeclareInterface");
    }
    flowParseInterfaceish(o, f) {
      if (o.id = this.flowParseRestrictedIdentifier(!f, !0), this.scope.declareName(o.id.name, f ? 17 : 8201, o.id.loc.start), this.match(47) ? o.typeParameters = this.flowParseTypeParameterDeclaration() : o.typeParameters = null, o.extends = [], this.eat(81))
        do
          o.extends.push(this.flowParseInterfaceExtends());
        while (!f && this.eat(12));
      if (f) {
        if (o.implements = [], o.mixins = [], this.eatContextual(117))
          do
            o.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            o.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      o.body = this.flowParseObjectType({ allowStatic: f, allowExact: !1, allowSpread: !1, allowProto: f, allowInexact: !1 });
    }
    flowParseInterfaceExtends() {
      let o = this.startNode();
      return o.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? o.typeParameters = this.flowParseTypeParameterInstantiation() : o.typeParameters = null, this.finishNode(o, "InterfaceExtends");
    }
    flowParseInterface(o) {
      return this.flowParseInterfaceish(o, !1), this.finishNode(o, "InterfaceDeclaration");
    }
    checkNotUnderscore(o) {
      o === "_" && this.raise(xe.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(o, f, g) {
      bA.has(o) && this.raise(g ? xe.AssignReservedType : xe.UnexpectedReservedType, f, { reservedType: o });
    }
    flowParseRestrictedIdentifier(o, f) {
      return this.checkReservedType(this.state.value, this.state.startLoc, f), this.parseIdentifier(o);
    }
    flowParseTypeAlias(o) {
      return o.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(o.id.name, 8201, o.id.loc.start), this.match(47) ? o.typeParameters = this.flowParseTypeParameterDeclaration() : o.typeParameters = null, o.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(o, "TypeAlias");
    }
    flowParseOpaqueType(o, f) {
      return this.expectContextual(130), o.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(o.id.name, 8201, o.id.loc.start), this.match(47) ? o.typeParameters = this.flowParseTypeParameterDeclaration() : o.typeParameters = null, o.supertype = null, this.match(14) && (o.supertype = this.flowParseTypeInitialiser(14)), o.impltype = null, f || (o.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(o, "OpaqueType");
    }
    flowParseTypeParameter(o = !1) {
      let f = this.state.startLoc, g = this.startNode(), b = this.flowParseVariance(), E = this.flowParseTypeAnnotatableIdentifier();
      return g.name = E.name, g.variance = b, g.bound = E.typeAnnotation, this.match(29) ? (this.eat(29), g.default = this.flowParseType()) : o && this.raise(xe.MissingTypeParamDefault, f), this.finishNode(g, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let o = this.state.inType, f = this.startNode();
      f.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let g = !1;
      do {
        let b = this.flowParseTypeParameter(g);
        f.params.push(b), b.default && (g = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = o, this.finishNode(f, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let o = this.startNode(), f = this.state.inType;
      o.params = [], this.state.inType = !0, this.expect(47);
      let g = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        o.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = g, this.expect(48), this.state.inType = f, this.finishNode(o, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let o = this.startNode(), f = this.state.inType;
      for (o.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        o.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = f, this.finishNode(o, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let o = this.startNode();
      if (this.expectContextual(129), o.extends = [], this.eat(81))
        do
          o.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return o.body = this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !1, allowProto: !1, allowInexact: !1 }), this.finishNode(o, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(o, f, g) {
      return o.static = f, this.lookahead().type === 14 ? (o.id = this.flowParseObjectPropertyKey(), o.key = this.flowParseTypeInitialiser()) : (o.id = null, o.key = this.flowParseType()), this.expect(3), o.value = this.flowParseTypeInitialiser(), o.variance = g, this.finishNode(o, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(o, f) {
      return o.static = f, o.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (o.method = !0, o.optional = !1, o.value = this.flowParseObjectTypeMethodish(this.startNodeAt(o.loc.start))) : (o.method = !1, this.eat(17) && (o.optional = !0), o.value = this.flowParseTypeInitialiser()), this.finishNode(o, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(o) {
      for (o.params = [], o.rest = null, o.typeParameters = null, o.this = null, this.match(47) && (o.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (o.this = this.flowParseFunctionTypeParam(!0), o.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        o.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (o.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), o.returnType = this.flowParseTypeInitialiser(), this.finishNode(o, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(o, f) {
      let g = this.startNode();
      return o.static = f, o.value = this.flowParseObjectTypeMethodish(g), this.finishNode(o, "ObjectTypeCallProperty");
    }
    flowParseObjectType({ allowStatic: o, allowExact: f, allowSpread: g, allowProto: b, allowInexact: E }) {
      let T = this.state.inType;
      this.state.inType = !0;
      let F = this.startNode();
      F.callProperties = [], F.properties = [], F.indexers = [], F.internalSlots = [];
      let N, $, U = !1;
      for (f && this.match(6) ? (this.expect(6), N = 9, $ = !0) : (this.expect(5), N = 8, $ = !1), F.exact = $; !this.match(N); ) {
        let ce = !1, oe = null, Xe = null, qe = this.startNode();
        if (b && this.isContextual(118)) {
          let Qt = this.lookahead();
          Qt.type !== 14 && Qt.type !== 17 && (this.next(), oe = this.state.startLoc, o = !1);
        }
        if (o && this.isContextual(106)) {
          let Qt = this.lookahead();
          Qt.type !== 14 && Qt.type !== 17 && (this.next(), ce = !0);
        }
        let mt = this.flowParseVariance();
        if (this.eat(0))
          oe != null && this.unexpected(oe), this.eat(0) ? (mt && this.unexpected(mt.loc.start), F.internalSlots.push(this.flowParseObjectTypeInternalSlot(qe, ce))) : F.indexers.push(this.flowParseObjectTypeIndexer(qe, ce, mt));
        else if (this.match(10) || this.match(47))
          oe != null && this.unexpected(oe), mt && this.unexpected(mt.loc.start), F.callProperties.push(this.flowParseObjectTypeCallProperty(qe, ce));
        else {
          let Qt = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let ip = this.lookahead();
            Ae(ip.type) && (Qt = this.state.value, this.next());
          }
          let cr = this.flowParseObjectTypeProperty(qe, ce, oe, mt, Qt, g, E ?? !$);
          cr === null ? (U = !0, Xe = this.state.lastTokStartLoc) : F.properties.push(cr);
        }
        this.flowObjectTypeSemicolon(), Xe && !this.match(8) && !this.match(9) && this.raise(xe.UnexpectedExplicitInexactInObject, Xe);
      }
      this.expect(N), g && (F.inexact = U);
      let ie = this.finishNode(F, "ObjectTypeAnnotation");
      return this.state.inType = T, ie;
    }
    flowParseObjectTypeProperty(o, f, g, b, E, T, F) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (T ? F || this.raise(xe.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(xe.InexactInsideNonObject, this.state.lastTokStartLoc), b && this.raise(xe.InexactVariance, b), null) : (T || this.raise(xe.UnexpectedSpreadType, this.state.lastTokStartLoc), g != null && this.unexpected(g), b && this.raise(xe.SpreadVariance, b), o.argument = this.flowParseType(), this.finishNode(o, "ObjectTypeSpreadProperty"));
      {
        o.key = this.flowParseObjectPropertyKey(), o.static = f, o.proto = g != null, o.kind = E;
        let N = !1;
        return this.match(47) || this.match(10) ? (o.method = !0, g != null && this.unexpected(g), b && this.unexpected(b.loc.start), o.value = this.flowParseObjectTypeMethodish(this.startNodeAt(o.loc.start)), (E === "get" || E === "set") && this.flowCheckGetterSetterParams(o), !T && o.key.name === "constructor" && o.value.this && this.raise(xe.ThisParamBannedInConstructor, o.value.this)) : (E !== "init" && this.unexpected(), o.method = !1, this.eat(17) && (N = !0), o.value = this.flowParseTypeInitialiser(), o.variance = b), o.optional = N, this.finishNode(o, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(o) {
      let f = o.kind === "get" ? 0 : 1, g = o.value.params.length + (o.value.rest ? 1 : 0);
      o.value.this && this.raise(o.kind === "get" ? xe.GetterMayNotHaveThisParam : xe.SetterMayNotHaveThisParam, o.value.this), g !== f && this.raise(o.kind === "get" ? x.BadGetterArity : x.BadSetterArity, o), o.kind === "set" && o.value.rest && this.raise(x.BadSetterRestParameter, o);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(o, f) {
      o != null || (o = this.state.startLoc);
      let g = f || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let b = this.startNodeAt(o);
        b.qualification = g, b.id = this.flowParseRestrictedIdentifier(!0), g = this.finishNode(b, "QualifiedTypeIdentifier");
      }
      return g;
    }
    flowParseGenericType(o, f) {
      let g = this.startNodeAt(o);
      return g.typeParameters = null, g.id = this.flowParseQualifiedTypeIdentifier(o, f), this.match(47) && (g.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(g, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let o = this.startNode();
      return this.expect(87), o.argument = this.flowParsePrimaryType(), this.finishNode(o, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let o = this.startNode();
      for (o.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (o.types.push(this.flowParseType()), !this.match(3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(o, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(o) {
      let f = null, g = !1, b = null, E = this.startNode(), T = this.lookahead(), F = this.state.type === 78;
      return T.type === 14 || T.type === 17 ? (F && !o && this.raise(xe.ThisParamMustBeFirst, E), f = this.parseIdentifier(F), this.eat(17) && (g = !0, F && this.raise(xe.ThisParamMayNotBeOptional, E)), b = this.flowParseTypeInitialiser()) : b = this.flowParseType(), E.name = f, E.optional = g, E.typeAnnotation = b, this.finishNode(E, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(o) {
      let f = this.startNodeAt(o.loc.start);
      return f.name = null, f.optional = !1, f.typeAnnotation = o, this.finishNode(f, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(o = []) {
      let f = null, g = null;
      for (this.match(78) && (g = this.flowParseFunctionTypeParam(!0), g.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        o.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (f = this.flowParseFunctionTypeParam(!1)), { params: o, rest: f, _this: g };
    }
    flowIdentToTypeAnnotation(o, f, g) {
      switch (g.name) {
        case "any":
          return this.finishNode(f, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(f, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(f, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(f, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(f, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(f, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(f, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(g.name), this.flowParseGenericType(o, g);
      }
    }
    flowParsePrimaryType() {
      let o = this.state.startLoc, f = this.startNode(), g, b, E = !1, T = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !0, allowProto: !1, allowInexact: !0 });
        case 6:
          return this.flowParseObjectType({ allowStatic: !1, allowExact: !0, allowSpread: !0, allowProto: !1, allowInexact: !1 });
        case 0:
          return this.state.noAnonFunctionType = !1, b = this.flowParseTupleType(), this.state.noAnonFunctionType = T, b;
        case 47:
          return f.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), g = this.flowParseFunctionTypeParams(), f.params = g.params, f.rest = g.rest, f.this = g._this, this.expect(11), this.expect(19), f.returnType = this.flowParseType(), this.finishNode(f, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (j(this.state.type) || this.match(78)) {
              let F = this.lookahead().type;
              E = F !== 17 && F !== 14;
            } else
              E = !0;
          if (E) {
            if (this.state.noAnonFunctionType = !1, b = this.flowParseType(), this.state.noAnonFunctionType = T, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), b;
            this.eat(12);
          }
          return b ? g = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(b)]) : g = this.flowParseFunctionTypeParams(), f.params = g.params, f.rest = g.rest, f.this = g._this, this.expect(11), this.expect(19), f.returnType = this.flowParseType(), f.typeParameters = null, this.finishNode(f, "FunctionTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return f.value = this.match(85), this.next(), this.finishNode(f, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", f);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", f);
            throw this.raise(xe.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(f, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(f, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(f, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(f, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (ur(this.state.type)) {
            let F = ui(this.state.type);
            return this.next(), super.createIdentifier(f, F);
          } else if (j(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(o, f, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let o = this.state.startLoc, f = this.flowParsePrimaryType(), g = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let b = this.startNodeAt(o), E = this.eat(18);
        g = g || E, this.expect(0), !E && this.match(3) ? (b.elementType = f, this.next(), f = this.finishNode(b, "ArrayTypeAnnotation")) : (b.objectType = f, b.indexType = this.flowParseType(), this.expect(3), g ? (b.optional = E, f = this.finishNode(b, "OptionalIndexedAccessType")) : f = this.finishNode(b, "IndexedAccessType"));
      }
      return f;
    }
    flowParsePrefixType() {
      let o = this.startNode();
      return this.eat(17) ? (o.typeAnnotation = this.flowParsePrefixType(), this.finishNode(o, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let o = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let f = this.startNodeAt(o.loc.start);
        return f.params = [this.reinterpretTypeAsFunctionTypeParam(o)], f.rest = null, f.this = null, f.returnType = this.flowParseType(), f.typeParameters = null, this.finishNode(f, "FunctionTypeAnnotation");
      }
      return o;
    }
    flowParseIntersectionType() {
      let o = this.startNode();
      this.eat(45);
      let f = this.flowParseAnonFunctionWithoutParens();
      for (o.types = [f]; this.eat(45); )
        o.types.push(this.flowParseAnonFunctionWithoutParens());
      return o.types.length === 1 ? f : this.finishNode(o, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let o = this.startNode();
      this.eat(43);
      let f = this.flowParseIntersectionType();
      for (o.types = [f]; this.eat(43); )
        o.types.push(this.flowParseIntersectionType());
      return o.types.length === 1 ? f : this.finishNode(o, "UnionTypeAnnotation");
    }
    flowParseType() {
      let o = this.state.inType;
      this.state.inType = !0;
      let f = this.flowParseUnionType();
      return this.state.inType = o, f;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let o = this.state.startLoc, f = this.parseIdentifier();
        return this.flowParseGenericType(o, f);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let o = this.startNode();
      return o.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(o, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(o) {
      let f = o ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (f.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(f)), f;
    }
    typeCastToParameter(o) {
      return o.expression.typeAnnotation = o.typeAnnotation, this.resetEndLocation(o.expression, o.typeAnnotation.loc.end), o.expression;
    }
    flowParseVariance() {
      let o = null;
      return this.match(53) ? (o = this.startNode(), this.state.value === "+" ? o.kind = "plus" : o.kind = "minus", this.next(), this.finishNode(o, "Variance")) : o;
    }
    parseFunctionBody(o, f, g = !1) {
      if (f) {
        this.forwardNoArrowParamsConversionAt(o, () => super.parseFunctionBody(o, !0, g));
        return;
      }
      super.parseFunctionBody(o, !1, g);
    }
    parseFunctionBodyAndFinish(o, f, g = !1) {
      if (this.match(14)) {
        let b = this.startNode();
        [b.typeAnnotation, o.predicate] = this.flowParseTypeAndPredicateInitialiser(), o.returnType = b.typeAnnotation ? this.finishNode(b, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(o, f, g);
    }
    parseStatementLike(o) {
      if (this.state.strict && this.isContextual(129)) {
        let g = this.lookahead();
        if (De(g.type)) {
          let b = this.startNode();
          return this.next(), this.flowParseInterface(b);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        let g = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(g);
      }
      let f = super.parseStatementLike(o);
      return this.flowPragma === void 0 && !this.isValidDirective(f) && (this.flowPragma = null), f;
    }
    parseExpressionStatement(o, f, g) {
      if (f.type === "Identifier") {
        if (f.name === "declare") {
          if (this.match(80) || j(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(o);
        } else if (j(this.state.type)) {
          if (f.name === "interface")
            return this.flowParseInterface(o);
          if (f.name === "type")
            return this.flowParseTypeAlias(o);
          if (f.name === "opaque")
            return this.flowParseOpaqueType(o, !1);
        }
      }
      return super.parseExpressionStatement(o, f, g);
    }
    shouldParseExportDeclaration() {
      let { type: o } = this.state;
      return Xr(o) || this.shouldParseEnums() && o === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let { type: o } = this.state;
      return Xr(o) || this.shouldParseEnums() && o === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        let o = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(o);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(o, f, g) {
      if (!this.match(17))
        return o;
      if (this.state.maybeInArrowParameters) {
        let ie = this.lookaheadCharCode();
        if (ie === 44 || ie === 61 || ie === 58 || ie === 41)
          return this.setOptionalParametersError(g), o;
      }
      this.expect(17);
      let b = this.state.clone(), E = this.state.noArrowAt, T = this.startNodeAt(f), { consequent: F, failed: N } = this.tryParseConditionalConsequent(), [$, U] = this.getArrowLikeExpressions(F);
      if (N || U.length > 0) {
        let ie = [...E];
        if (U.length > 0) {
          this.state = b, this.state.noArrowAt = ie;
          for (let ce = 0; ce < U.length; ce++)
            ie.push(U[ce].start);
          ({ consequent: F, failed: N } = this.tryParseConditionalConsequent()), [$, U] = this.getArrowLikeExpressions(F);
        }
        N && $.length > 1 && this.raise(xe.AmbiguousConditionalArrow, b.startLoc), N && $.length === 1 && (this.state = b, ie.push($[0].start), this.state.noArrowAt = ie, { consequent: F, failed: N } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(F, !0), this.state.noArrowAt = E, this.expect(14), T.test = o, T.consequent = F, T.alternate = this.forwardNoArrowParamsConversionAt(T, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(T, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let o = this.parseMaybeAssignAllowIn(), f = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), { consequent: o, failed: f };
    }
    getArrowLikeExpressions(o, f) {
      let g = [o], b = [];
      for (; g.length !== 0; ) {
        let E = g.pop();
        E.type === "ArrowFunctionExpression" ? (E.typeParameters || !E.returnType ? this.finishArrowValidation(E) : b.push(E), g.push(E.body)) : E.type === "ConditionalExpression" && (g.push(E.consequent), g.push(E.alternate));
      }
      return f ? (b.forEach((E) => this.finishArrowValidation(E)), [b, []]) : SA(b, (E) => E.params.every((T) => this.isAssignable(T, !0)));
    }
    finishArrowValidation(o) {
      var f;
      this.toAssignableList(o.params, (f = o.extra) == null ? void 0 : f.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(o, !1, !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(o, f) {
      let g;
      return this.state.noArrowParamsConversionAt.indexOf(o.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), g = f(), this.state.noArrowParamsConversionAt.pop()) : g = f(), g;
    }
    parseParenItem(o, f) {
      if (o = super.parseParenItem(o, f), this.eat(17) && (o.optional = !0, this.resetEndLocation(o)), this.match(14)) {
        let g = this.startNodeAt(f);
        return g.expression = o, g.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(g, "TypeCastExpression");
      }
      return o;
    }
    assertModuleNodeAllowed(o) {
      o.type === "ImportDeclaration" && (o.importKind === "type" || o.importKind === "typeof") || o.type === "ExportNamedDeclaration" && o.exportKind === "type" || o.type === "ExportAllDeclaration" && o.exportKind === "type" || super.assertModuleNodeAllowed(o);
    }
    parseExportDeclaration(o) {
      if (this.isContextual(130)) {
        o.exportKind = "type";
        let f = this.startNode();
        return this.next(), this.match(5) ? (o.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(o), null) : this.flowParseTypeAlias(f);
      } else if (this.isContextual(131)) {
        o.exportKind = "type";
        let f = this.startNode();
        return this.next(), this.flowParseOpaqueType(f, !1);
      } else if (this.isContextual(129)) {
        o.exportKind = "type";
        let f = this.startNode();
        return this.next(), this.flowParseInterface(f);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        o.exportKind = "value";
        let f = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(f);
      } else
        return super.parseExportDeclaration(o);
    }
    eatExportStar(o) {
      return super.eatExportStar(o) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (o.exportKind = "type", this.next(), this.next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(o) {
      let { startLoc: f } = this.state, g = super.maybeParseExportNamespaceSpecifier(o);
      return g && o.exportKind === "type" && this.unexpected(f), g;
    }
    parseClassId(o, f, g) {
      super.parseClassId(o, f, g), this.match(47) && (o.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(o, f, g) {
      let { startLoc: b } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(o, f))
          return;
        f.declare = !0;
      }
      super.parseClassMember(o, f, g), f.declare && (f.type !== "ClassProperty" && f.type !== "ClassPrivateProperty" && f.type !== "PropertyDefinition" ? this.raise(xe.DeclareClassElement, b) : f.value && this.raise(xe.DeclareClassFieldInitializer, f.value));
    }
    isIterator(o) {
      return o === "iterator" || o === "asyncIterator";
    }
    readIterator() {
      let o = super.readWord1(), f = "@@" + o;
      (!this.isIterator(o) || !this.state.inType) && this.raise(x.InvalidIdentifier, this.state.curPosition(), { identifierName: f }), this.finishToken(132, f);
    }
    getTokenFromCode(o) {
      let f = this.input.charCodeAt(this.state.pos + 1);
      o === 123 && f === 124 ? this.finishOp(6, 2) : this.state.inType && (o === 62 || o === 60) ? this.finishOp(o === 62 ? 48 : 47, 1) : this.state.inType && o === 63 ? f === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : zE(o, f, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(o);
    }
    isAssignable(o, f) {
      return o.type === "TypeCastExpression" ? this.isAssignable(o.expression, f) : super.isAssignable(o, f);
    }
    toAssignable(o, f = !1) {
      !f && o.type === "AssignmentExpression" && o.left.type === "TypeCastExpression" && (o.left = this.typeCastToParameter(o.left)), super.toAssignable(o, f);
    }
    toAssignableList(o, f, g) {
      for (let b = 0; b < o.length; b++) {
        let E = o[b];
        (E == null ? void 0 : E.type) === "TypeCastExpression" && (o[b] = this.typeCastToParameter(E));
      }
      super.toAssignableList(o, f, g);
    }
    toReferencedList(o, f) {
      for (let b = 0; b < o.length; b++) {
        var g;
        let E = o[b];
        E && E.type === "TypeCastExpression" && !((g = E.extra) != null && g.parenthesized) && (o.length > 1 || !f) && this.raise(xe.TypeCastInPattern, E.typeAnnotation);
      }
      return o;
    }
    parseArrayLike(o, f, g, b) {
      let E = super.parseArrayLike(o, f, g, b);
      return f && !this.state.maybeInArrowParameters && this.toReferencedList(E.elements), E;
    }
    isValidLVal(o, f, g) {
      return o === "TypeCastExpression" || super.isValidLVal(o, f, g);
    }
    parseClassProperty(o) {
      return this.match(14) && (o.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(o);
    }
    parseClassPrivateProperty(o) {
      return this.match(14) && (o.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(o);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(o) {
      return !this.match(14) && super.isNonstaticConstructor(o);
    }
    pushClassMethod(o, f, g, b, E, T) {
      if (f.variance && this.unexpected(f.variance.loc.start), delete f.variance, this.match(47) && (f.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(o, f, g, b, E, T), f.params && E) {
        let F = f.params;
        F.length > 0 && this.isThisParam(F[0]) && this.raise(xe.ThisParamBannedInConstructor, f);
      } else if (f.type === "MethodDefinition" && E && f.value.params) {
        let F = f.value.params;
        F.length > 0 && this.isThisParam(F[0]) && this.raise(xe.ThisParamBannedInConstructor, f);
      }
    }
    pushClassPrivateMethod(o, f, g, b) {
      f.variance && this.unexpected(f.variance.loc.start), delete f.variance, this.match(47) && (f.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(o, f, g, b);
    }
    parseClassSuper(o) {
      if (super.parseClassSuper(o), o.superClass && this.match(47) && (o.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
        this.next();
        let f = o.implements = [];
        do {
          let g = this.startNode();
          g.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? g.typeParameters = this.flowParseTypeParameterInstantiation() : g.typeParameters = null, f.push(this.finishNode(g, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(o) {
      super.checkGetterSetterParams(o);
      let f = this.getObjectOrClassMethodParams(o);
      if (f.length > 0) {
        let g = f[0];
        this.isThisParam(g) && o.kind === "get" ? this.raise(xe.GetterMayNotHaveThisParam, g) : this.isThisParam(g) && this.raise(xe.SetterMayNotHaveThisParam, g);
      }
    }
    parsePropertyNamePrefixOperator(o) {
      o.variance = this.flowParseVariance();
    }
    parseObjPropValue(o, f, g, b, E, T, F) {
      o.variance && this.unexpected(o.variance.loc.start), delete o.variance;
      let N;
      this.match(47) && !T && (N = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let $ = super.parseObjPropValue(o, f, g, b, E, T, F);
      return N && (($.value || $).typeParameters = N), $;
    }
    parseAssignableListItemTypes(o) {
      return this.eat(17) && (o.type !== "Identifier" && this.raise(xe.PatternIsOptional, o), this.isThisParam(o) && this.raise(xe.ThisParamMayNotBeOptional, o), o.optional = !0), this.match(14) ? o.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(o) && this.raise(xe.ThisParamAnnotationRequired, o), this.match(29) && this.isThisParam(o) && this.raise(xe.ThisParamNoDefault, o), this.resetEndLocation(o), o;
    }
    parseMaybeDefault(o, f) {
      let g = super.parseMaybeDefault(o, f);
      return g.type === "AssignmentPattern" && g.typeAnnotation && g.right.start < g.typeAnnotation.start && this.raise(xe.TypeBeforeInitializer, g.typeAnnotation), g;
    }
    checkImportReflection(o) {
      super.checkImportReflection(o), o.module && o.importKind !== "value" && this.raise(xe.ImportReflectionHasImportType, o.specifiers[0].loc.start);
    }
    parseImportSpecifierLocal(o, f, g) {
      f.local = xy(o) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), o.specifiers.push(this.finishImportSpecifier(f, g));
    }
    isPotentialImportPhase(o) {
      if (super.isPotentialImportPhase(o))
        return !0;
      if (this.isContextual(130)) {
        if (!o)
          return !0;
        let f = this.lookaheadCharCode();
        return f === 123 || f === 42;
      }
      return !o && this.isContextual(87);
    }
    applyImportPhase(o, f, g, b) {
      if (super.applyImportPhase(o, f, g, b), f) {
        if (!g && this.match(65))
          return;
        o.exportKind = g === "type" ? g : "value";
      } else
        g === "type" && this.match(55) && this.unexpected(), o.importKind = g === "type" || g === "typeof" ? g : "value";
    }
    parseImportSpecifier(o, f, g, b, E) {
      let T = o.imported, F = null;
      T.type === "Identifier" && (T.name === "type" ? F = "type" : T.name === "typeof" && (F = "typeof"));
      let N = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let U = this.parseIdentifier(!0);
        F !== null && !De(this.state.type) ? (o.imported = U, o.importKind = F, o.local = Zi(U)) : (o.imported = T, o.importKind = null, o.local = this.parseIdentifier());
      } else {
        if (F !== null && De(this.state.type))
          o.imported = this.parseIdentifier(!0), o.importKind = F;
        else {
          if (f)
            throw this.raise(x.ImportBindingIsString, o, { importName: T.value });
          o.imported = T, o.importKind = null;
        }
        this.eatContextual(93) ? o.local = this.parseIdentifier() : (N = !0, o.local = Zi(o.imported));
      }
      let $ = xy(o);
      return g && $ && this.raise(xe.ImportTypeShorthandOnlyInPureImport, o), (g || $) && this.checkReservedType(o.local.name, o.local.loc.start, !0), N && !g && !$ && this.checkReservedWord(o.local.name, o.loc.start, !0, !0), this.finishImportSpecifier(o, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(o, f) {
      let g = o.kind;
      g !== "get" && g !== "set" && this.match(47) && (o.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(o, f);
    }
    parseVarId(o, f) {
      super.parseVarId(o, f), this.match(14) && (o.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(o.id));
    }
    parseAsyncArrowFromCallExpression(o, f) {
      if (this.match(14)) {
        let g = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, o.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = g;
      }
      return super.parseAsyncArrowFromCallExpression(o, f);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(o, f) {
      var g;
      let b = null, E;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (b = this.state.clone(), E = this.tryParse(() => super.parseMaybeAssign(o, f), b), !E.error)
          return E.node;
        let { context: N } = this.state, $ = N[N.length - 1];
        ($ === I.j_oTag || $ === I.j_expr) && N.pop();
      }
      if ((g = E) != null && g.error || this.match(47)) {
        var T, F;
        b = b || this.state.clone();
        let N, $ = this.tryParse((ie) => {
          var ce;
          N = this.flowParseTypeParameterDeclaration();
          let oe = this.forwardNoArrowParamsConversionAt(N, () => {
            let qe = super.parseMaybeAssign(o, f);
            return this.resetStartLocationFromNode(qe, N), qe;
          });
          (ce = oe.extra) != null && ce.parenthesized && ie();
          let Xe = this.maybeUnwrapTypeCastExpression(oe);
          return Xe.type !== "ArrowFunctionExpression" && ie(), Xe.typeParameters = N, this.resetStartLocationFromNode(Xe, N), oe;
        }, b), U = null;
        if ($.node && this.maybeUnwrapTypeCastExpression($.node).type === "ArrowFunctionExpression") {
          if (!$.error && !$.aborted)
            return $.node.async && this.raise(xe.UnexpectedTypeParameterBeforeAsyncArrowFunction, N), $.node;
          U = $.node;
        }
        if ((T = E) != null && T.node)
          return this.state = E.failState, E.node;
        if (U)
          return this.state = $.failState, U;
        throw (F = E) != null && F.thrown ? E.error : $.thrown ? $.error : this.raise(xe.UnexpectedTokenAfterTypeParameter, N);
      }
      return super.parseMaybeAssign(o, f);
    }
    parseArrow(o) {
      if (this.match(14)) {
        let f = this.tryParse(() => {
          let g = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let b = this.startNode();
          return [b.typeAnnotation, o.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = g, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), b;
        });
        if (f.thrown)
          return null;
        f.error && (this.state = f.failState), o.returnType = f.node.typeAnnotation ? this.finishNode(f.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(o);
    }
    shouldParseArrow(o) {
      return this.match(14) || super.shouldParseArrow(o);
    }
    setArrowFunctionParameters(o, f) {
      this.state.noArrowParamsConversionAt.indexOf(o.start) !== -1 ? o.params = f : super.setArrowFunctionParameters(o, f);
    }
    checkParams(o, f, g, b = !0) {
      if (!(g && this.state.noArrowParamsConversionAt.indexOf(o.start) !== -1)) {
        for (let E = 0; E < o.params.length; E++)
          this.isThisParam(o.params[E]) && E > 0 && this.raise(xe.ThisParamMustBeFirst, o.params[E]);
        super.checkParams(o, f, g, b);
      }
    }
    parseParenAndDistinguishExpression(o) {
      return super.parseParenAndDistinguishExpression(o && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(o, f, g) {
      if (o.type === "Identifier" && o.name === "async" && this.state.noArrowAt.indexOf(f.index) !== -1) {
        this.next();
        let b = this.startNodeAt(f);
        b.callee = o, b.arguments = super.parseCallExpressionArguments(11, !1), o = this.finishNode(b, "CallExpression");
      } else if (o.type === "Identifier" && o.name === "async" && this.match(47)) {
        let b = this.state.clone(), E = this.tryParse((F) => this.parseAsyncArrowWithTypeParameters(f) || F(), b);
        if (!E.error && !E.aborted)
          return E.node;
        let T = this.tryParse(() => super.parseSubscripts(o, f, g), b);
        if (T.node && !T.error)
          return T.node;
        if (E.node)
          return this.state = E.failState, E.node;
        if (T.node)
          return this.state = T.failState, T.node;
        throw E.error || T.error;
      }
      return super.parseSubscripts(o, f, g);
    }
    parseSubscript(o, f, g, b) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (b.optionalChainMember = !0, g)
          return b.stop = !0, o;
        this.next();
        let E = this.startNodeAt(f);
        return E.callee = o, E.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), E.arguments = this.parseCallExpressionArguments(11, !1), E.optional = !0, this.finishCallExpression(E, !0);
      } else if (!g && this.shouldParseTypes() && this.match(47)) {
        let E = this.startNodeAt(f);
        E.callee = o;
        let T = this.tryParse(() => (E.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), E.arguments = super.parseCallExpressionArguments(11, !1), b.optionalChainMember && (E.optional = !1), this.finishCallExpression(E, b.optionalChainMember)));
        if (T.node)
          return T.error && (this.state = T.failState), T.node;
      }
      return super.parseSubscript(o, f, g, b);
    }
    parseNewCallee(o) {
      super.parseNewCallee(o);
      let f = null;
      this.shouldParseTypes() && this.match(47) && (f = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), o.typeArguments = f;
    }
    parseAsyncArrowWithTypeParameters(o) {
      let f = this.startNodeAt(o);
      if (this.parseFunctionParams(f, !1), !!this.parseArrow(f))
        return super.parseArrowExpression(f, void 0, !0);
    }
    readToken_mult_modulo(o) {
      let f = this.input.charCodeAt(this.state.pos + 1);
      if (o === 42 && f === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(o);
    }
    readToken_pipe_amp(o) {
      let f = this.input.charCodeAt(this.state.pos + 1);
      if (o === 124 && f === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(o);
    }
    parseTopLevel(o, f) {
      let g = super.parseTopLevel(o, f);
      return this.state.hasFlowComment && this.raise(xe.UnterminatedFlowComment, this.state.curPosition()), g;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(xe.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let o = this.skipFlowComment();
        o && (this.state.pos += o, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let { pos: o } = this.state, f = 2;
      for (; [32, 9].includes(this.input.charCodeAt(o + f)); )
        f++;
      let g = this.input.charCodeAt(f + o), b = this.input.charCodeAt(f + o + 1);
      return g === 58 && b === 58 ? f + 2 : this.input.slice(f + o, f + o + 12) === "flow-include" ? f + 12 : g === 58 && b !== 58 ? f : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(x.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(o, { enumName: f, memberName: g }) {
      this.raise(xe.EnumBooleanMemberNotInitialized, o, { memberName: g, enumName: f });
    }
    flowEnumErrorInvalidMemberInitializer(o, f) {
      return this.raise(f.explicitType ? f.explicitType === "symbol" ? xe.EnumInvalidMemberInitializerSymbolType : xe.EnumInvalidMemberInitializerPrimaryType : xe.EnumInvalidMemberInitializerUnknownType, o, f);
    }
    flowEnumErrorNumberMemberNotInitialized(o, f) {
      this.raise(xe.EnumNumberMemberNotInitialized, o, f);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(o, f) {
      this.raise(xe.EnumStringMemberInconsistentlyInitialized, o, f);
    }
    flowEnumMemberInit() {
      let o = this.state.startLoc, f = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 134: {
          let g = this.parseNumericLiteral(this.state.value);
          return f() ? { type: "number", loc: g.loc.start, value: g } : { type: "invalid", loc: o };
        }
        case 133: {
          let g = this.parseStringLiteral(this.state.value);
          return f() ? { type: "string", loc: g.loc.start, value: g } : { type: "invalid", loc: o };
        }
        case 85:
        case 86: {
          let g = this.parseBooleanLiteral(this.match(85));
          return f() ? { type: "boolean", loc: g.loc.start, value: g } : { type: "invalid", loc: o };
        }
        default:
          return { type: "invalid", loc: o };
      }
    }
    flowEnumMemberRaw() {
      let o = this.state.startLoc, f = this.parseIdentifier(!0), g = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: o };
      return { id: f, init: g };
    }
    flowEnumCheckExplicitTypeMismatch(o, f, g) {
      let { explicitType: b } = f;
      b !== null && b !== g && this.flowEnumErrorInvalidMemberInitializer(o, f);
    }
    flowEnumMembers({ enumName: o, explicitType: f }) {
      let g = /* @__PURE__ */ new Set(), b = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, E = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          E = !0;
          break;
        }
        let T = this.startNode(), { id: F, init: N } = this.flowEnumMemberRaw(), $ = F.name;
        if ($ === "")
          continue;
        /^[a-z]/.test($) && this.raise(xe.EnumInvalidMemberName, F, { memberName: $, suggestion: $[0].toUpperCase() + $.slice(1), enumName: o }), g.has($) && this.raise(xe.EnumDuplicateMemberName, F, { memberName: $, enumName: o }), g.add($);
        let U = { enumName: o, explicitType: f, memberName: $ };
        switch (T.id = F, N.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(N.loc, U, "boolean"), T.init = N.value, b.booleanMembers.push(this.finishNode(T, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(N.loc, U, "number"), T.init = N.value, b.numberMembers.push(this.finishNode(T, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(N.loc, U, "string"), T.init = N.value, b.stringMembers.push(this.finishNode(T, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(N.loc, U);
          case "none":
            switch (f) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(N.loc, U);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(N.loc, U);
                break;
              default:
                b.defaultedMembers.push(this.finishNode(T, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return { members: b, hasUnknownMembers: E };
    }
    flowEnumStringMembers(o, f, { enumName: g }) {
      if (o.length === 0)
        return f;
      if (f.length === 0)
        return o;
      if (f.length > o.length) {
        for (let b of o)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(b, { enumName: g });
        return f;
      } else {
        for (let b of f)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(b, { enumName: g });
        return o;
      }
    }
    flowEnumParseExplicitType({ enumName: o }) {
      if (!this.eatContextual(102))
        return null;
      if (!j(this.state.type))
        throw this.raise(xe.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: o });
      let { value: f } = this.state;
      return this.next(), f !== "boolean" && f !== "number" && f !== "string" && f !== "symbol" && this.raise(xe.EnumInvalidExplicitType, this.state.startLoc, { enumName: o, invalidEnumType: f }), f;
    }
    flowEnumBody(o, f) {
      let g = f.name, b = f.loc.start, E = this.flowEnumParseExplicitType({ enumName: g });
      this.expect(5);
      let { members: T, hasUnknownMembers: F } = this.flowEnumMembers({ enumName: g, explicitType: E });
      switch (o.hasUnknownMembers = F, E) {
        case "boolean":
          return o.explicitType = !0, o.members = T.booleanMembers, this.expect(8), this.finishNode(o, "EnumBooleanBody");
        case "number":
          return o.explicitType = !0, o.members = T.numberMembers, this.expect(8), this.finishNode(o, "EnumNumberBody");
        case "string":
          return o.explicitType = !0, o.members = this.flowEnumStringMembers(T.stringMembers, T.defaultedMembers, { enumName: g }), this.expect(8), this.finishNode(o, "EnumStringBody");
        case "symbol":
          return o.members = T.defaultedMembers, this.expect(8), this.finishNode(o, "EnumSymbolBody");
        default: {
          let N = () => (o.members = [], this.expect(8), this.finishNode(o, "EnumStringBody"));
          o.explicitType = !1;
          let $ = T.booleanMembers.length, U = T.numberMembers.length, ie = T.stringMembers.length, ce = T.defaultedMembers.length;
          if (!$ && !U && !ie && !ce)
            return N();
          if (!$ && !U)
            return o.members = this.flowEnumStringMembers(T.stringMembers, T.defaultedMembers, { enumName: g }), this.expect(8), this.finishNode(o, "EnumStringBody");
          if (!U && !ie && $ >= ce) {
            for (let oe of T.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(oe.loc.start, { enumName: g, memberName: oe.id.name });
            return o.members = T.booleanMembers, this.expect(8), this.finishNode(o, "EnumBooleanBody");
          } else if (!$ && !ie && U >= ce) {
            for (let oe of T.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(oe.loc.start, { enumName: g, memberName: oe.id.name });
            return o.members = T.numberMembers, this.expect(8), this.finishNode(o, "EnumNumberBody");
          } else
            return this.raise(xe.EnumInconsistentMemberValues, b, { enumName: g }), N();
        }
      }
    }
    flowParseEnumDeclaration(o) {
      let f = this.parseIdentifier();
      return o.id = f, o.body = this.flowEnumBody(this.startNode(), f), this.finishNode(o, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let o = this.nextTokenStart();
      if (this.input.charCodeAt(o) === 60) {
        let f = this.input.charCodeAt(o + 1);
        return f !== 60 && f !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(o) {
      return o.type === "TypeCastExpression" ? o.expression : o;
    }
  }, Gn = w`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: c }) => `Expected corresponding JSX closing tag for <${c}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: c, HTMLEntity: o }) => `Unexpected token \`${c}\`. Did you mean \`${o}\` or \`{'${c}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
  function hn(c) {
    return c ? c.type === "JSXOpeningFragment" || c.type === "JSXClosingFragment" : !1;
  }
  function qs(c) {
    if (c.type === "JSXIdentifier")
      return c.name;
    if (c.type === "JSXNamespacedName")
      return c.namespace.name + ":" + c.name.name;
    if (c.type === "JSXMemberExpression")
      return qs(c.object) + "." + qs(c.property);
    throw new Error("Node had unexpected type: " + c.type);
  }
  var AA = (c) => class extends c {
    jsxReadToken() {
      let o = "", f = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Gn.UnterminatedJsxContent, this.state.startLoc);
        let g = this.input.charCodeAt(this.state.pos);
        switch (g) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              g === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(g);
              return;
            }
            o += this.input.slice(f, this.state.pos), this.finishToken(141, o);
            return;
          case 38:
            o += this.input.slice(f, this.state.pos), o += this.jsxReadEntity(), f = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            Ka(g) ? (o += this.input.slice(f, this.state.pos), o += this.jsxReadNewLine(!0), f = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(o) {
      let f = this.input.charCodeAt(this.state.pos), g;
      return ++this.state.pos, f === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, g = o ? `
` : `\r
`) : g = String.fromCharCode(f), ++this.state.curLine, this.state.lineStart = this.state.pos, g;
    }
    jsxReadString(o) {
      let f = "", g = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(x.UnterminatedString, this.state.startLoc);
        let b = this.input.charCodeAt(this.state.pos);
        if (b === o)
          break;
        b === 38 ? (f += this.input.slice(g, this.state.pos), f += this.jsxReadEntity(), g = this.state.pos) : Ka(b) ? (f += this.input.slice(g, this.state.pos), f += this.jsxReadNewLine(!1), g = this.state.pos) : ++this.state.pos;
      }
      f += this.input.slice(g, this.state.pos++), this.finishToken(133, f);
    }
    jsxReadEntity() {
      let o = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let f = 10;
        this.codePointAtPos(this.state.pos) === 120 && (f = 16, ++this.state.pos);
        let g = this.readInt(f, void 0, !1, "bail");
        if (g !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(g);
      } else {
        let f = 0, g = !1;
        for (; f++ < 10 && this.state.pos < this.length && !(g = this.codePointAtPos(this.state.pos) == 59); )
          ++this.state.pos;
        if (g) {
          this.input.slice(o, this.state.pos);
          let b;
          ++this.state.pos;
        }
      }
      return this.state.pos = o, "&";
    }
    jsxReadWord() {
      let o, f = this.state.pos;
      do
        o = this.input.charCodeAt(++this.state.pos);
      while ($e(o) || o === 45);
      this.finishToken(140, this.input.slice(f, this.state.pos));
    }
    jsxParseIdentifier() {
      let o = this.startNode();
      return this.match(140) ? o.name = this.state.value : ur(this.state.type) ? o.name = ui(this.state.type) : this.unexpected(), this.next(), this.finishNode(o, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let o = this.state.startLoc, f = this.jsxParseIdentifier();
      if (!this.eat(14))
        return f;
      let g = this.startNodeAt(o);
      return g.namespace = f, g.name = this.jsxParseIdentifier(), this.finishNode(g, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let o = this.state.startLoc, f = this.jsxParseNamespacedName();
      if (f.type === "JSXNamespacedName")
        return f;
      for (; this.eat(16); ) {
        let g = this.startNodeAt(o);
        g.object = f, g.property = this.jsxParseIdentifier(), f = this.finishNode(g, "JSXMemberExpression");
      }
      return f;
    }
    jsxParseAttributeValue() {
      let o;
      switch (this.state.type) {
        case 5:
          return o = this.startNode(), this.setContext(I.brace), this.next(), o = this.jsxParseExpressionContainer(o, I.j_oTag), o.expression.type === "JSXEmptyExpression" && this.raise(Gn.AttributeIsEmpty, o), o;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(Gn.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let o = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(o, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(o) {
      return this.next(), o.expression = this.parseExpression(), this.setContext(I.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(o, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(o, f) {
      if (this.match(8))
        o.expression = this.jsxParseEmptyExpression();
      else {
        let g = this.parseExpression();
        o.expression = g;
      }
      return this.setContext(f), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(o, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let o = this.startNode();
      return this.match(5) ? (this.setContext(I.brace), this.next(), this.expect(21), o.argument = this.parseMaybeAssignAllowIn(), this.setContext(I.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(o, "JSXSpreadAttribute")) : (o.name = this.jsxParseNamespacedName(), o.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(o, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(o) {
      let f = this.startNodeAt(o);
      return this.eat(143) ? this.finishNode(f, "JSXOpeningFragment") : (f.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(f));
    }
    jsxParseOpeningElementAfterName(o) {
      let f = [];
      for (; !this.match(56) && !this.match(143); )
        f.push(this.jsxParseAttribute());
      return o.attributes = f, o.selfClosing = this.eat(56), this.expect(143), this.finishNode(o, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(o) {
      let f = this.startNodeAt(o);
      return this.eat(143) ? this.finishNode(f, "JSXClosingFragment") : (f.name = this.jsxParseElementName(), this.expect(143), this.finishNode(f, "JSXClosingElement"));
    }
    jsxParseElementAt(o) {
      let f = this.startNodeAt(o), g = [], b = this.jsxParseOpeningElementAt(o), E = null;
      if (!b.selfClosing) {
        e:
          for (; ; )
            switch (this.state.type) {
              case 142:
                if (o = this.state.startLoc, this.next(), this.eat(56)) {
                  E = this.jsxParseClosingElementAt(o);
                  break e;
                }
                g.push(this.jsxParseElementAt(o));
                break;
              case 141:
                g.push(this.parseExprAtom());
                break;
              case 5: {
                let T = this.startNode();
                this.setContext(I.brace), this.next(), this.match(21) ? g.push(this.jsxParseSpreadChild(T)) : g.push(this.jsxParseExpressionContainer(T, I.j_expr));
                break;
              }
              default:
                this.unexpected();
            }
        hn(b) && !hn(E) && E !== null ? this.raise(Gn.MissingClosingTagFragment, E) : !hn(b) && hn(E) ? this.raise(Gn.MissingClosingTagElement, E, { openingTagName: qs(b.name) }) : !hn(b) && !hn(E) && qs(E.name) !== qs(b.name) && this.raise(Gn.MissingClosingTagElement, E, { openingTagName: qs(b.name) });
      }
      if (hn(b) ? (f.openingFragment = b, f.closingFragment = E) : (f.openingElement = b, f.closingElement = E), f.children = g, this.match(47))
        throw this.raise(Gn.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return hn(b) ? this.finishNode(f, "JSXFragment") : this.finishNode(f, "JSXElement");
    }
    jsxParseElement() {
      let o = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(o);
    }
    setContext(o) {
      let { context: f } = this.state;
      f[f.length - 1] = o;
    }
    parseExprAtom(o) {
      return this.match(141) ? this.parseLiteral(this.state.value, "JSXText") : this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(o);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(o) {
      let f = this.curContext();
      if (f === I.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (f === I.j_oTag || f === I.j_cTag) {
        if (Ne(o)) {
          this.jsxReadWord();
          return;
        }
        if (o === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((o === 34 || o === 39) && f === I.j_oTag) {
          this.jsxReadString(o);
          return;
        }
      }
      if (o === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(o);
    }
    updateContext(o) {
      let { context: f, type: g } = this.state;
      if (g === 56 && o === 142)
        f.splice(-2, 2, I.j_cTag), this.state.canStartJSXElement = !1;
      else if (g === 142)
        f.push(I.j_oTag);
      else if (g === 143) {
        let b = f[f.length - 1];
        b === I.j_oTag && o === 56 || b === I.j_cTag ? (f.pop(), this.state.canStartJSXElement = f[f.length - 1] === I.j_expr) : (this.setContext(I.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = Jt(g);
    }
  }, kA = class extends zh {
    constructor(...c) {
      super(...c), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, TA = class extends Gh {
    constructor(...c) {
      super(...c), this.importsStack = [];
    }
    createScope(c) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new kA(c);
    }
    enter(c) {
      c == 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(c);
    }
    exit() {
      let c = super.exit();
      return c == 256 && this.importsStack.pop(), c;
    }
    hasImport(c, o) {
      let f = this.importsStack.length;
      if (this.importsStack[f - 1].has(c))
        return !0;
      if (!o && f > 1) {
        for (let g = 0; g < f - 1; g++)
          if (this.importsStack[g].has(c))
            return !0;
      }
      return !1;
    }
    declareName(c, o, f) {
      if (o & 4096) {
        this.hasImport(c, !0) && this.parser.raise(x.VarRedeclaration, f, { identifierName: c }), this.importsStack[this.importsStack.length - 1].add(c);
        return;
      }
      let g = this.currentScope(), b = g.tsNames.get(c) || 0;
      if (o & 1024) {
        this.maybeExportDefined(g, c), g.tsNames.set(c, b | 16);
        return;
      }
      super.declareName(c, o, f), o & 2 && (o & 1 || (this.checkRedeclarationInScope(g, c, o, f), this.maybeExportDefined(g, c)), b = b | 1), o & 256 && (b = b | 2), o & 512 && (b = b | 4), o & 128 && (b = b | 8), b && g.tsNames.set(c, b);
    }
    isRedeclaredInScope(c, o, f) {
      let g = c.tsNames.get(o);
      if ((g & 2) > 0) {
        if (f & 256) {
          let b = !!(f & 512), E = (g & 4) > 0;
          return b !== E;
        }
        return !0;
      }
      return f & 128 && (g & 8) > 0 ? c.names.get(o) & 2 ? !!(f & 1) : !1 : f & 2 && (g & 1) > 0 ? !0 : super.isRedeclaredInScope(c, o, f);
    }
    checkLocalExport(c) {
      let { name: o } = c;
      if (this.hasImport(o))
        return;
      let f = this.scopeStack.length;
      for (let g = f - 1; g >= 0; g--) {
        let b = this.scopeStack[g].tsNames.get(o);
        if ((b & 1) > 0 || (b & 16) > 0)
          return;
      }
      super.checkLocalExport(c);
    }
  }, PA = (c, o) => Object.hasOwnProperty.call(c, o) && c[o], Dy = (c) => c.type === "ParenthesizedExpression" ? Dy(c.expression) : c, FA = class extends DA {
    toAssignable(c, o = !1) {
      var f, g;
      let b;
      switch ((c.type === "ParenthesizedExpression" || (f = c.extra) != null && f.parenthesized) && (b = Dy(c), o ? b.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(x.InvalidParenthesizedAssignment, c) : b.type !== "MemberExpression" && !this.isOptionalMemberExpression(b) && this.raise(x.InvalidParenthesizedAssignment, c) : this.raise(x.InvalidParenthesizedAssignment, c)), c.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          c.type = "ObjectPattern";
          for (let T = 0, F = c.properties.length, N = F - 1; T < F; T++) {
            var E;
            let $ = c.properties[T], U = T === N;
            this.toAssignableObjectExpressionProp($, U, o), U && $.type === "RestElement" && (E = c.extra) != null && E.trailingCommaLoc && this.raise(x.RestTrailingComma, c.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let { key: T, value: F } = c;
          this.isPrivateName(T) && this.classScope.usePrivateName(this.getPrivateNameSV(T), T.loc.start), this.toAssignable(F, o);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          c.type = "ArrayPattern", this.toAssignableList(c.elements, (g = c.extra) == null ? void 0 : g.trailingCommaLoc, o);
          break;
        case "AssignmentExpression":
          c.operator !== "=" && this.raise(x.MissingEqInAssignment, c.left.loc.end), c.type = "AssignmentPattern", delete c.operator, this.toAssignable(c.left, o);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(b, o);
          break;
      }
    }
    toAssignableObjectExpressionProp(c, o, f) {
      if (c.type === "ObjectMethod")
        this.raise(c.kind === "get" || c.kind === "set" ? x.PatternHasAccessor : x.PatternHasMethod, c.key);
      else if (c.type === "SpreadElement") {
        c.type = "RestElement";
        let g = c.argument;
        this.checkToRestConversion(g, !1), this.toAssignable(g, f), o || this.raise(x.RestTrailingComma, c);
      } else
        this.toAssignable(c, f);
    }
    toAssignableList(c, o, f) {
      let g = c.length - 1;
      for (let b = 0; b <= g; b++) {
        let E = c[b];
        if (E) {
          if (E.type === "SpreadElement") {
            E.type = "RestElement";
            let T = E.argument;
            this.checkToRestConversion(T, !0), this.toAssignable(T, f);
          } else
            this.toAssignable(E, f);
          E.type === "RestElement" && (b < g ? this.raise(x.RestTrailingComma, E) : o && this.raise(x.RestTrailingComma, o));
        }
      }
    }
    isAssignable(c, o) {
      switch (c.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let f = c.properties.length - 1;
          return c.properties.every((g, b) => g.type !== "ObjectMethod" && (b === f || g.type !== "SpreadElement") && this.isAssignable(g));
        }
        case "ObjectProperty":
          return this.isAssignable(c.value);
        case "SpreadElement":
          return this.isAssignable(c.argument);
        case "ArrayExpression":
          return c.elements.every((f) => f === null || this.isAssignable(f));
        case "AssignmentExpression":
          return c.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(c.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !o;
        default:
          return !1;
      }
    }
    toReferencedList(c, o) {
      return c;
    }
    toReferencedListDeep(c, o) {
      this.toReferencedList(c, o);
      for (let f of c)
        (f == null ? void 0 : f.type) === "ArrayExpression" && this.toReferencedListDeep(f.elements);
    }
    parseSpread(c) {
      let o = this.startNode();
      return this.next(), o.argument = this.parseMaybeAssignAllowIn(c, void 0), this.finishNode(o, "SpreadElement");
    }
    parseRestBinding() {
      let c = this.startNode();
      return this.next(), c.argument = this.parseBindingAtom(), this.finishNode(c, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let c = this.startNode();
          return this.next(), c.elements = this.parseBindingList(3, 93, 1), this.finishNode(c, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(c, o, f) {
      let g = f & 1, b = [], E = !0;
      for (; !this.eat(c); )
        if (E ? E = !1 : this.expect(12), g && this.match(12))
          b.push(null);
        else {
          if (this.eat(c))
            break;
          if (this.match(21)) {
            if (b.push(this.parseAssignableListItemTypes(this.parseRestBinding(), f)), !this.checkCommaAfterRest(o)) {
              this.expect(c);
              break;
            }
          } else {
            let T = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(x.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
              T.push(this.parseDecorator());
            b.push(this.parseAssignableListItem(f, T));
          }
        }
      return b;
    }
    parseBindingRestProperty(c) {
      return this.next(), c.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(c, "RestElement");
    }
    parseBindingProperty() {
      let c = this.startNode(), { type: o, startLoc: f } = this.state;
      return o === 21 ? this.parseBindingRestProperty(c) : (o === 138 ? (this.expectPlugin("destructuringPrivate", f), this.classScope.usePrivateName(this.state.value, f), c.key = this.parsePrivateName()) : this.parsePropertyName(c), c.method = !1, this.parseObjPropValue(c, f, !1, !1, !0, !1));
    }
    parseAssignableListItem(c, o) {
      let f = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(f, c);
      let g = this.parseMaybeDefault(f.loc.start, f);
      return o.length && (f.decorators = o), g;
    }
    parseAssignableListItemTypes(c, o) {
      return c;
    }
    parseMaybeDefault(c, o) {
      var f;
      if (c != null || (c = this.state.startLoc), o = (f = o) != null ? f : this.parseBindingAtom(), !this.eat(29))
        return o;
      let g = this.startNodeAt(c);
      return g.left = o, g.right = this.parseMaybeAssignAllowIn(), this.finishNode(g, "AssignmentPattern");
    }
    isValidLVal(c, o, f) {
      return PA({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, c);
    }
    isOptionalMemberExpression(c) {
      return c.type === "OptionalMemberExpression";
    }
    checkLVal(c, { in: o, binding: f = 64, checkClashes: g = !1, strictModeChanged: b = !1, hasParenthesizedAncestor: E = !1 }) {
      var T;
      let F = c.type;
      if (this.isObjectMethod(c))
        return;
      let N = this.isOptionalMemberExpression(c);
      if (N || F === "MemberExpression") {
        N && (this.expectPlugin("optionalChainingAssign", c.loc.start), o.type !== "AssignmentExpression" && this.raise(x.InvalidLhsOptionalChaining, c, { ancestor: o })), f !== 64 && this.raise(x.InvalidPropertyBindingPattern, c);
        return;
      }
      if (F === "Identifier") {
        this.checkIdentifier(c, f, b);
        let { name: oe } = c;
        g && (g.has(oe) ? this.raise(x.ParamDupe, c) : g.add(oe));
        return;
      }
      let $ = this.isValidLVal(F, !(E || (T = c.extra) != null && T.parenthesized) && o.type === "AssignmentExpression", f);
      if ($ === !0)
        return;
      if ($ === !1) {
        let oe = f === 64 ? x.InvalidLhs : x.InvalidLhsBinding;
        this.raise(oe, c, { ancestor: o });
        return;
      }
      let [U, ie] = Array.isArray($) ? $ : [$, F === "ParenthesizedExpression"], ce = F === "ArrayPattern" || F === "ObjectPattern" ? { type: F } : o;
      for (let oe of [].concat(c[U]))
        oe && this.checkLVal(oe, { in: ce, binding: f, checkClashes: g, strictModeChanged: b, hasParenthesizedAncestor: ie });
    }
    checkIdentifier(c, o, f = !1) {
      this.state.strict && (f ? uy(c.name, this.inModule) : ly(c.name)) && (o === 64 ? this.raise(x.StrictEvalArguments, c, { referenceName: c.name }) : this.raise(x.StrictEvalArgumentsBinding, c, { bindingName: c.name })), o & 8192 && c.name === "let" && this.raise(x.LetInLexicalBinding, c), o & 64 || this.declareNameFromIdentifier(c, o);
    }
    declareNameFromIdentifier(c, o) {
      this.scope.declareName(c.name, o, c.loc.start);
    }
    checkToRestConversion(c, o) {
      switch (c.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(c.expression, o);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (o)
            break;
        default:
          this.raise(x.InvalidRestAssignmentPattern, c);
      }
    }
    checkCommaAfterRest(c) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === c ? x.RestTrailingComma : x.ElementAfterRest, this.state.startLoc), !0) : !1;
    }
  }, $A = (c, o) => Object.hasOwnProperty.call(c, o) && c[o];
  function BA(c) {
    if (c == null)
      throw new Error(`Unexpected ${c} value.`);
    return c;
  }
  function by(c) {
    if (!c)
      throw new Error("Assert fail");
  }
  var me = w`typescript`({ AbstractMethodHasImplementation: ({ methodName: c }) => `Method '${c}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: c }) => `Property '${c}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: c }) => `'declare' is not allowed in ${c}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: c }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier: c }) => `Duplicate modifier: '${c}'.`, EmptyHeritageClauseType: ({ token: c }) => `'${c}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: c }) => `'${c[0]}' modifier cannot be used with '${c[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: c }) => `Index signatures cannot have an accessibility modifier ('${c}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier: c }) => `'${c}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: c }) => `'${c}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: c }) => `'${c}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: c }) => `'${c[0]}' modifier must precede '${c[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: c }) => `Private elements cannot have an accessibility modifier ('${c}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: c }) => `Single type parameter ${c} should have a trailing comma. Example usage: <${c},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: c }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${c}.` });
  function IA(c) {
    switch (c) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  function vy(c) {
    return c === "private" || c === "public" || c === "protected";
  }
  function NA(c) {
    return c === "in" || c === "out";
  }
  var _A = (c) => class extends c {
    constructor(...o) {
      super(...o), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: me.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: me.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: me.InvalidModifierOnTypeParameter });
    }
    getScopeHandler() {
      return TA;
    }
    tsIsIdentifier() {
      return j(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(o, f) {
      if (!j(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let g = this.state.value;
      if (o.indexOf(g) !== -1) {
        if (f && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return g;
      }
    }
    tsParseModifiers({ allowedModifiers: o, disallowedModifiers: f, stopOnStartOfClassStaticBlock: g, errorTemplate: b = me.InvalidModifierOnTypeMember }, E) {
      let T = (N, $, U, ie) => {
        $ === U && E[ie] && this.raise(me.InvalidModifiersOrder, N, { orderedModifiers: [U, ie] });
      }, F = (N, $, U, ie) => {
        (E[U] && $ === ie || E[ie] && $ === U) && this.raise(me.IncompatibleModifiers, N, { modifiers: [U, ie] });
      };
      for (; ; ) {
        let { startLoc: N } = this.state, $ = this.tsParseModifier(o.concat(f ?? []), g);
        if (!$)
          break;
        vy($) ? E.accessibility ? this.raise(me.DuplicateAccessibilityModifier, N, { modifier: $ }) : (T(N, $, $, "override"), T(N, $, $, "static"), T(N, $, $, "readonly"), E.accessibility = $) : NA($) ? (E[$] && this.raise(me.DuplicateModifier, N, { modifier: $ }), E[$] = !0, T(N, $, "in", "out")) : (Object.hasOwnProperty.call(E, $) ? this.raise(me.DuplicateModifier, N, { modifier: $ }) : (T(N, $, "static", "readonly"), T(N, $, "static", "override"), T(N, $, "override", "readonly"), T(N, $, "abstract", "override"), F(N, $, "declare", "override"), F(N, $, "static", "abstract")), E[$] = !0), f != null && f.includes($) && this.raise(b, N, { modifier: $ });
      }
    }
    tsIsListTerminator(o) {
      switch (o) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(o, f) {
      let g = [];
      for (; !this.tsIsListTerminator(o); )
        g.push(f());
      return g;
    }
    tsParseDelimitedList(o, f, g) {
      return BA(this.tsParseDelimitedListWorker(o, f, !0, g));
    }
    tsParseDelimitedListWorker(o, f, g, b) {
      let E = [], T = -1;
      for (; !this.tsIsListTerminator(o); ) {
        T = -1;
        let F = f();
        if (F == null)
          return;
        if (E.push(F), this.eat(12)) {
          T = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(o))
          break;
        g && this.expect(12);
        return;
      }
      return b && (b.value = T), E;
    }
    tsParseBracketedList(o, f, g, b, E) {
      b || (g ? this.expect(0) : this.expect(47));
      let T = this.tsParseDelimitedList(o, f, E);
      return g ? this.expect(3) : this.expect(48), T;
    }
    tsParseImportType() {
      let o = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(me.UnsupportedImportTypeArgument, this.state.startLoc), o.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (o.qualifier = this.tsParseEntityName()), this.match(47) && (o.typeParameters = this.tsParseTypeArguments()), this.finishNode(o, "TSImportType");
    }
    tsParseEntityName(o = !0) {
      let f = this.parseIdentifier(o);
      for (; this.eat(16); ) {
        let g = this.startNodeAtNode(f);
        g.left = f, g.right = this.parseIdentifier(o), f = this.finishNode(g, "TSQualifiedName");
      }
      return f;
    }
    tsParseTypeReference() {
      let o = this.startNode();
      return o.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (o.typeParameters = this.tsParseTypeArguments()), this.finishNode(o, "TSTypeReference");
    }
    tsParseThisTypePredicate(o) {
      this.next();
      let f = this.startNodeAtNode(o);
      return f.parameterName = o, f.typeAnnotation = this.tsParseTypeAnnotation(!1), f.asserts = !1, this.finishNode(f, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let o = this.startNode();
      return this.next(), this.finishNode(o, "TSThisType");
    }
    tsParseTypeQuery() {
      let o = this.startNode();
      return this.expect(87), this.match(83) ? o.exprName = this.tsParseImportType() : o.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (o.typeParameters = this.tsParseTypeArguments()), this.finishNode(o, "TSTypeQuery");
    }
    tsParseTypeParameter(o) {
      let f = this.startNode();
      return o(f), f.name = this.tsParseTypeParameterName(), f.constraint = this.tsEatThenParseType(81), f.default = this.tsEatThenParseType(29), this.finishNode(f, "TSTypeParameter");
    }
    tsTryParseTypeParameters(o) {
      if (this.match(47))
        return this.tsParseTypeParameters(o);
    }
    tsParseTypeParameters(o) {
      let f = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let g = { value: -1 };
      return f.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, o), !1, !0, g), f.params.length === 0 && this.raise(me.EmptyTypeParameters, f), g.value !== -1 && this.addExtra(f, "trailingComma", g.value), this.finishNode(f, "TSTypeParameterDeclaration");
    }
    tsFillSignature(o, f) {
      let g = o === 19, b = "parameters", E = "typeAnnotation";
      f.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), f[b] = this.tsParseBindingListForSignature(), g ? f[E] = this.tsParseTypeOrTypePredicateAnnotation(o) : this.match(o) && (f[E] = this.tsParseTypeOrTypePredicateAnnotation(o));
    }
    tsParseBindingListForSignature() {
      let o = super.parseBindingList(11, 41, 2);
      for (let f of o) {
        let { type: g } = f;
        (g === "AssignmentPattern" || g === "TSParameterProperty") && this.raise(me.UnsupportedSignatureParameterKind, f, { type: g });
      }
      return o;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(o, f) {
      return this.tsFillSignature(14, f), this.tsParseTypeMemberSemicolon(), this.finishNode(f, o);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), j(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(o) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let f = this.parseIdentifier();
      f.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(f), this.expect(3), o.parameters = [f];
      let g = this.tsTryParseTypeAnnotation();
      return g && (o.typeAnnotation = g), this.tsParseTypeMemberSemicolon(), this.finishNode(o, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(o, f) {
      this.eat(17) && (o.optional = !0);
      let g = o;
      if (this.match(10) || this.match(47)) {
        f && this.raise(me.ReadonlyForMethodSignature, o);
        let b = g;
        b.kind && this.match(47) && this.raise(me.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, b), this.tsParseTypeMemberSemicolon();
        let E = "parameters", T = "typeAnnotation";
        if (b.kind === "get")
          b[E].length > 0 && (this.raise(x.BadGetterArity, this.state.curPosition()), this.isThisParam(b[E][0]) && this.raise(me.AccesorCannotDeclareThisParameter, this.state.curPosition()));
        else if (b.kind === "set") {
          if (b[E].length !== 1)
            this.raise(x.BadSetterArity, this.state.curPosition());
          else {
            let F = b[E][0];
            this.isThisParam(F) && this.raise(me.AccesorCannotDeclareThisParameter, this.state.curPosition()), F.type === "Identifier" && F.optional && this.raise(me.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), F.type === "RestElement" && this.raise(me.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          b[T] && this.raise(me.SetAccesorCannotHaveReturnType, b[T]);
        } else
          b.kind = "method";
        return this.finishNode(b, "TSMethodSignature");
      } else {
        let b = g;
        f && (b.readonly = !0);
        let E = this.tsTryParseTypeAnnotation();
        return E && (b.typeAnnotation = E), this.tsParseTypeMemberSemicolon(), this.finishNode(b, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let o = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", o);
      if (this.match(77)) {
        let g = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", o) : (o.key = this.createIdentifier(g, "new"), this.tsParsePropertyOrMethodSignature(o, !1));
      }
      return this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, o), this.tsTryParseIndexSignature(o) || (super.parsePropertyName(o), !o.computed && o.key.type === "Identifier" && (o.key.name === "get" || o.key.name === "set") && this.tsTokenCanFollowModifier() && (o.kind = o.key.name, super.parsePropertyName(o)), this.tsParsePropertyOrMethodSignature(o, !!o.readonly));
    }
    tsParseTypeLiteral() {
      let o = this.startNode();
      return o.members = this.tsParseObjectTypeMembers(), this.finishNode(o, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let o = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), o;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let o = this.startNode();
      return o.name = this.tsParseTypeParameterName(), o.constraint = this.tsExpectThenParseType(58), this.finishNode(o, "TSTypeParameter");
    }
    tsParseMappedType() {
      let o = this.startNode();
      return this.expect(5), this.match(53) ? (o.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (o.readonly = !0), this.expect(0), o.typeParameter = this.tsParseMappedTypeParameter(), o.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (o.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (o.optional = !0), o.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(o, "TSMappedType");
    }
    tsParseTupleType() {
      let o = this.startNode();
      o.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let f = !1;
      return o.elementTypes.forEach((g) => {
        let { type: b } = g;
        f && b !== "TSRestType" && b !== "TSOptionalType" && !(b === "TSNamedTupleMember" && g.optional) && this.raise(me.OptionalTypeBeforeRequired, g), f || (f = b === "TSNamedTupleMember" && g.optional || b === "TSOptionalType");
      }), this.finishNode(o, "TSTupleType");
    }
    tsParseTupleElementType() {
      let { startLoc: o } = this.state, f = this.eat(21), g, b, E, T, F = De(this.state.type) ? this.lookaheadCharCode() : null;
      if (F === 58)
        g = !0, E = !1, b = this.parseIdentifier(!0), this.expect(14), T = this.tsParseType();
      else if (F === 63) {
        E = !0;
        let N = this.state.startLoc, $ = this.state.value, U = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (g = !0, b = this.createIdentifier(this.startNodeAt(N), $), this.expect(17), this.expect(14), T = this.tsParseType()) : (g = !1, T = U, this.expect(17));
      } else
        T = this.tsParseType(), E = this.eat(17), g = this.eat(14);
      if (g) {
        let N;
        b ? (N = this.startNodeAtNode(b), N.optional = E, N.label = b, N.elementType = T, this.eat(17) && (N.optional = !0, this.raise(me.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (N = this.startNodeAtNode(T), N.optional = E, this.raise(me.InvalidTupleMemberLabel, T), N.label = T, N.elementType = this.tsParseType()), T = this.finishNode(N, "TSNamedTupleMember");
      } else if (E) {
        let N = this.startNodeAtNode(T);
        N.typeAnnotation = T, T = this.finishNode(N, "TSOptionalType");
      }
      if (f) {
        let N = this.startNodeAt(o);
        N.typeAnnotation = T, T = this.finishNode(N, "TSRestType");
      }
      return T;
    }
    tsParseParenthesizedType() {
      let o = this.startNode();
      return this.expect(10), o.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(o, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(o, f) {
      let g = this.startNode();
      return o === "TSConstructorType" && (g.abstract = !!f, f && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, g)), this.finishNode(g, o);
    }
    tsParseLiteralTypeNode() {
      let o = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          o.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(o, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let o = this.startNode();
      return o.literal = super.parseTemplate(!1), this.finishNode(o, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let o = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(o) : o;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let o = this.startNode(), f = this.lookahead();
            return f.type !== 134 && f.type !== 135 && this.unexpected(), o.literal = this.parseMaybeUnary(), this.finishNode(o, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let { type: o } = this.state;
          if (j(o) || o === 88 || o === 84) {
            let f = o === 88 ? "TSVoidKeyword" : o === 84 ? "TSNullKeyword" : IA(this.state.value);
            if (f !== void 0 && this.lookaheadCharCode() !== 46) {
              let g = this.startNode();
              return this.next(), this.finishNode(g, f);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let o = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let f = this.startNodeAtNode(o);
          f.elementType = o, this.expect(3), o = this.finishNode(f, "TSArrayType");
        } else {
          let f = this.startNodeAtNode(o);
          f.objectType = o, f.indexType = this.tsParseType(), this.expect(3), o = this.finishNode(f, "TSIndexedAccessType");
        }
      return o;
    }
    tsParseTypeOperator() {
      let o = this.startNode(), f = this.state.value;
      return this.next(), o.operator = f, o.typeAnnotation = this.tsParseTypeOperatorOrHigher(), f === "readonly" && this.tsCheckTypeAnnotationForReadOnly(o), this.finishNode(o, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(o) {
      switch (o.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(me.UnexpectedReadonly, o);
      }
    }
    tsParseInferType() {
      let o = this.startNode();
      this.expectContextual(115);
      let f = this.startNode();
      return f.name = this.tsParseTypeParameterName(), f.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), o.typeParameter = this.finishNode(f, "TSTypeParameter"), this.finishNode(o, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let o = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return o;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return Qi(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(o, f, g) {
      let b = this.startNode(), E = this.eat(g), T = [];
      do
        T.push(f());
      while (this.eat(g));
      return T.length === 1 && !E ? T[0] : (b.types = T, this.finishNode(b, o));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (j(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let { errors: o } = this.state, f = o.length;
        try {
          return this.parseObjectLike(8, !0), o.length === f;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let { errors: o } = this.state, f = o.length;
        try {
          return super.parseBindingList(3, 93, 1), o.length === f;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(o) {
      return this.tsInType(() => {
        let f = this.startNode();
        this.expect(o);
        let g = this.startNode(), b = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (b && this.match(78)) {
          let F = this.tsParseThisTypeOrThisTypePredicate();
          return F.type === "TSThisType" ? (g.parameterName = F, g.asserts = !0, g.typeAnnotation = null, F = this.finishNode(g, "TSTypePredicate")) : (this.resetStartLocationFromNode(F, g), F.asserts = !0), f.typeAnnotation = F, this.finishNode(f, "TSTypeAnnotation");
        }
        let E = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!E)
          return b ? (g.parameterName = this.parseIdentifier(), g.asserts = b, g.typeAnnotation = null, f.typeAnnotation = this.finishNode(g, "TSTypePredicate"), this.finishNode(f, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, f);
        let T = this.tsParseTypeAnnotation(!1);
        return g.parameterName = E, g.typeAnnotation = T, g.asserts = b, f.typeAnnotation = this.finishNode(g, "TSTypePredicate"), this.finishNode(f, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let o = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), o;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let o = this.state.containsEsc;
      return this.next(), !j(this.state.type) && !this.match(78) ? !1 : (o && this.raise(x.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), !0);
    }
    tsParseTypeAnnotation(o = !0, f = this.startNode()) {
      return this.tsInType(() => {
        o && this.expect(14), f.typeAnnotation = this.tsParseType();
      }), this.finishNode(f, "TSTypeAnnotation");
    }
    tsParseType() {
      by(this.state.inType);
      let o = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return o;
      let f = this.startNodeAtNode(o);
      return f.checkType = o, f.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), f.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), f.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(f, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(me.ReservedTypeAssertion, this.state.startLoc);
      let o = this.startNode();
      return o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), o.expression = this.parseMaybeUnary(), this.finishNode(o, "TSTypeAssertion");
    }
    tsParseHeritageClause(o) {
      let f = this.state.startLoc, g = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let b = this.startNode();
        return b.expression = this.tsParseEntityName(), this.match(47) && (b.typeParameters = this.tsParseTypeArguments()), this.finishNode(b, "TSExpressionWithTypeArguments");
      });
      return g.length || this.raise(me.EmptyHeritageClauseType, f, { token: o }), g;
    }
    tsParseInterfaceDeclaration(o, f = {}) {
      if (this.hasFollowingLineBreak())
        return null;
      this.expectContextual(129), f.declare && (o.declare = !0), j(this.state.type) ? (o.id = this.parseIdentifier(), this.checkIdentifier(o.id, 130)) : (o.id = null, this.raise(me.MissingInterfaceName, this.state.startLoc)), o.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (o.extends = this.tsParseHeritageClause("extends"));
      let g = this.startNode();
      return g.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), o.body = this.finishNode(g, "TSInterfaceBody"), this.finishNode(o, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(o) {
      return o.id = this.parseIdentifier(), this.checkIdentifier(o.id, 2), o.typeAnnotation = this.tsInType(() => {
        if (o.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
          let f = this.startNode();
          return this.next(), this.finishNode(f, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(o, "TSTypeAliasDeclaration");
    }
    tsInNoContext(o) {
      let f = this.state.context;
      this.state.context = [f[0]];
      try {
        return o();
      } finally {
        this.state.context = f;
      }
    }
    tsInType(o) {
      let f = this.state.inType;
      this.state.inType = !0;
      try {
        return o();
      } finally {
        this.state.inType = f;
      }
    }
    tsInDisallowConditionalTypesContext(o) {
      let f = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return o();
      } finally {
        this.state.inDisallowConditionalTypesContext = f;
      }
    }
    tsInAllowConditionalTypesContext(o) {
      let f = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return o();
      } finally {
        this.state.inDisallowConditionalTypesContext = f;
      }
    }
    tsEatThenParseType(o) {
      if (this.match(o))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(o) {
      return this.tsInType(() => (this.expect(o), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let o = this.startNode();
      return o.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (o.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(o, "TSEnumMember");
    }
    tsParseEnumDeclaration(o, f = {}) {
      return f.const && (o.const = !0), f.declare && (o.declare = !0), this.expectContextual(126), o.id = this.parseIdentifier(), this.checkIdentifier(o.id, o.const ? 8971 : 8459), this.expect(5), o.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(o, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let o = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(o.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(o, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(o, f = !1) {
      if (o.id = this.parseIdentifier(), f || this.checkIdentifier(o.id, 1024), this.eat(16)) {
        let g = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(g, !0), o.body = g;
      } else
        this.scope.enter(256), this.prodParam.enter(0), o.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(o, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(o) {
      return this.isContextual(112) ? (o.global = !0, o.id = this.parseIdentifier()) : this.match(133) ? o.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), o.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(o, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(o, f, g) {
      o.isExport = g || !1, o.id = f || this.parseIdentifier(), this.checkIdentifier(o.id, 4096), this.expect(29);
      let b = this.tsParseModuleReference();
      return o.importKind === "type" && b.type !== "TSExternalModuleReference" && this.raise(me.ImportAliasHasImportType, b), o.moduleReference = b, this.semicolon(), this.finishNode(o, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      let o = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), o.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(o, "TSExternalModuleReference");
    }
    tsLookAhead(o) {
      let f = this.state.clone(), g = o();
      return this.state = f, g;
    }
    tsTryParseAndCatch(o) {
      let f = this.tryParse((g) => o() || g());
      if (!(f.aborted || !f.node))
        return f.error && (this.state = f.failState), f.node;
    }
    tsTryParse(o) {
      let f = this.state.clone(), g = o();
      if (g !== void 0 && g !== !1)
        return g;
      this.state = f;
    }
    tsTryParseDeclare(o) {
      if (this.isLineTerminator())
        return;
      let f = this.state.type, g;
      return this.isContextual(100) && (f = 74, g = "let"), this.tsInAmbientContext(() => {
        switch (f) {
          case 68:
            return o.declare = !0, super.parseFunctionStatement(o, !1, !1);
          case 80:
            return o.declare = !0, this.parseClass(o, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(o, { declare: !0 });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(o);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (o.declare = !0, this.parseVarStatement(o, g || this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(o, { const: !0, declare: !0 }));
          case 129: {
            let b = this.tsParseInterfaceDeclaration(o, { declare: !0 });
            if (b)
              return b;
          }
          default:
            if (j(f))
              return this.tsParseDeclaration(o, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(o, f, g) {
      switch (f.name) {
        case "declare": {
          let b = this.tsTryParseDeclare(o);
          return b && (b.declare = !0), b;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let b = o;
            return b.global = !0, b.id = f, b.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(b, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(o, f.name, !1, g);
      }
    }
    tsParseDeclaration(o, f, g, b) {
      switch (f) {
        case "abstract":
          if (this.tsCheckLineTerminator(g) && (this.match(80) || j(this.state.type)))
            return this.tsParseAbstractDeclaration(o, b);
          break;
        case "module":
          if (this.tsCheckLineTerminator(g)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(o);
            if (j(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(o);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(g) && j(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(o);
          break;
        case "type":
          if (this.tsCheckLineTerminator(g) && j(this.state.type))
            return this.tsParseTypeAliasDeclaration(o);
          break;
      }
    }
    tsCheckLineTerminator(o) {
      return o ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(o) {
      if (!this.match(47))
        return;
      let f = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let g = this.tsTryParseAndCatch(() => {
        let b = this.startNodeAt(o);
        return b.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(b), b.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), b;
      });
      if (this.state.maybeInArrowParameters = f, !!g)
        return super.parseArrowExpression(g, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let o = this.startNode();
      return o.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), o.params.length === 0 ? this.raise(me.EmptyTypeArguments, o) : !this.state.inType && this.curContext() === I.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(o, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return ji(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(o, f) {
      let g = this.state.startLoc, b = {};
      this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, b);
      let E = b.accessibility, T = b.override, F = b.readonly;
      !(o & 4) && (E || F || T) && this.raise(me.UnexpectedParameterModifier, g);
      let N = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(N, o);
      let $ = this.parseMaybeDefault(N.loc.start, N);
      if (E || F || T) {
        let U = this.startNodeAt(g);
        return f.length && (U.decorators = f), E && (U.accessibility = E), F && (U.readonly = F), T && (U.override = T), $.type !== "Identifier" && $.type !== "AssignmentPattern" && this.raise(me.UnsupportedParameterPropertyKind, U), U.parameter = $, this.finishNode(U, "TSParameterProperty");
      }
      return f.length && (N.decorators = f), $;
    }
    isSimpleParameter(o) {
      return o.type === "TSParameterProperty" && super.isSimpleParameter(o.parameter) || super.isSimpleParameter(o);
    }
    tsDisallowOptionalPattern(o) {
      for (let f of o.params)
        f.type !== "Identifier" && f.optional && !this.state.isAmbientContext && this.raise(me.PatternIsOptional, f);
    }
    setArrowFunctionParameters(o, f, g) {
      super.setArrowFunctionParameters(o, f, g), this.tsDisallowOptionalPattern(o);
    }
    parseFunctionBodyAndFinish(o, f, g = !1) {
      this.match(14) && (o.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let b = f === "FunctionDeclaration" ? "TSDeclareFunction" : f === "ClassMethod" || f === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return b && !this.match(5) && this.isLineTerminator() ? this.finishNode(o, b) : b === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(me.DeclareFunctionHasImplementation, o), o.declare) ? super.parseFunctionBodyAndFinish(o, b, g) : (this.tsDisallowOptionalPattern(o), super.parseFunctionBodyAndFinish(o, f, g));
    }
    registerFunctionStatementId(o) {
      !o.body && o.id ? this.checkIdentifier(o.id, 1024) : super.registerFunctionStatementId(o);
    }
    tsCheckForInvalidTypeCasts(o) {
      o.forEach((f) => {
        (f == null ? void 0 : f.type) === "TSTypeCastExpression" && this.raise(me.UnexpectedTypeAnnotation, f.typeAnnotation);
      });
    }
    toReferencedList(o, f) {
      return this.tsCheckForInvalidTypeCasts(o), o;
    }
    parseArrayLike(o, f, g, b) {
      let E = super.parseArrayLike(o, f, g, b);
      return E.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(E.elements), E;
    }
    parseSubscript(o, f, g, b) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let T = this.startNodeAt(f);
        return T.expression = o, this.finishNode(T, "TSNonNullExpression");
      }
      let E = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (g)
          return b.stop = !0, o;
        b.optionalChainMember = E = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let T, F = this.tsTryParseAndCatch(() => {
          if (!g && this.atPossibleAsyncArrow(o)) {
            let ie = this.tsTryParseGenericAsyncArrowFunction(f);
            if (ie)
              return ie;
          }
          let N = this.tsParseTypeArgumentsInExpression();
          if (!N)
            return;
          if (E && !this.match(10)) {
            T = this.state.curPosition();
            return;
          }
          if (Zs(this.state.type)) {
            let ie = super.parseTaggedTemplateExpression(o, f, b);
            return ie.typeParameters = N, ie;
          }
          if (!g && this.eat(10)) {
            let ie = this.startNodeAt(f);
            return ie.callee = o, ie.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(ie.arguments), ie.typeParameters = N, b.optionalChainMember && (ie.optional = E), this.finishCallExpression(ie, b.optionalChainMember);
          }
          let $ = this.state.type;
          if ($ === 48 || $ === 52 || $ !== 10 && Mt($) && !this.hasPrecedingLineBreak())
            return;
          let U = this.startNodeAt(f);
          return U.expression = o, U.typeParameters = N, this.finishNode(U, "TSInstantiationExpression");
        });
        if (T && this.unexpected(T, 10), F)
          return F.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(me.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), F;
      }
      return super.parseSubscript(o, f, g, b);
    }
    parseNewCallee(o) {
      var f;
      super.parseNewCallee(o);
      let { callee: g } = o;
      g.type === "TSInstantiationExpression" && !((f = g.extra) != null && f.parenthesized) && (o.typeParameters = g.typeParameters, o.callee = g.expression);
    }
    parseExprOp(o, f, g) {
      let b;
      if (Rs(58) > g && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (b = this.isContextual(120)))) {
        let E = this.startNodeAt(f);
        return E.expression = o, E.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (b && this.raise(x.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(E, b ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(E, f, g);
      }
      return super.parseExprOp(o, f, g);
    }
    checkReservedWord(o, f, g, b) {
      this.state.isAmbientContext || super.checkReservedWord(o, f, g, b);
    }
    checkImportReflection(o) {
      super.checkImportReflection(o), o.module && o.importKind !== "value" && this.raise(me.ImportReflectionHasImportType, o.specifiers[0].loc.start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(o) {
      if (super.isPotentialImportPhase(o))
        return !0;
      if (this.isContextual(130)) {
        let f = this.lookaheadCharCode();
        return o ? f === 123 || f === 42 : f !== 61;
      }
      return !o && this.isContextual(87);
    }
    applyImportPhase(o, f, g, b) {
      super.applyImportPhase(o, f, g, b), f ? o.exportKind = g === "type" ? "type" : "value" : o.importKind = g === "type" || g === "typeof" ? g : "value";
    }
    parseImport(o) {
      if (this.match(133))
        return o.importKind = "value", super.parseImport(o);
      let f;
      if (j(this.state.type) && this.lookaheadCharCode() === 61)
        return o.importKind = "value", this.tsParseImportEqualsDeclaration(o);
      if (this.isContextual(130)) {
        let g = this.parseMaybeImportPhase(o, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(o, g);
        f = super.parseImportSpecifiersAndAfter(o, g);
      } else
        f = super.parseImport(o);
      return f.importKind === "type" && f.specifiers.length > 1 && f.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(me.TypeImportCannotSpecifyDefaultAndNamed, f), f;
    }
    parseExport(o, f) {
      if (this.match(83)) {
        this.next();
        let g = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? g = this.parseMaybeImportPhase(o, !1) : o.importKind = "value", this.tsParseImportEqualsDeclaration(o, g, !0);
      } else if (this.eat(29)) {
        let g = o;
        return g.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(g, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let g = o;
        return this.expectContextual(128), g.id = this.parseIdentifier(), this.semicolon(), this.finishNode(g, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(o, f);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let o = this.startNode();
        return this.next(), o.abstract = !0, this.parseClass(o, !0, !0);
      }
      if (this.match(129)) {
        let o = this.tsParseInterfaceDeclaration(this.startNode());
        if (o)
          return o;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(o, f, g = !1) {
      let { isAmbientContext: b } = this.state, E = super.parseVarStatement(o, f, g || b);
      if (!b)
        return E;
      for (let { id: T, init: F } of E.declarations)
        F && (f !== "const" || T.typeAnnotation ? this.raise(me.InitializerNotAllowedInAmbientContext, F) : LA(F, this.hasPlugin("estree")) || this.raise(me.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, F));
      return E;
    }
    parseStatementContent(o, f) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let g = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(g, { const: !0 });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let g = this.tsParseInterfaceDeclaration(this.startNode());
        if (g)
          return g;
      }
      return super.parseStatementContent(o, f);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(o, f) {
      return f.some((g) => vy(g) ? o.accessibility === g : !!o[g]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(o, f, g) {
      let b = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({ allowedModifiers: b, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: !0, errorTemplate: me.InvalidModifierOnTypeParameterPositions }, f);
      let E = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(f, b) && this.raise(me.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(o, f)) : this.parseClassMemberWithIsStatic(o, f, g, !!f.static);
      };
      f.declare ? this.tsInAmbientContext(E) : E();
    }
    parseClassMemberWithIsStatic(o, f, g, b) {
      let E = this.tsTryParseIndexSignature(f);
      if (E) {
        o.body.push(E), f.abstract && this.raise(me.IndexSignatureHasAbstract, f), f.accessibility && this.raise(me.IndexSignatureHasAccessibility, f, { modifier: f.accessibility }), f.declare && this.raise(me.IndexSignatureHasDeclare, f), f.override && this.raise(me.IndexSignatureHasOverride, f);
        return;
      }
      !this.state.inAbstractClass && f.abstract && this.raise(me.NonAbstractClassHasAbstractMethod, f), f.override && (g.hadSuperClass || this.raise(me.OverrideNotInSubClass, f)), super.parseClassMemberWithIsStatic(o, f, g, b);
    }
    parsePostMemberNameModifiers(o) {
      this.eat(17) && (o.optional = !0), o.readonly && this.match(10) && this.raise(me.ClassMethodHasReadonly, o), o.declare && this.match(10) && this.raise(me.ClassMethodHasDeclare, o);
    }
    parseExpressionStatement(o, f, g) {
      return (f.type === "Identifier" ? this.tsParseExpressionStatement(o, f, g) : void 0) || super.parseExpressionStatement(o, f, g);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(o, f, g) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(o, f, g);
      let b = this.tryParse(() => super.parseConditional(o, f));
      return b.node ? (b.error && (this.state = b.failState), b.node) : (b.error && super.setOptionalParametersError(g, b.error), o);
    }
    parseParenItem(o, f) {
      if (o = super.parseParenItem(o, f), this.eat(17) && (o.optional = !0, this.resetEndLocation(o)), this.match(14)) {
        let g = this.startNodeAt(f);
        return g.expression = o, g.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(g, "TSTypeCastExpression");
      }
      return o;
    }
    parseExportDeclaration(o) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(o));
      let f = this.state.startLoc, g = this.eatContextual(125);
      if (g && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(me.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let b = j(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(o);
      return b ? ((b.type === "TSInterfaceDeclaration" || b.type === "TSTypeAliasDeclaration" || g) && (o.exportKind = "type"), g && (this.resetStartLocation(b, f), b.declare = !0), b) : null;
    }
    parseClassId(o, f, g, b) {
      if ((!f || g) && this.isContextual(113))
        return;
      super.parseClassId(o, f, g, o.declare ? 1024 : 8331);
      let E = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      E && (o.typeParameters = E);
    }
    parseClassPropertyAnnotation(o) {
      o.optional || (this.eat(35) ? o.definite = !0 : this.eat(17) && (o.optional = !0));
      let f = this.tsTryParseTypeAnnotation();
      f && (o.typeAnnotation = f);
    }
    parseClassProperty(o) {
      if (this.parseClassPropertyAnnotation(o), this.state.isAmbientContext && !(o.readonly && !o.typeAnnotation) && this.match(29) && this.raise(me.DeclareClassFieldHasInitializer, this.state.startLoc), o.abstract && this.match(29)) {
        let { key: f } = o;
        this.raise(me.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: f.type === "Identifier" && !o.computed ? f.name : `[${this.input.slice(f.start, f.end)}]` });
      }
      return super.parseClassProperty(o);
    }
    parseClassPrivateProperty(o) {
      return o.abstract && this.raise(me.PrivateElementHasAbstract, o), o.accessibility && this.raise(me.PrivateElementHasAccessibility, o, { modifier: o.accessibility }), this.parseClassPropertyAnnotation(o), super.parseClassPrivateProperty(o);
    }
    parseClassAccessorProperty(o) {
      return this.parseClassPropertyAnnotation(o), o.optional && this.raise(me.AccessorCannotBeOptional, o), super.parseClassAccessorProperty(o);
    }
    pushClassMethod(o, f, g, b, E, T) {
      let F = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      F && E && this.raise(me.ConstructorHasTypeParameters, F);
      let { declare: N = !1, kind: $ } = f;
      N && ($ === "get" || $ === "set") && this.raise(me.DeclareAccessor, f, { kind: $ }), F && (f.typeParameters = F), super.pushClassMethod(o, f, g, b, E, T);
    }
    pushClassPrivateMethod(o, f, g, b) {
      let E = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      E && (f.typeParameters = E), super.pushClassPrivateMethod(o, f, g, b);
    }
    declareClassPrivateMethodInScope(o, f) {
      o.type !== "TSDeclareMethod" && (o.type === "MethodDefinition" && !o.value.body || super.declareClassPrivateMethodInScope(o, f));
    }
    parseClassSuper(o) {
      super.parseClassSuper(o), o.superClass && (this.match(47) || this.match(51)) && (o.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (o.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(o, f, g, b, E, T, F) {
      let N = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return N && (o.typeParameters = N), super.parseObjPropValue(o, f, g, b, E, T, F);
    }
    parseFunctionParams(o, f) {
      let g = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      g && (o.typeParameters = g), super.parseFunctionParams(o, f);
    }
    parseVarId(o, f) {
      super.parseVarId(o, f), o.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (o.definite = !0);
      let g = this.tsTryParseTypeAnnotation();
      g && (o.id.typeAnnotation = g, this.resetEndLocation(o.id));
    }
    parseAsyncArrowFromCallExpression(o, f) {
      return this.match(14) && (o.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(o, f);
    }
    parseMaybeAssign(o, f) {
      var g, b, E, T, F;
      let N, $, U;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (N = this.state.clone(), $ = this.tryParse(() => super.parseMaybeAssign(o, f), N), !$.error)
          return $.node;
        let { context: oe } = this.state, Xe = oe[oe.length - 1];
        (Xe === I.j_oTag || Xe === I.j_expr) && oe.pop();
      }
      if (!((g = $) != null && g.error) && !this.match(47))
        return super.parseMaybeAssign(o, f);
      (!N || N === this.state) && (N = this.state.clone());
      let ie, ce = this.tryParse((oe) => {
        var Xe, qe;
        ie = this.tsParseTypeParameters(this.tsParseConstModifier);
        let mt = super.parseMaybeAssign(o, f);
        return (mt.type !== "ArrowFunctionExpression" || (Xe = mt.extra) != null && Xe.parenthesized) && oe(), ((qe = ie) == null ? void 0 : qe.params.length) !== 0 && this.resetStartLocationFromNode(mt, ie), mt.typeParameters = ie, mt;
      }, N);
      if (!ce.error && !ce.aborted)
        return ie && this.reportReservedArrowTypeParam(ie), ce.node;
      if (!$ && (by(!this.hasPlugin("jsx")), U = this.tryParse(() => super.parseMaybeAssign(o, f), N), !U.error))
        return U.node;
      if ((b = $) != null && b.node)
        return this.state = $.failState, $.node;
      if (ce.node)
        return this.state = ce.failState, ie && this.reportReservedArrowTypeParam(ie), ce.node;
      if ((E = U) != null && E.node)
        return this.state = U.failState, U.node;
      throw ((T = $) == null ? void 0 : T.error) || ce.error || ((F = U) == null ? void 0 : F.error);
    }
    reportReservedArrowTypeParam(o) {
      var f;
      o.params.length === 1 && !o.params[0].constraint && !((f = o.extra) != null && f.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(me.ReservedArrowTypeParam, o);
    }
    parseMaybeUnary(o, f) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(o, f);
    }
    parseArrow(o) {
      if (this.match(14)) {
        let f = this.tryParse((g) => {
          let b = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && g(), b;
        });
        if (f.aborted)
          return;
        f.thrown || (f.error && (this.state = f.failState), o.returnType = f.node);
      }
      return super.parseArrow(o);
    }
    parseAssignableListItemTypes(o, f) {
      if (!(f & 2))
        return o;
      this.eat(17) && (o.optional = !0);
      let g = this.tsTryParseTypeAnnotation();
      return g && (o.typeAnnotation = g), this.resetEndLocation(o), o;
    }
    isAssignable(o, f) {
      switch (o.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(o.expression, f);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(o, f);
      }
    }
    toAssignable(o, f = !1) {
      switch (o.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(o, f);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          f ? this.expressionScope.recordArrowParameterBindingError(me.UnexpectedTypeCastInParameter, o) : this.raise(me.UnexpectedTypeCastInParameter, o), this.toAssignable(o.expression, f);
          break;
        case "AssignmentExpression":
          !f && o.left.type === "TSTypeCastExpression" && (o.left = this.typeCastToParameter(o.left));
        default:
          super.toAssignable(o, f);
      }
    }
    toAssignableParenthesizedExpression(o, f) {
      switch (o.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(o.expression, f);
          break;
        default:
          super.toAssignable(o, f);
      }
    }
    checkToRestConversion(o, f) {
      switch (o.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(o.expression, !1);
          break;
        default:
          super.checkToRestConversion(o, f);
      }
    }
    isValidLVal(o, f, g) {
      return $A({ TSTypeCastExpression: !0, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (g !== 64 || !f) && ["expression", !0], TSSatisfiesExpression: (g !== 64 || !f) && ["expression", !0], TSTypeAssertion: (g !== 64 || !f) && ["expression", !0] }, o) || super.isValidLVal(o, f, g);
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(o) {
      if (this.match(47) || this.match(51)) {
        let f = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let g = super.parseMaybeDecoratorArguments(o);
          return g.typeParameters = f, g;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(o);
    }
    checkCommaAfterRest(o) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === o ? (this.next(), !1) : super.checkCommaAfterRest(o);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(o, f) {
      let g = super.parseMaybeDefault(o, f);
      return g.type === "AssignmentPattern" && g.typeAnnotation && g.right.start < g.typeAnnotation.start && this.raise(me.TypeAnnotationAfterAssign, g.typeAnnotation), g;
    }
    getTokenFromCode(o) {
      if (this.state.inType) {
        if (o === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (o === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(o);
    }
    reScan_lt_gt() {
      let { type: o } = this.state;
      o === 47 ? (this.state.pos -= 1, this.readToken_lt()) : o === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let { type: o } = this.state;
      return o === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : o;
    }
    toAssignableList(o, f, g) {
      for (let b = 0; b < o.length; b++) {
        let E = o[b];
        (E == null ? void 0 : E.type) === "TSTypeCastExpression" && (o[b] = this.typeCastToParameter(E));
      }
      super.toAssignableList(o, f, g);
    }
    typeCastToParameter(o) {
      return o.expression.typeAnnotation = o.typeAnnotation, this.resetEndLocation(o.expression, o.typeAnnotation.loc.end), o.expression;
    }
    shouldParseArrow(o) {
      return this.match(14) ? o.every((f) => this.isAssignable(f, !0)) : super.shouldParseArrow(o);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(o) {
      if (this.match(47) || this.match(51)) {
        let f = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        f && (o.typeParameters = f);
      }
      return super.jsxParseOpeningElementAfterName(o);
    }
    getGetterSetterExpectedParamCount(o) {
      let f = super.getGetterSetterExpectedParamCount(o), g = this.getObjectOrClassMethodParams(o)[0];
      return g && this.isThisParam(g) ? f + 1 : f;
    }
    parseCatchClauseParam() {
      let o = super.parseCatchClauseParam(), f = this.tsTryParseTypeAnnotation();
      return f && (o.typeAnnotation = f, this.resetEndLocation(o)), o;
    }
    tsInAmbientContext(o) {
      let f = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return o();
      } finally {
        this.state.isAmbientContext = f;
      }
    }
    parseClass(o, f, g) {
      let b = this.state.inAbstractClass;
      this.state.inAbstractClass = !!o.abstract;
      try {
        return super.parseClass(o, f, g);
      } finally {
        this.state.inAbstractClass = b;
      }
    }
    tsParseAbstractDeclaration(o, f) {
      if (this.match(80))
        return o.abstract = !0, this.maybeTakeDecorators(f, this.parseClass(o, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return o.abstract = !0, this.raise(me.NonClassMethodPropertyHasAbstractModifer, o), this.tsParseInterfaceDeclaration(o);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(o, f, g, b, E, T, F) {
      let N = super.parseMethod(o, f, g, b, E, T, F);
      if (N.abstract && (this.hasPlugin("estree") ? N.value.body : N.body)) {
        let { key: $ } = N;
        this.raise(me.AbstractMethodHasImplementation, N, { methodName: $.type === "Identifier" && !N.computed ? $.name : `[${this.input.slice($.start, $.end)}]` });
      }
      return N;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(o, f, g, b) {
      return !f && b ? (this.parseTypeOnlyImportExportSpecifier(o, !1, g), this.finishNode(o, "ExportSpecifier")) : (o.exportKind = "value", super.parseExportSpecifier(o, f, g, b));
    }
    parseImportSpecifier(o, f, g, b, E) {
      return !f && b ? (this.parseTypeOnlyImportExportSpecifier(o, !0, g), this.finishNode(o, "ImportSpecifier")) : (o.importKind = "value", super.parseImportSpecifier(o, f, g, b, g ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(o, f, g) {
      let b = f ? "imported" : "local", E = f ? "local" : "exported", T = o[b], F, N = !1, $ = !0, U = T.loc.start;
      if (this.isContextual(93)) {
        let ce = this.parseIdentifier();
        if (this.isContextual(93)) {
          let oe = this.parseIdentifier();
          De(this.state.type) ? (N = !0, T = ce, F = f ? this.parseIdentifier() : this.parseModuleExportName(), $ = !1) : (F = oe, $ = !1);
        } else
          De(this.state.type) ? ($ = !1, F = f ? this.parseIdentifier() : this.parseModuleExportName()) : (N = !0, T = ce);
      } else
        De(this.state.type) && (N = !0, f ? (T = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(T.name, T.loc.start, !0, !0)) : T = this.parseModuleExportName());
      N && g && this.raise(f ? me.TypeModifierIsUsedInTypeImports : me.TypeModifierIsUsedInTypeExports, U), o[b] = T, o[E] = F;
      let ie = f ? "importKind" : "exportKind";
      o[ie] = N ? "type" : "value", $ && this.eatContextual(93) && (o[E] = f ? this.parseIdentifier() : this.parseModuleExportName()), o[E] || (o[E] = Zi(o[b])), f && this.checkIdentifier(o[E], N ? 4098 : 4096);
    }
  };
  function MA(c) {
    if (c.type !== "MemberExpression")
      return !1;
    let { computed: o, property: f } = c;
    return o && f.type !== "StringLiteral" && (f.type !== "TemplateLiteral" || f.expressions.length > 0) ? !1 : Sy(c.object);
  }
  function LA(c, o) {
    var f;
    let { type: g } = c;
    if ((f = c.extra) != null && f.parenthesized)
      return !1;
    if (o) {
      if (g === "Literal") {
        let { value: b } = c;
        if (typeof b == "string" || typeof b == "boolean")
          return !0;
      }
    } else if (g === "StringLiteral" || g === "BooleanLiteral")
      return !0;
    return !!(wy(c, o) || QA(c, o) || g === "TemplateLiteral" && c.expressions.length === 0 || MA(c));
  }
  function wy(c, o) {
    return o ? c.type === "Literal" && (typeof c.value == "number" || "bigint" in c) : c.type === "NumericLiteral" || c.type === "BigIntLiteral";
  }
  function QA(c, o) {
    if (c.type === "UnaryExpression") {
      let { operator: f, argument: g } = c;
      if (f === "-" && wy(g, o))
        return !0;
    }
    return !1;
  }
  function Sy(c) {
    return c.type === "Identifier" ? !0 : c.type !== "MemberExpression" || c.computed ? !1 : Sy(c.object);
  }
  var Cy = w`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), jA = (c) => class extends c {
    parsePlaceholder(o) {
      if (this.match(144)) {
        let f = this.startNode();
        return this.next(), this.assertNoSpace(), f.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(f, o);
      }
    }
    finishPlaceholder(o, f) {
      let g = !!(o.expectedNode && o.type === "Placeholder");
      return o.expectedNode = f, g ? o : this.finishNode(o, "Placeholder");
    }
    getTokenFromCode(o) {
      o === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(o);
    }
    parseExprAtom(o) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(o);
    }
    parseIdentifier(o) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(o);
    }
    checkReservedWord(o, f, g, b) {
      o !== void 0 && super.checkReservedWord(o, f, g, b);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(o, f, g) {
      return o === "Placeholder" || super.isValidLVal(o, f, g);
    }
    toAssignable(o, f) {
      o && o.type === "Placeholder" && o.expectedNode === "Expression" ? o.expectedNode = "Pattern" : super.toAssignable(o, f);
    }
    chStartsBindingIdentifier(o, f) {
      return !!(super.chStartsBindingIdentifier(o, f) || this.lookahead().type === 144);
    }
    verifyBreakContinue(o, f) {
      o.label && o.label.type === "Placeholder" || super.verifyBreakContinue(o, f);
    }
    parseExpressionStatement(o, f) {
      var g;
      if (f.type !== "Placeholder" || (g = f.extra) != null && g.parenthesized)
        return super.parseExpressionStatement(o, f);
      if (this.match(14)) {
        let b = o;
        return b.label = this.finishPlaceholder(f, "Identifier"), this.next(), b.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(b, "LabeledStatement");
      }
      return this.semicolon(), o.name = f.name, this.finishPlaceholder(o, "Statement");
    }
    parseBlock(o, f, g) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(o, f, g);
    }
    parseFunctionId(o) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(o);
    }
    parseClass(o, f, g) {
      let b = f ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let E = this.state.strict, T = this.parsePlaceholder("Identifier");
      if (T)
        if (this.match(81) || this.match(144) || this.match(5))
          o.id = T;
        else {
          if (g || !f)
            return o.id = null, o.body = this.finishPlaceholder(T, "ClassBody"), this.finishNode(o, b);
          throw this.raise(Cy.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(o, f, g);
      return super.parseClassSuper(o), o.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!o.superClass, E), this.finishNode(o, b);
    }
    parseExport(o, f) {
      let g = this.parsePlaceholder("Identifier");
      if (!g)
        return super.parseExport(o, f);
      if (!this.isContextual(98) && !this.match(12))
        return o.specifiers = [], o.source = null, o.declaration = this.finishPlaceholder(g, "Declaration"), this.finishNode(o, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      let b = this.startNode();
      return b.exported = g, o.specifiers = [this.finishNode(b, "ExportDefaultSpecifier")], super.parseExport(o, f);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let o = this.nextTokenStart();
        if (this.isUnparsedContextual(o, "from") && this.input.startsWith(ui(144), this.nextTokenStartSince(o + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(o, f) {
      var g;
      return (g = o.specifiers) != null && g.length ? !0 : super.maybeParseExportDefaultSpecifier(o, f);
    }
    checkExport(o) {
      let { specifiers: f } = o;
      f != null && f.length && (o.specifiers = f.filter((g) => g.exported.type === "Placeholder")), super.checkExport(o), o.specifiers = f;
    }
    parseImport(o) {
      let f = this.parsePlaceholder("Identifier");
      if (!f)
        return super.parseImport(o);
      if (o.specifiers = [], !this.isContextual(98) && !this.match(12))
        return o.source = this.finishPlaceholder(f, "StringLiteral"), this.semicolon(), this.finishNode(o, "ImportDeclaration");
      let g = this.startNodeAtNode(f);
      return g.local = f, o.specifiers.push(this.finishNode(g, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(o) || this.parseNamedImportSpecifiers(o)), this.expectContextual(98), o.source = this.parseImportSource(), this.semicolon(), this.finishNode(o, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(Cy.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, RA = (c) => class extends c {
    parseV8Intrinsic() {
      if (this.match(54)) {
        let o = this.state.startLoc, f = this.startNode();
        if (this.next(), j(this.state.type)) {
          let g = this.parseIdentifierName(), b = this.createIdentifier(f, g);
          if (b.type = "V8IntrinsicIdentifier", this.match(10))
            return b;
        }
        this.unexpected(o);
      }
    }
    parseExprAtom(o) {
      return this.parseV8Intrinsic() || super.parseExprAtom(o);
    }
  };
  function pt(c, o) {
    let [f, g] = typeof o == "string" ? [o, {}] : o, b = Object.keys(g), E = b.length === 0;
    return c.some((T) => {
      if (typeof T == "string")
        return E && T === f;
      {
        let [F, N] = T;
        if (F !== f)
          return !1;
        for (let $ of b)
          if (N[$] !== g[$])
            return !1;
        return !0;
      }
    });
  }
  function pn(c, o, f) {
    let g = c.find((b) => Array.isArray(b) ? b[0] === o : b === o);
    return g && Array.isArray(g) && g.length > 1 ? g[1][f] : null;
  }
  var Ey = ["minimal", "fsharp", "hack", "smart"], Ay = ["^^", "@@", "^", "%", "#"], ky = ["hash", "bar"];
  function ZA(c) {
    if (pt(c, "decorators")) {
      if (pt(c, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let o = pn(c, "decorators", "decoratorsBeforeExport");
      if (o != null && typeof o != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let f = pn(c, "decorators", "allowCallParenthesized");
      if (f != null && typeof f != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (pt(c, "flow") && pt(c, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (pt(c, "placeholders") && pt(c, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (pt(c, "pipelineOperator")) {
      let o = pn(c, "pipelineOperator", "proposal");
      if (!Ey.includes(o)) {
        let g = Ey.map((b) => `"${b}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${g}.`);
      }
      let f = pt(c, ["recordAndTuple", { syntaxType: "hash" }]);
      if (o === "hack") {
        if (pt(c, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (pt(c, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let g = pn(c, "pipelineOperator", "topicToken");
        if (!Ay.includes(g)) {
          let b = Ay.map((E) => `"${E}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${b}.`);
        }
        if (g === "#" && f)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      } else if (o === "smart" && f)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (pt(c, "moduleAttributes")) {
      if (pt(c, "importAssertions") || pt(c, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (pn(c, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (pt(c, "importAssertions") && pt(c, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (pt(c, "recordAndTuple") && pn(c, "recordAndTuple", "syntaxType") != null && !ky.includes(pn(c, "recordAndTuple", "syntaxType")))
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + ky.map((o) => `'${o}'`).join(", "));
    if (pt(c, "asyncDoExpressions") && !pt(c, "doExpressions")) {
      let o = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw o.missingPlugins = "doExpressions", o;
    }
    if (pt(c, "optionalChainingAssign") && pn(c, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
  }
  var Ty = { estree: A, jsx: AA, flow: EA, typescript: _A, v8intrinsic: RA, placeholders: jA }, WA = Object.keys(Ty), ep = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: !1, allowReturnOutsideFunction: !1, allowNewTargetOutsideFunction: !1, allowImportExportEverywhere: !1, allowSuperOutsideMethod: !1, allowUndeclaredExports: !1, plugins: [], strictMode: null, ranges: !1, tokens: !1, createImportExpressions: !1, createParenthesizedExpressions: !1, errorRecovery: !1, attachComment: !0, annexB: !0 };
  function qA(c) {
    if (c == null)
      return Object.assign({}, ep);
    if (c.annexB != null && c.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    let o = {};
    for (let g of Object.keys(ep)) {
      var f;
      o[g] = (f = c[g]) != null ? f : ep[g];
    }
    return o;
  }
  var XA = class extends FA {
    checkProto(c, o, f, g) {
      if (c.type === "SpreadElement" || this.isObjectMethod(c) || c.computed || c.shorthand)
        return;
      let b = c.key;
      if ((b.type === "Identifier" ? b.name : b.value) === "__proto__") {
        if (o) {
          this.raise(x.RecordNoProto, b);
          return;
        }
        f.used && (g ? g.doubleProtoLoc === null && (g.doubleProtoLoc = b.loc.start) : this.raise(x.DuplicateProto, b)), f.used = !0;
      }
    }
    shouldExitDescending(c, o) {
      return c.type === "ArrowFunctionExpression" && c.start === o;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let c = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), c.comments = this.comments, c.errors = this.state.errors, this.options.tokens && (c.tokens = this.tokens), c;
    }
    parseExpression(c, o) {
      return c ? this.disallowInAnd(() => this.parseExpressionBase(o)) : this.allowInAnd(() => this.parseExpressionBase(o));
    }
    parseExpressionBase(c) {
      let o = this.state.startLoc, f = this.parseMaybeAssign(c);
      if (this.match(12)) {
        let g = this.startNodeAt(o);
        for (g.expressions = [f]; this.eat(12); )
          g.expressions.push(this.parseMaybeAssign(c));
        return this.toReferencedList(g.expressions), this.finishNode(g, "SequenceExpression");
      }
      return f;
    }
    parseMaybeAssignDisallowIn(c, o) {
      return this.disallowInAnd(() => this.parseMaybeAssign(c, o));
    }
    parseMaybeAssignAllowIn(c, o) {
      return this.allowInAnd(() => this.parseMaybeAssign(c, o));
    }
    setOptionalParametersError(c, o) {
      var f;
      c.optionalParametersLoc = (f = o == null ? void 0 : o.loc) != null ? f : this.state.startLoc;
    }
    parseMaybeAssign(c, o) {
      let f = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let T = this.parseYield();
        return o && (T = o.call(this, T, f)), T;
      }
      let g;
      c ? g = !1 : (c = new Hl(), g = !0);
      let { type: b } = this.state;
      (b === 10 || j(b)) && (this.state.potentialArrowAt = this.state.start);
      let E = this.parseMaybeConditional(c);
      if (o && (E = o.call(this, E, f)), wt(this.state.type)) {
        let T = this.startNodeAt(f), F = this.state.value;
        if (T.operator = F, this.match(29)) {
          this.toAssignable(E, !0), T.left = E;
          let N = f.index;
          c.doubleProtoLoc != null && c.doubleProtoLoc.index >= N && (c.doubleProtoLoc = null), c.shorthandAssignLoc != null && c.shorthandAssignLoc.index >= N && (c.shorthandAssignLoc = null), c.privateKeyLoc != null && c.privateKeyLoc.index >= N && (this.checkDestructuringPrivate(c), c.privateKeyLoc = null);
        } else
          T.left = E;
        return this.next(), T.right = this.parseMaybeAssign(), this.checkLVal(E, { in: this.finishNode(T, "AssignmentExpression") }), T;
      } else
        g && this.checkExpressionErrors(c, !0);
      return E;
    }
    parseMaybeConditional(c) {
      let o = this.state.startLoc, f = this.state.potentialArrowAt, g = this.parseExprOps(c);
      return this.shouldExitDescending(g, f) ? g : this.parseConditional(g, o, c);
    }
    parseConditional(c, o, f) {
      if (this.eat(17)) {
        let g = this.startNodeAt(o);
        return g.test = c, g.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), g.alternate = this.parseMaybeAssign(), this.finishNode(g, "ConditionalExpression");
      }
      return c;
    }
    parseMaybeUnaryOrPrivate(c) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(c);
    }
    parseExprOps(c) {
      let o = this.state.startLoc, f = this.state.potentialArrowAt, g = this.parseMaybeUnaryOrPrivate(c);
      return this.shouldExitDescending(g, f) ? g : this.parseExprOp(g, o, -1);
    }
    parseExprOp(c, o, f) {
      if (this.isPrivateName(c)) {
        let b = this.getPrivateNameSV(c);
        (f >= Rs(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(x.PrivateInExpectedIn, c, { identifierName: b }), this.classScope.usePrivateName(b, c.loc.start);
      }
      let g = this.state.type;
      if (kr(g) && (this.prodParam.hasIn || !this.match(58))) {
        let b = Rs(g);
        if (b > f) {
          if (g === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return c;
            this.checkPipelineAtInfixOperator(c, o);
          }
          let E = this.startNodeAt(o);
          E.left = c, E.operator = this.state.value;
          let T = g === 41 || g === 42, F = g === 40;
          if (F && (b = Rs(42)), this.next(), g === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(x.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          E.right = this.parseExprOpRightExpr(g, b);
          let N = this.finishNode(E, T || F ? "LogicalExpression" : "BinaryExpression"), $ = this.state.type;
          if (F && ($ === 41 || $ === 42) || T && $ === 40)
            throw this.raise(x.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(N, o, f);
        }
      }
      return c;
    }
    parseExprOpRightExpr(c, o) {
      let f = this.state.startLoc;
      switch (c) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(x.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(c, o), f);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(o));
          }
        default:
          return this.parseExprOpBaseRightExpr(c, o);
      }
    }
    parseExprOpBaseRightExpr(c, o) {
      let f = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), f, ql(c) ? o - 1 : o);
    }
    parseHackPipeBody() {
      var c;
      let { startLoc: o } = this.state, f = this.parseMaybeAssign();
      return d.has(f.type) && !((c = f.extra) != null && c.parenthesized) && this.raise(x.PipeUnparenthesizedBody, o, { type: f.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(x.PipeTopicUnused, o), f;
    }
    checkExponentialAfterUnary(c) {
      this.match(57) && this.raise(x.UnexpectedTokenUnaryExponentiation, c.argument);
    }
    parseMaybeUnary(c, o) {
      let f = this.state.startLoc, g = this.isContextual(96);
      if (g && this.isAwaitAllowed()) {
        this.next();
        let F = this.parseAwait(f);
        return o || this.checkExponentialAfterUnary(F), F;
      }
      let b = this.match(34), E = this.startNode();
      if (un(this.state.type)) {
        E.operator = this.state.value, E.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let F = this.match(89);
        if (this.next(), E.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(c, !0), this.state.strict && F) {
          let N = E.argument;
          N.type === "Identifier" ? this.raise(x.StrictDelete, E) : this.hasPropertyAsPrivateName(N) && this.raise(x.DeletePrivateField, E);
        }
        if (!b)
          return o || this.checkExponentialAfterUnary(E), this.finishNode(E, "UnaryExpression");
      }
      let T = this.parseUpdate(E, b, c);
      if (g) {
        let { type: F } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Mt(F) : Mt(F) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(x.AwaitNotInAsyncContext, f), this.parseAwait(f);
      }
      return T;
    }
    parseUpdate(c, o, f) {
      if (o) {
        let E = c;
        return this.checkLVal(E.argument, { in: this.finishNode(E, "UpdateExpression") }), c;
      }
      let g = this.state.startLoc, b = this.parseExprSubscripts(f);
      if (this.checkExpressionErrors(f, !1))
        return b;
      for (; li(this.state.type) && !this.canInsertSemicolon(); ) {
        let E = this.startNodeAt(g);
        E.operator = this.state.value, E.prefix = !1, E.argument = b, this.next(), this.checkLVal(b, { in: b = this.finishNode(E, "UpdateExpression") });
      }
      return b;
    }
    parseExprSubscripts(c) {
      let o = this.state.startLoc, f = this.state.potentialArrowAt, g = this.parseExprAtom(c);
      return this.shouldExitDescending(g, f) ? g : this.parseSubscripts(g, o);
    }
    parseSubscripts(c, o, f) {
      let g = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(c), stop: !1 };
      do
        c = this.parseSubscript(c, o, f, g), g.maybeAsyncArrow = !1;
      while (!g.stop);
      return c;
    }
    parseSubscript(c, o, f, g) {
      let { type: b } = this.state;
      if (!f && b === 15)
        return this.parseBind(c, o, f, g);
      if (Zs(b))
        return this.parseTaggedTemplateExpression(c, o, g);
      let E = !1;
      if (b === 18) {
        if (f && (this.raise(x.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return g.stop = !0, c;
        g.optionalChainMember = E = !0, this.next();
      }
      if (!f && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(c, o, g, E);
      {
        let T = this.eat(0);
        return T || E || this.eat(16) ? this.parseMember(c, o, g, T, E) : (g.stop = !0, c);
      }
    }
    parseMember(c, o, f, g, b) {
      let E = this.startNodeAt(o);
      return E.object = c, E.computed = g, g ? (E.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (c.type === "Super" && this.raise(x.SuperPrivateField, o), this.classScope.usePrivateName(this.state.value, this.state.startLoc), E.property = this.parsePrivateName()) : E.property = this.parseIdentifier(!0), f.optionalChainMember ? (E.optional = b, this.finishNode(E, "OptionalMemberExpression")) : this.finishNode(E, "MemberExpression");
    }
    parseBind(c, o, f, g) {
      let b = this.startNodeAt(o);
      return b.object = c, this.next(), b.callee = this.parseNoCallExpr(), g.stop = !0, this.parseSubscripts(this.finishNode(b, "BindExpression"), o, f);
    }
    parseCoverCallAndAsyncArrowHead(c, o, f, g) {
      let b = this.state.maybeInArrowParameters, E = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let T = this.startNodeAt(o);
      T.callee = c;
      let { maybeAsyncArrow: F, optionalChainMember: N } = f;
      F && (this.expressionScope.enter(mA()), E = new Hl()), N && (T.optional = g), g ? T.arguments = this.parseCallExpressionArguments(11) : T.arguments = this.parseCallExpressionArguments(11, c.type === "Import", c.type !== "Super", T, E);
      let $ = this.finishCallExpression(T, N);
      return F && this.shouldParseAsyncArrow() && !g ? (f.stop = !0, this.checkDestructuringPrivate(E), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), $ = this.parseAsyncArrowFromCallExpression(this.startNodeAt(o), $)) : (F && (this.checkExpressionErrors(E, !0), this.expressionScope.exit()), this.toReferencedArguments($)), this.state.maybeInArrowParameters = b, $;
    }
    toReferencedArguments(c, o) {
      this.toReferencedListDeep(c.arguments, o);
    }
    parseTaggedTemplateExpression(c, o, f) {
      let g = this.startNodeAt(o);
      return g.tag = c, g.quasi = this.parseTemplate(!0), f.optionalChainMember && this.raise(x.OptionalChainingNoTemplate, o), this.finishNode(g, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(c) {
      return c.type === "Identifier" && c.name === "async" && this.state.lastTokEndLoc.index === c.end && !this.canInsertSemicolon() && c.end - c.start === 5 && c.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(c, o) {
      if (c.callee.type === "Import")
        if (c.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), c.arguments.length === 0 || c.arguments.length > 2)
          this.raise(x.ImportCallArity, c, { maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
        else
          for (let f of c.arguments)
            f.type === "SpreadElement" && this.raise(x.ImportCallSpreadArgument, f);
      return this.finishNode(c, o ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(c, o, f, g, b) {
      let E = [], T = !0, F = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(c); ) {
        if (T)
          T = !1;
        else if (this.expect(12), this.match(c)) {
          o && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(x.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), g && this.addTrailingCommaExtraToNode(g), this.next();
          break;
        }
        E.push(this.parseExprListItem(!1, b, f));
      }
      return this.state.inFSharpPipelineDirectBody = F, E;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(c, o) {
      var f;
      return this.resetPreviousNodeTrailingComments(o), this.expect(19), this.parseArrowExpression(c, o.arguments, !0, (f = o.extra) == null ? void 0 : f.trailingCommaLoc), o.innerComments && Ha(c, o.innerComments), o.callee.trailingComments && Ha(c, o.callee.trailingComments), c;
    }
    parseNoCallExpr() {
      let c = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), c, !0);
    }
    parseExprAtom(c) {
      let o, f = null, { type: g } = this.state;
      switch (g) {
        case 79:
          return this.parseSuper();
        case 83:
          return o = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(o) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(o) : this.finishNode(o, "Import") : (this.raise(x.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(o, "Import"));
        case 78:
          return o = this.startNode(), this.next(), this.finishNode(o, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let b = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(b);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, c);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, c);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          f = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(f, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          o = this.startNode(), this.next(), o.object = null;
          let b = o.callee = this.parseNoCallExpr();
          if (b.type === "MemberExpression")
            return this.finishNode(o, "BindExpression");
          throw this.raise(x.UnsupportedBind, b);
        }
        case 138:
          return this.raise(x.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let b = this.getPluginOption("pipelineOperator", "proposal");
          if (b)
            return this.parseTopicReference(b);
          this.unexpected();
          break;
        }
        case 47: {
          let b = this.input.codePointAt(this.nextTokenStart());
          Ne(b) || b === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (j(g)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let b = this.state.potentialArrowAt === this.state.start, E = this.state.containsEsc, T = this.parseIdentifier();
            if (!E && T.name === "async" && !this.canInsertSemicolon()) {
              let { type: F } = this.state;
              if (F === 68)
                return this.resetPreviousNodeTrailingComments(T), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(T));
              if (j(F))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(T)) : T;
              if (F === 90)
                return this.resetPreviousNodeTrailingComments(T), this.parseDo(this.startNodeAtNode(T), !0);
            }
            return b && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(T), [T], !1)) : T;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(c, o) {
      let f = this.getPluginOption("pipelineOperator", "proposal");
      if (f)
        return this.state.type = c, this.state.value = o, this.state.pos--, this.state.end--, this.state.endLoc = n(this.state.endLoc, -1), this.parseTopicReference(f);
      this.unexpected();
    }
    parseTopicReference(c) {
      let o = this.startNode(), f = this.state.startLoc, g = this.state.type;
      return this.next(), this.finishTopicReference(o, f, c, g);
    }
    finishTopicReference(c, o, f, g) {
      if (this.testTopicReferenceConfiguration(f, o, g)) {
        let b = f === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(f === "smart" ? x.PrimaryTopicNotAllowed : x.PipeTopicUnbound, o), this.registerTopicReference(), this.finishNode(c, b);
      } else
        throw this.raise(x.PipeTopicUnconfiguredToken, o, { token: ui(g) });
    }
    testTopicReferenceConfiguration(c, o, f) {
      switch (c) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", { topicToken: ui(f) }]);
        case "smart":
          return f === 27;
        default:
          throw this.raise(x.PipeTopicRequiresHackPipes, o);
      }
    }
    parseAsyncArrowUnaryFunction(c) {
      this.prodParam.enter(Gl(!0, this.prodParam.hasYield));
      let o = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(x.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(c, o, !0);
    }
    parseDo(c, o) {
      this.expectPlugin("doExpressions"), o && this.expectPlugin("asyncDoExpressions"), c.async = o, this.next();
      let f = this.state.labels;
      return this.state.labels = [], o ? (this.prodParam.enter(2), c.body = this.parseBlock(), this.prodParam.exit()) : c.body = this.parseBlock(), this.state.labels = f, this.finishNode(c, "DoExpression");
    }
    parseSuper() {
      let c = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(x.SuperNotAllowed, c) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(x.UnexpectedSuper, c), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(x.UnsupportedSuper, c), this.finishNode(c, "Super");
    }
    parsePrivateName() {
      let c = this.startNode(), o = this.startNodeAt(n(this.state.startLoc, 1)), f = this.state.value;
      return this.next(), c.id = this.createIdentifier(o, f), this.finishNode(c, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let c = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let o = this.createIdentifier(this.startNodeAtNode(c), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(c, o, "sent");
      }
      return this.parseFunction(c);
    }
    parseMetaProperty(c, o, f) {
      c.meta = o;
      let g = this.state.containsEsc;
      return c.property = this.parseIdentifier(!0), (c.property.name !== f || g) && this.raise(x.UnsupportedMetaProperty, c.property, { target: o.name, onlyValidPropertyName: f }), this.finishNode(c, "MetaProperty");
    }
    parseImportMetaProperty(c) {
      let o = this.createIdentifier(this.startNodeAtNode(c), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(x.ImportMetaOutsideModule, o), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let f = this.isContextual(105);
        if (f || this.unexpected(), this.expectPlugin(f ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(x.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
        return this.next(), c.phase = f ? "source" : "defer", this.parseImportCall(c);
      }
      return this.parseMetaProperty(c, o, "meta");
    }
    parseLiteralAtNode(c, o, f) {
      return this.addExtra(f, "rawValue", c), this.addExtra(f, "raw", this.input.slice(f.start, this.state.end)), f.value = c, this.next(), this.finishNode(f, o);
    }
    parseLiteral(c, o) {
      let f = this.startNode();
      return this.parseLiteralAtNode(c, o, f);
    }
    parseStringLiteral(c) {
      return this.parseLiteral(c, "StringLiteral");
    }
    parseNumericLiteral(c) {
      return this.parseLiteral(c, "NumericLiteral");
    }
    parseBigIntLiteral(c) {
      return this.parseLiteral(c, "BigIntLiteral");
    }
    parseDecimalLiteral(c) {
      return this.parseLiteral(c, "DecimalLiteral");
    }
    parseRegExpLiteral(c) {
      let o = this.parseLiteral(c.value, "RegExpLiteral");
      return o.pattern = c.pattern, o.flags = c.flags, o;
    }
    parseBooleanLiteral(c) {
      let o = this.startNode();
      return o.value = c, this.next(), this.finishNode(o, "BooleanLiteral");
    }
    parseNullLiteral() {
      let c = this.startNode();
      return this.next(), this.finishNode(c, "NullLiteral");
    }
    parseParenAndDistinguishExpression(c) {
      let o = this.state.startLoc, f;
      this.next(), this.expressionScope.enter(fA());
      let g = this.state.maybeInArrowParameters, b = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let E = this.state.startLoc, T = [], F = new Hl(), N = !0, $, U;
      for (; !this.match(11); ) {
        if (N)
          N = !1;
        else if (this.expect(12, F.optionalParametersLoc === null ? null : F.optionalParametersLoc), this.match(11)) {
          U = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let oe = this.state.startLoc;
          if ($ = this.state.startLoc, T.push(this.parseParenItem(this.parseRestBinding(), oe)), !this.checkCommaAfterRest(41))
            break;
        } else
          T.push(this.parseMaybeAssignAllowIn(F, this.parseParenItem));
      }
      let ie = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = g, this.state.inFSharpPipelineDirectBody = b;
      let ce = this.startNodeAt(o);
      return c && this.shouldParseArrow(T) && (ce = this.parseArrow(ce)) ? (this.checkDestructuringPrivate(F), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(ce, T, !1), ce) : (this.expressionScope.exit(), T.length || this.unexpected(this.state.lastTokStartLoc), U && this.unexpected(U), $ && this.unexpected($), this.checkExpressionErrors(F, !0), this.toReferencedListDeep(T, !0), T.length > 1 ? (f = this.startNodeAt(E), f.expressions = T, this.finishNode(f, "SequenceExpression"), this.resetEndLocation(f, ie)) : f = T[0], this.wrapParenthesis(o, f));
    }
    wrapParenthesis(c, o) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(o, "parenthesized", !0), this.addExtra(o, "parenStart", c.index), this.takeSurroundingComments(o, c.index, this.state.lastTokEndLoc.index), o;
      let f = this.startNodeAt(c);
      return f.expression = o, this.finishNode(f, "ParenthesizedExpression");
    }
    shouldParseArrow(c) {
      return !this.canInsertSemicolon();
    }
    parseArrow(c) {
      if (this.eat(19))
        return c;
    }
    parseParenItem(c, o) {
      return c;
    }
    parseNewOrNewTarget() {
      let c = this.startNode();
      if (this.next(), this.match(16)) {
        let o = this.createIdentifier(this.startNodeAtNode(c), "new");
        this.next();
        let f = this.parseMetaProperty(c, o, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(x.UnexpectedNewTarget, f), f;
      }
      return this.parseNew(c);
    }
    parseNew(c) {
      if (this.parseNewCallee(c), this.eat(10)) {
        let o = this.parseExprList(11);
        this.toReferencedList(o), c.arguments = o;
      } else
        c.arguments = [];
      return this.finishNode(c, "NewExpression");
    }
    parseNewCallee(c) {
      let o = this.match(83), f = this.parseNoCallExpr();
      c.callee = f, o && (f.type === "Import" || f.type === "ImportExpression") && this.raise(x.ImportCallNotNewExpression, f);
    }
    parseTemplateElement(c) {
      let { start: o, startLoc: f, end: g, value: b } = this.state, E = o + 1, T = this.startNodeAt(n(f, 1));
      b === null && (c || this.raise(x.InvalidEscapeSequenceTemplate, n(this.state.firstInvalidTemplateEscapePos, 1)));
      let F = this.match(24), N = F ? -1 : -2, $ = g + N;
      T.value = { raw: this.input.slice(E, $).replace(/\r\n?/g, `
`), cooked: b === null ? null : b.slice(1, N) }, T.tail = F, this.next();
      let U = this.finishNode(T, "TemplateElement");
      return this.resetEndLocation(U, n(this.state.lastTokEndLoc, N)), U;
    }
    parseTemplate(c) {
      let o = this.startNode();
      o.expressions = [];
      let f = this.parseTemplateElement(c);
      for (o.quasis = [f]; !f.tail; )
        o.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), o.quasis.push(f = this.parseTemplateElement(c));
      return this.finishNode(o, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(c, o, f, g) {
      f && this.expectPlugin("recordAndTuple");
      let b = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let E = /* @__PURE__ */ Object.create(null), T = !0, F = this.startNode();
      for (F.properties = [], this.next(); !this.match(c); ) {
        if (T)
          T = !1;
        else if (this.expect(12), this.match(c)) {
          this.addTrailingCommaExtraToNode(F);
          break;
        }
        let $;
        o ? $ = this.parseBindingProperty() : ($ = this.parsePropertyDefinition(g), this.checkProto($, f, E, g)), f && !this.isObjectProperty($) && $.type !== "SpreadElement" && this.raise(x.InvalidRecordProperty, $), $.shorthand && this.addExtra($, "shorthand", !0), F.properties.push($);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = b;
      let N = "ObjectExpression";
      return o ? N = "ObjectPattern" : f && (N = "RecordExpression"), this.finishNode(F, N);
    }
    addTrailingCommaExtraToNode(c) {
      this.addExtra(c, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(c, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(c) {
      return !c.computed && c.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(c) {
      let o = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(x.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          o.push(this.parseDecorator());
      let f = this.startNode(), g = !1, b = !1, E;
      if (this.match(21))
        return o.length && this.unexpected(), this.parseSpread();
      o.length && (f.decorators = o, o = []), f.method = !1, c && (E = this.state.startLoc);
      let T = this.eat(55);
      this.parsePropertyNamePrefixOperator(f);
      let F = this.state.containsEsc, N = this.parsePropertyName(f, c);
      if (!T && !F && this.maybeAsyncOrAccessorProp(f)) {
        let $ = N.name;
        $ === "async" && !this.hasPrecedingLineBreak() && (g = !0, this.resetPreviousNodeTrailingComments(N), T = this.eat(55), this.parsePropertyName(f)), ($ === "get" || $ === "set") && (b = !0, this.resetPreviousNodeTrailingComments(N), f.kind = $, this.match(55) && (T = !0, this.raise(x.AccessorIsGenerator, this.state.curPosition(), { kind: $ }), this.next()), this.parsePropertyName(f));
      }
      return this.parseObjPropValue(f, E, T, g, !1, b, c);
    }
    getGetterSetterExpectedParamCount(c) {
      return c.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(c) {
      return c.params;
    }
    checkGetterSetterParams(c) {
      var o;
      let f = this.getGetterSetterExpectedParamCount(c), g = this.getObjectOrClassMethodParams(c);
      g.length !== f && this.raise(c.kind === "get" ? x.BadGetterArity : x.BadSetterArity, c), c.kind === "set" && ((o = g[g.length - 1]) == null ? void 0 : o.type) === "RestElement" && this.raise(x.BadSetterRestParameter, c);
    }
    parseObjectMethod(c, o, f, g, b) {
      if (b) {
        let E = this.parseMethod(c, o, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(E), E;
      }
      if (f || o || this.match(10))
        return g && this.unexpected(), c.kind = "method", c.method = !0, this.parseMethod(c, o, f, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(c, o, f, g) {
      if (c.shorthand = !1, this.eat(14))
        return c.value = f ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(g), this.finishNode(c, "ObjectProperty");
      if (!c.computed && c.key.type === "Identifier") {
        if (this.checkReservedWord(c.key.name, c.key.loc.start, !0, !1), f)
          c.value = this.parseMaybeDefault(o, Zi(c.key));
        else if (this.match(29)) {
          let b = this.state.startLoc;
          g != null ? g.shorthandAssignLoc === null && (g.shorthandAssignLoc = b) : this.raise(x.InvalidCoverInitializedName, b), c.value = this.parseMaybeDefault(o, Zi(c.key));
        } else
          c.value = Zi(c.key);
        return c.shorthand = !0, this.finishNode(c, "ObjectProperty");
      }
    }
    parseObjPropValue(c, o, f, g, b, E, T) {
      let F = this.parseObjectMethod(c, f, g, b, E) || this.parseObjectProperty(c, o, b, T);
      return F || this.unexpected(), F;
    }
    parsePropertyName(c, o) {
      if (this.eat(0))
        c.computed = !0, c.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let { type: f, value: g } = this.state, b;
        if (De(f))
          b = this.parseIdentifier(!0);
        else
          switch (f) {
            case 134:
              b = this.parseNumericLiteral(g);
              break;
            case 133:
              b = this.parseStringLiteral(g);
              break;
            case 135:
              b = this.parseBigIntLiteral(g);
              break;
            case 136:
              b = this.parseDecimalLiteral(g);
              break;
            case 138: {
              let E = this.state.startLoc;
              o != null ? o.privateKeyLoc === null && (o.privateKeyLoc = E) : this.raise(x.UnexpectedPrivateField, E), b = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        c.key = b, f !== 138 && (c.computed = !1);
      }
      return c.key;
    }
    initFunction(c, o) {
      c.id = null, c.generator = !1, c.async = o;
    }
    parseMethod(c, o, f, g, b, E, T = !1) {
      this.initFunction(c, f), c.generator = o, this.scope.enter(18 | (T ? 64 : 0) | (b ? 32 : 0)), this.prodParam.enter(Gl(f, c.generator)), this.parseFunctionParams(c, g);
      let F = this.parseFunctionBodyAndFinish(c, E, !0);
      return this.prodParam.exit(), this.scope.exit(), F;
    }
    parseArrayLike(c, o, f, g) {
      f && this.expectPlugin("recordAndTuple");
      let b = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let E = this.startNode();
      return this.next(), E.elements = this.parseExprList(c, !f, g, E), this.state.inFSharpPipelineDirectBody = b, this.finishNode(E, f ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(c, o, f, g) {
      this.scope.enter(6);
      let b = Gl(f, !1);
      !this.match(5) && this.prodParam.hasIn && (b |= 8), this.prodParam.enter(b), this.initFunction(c, f);
      let E = this.state.maybeInArrowParameters;
      return o && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(c, o, g)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(c, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = E, this.finishNode(c, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(c, o, f) {
      this.toAssignableList(o, f, !1), c.params = o;
    }
    parseFunctionBodyAndFinish(c, o, f = !1) {
      return this.parseFunctionBody(c, !1, f), this.finishNode(c, o);
    }
    parseFunctionBody(c, o, f = !1) {
      let g = o && !this.match(5);
      if (this.expressionScope.enter(Oy()), g)
        c.body = this.parseMaybeAssign(), this.checkParams(c, !1, o, !1);
      else {
        let b = this.state.strict, E = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), c.body = this.parseBlock(!0, !1, (T) => {
          let F = !this.isSimpleParamList(c.params);
          T && F && this.raise(x.IllegalLanguageModeDirective, (c.kind === "method" || c.kind === "constructor") && c.key ? c.key.loc.end : c);
          let N = !b && this.state.strict;
          this.checkParams(c, !this.state.strict && !o && !f && !F, o, N), this.state.strict && c.id && this.checkIdentifier(c.id, 65, N);
        }), this.prodParam.exit(), this.state.labels = E;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(c) {
      return c.type === "Identifier";
    }
    isSimpleParamList(c) {
      for (let o = 0, f = c.length; o < f; o++)
        if (!this.isSimpleParameter(c[o]))
          return !1;
      return !0;
    }
    checkParams(c, o, f, g = !0) {
      let b = !o && /* @__PURE__ */ new Set(), E = { type: "FormalParameters" };
      for (let T of c.params)
        this.checkLVal(T, { in: E, binding: 5, checkClashes: b, strictModeChanged: g });
    }
    parseExprList(c, o, f, g) {
      let b = [], E = !0;
      for (; !this.eat(c); ) {
        if (E)
          E = !1;
        else if (this.expect(12), this.match(c)) {
          g && this.addTrailingCommaExtraToNode(g), this.next();
          break;
        }
        b.push(this.parseExprListItem(o, f));
      }
      return b;
    }
    parseExprListItem(c, o, f) {
      let g;
      if (this.match(12))
        c || this.raise(x.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), g = null;
      else if (this.match(21)) {
        let b = this.state.startLoc;
        g = this.parseParenItem(this.parseSpread(o), b);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), f || this.raise(x.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let b = this.startNode();
        this.next(), g = this.finishNode(b, "ArgumentPlaceholder");
      } else
        g = this.parseMaybeAssignAllowIn(o, this.parseParenItem);
      return g;
    }
    parseIdentifier(c) {
      let o = this.startNode(), f = this.parseIdentifierName(c);
      return this.createIdentifier(o, f);
    }
    createIdentifier(c, o) {
      return c.name = o, c.loc.identifierName = o, this.finishNode(c, "Identifier");
    }
    parseIdentifierName(c) {
      let o, { startLoc: f, type: g } = this.state;
      De(g) ? o = this.state.value : this.unexpected();
      let b = ve(g);
      return c ? b && this.replaceToken(132) : this.checkReservedWord(o, f, b, !1), this.next(), o;
    }
    checkReservedWord(c, o, f, g) {
      if (!(c.length > 10 || !HE(c))) {
        if (f && YE(c)) {
          this.raise(x.UnexpectedKeyword, o, { keyword: c });
          return;
        }
        if ((this.state.strict ? g ? uy : Ws : Ri)(c, this.inModule)) {
          this.raise(x.UnexpectedReservedWord, o, { reservedWord: c });
          return;
        } else if (c === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(x.YieldBindingIdentifier, o);
            return;
          }
        } else if (c === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(x.AwaitBindingIdentifier, o);
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(x.AwaitBindingIdentifierInStaticBlock, o);
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError(o);
        } else if (c === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(x.ArgumentsInClass, o);
          return;
        }
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(c) {
      let o = this.startNodeAt(c);
      return this.expressionScope.recordParameterInitializerError(x.AwaitExpressionFormalParameter, o), this.eat(55) && this.raise(x.ObsoleteAwaitStar, o), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (o.argument = this.parseMaybeUnary(null, !0)), this.finishNode(o, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak())
        return !0;
      let { type: c } = this.state;
      return c === 53 || c === 10 || c === 0 || Zs(c) || c === 102 && !this.state.containsEsc || c === 137 || c === 56 || this.hasPlugin("v8intrinsic") && c === 54;
    }
    parseYield() {
      let c = this.startNode();
      this.expressionScope.recordParameterInitializerError(x.YieldInParameter, c), this.next();
      let o = !1, f = null;
      if (!this.hasPrecedingLineBreak())
        switch (o = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!o)
              break;
          default:
            f = this.parseMaybeAssign();
        }
      return c.delegate = o, c.argument = f, this.finishNode(c, "YieldExpression");
    }
    parseImportCall(c) {
      return this.next(), c.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (c.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (c.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(c, "ImportExpression");
    }
    checkPipelineAtInfixOperator(c, o) {
      this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && c.type === "SequenceExpression" && this.raise(x.PipelineHeadSequenceExpression, o);
    }
    parseSmartPipelineBodyInStyle(c, o) {
      if (this.isSimpleReference(c)) {
        let f = this.startNodeAt(o);
        return f.callee = c, this.finishNode(f, "PipelineBareFunction");
      } else {
        let f = this.startNodeAt(o);
        return this.checkSmartPipeTopicBodyEarlyErrors(o), f.expression = c, this.finishNode(f, "PipelineTopicExpression");
      }
    }
    isSimpleReference(c) {
      switch (c.type) {
        case "MemberExpression":
          return !c.computed && this.isSimpleReference(c.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(c) {
      if (this.match(19))
        throw this.raise(x.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(x.PipelineTopicUnused, c);
    }
    withTopicBindingContext(c) {
      let o = this.state.topicContext;
      this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
      try {
        return c();
      } finally {
        this.state.topicContext = o;
      }
    }
    withSmartMixTopicForbiddingContext(c) {
      if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
        let o = this.state.topicContext;
        this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
        try {
          return c();
        } finally {
          this.state.topicContext = o;
        }
      } else
        return c();
    }
    withSoloAwaitPermittingContext(c) {
      let o = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return c();
      } finally {
        this.state.soloAwait = o;
      }
    }
    allowInAnd(c) {
      let o = this.prodParam.currentFlags();
      if (8 & ~o) {
        this.prodParam.enter(o | 8);
        try {
          return c();
        } finally {
          this.prodParam.exit();
        }
      }
      return c();
    }
    disallowInAnd(c) {
      let o = this.prodParam.currentFlags();
      if (8 & o) {
        this.prodParam.enter(o & -9);
        try {
          return c();
        } finally {
          this.prodParam.exit();
        }
      }
      return c();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(c) {
      let o = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let f = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let g = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), o, c);
      return this.state.inFSharpPipelineDirectBody = f, g;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let c = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let o = this.startNodeAt(this.state.endLoc);
      this.next();
      let f = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        c.body = this.parseProgram(o, 8, "module");
      } finally {
        f();
      }
      return this.finishNode(c, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(c) {
    }
  }, tp = { kind: 1 }, VA = { kind: 2 }, UA = /[\uD800-\uDFFF]/u, rp = /in(?:stanceof)?/y;
  function YA(c, o) {
    for (let f = 0; f < c.length; f++) {
      let g = c[f], { type: b } = g;
      if (typeof b == "number") {
        {
          if (b === 138) {
            let { loc: E, start: T, value: F, end: N } = g, $ = T + 1, U = n(E.start, 1);
            c.splice(f, 1, new cn({ type: Vr(27), value: "#", start: T, end: $, startLoc: E.start, endLoc: U }), new cn({ type: Vr(132), value: F, start: $, end: N, startLoc: U, endLoc: E.end })), f++;
            continue;
          }
          if (Zs(b)) {
            let { loc: E, start: T, value: F, end: N } = g, $ = T + 1, U = n(E.start, 1), ie;
            o.charCodeAt(T) === 96 ? ie = new cn({ type: Vr(22), value: "`", start: T, end: $, startLoc: E.start, endLoc: U }) : ie = new cn({ type: Vr(8), value: "}", start: T, end: $, startLoc: E.start, endLoc: U });
            let ce, oe, Xe, qe;
            b === 24 ? (oe = N - 1, Xe = n(E.end, -1), ce = F === null ? null : F.slice(1, -1), qe = new cn({ type: Vr(22), value: "`", start: oe, end: N, startLoc: Xe, endLoc: E.end })) : (oe = N - 2, Xe = n(E.end, -2), ce = F === null ? null : F.slice(1, -2), qe = new cn({ type: Vr(23), value: "${", start: oe, end: N, startLoc: Xe, endLoc: E.end })), c.splice(f, 1, ie, new cn({ type: Vr(20), value: ce, start: $, end: oe, startLoc: U, endLoc: Xe }), qe), f += 2;
            continue;
          }
        }
        g.type = Vr(b);
      }
    }
    return c;
  }
  var zA = class extends XA {
    parseTopLevel(c, o) {
      return c.program = this.parseProgram(o), c.comments = this.comments, this.options.tokens && (c.tokens = YA(this.tokens, this.input)), this.finishNode(c, "File");
    }
    parseProgram(c, o = 139, f = this.options.sourceType) {
      if (c.sourceType = f, c.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(c, !0, !0, o), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [b, E] of Array.from(this.scope.undefinedExports))
          this.raise(x.ModuleExportUndefined, E, { localName: b });
      let g;
      return o === 139 ? g = this.finishNode(c, "Program") : g = this.finishNodeAt(c, "Program", n(this.state.startLoc, -1)), g;
    }
    stmtToDirective(c) {
      let o = c;
      o.type = "Directive", o.value = o.expression, delete o.expression;
      let f = o.value, g = f.value, b = this.input.slice(f.start, f.end), E = f.value = b.slice(1, -1);
      return this.addExtra(f, "raw", b), this.addExtra(f, "rawValue", E), this.addExtra(f, "expressionValue", g), f.type = "DirectiveLiteral", o;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let c = this.startNode();
      return c.value = this.state.value, this.next(), this.finishNode(c, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(c, o) {
      if (Ne(c)) {
        if (rp.lastIndex = o, rp.test(this.input)) {
          let f = this.codePointAtPos(rp.lastIndex);
          if (!$e(f) && f !== 92)
            return !1;
        }
        return !0;
      } else
        return c === 92;
    }
    chStartsBindingPattern(c) {
      return c === 91 || c === 123;
    }
    hasFollowingBindingAtom() {
      let c = this.nextTokenStart(), o = this.codePointAtPos(c);
      return this.chStartsBindingPattern(o) || this.chStartsBindingIdentifier(o, c);
    }
    hasInLineFollowingBindingIdentifier() {
      let c = this.nextTokenInLineStart(), o = this.codePointAtPos(c);
      return this.chStartsBindingIdentifier(o, c);
    }
    startsUsingForOf() {
      let { type: c, containsEsc: o } = this.lookahead();
      if (c === 102 && !o)
        return !1;
      if (j(c) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let c = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(c, "using")) {
        c = this.nextTokenInLineStartSince(c + 5);
        let o = this.codePointAtPos(c);
        if (this.chStartsBindingIdentifier(o, c))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(c = !1) {
      let o = 0;
      return this.options.annexB && !this.state.strict && (o |= 4, c && (o |= 8)), this.parseStatementLike(o);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(c) {
      let o = null;
      return this.match(26) && (o = this.parseDecorators(!0)), this.parseStatementContent(c, o);
    }
    parseStatementContent(c, o) {
      let f = this.state.type, g = this.startNode(), b = !!(c & 2), E = !!(c & 4), T = c & 1;
      switch (f) {
        case 60:
          return this.parseBreakContinueStatement(g, !0);
        case 63:
          return this.parseBreakContinueStatement(g, !1);
        case 64:
          return this.parseDebuggerStatement(g);
        case 90:
          return this.parseDoWhileStatement(g);
        case 91:
          return this.parseForStatement(g);
        case 68:
          if (this.lookaheadCharCode() === 46)
            break;
          return E || this.raise(this.state.strict ? x.StrictFunction : this.options.annexB ? x.SloppyFunctionAnnexB : x.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(g, !1, !b && E);
        case 80:
          return b || this.unexpected(), this.parseClass(this.maybeTakeDecorators(o, g), !0);
        case 69:
          return this.parseIfStatement(g);
        case 70:
          return this.parseReturnStatement(g);
        case 71:
          return this.parseSwitchStatement(g);
        case 72:
          return this.parseThrowStatement(g);
        case 73:
          return this.parseTryStatement(g);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.isAwaitAllowed() ? b || this.raise(x.UnexpectedLexicalDeclaration, g) : this.raise(x.AwaitUsingNotInAsyncContext, g), this.next(), this.parseVarStatement(g, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(x.UnexpectedUsingDeclaration, this.state.startLoc) : b || this.raise(x.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(g, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let $ = this.nextTokenStart(), U = this.codePointAtPos($);
          if (U !== 91 && (!b && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(U, $) && U !== 123))
            break;
        }
        case 75:
          b || this.raise(x.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let $ = this.state.value;
          return this.parseVarStatement(g, $);
        }
        case 92:
          return this.parseWhileStatement(g);
        case 76:
          return this.parseWithStatement(g);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(g);
        case 83: {
          let $ = this.lookaheadCharCode();
          if ($ === 40 || $ === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !T && this.raise(x.UnexpectedImportExport, this.state.startLoc), this.next();
          let $;
          return f === 83 ? ($ = this.parseImport(g), $.type === "ImportDeclaration" && (!$.importKind || $.importKind === "value") && (this.sawUnambiguousESM = !0)) : ($ = this.parseExport(g, o), ($.type === "ExportNamedDeclaration" && (!$.exportKind || $.exportKind === "value") || $.type === "ExportAllDeclaration" && (!$.exportKind || $.exportKind === "value") || $.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed($), $;
        }
        default:
          if (this.isAsyncFunction())
            return b || this.raise(x.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(g, !0, !b && E);
      }
      let F = this.state.value, N = this.parseExpression();
      return j(f) && N.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(g, F, N, c) : this.parseExpressionStatement(g, N, o);
    }
    assertModuleNodeAllowed(c) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(x.ImportOutsideModule, c);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
    }
    maybeTakeDecorators(c, o, f) {
      return c && (o.decorators && o.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(x.DecoratorsBeforeAfterExport, o.decorators[0]), o.decorators.unshift(...c)) : o.decorators = c, this.resetStartLocationFromNode(o, c[0]), f && this.resetStartLocationFromNode(f, o)), o;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(c) {
      let o = [];
      do
        o.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        c || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(x.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(x.UnexpectedLeadingDecorator, this.state.startLoc);
      return o;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let c = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let o = this.state.startLoc, f;
        if (this.match(10)) {
          let g = this.state.startLoc;
          this.next(), f = this.parseExpression(), this.expect(11), f = this.wrapParenthesis(g, f);
          let b = this.state.startLoc;
          c.expression = this.parseMaybeDecoratorArguments(f), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && c.expression !== f && this.raise(x.DecoratorArgumentsOutsideParentheses, b);
        } else {
          for (f = this.parseIdentifier(!1); this.eat(16); ) {
            let g = this.startNodeAt(o);
            g.object = f, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), g.property = this.parsePrivateName()) : g.property = this.parseIdentifier(!0), g.computed = !1, f = this.finishNode(g, "MemberExpression");
          }
          c.expression = this.parseMaybeDecoratorArguments(f);
        }
      } else
        c.expression = this.parseExprSubscripts();
      return this.finishNode(c, "Decorator");
    }
    parseMaybeDecoratorArguments(c) {
      if (this.eat(10)) {
        let o = this.startNodeAtNode(c);
        return o.callee = c, o.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(o.arguments), this.finishNode(o, "CallExpression");
      }
      return c;
    }
    parseBreakContinueStatement(c, o) {
      return this.next(), this.isLineTerminator() ? c.label = null : (c.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(c, o), this.finishNode(c, o ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(c, o) {
      let f;
      for (f = 0; f < this.state.labels.length; ++f) {
        let g = this.state.labels[f];
        if ((c.label == null || g.name === c.label.name) && (g.kind != null && (o || g.kind === 1) || c.label && o))
          break;
      }
      if (f === this.state.labels.length) {
        let g = o ? "BreakStatement" : "ContinueStatement";
        this.raise(x.IllegalBreakContinue, c, { type: g });
      }
    }
    parseDebuggerStatement(c) {
      return this.next(), this.semicolon(), this.finishNode(c, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let c = this.parseExpression();
      return this.expect(11), c;
    }
    parseDoWhileStatement(c) {
      return this.next(), this.state.labels.push(tp), c.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), c.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(c, "DoWhileStatement");
    }
    parseForStatement(c) {
      this.next(), this.state.labels.push(tp);
      let o = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (o = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
        return o !== null && this.unexpected(o), this.parseFor(c, null);
      let f = this.isContextual(100);
      {
        let F = this.isContextual(96) && this.startsAwaitUsing(), N = F || this.isContextual(107) && this.startsUsingForOf(), $ = f && this.hasFollowingBindingAtom() || N;
        if (this.match(74) || this.match(75) || $) {
          let U = this.startNode(), ie;
          F ? (ie = "await using", this.isAwaitAllowed() || this.raise(x.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : ie = this.state.value, this.next(), this.parseVar(U, !0, ie);
          let ce = this.finishNode(U, "VariableDeclaration"), oe = this.match(58);
          return oe && N && this.raise(x.ForInUsing, ce), (oe || this.isContextual(102)) && ce.declarations.length === 1 ? this.parseForIn(c, ce, o) : (o !== null && this.unexpected(o), this.parseFor(c, ce));
        }
      }
      let g = this.isContextual(95), b = new Hl(), E = this.parseExpression(!0, b), T = this.isContextual(102);
      if (T && (f && this.raise(x.ForOfLet, E), o === null && g && E.type === "Identifier" && this.raise(x.ForOfAsync, E)), T || this.match(58)) {
        this.checkDestructuringPrivate(b), this.toAssignable(E, !0);
        let F = T ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(E, { in: { type: F } }), this.parseForIn(c, E, o);
      } else
        this.checkExpressionErrors(b, !0);
      return o !== null && this.unexpected(o), this.parseFor(c, E);
    }
    parseFunctionStatement(c, o, f) {
      return this.next(), this.parseFunction(c, 1 | (f ? 2 : 0) | (o ? 8 : 0));
    }
    parseIfStatement(c) {
      return this.next(), c.test = this.parseHeaderExpression(), c.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), c.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(c, "IfStatement");
    }
    parseReturnStatement(c) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(x.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? c.argument = null : (c.argument = this.parseExpression(), this.semicolon()), this.finishNode(c, "ReturnStatement");
    }
    parseSwitchStatement(c) {
      this.next(), c.discriminant = this.parseHeaderExpression();
      let o = c.cases = [];
      this.expect(5), this.state.labels.push(VA), this.scope.enter(0);
      let f;
      for (let g; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let b = this.match(61);
          f && this.finishNode(f, "SwitchCase"), o.push(f = this.startNode()), f.consequent = [], this.next(), b ? f.test = this.parseExpression() : (g && this.raise(x.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), g = !0, f.test = null), this.expect(14);
        } else
          f ? f.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), f && this.finishNode(f, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(c, "SwitchStatement");
    }
    parseThrowStatement(c) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(x.NewlineAfterThrow, this.state.lastTokEndLoc), c.argument = this.parseExpression(), this.semicolon(), this.finishNode(c, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let c = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && c.type === "Identifier" ? 8 : 0), this.checkLVal(c, { in: { type: "CatchClause" }, binding: 9 }), c;
    }
    parseTryStatement(c) {
      if (this.next(), c.block = this.parseBlock(), c.handler = null, this.match(62)) {
        let o = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), o.param = this.parseCatchClauseParam(), this.expect(11)) : (o.param = null, this.scope.enter(0)), o.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), c.handler = this.finishNode(o, "CatchClause");
      }
      return c.finalizer = this.eat(67) ? this.parseBlock() : null, !c.handler && !c.finalizer && this.raise(x.NoCatchOrFinally, c), this.finishNode(c, "TryStatement");
    }
    parseVarStatement(c, o, f = !1) {
      return this.next(), this.parseVar(c, !1, o, f), this.semicolon(), this.finishNode(c, "VariableDeclaration");
    }
    parseWhileStatement(c) {
      return this.next(), c.test = this.parseHeaderExpression(), this.state.labels.push(tp), c.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(c, "WhileStatement");
    }
    parseWithStatement(c) {
      return this.state.strict && this.raise(x.StrictWith, this.state.startLoc), this.next(), c.object = this.parseHeaderExpression(), c.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(c, "WithStatement");
    }
    parseEmptyStatement(c) {
      return this.next(), this.finishNode(c, "EmptyStatement");
    }
    parseLabeledStatement(c, o, f, g) {
      for (let E of this.state.labels)
        E.name === o && this.raise(x.LabelRedeclaration, f, { labelName: o });
      let b = ln(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let E = this.state.labels.length - 1; E >= 0; E--) {
        let T = this.state.labels[E];
        if (T.statementStart === c.start)
          T.statementStart = this.state.start, T.kind = b;
        else
          break;
      }
      return this.state.labels.push({ name: o, kind: b, statementStart: this.state.start }), c.body = g & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), c.label = f, this.finishNode(c, "LabeledStatement");
    }
    parseExpressionStatement(c, o, f) {
      return c.expression = o, this.semicolon(), this.finishNode(c, "ExpressionStatement");
    }
    parseBlock(c = !1, o = !0, f) {
      let g = this.startNode();
      return c && this.state.strictErrors.clear(), this.expect(5), o && this.scope.enter(0), this.parseBlockBody(g, c, !1, 8, f), o && this.scope.exit(), this.finishNode(g, "BlockStatement");
    }
    isValidDirective(c) {
      return c.type === "ExpressionStatement" && c.expression.type === "StringLiteral" && !c.expression.extra.parenthesized;
    }
    parseBlockBody(c, o, f, g, b) {
      let E = c.body = [], T = c.directives = [];
      this.parseBlockOrModuleBlockBody(E, o ? T : void 0, f, g, b);
    }
    parseBlockOrModuleBlockBody(c, o, f, g, b) {
      let E = this.state.strict, T = !1, F = !1;
      for (; !this.match(g); ) {
        let N = f ? this.parseModuleItem() : this.parseStatementListItem();
        if (o && !F) {
          if (this.isValidDirective(N)) {
            let $ = this.stmtToDirective(N);
            o.push($), !T && $.value.value === "use strict" && (T = !0, this.setStrict(!0));
            continue;
          }
          F = !0, this.state.strictErrors.clear();
        }
        c.push(N);
      }
      b == null || b.call(this, T), E || this.setStrict(!1), this.next();
    }
    parseFor(c, o) {
      return c.init = o, this.semicolon(!1), c.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), c.update = this.match(11) ? null : this.parseExpression(), this.expect(11), c.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(c, "ForStatement");
    }
    parseForIn(c, o, f) {
      let g = this.match(58);
      return this.next(), g ? f !== null && this.unexpected(f) : c.await = f !== null, o.type === "VariableDeclaration" && o.declarations[0].init != null && (!g || !this.options.annexB || this.state.strict || o.kind !== "var" || o.declarations[0].id.type !== "Identifier") && this.raise(x.ForInOfLoopInitializer, o, { type: g ? "ForInStatement" : "ForOfStatement" }), o.type === "AssignmentPattern" && this.raise(x.InvalidLhs, o, { ancestor: { type: "ForStatement" } }), c.left = o, c.right = g ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), c.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(c, g ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(c, o, f, g = !1) {
      let b = c.declarations = [];
      for (c.kind = f; ; ) {
        let E = this.startNode();
        if (this.parseVarId(E, f), E.init = this.eat(29) ? o ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, E.init === null && !g && (E.id.type !== "Identifier" && !(o && (this.match(58) || this.isContextual(102))) ? this.raise(x.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" }) : f === "const" && !(this.match(58) || this.isContextual(102)) && this.raise(x.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "const" })), b.push(this.finishNode(E, "VariableDeclarator")), !this.eat(12))
          break;
      }
      return c;
    }
    parseVarId(c, o) {
      let f = this.parseBindingAtom();
      this.checkLVal(f, { in: { type: "VariableDeclarator" }, binding: o === "var" ? 5 : 8201 }), c.id = f;
    }
    parseAsyncFunctionExpression(c) {
      return this.parseFunction(c, 8);
    }
    parseFunction(c, o = 0) {
      let f = o & 2, g = !!(o & 1), b = g && !(o & 4), E = !!(o & 8);
      this.initFunction(c, E), this.match(55) && (f && this.raise(x.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), c.generator = !0), g && (c.id = this.parseFunctionId(b));
      let T = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(Gl(E, c.generator)), g || (c.id = this.parseFunctionId()), this.parseFunctionParams(c, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(c, g ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), g && !f && this.registerFunctionStatementId(c), this.state.maybeInArrowParameters = T, c;
    }
    parseFunctionId(c) {
      return c || j(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(c, o) {
      this.expect(10), this.expressionScope.enter(dA()), c.params = this.parseBindingList(11, 41, 2 | (o ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(c) {
      c.id && this.scope.declareName(c.id.name, !this.options.annexB || this.state.strict || c.generator || c.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, c.id.loc.start);
    }
    parseClass(c, o, f) {
      this.next();
      let g = this.state.strict;
      return this.state.strict = !0, this.parseClassId(c, o, f), this.parseClassSuper(c), c.body = this.parseClassBody(!!c.superClass, g), this.finishNode(c, o ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(c) {
      return !c.computed && !c.static && (c.key.name === "constructor" || c.key.value === "constructor");
    }
    parseClassBody(c, o) {
      this.classScope.enter();
      let f = { hadConstructor: !1, hadSuperClass: c }, g = [], b = this.startNode();
      if (b.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (g.length > 0)
              throw this.raise(x.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            g.push(this.parseDecorator());
            continue;
          }
          let E = this.startNode();
          g.length && (E.decorators = g, this.resetStartLocationFromNode(E, g[0]), g = []), this.parseClassMember(b, E, f), E.kind === "constructor" && E.decorators && E.decorators.length > 0 && this.raise(x.DecoratorConstructor, E);
        }
      }), this.state.strict = o, this.next(), g.length)
        throw this.raise(x.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(b, "ClassBody");
    }
    parseClassMemberFromModifier(c, o) {
      let f = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let g = o;
        return g.kind = "method", g.computed = !1, g.key = f, g.static = !1, this.pushClassMethod(c, g, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let g = o;
        return g.computed = !1, g.key = f, g.static = !1, c.body.push(this.parseClassProperty(g)), !0;
      }
      return this.resetPreviousNodeTrailingComments(f), !1;
    }
    parseClassMember(c, o, f) {
      let g = this.isContextual(106);
      if (g) {
        if (this.parseClassMemberFromModifier(c, o))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(c, o);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(c, o, f, g);
    }
    parseClassMemberWithIsStatic(c, o, f, g) {
      let b = o, E = o, T = o, F = o, N = o, $ = b, U = b;
      if (o.static = g, this.parsePropertyNamePrefixOperator(o), this.eat(55)) {
        $.kind = "method";
        let qe = this.match(138);
        if (this.parseClassElementName($), qe) {
          this.pushClassPrivateMethod(c, E, !0, !1);
          return;
        }
        this.isNonstaticConstructor(b) && this.raise(x.ConstructorIsGenerator, b.key), this.pushClassMethod(c, b, !0, !1, !1, !1);
        return;
      }
      let ie = j(this.state.type) && !this.state.containsEsc, ce = this.match(138), oe = this.parseClassElementName(o), Xe = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(U), this.isClassMethod()) {
        if ($.kind = "method", ce) {
          this.pushClassPrivateMethod(c, E, !1, !1);
          return;
        }
        let qe = this.isNonstaticConstructor(b), mt = !1;
        qe && (b.kind = "constructor", f.hadConstructor && !this.hasPlugin("typescript") && this.raise(x.DuplicateConstructor, oe), qe && this.hasPlugin("typescript") && o.override && this.raise(x.OverrideOnConstructor, oe), f.hadConstructor = !0, mt = f.hadSuperClass), this.pushClassMethod(c, b, !1, !1, qe, mt);
      } else if (this.isClassProperty())
        ce ? this.pushClassPrivateProperty(c, F) : this.pushClassProperty(c, T);
      else if (ie && oe.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(oe);
        let qe = this.eat(55);
        U.optional && this.unexpected(Xe), $.kind = "method";
        let mt = this.match(138);
        this.parseClassElementName($), this.parsePostMemberNameModifiers(U), mt ? this.pushClassPrivateMethod(c, E, qe, !0) : (this.isNonstaticConstructor(b) && this.raise(x.ConstructorIsAsync, b.key), this.pushClassMethod(c, b, qe, !0, !1, !1));
      } else if (ie && (oe.name === "get" || oe.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(oe), $.kind = oe.name;
        let qe = this.match(138);
        this.parseClassElementName(b), qe ? this.pushClassPrivateMethod(c, E, !1, !1) : (this.isNonstaticConstructor(b) && this.raise(x.ConstructorIsAccessor, b.key), this.pushClassMethod(c, b, !1, !1, !1, !1)), this.checkGetterSetterParams(b);
      } else if (ie && oe.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(oe);
        let qe = this.match(138);
        this.parseClassElementName(T), this.pushClassAccessorProperty(c, N, qe);
      } else
        this.isLineTerminator() ? ce ? this.pushClassPrivateProperty(c, F) : this.pushClassProperty(c, T) : this.unexpected();
    }
    parseClassElementName(c) {
      let { type: o, value: f } = this.state;
      if ((o === 132 || o === 133) && c.static && f === "prototype" && this.raise(x.StaticPrototype, this.state.startLoc), o === 138) {
        f === "constructor" && this.raise(x.ConstructorClassPrivateField, this.state.startLoc);
        let g = this.parsePrivateName();
        return c.key = g, g;
      }
      return this.parsePropertyName(c);
    }
    parseClassStaticBlock(c, o) {
      var f;
      this.scope.enter(208);
      let g = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let b = o.body = [];
      this.parseBlockOrModuleBlockBody(b, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = g, c.body.push(this.finishNode(o, "StaticBlock")), (f = o.decorators) != null && f.length && this.raise(x.DecoratorStaticBlock, o);
    }
    pushClassProperty(c, o) {
      !o.computed && (o.key.name === "constructor" || o.key.value === "constructor") && this.raise(x.ConstructorClassField, o.key), c.body.push(this.parseClassProperty(o));
    }
    pushClassPrivateProperty(c, o) {
      let f = this.parseClassPrivateProperty(o);
      c.body.push(f), this.classScope.declarePrivateName(this.getPrivateNameSV(f.key), 0, f.key.loc.start);
    }
    pushClassAccessorProperty(c, o, f) {
      if (!f && !o.computed) {
        let b = o.key;
        (b.name === "constructor" || b.value === "constructor") && this.raise(x.ConstructorClassField, b);
      }
      let g = this.parseClassAccessorProperty(o);
      c.body.push(g), f && this.classScope.declarePrivateName(this.getPrivateNameSV(g.key), 0, g.key.loc.start);
    }
    pushClassMethod(c, o, f, g, b, E) {
      c.body.push(this.parseMethod(o, f, g, b, E, "ClassMethod", !0));
    }
    pushClassPrivateMethod(c, o, f, g) {
      let b = this.parseMethod(o, f, g, !1, !1, "ClassPrivateMethod", !0);
      c.body.push(b);
      let E = b.kind === "get" ? b.static ? 6 : 2 : b.kind === "set" ? b.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(b, E);
    }
    declareClassPrivateMethodInScope(c, o) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(c.key), o, c.key.loc.start);
    }
    parsePostMemberNameModifiers(c) {
    }
    parseClassPrivateProperty(c) {
      return this.parseInitializer(c), this.semicolon(), this.finishNode(c, "ClassPrivateProperty");
    }
    parseClassProperty(c) {
      return this.parseInitializer(c), this.semicolon(), this.finishNode(c, "ClassProperty");
    }
    parseClassAccessorProperty(c) {
      return this.parseInitializer(c), this.semicolon(), this.finishNode(c, "ClassAccessorProperty");
    }
    parseInitializer(c) {
      this.scope.enter(80), this.expressionScope.enter(Oy()), this.prodParam.enter(0), c.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(c, o, f, g = 8331) {
      if (j(this.state.type))
        c.id = this.parseIdentifier(), o && this.declareNameFromIdentifier(c.id, g);
      else if (f || !o)
        c.id = null;
      else
        throw this.raise(x.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(c) {
      c.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(c, o) {
      let f = this.parseMaybeImportPhase(c, !0), g = this.maybeParseExportDefaultSpecifier(c, f), b = !g || this.eat(12), E = b && this.eatExportStar(c), T = E && this.maybeParseExportNamespaceSpecifier(c), F = b && (!T || this.eat(12)), N = g || E;
      if (E && !T) {
        if (g && this.unexpected(), o)
          throw this.raise(x.UnsupportedDecoratorExport, c);
        return this.parseExportFrom(c, !0), this.finishNode(c, "ExportAllDeclaration");
      }
      let $ = this.maybeParseExportNamedSpecifiers(c);
      g && b && !E && !$ && this.unexpected(null, 5), T && F && this.unexpected(null, 98);
      let U;
      if (N || $) {
        if (U = !1, o)
          throw this.raise(x.UnsupportedDecoratorExport, c);
        this.parseExportFrom(c, N);
      } else
        U = this.maybeParseExportDeclaration(c);
      if (N || $ || U) {
        var ie;
        let ce = c;
        if (this.checkExport(ce, !0, !1, !!ce.source), ((ie = ce.declaration) == null ? void 0 : ie.type) === "ClassDeclaration")
          this.maybeTakeDecorators(o, ce.declaration, ce);
        else if (o)
          throw this.raise(x.UnsupportedDecoratorExport, c);
        return this.finishNode(ce, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let ce = c, oe = this.parseExportDefaultExpression();
        if (ce.declaration = oe, oe.type === "ClassDeclaration")
          this.maybeTakeDecorators(o, oe, ce);
        else if (o)
          throw this.raise(x.UnsupportedDecoratorExport, c);
        return this.checkExport(ce, !0, !0), this.finishNode(ce, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(c) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(c, o) {
      if (o || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", o == null ? void 0 : o.loc.start);
        let f = o || this.parseIdentifier(!0), g = this.startNodeAtNode(f);
        return g.exported = f, c.specifiers = [this.finishNode(g, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(c) {
      if (this.isContextual(93)) {
        c.specifiers || (c.specifiers = []);
        let o = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), o.exported = this.parseModuleExportName(), c.specifiers.push(this.finishNode(o, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(c) {
      if (this.match(5)) {
        c.specifiers || (c.specifiers = []);
        let o = c.exportKind === "type";
        return c.specifiers.push(...this.parseExportSpecifiers(o)), c.source = null, c.declaration = null, this.hasPlugin("importAssertions") && (c.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(c) {
      return this.shouldParseExportDeclaration() ? (c.specifiers = [], c.source = null, this.hasPlugin("importAssertions") && (c.assertions = []), c.declaration = this.parseExportDeclaration(c), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95))
        return !1;
      let c = this.nextTokenInLineStart();
      return this.isUnparsedContextual(c, "function");
    }
    parseExportDefaultExpression() {
      let c = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(c, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(c, 13);
      if (this.match(80))
        return this.parseClass(c, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(x.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(x.UnsupportedDefaultExport, this.state.startLoc);
      let o = this.parseMaybeAssignAllowIn();
      return this.semicolon(), o;
    }
    parseExportDeclaration(c) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let { type: c } = this.state;
      if (j(c)) {
        if (c === 95 && !this.state.containsEsc || c === 100)
          return !1;
        if ((c === 130 || c === 129) && !this.state.containsEsc) {
          let { type: g } = this.lookahead();
          if (j(g) && g !== 98 || g === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let o = this.nextTokenStart(), f = this.isUnparsedContextual(o, "from");
      if (this.input.charCodeAt(o) === 44 || j(this.state.type) && f)
        return !0;
      if (this.match(65) && f) {
        let g = this.input.charCodeAt(this.nextTokenStartSince(o + 4));
        return g === 34 || g === 39;
      }
      return !1;
    }
    parseExportFrom(c, o) {
      this.eatContextual(98) ? (c.source = this.parseImportSource(), this.checkExport(c), this.maybeParseImportAttributes(c), this.checkJSONModuleImport(c)) : o && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let { type: c } = this.state;
      return c === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(x.DecoratorBeforeExport, this.state.startLoc), !0) : c === 74 || c === 75 || c === 68 || c === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(c, o, f, g) {
      if (o) {
        var b;
        if (f) {
          if (this.checkDuplicateExports(c, "default"), this.hasPlugin("exportDefaultFrom")) {
            var E;
            let T = c.declaration;
            T.type === "Identifier" && T.name === "from" && T.end - T.start === 4 && !((E = T.extra) != null && E.parenthesized) && this.raise(x.ExportDefaultFromAsIdentifier, T);
          }
        } else if ((b = c.specifiers) != null && b.length)
          for (let T of c.specifiers) {
            let { exported: F } = T, N = F.type === "Identifier" ? F.name : F.value;
            if (this.checkDuplicateExports(T, N), !g && T.local) {
              let { local: $ } = T;
              $.type !== "Identifier" ? this.raise(x.ExportBindingIsString, T, { localName: $.value, exportName: N }) : (this.checkReservedWord($.name, $.loc.start, !0, !1), this.scope.checkLocalExport($));
            }
          }
        else if (c.declaration) {
          if (c.declaration.type === "FunctionDeclaration" || c.declaration.type === "ClassDeclaration") {
            let T = c.declaration.id;
            if (!T)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(c, T.name);
          } else if (c.declaration.type === "VariableDeclaration")
            for (let T of c.declaration.declarations)
              this.checkDeclaration(T.id);
        }
      }
    }
    checkDeclaration(c) {
      if (c.type === "Identifier")
        this.checkDuplicateExports(c, c.name);
      else if (c.type === "ObjectPattern")
        for (let o of c.properties)
          this.checkDeclaration(o);
      else if (c.type === "ArrayPattern")
        for (let o of c.elements)
          o && this.checkDeclaration(o);
      else
        c.type === "ObjectProperty" ? this.checkDeclaration(c.value) : c.type === "RestElement" ? this.checkDeclaration(c.argument) : c.type === "AssignmentPattern" && this.checkDeclaration(c.left);
    }
    checkDuplicateExports(c, o) {
      this.exportedIdentifiers.has(o) && (o === "default" ? this.raise(x.DuplicateDefaultExport, c) : this.raise(x.DuplicateExport, c, { exportName: o })), this.exportedIdentifiers.add(o);
    }
    parseExportSpecifiers(c) {
      let o = [], f = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (f)
          f = !1;
        else if (this.expect(12), this.eat(8))
          break;
        let g = this.isContextual(130), b = this.match(133), E = this.startNode();
        E.local = this.parseModuleExportName(), o.push(this.parseExportSpecifier(E, b, c, g));
      }
      return o;
    }
    parseExportSpecifier(c, o, f, g) {
      return this.eatContextual(93) ? c.exported = this.parseModuleExportName() : o ? c.exported = xA(c.local) : c.exported || (c.exported = Zi(c.local)), this.finishNode(c, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        let c = this.parseStringLiteral(this.state.value), o = c.value.match(UA);
        return o && this.raise(x.ModuleExportNameHasLoneSurrogate, c, { surrogateCharCode: o[0].charCodeAt(0) }), c;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(c) {
      return c.assertions != null ? c.assertions.some(({ key: o, value: f }) => f.value === "json" && (o.type === "Identifier" ? o.name === "type" : o.value === "type")) : !1;
    }
    checkImportReflection(c) {
      let { specifiers: o } = c, f = o.length === 1 ? o[0].type : null;
      if (c.phase === "source")
        f !== "ImportDefaultSpecifier" && this.raise(x.SourcePhaseImportRequiresDefault, o[0].loc.start);
      else if (c.phase === "defer")
        f !== "ImportNamespaceSpecifier" && this.raise(x.DeferImportRequiresNamespace, o[0].loc.start);
      else if (c.module) {
        var g;
        f !== "ImportDefaultSpecifier" && this.raise(x.ImportReflectionNotBinding, o[0].loc.start), ((g = c.assertions) == null ? void 0 : g.length) > 0 && this.raise(x.ImportReflectionHasAssertion, o[0].loc.start);
      }
    }
    checkJSONModuleImport(c) {
      if (this.isJSONModuleImport(c) && c.type !== "ExportAllDeclaration") {
        let { specifiers: o } = c;
        if (o != null) {
          let f = o.find((g) => {
            let b;
            if (g.type === "ExportSpecifier" ? b = g.local : g.type === "ImportSpecifier" && (b = g.imported), b !== void 0)
              return b.type === "Identifier" ? b.name !== "default" : b.value !== "default";
          });
          f !== void 0 && this.raise(x.ImportJSONBindingNotDefault, f.loc.start);
        }
      }
    }
    isPotentialImportPhase(c) {
      return c ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(c, o, f, g) {
      o || (f === "module" ? (this.expectPlugin("importReflection", g), c.module = !0) : this.hasPlugin("importReflection") && (c.module = !1), f === "source" ? (this.expectPlugin("sourcePhaseImports", g), c.phase = "source") : f === "defer" ? (this.expectPlugin("deferredImportEvaluation", g), c.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (c.phase = null));
    }
    parseMaybeImportPhase(c, o) {
      if (!this.isPotentialImportPhase(o))
        return this.applyImportPhase(c, o, null), null;
      let f = this.parseIdentifier(!0), { type: g } = this.state;
      return (De(g) ? g !== 98 || this.lookaheadCharCode() === 102 : g !== 12) ? (this.resetPreviousIdentifierLeadingComments(f), this.applyImportPhase(c, o, f.name, f.loc.start), null) : (this.applyImportPhase(c, o, null), f);
    }
    isPrecedingIdImportPhase(c) {
      let { type: o } = this.state;
      return j(o) ? o !== 98 || this.lookaheadCharCode() === 102 : o !== 12;
    }
    parseImport(c) {
      return this.match(133) ? this.parseImportSourceAndAttributes(c) : this.parseImportSpecifiersAndAfter(c, this.parseMaybeImportPhase(c, !1));
    }
    parseImportSpecifiersAndAfter(c, o) {
      c.specifiers = [];
      let f = !this.maybeParseDefaultImportSpecifier(c, o) || this.eat(12), g = f && this.maybeParseStarImportSpecifier(c);
      return f && !g && this.parseNamedImportSpecifiers(c), this.expectContextual(98), this.parseImportSourceAndAttributes(c);
    }
    parseImportSourceAndAttributes(c) {
      return c.specifiers != null || (c.specifiers = []), c.source = this.parseImportSource(), this.maybeParseImportAttributes(c), this.checkImportReflection(c), this.checkJSONModuleImport(c), this.semicolon(), this.finishNode(c, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(c, o, f) {
      o.local = this.parseIdentifier(), c.specifiers.push(this.finishImportSpecifier(o, f));
    }
    finishImportSpecifier(c, o, f = 8201) {
      return this.checkLVal(c.local, { in: { type: o }, binding: f }), this.finishNode(c, o);
    }
    parseImportAttributes() {
      this.expect(5);
      let c = [], o = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let f = this.startNode(), g = this.state.value;
        if (o.has(g) && this.raise(x.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: g }), o.add(g), this.match(133) ? f.key = this.parseStringLiteral(g) : f.key = this.parseIdentifier(!0), this.expect(14), !this.match(133))
          throw this.raise(x.ModuleAttributeInvalidValue, this.state.startLoc);
        f.value = this.parseStringLiteral(this.state.value), c.push(this.finishNode(f, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), c;
    }
    parseModuleAttributes() {
      let c = [], o = /* @__PURE__ */ new Set();
      do {
        let f = this.startNode();
        if (f.key = this.parseIdentifier(!0), f.key.name !== "type" && this.raise(x.ModuleAttributeDifferentFromType, f.key), o.has(f.key.name) && this.raise(x.ModuleAttributesWithDuplicateKeys, f.key, { key: f.key.name }), o.add(f.key.name), this.expect(14), !this.match(133))
          throw this.raise(x.ModuleAttributeInvalidValue, this.state.startLoc);
        f.value = this.parseStringLiteral(this.state.value), c.push(this.finishNode(f, "ImportAttribute"));
      } while (this.eat(12));
      return c;
    }
    maybeParseImportAttributes(c) {
      let o, f = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? o = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), o = this.parseImportAttributes()), f = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(x.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(c, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), o = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        o = [];
      else if (this.hasPlugin("moduleAttributes"))
        o = [];
      else
        return;
      !f && this.hasPlugin("importAssertions") ? c.assertions = o : c.attributes = o;
    }
    maybeParseDefaultImportSpecifier(c, o) {
      if (o) {
        let f = this.startNodeAtNode(o);
        return f.local = o, c.specifiers.push(this.finishImportSpecifier(f, "ImportDefaultSpecifier")), !0;
      } else if (De(this.state.type))
        return this.parseImportSpecifierLocal(c, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(c) {
      if (this.match(55)) {
        let o = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(c, o, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(c) {
      let o = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (o)
          o = !1;
        else {
          if (this.eat(14))
            throw this.raise(x.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8))
            break;
        }
        let f = this.startNode(), g = this.match(133), b = this.isContextual(130);
        f.imported = this.parseModuleExportName();
        let E = this.parseImportSpecifier(f, g, c.importKind === "type" || c.importKind === "typeof", b, void 0);
        c.specifiers.push(E);
      }
    }
    parseImportSpecifier(c, o, f, g, b) {
      if (this.eatContextual(93))
        c.local = this.parseIdentifier();
      else {
        let { imported: E } = c;
        if (o)
          throw this.raise(x.ImportBindingIsString, c, { importName: E.value });
        this.checkReservedWord(E.name, c.loc.start, !0, !0), c.local || (c.local = Zi(E));
      }
      return this.finishImportSpecifier(c, "ImportSpecifier", b);
    }
    isThisParam(c) {
      return c.type === "Identifier" && c.name === "this";
    }
  }, Py = class extends zA {
    constructor(c, o) {
      c = qA(c), super(c, o), this.options = c, this.initializeScopes(), this.plugins = GA(this.options.plugins), this.filename = c.sourceFilename;
    }
    getScopeHandler() {
      return Gh;
    }
    parse() {
      this.enterInitialScopes();
      let c = this.startNode(), o = this.startNode();
      return this.nextToken(), c.errors = null, this.parseTopLevel(c, o), c.errors = this.state.errors, c.comments.length = this.state.commentsLen, c;
    }
  };
  function GA(c) {
    let o = /* @__PURE__ */ new Map();
    for (let f of c) {
      let [g, b] = Array.isArray(f) ? f : [f, {}];
      o.has(g) || o.set(g, b || {});
    }
    return o;
  }
  function HA(c, o) {
    var f;
    if (((f = o) == null ? void 0 : f.sourceType) === "unambiguous") {
      o = Object.assign({}, o);
      try {
        o.sourceType = "module";
        let g = to(o, c), b = g.parse();
        if (g.sawUnambiguousESM)
          return b;
        if (g.ambiguousScriptDifferentAst)
          try {
            return o.sourceType = "script", to(o, c).parse();
          } catch {
          }
        else
          b.program.sourceType = "script";
        return b;
      } catch (g) {
        try {
          return o.sourceType = "script", to(o, c).parse();
        } catch {
        }
        throw g;
      }
    } else
      return to(o, c).parse();
  }
  function JA(c, o) {
    let f = to(o, c);
    return f.options.strictMode && (f.state.strict = !0), f.getExpression();
  }
  function KA(c) {
    let o = {};
    for (let f of Object.keys(c))
      o[f] = Vr(c[f]);
    return o;
  }
  var ek = KA(W);
  function to(c, o) {
    let f = Py;
    return c != null && c.plugins && (ZA(c.plugins), f = tk(c.plugins)), new f(c, o);
  }
  var Fy = {};
  function tk(c) {
    let o = WA.filter((b) => pt(c, b)), f = o.join("/"), g = Fy[f];
    if (!g) {
      g = Py;
      for (let b of o)
        g = Ty[b](g);
      Fy[f] = g;
    }
    return g;
  }
  t.parse = HA, t.parseExpression = JA, t.tokTypes = ek;
}), dL = xw((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = p, t.parse = m, t.parseWithComments = y, t.print = O, t.strip = d;
  var e = /\*\/$/, r = /^\/\*\*?/, i = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, n = /(^|\s+)\/\/([^\r\n]*)/g, s = /^(\r?\n)+/, a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, l = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, u = /(\r?\n|^) *\* ?/g, h = [];
  function p(v) {
    let w = v.match(i);
    return w ? w[0].trimLeft() : "";
  }
  function d(v) {
    let w = v.match(i);
    return w && w[0] ? v.substring(w[0].length) : v;
  }
  function m(v) {
    return y(v).pragmas;
  }
  function y(v) {
    let w = `
`;
    v = v.replace(r, "").replace(e, "").replace(u, "$1");
    let x = "";
    for (; x !== v; )
      x = v, v = v.replace(a, `${w}$1 $2${w}`);
    v = v.replace(s, "").trimRight();
    let S = /* @__PURE__ */ Object.create(null), k = v.replace(l, "").replace(s, "").trimRight(), C;
    for (; C = l.exec(v); ) {
      let A = C[2].replace(n, "");
      typeof S[C[1]] == "string" || Array.isArray(S[C[1]]) ? S[C[1]] = h.concat(S[C[1]], A) : S[C[1]] = A;
    }
    return { comments: k, pragmas: S };
  }
  function O({ comments: v = "", pragmas: w = {} }) {
    let x = `
`, S = "/**", k = " *", C = " */", A = Object.keys(w), P = A.flatMap((B) => D(B, w[B])).map((B) => `${k} ${B}${x}`).join("");
    if (!v) {
      if (A.length === 0)
        return "";
      if (A.length === 1 && !Array.isArray(w[A[0]])) {
        let B = w[A[0]];
        return `${S} ${D(A[0], B)[0]}${C}`;
      }
    }
    let I = v.split(x).map((B) => `${k} ${B}`).join(x) + x;
    return S + x + (v ? I : "") + (v && A.length ? k + x : "") + P + C;
  }
  function D(v, w) {
    return h.concat(w).map((x) => `@${v} ${x}`.trim());
  }
}), vw = {};
hL(vw, { parsers: () => cQ });
var l1 = Ag(Dw(), 1);
function ww(t) {
  return (e, r, i) => {
    let n = !!(i != null && i.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, a = r;
    for (; a >= 0 && a < s; ) {
      let l = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(l))
          return a;
      } else if (!t.includes(l))
        return a;
      n ? a-- : a++;
    }
    return a === -1 || a === s ? a : !1;
  };
}
var fL = ww(" 	"), mL = ww(/[^\n\r]/);
function gL(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var yL = gL;
function OL(t, e, r) {
  let i = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let n = t.charAt(e);
  if (i) {
    if (t.charAt(e - 1) === "\r" && n === `
`)
      return e - 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e - 1;
  } else {
    if (n === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e + 1;
  }
  return e;
}
var xL = OL;
function DL(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? mL(t, e) : e;
}
var bL = DL;
function vL(t, e) {
  let r = null, i = e;
  for (; i !== r; )
    r = i, i = fL(t, i), i = yL(t, i), i = bL(t, i), i = xL(t, i);
  return i;
}
var wL = vL;
function SL(t) {
  let e = [];
  for (let r of t)
    try {
      return r();
    } catch (i) {
      e.push(i);
    }
  throw Object.assign(new Error("All combinations failed"), { errors: e });
}
var CL = SL;
function EL(t) {
  if (!t.startsWith("#!"))
    return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var Sw = EL, AL = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, u1 = AL;
function kL(t) {
  return Array.isArray(t) && t.length > 0;
}
var kg = kL;
function Hr(t) {
  var e, r, i;
  let n = ((e = t.range) == null ? void 0 : e[0]) ?? t.start, s = (i = ((r = t.declaration) == null ? void 0 : r.decorators) ?? t.decorators) == null ? void 0 : i[0];
  return s ? Math.min(Hr(s), n) : n;
}
function bn(t) {
  var e;
  return ((e = t.range) == null ? void 0 : e[1]) ?? t.end;
}
function TL(t) {
  let e = new Set(t);
  return (r) => e.has(r == null ? void 0 : r.type);
}
var PL = TL, FL = PL(["Block", "CommentBlock", "MultiLine"]), Vd = FL;
function $L(t) {
  let e = `*${t.value}*`.split(`
`);
  return e.length > 1 && e.every((r) => r.trimStart()[0] === "*");
}
var c1 = $L;
function BL(t) {
  return Vd(t) && t.value[0] === "*" && /@(?:type|satisfies)\b/.test(t.value);
}
var IL = BL, co = null;
function Qo(t) {
  if (co !== null && typeof co.property) {
    let e = co;
    return co = Qo.prototype = null, e;
  }
  return co = Qo.prototype = t ?? /* @__PURE__ */ Object.create(null), new Qo();
}
var NL = 10;
for (let t = 0; t <= NL; t++)
  Qo();
function _L(t) {
  return Qo(t);
}
function ML(t, e = "type") {
  _L(t);
  function r(i) {
    let n = i[e], s = t[n];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: i });
    return s;
  }
  return r;
}
var LL = ML, QL = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value", "optional", "static", "method"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareEnum: ["id", "body"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], AsConstExpression: ["expression"], SatisfiesExpression: ["expression", "typeAnnotation"] }, jL = LL(QL), RL = jL;
function Ud(t, e) {
  if (!(t !== null && typeof t == "object"))
    return t;
  if (Array.isArray(t)) {
    for (let i = 0; i < t.length; i++)
      t[i] = Ud(t[i], e);
    return t;
  }
  let r = RL(t);
  for (let i = 0; i < r.length; i++)
    t[r[i]] = Ud(t[r[i]], e);
  return e(t) || t;
}
var Bp = Ud;
function ZL(t, e) {
  let { parser: r, text: i } = e;
  if (t.type === "File" && t.program.interpreter) {
    let { program: { interpreter: n }, comments: s } = t;
    delete t.program.interpreter, s.unshift(n);
  }
  if (r === "babel") {
    let n = /* @__PURE__ */ new Set();
    t = Bp(t, (s) => {
      var a;
      (a = s.leadingComments) != null && a.some(IL) && n.add(Hr(s));
    }), t = Bp(t, (s) => {
      if (s.type === "ParenthesizedExpression") {
        let { expression: a } = s;
        if (a.type === "TypeCastExpression")
          return a.range = [...s.range], a;
        let l = Hr(s);
        if (!n.has(l))
          return a.extra = { ...a.extra, parenthesized: !0 }, a;
      }
    });
  }
  if (t = Bp(t, (n) => {
    var s;
    switch (n.type) {
      case "LogicalExpression":
        if (Cw(n))
          return Yd(n);
        break;
      case "VariableDeclaration": {
        let a = u1(!1, n.declarations, -1);
        a != null && a.init && i[bn(a)] !== ";" && (n.range = [Hr(n), bn(a)]);
        break;
      }
      case "TSParenthesizedType":
        return n.typeAnnotation;
      case "TSTypeParameter":
        if (typeof n.name == "string") {
          let a = Hr(n);
          n.name = { type: "Identifier", name: n.name, range: [a, a + n.name.length] };
        }
        break;
      case "TopicReference":
        t.extra = { ...t.extra, __isUsingHackPipeline: !0 };
        break;
      case "ExportAllDeclaration":
        if (r === "meriyah" && ((s = n.exported) == null ? void 0 : s.type) === "Identifier") {
          let { exported: a } = n, l = i.slice(Hr(a), bn(a));
          (l.startsWith('"') || l.startsWith("'")) && (n.exported = { ...n.exported, type: "Literal", value: n.exported.name, raw: l });
        }
        break;
      case "TSUnionType":
      case "TSIntersectionType":
        if (n.types.length === 1)
          return n.types[0];
        break;
    }
  }), kg(t.comments)) {
    let n = u1(!1, t.comments, -1);
    for (let s = t.comments.length - 2; s >= 0; s--) {
      let a = t.comments[s];
      bn(a) === Hr(n) && Vd(a) && Vd(n) && c1(a) && c1(n) && (t.comments.splice(s + 1, 1), a.value += "*//*" + n.value, a.range = [Hr(a), bn(n)]), n = a;
    }
  }
  return t.type === "Program" && (t.range = [0, i.length]), t;
}
function Cw(t) {
  return t.type === "LogicalExpression" && t.right.type === "LogicalExpression" && t.operator === t.right.operator;
}
function Yd(t) {
  return Cw(t) ? Yd({ type: "LogicalExpression", operator: t.operator, left: Yd({ type: "LogicalExpression", operator: t.operator, left: t.left, right: t.right.left, range: [Hr(t.left), bn(t.right.left)] }), right: t.right.right, range: [Hr(t), bn(t)] }) : t;
}
var WL = ZL;
function qL(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var Ew = qL;
function XL(t) {
  let { message: e, loc: { line: r, column: i }, reasonCode: n } = t, s = t;
  (n === "MissingPlugin" || n === "MissingOneOfPlugins") && (e = "Unexpected token.", s = void 0);
  let a = ` (${r}:${i})`;
  return e.endsWith(a) && (e = e.slice(0, -a.length)), Ew(e, { loc: { start: { line: r, column: i + 1 } }, cause: s });
}
var Aw = XL, h1 = Ag(dL(), 1);
function VL(t) {
  let e = Sw(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, h1.extract)(t), { pragmas: i, comments: n } = (0, h1.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: i, comments: n };
}
function UL(t) {
  let { pragmas: e } = VL(t);
  return Object.prototype.hasOwnProperty.call(e, "prettier") || Object.prototype.hasOwnProperty.call(e, "format");
}
function YL(t) {
  return t = typeof t == "function" ? { parse: t } : t, { astFormat: "estree", hasPragma: UL, locStart: Hr, locEnd: bn, ...t };
}
var vo = YL;
function zL(t) {
  let { filepath: e } = t;
  if (e) {
    if (e = e.toLowerCase(), e.endsWith(".cjs"))
      return "script";
    if (e.endsWith(".mjs"))
      return "module";
  }
}
var GL = zL;
function HL(t, e) {
  let { type: r = "JsExpressionRoot", rootMarker: i, text: n } = e, { tokens: s, comments: a } = t;
  return delete t.tokens, delete t.comments, { tokens: s, comments: a, type: r, node: t, range: [0, n.length], rootMarker: i };
}
var kw = HL, Xa = (t) => vo(iQ(t)), JL = { sourceType: "module", allowImportExportEverywhere: !0, allowReturnOutsideFunction: !0, allowNewTargetOutsideFunction: !0, allowSuperOutsideMethod: !0, allowUndeclaredExports: !0, errorRecovery: !0, createParenthesizedExpressions: !0, createImportExpressions: !0, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", "decorators", "decimal", "moduleBlocks", "asyncDoExpressions", "regexpUnicodeSets", "destructuringPrivate", "decoratorAutoAccessors", "importReflection", "explicitResourceManagement", ["importAttributes", { deprecatedAssertSyntax: !0 }], "sourcePhaseImports", "deferredImportEvaluation", ["optionalChainingAssign", { version: "2023-07" }]], tokens: !0, ranges: !0 }, KL = ["recordAndTuple", { syntaxType: "hash" }], p1 = "v8intrinsic", d1 = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], Ei = (t, e = JL) => ({ ...e, plugins: [...e.plugins, ...t] }), eQ = /@(?:no)?flow\b/;
function tQ(t, e) {
  var r;
  if ((r = e.filepath) != null && r.endsWith(".js.flow"))
    return !0;
  let i = Sw(t);
  i && (t = t.slice(i.length));
  let n = wL(t, 0);
  return n !== !1 && (t = t.slice(0, n)), eQ.test(t);
}
function rQ(t, e, r) {
  let i = t(e, r), n = i.errors.find((s) => !nQ.has(s.reasonCode));
  if (n)
    throw n;
  return i;
}
function iQ({ isExpression: t = !1, optionsCombinations: e }) {
  return (r, i = {}) => {
    if ((i.parser === "babel" || i.parser === "__babel_estree") && tQ(r, i))
      return i.parser = "babel-flow", Pw.parse(r, i);
    let n = e;
    (i.__babelSourceType ?? GL(i)) === "script" && (n = n.map((u) => ({ ...u, sourceType: "script" }))), /#[[{]/.test(r) && (n = n.map((u) => Ei([KL], u)));
    let s = /%[A-Z]/.test(r);
    r.includes("|>") ? n = (s ? [...d1, p1] : d1).flatMap((u) => n.map((h) => Ei([u], h))) : s && (n = n.map((u) => Ei([p1], u)));
    let a = t ? l1.parseExpression : l1.parse, l;
    try {
      l = CL(n.map((u) => () => rQ(a, r, u)));
    } catch ({ errors: [u] }) {
      throw Aw(u);
    }
    return t && (l = kw(l, { text: r, rootMarker: i.rootMarker })), WL(l, { parser: "babel", text: r });
  };
}
var nQ = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "DuplicateAccessibilityModifier", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), Tw = [Ei(["jsx"])], f1 = Xa({ optionsCombinations: Tw }), m1 = Xa({ optionsCombinations: [Ei(["jsx", "typescript"]), Ei(["typescript"])] }), g1 = Xa({ isExpression: !0, optionsCombinations: [Ei(["jsx"])] }), y1 = Xa({ isExpression: !0, optionsCombinations: [Ei(["typescript"])] }), Pw = Xa({ optionsCombinations: [Ei(["jsx", ["flow", { all: !0, enums: !0 }], "flowComments"])] }), sQ = Xa({ optionsCombinations: Tw.map((t) => Ei(["estree"], t)) }), aQ = { babel: f1, "babel-flow": Pw, "babel-ts": m1, __js_expression: g1, __ts_expression: y1, __vue_expression: g1, __vue_ts_expression: y1, __vue_event_binding: f1, __vue_ts_event_binding: m1, __babel_estree: sQ }, oQ = Ag(Dw(), 1);
function Fw(t = {}) {
  let { allowComments: e = !0 } = t;
  return function(r) {
    let i;
    try {
      i = (0, oQ.parseExpression)(r, { tokens: !0, ranges: !0, attachComment: !1 });
    } catch (n) {
      throw Aw(n);
    }
    if (!e && kg(i.comments))
      throw On(i.comments[0], "Comment");
    return ra(i), kw(i, { type: "JsonRoot", text: r });
  };
}
function On(t, e) {
  let [r, i] = [t.loc.start, t.loc.end].map(({ line: n, column: s }) => ({ line: n, column: s + 1 }));
  return Ew(`${e} is not allowed in JSON.`, { loc: { start: r, end: i } });
}
function ra(t) {
  switch (t.type) {
    case "ArrayExpression":
      for (let e of t.elements)
        e !== null && ra(e);
      return;
    case "ObjectExpression":
      for (let e of t.properties)
        ra(e);
      return;
    case "ObjectProperty":
      if (t.computed)
        throw On(t.key, "Computed key");
      if (t.shorthand)
        throw On(t.key, "Shorthand property");
      t.key.type !== "Identifier" && ra(t.key), ra(t.value);
      return;
    case "UnaryExpression": {
      let { operator: e, argument: r } = t;
      if (e !== "+" && e !== "-")
        throw On(t, `Operator '${t.operator}'`);
      if (r.type === "NumericLiteral" || r.type === "Identifier" && (r.name === "Infinity" || r.name === "NaN"))
        return;
      throw On(r, `Operator '${e}' before '${r.type}'`);
    }
    case "Identifier":
      if (t.name !== "Infinity" && t.name !== "NaN" && t.name !== "undefined")
        throw On(t, `Identifier '${t.name}'`);
      return;
    case "TemplateLiteral":
      if (kg(t.expressions))
        throw On(t.expressions[0], "'TemplateLiteral' with expression");
      for (let e of t.quasis)
        ra(e);
      return;
    case "NullLiteral":
    case "BooleanLiteral":
    case "NumericLiteral":
    case "StringLiteral":
    case "TemplateElement":
      return;
    default:
      throw On(t, `'${t.type}'`);
  }
}
var Ip = Fw(), lQ = { json: vo({ parse: Ip, hasPragma() {
  return !0;
} }), json5: vo(Ip), jsonc: vo(Ip), "json-stringify": vo({ parse: Fw({ allowComments: !1 }), astFormat: "estree-json" }) }, uQ = lQ, cQ = { ...aQ, ...uQ }, hQ = vw;
const pQ = async (t, e) => {
  if (!bx(e))
    return t;
  const r = e === "js" ? "babel" : e;
  return await $F.format(t, {
    parser: r,
    plugins: [c7, k8, sL, hQ],
    tabWidth: 2,
    htmlWhitespaceSensitivity: "ignore"
  });
}, $w = (t, e = { mustBeOpen: !0 }) => Object.values(t).filter((r) => !e.mustBeOpen || r.open && e.mustBeOpen).sort((r, i) => r.name.localeCompare(i.name)), Ge = {
  REPLACE_PROJECT: "REPLACE_PROJECT",
  NEW_FILE: "NEW_FILE",
  RENAME_FILE: "RENAME_FILE",
  SAVE_FILE: "SAVE_FILE",
  OPEN_FILE: "OPEN_FILE",
  ACTIVATE_FILE: "ACTIVATE_FILE",
  MOVE_FILE: "MOVE_FILE",
  CLOSE_FILE: "CLOSE_FILE",
  DELETE_FILE: "DELETE_FILE",
  NEW_FOLDER: "NEW_FOLDER",
  TOGGLE_OPEN_FOLDER: "TOGGLE_OPEN_FOLDER",
  DELETE_FOLDER: "DELETE_FOLDER",
  RENAME_FOLDER: "RENAME_FOLDER"
}, dQ = "Add your changes to ${fileName}", fQ = (t) => String(Math.max(...t.map((e) => Number(e.id))) + 1), mQ = (t) => String(Math.max(...t.map((e) => Number(e.id))) + 1), Tg = (t, e) => e.reduce((r, i) => (i.parentId === t && r.push(i.id, ...Tg(i.id, e)), r), []), gQ = (t, e, r) => {
  const i = new Set(
    r ? [t, ...Tg(t, r)] : [t]
  );
  return e.reduce((n, s) => (i.has(s.folderId) && n.push(s.id), n), []);
}, yQ = (t) => xx(() => {
  const e = {
    replaceProject: (r, i) => {
      t({
        type: Ge.REPLACE_PROJECT,
        payload: { project: r, shouldNotifyProjectUpdate: i }
      });
    },
    newFile: ({
      fileId: r,
      fileName: i,
      folderId: n = cs,
      contents: s = dQ
    }) => {
      t({
        type: Ge.NEW_FILE,
        payload: {
          fileId: r,
          fileName: i,
          folderId: n,
          contents: s.replace(/\${fileName}/g, i)
        }
      }), e.setActiveFile(r);
    },
    renameFile: (r, i) => {
      t({
        type: Ge.RENAME_FILE,
        payload: { fileId: r, newName: i }
      });
    },
    saveFile: (r, i) => {
      t({
        type: Ge.SAVE_FILE,
        payload: { fileId: r, contents: i }
      });
    },
    openFile: (r) => {
      t({
        type: Ge.OPEN_FILE,
        payload: { fileId: r }
      });
    },
    closeFile: (r) => {
      t({
        type: Ge.CLOSE_FILE,
        payload: { fileId: r }
      });
    },
    deleteFile: (r) => {
      t({
        type: Ge.DELETE_FILE,
        payload: { fileId: r }
      });
    },
    setActiveFile: (r) => {
      t({
        type: Ge.ACTIVATE_FILE,
        payload: { fileId: r }
      });
    },
    moveFile: (r, i) => {
      t({
        type: Ge.MOVE_FILE,
        payload: { fileId: r, folderId: i }
      });
    },
    newFolder: ({
      folderId: r,
      folderName: i,
      parentId: n = cs
    }) => {
      t({
        type: Ge.NEW_FOLDER,
        payload: { folderId: r, folderName: i, parentId: n }
      });
    },
    renameFolder: (r, i) => {
      t({
        type: Ge.RENAME_FOLDER,
        payload: { folderId: r, newName: i }
      });
    },
    toggleOpenFolder: (r) => {
      t({
        type: Ge.TOGGLE_OPEN_FOLDER,
        payload: { folderId: r }
      });
    },
    deleteFolder: (r) => {
      t({
        type: Ge.DELETE_FOLDER,
        payload: { folderId: r }
      });
    }
  };
  return e;
}, [t]), OQ = (t, e) => {
  var r;
  switch (e.type) {
    case Ge.REPLACE_PROJECT: {
      const {
        project: i,
        shouldNotifyProjectUpdate: n
      } = e.payload;
      return t !== i && (n.current = !1), i;
    }
    case Ge.NEW_FILE: {
      const { fileId: i, fileName: n, folderId: s, contents: a = "" } = e.payload, l = { ...t, files: { ...t.files } }, [u, h] = n.split(".");
      return l.files[i] = {
        id: i,
        name: n,
        language: h || "html",
        contents: a,
        folderId: s
      }, l;
    }
    case Ge.RENAME_FILE: {
      const { fileId: i, newName: n } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [i]: { ...t.files[i], name: n }
        }
      };
    }
    case Ge.SAVE_FILE: {
      const { fileId: i, contents: n } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [i]: { ...t.files[i], contents: n }
        }
      };
    }
    case Ge.OPEN_FILE:
    case Ge.ACTIVATE_FILE: {
      const { fileId: i } = e.payload, n = (r = Object.values(t.files).filter(
        (a) => a.active
      )) == null ? void 0 : r[0];
      if ((n == null ? void 0 : n.id) === i)
        return t;
      const s = {
        ...t,
        files: {
          ...t.files,
          [i]: { ...t.files[i], active: !0, open: !0 }
        }
      };
      return n && (s.files[n.id].active = !1), s;
    }
    case Ge.CLOSE_FILE: {
      const { fileId: i } = e.payload, n = t.files[i], s = {
        ...t,
        files: {
          ...t.files,
          [i]: { ...t.files[i], open: !1, active: !1 }
        }
      };
      if (n.active) {
        const a = $w(t.files, {
          mustBeOpen: !0
        }), l = a.findIndex((h) => h.id === n.id);
        let u;
        l > 0 ? u = a[l - 1].id : l < a.length - 1 && (u = a[l + 1].id), u && (s.files[u] = {
          ...s.files[u],
          active: !0
        });
      }
      return s;
    }
    case Ge.DELETE_FILE: {
      const { fileId: i } = e.payload, n = {
        ...t,
        files: {
          ...t.files
        }
      };
      return delete n.files[i], n;
    }
    case Ge.MOVE_FILE: {
      const { fileId: i, folderId: n } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [i]: { ...t.files[i], folderId: n }
        }
      };
    }
    case Ge.NEW_FOLDER: {
      const { folderId: i, folderName: n, parentId: s } = e.payload, a = { ...t, folders: { ...t.folders } };
      return a.folders[i] = {
        id: i,
        name: n,
        parentId: s
      }, a;
    }
    case Ge.TOGGLE_OPEN_FOLDER: {
      const { folderId: i } = e.payload;
      return {
        ...t,
        folders: {
          ...t.folders,
          [i]: {
            ...t.folders[i],
            open: !t.folders[i].open
          }
        }
      };
    }
    case Ge.DELETE_FOLDER: {
      const { folderId: i } = e.payload, n = {
        ...t,
        folders: {
          ...t.folders
        }
      }, s = new Set(
        Tg(i, Object.values(t.folders))
      ), a = new Set(
        gQ(
          i,
          Object.values(t.files),
          Object.values(t.folders)
        )
      );
      return delete n.folders[i], Object.values(n.folders).filter((l) => s.has(l.id)).forEach((l) => delete n.folders[l.id]), a.size && (n.files = { ...n.files }, Object.values(n.files).filter((l) => a.has(l.id)).forEach((l) => delete n.files[l.id])), n;
    }
    case Ge.RENAME_FOLDER: {
      const { folderId: i, newName: n } = e.payload;
      return {
        ...t,
        folders: {
          ...t.folders,
          [i]: { ...t.folders[i], name: n }
        }
      };
    }
    default:
      return t;
  }
}, xQ = ({ setActivePane: t, activePane: e }) => {
  const {
    config: { leftNav: r }
  } = Cr();
  return /* @__PURE__ */ z.jsx("div", { className: "nav-bar", children: r.map((i) => /* @__PURE__ */ z.jsx(
    "div",
    {
      onClick: () => t(i.component),
      style: {
        cursor: "pointer",
        backgroundColor: i.component === e ? "#666" : ""
      },
      children: /* @__PURE__ */ z.jsx("i", { className: `fa-regular fa-2xl ${i.icon}` })
    },
    i.icon
  )) });
}, DQ = () => {
  const {
    config: { sideBar: t }
  } = Cr();
  return /* @__PURE__ */ z.jsx("div", { className: "left-side-bar", children: t.map((e) => /* @__PURE__ */ z.jsx(
    "div",
    {
      onClick: () => alert("not implemented"),
      style: { cursor: "pointer" },
      children: /* @__PURE__ */ z.jsx("i", { className: `fa-regular fa-2xl ${e}` })
    },
    e
  )) });
}, Bw = ({
  parentId: t,
  folders: e,
  files: r,
  newFolderPrompt: i,
  newFilePrompt: n,
  moveFilePrompt: s,
  renameFilePrompt: a,
  renameFolderPrompt: l
}) => {
  const {
    openFile: u,
    deleteFile: h,
    toggleOpenFolder: p,
    deleteFolder: d
  } = Cr();
  return /* @__PURE__ */ z.jsxs(z.Fragment, { children: [
    Object.values(e).filter((m) => m.parentId === t).sort((m, y) => m.name.localeCompare(y.name)).map((m) => {
      const y = /* @__PURE__ */ z.jsx(
        "i",
        {
          className: m.open ? "fa-solid fa-caret-down" : "fa-solid fa-caret-right"
        }
      );
      return /* @__PURE__ */ z.jsxs("li", { children: [
        /* @__PURE__ */ z.jsxs("span", { className: "label", children: [
          /* @__PURE__ */ z.jsxs("span", { className: "title", children: [
            /* @__PURE__ */ z.jsx(
              "span",
              {
                className: "caret-container",
                onClick: () => p(m.id),
                children: y
              }
            ),
            /* @__PURE__ */ z.jsx("span", { children: m.name })
          ] }),
          /* @__PURE__ */ z.jsxs("span", { className: "button-bar", children: [
            /* @__PURE__ */ z.jsx("span", { onClick: () => l(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-pencil" }) }),
            /* @__PURE__ */ z.jsx("span", { onClick: () => i(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-folder-plus" }) }),
            /* @__PURE__ */ z.jsx("span", { onClick: () => n(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-plus" }) }),
            /* @__PURE__ */ z.jsx("span", { onClick: () => d(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-trash" }) })
          ] })
        ] }),
        m.open && /* @__PURE__ */ z.jsx("ul", { children: /* @__PURE__ */ z.jsx(
          Bw,
          {
            folders: e,
            newFolderPrompt: i,
            parentId: m.id,
            files: r,
            newFilePrompt: n,
            moveFilePrompt: s,
            renameFilePrompt: a,
            renameFolderPrompt: l
          }
        ) })
      ] }, m.id + m.open);
    }),
    Object.values(r).filter((m) => m.folderId === t).sort((m, y) => m.name.localeCompare(y.name)).map((m) => /* @__PURE__ */ z.jsx("li", { children: /* @__PURE__ */ z.jsxs("span", { className: "label", children: [
      /* @__PURE__ */ z.jsx("span", { onClick: () => u(m.id), children: m.name }),
      /* @__PURE__ */ z.jsxs("span", { className: "button-bar", children: [
        /* @__PURE__ */ z.jsx("span", { onClick: () => s(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-arrow-right" }) }),
        /* @__PURE__ */ z.jsx("span", { onClick: () => a(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-pencil" }) }),
        /* @__PURE__ */ z.jsx("span", { onClick: () => h(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-trash" }) })
      ] })
    ] }) }, m.id))
  ] });
}, bQ = () => {
  const {
    project: t,
    newFile: e,
    renameFile: r,
    moveFile: i,
    renameFolder: n,
    newFolder: s
  } = Cr(), a = (d = cs) => {
    const m = mQ(Object.values(t.folders)), y = window.prompt("Please name your new folder");
    if (!y)
      return;
    if (Object.values(t.folders).some(
      (D) => D.name === y && D.parentId === d
    )) {
      alert("Folder already exists");
      return;
    }
    s({ parentId: d, folderName: y, folderId: m });
  }, l = (d = cs) => {
    var w;
    const m = (w = window.prompt("Please name your new file")) == null ? void 0 : w.replace(/[^\w.]+/g, "");
    if (!m)
      return;
    if (Object.values(t.files).some(
      (x) => x.name === m && x.folderId === d
    )) {
      alert("File already exists");
      return;
    }
    const [O, D] = m.split(".");
    if (!D) {
      window.alert("Files must have extensions");
      return;
    }
    const v = fQ(Object.values(t.files));
    e({
      fileId: v,
      fileName: m,
      folderId: d
    });
  }, u = (d) => {
    const m = t.files[d], y = window.prompt("Please enter your destination folder") ?? "";
    try {
      const O = vx(y.split("/"), {
        folders: Object.values(t.folders),
        required: !0
      });
      if (Object.values(t.files).some(
        (v) => v.name === m.name && v.folderId === O
      )) {
        alert("File already exists");
        return;
      }
      i(d, O);
    } catch (O) {
      window.alert(wx(O));
    }
  }, h = (d) => {
    const m = t.files[d], y = window.prompt("Rename file", m.name);
    if (y === null || y === m.name)
      return;
    if (Object.values(t.files).some(
      (D) => D.name === y && D.folderId === m.folderId
    )) {
      alert("File already exists");
      return;
    }
    r(d, y);
  }, p = (d) => {
    const m = t.folders[d], y = window.prompt("Rename folder", m.name);
    if (y === null || y === m.name)
      return;
    if (Object.values(t.folders).some(
      (D) => D.name === y && D.parentId === m.parentId
    )) {
      alert("Folder already exists");
      return;
    }
    n(m.id, y);
  };
  return /* @__PURE__ */ z.jsxs("div", { children: [
    /* @__PURE__ */ z.jsxs("div", { className: "files-toolbar", children: [
      /* @__PURE__ */ z.jsx("button", { type: "button", onClick: () => a(), children: "New Folder" }),
      /* @__PURE__ */ z.jsx("button", { type: "button", onClick: () => l(), children: "New File" })
    ] }),
    /* @__PURE__ */ z.jsx("ul", { children: /* @__PURE__ */ z.jsx(
      Bw,
      {
        parentId: cs,
        folders: t.folders,
        newFolderPrompt: a,
        files: t.files,
        newFilePrompt: l,
        moveFilePrompt: u,
        renameFilePrompt: h,
        renameFolderPrompt: p
      }
    ) })
  ] });
}, vQ = () => {
  const {
    config: { instructions: t }
  } = Cr();
  return /* @__PURE__ */ z.jsx("div", { className: "instructions", children: t });
}, wQ = () => /* @__PURE__ */ z.jsx("div", { children: "Search is not yet implemented. Sorry." }), SQ = {
  Instructions: vQ,
  Files: bQ,
  Search: wQ
}, CQ = () => {
  const { config: t } = Cr(), [e, r] = An(
    t.activeLeftNav || t.leftNav[0].component
  ), i = SQ[e];
  return /* @__PURE__ */ z.jsxs(
    "div",
    {
      className: "left-pane-outer",
      style: { gridTemplateColumns: t.showSideBar ? "1fr 9fr" : "1fr" },
      children: [
        t.showSideBar && /* @__PURE__ */ z.jsx(DQ, {}),
        /* @__PURE__ */ z.jsxs("div", { className: "left-pane-inner", children: [
          /* @__PURE__ */ z.jsx("div", { className: "left-nav", children: /* @__PURE__ */ z.jsx(xQ, { setActivePane: r, activePane: e }) }),
          /* @__PURE__ */ z.jsx("div", { className: "left-main", children: /* @__PURE__ */ z.jsx(i, {}) })
        ] })
      ]
    }
  );
}, EQ = () => {
  const { project: t, closeFile: e, setActiveFile: r } = Cr(), i = $w(t.files, { mustBeOpen: !0 });
  return /* @__PURE__ */ z.jsx("div", { className: "files-nav-bar", children: i.map((n) => /* @__PURE__ */ z.jsxs("div", { className: "file-tab", style: { cursor: "pointer" }, children: [
    /* @__PURE__ */ z.jsx(
      "span",
      {
        onClick: () => r(n.id),
        style: { fontWeight: n.active ? "bold" : "normal" },
        children: n.name
      }
    ),
    /* @__PURE__ */ z.jsx("span", { onClick: () => e(n.id), children: "X" })
  ] }, n.id)) });
};
function zd() {
  return zd = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
    }
    return t;
  }, zd.apply(this, arguments);
}
function AQ(t, e) {
  if (t == null)
    return {};
  var r = {}, i = Object.keys(t), n, s;
  for (s = 0; s < i.length; s++)
    n = i[s], !(e.indexOf(n) >= 0) && (r[n] = t[n]);
  return r;
}
class je {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, r, i) {
    [e, r] = Aa(this, e, r);
    let n = [];
    return this.decompose(
      0,
      e,
      n,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      n,
      3
      /* Open.To */
    ), this.decompose(
      r,
      this.length,
      n,
      1
      /* Open.From */
    ), xi.from(n, this.length - (r - e) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, r = this.length) {
    [e, r] = Aa(this, e, r);
    let i = [];
    return this.decompose(e, r, i, 0), xi.from(i, r - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let r = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), n = new jo(this), s = new jo(e);
    for (let a = r, l = r; ; ) {
      if (n.next(a), s.next(a), a = 0, n.lineBreak != s.lineBreak || n.done != s.done || n.value != s.value)
        return !1;
      if (l += n.value.length, n.done || l >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new jo(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, r = this.length) {
    return new Iw(this, e, r);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, r) {
    let i;
    if (e == null)
      i = this.iter();
    else {
      r == null && (r = this.lines + 1);
      let n = this.line(e).from;
      i = this.iterRange(n, Math.max(n, r == this.lines + 1 ? this.length : r <= 1 ? 0 : this.line(r - 1).to));
    }
    return new Nw(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? je.empty : e.length <= 32 ? new lt(e) : xi.from(lt.split(e, []));
  }
}
class lt extends je {
  constructor(e, r = kQ(e)) {
    super(), this.text = e, this.length = r;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, r, i, n) {
    for (let s = 0; ; s++) {
      let a = this.text[s], l = n + a.length;
      if ((r ? i : l) >= e)
        return new TQ(n, l, i, a);
      n = l + 1, i++;
    }
  }
  decompose(e, r, i, n) {
    let s = e <= 0 && r >= this.length ? this : new lt(O1(this.text, e, r), Math.min(r, this.length) - Math.max(0, e));
    if (n & 1) {
      let a = i.pop(), l = Yu(s.text, a.text.slice(), 0, s.length);
      if (l.length <= 32)
        i.push(new lt(l, a.length + s.length));
      else {
        let u = l.length >> 1;
        i.push(new lt(l.slice(0, u)), new lt(l.slice(u)));
      }
    } else
      i.push(s);
  }
  replace(e, r, i) {
    if (!(i instanceof lt))
      return super.replace(e, r, i);
    [e, r] = Aa(this, e, r);
    let n = Yu(this.text, Yu(i.text, O1(this.text, 0, e)), r), s = this.length + i.length - (r - e);
    return n.length <= 32 ? new lt(n, s) : xi.from(lt.split(n, []), s);
  }
  sliceString(e, r = this.length, i = `
`) {
    [e, r] = Aa(this, e, r);
    let n = "";
    for (let s = 0, a = 0; s <= r && a < this.text.length; a++) {
      let l = this.text[a], u = s + l.length;
      s > e && a && (n += i), e < u && r > s && (n += l.slice(Math.max(0, e - s), r - s)), s = u + 1;
    }
    return n;
  }
  flatten(e) {
    for (let r of this.text)
      e.push(r);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, r) {
    let i = [], n = -1;
    for (let s of e)
      i.push(s), n += s.length + 1, i.length == 32 && (r.push(new lt(i, n)), i = [], n = -1);
    return n > -1 && r.push(new lt(i, n)), r;
  }
}
class xi extends je {
  constructor(e, r) {
    super(), this.children = e, this.length = r, this.lines = 0;
    for (let i of e)
      this.lines += i.lines;
  }
  lineInner(e, r, i, n) {
    for (let s = 0; ; s++) {
      let a = this.children[s], l = n + a.length, u = i + a.lines - 1;
      if ((r ? u : l) >= e)
        return a.lineInner(e, r, i, n);
      n = l + 1, i = u + 1;
    }
  }
  decompose(e, r, i, n) {
    for (let s = 0, a = 0; a <= r && s < this.children.length; s++) {
      let l = this.children[s], u = a + l.length;
      if (e <= u && r >= a) {
        let h = n & ((a <= e ? 1 : 0) | (u >= r ? 2 : 0));
        a >= e && u <= r && !h ? i.push(l) : l.decompose(e - a, r - a, i, h);
      }
      a = u + 1;
    }
  }
  replace(e, r, i) {
    if ([e, r] = Aa(this, e, r), i.lines < this.lines)
      for (let n = 0, s = 0; n < this.children.length; n++) {
        let a = this.children[n], l = s + a.length;
        if (e >= s && r <= l) {
          let u = a.replace(e - s, r - s, i), h = this.lines - a.lines + u.lines;
          if (u.lines < h >> 4 && u.lines > h >> 6) {
            let p = this.children.slice();
            return p[n] = u, new xi(p, this.length - (r - e) + i.length);
          }
          return super.replace(s, l, u);
        }
        s = l + 1;
      }
    return super.replace(e, r, i);
  }
  sliceString(e, r = this.length, i = `
`) {
    [e, r] = Aa(this, e, r);
    let n = "";
    for (let s = 0, a = 0; s < this.children.length && a <= r; s++) {
      let l = this.children[s], u = a + l.length;
      a > e && s && (n += i), e < u && r > a && (n += l.sliceString(e - a, r - a, i)), a = u + 1;
    }
    return n;
  }
  flatten(e) {
    for (let r of this.children)
      r.flatten(e);
  }
  scanIdentical(e, r) {
    if (!(e instanceof xi))
      return 0;
    let i = 0, [n, s, a, l] = r > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; n += r, s += r) {
      if (n == a || s == l)
        return i;
      let u = this.children[n], h = e.children[s];
      if (u != h)
        return i + u.scanIdentical(h, r);
      i += u.length + 1;
    }
  }
  static from(e, r = e.reduce((i, n) => i + n.length + 1, -1)) {
    let i = 0;
    for (let y of e)
      i += y.lines;
    if (i < 32) {
      let y = [];
      for (let O of e)
        O.flatten(y);
      return new lt(y, r);
    }
    let n = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), s = n << 1, a = n >> 1, l = [], u = 0, h = -1, p = [];
    function d(y) {
      let O;
      if (y.lines > s && y instanceof xi)
        for (let D of y.children)
          d(D);
      else
        y.lines > a && (u > a || !u) ? (m(), l.push(y)) : y instanceof lt && u && (O = p[p.length - 1]) instanceof lt && y.lines + O.lines <= 32 ? (u += y.lines, h += y.length + 1, p[p.length - 1] = new lt(O.text.concat(y.text), O.length + 1 + y.length)) : (u + y.lines > n && m(), u += y.lines, h += y.length + 1, p.push(y));
    }
    function m() {
      u != 0 && (l.push(p.length == 1 ? p[0] : xi.from(p, h)), h = -1, u = p.length = 0);
    }
    for (let y of e)
      d(y);
    return m(), l.length == 1 ? l[0] : new xi(l, r);
  }
}
je.empty = /* @__PURE__ */ new lt([""], 0);
function kQ(t) {
  let e = -1;
  for (let r of t)
    e += r.length + 1;
  return e;
}
function Yu(t, e, r = 0, i = 1e9) {
  for (let n = 0, s = 0, a = !0; s < t.length && n <= i; s++) {
    let l = t[s], u = n + l.length;
    u >= r && (u > i && (l = l.slice(0, i - n)), n < r && (l = l.slice(r - n)), a ? (e[e.length - 1] += l, a = !1) : e.push(l)), n = u + 1;
  }
  return e;
}
function O1(t, e, r) {
  return Yu(t, [""], e, r);
}
class jo {
  constructor(e, r = 1) {
    this.dir = r, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [r > 0 ? 1 : (e instanceof lt ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, r) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, n = this.nodes[i], s = this.offsets[i], a = s >> 1, l = n instanceof lt ? n.text.length : n.children.length;
      if (a == (r > 0 ? l : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        r > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (r > 0 ? 0 : 1)) {
        if (this.offsets[i] += r, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (n instanceof lt) {
        let u = n.text[a + (r < 0 ? -1 : 0)];
        if (this.offsets[i] += r, u.length > Math.max(0, e))
          return this.value = e == 0 ? u : r > 0 ? u.slice(e) : u.slice(0, u.length - e), this;
        e -= u.length;
      } else {
        let u = n.children[a + (r < 0 ? -1 : 0)];
        e > u.length ? (e -= u.length, this.offsets[i] += r) : (r < 0 && this.offsets[i]--, this.nodes.push(u), this.offsets.push(r > 0 ? 1 : (u instanceof lt ? u.text.length : u.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class Iw {
  constructor(e, r, i) {
    this.value = "", this.done = !1, this.cursor = new jo(e, r > i ? -1 : 1), this.pos = r > i ? e.length : 0, this.from = Math.min(r, i), this.to = Math.max(r, i);
  }
  nextInner(e, r) {
    if (r < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, r < 0 ? this.pos - this.to : this.from - this.pos);
    let i = r < 0 ? this.pos - this.from : this.to - this.pos;
    e > i && (e = i), i -= e;
    let { value: n } = this.cursor.next(e);
    return this.pos += (n.length + e) * r, this.value = n.length <= i ? n : r < 0 ? n.slice(n.length - i) : n.slice(0, i), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class Nw {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: r, lineBreak: i, value: n } = this.inner.next(e);
    return r && this.afterBreak ? (this.value = "", this.afterBreak = !1) : r ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = n, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (je.prototype[Symbol.iterator] = function() {
  return this.iter();
}, jo.prototype[Symbol.iterator] = Iw.prototype[Symbol.iterator] = Nw.prototype[Symbol.iterator] = function() {
  return this;
});
class TQ {
  /**
  @internal
  */
  constructor(e, r, i, n) {
    this.from = e, this.to = r, this.number = i, this.text = n;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function Aa(t, e, r) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, r))];
}
let da = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
for (let t = 1; t < da.length; t++)
  da[t] += da[t - 1];
function PQ(t) {
  for (let e = 1; e < da.length; e += 2)
    if (da[e] > t)
      return da[e - 1] <= t;
  return !1;
}
function x1(t) {
  return t >= 127462 && t <= 127487;
}
const D1 = 8205;
function Ft(t, e, r = !0, i = !0) {
  return (r ? _w : FQ)(t, e, i);
}
function _w(t, e, r) {
  if (e == t.length)
    return e;
  e && Mw(t.charCodeAt(e)) && Lw(t.charCodeAt(e - 1)) && e--;
  let i = Et(t, e);
  for (e += Br(i); e < t.length; ) {
    let n = Et(t, e);
    if (i == D1 || n == D1 || r && PQ(n))
      e += Br(n), i = n;
    else if (x1(n)) {
      let s = 0, a = e - 2;
      for (; a >= 0 && x1(Et(t, a)); )
        s++, a -= 2;
      if (s % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function FQ(t, e, r) {
  for (; e > 0; ) {
    let i = _w(t, e - 2, r);
    if (i < e)
      return i;
    e--;
  }
  return 0;
}
function Mw(t) {
  return t >= 56320 && t < 57344;
}
function Lw(t) {
  return t >= 55296 && t < 56320;
}
function Et(t, e) {
  let r = t.charCodeAt(e);
  if (!Lw(r) || e + 1 == t.length)
    return r;
  let i = t.charCodeAt(e + 1);
  return Mw(i) ? (r - 55296 << 10) + (i - 56320) + 65536 : r;
}
function Pg(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function Br(t) {
  return t < 65536 ? 1 : 2;
}
const Gd = /\r\n?|\n/;
var Tt = /* @__PURE__ */ function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
}(Tt || (Tt = {}));
class Ai {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2)
      e += this.sections[r];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2) {
      let i = this.sections[r + 1];
      e += i < 0 ? this.sections[r] : i;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let r = 0, i = 0, n = 0; r < this.sections.length; ) {
      let s = this.sections[r++], a = this.sections[r++];
      a < 0 ? (e(i, n, s), n += s) : n += a, i += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, r = !1) {
    Hd(this, e, r);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let r = 0; r < this.sections.length; ) {
      let i = this.sections[r++], n = this.sections[r++];
      n < 0 ? e.push(i, n) : e.push(n, i);
    }
    return new Ai(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : Qw(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, r = !1) {
    return e.empty ? this : Jd(this, e, r);
  }
  mapPos(e, r = -1, i = Tt.Simple) {
    let n = 0, s = 0;
    for (let a = 0; a < this.sections.length; ) {
      let l = this.sections[a++], u = this.sections[a++], h = n + l;
      if (u < 0) {
        if (h > e)
          return s + (e - n);
        s += l;
      } else {
        if (i != Tt.Simple && h >= e && (i == Tt.TrackDel && n < e && h > e || i == Tt.TrackBefore && n < e || i == Tt.TrackAfter && h > e))
          return null;
        if (h > e || h == e && r < 0 && !l)
          return e == n || r < 0 ? s : s + u;
        s += u;
      }
      n = h;
    }
    if (e > n)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${n}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, r = e) {
    for (let i = 0, n = 0; i < this.sections.length && n <= r; ) {
      let s = this.sections[i++], a = this.sections[i++], l = n + s;
      if (a >= 0 && n <= r && l >= e)
        return n < e && l > r ? "cover" : !0;
      n = l;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let r = 0; r < this.sections.length; ) {
      let i = this.sections[r++], n = this.sections[r++];
      e += (e ? " " : "") + i + (n >= 0 ? ":" + n : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((r) => typeof r != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Ai(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new Ai(e);
  }
}
class yt extends Ai {
  constructor(e, r) {
    super(e), this.inserted = r;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Hd(this, (r, i, n, s, a) => e = e.replace(n, n + (i - r), a), !1), e;
  }
  mapDesc(e, r = !1) {
    return Jd(this, e, r, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let r = this.sections.slice(), i = [];
    for (let n = 0, s = 0; n < r.length; n += 2) {
      let a = r[n], l = r[n + 1];
      if (l >= 0) {
        r[n] = l, r[n + 1] = a;
        let u = n >> 1;
        for (; i.length < u; )
          i.push(je.empty);
        i.push(a ? e.slice(s, s + a) : je.empty);
      }
      s += a;
    }
    return new yt(r, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : Qw(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, r = !1) {
    return e.empty ? this : Jd(this, e, r, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, r = !1) {
    Hd(this, e, r);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Ai.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let r = [], i = [], n = [], s = new tl(this);
    e:
      for (let a = 0, l = 0; ; ) {
        let u = a == e.length ? 1e9 : e[a++];
        for (; l < u || l == u && s.len == 0; ) {
          if (s.done)
            break e;
          let p = Math.min(s.len, u - l);
          jt(n, p, -1);
          let d = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
          jt(r, p, d), d > 0 && Sn(i, r, s.text), s.forward(p), l += p;
        }
        let h = e[a++];
        for (; l < h; ) {
          if (s.done)
            break e;
          let p = Math.min(s.len, h - l);
          jt(r, p, -1), jt(n, p, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(p), l += p;
        }
      }
    return {
      changes: new yt(r, i),
      filtered: Ai.create(n)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let r = 0; r < this.sections.length; r += 2) {
      let i = this.sections[r], n = this.sections[r + 1];
      n < 0 ? e.push(i) : n == 0 ? e.push([i]) : e.push([i].concat(this.inserted[r >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, r, i) {
    let n = [], s = [], a = 0, l = null;
    function u(p = !1) {
      if (!p && !n.length)
        return;
      a < r && jt(n, r - a, -1);
      let d = new yt(n, s);
      l = l ? l.compose(d.map(l)) : d, n = [], s = [], a = 0;
    }
    function h(p) {
      if (Array.isArray(p))
        for (let d of p)
          h(d);
      else if (p instanceof yt) {
        if (p.length != r)
          throw new RangeError(`Mismatched change set length (got ${p.length}, expected ${r})`);
        u(), l = l ? l.compose(p.map(l)) : p;
      } else {
        let { from: d, to: m = d, insert: y } = p;
        if (d > m || d < 0 || m > r)
          throw new RangeError(`Invalid change range ${d} to ${m} (in doc of length ${r})`);
        let O = y ? typeof y == "string" ? je.of(y.split(i || Gd)) : y : je.empty, D = O.length;
        if (d == m && D == 0)
          return;
        d < a && u(), d > a && jt(n, d - a, -1), jt(n, m - d, D), Sn(s, n, O), a = m;
      }
    }
    return h(e), u(!l), l;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new yt(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let r = [], i = [];
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if (typeof s == "number")
        r.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((a, l) => l && typeof a != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          r.push(s[0], 0);
        else {
          for (; i.length < n; )
            i.push(je.empty);
          i[n] = je.of(s.slice(1)), r.push(s[0], i[n].length);
        }
      }
    }
    return new yt(r, i);
  }
  /**
  @internal
  */
  static createSet(e, r) {
    return new yt(e, r);
  }
}
function jt(t, e, r, i = !1) {
  if (e == 0 && r <= 0)
    return;
  let n = t.length - 2;
  n >= 0 && r <= 0 && r == t[n + 1] ? t[n] += e : e == 0 && t[n] == 0 ? t[n + 1] += r : i ? (t[n] += e, t[n + 1] += r) : t.push(e, r);
}
function Sn(t, e, r) {
  if (r.length == 0)
    return;
  let i = e.length - 2 >> 1;
  if (i < t.length)
    t[t.length - 1] = t[t.length - 1].append(r);
  else {
    for (; t.length < i; )
      t.push(je.empty);
    t.push(r);
  }
}
function Hd(t, e, r) {
  let i = t.inserted;
  for (let n = 0, s = 0, a = 0; a < t.sections.length; ) {
    let l = t.sections[a++], u = t.sections[a++];
    if (u < 0)
      n += l, s += l;
    else {
      let h = n, p = s, d = je.empty;
      for (; h += l, p += u, u && i && (d = d.append(i[a - 2 >> 1])), !(r || a == t.sections.length || t.sections[a + 1] < 0); )
        l = t.sections[a++], u = t.sections[a++];
      e(n, h, s, p, d), n = h, s = p;
    }
  }
}
function Jd(t, e, r, i = !1) {
  let n = [], s = i ? [] : null, a = new tl(t), l = new tl(e);
  for (let u = -1; ; )
    if (a.ins == -1 && l.ins == -1) {
      let h = Math.min(a.len, l.len);
      jt(n, h, -1), a.forward(h), l.forward(h);
    } else if (l.ins >= 0 && (a.ins < 0 || u == a.i || a.off == 0 && (l.len < a.len || l.len == a.len && !r))) {
      let h = l.len;
      for (jt(n, l.ins, -1); h; ) {
        let p = Math.min(a.len, h);
        a.ins >= 0 && u < a.i && a.len <= p && (jt(n, 0, a.ins), s && Sn(s, n, a.text), u = a.i), a.forward(p), h -= p;
      }
      l.next();
    } else if (a.ins >= 0) {
      let h = 0, p = a.len;
      for (; p; )
        if (l.ins == -1) {
          let d = Math.min(p, l.len);
          h += d, p -= d, l.forward(d);
        } else if (l.ins == 0 && l.len < p)
          p -= l.len, l.next();
        else
          break;
      jt(n, h, u < a.i ? a.ins : 0), s && u < a.i && Sn(s, n, a.text), u = a.i, a.forward(a.len - p);
    } else {
      if (a.done && l.done)
        return s ? yt.createSet(n, s) : Ai.create(n);
      throw new Error("Mismatched change set lengths");
    }
}
function Qw(t, e, r = !1) {
  let i = [], n = r ? [] : null, s = new tl(t), a = new tl(e);
  for (let l = !1; ; ) {
    if (s.done && a.done)
      return n ? yt.createSet(i, n) : Ai.create(i);
    if (s.ins == 0)
      jt(i, s.len, 0, l), s.next();
    else if (a.len == 0 && !a.done)
      jt(i, 0, a.ins, l), n && Sn(n, i, a.text), a.next();
    else {
      if (s.done || a.done)
        throw new Error("Mismatched change set lengths");
      {
        let u = Math.min(s.len2, a.len), h = i.length;
        if (s.ins == -1) {
          let p = a.ins == -1 ? -1 : a.off ? 0 : a.ins;
          jt(i, u, p, l), n && p && Sn(n, i, a.text);
        } else
          a.ins == -1 ? (jt(i, s.off ? 0 : s.len, u, l), n && Sn(n, i, s.textBit(u))) : (jt(i, s.off ? 0 : s.len, a.off ? 0 : a.ins, l), n && !a.off && Sn(n, i, a.text));
        l = (s.ins > u || a.ins >= 0 && a.len > u) && (l || i.length > h), s.forward2(u), a.forward(u);
      }
    }
  }
}
class tl {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, r = this.i - 2 >> 1;
    return r >= e.length ? je.empty : e[r];
  }
  textBit(e) {
    let { inserted: r } = this.set, i = this.i - 2 >> 1;
    return i >= r.length && !e ? je.empty : r[i].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class ls {
  constructor(e, r, i) {
    this.from = e, this.to = r, this.flags = i;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, r = -1) {
    let i, n;
    return this.empty ? i = n = e.mapPos(this.from, r) : (i = e.mapPos(this.from, 1), n = e.mapPos(this.to, -1)), i == this.from && n == this.to ? this : new ls(i, n, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, r = e) {
    if (e <= this.anchor && r >= this.anchor)
      return Y.range(e, r);
    let i = Math.abs(e - this.anchor) > Math.abs(r - this.anchor) ? e : r;
    return Y.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(e, r = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!r || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return Y.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, r, i) {
    return new ls(e, r, i);
  }
}
class Y {
  constructor(e, r) {
    this.ranges = e, this.mainIndex = r;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, r = -1) {
    return e.empty ? this : Y.create(this.ranges.map((i) => i.map(e, r)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, r = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(e.ranges[i], r))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new Y([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, r = !0) {
    return Y.create([e].concat(this.ranges), r ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, r = this.mainIndex) {
    let i = this.ranges.slice();
    return i[r] = e, Y.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new Y(e.ranges.map((r) => ls.fromJSON(r)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, r = e) {
    return new Y([Y.range(e, r)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, r = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, n = 0; n < e.length; n++) {
      let s = e[n];
      if (s.empty ? s.from <= i : s.from < i)
        return Y.normalized(e.slice(), r);
      i = s.to;
    }
    return new Y(e, r);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, r = 0, i, n) {
    return ls.create(e, e, (r == 0 ? 0 : r < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (n ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, r, i, n) {
    let s = (i ?? 16777215) << 6 | (n == null ? 7 : Math.min(6, n));
    return r < e ? ls.create(r, e, 48 | s) : ls.create(e, r, (r > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, r = 0) {
    let i = e[r];
    e.sort((n, s) => n.from - s.from), r = e.indexOf(i);
    for (let n = 1; n < e.length; n++) {
      let s = e[n], a = e[n - 1];
      if (s.empty ? s.from <= a.to : s.from < a.to) {
        let l = a.from, u = Math.max(s.to, a.to);
        n <= r && r--, e.splice(--n, 2, s.anchor > s.head ? Y.range(u, l) : Y.range(l, u));
      }
    }
    return new Y(e, r);
  }
}
function jw(t, e) {
  for (let r of t.ranges)
    if (r.to > e)
      throw new RangeError("Selection points outside of document");
}
let Fg = 0;
class fe {
  constructor(e, r, i, n, s) {
    this.combine = e, this.compareInput = r, this.compare = i, this.isStatic = n, this.id = Fg++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new fe(e.combine || ((r) => r), e.compareInput || ((r, i) => r === i), e.compare || (e.combine ? (r, i) => r === i : $g), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new zu([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new zu(e, this, 1, r);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new zu(e, this, 2, r);
  }
  from(e, r) {
    return r || (r = (i) => i), this.compute([e], (i) => r(i.field(e)));
  }
}
function $g(t, e) {
  return t == e || t.length == e.length && t.every((r, i) => r === e[i]);
}
class zu {
  constructor(e, r, i, n) {
    this.dependencies = e, this.facet = r, this.type = i, this.value = n, this.id = Fg++;
  }
  dynamicSlot(e) {
    var r;
    let i = this.value, n = this.facet.compareInput, s = this.id, a = e[s] >> 1, l = this.type == 2, u = !1, h = !1, p = [];
    for (let d of this.dependencies)
      d == "doc" ? u = !0 : d == "selection" ? h = !0 : ((r = e[d.id]) !== null && r !== void 0 ? r : 1) & 1 || p.push(e[d.id]);
    return {
      create(d) {
        return d.values[a] = i(d), 1;
      },
      update(d, m) {
        if (u && m.docChanged || h && (m.docChanged || m.selection) || Kd(d, p)) {
          let y = i(d);
          if (l ? !b1(y, d.values[a], n) : !n(y, d.values[a]))
            return d.values[a] = y, 1;
        }
        return 0;
      },
      reconfigure: (d, m) => {
        let y, O = m.config.address[s];
        if (O != null) {
          let D = Dc(m, O);
          if (this.dependencies.every((v) => v instanceof fe ? m.facet(v) === d.facet(v) : v instanceof vt ? m.field(v, !1) == d.field(v, !1) : !0) || (l ? b1(y = i(d), D, n) : n(y = i(d), D)))
            return d.values[a] = D, 0;
        } else
          y = i(d);
        return d.values[a] = y, 1;
      }
    };
  }
}
function b1(t, e, r) {
  if (t.length != e.length)
    return !1;
  for (let i = 0; i < t.length; i++)
    if (!r(t[i], e[i]))
      return !1;
  return !0;
}
function Kd(t, e) {
  let r = !1;
  for (let i of e)
    Ro(t, i) & 1 && (r = !0);
  return r;
}
function $Q(t, e, r) {
  let i = r.map((u) => t[u.id]), n = r.map((u) => u.type), s = i.filter((u) => !(u & 1)), a = t[e.id] >> 1;
  function l(u) {
    let h = [];
    for (let p = 0; p < i.length; p++) {
      let d = Dc(u, i[p]);
      if (n[p] == 2)
        for (let m of d)
          h.push(m);
      else
        h.push(d);
    }
    return e.combine(h);
  }
  return {
    create(u) {
      for (let h of i)
        Ro(u, h);
      return u.values[a] = l(u), 1;
    },
    update(u, h) {
      if (!Kd(u, s))
        return 0;
      let p = l(u);
      return e.compare(p, u.values[a]) ? 0 : (u.values[a] = p, 1);
    },
    reconfigure(u, h) {
      let p = Kd(u, i), d = h.config.facets[e.id], m = h.facet(e);
      if (d && !p && $g(r, d))
        return u.values[a] = m, 0;
      let y = l(u);
      return e.compare(y, m) ? (u.values[a] = m, 0) : (u.values[a] = y, 1);
    }
  };
}
const v1 = /* @__PURE__ */ fe.define({ static: !0 });
class vt {
  constructor(e, r, i, n, s) {
    this.id = e, this.createF = r, this.updateF = i, this.compareF = n, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let r = new vt(Fg++, e.create, e.update, e.compare || ((i, n) => i === n), e);
    return e.provide && (r.provides = e.provide(r)), r;
  }
  create(e) {
    let r = e.facet(v1).find((i) => i.field == this);
    return ((r == null ? void 0 : r.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let r = e[this.id] >> 1;
    return {
      create: (i) => (i.values[r] = this.create(i), 1),
      update: (i, n) => {
        let s = i.values[r], a = this.updateF(s, n);
        return this.compareF(s, a) ? 0 : (i.values[r] = a, 1);
      },
      reconfigure: (i, n) => n.config.address[this.id] != null ? (i.values[r] = n.field(this), 0) : (i.values[r] = this.create(i), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, v1.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const is = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function ho(t) {
  return (e) => new Rw(e, t);
}
const js = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ ho(is.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ ho(is.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ ho(is.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ ho(is.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ ho(is.lowest)
};
class Rw {
  constructor(e, r) {
    this.inner = e, this.prec = r;
  }
}
class Nh {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new ef(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Nh.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class ef {
  constructor(e, r) {
    this.compartment = e, this.inner = r;
  }
}
class xc {
  constructor(e, r, i, n, s, a) {
    for (this.base = e, this.compartments = r, this.dynamicSlots = i, this.address = n, this.staticValues = s, this.facets = a, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let r = this.address[e.id];
    return r == null ? e.default : this.staticValues[r >> 1];
  }
  static resolve(e, r, i) {
    let n = [], s = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ new Map();
    for (let m of BQ(e, r, a))
      m instanceof vt ? n.push(m) : (s[m.facet.id] || (s[m.facet.id] = [])).push(m);
    let l = /* @__PURE__ */ Object.create(null), u = [], h = [];
    for (let m of n)
      l[m.id] = h.length << 1, h.push((y) => m.slot(y));
    let p = i == null ? void 0 : i.config.facets;
    for (let m in s) {
      let y = s[m], O = y[0].facet, D = p && p[m] || [];
      if (y.every(
        (v) => v.type == 0
        /* Provider.Static */
      ))
        if (l[O.id] = u.length << 1 | 1, $g(D, y))
          u.push(i.facet(O));
        else {
          let v = O.combine(y.map((w) => w.value));
          u.push(i && O.compare(v, i.facet(O)) ? i.facet(O) : v);
        }
      else {
        for (let v of y)
          v.type == 0 ? (l[v.id] = u.length << 1 | 1, u.push(v.value)) : (l[v.id] = h.length << 1, h.push((w) => v.dynamicSlot(w)));
        l[O.id] = h.length << 1, h.push((v) => $Q(v, O, y));
      }
    }
    let d = h.map((m) => m(l));
    return new xc(e, a, d, l, u, s);
  }
}
function BQ(t, e, r) {
  let i = [[], [], [], [], []], n = /* @__PURE__ */ new Map();
  function s(a, l) {
    let u = n.get(a);
    if (u != null) {
      if (u <= l)
        return;
      let h = i[u].indexOf(a);
      h > -1 && i[u].splice(h, 1), a instanceof ef && r.delete(a.compartment);
    }
    if (n.set(a, l), Array.isArray(a))
      for (let h of a)
        s(h, l);
    else if (a instanceof ef) {
      if (r.has(a.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let h = e.get(a.compartment) || a.inner;
      r.set(a.compartment, h), s(h, l);
    } else if (a instanceof Rw)
      s(a.inner, a.prec);
    else if (a instanceof vt)
      i[l].push(a), a.provides && s(a.provides, l);
    else if (a instanceof zu)
      i[l].push(a), a.facet.extensions && s(a.facet.extensions, is.default);
    else {
      let h = a.extension;
      if (!h)
        throw new Error(`Unrecognized extension value in extension set (${a}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(h, l);
    }
  }
  return s(t, is.default), i.reduce((a, l) => a.concat(l));
}
function Ro(t, e) {
  if (e & 1)
    return 2;
  let r = e >> 1, i = t.status[r];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  t.status[r] = 4;
  let n = t.computeSlot(t, t.config.dynamicSlots[r]);
  return t.status[r] = 2 | n;
}
function Dc(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const Zw = /* @__PURE__ */ fe.define(), tf = /* @__PURE__ */ fe.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), Ww = /* @__PURE__ */ fe.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), qw = /* @__PURE__ */ fe.define(), Xw = /* @__PURE__ */ fe.define(), Vw = /* @__PURE__ */ fe.define(), Uw = /* @__PURE__ */ fe.define({
  combine: (t) => t.length ? t[0] : !1
});
class Ni {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new IQ();
  }
}
class IQ {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Ni(this, e);
  }
}
class NQ {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new we(this, e);
  }
}
class we {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let r = this.type.map(this.value, e);
    return r === void 0 ? void 0 : r == this.value ? this : new we(this.type, r);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new NQ(e.map || ((r) => r));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, r) {
    if (!e.length)
      return e;
    let i = [];
    for (let n of e) {
      let s = n.map(r);
      s && i.push(s);
    }
    return i;
  }
}
we.reconfigure = /* @__PURE__ */ we.define();
we.appendConfig = /* @__PURE__ */ we.define();
class dt {
  constructor(e, r, i, n, s, a) {
    this.startState = e, this.changes = r, this.selection = i, this.effects = n, this.annotations = s, this.scrollIntoView = a, this._doc = null, this._state = null, i && jw(i, r.newLength), s.some((l) => l.type == dt.time) || (this.annotations = s.concat(dt.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, r, i, n, s, a) {
    return new dt(e, r, i, n, s, a);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let r of this.annotations)
      if (r.type == e)
        return r.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let r = this.annotation(dt.userEvent);
    return !!(r && (r == e || r.length > e.length && r.slice(0, e.length) == e && r[e.length] == "."));
  }
}
dt.time = /* @__PURE__ */ Ni.define();
dt.userEvent = /* @__PURE__ */ Ni.define();
dt.addToHistory = /* @__PURE__ */ Ni.define();
dt.remote = /* @__PURE__ */ Ni.define();
function _Q(t, e) {
  let r = [];
  for (let i = 0, n = 0; ; ) {
    let s, a;
    if (i < t.length && (n == e.length || e[n] >= t[i]))
      s = t[i++], a = t[i++];
    else if (n < e.length)
      s = e[n++], a = e[n++];
    else
      return r;
    !r.length || r[r.length - 1] < s ? r.push(s, a) : r[r.length - 1] < a && (r[r.length - 1] = a);
  }
}
function Yw(t, e, r) {
  var i;
  let n, s, a;
  return r ? (n = e.changes, s = yt.empty(e.changes.length), a = t.changes.compose(e.changes)) : (n = e.changes.map(t.changes), s = t.changes.mapDesc(e.changes, !0), a = t.changes.compose(n)), {
    changes: a,
    selection: e.selection ? e.selection.map(s) : (i = t.selection) === null || i === void 0 ? void 0 : i.map(n),
    effects: we.mapEffects(t.effects, n).concat(we.mapEffects(e.effects, s)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function rf(t, e, r) {
  let i = e.selection, n = fa(e.annotations);
  return e.userEvent && (n = n.concat(dt.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof yt ? e.changes : yt.of(e.changes || [], r, t.facet(Ww)),
    selection: i && (i instanceof Y ? i : Y.single(i.anchor, i.head)),
    effects: fa(e.effects),
    annotations: n,
    scrollIntoView: !!e.scrollIntoView
  };
}
function zw(t, e, r) {
  let i = rf(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (r = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (r = !1);
    let a = !!e[s].sequential;
    i = Yw(i, rf(t, e[s], a ? i.changes.newLength : t.doc.length), a);
  }
  let n = dt.create(t, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return LQ(r ? MQ(n) : n);
}
function MQ(t) {
  let e = t.startState, r = !0;
  for (let n of e.facet(qw)) {
    let s = n(t);
    if (s === !1) {
      r = !1;
      break;
    }
    Array.isArray(s) && (r = r === !0 ? s : _Q(r, s));
  }
  if (r !== !0) {
    let n, s;
    if (r === !1)
      s = t.changes.invertedDesc, n = yt.empty(e.doc.length);
    else {
      let a = t.changes.filter(r);
      n = a.changes, s = a.filtered.mapDesc(a.changes).invertedDesc;
    }
    t = dt.create(e, n, t.selection && t.selection.map(s), we.mapEffects(t.effects, s), t.annotations, t.scrollIntoView);
  }
  let i = e.facet(Xw);
  for (let n = i.length - 1; n >= 0; n--) {
    let s = i[n](t);
    s instanceof dt ? t = s : Array.isArray(s) && s.length == 1 && s[0] instanceof dt ? t = s[0] : t = zw(e, fa(s), !1);
  }
  return t;
}
function LQ(t) {
  let e = t.startState, r = e.facet(Vw), i = t;
  for (let n = r.length - 1; n >= 0; n--) {
    let s = r[n](t);
    s && Object.keys(s).length && (i = Yw(i, rf(e, s, t.changes.newLength), !0));
  }
  return i == t ? t : dt.create(e, t.changes, t.selection, i.effects, i.annotations, i.scrollIntoView);
}
const QQ = [];
function fa(t) {
  return t == null ? QQ : Array.isArray(t) ? t : [t];
}
var it = /* @__PURE__ */ function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
}(it || (it = {}));
const jQ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let nf;
try {
  nf = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function RQ(t) {
  if (nf)
    return nf.test(t);
  for (let e = 0; e < t.length; e++) {
    let r = t[e];
    if (/\w/.test(r) || r > "" && (r.toUpperCase() != r.toLowerCase() || jQ.test(r)))
      return !0;
  }
  return !1;
}
function ZQ(t) {
  return (e) => {
    if (!/\S/.test(e))
      return it.Space;
    if (RQ(e))
      return it.Word;
    for (let r = 0; r < t.length; r++)
      if (e.indexOf(t[r]) > -1)
        return it.Word;
    return it.Other;
  };
}
class Be {
  constructor(e, r, i, n, s, a) {
    this.config = e, this.doc = r, this.selection = i, this.values = n, this.status = e.statusTemplate.slice(), this.computeSlot = s, a && (a._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++)
      Ro(this, l << 1);
    this.computeSlot = null;
  }
  field(e, r = !0) {
    let i = this.config.address[e.id];
    if (i == null) {
      if (r)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Ro(this, i), Dc(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return zw(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let r = this.config, { base: i, compartments: n } = r;
    for (let l of e.effects)
      l.is(Nh.reconfigure) ? (r && (n = /* @__PURE__ */ new Map(), r.compartments.forEach((u, h) => n.set(h, u)), r = null), n.set(l.value.compartment, l.value.extension)) : l.is(we.reconfigure) ? (r = null, i = l.value) : l.is(we.appendConfig) && (r = null, i = fa(i).concat(l.value));
    let s;
    r ? s = e.startState.values.slice() : (r = xc.resolve(i, n, this), s = new Be(r, this.doc, this.selection, r.dynamicSlots.map(() => null), (u, h) => h.reconfigure(u, this), null).values);
    let a = e.startState.facet(tf) ? e.newSelection : e.newSelection.asSingle();
    new Be(r, e.newDoc, a, s, (l, u) => u.update(l, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((r) => ({
      changes: { from: r.from, to: r.to, insert: e },
      range: Y.cursor(r.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let r = this.selection, i = e(r.ranges[0]), n = this.changes(i.changes), s = [i.range], a = fa(i.effects);
    for (let l = 1; l < r.ranges.length; l++) {
      let u = e(r.ranges[l]), h = this.changes(u.changes), p = h.map(n);
      for (let m = 0; m < l; m++)
        s[m] = s[m].map(p);
      let d = n.mapDesc(h, !0);
      s.push(u.range.map(d)), n = n.compose(p), a = we.mapEffects(a, p).concat(we.mapEffects(fa(u.effects), d));
    }
    return {
      changes: n,
      selection: Y.create(s, r.mainIndex),
      effects: a
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof yt ? e : yt.of(e, this.doc.length, this.facet(Be.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return je.of(e.split(this.facet(Be.lineSeparator) || Gd));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, r = this.doc.length) {
    return this.doc.sliceString(e, r, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let r = this.config.address[e.id];
    return r == null ? e.default : (Ro(this, r), Dc(this, r));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let r = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let i in e) {
        let n = e[i];
        n instanceof vt && this.config.address[n.id] != null && (r[i] = n.spec.toJSON(this.field(e[i]), this));
      }
    return r;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, r = {}, i) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let n = [];
    if (i) {
      for (let s in i)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let a = i[s], l = e[s];
          n.push(a.init((u) => a.spec.fromJSON(l, u)));
        }
    }
    return Be.create({
      doc: e.doc,
      selection: Y.fromJSON(e.selection),
      extensions: r.extensions ? n.concat([r.extensions]) : n
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let r = xc.resolve(e.extensions || [], /* @__PURE__ */ new Map()), i = e.doc instanceof je ? e.doc : je.of((e.doc || "").split(r.staticFacet(Be.lineSeparator) || Gd)), n = e.selection ? e.selection instanceof Y ? e.selection : Y.single(e.selection.anchor, e.selection.head) : Y.single(0);
    return jw(n, i.length), r.staticFacet(tf) || (n = n.asSingle()), new Be(r, i, n, r.dynamicSlots.map(() => null), (s, a) => a.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(Be.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(Be.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(Uw);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...r) {
    for (let i of this.facet(Be.phrases))
      if (Object.prototype.hasOwnProperty.call(i, e)) {
        e = i[e];
        break;
      }
    return r.length && (e = e.replace(/\$(\$|\d*)/g, (i, n) => {
      if (n == "$")
        return "$";
      let s = +(n || 1);
      return !s || s > r.length ? i : r[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, r, i = -1) {
    let n = [];
    for (let s of this.facet(Zw))
      for (let a of s(this, r, i))
        Object.prototype.hasOwnProperty.call(a, e) && n.push(a[e]);
    return n;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return ZQ(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: r, from: i, length: n } = this.doc.lineAt(e), s = this.charCategorizer(e), a = e - i, l = e - i;
    for (; a > 0; ) {
      let u = Ft(r, a, !1);
      if (s(r.slice(u, a)) != it.Word)
        break;
      a = u;
    }
    for (; l < n; ) {
      let u = Ft(r, l);
      if (s(r.slice(l, u)) != it.Word)
        break;
      l = u;
    }
    return a == l ? null : Y.range(a + i, l + i);
  }
}
Be.allowMultipleSelections = tf;
Be.tabSize = /* @__PURE__ */ fe.define({
  combine: (t) => t.length ? t[0] : 4
});
Be.lineSeparator = Ww;
Be.readOnly = Uw;
Be.phrases = /* @__PURE__ */ fe.define({
  compare(t, e) {
    let r = Object.keys(t), i = Object.keys(e);
    return r.length == i.length && r.every((n) => t[n] == e[n]);
  }
});
Be.languageData = Zw;
Be.changeFilter = qw;
Be.transactionFilter = Xw;
Be.transactionExtender = Vw;
Nh.reconfigure = /* @__PURE__ */ we.define();
function _i(t, e, r = {}) {
  let i = {};
  for (let n of t)
    for (let s of Object.keys(n)) {
      let a = n[s], l = i[s];
      if (l === void 0)
        i[s] = a;
      else if (!(l === a || a === void 0))
        if (Object.hasOwnProperty.call(r, s))
          i[s] = r[s](l, a);
        else
          throw new Error("Config merge conflict for field " + s);
    }
  for (let n in e)
    i[n] === void 0 && (i[n] = e[n]);
  return i;
}
class ws {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, r = e) {
    return sf.create(e, r, this);
  }
}
ws.prototype.startSide = ws.prototype.endSide = 0;
ws.prototype.point = !1;
ws.prototype.mapMode = Tt.TrackDel;
let sf = class Gw {
  constructor(e, r, i) {
    this.from = e, this.to = r, this.value = i;
  }
  /**
  @internal
  */
  static create(e, r, i) {
    return new Gw(e, r, i);
  }
};
function af(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class Bg {
  constructor(e, r, i, n) {
    this.from = e, this.to = r, this.value = i, this.maxPoint = n;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, r, i, n = 0) {
    let s = i ? this.to : this.from;
    for (let a = n, l = s.length; ; ) {
      if (a == l)
        return a;
      let u = a + l >> 1, h = s[u] - e || (i ? this.value[u].endSide : this.value[u].startSide) - r;
      if (u == a)
        return h >= 0 ? a : l;
      h >= 0 ? l = u : a = u + 1;
    }
  }
  between(e, r, i, n) {
    for (let s = this.findIndex(r, -1e9, !0), a = this.findIndex(i, 1e9, !1, s); s < a; s++)
      if (n(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, r) {
    let i = [], n = [], s = [], a = -1, l = -1;
    for (let u = 0; u < this.value.length; u++) {
      let h = this.value[u], p = this.from[u] + e, d = this.to[u] + e, m, y;
      if (p == d) {
        let O = r.mapPos(p, h.startSide, h.mapMode);
        if (O == null || (m = y = O, h.startSide != h.endSide && (y = r.mapPos(p, h.endSide), y < m)))
          continue;
      } else if (m = r.mapPos(p, h.startSide), y = r.mapPos(d, h.endSide), m > y || m == y && h.startSide > 0 && h.endSide <= 0)
        continue;
      (y - m || h.endSide - h.startSide) < 0 || (a < 0 && (a = m), h.point && (l = Math.max(l, y - m)), i.push(h), n.push(m - a), s.push(y - a));
    }
    return { mapped: i.length ? new Bg(n, s, i, l) : null, pos: a };
  }
}
class Me {
  constructor(e, r, i, n) {
    this.chunkPos = e, this.chunk = r, this.nextLayer = i, this.maxPoint = n;
  }
  /**
  @internal
  */
  static create(e, r, i, n) {
    return new Me(e, r, i, n);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let r of this.chunk)
      e += r.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: r = [], sort: i = !1, filterFrom: n = 0, filterTo: s = this.length } = e, a = e.filter;
    if (r.length == 0 && !a)
      return this;
    if (i && (r = r.slice().sort(af)), this.isEmpty)
      return r.length ? Me.of(r) : this;
    let l = new Hw(this, null, -1).goto(0), u = 0, h = [], p = new Mn();
    for (; l.value || u < r.length; )
      if (u < r.length && (l.from - r[u].from || l.startSide - r[u].value.startSide) >= 0) {
        let d = r[u++];
        p.addInner(d.from, d.to, d.value) || h.push(d);
      } else
        l.rangeIndex == 1 && l.chunkIndex < this.chunk.length && (u == r.length || this.chunkEnd(l.chunkIndex) < r[u].from) && (!a || n > this.chunkEnd(l.chunkIndex) || s < this.chunkPos[l.chunkIndex]) && p.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex]) ? l.nextChunk() : ((!a || n > l.to || s < l.from || a(l.from, l.to, l.value)) && (p.addInner(l.from, l.to, l.value) || h.push(sf.create(l.from, l.to, l.value))), l.next());
    return p.finishInner(this.nextLayer.isEmpty && !h.length ? Me.empty : this.nextLayer.update({ add: h, filter: a, filterFrom: n, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let r = [], i = [], n = -1;
    for (let a = 0; a < this.chunk.length; a++) {
      let l = this.chunkPos[a], u = this.chunk[a], h = e.touchesRange(l, l + u.length);
      if (h === !1)
        n = Math.max(n, u.maxPoint), r.push(u), i.push(e.mapPos(l));
      else if (h === !0) {
        let { mapped: p, pos: d } = u.map(l, e);
        p && (n = Math.max(n, p.maxPoint), r.push(p), i.push(d));
      }
    }
    let s = this.nextLayer.map(e);
    return r.length == 0 ? s : new Me(i, r, s || Me.empty, n);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, r, i) {
    if (!this.isEmpty) {
      for (let n = 0; n < this.chunk.length; n++) {
        let s = this.chunkPos[n], a = this.chunk[n];
        if (r >= s && e <= s + a.length && a.between(s, e - s, r - s, i) === !1)
          return;
      }
      this.nextLayer.between(e, r, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return rl.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, r = 0) {
    return rl.from(e).goto(r);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, r, i, n, s = -1) {
    let a = e.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= s), l = r.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= s), u = w1(a, l, i), h = new po(a, u, s), p = new po(l, u, s);
    i.iterGaps((d, m, y) => S1(h, d, p, m, y, n)), i.empty && i.length == 0 && S1(h, 0, p, 0, 0, n);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, r, i = 0, n) {
    n == null && (n = 999999999);
    let s = e.filter((p) => !p.isEmpty && r.indexOf(p) < 0), a = r.filter((p) => !p.isEmpty && e.indexOf(p) < 0);
    if (s.length != a.length)
      return !1;
    if (!s.length)
      return !0;
    let l = w1(s, a), u = new po(s, l, 0).goto(i), h = new po(a, l, 0).goto(i);
    for (; ; ) {
      if (u.to != h.to || !of(u.active, h.active) || u.point && (!h.point || !u.point.eq(h.point)))
        return !1;
      if (u.to > n)
        return !0;
      u.next(), h.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, r, i, n, s = -1) {
    let a = new po(e, null, s).goto(r), l = r, u = a.openStart;
    for (; ; ) {
      let h = Math.min(a.to, i);
      if (a.point) {
        let p = a.activeForPoint(a.to), d = a.pointFrom < r ? p.length + 1 : Math.min(p.length, u);
        n.point(l, h, a.point, p, d, a.pointRank), u = Math.min(a.openEnd(h), p.length);
      } else
        h > l && (n.span(l, h, a.active, u), u = a.openEnd(h));
      if (a.to > i)
        return u + (a.point && a.to > i ? 1 : 0);
      l = a.to, a.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, r = !1) {
    let i = new Mn();
    for (let n of e instanceof sf ? [e] : r ? WQ(e) : e)
      i.add(n.from, n.to, n.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return Me.empty;
    let r = e[e.length - 1];
    for (let i = e.length - 2; i >= 0; i--)
      for (let n = e[i]; n != Me.empty; n = n.nextLayer)
        r = new Me(n.chunkPos, n.chunk, r, Math.max(n.maxPoint, r.maxPoint));
    return r;
  }
}
Me.empty = /* @__PURE__ */ new Me([], [], null, -1);
function WQ(t) {
  if (t.length > 1)
    for (let e = t[0], r = 1; r < t.length; r++) {
      let i = t[r];
      if (af(e, i) > 0)
        return t.slice().sort(af);
      e = i;
    }
  return t;
}
Me.empty.nextLayer = Me.empty;
class Mn {
  finishChunk(e) {
    this.chunks.push(new Bg(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, r, i) {
    this.addInner(e, r, i) || (this.nextLayer || (this.nextLayer = new Mn())).add(e, r, i);
  }
  /**
  @internal
  */
  addInner(e, r, i) {
    let n = e - this.lastTo || i.startSide - this.last.endSide;
    if (n <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return n < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(r - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = r, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, r - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, r) {
    if ((e - this.lastTo || r.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, r.maxPoint), this.chunks.push(r), this.chunkPos.push(e);
    let i = r.value.length - 1;
    return this.last = r.value[i], this.lastFrom = r.from[i] + e, this.lastTo = r.to[i] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Me.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let r = Me.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, r;
  }
}
function w1(t, e, r) {
  let i = /* @__PURE__ */ new Map();
  for (let s of t)
    for (let a = 0; a < s.chunk.length; a++)
      s.chunk[a].maxPoint <= 0 && i.set(s.chunk[a], s.chunkPos[a]);
  let n = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let a = 0; a < s.chunk.length; a++) {
      let l = i.get(s.chunk[a]);
      l != null && (r ? r.mapPos(l) : l) == s.chunkPos[a] && !(r != null && r.touchesRange(l, l + s.chunk[a].length)) && n.add(s.chunk[a]);
    }
  return n;
}
class Hw {
  constructor(e, r, i, n = 0) {
    this.layer = e, this.skip = r, this.minPoint = i, this.rank = n;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, r = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, r, !1), this;
  }
  gotoInner(e, r, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let n = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(n) || this.layer.chunkEnd(this.chunkIndex) < e || n.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let n = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], r, !0);
      (!i || this.rangeIndex < n) && this.setRangeIndex(n);
    }
    this.next();
  }
  forward(e, r) {
    (this.to - e || this.endSide - r) < 0 && this.gotoInner(e, r, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], r = this.layer.chunk[this.chunkIndex], i = e + r.from[this.rangeIndex];
        if (this.from = i, this.to = e + r.to[this.rangeIndex], this.value = r.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class rl {
  constructor(e) {
    this.heap = e;
  }
  static from(e, r = null, i = -1) {
    let n = [];
    for (let s = 0; s < e.length; s++)
      for (let a = e[s]; !a.isEmpty; a = a.nextLayer)
        a.maxPoint >= i && n.push(new Hw(a, r, i, s));
    return n.length == 1 ? n[0] : new rl(n);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, r = -1e9) {
    for (let i of this.heap)
      i.goto(e, r);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Np(this.heap, i);
    return this.next(), this;
  }
  forward(e, r) {
    for (let i of this.heap)
      i.forward(e, r);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Np(this.heap, i);
    (this.to - e || this.value.endSide - r) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Np(this.heap, 0);
    }
  }
}
function Np(t, e) {
  for (let r = t[e]; ; ) {
    let i = (e << 1) + 1;
    if (i >= t.length)
      break;
    let n = t[i];
    if (i + 1 < t.length && n.compare(t[i + 1]) >= 0 && (n = t[i + 1], i++), r.compare(n) < 0)
      break;
    t[i] = r, t[e] = n, e = i;
  }
}
class po {
  constructor(e, r, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = rl.from(e, r, i);
  }
  goto(e, r = -1e9) {
    return this.cursor.goto(e, r), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = r, this.openStart = -1, this.next(), this;
  }
  forward(e, r) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - r) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, r);
  }
  removeActive(e) {
    gu(this.active, e), gu(this.activeTo, e), gu(this.activeRank, e), this.minActive = C1(this.active, this.activeTo);
  }
  addActive(e) {
    let r = 0, { value: i, to: n, rank: s } = this.cursor;
    for (; r < this.activeRank.length && (s - this.activeRank[r] || n - this.activeTo[r]) > 0; )
      r++;
    yu(this.active, r, i), yu(this.activeTo, r, n), yu(this.activeRank, r, s), e && yu(e, r, this.cursor.from), this.minActive = C1(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, r = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let n = this.minActive;
      if (n > -1 && (this.activeTo[n] - this.cursor.from || this.active[n].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[n] > e) {
          this.to = this.activeTo[n], this.endSide = this.active[n].endSide;
          break;
        }
        this.removeActive(n), i && gu(i, n);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(i), this.cursor.next();
          else if (r && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let n = i.length - 1; n >= 0 && i[n] < e; n--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let r = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && r.push(this.active[i]);
    return r.reverse();
  }
  openEnd(e) {
    let r = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)
      r++;
    return r;
  }
}
function S1(t, e, r, i, n, s) {
  t.goto(e), r.goto(i);
  let a = i + n, l = i, u = i - e;
  for (; ; ) {
    let h = t.to + u - r.to || t.endSide - r.endSide, p = h < 0 ? t.to + u : r.to, d = Math.min(p, a);
    if (t.point || r.point ? t.point && r.point && (t.point == r.point || t.point.eq(r.point)) && of(t.activeForPoint(t.to), r.activeForPoint(r.to)) || s.comparePoint(l, d, t.point, r.point) : d > l && !of(t.active, r.active) && s.compareRange(l, d, t.active, r.active), p > a)
      break;
    l = p, h <= 0 && t.next(), h >= 0 && r.next();
  }
}
function of(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (t[r] != e[r] && !t[r].eq(e[r]))
      return !1;
  return !0;
}
function gu(t, e) {
  for (let r = e, i = t.length - 1; r < i; r++)
    t[r] = t[r + 1];
  t.pop();
}
function yu(t, e, r) {
  for (let i = t.length - 1; i >= e; i--)
    t[i + 1] = t[i];
  t[e] = r;
}
function C1(t, e) {
  let r = -1, i = 1e9;
  for (let n = 0; n < e.length; n++)
    (e[n] - i || t[n].endSide - t[r].endSide) < 0 && (r = n, i = e[n]);
  return r;
}
function Va(t, e, r = t.length) {
  let i = 0;
  for (let n = 0; n < r; )
    t.charCodeAt(n) == 9 ? (i += e - i % e, n++) : (i++, n = Ft(t, n));
  return i;
}
function lf(t, e, r, i) {
  for (let n = 0, s = 0; ; ) {
    if (s >= e)
      return n;
    if (n == t.length)
      break;
    s += t.charCodeAt(n) == 9 ? r - s % r : 1, n = Ft(t, n);
  }
  return i === !0 ? -1 : t.length;
}
const uf = "ͼ", E1 = typeof Symbol > "u" ? "__" + uf : Symbol.for(uf), cf = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), A1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Ln {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, r) {
    this.rules = [];
    let { finish: i } = r || {};
    function n(a) {
      return /^@/.test(a) ? [a] : a.split(/,\s*/);
    }
    function s(a, l, u, h) {
      let p = [], d = /^@(\w+)\b/.exec(a[0]), m = d && d[1] == "keyframes";
      if (d && l == null)
        return u.push(a[0] + ";");
      for (let y in l) {
        let O = l[y];
        if (/&/.test(y))
          s(
            y.split(/,\s*/).map((D) => a.map((v) => D.replace(/&/, v))).reduce((D, v) => D.concat(v)),
            O,
            u
          );
        else if (O && typeof O == "object") {
          if (!d)
            throw new RangeError("The value of a property (" + y + ") should be a primitive value.");
          s(n(y), O, p, m);
        } else
          O != null && p.push(y.replace(/_.*/, "").replace(/[A-Z]/g, (D) => "-" + D.toLowerCase()) + ": " + O + ";");
      }
      (p.length || m) && u.push((i && !d && !h ? a.map(i) : a).join(", ") + " {" + p.join(" ") + "}");
    }
    for (let a in e)
      s(n(a), e[a], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = A1[E1] || 1;
    return A1[E1] = e + 1, uf + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, r, i) {
    let n = e[cf], s = i && i.nonce;
    n ? s && n.setNonce(s) : n = new qQ(e, s), n.mount(Array.isArray(r) ? r : [r]);
  }
}
let k1 = /* @__PURE__ */ new Map();
class qQ {
  constructor(e, r) {
    let i = e.ownerDocument || e, n = i.defaultView;
    if (!e.head && e.adoptedStyleSheets && n.CSSStyleSheet) {
      let s = k1.get(i);
      if (s)
        return e.adoptedStyleSheets = [s.sheet, ...e.adoptedStyleSheets], e[cf] = s;
      this.sheet = new n.CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets], k1.set(i, this);
    } else {
      this.styleTag = i.createElement("style"), r && this.styleTag.setAttribute("nonce", r);
      let s = e.head || e;
      s.insertBefore(this.styleTag, s.firstChild);
    }
    this.modules = [], e[cf] = this;
  }
  mount(e) {
    let r = this.sheet, i = 0, n = 0;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], l = this.modules.indexOf(a);
      if (l < n && l > -1 && (this.modules.splice(l, 1), n--, l = -1), l == -1) {
        if (this.modules.splice(n++, 0, a), r)
          for (let u = 0; u < a.rules.length; u++)
            r.insertRule(a.rules[u], i++);
      } else {
        for (; n < l; )
          i += this.modules[n++].rules.length;
        i += a.rules.length, n++;
      }
    }
    if (!r) {
      let s = "";
      for (let a = 0; a < this.modules.length; a++)
        s += this.modules[a].getRules() + `
`;
      this.styleTag.textContent = s;
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var Qn = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, il = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, XQ = typeof navigator < "u" && /Mac/.test(navigator.platform), VQ = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var At = 0; At < 10; At++)
  Qn[48 + At] = Qn[96 + At] = String(At);
for (var At = 1; At <= 24; At++)
  Qn[At + 111] = "F" + At;
for (var At = 65; At <= 90; At++)
  Qn[At] = String.fromCharCode(At + 32), il[At] = String.fromCharCode(At);
for (var _p in Qn)
  il.hasOwnProperty(_p) || (il[_p] = Qn[_p]);
function UQ(t) {
  var e = XQ && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || VQ && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", r = !e && t.key || (t.shiftKey ? il : Qn)[t.keyCode] || t.key || "Unidentified";
  return r == "Esc" && (r = "Escape"), r == "Del" && (r = "Delete"), r == "Left" && (r = "ArrowLeft"), r == "Up" && (r = "ArrowUp"), r == "Right" && (r = "ArrowRight"), r == "Down" && (r = "ArrowDown"), r;
}
function bc(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function hf(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function YQ(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function Gu(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return hf(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function ka(t) {
  return t.nodeType == 3 ? Ss(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function Zo(t, e, r, i) {
  return r ? T1(t, e, r, i, -1) || T1(t, e, r, i, 1) : !1;
}
function nl(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function T1(t, e, r, i, n) {
  for (; ; ) {
    if (t == r && e == i)
      return !0;
    if (e == (n < 0 ? 0 : zi(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let s = t.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = nl(t) + (n < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (n < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = n < 0 ? zi(t) : 0;
    } else
      return !1;
  }
}
function zi(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function _h(t, e) {
  let r = e ? t.left : t.right;
  return { left: r, right: r, top: t.top, bottom: t.bottom };
}
function zQ(t) {
  return {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function Jw(t, e) {
  let r = e.width / t.offsetWidth, i = e.height / t.offsetHeight;
  return (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.width - t.offsetWidth) < 1) && (r = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(e.height - t.offsetHeight) < 1) && (i = 1), { scaleX: r, scaleY: i };
}
function GQ(t, e, r, i, n, s, a, l) {
  let u = t.ownerDocument, h = u.defaultView || window;
  for (let p = t, d = !1; p && !d; )
    if (p.nodeType == 1) {
      let m, y = p == u.body, O = 1, D = 1;
      if (y)
        m = zQ(h);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(p).position) && (d = !0), p.scrollHeight <= p.clientHeight && p.scrollWidth <= p.clientWidth) {
          p = p.assignedSlot || p.parentNode;
          continue;
        }
        let x = p.getBoundingClientRect();
        ({ scaleX: O, scaleY: D } = Jw(p, x)), m = {
          left: x.left,
          right: x.left + p.clientWidth * O,
          top: x.top,
          bottom: x.top + p.clientHeight * D
        };
      }
      let v = 0, w = 0;
      if (n == "nearest")
        e.top < m.top ? (w = -(m.top - e.top + a), r > 0 && e.bottom > m.bottom + w && (w = e.bottom - m.bottom + w + a)) : e.bottom > m.bottom && (w = e.bottom - m.bottom + a, r < 0 && e.top - w < m.top && (w = -(m.top + w - e.top + a)));
      else {
        let x = e.bottom - e.top, S = m.bottom - m.top;
        w = (n == "center" && x <= S ? e.top + x / 2 - S / 2 : n == "start" || n == "center" && r < 0 ? e.top - a : e.bottom - S + a) - m.top;
      }
      if (i == "nearest" ? e.left < m.left ? (v = -(m.left - e.left + s), r > 0 && e.right > m.right + v && (v = e.right - m.right + v + s)) : e.right > m.right && (v = e.right - m.right + s, r < 0 && e.left < m.left + v && (v = -(m.left + v - e.left + s))) : v = (i == "center" ? e.left + (e.right - e.left) / 2 - (m.right - m.left) / 2 : i == "start" == l ? e.left - s : e.right - (m.right - m.left) + s) - m.left, v || w)
        if (y)
          h.scrollBy(v, w);
        else {
          let x = 0, S = 0;
          if (w) {
            let k = p.scrollTop;
            p.scrollTop += w / D, S = (p.scrollTop - k) * D;
          }
          if (v) {
            let k = p.scrollLeft;
            p.scrollLeft += v / O, x = (p.scrollLeft - k) * O;
          }
          e = {
            left: e.left - x,
            top: e.top - S,
            right: e.right - x,
            bottom: e.bottom - S
          }, x && Math.abs(x - v) < 1 && (i = "nearest"), S && Math.abs(S - w) < 1 && (n = "nearest");
        }
      if (y)
        break;
      p = p.assignedSlot || p.parentNode;
    } else if (p.nodeType == 11)
      p = p.host;
    else
      break;
}
function HQ(t) {
  let e = t.ownerDocument;
  for (let r = t.parentNode; r && r != e.body; )
    if (r.nodeType == 1) {
      if (r.scrollHeight > r.clientHeight || r.scrollWidth > r.clientWidth)
        return r;
      r = r.assignedSlot || r.parentNode;
    } else if (r.nodeType == 11)
      r = r.host;
    else
      break;
  return null;
}
class JQ {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: r, focusNode: i } = e;
    this.set(r, Math.min(e.anchorOffset, r ? zi(r) : 0), i, Math.min(e.focusOffset, i ? zi(i) : 0));
  }
  set(e, r, i, n) {
    this.anchorNode = e, this.anchorOffset = r, this.focusNode = i, this.focusOffset = n;
  }
}
let Hs = null;
function Kw(t) {
  if (t.setActive)
    return t.setActive();
  if (Hs)
    return t.focus(Hs);
  let e = [];
  for (let r = t; r && (e.push(r, r.scrollTop, r.scrollLeft), r != r.ownerDocument); r = r.parentNode)
    ;
  if (t.focus(Hs == null ? {
    get preventScroll() {
      return Hs = { preventScroll: !0 }, !0;
    }
  } : void 0), !Hs) {
    Hs = !1;
    for (let r = 0; r < e.length; ) {
      let i = e[r++], n = e[r++], s = e[r++];
      i.scrollTop != n && (i.scrollTop = n), i.scrollLeft != s && (i.scrollLeft = s);
    }
  }
}
let P1;
function Ss(t, e, r = e) {
  let i = P1 || (P1 = document.createRange());
  return i.setEnd(t, r), i.setStart(t, e), i;
}
function ma(t, e, r) {
  let i = { key: e, code: e, keyCode: r, which: r, cancelable: !0 }, n = new KeyboardEvent("keydown", i);
  n.synthetic = !0, t.dispatchEvent(n);
  let s = new KeyboardEvent("keyup", i);
  return s.synthetic = !0, t.dispatchEvent(s), n.defaultPrevented || s.defaultPrevented;
}
function KQ(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function eS(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function ej(t, e) {
  let r = e.focusNode, i = e.focusOffset;
  if (!r || e.anchorNode != r || e.anchorOffset != i)
    return !1;
  for (i = Math.min(i, zi(r)); ; )
    if (i) {
      if (r.nodeType != 1)
        return !1;
      let n = r.childNodes[i - 1];
      n.contentEditable == "false" ? i-- : (r = n, i = zi(r));
    } else {
      if (r == t)
        return !0;
      i = nl(r), r = r.parentNode;
    }
}
function tS(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
class Zt {
  constructor(e, r, i = !0) {
    this.node = e, this.offset = r, this.precise = i;
  }
  static before(e, r) {
    return new Zt(e.parentNode, nl(e), r);
  }
  static after(e, r) {
    return new Zt(e.parentNode, nl(e) + 1, r);
  }
}
const Ig = [];
class et {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let r = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return r;
      r += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, r) {
    if (this.flags & 2) {
      let i = this.dom, n = null, s;
      for (let a of this.children) {
        if (a.flags & 7) {
          if (!a.dom && (s = n ? n.nextSibling : i.firstChild)) {
            let l = et.get(s);
            (!l || !l.parent && l.canReuseDOM(a)) && a.reuseDOM(s);
          }
          a.sync(e, r), a.flags &= -8;
        }
        if (s = n ? n.nextSibling : i.firstChild, r && !r.written && r.node == i && s != a.dom && (r.written = !0), a.dom.parentNode == i)
          for (; s && s != a.dom; )
            s = F1(s);
        else
          i.insertBefore(a.dom, s);
        n = a.dom;
      }
      for (s = n ? n.nextSibling : i.firstChild, s && r && r.node == i && (r.written = !0); s; )
        s = F1(s);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(e, r), i.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, r) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[r];
    else {
      let n = zi(e) == 0 ? 0 : r == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        n == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? n = -1 : n = 1), e = s;
      }
      n < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !et.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let n = 0, s = 0; ; n++) {
      let a = this.children[n];
      if (a.dom == i)
        return s;
      s += a.length + a.breakAfter;
    }
  }
  domBoundsAround(e, r, i = 0) {
    let n = -1, s = -1, a = -1, l = -1;
    for (let u = 0, h = i, p = i; u < this.children.length; u++) {
      let d = this.children[u], m = h + d.length;
      if (h < e && m > r)
        return d.domBoundsAround(e, r, h);
      if (m >= e && n == -1 && (n = u, s = h), h > r && d.dom.parentNode == this.dom) {
        a = u, l = p;
        break;
      }
      p = m, h = m + d.breakAfter;
    }
    return {
      from: s,
      to: l < 0 ? i + this.length : l,
      startDOM: (n ? this.children[n - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: a < this.children.length && a >= 0 ? this.children[a].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let r = this.parent; r; r = r.parent) {
      if (e && (r.flags |= 2), r.flags & 1)
        return;
      r.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let r = e.parent;
      if (!r)
        return e;
      e = r;
    }
  }
  replaceChildren(e, r, i = Ig) {
    this.markDirty();
    for (let n = e; n < r; n++) {
      let s = this.children[n];
      s.parent == this && i.indexOf(s) < 0 && s.destroy();
    }
    this.children.splice(e, r - e, ...i);
    for (let n = 0; n < i.length; n++)
      i[n].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new rS(this.children, e, this.children.length);
  }
  childPos(e, r = 1) {
    return this.childCursor().findPos(e, r);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, r, i, n, s, a) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
et.prototype.breakAfter = 0;
function F1(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class rS {
  constructor(e, r, i) {
    this.children = e, this.pos = r, this.i = i, this.off = 0;
  }
  findPos(e, r = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (r > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function iS(t, e, r, i, n, s, a, l, u) {
  let { children: h } = t, p = h.length ? h[e] : null, d = s.length ? s[s.length - 1] : null, m = d ? d.breakAfter : a;
  if (!(e == i && p && !a && !m && s.length < 2 && p.merge(r, n, s.length ? d : null, r == 0, l, u))) {
    if (i < h.length) {
      let y = h[i];
      y && (n < y.length || y.breakAfter && (d != null && d.breakAfter)) ? (e == i && (y = y.split(n), n = 0), !m && d && y.merge(0, n, d, !0, 0, u) ? s[s.length - 1] = y : ((n || y.children.length && !y.children[0].length) && y.merge(0, n, null, !1, 0, u), s.push(y))) : y != null && y.breakAfter && (d ? d.breakAfter = 1 : a = 1), i++;
    }
    for (p && (p.breakAfter = a, r > 0 && (!a && s.length && p.merge(r, p.length, s[0], !1, l, 0) ? p.breakAfter = s.shift().breakAfter : (r < p.length || p.children.length && p.children[p.children.length - 1].length == 0) && p.merge(r, p.length, null, !1, l, 0), e++)); e < i && s.length; )
      if (h[i - 1].become(s[s.length - 1]))
        i--, s.pop(), u = s.length ? 0 : l;
      else if (h[e].become(s[0]))
        e++, s.shift(), l = s.length ? 0 : u;
      else
        break;
    !s.length && e && i < h.length && !h[e - 1].breakAfter && h[i].merge(0, 0, h[e - 1], !1, l, u) && e--, (e < i || s.length) && t.replaceChildren(e, i, s);
  }
}
function nS(t, e, r, i, n, s) {
  let a = t.childCursor(), { i: l, off: u } = a.findPos(r, 1), { i: h, off: p } = a.findPos(e, -1), d = e - r;
  for (let m of i)
    d += m.length;
  t.length += d, iS(t, h, p, l, u, i, 0, n, s);
}
let yr = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, pf = typeof document < "u" ? document : { documentElement: { style: {} } };
const df = /* @__PURE__ */ /Edge\/(\d+)/.exec(yr.userAgent), sS = /* @__PURE__ */ /MSIE \d/.test(yr.userAgent), ff = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(yr.userAgent), Mh = !!(sS || ff || df), $1 = !Mh && /* @__PURE__ */ /gecko\/(\d+)/i.test(yr.userAgent), Mp = !Mh && /* @__PURE__ */ /Chrome\/(\d+)/.exec(yr.userAgent), B1 = "webkitFontSmoothing" in pf.documentElement.style, aS = !Mh && /* @__PURE__ */ /Apple Computer/.test(yr.vendor), I1 = aS && (/* @__PURE__ */ /Mobile\/\w+/.test(yr.userAgent) || yr.maxTouchPoints > 2);
var ge = {
  mac: I1 || /* @__PURE__ */ /Mac/.test(yr.platform),
  windows: /* @__PURE__ */ /Win/.test(yr.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(yr.platform),
  ie: Mh,
  ie_version: sS ? pf.documentMode || 6 : ff ? +ff[1] : df ? +df[1] : 0,
  gecko: $1,
  gecko_version: $1 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(yr.userAgent) || [0, 0])[1] : 0,
  chrome: !!Mp,
  chrome_version: Mp ? +Mp[1] : 0,
  ios: I1,
  android: /* @__PURE__ */ /Android\b/.test(yr.userAgent),
  webkit: B1,
  safari: aS,
  webkit_version: B1 ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: pf.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const tj = 256;
class Gi extends et {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, r) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (r && r.node == this.dom && (r.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, r, i) {
    return this.flags & 8 || i && (!(i instanceof Gi) || this.length - (r - e) + i.length > tj || i.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(r), this.markDirty(), !0);
  }
  split(e) {
    let r = new Gi(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), r.flags |= this.flags & 8, r;
  }
  localPosFromDOM(e, r) {
    return e == this.dom ? r : r ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Zt(this.dom, e);
  }
  domBoundsAround(e, r, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, r) {
    return rj(this.dom, e, r);
  }
}
class Hi extends et {
  constructor(e, r = [], i = 0) {
    super(), this.mark = e, this.children = r, this.length = i;
    for (let n of r)
      n.setParent(this);
  }
  setAttrs(e) {
    if (eS(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let r in this.mark.attrs)
        e.setAttribute(r, this.mark.attrs[r]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, r);
  }
  merge(e, r, i, n, s, a) {
    return i && (!(i instanceof Hi && i.mark.eq(this.mark)) || e && s <= 0 || r < this.length && a <= 0) ? !1 : (nS(this, e, r, i ? i.children.slice() : [], s - 1, a - 1), this.markDirty(), !0);
  }
  split(e) {
    let r = [], i = 0, n = -1, s = 0;
    for (let l of this.children) {
      let u = i + l.length;
      u > e && r.push(i < e ? l.split(e - i) : l), n < 0 && i >= e && (n = s), i = u, s++;
    }
    let a = this.length - e;
    return this.length = e, n > -1 && (this.children.length = n, this.markDirty()), new Hi(this.mark, r, a);
  }
  domAtPos(e) {
    return oS(this, e);
  }
  coordsAt(e, r) {
    return uS(this, e, r);
  }
}
function rj(t, e, r) {
  let i = t.nodeValue.length;
  e > i && (e = i);
  let n = e, s = e, a = 0;
  e == 0 && r < 0 || e == i && r >= 0 ? ge.chrome || ge.gecko || (e ? (n--, a = 1) : s < i && (s++, a = -1)) : r < 0 ? n-- : s < i && s++;
  let l = Ss(t, n, s).getClientRects();
  if (!l.length)
    return null;
  let u = l[(a ? a < 0 : r >= 0) ? 0 : l.length - 1];
  return ge.safari && !a && u.width == 0 && (u = Array.prototype.find.call(l, (h) => h.width) || u), a ? _h(u, a < 0) : u || null;
}
class Cn extends et {
  static create(e, r, i) {
    return new Cn(e, r, i);
  }
  constructor(e, r, i) {
    super(), this.widget = e, this.length = r, this.side = i, this.prevWidget = null;
  }
  split(e) {
    let r = Cn.create(this.widget, this.length - e, this.side);
    return this.length -= e, r;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, r, i, n, s, a) {
    return i && (!(i instanceof Cn) || !this.widget.compare(i.widget) || e > 0 && s <= 0 || r < this.length && a <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - r), !0);
  }
  become(e) {
    return e instanceof Cn && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return je.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: r } = e, i = r && r.state.doc, n = this.posAtStart;
    return i ? i.slice(n, n + this.length) : je.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Zt.before(this.dom) : Zt.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, r) {
    let i = this.widget.coordsAt(this.dom, e, r);
    if (i)
      return i;
    let n = this.dom.getClientRects(), s = null;
    if (!n.length)
      return null;
    let a = this.side ? this.side < 0 : e > 0;
    for (let l = a ? n.length - 1 : 0; s = n[l], !(e > 0 ? l == 0 : l == n.length - 1 || s.top < s.bottom); l += a ? -1 : 1)
      ;
    return _h(s, !a);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Ta extends et {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Ta && e.side == this.side;
  }
  split() {
    return new Ta(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Zt.before(this.dom) : Zt.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return je.empty;
  }
  get isHidden() {
    return !0;
  }
}
Gi.prototype.children = Cn.prototype.children = Ta.prototype.children = Ig;
function oS(t, e) {
  let r = t.dom, { children: i } = t, n = 0;
  for (let s = 0; n < i.length; n++) {
    let a = i[n], l = s + a.length;
    if (!(l == s && a.getSide() <= 0)) {
      if (e > s && e < l && a.dom.parentNode == r)
        return a.domAtPos(e - s);
      if (e <= s)
        break;
      s = l;
    }
  }
  for (let s = n; s > 0; s--) {
    let a = i[s - 1];
    if (a.dom.parentNode == r)
      return a.domAtPos(a.length);
  }
  for (let s = n; s < i.length; s++) {
    let a = i[s];
    if (a.dom.parentNode == r)
      return a.domAtPos(0);
  }
  return new Zt(r, 0);
}
function lS(t, e, r) {
  let i, { children: n } = t;
  r > 0 && e instanceof Hi && n.length && (i = n[n.length - 1]) instanceof Hi && i.mark.eq(e.mark) ? lS(i, e.children[0], r - 1) : (n.push(e), e.setParent(t)), t.length += e.length;
}
function uS(t, e, r) {
  let i = null, n = -1, s = null, a = -1;
  function l(h, p) {
    for (let d = 0, m = 0; d < h.children.length && m <= p; d++) {
      let y = h.children[d], O = m + y.length;
      O >= p && (y.children.length ? l(y, p - m) : (!s || s.isHidden && r > 0) && (O > p || m == O && y.getSide() > 0) ? (s = y, a = p - m) : (m < p || m == O && y.getSide() < 0 && !y.isHidden) && (i = y, n = p - m)), m = O;
    }
  }
  l(t, e);
  let u = (r < 0 ? i : s) || i || s;
  return u ? u.coordsAt(Math.max(0, u == i ? n : a), r) : ij(t);
}
function ij(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let r = ka(e);
  return r[r.length - 1] || null;
}
function mf(t, e) {
  for (let r in t)
    r == "class" && e.class ? e.class += " " + t.class : r == "style" && e.style ? e.style += ";" + t.style : e[r] = t[r];
  return e;
}
const N1 = /* @__PURE__ */ Object.create(null);
function Ng(t, e, r) {
  if (t == e)
    return !0;
  t || (t = N1), e || (e = N1);
  let i = Object.keys(t), n = Object.keys(e);
  if (i.length - (r && i.indexOf(r) > -1 ? 1 : 0) != n.length - (r && n.indexOf(r) > -1 ? 1 : 0))
    return !1;
  for (let s of i)
    if (s != r && (n.indexOf(s) == -1 || t[s] !== e[s]))
      return !1;
  return !0;
}
function gf(t, e, r) {
  let i = !1;
  if (e)
    for (let n in e)
      r && n in r || (i = !0, n == "style" ? t.style.cssText = "" : t.removeAttribute(n));
  if (r)
    for (let n in r)
      e && e[n] == r[n] || (i = !0, n == "style" ? t.style.cssText = r[n] : t.setAttribute(n, r[n]));
  return i;
}
function nj(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r = 0; r < t.attributes.length; r++) {
    let i = t.attributes[r];
    e[i.name] = i.value;
  }
  return e;
}
class gt extends et {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, r, i, n, s, a) {
    if (i) {
      if (!(i instanceof gt))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return n && this.setDeco(i ? i.attrs : null), nS(this, e, r, i ? i.children.slice() : [], s, a), !0;
  }
  split(e) {
    let r = new gt();
    if (r.breakAfter = this.breakAfter, this.length == 0)
      return r;
    let { i, off: n } = this.childPos(e);
    n && (r.append(this.children[i].split(n), 0), this.children[i].merge(n, this.children[i].length, null, !1, 0, 0), i++);
    for (let s = i; s < this.children.length; s++)
      r.append(this.children[s], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, r;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Ng(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, r) {
    lS(this, e, r);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let r = e.spec.attributes, i = e.spec.class;
    r && (this.attrs = mf(r, this.attrs || {})), i && (this.attrs = mf({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return oS(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    var i;
    this.dom ? this.flags & 4 && (eS(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (gf(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, r);
    let n = this.dom.lastChild;
    for (; n && et.get(n) instanceof Hi; )
      n = n.lastChild;
    if (!n || !this.length || n.nodeName != "BR" && ((i = et.get(n)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!ge.ios || !this.children.some((s) => s instanceof Gi))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, r;
    for (let i of this.children) {
      if (!(i instanceof Gi) || /[^ -~]/.test(i.text))
        return null;
      let n = ka(i.dom);
      if (n.length != 1)
        return null;
      e += n[0].width, r = n[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: r
    } : null;
  }
  coordsAt(e, r) {
    let i = uS(this, e, r);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: n } = this.parent.view.viewState, s = i.bottom - i.top;
      if (Math.abs(s - n.lineHeight) < 2 && n.textHeight < s) {
        let a = (s - n.textHeight) / 2;
        return { top: i.top + a, bottom: i.bottom - a, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(e) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(e, r) {
    for (let i = 0, n = 0; i < e.children.length; i++) {
      let s = e.children[i], a = n + s.length;
      if (a >= r) {
        if (s instanceof gt)
          return s;
        if (a > r)
          break;
      }
      n = a + s.breakAfter;
    }
    return null;
  }
}
class Tn extends et {
  constructor(e, r, i) {
    super(), this.widget = e, this.length = r, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, r, i, n, s, a) {
    return i && (!(i instanceof Tn) || !this.widget.compare(i.widget) || e > 0 && s <= 0 || r < this.length && a <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - r), !0);
  }
  domAtPos(e) {
    return e == 0 ? Zt.before(this.dom) : Zt.after(this.dom, e == this.length);
  }
  split(e) {
    let r = this.length - e;
    this.length = e;
    let i = new Tn(this.widget, r, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return Ig;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : je.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Tn && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, r) {
    return this.widget.coordsAt(this.dom, e, r);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: r, endSide: i } = this.deco;
    return r == i ? !1 : e < 0 ? r < 0 : i > 0;
  }
}
class Mi {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, r) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, r, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Gt = /* @__PURE__ */ function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
}(Gt || (Gt = {}));
class Oe extends ws {
  constructor(e, r, i, n) {
    super(), this.startSide = e, this.endSide = r, this.widget = i, this.spec = n;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Il(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let r = Math.max(-1e4, Math.min(1e4, e.side || 0)), i = !!e.block;
    return r += i && !e.inlineOrder ? r > 0 ? 3e8 : -4e8 : r > 0 ? 1e8 : -1e8, new jn(e, r, r, i, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let r = !!e.block, i, n;
    if (e.isBlockGap)
      i = -5e8, n = 4e8;
    else {
      let { start: s, end: a } = cS(e, r);
      i = (s ? r ? -3e8 : -1 : 5e8) - 1, n = (a ? r ? 2e8 : 1 : -6e8) + 1;
    }
    return new jn(e, i, n, r, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Nl(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, r = !1) {
    return Me.of(e, r);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
Oe.none = Me.empty;
class Il extends Oe {
  constructor(e) {
    let { start: r, end: i } = cS(e);
    super(r ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var r, i;
    return this == e || e instanceof Il && this.tagName == e.tagName && (this.class || ((r = this.attrs) === null || r === void 0 ? void 0 : r.class)) == (e.class || ((i = e.attrs) === null || i === void 0 ? void 0 : i.class)) && Ng(this.attrs, e.attrs, "class");
  }
  range(e, r = e) {
    if (e >= r)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, r);
  }
}
Il.prototype.point = !1;
class Nl extends Oe {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Nl && this.spec.class == e.spec.class && Ng(this.spec.attributes, e.spec.attributes);
  }
  range(e, r = e) {
    if (r != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, r);
  }
}
Nl.prototype.mapMode = Tt.TrackBefore;
Nl.prototype.point = !0;
class jn extends Oe {
  constructor(e, r, i, n, s, a) {
    super(r, i, s, e), this.block = n, this.isReplace = a, this.mapMode = n ? r <= 0 ? Tt.TrackBefore : Tt.TrackAfter : Tt.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Gt.WidgetRange : this.startSide <= 0 ? Gt.WidgetBefore : Gt.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof jn && sj(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, r = e) {
    if (this.isReplace && (e > r || e == r && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && r != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, r);
  }
}
jn.prototype.point = !0;
function cS(t, e = !1) {
  let { inclusiveStart: r, inclusiveEnd: i } = t;
  return r == null && (r = t.inclusive), i == null && (i = t.inclusive), { start: r ?? e, end: i ?? e };
}
function sj(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function yf(t, e, r, i = 0) {
  let n = r.length - 1;
  n >= 0 && r[n] + i >= t ? r[n] = Math.max(r[n], e) : r.push(t, e);
}
class Wo {
  constructor(e, r, i, n) {
    this.doc = e, this.pos = r, this.end = i, this.disallowBlockEffectsFor = n, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = r;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof Tn && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new gt()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Ou(new Ta(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Tn) && this.getLine();
  }
  buildText(e, r, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: a, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (a) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let n = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(r.slice(r.length - i)), this.getLine().append(Ou(new Gi(this.text.slice(this.textOff, this.textOff + n)), r), i), this.atCursorPos = !0, this.textOff += n, e -= n, i = 0;
    }
  }
  span(e, r, i, n) {
    this.buildText(r - e, i, n), this.pos = r, this.openStart < 0 && (this.openStart = n);
  }
  point(e, r, i, n, s, a) {
    if (this.disallowBlockEffectsFor[a] && i instanceof jn) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (r > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = r - e;
    if (i instanceof jn)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Tn(i.widget || new _1("div"), l, i));
      else {
        let u = Cn.create(i.widget || new _1("span"), l, l ? 0 : i.startSide), h = this.atCursorPos && !u.isEditable && s <= n.length && (e < r || i.startSide > 0), p = !u.isEditable && (e < r || s > n.length || i.startSide <= 0), d = this.getLine();
        this.pendingBuffer == 2 && !h && !u.isEditable && (this.pendingBuffer = 0), this.flushBuffer(n), h && (d.append(Ou(new Ta(1), n), s), s = n.length + Math.max(0, s - n.length)), d.append(Ou(u, n), s), this.atCursorPos = p, this.pendingBuffer = p ? e < r || s > n.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = n.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = r), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, r, i, n, s) {
    let a = new Wo(e, r, i, s);
    return a.openEnd = Me.spans(n, r, i, a), a.openStart < 0 && (a.openStart = a.openEnd), a.finish(a.openEnd), a;
  }
}
function Ou(t, e) {
  for (let r of e)
    t = new Hi(r, [t], t.length);
  return t;
}
class _1 extends Mi {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
var tt = /* @__PURE__ */ function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
}(tt || (tt = {}));
const Cs = tt.LTR, _g = tt.RTL;
function hS(t) {
  let e = [];
  for (let r = 0; r < t.length; r++)
    e.push(1 << +t[r]);
  return e;
}
const aj = /* @__PURE__ */ hS("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), oj = /* @__PURE__ */ hS("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Of = /* @__PURE__ */ Object.create(null), pi = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), r = /* @__PURE__ */ t.charCodeAt(1);
  Of[e] = r, Of[r] = -e;
}
function pS(t) {
  return t <= 247 ? aj[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? oj[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const lj = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class En {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? _g : Cs;
  }
  /**
  @internal
  */
  constructor(e, r, i) {
    this.from = e, this.to = r, this.level = i;
  }
  /**
  @internal
  */
  side(e, r) {
    return this.dir == r == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, r) {
    return e == (this.dir == r);
  }
  /**
  @internal
  */
  static find(e, r, i, n) {
    let s = -1;
    for (let a = 0; a < e.length; a++) {
      let l = e[a];
      if (l.from <= r && l.to >= r) {
        if (l.level == i)
          return a;
        (s < 0 || (n != 0 ? n < 0 ? l.from < r : l.to > r : e[s].level > l.level)) && (s = a);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function dS(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++) {
    let i = t[r], n = e[r];
    if (i.from != n.from || i.to != n.to || i.direction != n.direction || !dS(i.inner, n.inner))
      return !1;
  }
  return !0;
}
const ze = [];
function uj(t, e, r, i, n) {
  for (let s = 0; s <= i.length; s++) {
    let a = s ? i[s - 1].to : e, l = s < i.length ? i[s].from : r, u = s ? 256 : n;
    for (let h = a, p = u, d = u; h < l; h++) {
      let m = pS(t.charCodeAt(h));
      m == 512 ? m = p : m == 8 && d == 4 && (m = 16), ze[h] = m == 4 ? 2 : m, m & 7 && (d = m), p = m;
    }
    for (let h = a, p = u, d = u; h < l; h++) {
      let m = ze[h];
      if (m == 128)
        h < l - 1 && p == ze[h + 1] && p & 24 ? m = ze[h] = p : ze[h] = 256;
      else if (m == 64) {
        let y = h + 1;
        for (; y < l && ze[y] == 64; )
          y++;
        let O = h && p == 8 || y < r && ze[y] == 8 ? d == 1 ? 1 : 8 : 256;
        for (let D = h; D < y; D++)
          ze[D] = O;
        h = y - 1;
      } else
        m == 8 && d == 1 && (ze[h] = 1);
      p = m, m & 7 && (d = m);
    }
  }
}
function cj(t, e, r, i, n) {
  let s = n == 1 ? 2 : 1;
  for (let a = 0, l = 0, u = 0; a <= i.length; a++) {
    let h = a ? i[a - 1].to : e, p = a < i.length ? i[a].from : r;
    for (let d = h, m, y, O; d < p; d++)
      if (y = Of[m = t.charCodeAt(d)])
        if (y < 0) {
          for (let D = l - 3; D >= 0; D -= 3)
            if (pi[D + 1] == -y) {
              let v = pi[D + 2], w = v & 2 ? n : v & 4 ? v & 1 ? s : n : 0;
              w && (ze[d] = ze[pi[D]] = w), l = D;
              break;
            }
        } else {
          if (pi.length == 189)
            break;
          pi[l++] = d, pi[l++] = m, pi[l++] = u;
        }
      else if ((O = ze[d]) == 2 || O == 1) {
        let D = O == n;
        u = D ? 0 : 1;
        for (let v = l - 3; v >= 0; v -= 3) {
          let w = pi[v + 2];
          if (w & 2)
            break;
          if (D)
            pi[v + 2] |= 2;
          else {
            if (w & 4)
              break;
            pi[v + 2] |= 4;
          }
        }
      }
  }
}
function hj(t, e, r, i) {
  for (let n = 0, s = i; n <= r.length; n++) {
    let a = n ? r[n - 1].to : t, l = n < r.length ? r[n].from : e;
    for (let u = a; u < l; ) {
      let h = ze[u];
      if (h == 256) {
        let p = u + 1;
        for (; ; )
          if (p == l) {
            if (n == r.length)
              break;
            p = r[n++].to, l = n < r.length ? r[n].from : e;
          } else if (ze[p] == 256)
            p++;
          else
            break;
        let d = s == 1, m = (p < e ? ze[p] : i) == 1, y = d == m ? d ? 1 : 2 : i;
        for (let O = p, D = n, v = D ? r[D - 1].to : t; O > u; )
          O == v && (O = r[--D].from, v = D ? r[D - 1].to : t), ze[--O] = y;
        u = p;
      } else
        s = h, u++;
    }
  }
}
function xf(t, e, r, i, n, s, a) {
  let l = i % 2 ? 2 : 1;
  if (i % 2 == n % 2)
    for (let u = e, h = 0; u < r; ) {
      let p = !0, d = !1;
      if (h == s.length || u < s[h].from) {
        let D = ze[u];
        D != l && (p = !1, d = D == 16);
      }
      let m = !p && l == 1 ? [] : null, y = p ? i : i + 1, O = u;
      e:
        for (; ; )
          if (h < s.length && O == s[h].from) {
            if (d)
              break e;
            let D = s[h];
            if (!p)
              for (let v = D.to, w = h + 1; ; ) {
                if (v == r)
                  break e;
                if (w < s.length && s[w].from == v)
                  v = s[w++].to;
                else {
                  if (ze[v] == l)
                    break e;
                  break;
                }
              }
            if (h++, m)
              m.push(D);
            else {
              D.from > u && a.push(new En(u, D.from, y));
              let v = D.direction == Cs != !(y % 2);
              Df(t, v ? i + 1 : i, n, D.inner, D.from, D.to, a), u = D.to;
            }
            O = D.to;
          } else {
            if (O == r || (p ? ze[O] != l : ze[O] == l))
              break;
            O++;
          }
      m ? xf(t, u, O, i + 1, n, m, a) : u < O && a.push(new En(u, O, y)), u = O;
    }
  else
    for (let u = r, h = s.length; u > e; ) {
      let p = !0, d = !1;
      if (!h || u > s[h - 1].to) {
        let D = ze[u - 1];
        D != l && (p = !1, d = D == 16);
      }
      let m = !p && l == 1 ? [] : null, y = p ? i : i + 1, O = u;
      e:
        for (; ; )
          if (h && O == s[h - 1].to) {
            if (d)
              break e;
            let D = s[--h];
            if (!p)
              for (let v = D.from, w = h; ; ) {
                if (v == e)
                  break e;
                if (w && s[w - 1].to == v)
                  v = s[--w].from;
                else {
                  if (ze[v - 1] == l)
                    break e;
                  break;
                }
              }
            if (m)
              m.push(D);
            else {
              D.to < u && a.push(new En(D.to, u, y));
              let v = D.direction == Cs != !(y % 2);
              Df(t, v ? i + 1 : i, n, D.inner, D.from, D.to, a), u = D.from;
            }
            O = D.from;
          } else {
            if (O == e || (p ? ze[O - 1] != l : ze[O - 1] == l))
              break;
            O--;
          }
      m ? xf(t, O, u, i + 1, n, m, a) : O < u && a.push(new En(O, u, y)), u = O;
    }
}
function Df(t, e, r, i, n, s, a) {
  let l = e % 2 ? 2 : 1;
  uj(t, n, s, i, l), cj(t, n, s, i, l), hj(n, s, i, l), xf(t, n, s, e, r, i, a);
}
function pj(t, e, r) {
  if (!t)
    return [new En(0, 0, e == _g ? 1 : 0)];
  if (e == Cs && !r.length && !lj.test(t))
    return fS(t.length);
  if (r.length)
    for (; t.length > ze.length; )
      ze[ze.length] = 256;
  let i = [], n = e == Cs ? 0 : 1;
  return Df(t, n, n, r, 0, t.length, i), i;
}
function fS(t) {
  return [new En(0, t, 0)];
}
let mS = "";
function dj(t, e, r, i, n) {
  var s;
  let a = i.head - t.from, l = En.find(e, a, (s = i.bidiLevel) !== null && s !== void 0 ? s : -1, i.assoc), u = e[l], h = u.side(n, r);
  if (a == h) {
    let m = l += n ? 1 : -1;
    if (m < 0 || m >= e.length)
      return null;
    u = e[l = m], a = u.side(!n, r), h = u.side(n, r);
  }
  let p = Ft(t.text, a, u.forward(n, r));
  (p < u.from || p > u.to) && (p = h), mS = t.text.slice(Math.min(a, p), Math.max(a, p));
  let d = l == (n ? e.length - 1 : 0) ? null : e[l + (n ? 1 : -1)];
  return d && p == h && d.level + (n ? 0 : 1) < u.level ? Y.cursor(d.side(!n, r) + t.from, d.forward(n, r) ? 1 : -1, d.level) : Y.cursor(p + t.from, u.forward(n, r) ? -1 : 1, u.level);
}
function fj(t, e, r) {
  for (let i = e; i < r; i++) {
    let n = pS(t.charCodeAt(i));
    if (n == 1)
      return Cs;
    if (n == 2 || n == 4)
      return _g;
  }
  return Cs;
}
const gS = /* @__PURE__ */ fe.define(), yS = /* @__PURE__ */ fe.define(), OS = /* @__PURE__ */ fe.define(), xS = /* @__PURE__ */ fe.define(), bf = /* @__PURE__ */ fe.define(), DS = /* @__PURE__ */ fe.define(), bS = /* @__PURE__ */ fe.define(), vS = /* @__PURE__ */ fe.define({
  combine: (t) => t.some((e) => e)
}), wS = /* @__PURE__ */ fe.define({
  combine: (t) => t.some((e) => e)
});
class ga {
  constructor(e, r = "nearest", i = "nearest", n = 5, s = 5, a = !1) {
    this.range = e, this.y = r, this.x = i, this.yMargin = n, this.xMargin = s, this.isSnapshot = a;
  }
  map(e) {
    return e.empty ? this : new ga(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new ga(Y.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const xu = /* @__PURE__ */ we.define({ map: (t, e) => t.map(e) });
function Nr(t, e, r) {
  let i = t.facet(xS);
  i.length ? i[0](e) : window.onerror ? window.onerror(String(e), r, void 0, void 0, e) : r ? console.error(r + ":", e) : console.error(e);
}
const Lh = /* @__PURE__ */ fe.define({ combine: (t) => t.length ? t[0] : !0 });
let mj = 0;
const wo = /* @__PURE__ */ fe.define();
class ct {
  constructor(e, r, i, n, s) {
    this.id = e, this.create = r, this.domEventHandlers = i, this.domEventObservers = n, this.extension = s(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, r) {
    const { eventHandlers: i, eventObservers: n, provide: s, decorations: a } = r || {};
    return new ct(mj++, e, i, n, (l) => {
      let u = [wo.of(l)];
      return a && u.push(sl.of((h) => {
        let p = h.plugin(l);
        return p ? a(p) : Oe.none;
      })), s && u.push(s(l)), u;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, r) {
    return ct.define((i) => new e(i), r);
  }
}
class Lp {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let r = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(r);
          } catch (i) {
            if (Nr(r.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (r) {
        Nr(e.state, r, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var r;
    if (!((r = this.value) === null || r === void 0) && r.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        Nr(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const SS = /* @__PURE__ */ fe.define(), Mg = /* @__PURE__ */ fe.define(), sl = /* @__PURE__ */ fe.define(), CS = /* @__PURE__ */ fe.define(), Lg = /* @__PURE__ */ fe.define(), ES = /* @__PURE__ */ fe.define();
function M1(t, e) {
  let r = t.state.facet(ES);
  if (!r.length)
    return r;
  let i = r.map((s) => s instanceof Function ? s(t) : s), n = [];
  return Me.spans(i, e.from, e.to, {
    point() {
    },
    span(s, a, l, u) {
      let h = s - e.from, p = a - e.from, d = n;
      for (let m = l.length - 1; m >= 0; m--, u--) {
        let y = l[m].spec.bidiIsolate, O;
        if (y == null && (y = fj(e.text, h, p)), u > 0 && d.length && (O = d[d.length - 1]).to == h && O.direction == y)
          O.to = p, d = O.inner;
        else {
          let D = { from: h, to: p, direction: y, inner: [] };
          d.push(D), d = D.inner;
        }
      }
    }
  }), n;
}
const AS = /* @__PURE__ */ fe.define();
function kS(t) {
  let e = 0, r = 0, i = 0, n = 0;
  for (let s of t.state.facet(AS)) {
    let a = s(t);
    a && (a.left != null && (e = Math.max(e, a.left)), a.right != null && (r = Math.max(r, a.right)), a.top != null && (i = Math.max(i, a.top)), a.bottom != null && (n = Math.max(n, a.bottom)));
  }
  return { left: e, right: r, top: i, bottom: n };
}
const So = /* @__PURE__ */ fe.define();
class _r {
  constructor(e, r, i, n) {
    this.fromA = e, this.toA = r, this.fromB = i, this.toB = n;
  }
  join(e) {
    return new _r(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let r = e.length, i = this;
    for (; r > 0; r--) {
      let n = e[r - 1];
      if (!(n.fromA > i.toA)) {
        if (n.toA < i.fromA)
          break;
        i = i.join(n), e.splice(r - 1, 1);
      }
    }
    return e.splice(r, 0, i), e;
  }
  static extendWithRanges(e, r) {
    if (r.length == 0)
      return e;
    let i = [];
    for (let n = 0, s = 0, a = 0, l = 0; ; n++) {
      let u = n == e.length ? null : e[n], h = a - l, p = u ? u.fromB : 1e9;
      for (; s < r.length && r[s] < p; ) {
        let d = r[s], m = r[s + 1], y = Math.max(l, d), O = Math.min(p, m);
        if (y <= O && new _r(y + h, O + h, y, O).addToSet(i), m > p)
          break;
        s += 2;
      }
      if (!u)
        return i;
      new _r(u.fromA, u.toA, u.fromB, u.toB).addToSet(i), a = u.toA, l = u.toB;
    }
  }
}
class vc {
  constructor(e, r, i) {
    this.view = e, this.state = r, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = yt.empty(this.startState.doc.length);
    for (let s of i)
      this.changes = this.changes.compose(s.changes);
    let n = [];
    this.changes.iterChangedRanges((s, a, l, u) => n.push(new _r(s, a, l, u))), this.changedRanges = n;
  }
  /**
  @internal
  */
  static create(e, r, i) {
    return new vc(e, r, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class L1 extends et {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new gt()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new _r(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var r;
    let i = e.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: h, toA: p }) => p < this.minWidthFrom || h > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let n = -1;
    this.view.inputState.composing >= 0 && (!((r = this.domChanged) === null || r === void 0) && r.newSel ? n = this.domChanged.newSel.head : !vj(e.changes, this.hasComposition) && !e.selectionSet && (n = e.state.selection.main.head));
    let s = n > -1 ? yj(this.view, e.changes, n) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: h, to: p } = this.hasComposition;
      i = new _r(h, p, e.changes.mapPos(h, -1), e.changes.mapPos(p, 1)).addToSet(i.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (ge.ie || ge.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let a = this.decorations, l = this.updateDeco(), u = Dj(a, l, e.changes);
    return i = _r.extendWithRanges(i, u), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, r, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, r, i);
    let { observer: n } = this.view;
    n.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let a = ge.chrome || ge.ios ? { node: n.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, a), this.flags &= -8, a && (a.written || n.selectionRange.focusNode != a.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (a) => a.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let a of this.children)
        a instanceof Tn && a.widget instanceof Q1 && s.push(a.dom);
    n.updateGaps(s);
  }
  updateChildren(e, r, i) {
    let n = i ? i.range.addToSet(e.slice()) : e, s = this.childCursor(r);
    for (let a = n.length - 1; ; a--) {
      let l = a >= 0 ? n[a] : null;
      if (!l)
        break;
      let { fromA: u, toA: h, fromB: p, toB: d } = l, m, y, O, D;
      if (i && i.range.fromB < d && i.range.toB > p) {
        let k = Wo.build(this.view.state.doc, p, i.range.fromB, this.decorations, this.dynamicDecorationMap), C = Wo.build(this.view.state.doc, i.range.toB, d, this.decorations, this.dynamicDecorationMap);
        y = k.breakAtStart, O = k.openStart, D = C.openEnd;
        let A = this.compositionView(i);
        C.breakAtStart ? A.breakAfter = 1 : C.content.length && A.merge(A.length, A.length, C.content[0], !1, C.openStart, 0) && (A.breakAfter = C.content[0].breakAfter, C.content.shift()), k.content.length && A.merge(0, 0, k.content[k.content.length - 1], !0, 0, k.openEnd) && k.content.pop(), m = k.content.concat(A).concat(C.content);
      } else
        ({ content: m, breakAtStart: y, openStart: O, openEnd: D } = Wo.build(this.view.state.doc, p, d, this.decorations, this.dynamicDecorationMap));
      let { i: v, off: w } = s.findPos(h, 1), { i: x, off: S } = s.findPos(u, -1);
      iS(this, x, S, v, w, m, y, O, D);
    }
    i && this.fixCompositionDOM(i);
  }
  compositionView(e) {
    let r = new Gi(e.text.nodeValue);
    r.flags |= 8;
    for (let { deco: n } of e.marks)
      r = new Hi(n, [r], r.length);
    let i = new gt();
    return i.append(r, 0), i;
  }
  fixCompositionDOM(e) {
    let r = (s, a) => {
      a.flags |= 8 | (a.children.some(
        (u) => u.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(a);
      let l = et.get(s);
      l && l != a && (l.dom = null), a.setDOM(s);
    }, i = this.childPos(e.range.fromB, 1), n = this.children[i.i];
    r(e.line, n);
    for (let s = e.marks.length - 1; s >= -1; s--)
      i = n.childPos(i.off, 1), n = n.children[i.i], r(s >= 0 ? e.marks[s].node : e.text, n);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, r = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, n = i == this.dom, s = !n && Gu(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(n || r || s))
      return;
    let a = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, u = this.moveToLine(this.domAtPos(l.anchor)), h = l.empty ? u : this.moveToLine(this.domAtPos(l.head));
    if (ge.gecko && l.empty && !this.hasComposition && gj(u)) {
      let d = document.createTextNode("");
      this.view.observer.ignore(() => u.node.insertBefore(d, u.node.childNodes[u.offset] || null)), u = h = new Zt(d, 0), a = !0;
    }
    let p = this.view.observer.selectionRange;
    (a || !p.focusNode || (!Zo(u.node, u.offset, p.anchorNode, p.anchorOffset) || !Zo(h.node, h.offset, p.focusNode, p.focusOffset)) && !this.suppressWidgetCursorChange(p, l)) && (this.view.observer.ignore(() => {
      ge.android && ge.chrome && this.dom.contains(p.focusNode) && bj(p.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let d = bc(this.view.root);
      if (d)
        if (l.empty) {
          if (ge.gecko) {
            let m = Oj(u.node, u.offset);
            if (m && m != 3) {
              let y = PS(u.node, u.offset, m == 1 ? 1 : -1);
              y && (u = new Zt(y.node, y.offset));
            }
          }
          d.collapse(u.node, u.offset), l.bidiLevel != null && d.caretBidiLevel !== void 0 && (d.caretBidiLevel = l.bidiLevel);
        } else if (d.extend) {
          d.collapse(u.node, u.offset);
          try {
            d.extend(h.node, h.offset);
          } catch {
          }
        } else {
          let m = document.createRange();
          l.anchor > l.head && ([u, h] = [h, u]), m.setEnd(h.node, h.offset), m.setStart(u.node, u.offset), d.removeAllRanges(), d.addRange(m);
        }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(u, h)), this.impreciseAnchor = u.precise ? null : new Zt(p.anchorNode, p.anchorOffset), this.impreciseHead = h.precise ? null : new Zt(p.focusNode, p.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, r) {
    return this.hasComposition && r.empty && Zo(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == r.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, r = e.state.selection.main, i = bc(e.root), { anchorNode: n, anchorOffset: s } = e.observer.selectionRange;
    if (!i || !r.empty || !r.assoc || !i.modify)
      return;
    let a = gt.find(this, r.head);
    if (!a)
      return;
    let l = a.posAtStart;
    if (r.head == l || r.head == l + a.length)
      return;
    let u = this.coordsAt(r.head, -1), h = this.coordsAt(r.head, 1);
    if (!u || !h || u.bottom > h.top)
      return;
    let p = this.domAtPos(r.head + r.assoc);
    i.collapse(p.node, p.offset), i.modify("move", r.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let d = e.observer.selectionRange;
    e.docView.posFromDOM(d.anchorNode, d.anchorOffset) != r.from && i.collapse(n, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let r = this.dom, i;
    if (e.node != r)
      return e;
    for (let n = e.offset; !i && n < r.childNodes.length; n++) {
      let s = et.get(r.childNodes[n]);
      s instanceof gt && (i = s.domAtPos(0));
    }
    for (let n = e.offset - 1; !i && n >= 0; n--) {
      let s = et.get(r.childNodes[n]);
      s instanceof gt && (i = s.domAtPos(s.length));
    }
    return i ? new Zt(i.node, i.offset, !0) : e;
  }
  nearest(e) {
    for (let r = e; r; ) {
      let i = et.get(r);
      if (i && i.rootView == this)
        return i;
      r = r.parentNode;
    }
    return null;
  }
  posFromDOM(e, r) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, r) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: r, off: i } = this.childCursor().findPos(e, -1);
    for (; r < this.children.length - 1; ) {
      let n = this.children[r];
      if (i < n.length || n instanceof gt)
        break;
      r++, i = 0;
    }
    return this.children[r].domAtPos(i);
  }
  coordsAt(e, r) {
    let i = null, n = 0;
    for (let s = this.length, a = this.children.length - 1; a >= 0; a--) {
      let l = this.children[a], u = s - l.breakAfter, h = u - l.length;
      if (u < e)
        break;
      h <= e && (h < e || l.covers(-1)) && (u > e || l.covers(1)) && (!i || l instanceof gt && !(i instanceof gt && r >= 0)) && (i = l, n = h), s = h;
    }
    return i ? i.coordsAt(e - n, r) : null;
  }
  coordsForChar(e) {
    let { i: r, off: i } = this.childPos(e, 1), n = this.children[r];
    if (!(n instanceof gt))
      return null;
    for (; n.children.length; ) {
      let { i: l, off: u } = n.childPos(i, 1);
      for (; ; l++) {
        if (l == n.children.length)
          return null;
        if ((n = n.children[l]).length)
          break;
      }
      i = u;
    }
    if (!(n instanceof Gi))
      return null;
    let s = Ft(n.text, i);
    if (s == i)
      return null;
    let a = Ss(n.dom, i, s).getClientRects();
    for (let l = 0; l < a.length; l++) {
      let u = a[l];
      if (l == a.length - 1 || u.top < u.bottom && u.left < u.right)
        return u;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let r = [], { from: i, to: n } = e, s = this.view.contentDOM.clientWidth, a = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, u = this.view.textDirection == tt.LTR;
    for (let h = 0, p = 0; p < this.children.length; p++) {
      let d = this.children[p], m = h + d.length;
      if (m > n)
        break;
      if (h >= i) {
        let y = d.dom.getBoundingClientRect();
        if (r.push(y.height), a) {
          let O = d.dom.lastChild, D = O ? ka(O) : [];
          if (D.length) {
            let v = D[D.length - 1], w = u ? v.right - y.left : y.right - v.left;
            w > l && (l = w, this.minWidth = s, this.minWidthFrom = h, this.minWidthTo = m);
          }
        }
      }
      h = m + d.breakAfter;
    }
    return r;
  }
  textDirectionAt(e) {
    let { i: r } = this.childPos(e, 1);
    return getComputedStyle(this.children[r].dom).direction == "rtl" ? tt.RTL : tt.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof gt) {
        let a = s.measureTextSize();
        if (a)
          return a;
      }
    let e = document.createElement("div"), r, i, n;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = ka(e.firstChild)[0];
      r = e.getBoundingClientRect().height, i = s ? s.width / 27 : 7, n = s ? s.height : r, e.remove();
    }), { lineHeight: r, charWidth: i, textHeight: n };
  }
  childCursor(e = this.length) {
    let r = this.children.length;
    return r && (e -= this.children[--r].length), new rS(this.children, e, r);
  }
  computeBlockGapDeco() {
    let e = [], r = this.view.viewState;
    for (let i = 0, n = 0; ; n++) {
      let s = n == r.viewports.length ? null : r.viewports[n], a = s ? s.from - 1 : this.length;
      if (a > i) {
        let l = (r.lineBlockAt(a).bottom - r.lineBlockAt(i).top) / this.view.scaleY;
        e.push(Oe.replace({
          widget: new Q1(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, a));
      }
      if (!s)
        break;
      i = s.to + 1;
    }
    return Oe.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(sl).map((n, s) => (this.dynamicDecorationMap[s] = typeof n == "function") ? n(this.view) : n), r = !1, i = this.view.state.facet(CS).map((n, s) => {
      let a = typeof n == "function";
      return a && (r = !0), a ? n(this.view) : n;
    });
    i.length && (this.dynamicDecorationMap[e.length] = r, e.push(Me.join(i)));
    for (let n = e.length; n < e.length + 3; n++)
      this.dynamicDecorationMap[n] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let h = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = h.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    let { range: r } = e, i = this.coordsAt(r.head, r.empty ? r.assoc : r.head > r.anchor ? -1 : 1), n;
    if (!i)
      return;
    !r.empty && (n = this.coordsAt(r.anchor, r.anchor > r.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, n.left),
      top: Math.min(i.top, n.top),
      right: Math.max(i.right, n.right),
      bottom: Math.max(i.bottom, n.bottom)
    });
    let s = kS(this.view), a = {
      left: i.left - s.left,
      top: i.top - s.top,
      right: i.right + s.right,
      bottom: i.bottom + s.bottom
    }, { offsetWidth: l, offsetHeight: u } = this.view.scrollDOM;
    GQ(this.view.scrollDOM, a, r.head < r.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, l), -l), Math.max(Math.min(e.yMargin, u), -u), this.view.textDirection == tt.LTR);
  }
}
function gj(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
class Q1 extends Mi {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
function TS(t, e) {
  let r = t.observer.selectionRange, i = r.focusNode && PS(r.focusNode, r.focusOffset, 0);
  if (!i)
    return null;
  let n = e - i.offset;
  return { from: n, to: n + i.node.nodeValue.length, node: i.node };
}
function yj(t, e, r) {
  let i = TS(t, r);
  if (!i)
    return null;
  let { node: n, from: s, to: a } = i, l = n.nodeValue;
  if (/[\n\r]/.test(l) || t.state.doc.sliceString(i.from, i.to) != l)
    return null;
  let u = e.invertedDesc, h = new _r(u.mapPos(s), u.mapPos(a), s, a), p = [];
  for (let d = n.parentNode; ; d = d.parentNode) {
    let m = et.get(d);
    if (m instanceof Hi)
      p.push({ node: d, deco: m.mark });
    else {
      if (m instanceof gt || d.nodeName == "DIV" && d.parentNode == t.contentDOM)
        return { range: h, text: n, marks: p, line: d };
      if (d != t.contentDOM)
        p.push({ node: d, deco: new Il({
          inclusive: !0,
          attributes: nj(d),
          tagName: d.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function PS(t, e, r) {
  if (r <= 0)
    for (let i = t, n = e; ; ) {
      if (i.nodeType == 3)
        return { node: i, offset: n };
      if (i.nodeType == 1 && n > 0)
        i = i.childNodes[n - 1], n = zi(i);
      else
        break;
    }
  if (r >= 0)
    for (let i = t, n = e; ; ) {
      if (i.nodeType == 3)
        return { node: i, offset: n };
      if (i.nodeType == 1 && n < i.childNodes.length && r >= 0)
        i = i.childNodes[n], n = 0;
      else
        break;
    }
  return null;
}
function Oj(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let xj = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, r) {
    yf(e, r, this.changes);
  }
  comparePoint(e, r) {
    yf(e, r, this.changes);
  }
};
function Dj(t, e, r) {
  let i = new xj();
  return Me.compare(t, e, r, i), i.changes;
}
function bj(t, e) {
  for (let r = t; r && r != e; r = r.assignedSlot || r.parentNode)
    if (r.nodeType == 1 && r.contentEditable == "false")
      return !0;
  return !1;
}
function vj(t, e) {
  let r = !1;
  return e && t.iterChangedRanges((i, n) => {
    i < e.to && n > e.from && (r = !0);
  }), r;
}
function wj(t, e, r = 1) {
  let i = t.charCategorizer(e), n = t.doc.lineAt(e), s = e - n.from;
  if (n.length == 0)
    return Y.cursor(e);
  s == 0 ? r = 1 : s == n.length && (r = -1);
  let a = s, l = s;
  r < 0 ? a = Ft(n.text, s, !1) : l = Ft(n.text, s);
  let u = i(n.text.slice(a, l));
  for (; a > 0; ) {
    let h = Ft(n.text, a, !1);
    if (i(n.text.slice(h, a)) != u)
      break;
    a = h;
  }
  for (; l < n.length; ) {
    let h = Ft(n.text, l);
    if (i(n.text.slice(l, h)) != u)
      break;
    l = h;
  }
  return Y.range(a + n.from, l + n.from);
}
function Sj(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function Cj(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function Qp(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function j1(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function R1(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function vf(t, e, r) {
  let i, n, s, a, l = !1, u, h, p, d;
  for (let O = t.firstChild; O; O = O.nextSibling) {
    let D = ka(O);
    for (let v = 0; v < D.length; v++) {
      let w = D[v];
      n && Qp(n, w) && (w = j1(R1(w, n.bottom), n.top));
      let x = Sj(e, w), S = Cj(r, w);
      if (x == 0 && S == 0)
        return O.nodeType == 3 ? Z1(O, e, r) : vf(O, e, r);
      if (!i || a > S || a == S && s > x) {
        i = O, n = w, s = x, a = S;
        let k = S ? r < w.top ? -1 : 1 : x ? e < w.left ? -1 : 1 : 0;
        l = !k || (k > 0 ? v < D.length - 1 : v > 0);
      }
      x == 0 ? r > w.bottom && (!p || p.bottom < w.bottom) ? (u = O, p = w) : r < w.top && (!d || d.top > w.top) && (h = O, d = w) : p && Qp(p, w) ? p = R1(p, w.bottom) : d && Qp(d, w) && (d = j1(d, w.top));
    }
  }
  if (p && p.bottom >= r ? (i = u, n = p) : d && d.top <= r && (i = h, n = d), !i)
    return { node: t, offset: 0 };
  let m = Math.max(n.left, Math.min(n.right, e));
  if (i.nodeType == 3)
    return Z1(i, m, r);
  if (l && i.contentEditable != "false")
    return vf(i, m, r);
  let y = Array.prototype.indexOf.call(t.childNodes, i) + (e >= (n.left + n.right) / 2 ? 1 : 0);
  return { node: t, offset: y };
}
function Z1(t, e, r) {
  let i = t.nodeValue.length, n = -1, s = 1e9, a = 0;
  for (let l = 0; l < i; l++) {
    let u = Ss(t, l, l + 1).getClientRects();
    for (let h = 0; h < u.length; h++) {
      let p = u[h];
      if (p.top == p.bottom)
        continue;
      a || (a = e - p.left);
      let d = (p.top > r ? p.top - r : r - p.bottom) - 1;
      if (p.left - 1 <= e && p.right + 1 >= e && d < s) {
        let m = e >= (p.left + p.right) / 2, y = m;
        if ((ge.chrome || ge.gecko) && Ss(t, l).getBoundingClientRect().left == p.right && (y = !m), d <= 0)
          return { node: t, offset: l + (y ? 1 : 0) };
        n = l + (y ? 1 : 0), s = d;
      }
    }
  }
  return { node: t, offset: n > -1 ? n : a > 0 ? t.nodeValue.length : 0 };
}
function FS(t, e, r, i = -1) {
  var n, s;
  let a = t.contentDOM.getBoundingClientRect(), l = a.top + t.viewState.paddingTop, u, { docHeight: h } = t.viewState, { x: p, y: d } = e, m = d - l;
  if (m < 0)
    return 0;
  if (m > h)
    return t.state.doc.length;
  for (let k = t.viewState.heightOracle.textHeight / 2, C = !1; u = t.elementAtHeight(m), u.type != Gt.Text; )
    for (; m = i > 0 ? u.bottom + k : u.top - k, !(m >= 0 && m <= h); ) {
      if (C)
        return r ? null : 0;
      C = !0, i = -i;
    }
  d = l + m;
  let y = u.from;
  if (y < t.viewport.from)
    return t.viewport.from == 0 ? 0 : r ? null : W1(t, a, u, p, d);
  if (y > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : r ? null : W1(t, a, u, p, d);
  let O = t.dom.ownerDocument, D = t.root.elementFromPoint ? t.root : O, v = D.elementFromPoint(p, d);
  v && !t.contentDOM.contains(v) && (v = null), v || (p = Math.max(a.left + 1, Math.min(a.right - 1, p)), v = D.elementFromPoint(p, d), v && !t.contentDOM.contains(v) && (v = null));
  let w, x = -1;
  if (v && ((n = t.docView.nearest(v)) === null || n === void 0 ? void 0 : n.isEditable) != !1) {
    if (O.caretPositionFromPoint) {
      let k = O.caretPositionFromPoint(p, d);
      k && ({ offsetNode: w, offset: x } = k);
    } else if (O.caretRangeFromPoint) {
      let k = O.caretRangeFromPoint(p, d);
      k && ({ startContainer: w, startOffset: x } = k, (!t.contentDOM.contains(w) || ge.safari && Ej(w, x, p) || ge.chrome && Aj(w, x, p)) && (w = void 0));
    }
  }
  if (!w || !t.docView.dom.contains(w)) {
    let k = gt.find(t.docView, y);
    if (!k)
      return m > u.top + u.height / 2 ? u.to : u.from;
    ({ node: w, offset: x } = vf(k.dom, p, d));
  }
  let S = t.docView.nearest(w);
  if (!S)
    return null;
  if (S.isWidget && ((s = S.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let k = S.dom.getBoundingClientRect();
    return e.y < k.top || e.y <= k.bottom && e.x <= (k.left + k.right) / 2 ? S.posAtStart : S.posAtEnd;
  } else
    return S.localPosFromDOM(w, x) + S.posAtStart;
}
function W1(t, e, r, i, n) {
  let s = Math.round((i - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && r.height > t.defaultLineHeight * 1.5) {
    let l = t.viewState.heightOracle.textHeight, u = Math.floor((n - r.top - (t.defaultLineHeight - l) * 0.5) / l);
    s += u * t.viewState.heightOracle.lineLength;
  }
  let a = t.state.sliceDoc(r.from, r.to);
  return r.from + lf(a, s, t.state.tabSize);
}
function Ej(t, e, r) {
  let i;
  if (t.nodeType != 3 || e != (i = t.nodeValue.length))
    return !1;
  for (let n = t.nextSibling; n; n = n.nextSibling)
    if (n.nodeType != 1 || n.nodeName != "BR")
      return !1;
  return Ss(t, i - 1, i).getBoundingClientRect().left > r;
}
function Aj(t, e, r) {
  if (e != 0)
    return !1;
  for (let n = t; ; ) {
    let s = n.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != n)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    n = s;
  }
  let i = t.nodeType == 1 ? t.getBoundingClientRect() : Ss(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return r - i.left > 5;
}
function wf(t, e) {
  let r = t.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    for (let i of r.type)
      if (i.to > e || i.to == e && (i.to == r.to || i.type == Gt.Text))
        return i;
  }
  return r;
}
function kj(t, e, r, i) {
  let n = wf(t, e.head), s = !i || n.type != Gt.Text || !(t.lineWrapping || n.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > n.from ? e.head - 1 : e.head);
  if (s) {
    let a = t.dom.getBoundingClientRect(), l = t.textDirectionAt(n.from), u = t.posAtCoords({
      x: r == (l == tt.LTR) ? a.right - 1 : a.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (u != null)
      return Y.cursor(u, r ? -1 : 1);
  }
  return Y.cursor(r ? n.to : n.from, r ? -1 : 1);
}
function q1(t, e, r, i) {
  let n = t.state.doc.lineAt(e.head), s = t.bidiSpans(n), a = t.textDirectionAt(n.from);
  for (let l = e, u = null; ; ) {
    let h = dj(n, s, a, l, r), p = mS;
    if (!h) {
      if (n.number == (r ? t.state.doc.lines : 1))
        return l;
      p = `
`, n = t.state.doc.line(n.number + (r ? 1 : -1)), s = t.bidiSpans(n), h = t.visualLineSide(n, !r);
    }
    if (u) {
      if (!u(p))
        return l;
    } else {
      if (!i)
        return h;
      u = i(p);
    }
    l = h;
  }
}
function Tj(t, e, r) {
  let i = t.state.charCategorizer(e), n = i(r);
  return (s) => {
    let a = i(s);
    return n == it.Space && (n = a), n == a;
  };
}
function Pj(t, e, r, i) {
  let n = e.head, s = r ? 1 : -1;
  if (n == (r ? t.state.doc.length : 0))
    return Y.cursor(n, e.assoc);
  let a = e.goalColumn, l, u = t.contentDOM.getBoundingClientRect(), h = t.coordsAtPos(n, e.assoc || -1), p = t.documentTop;
  if (h)
    a == null && (a = h.left - u.left), l = s < 0 ? h.top : h.bottom;
  else {
    let y = t.viewState.lineBlockAt(n);
    a == null && (a = Math.min(u.right - u.left, t.defaultCharacterWidth * (n - y.from))), l = (s < 0 ? y.top : y.bottom) + p;
  }
  let d = u.left + a, m = i ?? t.viewState.heightOracle.textHeight >> 1;
  for (let y = 0; ; y += 10) {
    let O = l + (m + y) * s, D = FS(t, { x: d, y: O }, !1, s);
    if (O < u.top || O > u.bottom || (s < 0 ? D < n : D > n)) {
      let v = t.docView.coordsForChar(D), w = !v || O < v.top ? -1 : 1;
      return Y.cursor(D, w, void 0, a);
    }
  }
}
function Hu(t, e, r) {
  for (; ; ) {
    let i = 0;
    for (let n of t)
      n.between(e - 1, e + 1, (s, a, l) => {
        if (e > s && e < a) {
          let u = i || r || (e - s < a - e ? -1 : 1);
          e = u < 0 ? s : a, i = u;
        }
      });
    if (!i)
      return e;
  }
}
function jp(t, e, r) {
  let i = Hu(t.state.facet(Lg).map((n) => n(t)), r.from, e.head > r.from ? -1 : 1);
  return i == r.from ? r : Y.cursor(i, i < r.from ? 1 : -1);
}
class Fj {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, ge.safari && e.contentDOM.addEventListener("input", () => null), ge.gecko && Uj(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !Qj(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, r) {
    let i = this.handlers[e];
    if (i) {
      for (let n of i.observers)
        n(this.view, r);
      for (let n of i.handlers) {
        if (r.defaultPrevented)
          break;
        if (n(this.view, r)) {
          r.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let r = $j(e), i = this.handlers, n = this.view.contentDOM;
    for (let s in r)
      if (s != "scroll") {
        let a = !r[s].handlers.length, l = i[s];
        l && a != !l.handlers.length && (n.removeEventListener(s, this.handleEvent), l = null), l || n.addEventListener(s, this.handleEvent, { passive: a });
      }
    for (let s in i)
      s != "scroll" && !r[s] && n.removeEventListener(s, this.handleEvent);
    this.handlers = r;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (e.keyCode != 27 && BS.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), ge.android && ge.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let r;
    return ge.ios && !e.synthetic && !e.altKey && !e.metaKey && ((r = $S.find((i) => i.keyCode == e.keyCode)) && !e.ctrlKey || Bj.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = r || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let e = this.pendingIOSKey;
    return e ? (this.pendingIOSKey = void 0, ma(this.view.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : ge.safari && !ge.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function X1(t, e) {
  return (r, i) => {
    try {
      return e.call(t, i, r);
    } catch (n) {
      Nr(r.state, n);
    }
  };
}
function $j(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function r(i) {
    return e[i] || (e[i] = { observers: [], handlers: [] });
  }
  for (let i of t) {
    let n = i.spec;
    if (n && n.domEventHandlers)
      for (let s in n.domEventHandlers) {
        let a = n.domEventHandlers[s];
        a && r(s).handlers.push(X1(i.value, a));
      }
    if (n && n.domEventObservers)
      for (let s in n.domEventObservers) {
        let a = n.domEventObservers[s];
        a && r(s).observers.push(X1(i.value, a));
      }
  }
  for (let i in si)
    r(i).handlers.push(si[i]);
  for (let i in ai)
    r(i).observers.push(ai[i]);
  return e;
}
const $S = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], Bj = "dthko", BS = [16, 17, 18, 20, 91, 92, 224, 225], Du = 6;
function bu(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function Ij(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class Nj {
  constructor(e, r, i, n) {
    this.view = e, this.startEvent = r, this.style = i, this.mustSelect = n, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = r, this.scrollParent = HQ(e.contentDOM), this.atoms = e.state.facet(Lg).map((a) => a(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = r.shiftKey, this.multiple = e.state.facet(Be.allowMultipleSelections) && _j(e, r), this.dragging = Lj(e, r) && MS(r) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var r;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && Ij(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let i = 0, n = 0, s = ((r = this.scrollParent) === null || r === void 0 ? void 0 : r.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, a = kS(this.view);
    e.clientX - a.left <= s.left + Du ? i = -bu(s.left - e.clientX) : e.clientX + a.right >= s.right - Du && (i = bu(e.clientX - s.right)), e.clientY - a.top <= s.top + Du ? n = -bu(s.top - e.clientY) : e.clientY + a.bottom >= s.bottom - Du && (n = bu(e.clientY - s.bottom)), this.setScrollSpeed(i, n);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, r) {
    this.scrollSpeed = { x: e, y: r }, e || r ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let r = null;
    for (let i = 0; i < e.ranges.length; i++) {
      let n = e.ranges[i], s = null;
      if (n.empty) {
        let a = Hu(this.atoms, n.from, 0);
        a != n.from && (s = Y.cursor(a, -1));
      } else {
        let a = Hu(this.atoms, n.from, -1), l = Hu(this.atoms, n.to, 1);
        (a != n.from || l != n.to) && (s = Y.range(n.from == n.anchor ? a : l, n.from == n.head ? a : l));
      }
      s && (r || (r = e.ranges.slice()), r[i] = s);
    }
    return r ? Y.create(r, e.mainIndex) : e;
  }
  select(e) {
    let { view: r } = this, i = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !i.eq(r.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function _j(t, e) {
  let r = t.state.facet(gS);
  return r.length ? r[0](e) : ge.mac ? e.metaKey : e.ctrlKey;
}
function Mj(t, e) {
  let r = t.state.facet(yS);
  return r.length ? r[0](e) : ge.mac ? !e.altKey : !e.ctrlKey;
}
function Lj(t, e) {
  let { main: r } = t.state.selection;
  if (r.empty)
    return !1;
  let i = bc(t.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let n = i.getRangeAt(0).getClientRects();
  for (let s = 0; s < n.length; s++) {
    let a = n[s];
    if (a.left <= e.clientX && a.right >= e.clientX && a.top <= e.clientY && a.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function Qj(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let r = e.target, i; r != t.contentDOM; r = r.parentNode)
    if (!r || r.nodeType == 11 || (i = et.get(r)) && i.ignoreEvent(e))
      return !1;
  return !0;
}
const si = /* @__PURE__ */ Object.create(null), ai = /* @__PURE__ */ Object.create(null), IS = ge.ie && ge.ie_version < 15 || ge.ios && ge.webkit_version < 604;
function jj(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let r = e.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(), setTimeout(() => {
    t.focus(), r.remove(), NS(t, r.value);
  }, 50);
}
function NS(t, e) {
  let { state: r } = t, i, n = 1, s = r.toText(e), a = s.lines == r.selection.ranges.length;
  if (Sf != null && r.selection.ranges.every((u) => u.empty) && Sf == s.toString()) {
    let u = -1;
    i = r.changeByRange((h) => {
      let p = r.doc.lineAt(h.from);
      if (p.from == u)
        return { range: h };
      u = p.from;
      let d = r.toText((a ? s.line(n++).text : e) + r.lineBreak);
      return {
        changes: { from: p.from, insert: d },
        range: Y.cursor(h.from + d.length)
      };
    });
  } else
    a ? i = r.changeByRange((u) => {
      let h = s.line(n++);
      return {
        changes: { from: u.from, to: u.to, insert: h.text },
        range: Y.cursor(u.from + h.length)
      };
    }) : i = r.replaceSelection(s);
  t.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
ai.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
si.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (t.inputState.lastEscPress = Date.now()), !1);
ai.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
ai.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
si.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let r = null;
  for (let i of t.state.facet(OS))
    if (r = i(t, e), r)
      break;
  if (!r && e.button == 0 && (r = Wj(t, e)), r) {
    let i = !t.hasFocus;
    t.inputState.startMouseSelection(new Nj(t, e, r, i)), i && t.observer.ignore(() => Kw(t.contentDOM));
    let n = t.inputState.mouseSelection;
    if (n)
      return n.start(e), n.dragging === !1;
  }
  return !1;
};
function V1(t, e, r, i) {
  if (i == 1)
    return Y.cursor(e, r);
  if (i == 2)
    return wj(t.state, e, r);
  {
    let n = gt.find(t.docView, e), s = t.state.doc.lineAt(n ? n.posAtEnd : e), a = n ? n.posAtStart : s.from, l = n ? n.posAtEnd : s.to;
    return l < t.state.doc.length && l == s.to && l++, Y.range(a, l);
  }
}
let _S = (t, e) => t >= e.top && t <= e.bottom, U1 = (t, e, r) => _S(e, r) && t >= r.left && t <= r.right;
function Rj(t, e, r, i) {
  let n = gt.find(t.docView, e);
  if (!n)
    return 1;
  let s = e - n.posAtStart;
  if (s == 0)
    return 1;
  if (s == n.length)
    return -1;
  let a = n.coordsAt(s, -1);
  if (a && U1(r, i, a))
    return -1;
  let l = n.coordsAt(s, 1);
  return l && U1(r, i, l) ? 1 : a && _S(i, a) ? -1 : 1;
}
function Y1(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: r, bias: Rj(t, r, e.clientX, e.clientY) };
}
const Zj = ge.ie && ge.ie_version <= 11;
let z1 = null, G1 = 0, H1 = 0;
function MS(t) {
  if (!Zj)
    return t.detail;
  let e = z1, r = H1;
  return z1 = t, H1 = Date.now(), G1 = !e || r > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (G1 + 1) % 3 : 1;
}
function Wj(t, e) {
  let r = Y1(t, e), i = MS(e), n = t.state.selection;
  return {
    update(s) {
      s.docChanged && (r.pos = s.changes.mapPos(r.pos), n = n.map(s.changes));
    },
    get(s, a, l) {
      let u = Y1(t, s), h, p = V1(t, u.pos, u.bias, i);
      if (r.pos != u.pos && !a) {
        let d = V1(t, r.pos, r.bias, i), m = Math.min(d.from, p.from), y = Math.max(d.to, p.to);
        p = m < p.from ? Y.range(m, y) : Y.range(y, m);
      }
      return a ? n.replaceRange(n.main.extend(p.from, p.to)) : l && i == 1 && n.ranges.length > 1 && (h = qj(n, u.pos)) ? h : l ? n.addRange(p) : Y.create([p]);
    }
  };
}
function qj(t, e) {
  for (let r = 0; r < t.ranges.length; r++) {
    let { from: i, to: n } = t.ranges[r];
    if (i <= e && n >= e)
      return Y.create(t.ranges.slice(0, r).concat(t.ranges.slice(r + 1)), t.mainIndex == r ? 0 : t.mainIndex - (t.mainIndex > r ? 1 : 0));
  }
  return null;
}
si.dragstart = (t, e) => {
  let { selection: { main: r } } = t.state;
  if (e.target.draggable) {
    let n = t.docView.nearest(e.target);
    if (n && n.isWidget) {
      let s = n.posAtStart, a = s + n.length;
      (s >= r.to || a <= r.from) && (r = Y.range(s, a));
    }
  }
  let { inputState: i } = t;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = r, e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(r.from, r.to)), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
si.dragend = (t) => (t.inputState.draggedContent = null, !1);
function J1(t, e, r, i) {
  if (!r)
    return;
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = t.inputState, a = i && s && Mj(t, e) ? { from: s.from, to: s.to } : null, l = { from: n, insert: r }, u = t.state.changes(a ? [a, l] : l);
  t.focus(), t.dispatch({
    changes: u,
    selection: { anchor: u.mapPos(n, -1), head: u.mapPos(n, 1) },
    userEvent: a ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
si.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let r = e.dataTransfer.files;
  if (r && r.length) {
    let i = Array(r.length), n = 0, s = () => {
      ++n == r.length && J1(t, e, i.filter((a) => a != null).join(t.state.lineBreak), !1);
    };
    for (let a = 0; a < r.length; a++) {
      let l = new FileReader();
      l.onerror = s, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (i[a] = l.result), s();
      }, l.readAsText(r[a]);
    }
    return !0;
  } else {
    let i = e.dataTransfer.getData("Text");
    if (i)
      return J1(t, e, i, !0), !0;
  }
  return !1;
};
si.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let r = IS ? null : e.clipboardData;
  return r ? (NS(t, r.getData("text/plain") || r.getData("text/uri-text")), !0) : (jj(t), !1);
};
function Xj(t, e) {
  let r = t.dom.parentNode;
  if (!r)
    return;
  let i = r.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), t.focus();
  }, 50);
}
function Vj(t) {
  let e = [], r = [], i = !1;
  for (let n of t.selection.ranges)
    n.empty || (e.push(t.sliceDoc(n.from, n.to)), r.push(n));
  if (!e.length) {
    let n = -1;
    for (let { from: s } of t.selection.ranges) {
      let a = t.doc.lineAt(s);
      a.number > n && (e.push(a.text), r.push({ from: a.from, to: Math.min(t.doc.length, a.to + 1) })), n = a.number;
    }
    i = !0;
  }
  return { text: e.join(t.lineBreak), ranges: r, linewise: i };
}
let Sf = null;
si.copy = si.cut = (t, e) => {
  let { text: r, ranges: i, linewise: n } = Vj(t.state);
  if (!r && !n)
    return !1;
  Sf = n ? r : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = IS ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", r), !0) : (Xj(t, r), !1);
};
const LS = /* @__PURE__ */ Ni.define();
function QS(t, e) {
  let r = [];
  for (let i of t.facet(bS)) {
    let n = i(t, e);
    n && r.push(n);
  }
  return r ? t.update({ effects: r, annotations: LS.of(!0) }) : null;
}
function jS(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let r = QS(t.state, e);
      r ? t.dispatch(r) : t.update([]);
    }
  }, 10);
}
ai.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), jS(t);
};
ai.blur = (t) => {
  t.observer.clearSelectionRange(), jS(t);
};
ai.compositionstart = ai.compositionupdate = (t) => {
  t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0);
};
ai.compositionend = (t) => {
  t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, ge.chrome && ge.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50);
};
ai.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
si.beforeinput = (t, e) => {
  var r;
  let i;
  if (ge.chrome && ge.android && (i = $S.find((n) => n.inputType == e.inputType)) && (t.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let n = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > n + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return !1;
};
const K1 = /* @__PURE__ */ new Set();
function Uj(t) {
  K1.has(t) || (K1.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const eO = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class Yj {
  constructor(e) {
    this.lineWrapping = e, this.doc = je.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, r) {
    let i = this.doc.lineAt(r).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((r - e - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return eO.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let r = !1;
    for (let i = 0; i < e.length; i++) {
      let n = e[i];
      n < 0 ? i++ : this.heightSamples[Math.floor(n * 10)] || (r = !0, this.heightSamples[Math.floor(n * 10)] = !0);
    }
    return r;
  }
  refresh(e, r, i, n, s, a) {
    let l = eO.indexOf(e) > -1, u = Math.round(r) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (this.lineWrapping = l, this.lineHeight = r, this.charWidth = i, this.textHeight = n, this.lineLength = s, u) {
      this.heightSamples = {};
      for (let h = 0; h < a.length; h++) {
        let p = a[h];
        p < 0 ? h++ : this.heightSamples[Math.floor(p * 10)] = !0;
      }
    }
    return u;
  }
}
class zj {
  constructor(e, r) {
    this.from = e, this.heights = r, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Di {
  /**
  @internal
  */
  constructor(e, r, i, n, s) {
    this.from = e, this.length = r, this.top = i, this.height = n, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Gt.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof jn ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let r = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new Di(this.from, this.length + e.length, this.top, this.height + e.height, r);
  }
}
var Ke = /* @__PURE__ */ function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
}(Ke || (Ke = {}));
const Ju = 1e-3;
class Ht {
  constructor(e, r, i = 2) {
    this.length = e, this.height = r, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, r) {
    this.height != r && (Math.abs(this.height - r) > Ju && (e.heightChanged = !0), this.height = r);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, r, i) {
    return Ht.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, r) {
    r.push(this);
  }
  decomposeRight(e, r) {
    r.push(this);
  }
  applyChanges(e, r, i, n) {
    let s = this, a = i.doc;
    for (let l = n.length - 1; l >= 0; l--) {
      let { fromA: u, toA: h, fromB: p, toB: d } = n[l], m = s.lineAt(u, Ke.ByPosNoHeight, i.setDoc(r), 0, 0), y = m.to >= h ? m : s.lineAt(h, Ke.ByPosNoHeight, i, 0, 0);
      for (d += y.to - h, h = y.to; l > 0 && m.from <= n[l - 1].toA; )
        u = n[l - 1].fromA, p = n[l - 1].fromB, l--, u < m.from && (m = s.lineAt(u, Ke.ByPosNoHeight, i, 0, 0));
      p += m.from - u, u = m.from;
      let O = Qg.build(i.setDoc(a), e, p, d);
      s = s.replace(u, h, O);
    }
    return s.updateHeight(i, 0);
  }
  static empty() {
    return new fr(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let r = 0, i = e.length, n = 0, s = 0;
    for (; ; )
      if (r == i)
        if (n > s * 2) {
          let l = e[r - 1];
          l.break ? e.splice(--r, 1, l.left, null, l.right) : e.splice(--r, 1, l.left, l.right), i += 1 + l.break, n -= l.size;
        } else if (s > n * 2) {
          let l = e[i];
          l.break ? e.splice(i, 1, l.left, null, l.right) : e.splice(i, 1, l.left, l.right), i += 2 + l.break, s -= l.size;
        } else
          break;
      else if (n < s) {
        let l = e[r++];
        l && (n += l.size);
      } else {
        let l = e[--i];
        l && (s += l.size);
      }
    let a = 0;
    return e[r - 1] == null ? (a = 1, r--) : e[r] == null && (a = 1, i++), new Gj(Ht.of(e.slice(0, r)), a, Ht.of(e.slice(i)));
  }
}
Ht.prototype.size = 1;
class RS extends Ht {
  constructor(e, r, i) {
    super(e, r), this.deco = i;
  }
  blockAt(e, r, i, n) {
    return new Di(n, this.length, i, this.height, this.deco || 0);
  }
  lineAt(e, r, i, n, s) {
    return this.blockAt(0, i, n, s);
  }
  forEachLine(e, r, i, n, s, a) {
    e <= s + this.length && r >= s && a(this.blockAt(0, i, n, s));
  }
  updateHeight(e, r = 0, i = !1, n) {
    return n && n.from <= r && n.more && this.setHeight(e, n.heights[n.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class fr extends RS {
  constructor(e, r) {
    super(e, r, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, r, i, n) {
    return new Di(n, this.length, i, this.height, this.breaks);
  }
  replace(e, r, i) {
    let n = i[0];
    return i.length == 1 && (n instanceof fr || n instanceof Ct && n.flags & 4) && Math.abs(this.length - n.length) < 10 ? (n instanceof Ct ? n = new fr(n.length, this.height) : n.height = this.height, this.outdated || (n.outdated = !1), n) : Ht.of(i);
  }
  updateHeight(e, r = 0, i = !1, n) {
    return n && n.from <= r && n.more ? this.setHeight(e, n.heights[n.index++]) : (i || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Ct extends Ht {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, r) {
    let i = e.doc.lineAt(r).number, n = e.doc.lineAt(r + this.length).number, s = n - i + 1, a, l = 0;
    if (e.lineWrapping) {
      let u = Math.min(this.height, e.lineHeight * s);
      a = u / s, this.length > s + 1 && (l = (this.height - u) / (this.length - s - 1));
    } else
      a = this.height / s;
    return { firstLine: i, lastLine: n, perLine: a, perChar: l };
  }
  blockAt(e, r, i, n) {
    let { firstLine: s, lastLine: a, perLine: l, perChar: u } = this.heightMetrics(r, n);
    if (r.lineWrapping) {
      let h = n + Math.round(Math.max(0, Math.min(1, (e - i) / this.height)) * this.length), p = r.doc.lineAt(h), d = l + p.length * u, m = Math.max(i, e - d / 2);
      return new Di(p.from, p.length, m, d, 0);
    } else {
      let h = Math.max(0, Math.min(a - s, Math.floor((e - i) / l))), { from: p, length: d } = r.doc.line(s + h);
      return new Di(p, d, i + l * h, l, 0);
    }
  }
  lineAt(e, r, i, n, s) {
    if (r == Ke.ByHeight)
      return this.blockAt(e, i, n, s);
    if (r == Ke.ByPosNoHeight) {
      let { from: y, to: O } = i.doc.lineAt(e);
      return new Di(y, O - y, 0, 0, 0);
    }
    let { firstLine: a, perLine: l, perChar: u } = this.heightMetrics(i, s), h = i.doc.lineAt(e), p = l + h.length * u, d = h.number - a, m = n + l * d + u * (h.from - s - d);
    return new Di(h.from, h.length, Math.max(n, Math.min(m, n + this.height - p)), p, 0);
  }
  forEachLine(e, r, i, n, s, a) {
    e = Math.max(e, s), r = Math.min(r, s + this.length);
    let { firstLine: l, perLine: u, perChar: h } = this.heightMetrics(i, s);
    for (let p = e, d = n; p <= r; ) {
      let m = i.doc.lineAt(p);
      if (p == e) {
        let O = m.number - l;
        d += u * O + h * (e - s - O);
      }
      let y = u + h * m.length;
      a(new Di(m.from, m.length, d, y, 0)), d += y, p = m.to + 1;
    }
  }
  replace(e, r, i) {
    let n = this.length - r;
    if (n > 0) {
      let s = i[i.length - 1];
      s instanceof Ct ? i[i.length - 1] = new Ct(s.length + n) : i.push(null, new Ct(n - 1));
    }
    if (e > 0) {
      let s = i[0];
      s instanceof Ct ? i[0] = new Ct(e + s.length) : i.unshift(new Ct(e - 1), null);
    }
    return Ht.of(i);
  }
  decomposeLeft(e, r) {
    r.push(new Ct(e - 1), null);
  }
  decomposeRight(e, r) {
    r.push(null, new Ct(this.length - e - 1));
  }
  updateHeight(e, r = 0, i = !1, n) {
    let s = r + this.length;
    if (n && n.from <= r + this.length && n.more) {
      let a = [], l = Math.max(r, n.from), u = -1;
      for (n.from > r && a.push(new Ct(n.from - r - 1).updateHeight(e, r)); l <= s && n.more; ) {
        let p = e.doc.lineAt(l).length;
        a.length && a.push(null);
        let d = n.heights[n.index++];
        u == -1 ? u = d : Math.abs(d - u) >= Ju && (u = -2);
        let m = new fr(p, d);
        m.outdated = !1, a.push(m), l += p + 1;
      }
      l <= s && a.push(null, new Ct(s - l).updateHeight(e, l));
      let h = Ht.of(a);
      return (u < 0 || Math.abs(h.height - this.height) >= Ju || Math.abs(u - this.heightMetrics(e, r).perLine) >= Ju) && (e.heightChanged = !0), h;
    } else
      (i || this.outdated) && (this.setHeight(e, e.heightForGap(r, r + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class Gj extends Ht {
  constructor(e, r, i) {
    super(e.length + r + i.length, e.height + i.height, r | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, r, i, n) {
    let s = i + this.left.height;
    return e < s ? this.left.blockAt(e, r, i, n) : this.right.blockAt(e, r, s, n + this.left.length + this.break);
  }
  lineAt(e, r, i, n, s) {
    let a = n + this.left.height, l = s + this.left.length + this.break, u = r == Ke.ByHeight ? e < a : e < l, h = u ? this.left.lineAt(e, r, i, n, s) : this.right.lineAt(e, r, i, a, l);
    if (this.break || (u ? h.to < l : h.from > l))
      return h;
    let p = r == Ke.ByPosNoHeight ? Ke.ByPosNoHeight : Ke.ByPos;
    return u ? h.join(this.right.lineAt(l, p, i, a, l)) : this.left.lineAt(l, p, i, n, s).join(h);
  }
  forEachLine(e, r, i, n, s, a) {
    let l = n + this.left.height, u = s + this.left.length + this.break;
    if (this.break)
      e < u && this.left.forEachLine(e, r, i, n, s, a), r >= u && this.right.forEachLine(e, r, i, l, u, a);
    else {
      let h = this.lineAt(u, Ke.ByPos, i, n, s);
      e < h.from && this.left.forEachLine(e, h.from - 1, i, n, s, a), h.to >= e && h.from <= r && a(h), r > h.to && this.right.forEachLine(h.to + 1, r, i, l, u, a);
    }
  }
  replace(e, r, i) {
    let n = this.left.length + this.break;
    if (r < n)
      return this.balanced(this.left.replace(e, r, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - n, r - n, i));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let a = s.length;
    for (let l of i)
      s.push(l);
    if (e > 0 && tO(s, a - 1), r < this.length) {
      let l = s.length;
      this.decomposeRight(r, s), tO(s, l);
    }
    return Ht.of(s);
  }
  decomposeLeft(e, r) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, r);
    r.push(this.left), this.break && (i++, e >= i && r.push(null)), e > i && this.right.decomposeLeft(e - i, r);
  }
  decomposeRight(e, r) {
    let i = this.left.length, n = i + this.break;
    if (e >= n)
      return this.right.decomposeRight(e - n, r);
    e < i && this.left.decomposeRight(e, r), this.break && e < n && r.push(null), r.push(this.right);
  }
  balanced(e, r) {
    return e.size > 2 * r.size || r.size > 2 * e.size ? Ht.of(this.break ? [e, null, r] : [e, r]) : (this.left = e, this.right = r, this.height = e.height + r.height, this.outdated = e.outdated || r.outdated, this.size = e.size + r.size, this.length = e.length + this.break + r.length, this);
  }
  updateHeight(e, r = 0, i = !1, n) {
    let { left: s, right: a } = this, l = r + s.length + this.break, u = null;
    return n && n.from <= r + s.length && n.more ? u = s = s.updateHeight(e, r, i, n) : s.updateHeight(e, r, i), n && n.from <= l + a.length && n.more ? u = a = a.updateHeight(e, l, i, n) : a.updateHeight(e, l, i), u ? this.balanced(s, a) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function tO(t, e) {
  let r, i;
  t[e] == null && (r = t[e - 1]) instanceof Ct && (i = t[e + 1]) instanceof Ct && t.splice(e - 1, 3, new Ct(r.length + 1 + i.length));
}
const Hj = 5;
class Qg {
  constructor(e, r) {
    this.pos = e, this.oracle = r, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, r) {
    if (this.lineStart > -1) {
      let i = Math.min(r, this.lineEnd), n = this.nodes[this.nodes.length - 1];
      n instanceof fr ? n.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new fr(i - this.pos, -1)), this.writtenTo = i, r > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = r;
  }
  point(e, r, i) {
    if (e < r || i.heightRelevant) {
      let n = i.widget ? i.widget.estimatedHeight : 0, s = i.widget ? i.widget.lineBreaks : 0;
      n < 0 && (n = this.oracle.lineHeight);
      let a = r - e;
      i.block ? this.addBlock(new RS(a, n, i)) : (a || s || n >= Hj) && this.addLineDeco(n, s, a);
    } else
      r > e && this.span(e, r);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: r } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = r, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new fr(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, r) {
    let i = new Ct(r - e);
    return this.oracle.doc.lineAt(e).to == r && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof fr)
      return e;
    let r = new fr(0, -1);
    return this.nodes.push(r), r;
  }
  addBlock(e) {
    this.enterLine();
    let r = e.deco;
    r && r.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, r && r.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, r, i) {
    let n = this.ensureLine();
    n.length += i, n.collapsed += i, n.widgetHeight = Math.max(n.widgetHeight, e), n.breaks += r, this.writtenTo = this.pos = this.pos + i;
  }
  finish(e) {
    let r = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(r instanceof fr) && !this.isCovered ? this.nodes.push(new fr(0, -1)) : (this.writtenTo < this.pos || r == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let n of this.nodes)
      n instanceof fr && n.updateHeight(this.oracle, i), i += n ? n.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, r, i, n) {
    let s = new Qg(i, e);
    return Me.spans(r, i, n, s, 0), s.finish(i);
  }
}
function Jj(t, e, r) {
  let i = new Kj();
  return Me.compare(t, e, r, i, 0), i.changes;
}
class Kj {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, r, i, n) {
    (e < r || i && i.heightRelevant || n && n.heightRelevant) && yf(e, r, this.changes, 5);
  }
}
function eR(t, e) {
  let r = t.getBoundingClientRect(), i = t.ownerDocument, n = i.defaultView || window, s = Math.max(0, r.left), a = Math.min(n.innerWidth, r.right), l = Math.max(0, r.top), u = Math.min(n.innerHeight, r.bottom);
  for (let h = t.parentNode; h && h != i.body; )
    if (h.nodeType == 1) {
      let p = h, d = window.getComputedStyle(p);
      if ((p.scrollHeight > p.clientHeight || p.scrollWidth > p.clientWidth) && d.overflow != "visible") {
        let m = p.getBoundingClientRect();
        s = Math.max(s, m.left), a = Math.min(a, m.right), l = Math.max(l, m.top), u = h == t.parentNode ? m.bottom : Math.min(u, m.bottom);
      }
      h = d.position == "absolute" || d.position == "fixed" ? p.offsetParent : p.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
  return {
    left: s - r.left,
    right: Math.max(s, a) - r.left,
    top: l - (r.top + e),
    bottom: Math.max(l, u) - (r.top + e)
  };
}
function tR(t, e) {
  let r = t.getBoundingClientRect();
  return {
    left: 0,
    right: r.right - r.left,
    top: e,
    bottom: r.bottom - (r.top + e)
  };
}
class Rp {
  constructor(e, r, i) {
    this.from = e, this.to = r, this.size = i;
  }
  static same(e, r) {
    if (e.length != r.length)
      return !1;
    for (let i = 0; i < e.length; i++) {
      let n = e[i], s = r[i];
      if (n.from != s.from || n.to != s.to || n.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, r) {
    return Oe.replace({
      widget: new rR(this.size * (r ? e.scaleY : e.scaleX), r)
    }).range(this.from, this.to);
  }
}
class rR extends Mi {
  constructor(e, r) {
    super(), this.size = e, this.vertical = r;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class rO {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = iO, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = tt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let r = e.facet(Mg).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new Yj(r), this.stateDeco = e.facet(sl).filter((i) => typeof i != "function"), this.heightMap = Ht.empty().applyChanges(this.stateDeco, je.empty, this.heightOracle.setDoc(e.doc), [new _r(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Oe.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: r } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let n = i ? r.head : r.anchor;
      if (!e.some(({ from: s, to: a }) => n >= s && n <= a)) {
        let { from: s, to: a } = this.lineBlockAt(n);
        e.push(new vu(s, a));
      }
    }
    this.viewports = e.sort((i, n) => i.from - n.from), this.scaler = this.heightMap.height <= 7e6 ? iO : new sR(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : Co(e, this.scaler));
    });
  }
  update(e, r = null) {
    this.state = e.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(sl).filter((p) => typeof p != "function");
    let n = e.changedRanges, s = _r.extendWithRanges(n, Jj(i, this.stateDeco, e ? e.changes : yt.empty(this.state.doc.length))), a = this.heightMap.height, l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != a && (e.flags |= 2), l ? (this.scrollAnchorPos = e.changes.mapPos(l.from, -1), this.scrollAnchorHeight = l.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let u = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (r && (r.range.head < u.from || r.range.head > u.to) || !this.viewportIsAppropriate(u)) && (u = this.getViewport(0, r));
    let h = !e.changes.empty || e.flags & 2 || u.from != this.viewport.from || u.to != this.viewport.to;
    this.viewport = u, this.updateForViewport(), h && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), r && (this.scrollTarget = r), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(wS) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let r = e.contentDOM, i = window.getComputedStyle(r), n = this.heightOracle, s = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? tt.RTL : tt.LTR;
    let a = this.heightOracle.mustRefreshForWrapping(s), l = r.getBoundingClientRect(), u = a || this.mustMeasureContent || this.contentDOMHeight != l.height;
    this.contentDOMHeight = l.height, this.mustMeasureContent = !1;
    let h = 0, p = 0;
    if (l.width && l.height) {
      let { scaleX: k, scaleY: C } = Jw(r, l);
      (this.scaleX != k || this.scaleY != C) && (this.scaleX = k, this.scaleY = C, h |= 8, a = u = !0);
    }
    let d = (parseInt(i.paddingTop) || 0) * this.scaleY, m = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d || this.paddingBottom != m) && (this.paddingTop = d, this.paddingBottom = m, h |= 10), this.editorWidth != e.scrollDOM.clientWidth && (n.lineWrapping && (u = !0), this.editorWidth = e.scrollDOM.clientWidth, h |= 8);
    let y = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != y && (this.scrollAnchorHeight = -1, this.scrollTop = y), this.scrolledToBottom = tS(e.scrollDOM);
    let O = (this.printing ? tR : eR)(r, this.paddingTop), D = O.top - this.pixelViewport.top, v = O.bottom - this.pixelViewport.bottom;
    this.pixelViewport = O;
    let w = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (w != this.inView && (this.inView = w, w && (u = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let x = l.width;
    if ((this.contentDOMWidth != x || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = l.width, this.editorHeight = e.scrollDOM.clientHeight, h |= 8), u) {
      let k = e.docView.measureVisibleLineHeights(this.viewport);
      if (n.mustRefreshForHeights(k) && (a = !0), a || n.lineWrapping && Math.abs(x - this.contentDOMWidth) > n.charWidth) {
        let { lineHeight: C, charWidth: A, textHeight: P } = e.docView.measureTextSize();
        a = C > 0 && n.refresh(s, C, A, P, x / A, k), a && (e.docView.minWidth = 0, h |= 8);
      }
      D > 0 && v > 0 ? p = Math.max(D, v) : D < 0 && v < 0 && (p = Math.min(D, v)), n.heightChanged = !1;
      for (let C of this.viewports) {
        let A = C.from == this.viewport.from ? k : e.docView.measureVisibleLineHeights(C);
        this.heightMap = (a ? Ht.empty().applyChanges(this.stateDeco, je.empty, this.heightOracle, [new _r(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(n, 0, a, new zj(C.from, A));
      }
      n.heightChanged && (h |= 2);
    }
    let S = !this.viewportIsAppropriate(this.viewport, p) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return S && (this.viewport = this.getViewport(p, this.scrollTarget)), this.updateForViewport(), (h & 2 || S) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(a ? [] : this.lineGaps, e)), h |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), h;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, r) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), n = this.heightMap, s = this.heightOracle, { visibleTop: a, visibleBottom: l } = this, u = new vu(n.lineAt(a - i * 1e3, Ke.ByHeight, s, 0, 0).from, n.lineAt(l + (1 - i) * 1e3, Ke.ByHeight, s, 0, 0).to);
    if (r) {
      let { head: h } = r.range;
      if (h < u.from || h > u.to) {
        let p = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), d = n.lineAt(h, Ke.ByPos, s, 0, 0), m;
        r.y == "center" ? m = (d.top + d.bottom) / 2 - p / 2 : r.y == "start" || r.y == "nearest" && h < u.from ? m = d.top : m = d.bottom - p, u = new vu(n.lineAt(m - 1e3 / 2, Ke.ByHeight, s, 0, 0).from, n.lineAt(m + p + 1e3 / 2, Ke.ByHeight, s, 0, 0).to);
      }
    }
    return u;
  }
  mapViewport(e, r) {
    let i = r.mapPos(e.from, -1), n = r.mapPos(e.to, 1);
    return new vu(this.heightMap.lineAt(i, Ke.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(n, Ke.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: r }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: n } = this.heightMap.lineAt(e, Ke.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(r, Ke.ByPos, this.heightOracle, 0, 0), { visibleTop: a, visibleBottom: l } = this;
    return (e == 0 || n <= a - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (r == this.state.doc.length || s >= l + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && n > a - 2 * 1e3 && s < l + 2 * 1e3;
  }
  mapLineGaps(e, r) {
    if (!e.length || r.empty)
      return e;
    let i = [];
    for (let n of e)
      r.touchesRange(n.from, n.to) || i.push(new Rp(r.mapPos(n.from), r.mapPos(n.to), n.size));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, r) {
    let i = this.heightOracle.lineWrapping, n = i ? 1e4 : 2e3, s = n >> 1, a = n << 1;
    if (this.defaultTextDirection != tt.LTR && !i)
      return [];
    let l = [], u = (h, p, d, m) => {
      if (p - h < s)
        return;
      let y = this.state.selection.main, O = [y.from];
      y.empty || O.push(y.to);
      for (let v of O)
        if (v > h && v < p) {
          u(h, v - 10, d, m), u(v + 10, p, d, m);
          return;
        }
      let D = nR(e, (v) => v.from >= d.from && v.to <= d.to && Math.abs(v.from - h) < s && Math.abs(v.to - p) < s && !O.some((w) => v.from < w && v.to > w));
      if (!D) {
        if (p < d.to && r && i && r.visibleRanges.some((v) => v.from <= p && v.to >= p)) {
          let v = r.moveToLineBoundary(Y.cursor(p), !1, !0).head;
          v > h && (p = v);
        }
        D = new Rp(h, p, this.gapSize(d, h, p, m));
      }
      l.push(D);
    };
    for (let h of this.viewportLines) {
      if (h.length < a)
        continue;
      let p = iR(h.from, h.to, this.stateDeco);
      if (p.total < a)
        continue;
      let d = this.scrollTarget ? this.scrollTarget.range.head : null, m, y;
      if (i) {
        let O = n / this.heightOracle.lineLength * this.heightOracle.lineHeight, D, v;
        if (d != null) {
          let w = Su(p, d), x = ((this.visibleBottom - this.visibleTop) / 2 + O) / h.height;
          D = w - x, v = w + x;
        } else
          D = (this.visibleTop - h.top - O) / h.height, v = (this.visibleBottom - h.top + O) / h.height;
        m = wu(p, D), y = wu(p, v);
      } else {
        let O = p.total * this.heightOracle.charWidth, D = n * this.heightOracle.charWidth, v, w;
        if (d != null) {
          let x = Su(p, d), S = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + D) / O;
          v = x - S, w = x + S;
        } else
          v = (this.pixelViewport.left - D) / O, w = (this.pixelViewport.right + D) / O;
        m = wu(p, v), y = wu(p, w);
      }
      m > h.from && u(h.from, m, h, p), y < h.to && u(y, h.to, h, p);
    }
    return l;
  }
  gapSize(e, r, i, n) {
    let s = Su(n, i) - Su(n, r);
    return this.heightOracle.lineWrapping ? e.height * s : n.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    Rp.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = Oe.set(e.map((r) => r.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let r = [];
    Me.spans(e, this.viewport.from, this.viewport.to, {
      span(n, s) {
        r.push({ from: n, to: s });
      },
      point() {
      }
    }, 20);
    let i = r.length != this.visibleRanges.length || this.visibleRanges.some((n, s) => n.from != r[s].from || n.to != r[s].to);
    return this.visibleRanges = r, i ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((r) => r.from <= e && r.to >= e) || Co(this.heightMap.lineAt(e, Ke.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return Co(this.heightMap.lineAt(this.scaler.fromDOM(e), Ke.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let r = this.lineBlockAtHeight(e + 8);
    return r.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? r : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return Co(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class vu {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
function iR(t, e, r) {
  let i = [], n = t, s = 0;
  return Me.spans(r, t, e, {
    span() {
    },
    point(a, l) {
      a > n && (i.push({ from: n, to: a }), s += a - n), n = l;
    }
  }, 20), n < e && (i.push({ from: n, to: e }), s += e - n), { total: s, ranges: i };
}
function wu({ total: t, ranges: e }, r) {
  if (r <= 0)
    return e[0].from;
  if (r >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(t * r);
  for (let n = 0; ; n++) {
    let { from: s, to: a } = e[n], l = a - s;
    if (i <= l)
      return s + i;
    i -= l;
  }
}
function Su(t, e) {
  let r = 0;
  for (let { from: i, to: n } of t.ranges) {
    if (e <= n) {
      r += e - i;
      break;
    }
    r += n - i;
  }
  return r / t.total;
}
function nR(t, e) {
  for (let r of t)
    if (e(r))
      return r;
}
const iO = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1
};
class sR {
  constructor(e, r, i) {
    let n = 0, s = 0, a = 0;
    this.viewports = i.map(({ from: l, to: u }) => {
      let h = r.lineAt(l, Ke.ByPos, e, 0, 0).top, p = r.lineAt(u, Ke.ByPos, e, 0, 0).bottom;
      return n += p - h, { from: l, to: u, top: h, bottom: p, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - n) / (r.height - n);
    for (let l of this.viewports)
      l.domTop = a + (l.top - s) * this.scale, a = l.domBottom = l.domTop + (l.bottom - l.top), s = l.bottom;
  }
  toDOM(e) {
    for (let r = 0, i = 0, n = 0; ; r++) {
      let s = r < this.viewports.length ? this.viewports[r] : null;
      if (!s || e < s.top)
        return n + (e - i) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      i = s.bottom, n = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let r = 0, i = 0, n = 0; ; r++) {
      let s = r < this.viewports.length ? this.viewports[r] : null;
      if (!s || e < s.domTop)
        return i + (e - n) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      i = s.bottom, n = s.domBottom;
    }
  }
}
function Co(t, e) {
  if (e.scale == 1)
    return t;
  let r = e.toDOM(t.top), i = e.toDOM(t.bottom);
  return new Di(t.from, t.length, r, i - r, Array.isArray(t._content) ? t._content.map((n) => Co(n, e)) : t._content);
}
const Cu = /* @__PURE__ */ fe.define({ combine: (t) => t.join(" ") }), Cf = /* @__PURE__ */ fe.define({ combine: (t) => t.indexOf(!0) > -1 }), Ef = /* @__PURE__ */ Ln.newName(), ZS = /* @__PURE__ */ Ln.newName(), WS = /* @__PURE__ */ Ln.newName(), qS = { "&light": "." + ZS, "&dark": "." + WS };
function Af(t, e, r) {
  return new Ln(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (n) => {
        if (n == "&")
          return t;
        if (!r || !r[n])
          throw new RangeError(`Unsupported selector: ${n}`);
        return r[n];
      }) : t + " " + i;
    }
  });
}
const aR = /* @__PURE__ */ Af("." + Ef, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, qS), Eo = "￿";
class oR {
  constructor(e, r) {
    this.points = e, this.text = "", this.lineSeparator = r.facet(Be.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Eo;
  }
  readRange(e, r) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let n = e; ; ) {
      this.findPointBefore(i, n);
      let s = this.text.length;
      this.readNode(n);
      let a = n.nextSibling;
      if (a == r)
        break;
      let l = et.get(n), u = et.get(a);
      (l && u ? l.breakAfter : (l ? l.breakAfter : nO(n)) || nO(a) && (n.nodeName != "BR" || n.cmIgnore) && this.text.length > s) && this.lineBreak(), n = a;
    }
    return this.findPointBefore(i, r), this;
  }
  readTextNode(e) {
    let r = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, r.length));
    for (let i = 0, n = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, a = 1, l;
      if (this.lineSeparator ? (s = r.indexOf(this.lineSeparator, i), a = this.lineSeparator.length) : (l = n.exec(r)) && (s = l.index, a = l[0].length), this.append(r.slice(i, s < 0 ? r.length : s)), s < 0)
        break;
      if (this.lineBreak(), a > 1)
        for (let u of this.points)
          u.node == e && u.pos > this.text.length && (u.pos -= a - 1);
      i = s + a;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let r = et.get(e), i = r && r.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let n = i.iter(); !n.next().done; )
        n.lineBreak ? this.lineBreak() : this.append(n.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, r) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == r && (i.pos = this.text.length);
  }
  findPointInside(e, r) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + (lR(e, i.node, i.offset) ? r : 0));
  }
}
function lR(t, e, r) {
  for (; ; ) {
    if (!e || r < zi(e))
      return !1;
    if (e == t)
      return !0;
    r = nl(e) + 1, e = e.parentNode;
  }
}
function nO(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
class sO {
  constructor(e, r) {
    this.node = e, this.offset = r, this.pos = -1;
  }
}
class uR {
  constructor(e, r, i, n) {
    this.typeOver = n, this.bounds = null, this.text = "";
    let { impreciseHead: s, impreciseAnchor: a } = e.docView;
    if (e.state.readOnly && r > -1)
      this.newSel = null;
    else if (r > -1 && (this.bounds = e.docView.domBoundsAround(r, i, 0))) {
      let l = s || a ? [] : pR(e), u = new oR(l, e.state);
      u.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = u.text, this.newSel = dR(l, this.bounds.from);
    } else {
      let l = e.observer.selectionRange, u = s && s.node == l.focusNode && s.offset == l.focusOffset || !hf(e.contentDOM, l.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(l.focusNode, l.focusOffset), h = a && a.node == l.anchorNode && a.offset == l.anchorOffset || !hf(e.contentDOM, l.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(l.anchorNode, l.anchorOffset), p = e.viewport;
      if ((ge.ios || ge.chrome) && e.state.selection.main.empty && u != h && (p.from > 0 || p.to < e.state.doc.length)) {
        let d = Math.min(u, h), m = Math.max(u, h), y = p.from - d, O = p.to - m;
        (y == 0 || y == 1 || d == 0) && (O == 0 || O == -1 || m == e.state.doc.length) && (u = 0, h = e.state.doc.length);
      }
      this.newSel = Y.single(h, u);
    }
  }
}
function XS(t, e) {
  let r, { newSel: i } = e, n = t.state.selection.main, s = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: a, to: l } = e.bounds, u = n.from, h = null;
    (s === 8 || ge.android && e.text.length < l - a) && (u = n.to, h = "end");
    let p = hR(t.state.doc.sliceString(a, l, Eo), e.text, u - a, h);
    p && (ge.chrome && s == 13 && p.toB == p.from + 2 && e.text.slice(p.from, p.toB) == Eo + Eo && p.toB--, r = {
      from: a + p.from,
      to: a + p.toA,
      insert: je.of(e.text.slice(p.from, p.toB).split(Eo))
    });
  } else
    i && (!t.hasFocus && t.state.facet(Lh) || i.main.eq(n)) && (i = null);
  if (!r && !i)
    return !1;
  if (!r && e.typeOver && !n.empty && i && i.main.empty ? r = { from: n.from, to: n.to, insert: t.state.doc.slice(n.from, n.to) } : r && r.from >= n.from && r.to <= n.to && (r.from != n.from || r.to != n.to) && n.to - n.from - (r.to - r.from) <= 4 ? r = {
    from: n.from,
    to: n.to,
    insert: t.state.doc.slice(n.from, r.from).append(r.insert).append(t.state.doc.slice(r.to, n.to))
  } : (ge.mac || ge.android) && r && r.from == r.to && r.from == n.head - 1 && /^\. ?$/.test(r.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (i && r.insert.length == 2 && (i = Y.single(i.main.anchor - 1, i.main.head - 1)), r = { from: n.from, to: n.to, insert: je.of([" "]) }) : ge.chrome && r && r.from == r.to && r.from == n.head && r.insert.toString() == `
 ` && t.lineWrapping && (i && (i = Y.single(i.main.anchor - 1, i.main.head - 1)), r = { from: n.from, to: n.to, insert: je.of([" "]) }), r) {
    if (ge.ios && t.inputState.flushIOSKey() || ge.android && (r.from == n.from && r.to == n.to && r.insert.length == 1 && r.insert.lines == 2 && ma(t.contentDOM, "Enter", 13) || (r.from == n.from - 1 && r.to == n.to && r.insert.length == 0 || s == 8 && r.insert.length < r.to - r.from && r.to > n.head) && ma(t.contentDOM, "Backspace", 8) || r.from == n.from && r.to == n.to + 1 && r.insert.length == 0 && ma(t.contentDOM, "Delete", 46)))
      return !0;
    let a = r.insert.toString();
    t.inputState.composing >= 0 && t.inputState.composing++;
    let l, u = () => l || (l = cR(t, r, i));
    return t.state.facet(DS).some((h) => h(t, r.from, r.to, a, u)) || t.dispatch(u()), !0;
  } else if (i && !i.main.eq(n)) {
    let a = !1, l = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (a = !0), l = t.inputState.lastSelectionOrigin), t.dispatch({ selection: i, scrollIntoView: a, userEvent: l }), !0;
  } else
    return !1;
}
function cR(t, e, r) {
  let i, n = t.state, s = n.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!r || r.main.empty && r.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let l = s.from < e.from ? n.sliceDoc(s.from, e.from) : "", u = s.to > e.to ? n.sliceDoc(e.to, s.to) : "";
    i = n.replaceSelection(t.state.toText(l + e.insert.sliceString(0, void 0, t.state.lineBreak) + u));
  } else {
    let l = n.changes(e), u = r && r.main.to <= l.newLength ? r.main : void 0;
    if (n.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let h = t.state.sliceDoc(e.from, e.to), p, d = r && TS(t, r.main.head);
      if (d) {
        let O = e.insert.length - (e.to - e.from);
        p = { from: d.from, to: d.to - O };
      } else
        p = t.state.doc.lineAt(s.head);
      let m = s.to - e.to, y = s.to - s.from;
      i = n.changeByRange((O) => {
        if (O.from == s.from && O.to == s.to)
          return { changes: l, range: u || O.map(l) };
        let D = O.to - m, v = D - h.length;
        if (O.to - O.from != y || t.state.sliceDoc(v, D) != h || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        O.to >= p.from && O.from <= p.to)
          return { range: O };
        let w = n.changes({ from: v, to: D, insert: e.insert }), x = O.to - s.to;
        return {
          changes: w,
          range: u ? Y.range(Math.max(0, u.anchor + x), Math.max(0, u.head + x)) : O.map(w)
        };
      });
    } else
      i = {
        changes: l,
        selection: u && n.selection.replaceRange(u)
      };
  }
  let a = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, a += ".compose", t.inputState.compositionFirstChange && (a += ".start", t.inputState.compositionFirstChange = !1)), n.update(i, { userEvent: a, scrollIntoView: !0 });
}
function hR(t, e, r, i) {
  let n = Math.min(t.length, e.length), s = 0;
  for (; s < n && t.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == n && t.length == e.length)
    return null;
  let a = t.length, l = e.length;
  for (; a > 0 && l > 0 && t.charCodeAt(a - 1) == e.charCodeAt(l - 1); )
    a--, l--;
  if (i == "end") {
    let u = Math.max(0, s - Math.min(a, l));
    r -= a + u - s;
  }
  if (a < s && t.length < e.length) {
    let u = r <= s && r >= a ? s - r : 0;
    s -= u, l = s + (l - a), a = s;
  } else if (l < s) {
    let u = r <= s && r >= l ? s - r : 0;
    s -= u, a = s + (a - l), l = s;
  }
  return { from: s, toA: a, toB: l };
}
function pR(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: r, anchorOffset: i, focusNode: n, focusOffset: s } = t.observer.selectionRange;
  return r && (e.push(new sO(r, i)), (n != r || s != i) && e.push(new sO(n, s))), e;
}
function dR(t, e) {
  if (t.length == 0)
    return null;
  let r = t[0].pos, i = t.length == 2 ? t[1].pos : r;
  return r > -1 && i > -1 ? Y.single(r + e, i + e) : null;
}
const fR = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Zp = ge.ie && ge.ie_version <= 11;
class mR {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new JQ(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((r) => {
      for (let i of r)
        this.queue.push(i);
      (ge.ie && ge.ie_version <= 11 || ge.ios && e.composing) && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Zp && (this.onCharData = (r) => {
      this.queue.push({
        target: r.target,
        type: "characterData",
        oldValue: r.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var r;
      ((r = this.view.docView) === null || r === void 0 ? void 0 : r.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((r) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), r.length > 0 && r[r.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((r) => {
      r.length > 0 && r[r.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((r, i) => r != e[i]))) {
      this.gapIntersection.disconnect();
      for (let r of e)
        this.gapIntersection.observe(r);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let r = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, n = this.selectionRange;
    if (i.state.facet(Lh) ? i.root.activeElement != this.dom : !Gu(i.dom, n))
      return;
    let s = n.anchorNode && i.docView.nearest(n.anchorNode);
    if (s && s.ignoreEvent(e)) {
      r || (this.selectionChanged = !1);
      return;
    }
    (ge.ie && ge.ie_version <= 11 || ge.android && ge.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    n.focusNode && Zo(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, r = ge.safari && e.root.nodeType == 11 && YQ(this.dom.ownerDocument) == this.dom && gR(this.view) || bc(e.root);
    if (!r || this.selectionRange.eq(r))
      return !1;
    let i = Gu(this.dom, r);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && ej(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, r) {
    this.selectionRange.set(e.node, e.offset, r.node, r.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, r = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !r && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : r || (r = this.scrollTargets.slice(0, e)), r && r.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !r && (r = this.scrollTargets.slice(0, e)), r) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = r)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, fR), Zp && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Zp && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, r) {
    var i;
    if (!this.delayedAndroidKey) {
      let n = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && ma(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(n);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: r,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let r = -1, i = -1, n = !1;
    for (let s of e) {
      let a = this.readMutation(s);
      a && (a.typeOver && (n = !0), r == -1 ? { from: r, to: i } = a : (r = Math.min(a.from, r), i = Math.max(a.to, i)));
    }
    return { from: r, to: i, typeOver: n };
  }
  readChange() {
    let { from: e, to: r, typeOver: i } = this.processRecords(), n = this.selectionChanged && Gu(this.dom, this.selectionRange);
    if (e < 0 && !n)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new uR(this.view, e, r, i);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let r = this.readChange();
    if (!r)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, n = XS(this.view, r);
    return this.view.state == i && this.view.update([]), n;
  }
  readMutation(e) {
    let r = this.view.docView.nearest(e.target);
    if (!r || r.ignoreMutation(e))
      return null;
    if (r.markDirty(e.type == "attributes"), e.type == "attributes" && (r.flags |= 4), e.type == "childList") {
      let i = aO(r, e.previousSibling || e.target.previousSibling, -1), n = aO(r, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? r.posAfter(i) : r.posAtStart,
        to: n ? r.posBefore(n) : r.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, r, i;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (r = this.gapIntersection) === null || r === void 0 || r.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let n of this.scrollTargets)
      n.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function aO(t, e, r) {
  for (; e; ) {
    let i = et.get(e);
    if (i && i.parent == t)
      return i;
    let n = e.parentNode;
    e = n != t.dom ? n : r > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function gR(t) {
  let e = null;
  function r(u) {
    u.preventDefault(), u.stopImmediatePropagation(), e = u.getTargetRanges()[0];
  }
  if (t.contentDOM.addEventListener("beforeinput", r, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", r, !0), !e)
    return null;
  let i = e.startContainer, n = e.startOffset, s = e.endContainer, a = e.endOffset, l = t.docView.domAtPos(t.state.selection.main.anchor);
  return Zo(l.node, l.offset, s, a) && ([i, n, s, a] = [s, a, i, n]), { anchorNode: i, anchorOffset: n, focusNode: s, focusOffset: a };
}
class le {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((i) => i.forEach((n) => r(n, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || KQ(e.parent) || document, this.viewState = new rO(e.state || Be.create(e)), e.scrollTo && e.scrollTo.is(xu) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(wo).map((i) => new Lp(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new mR(this), this.inputState = new Fj(this), this.inputState.ensureHandlers(this.plugins), this.docView = new L1(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...e) {
    let r = e.length == 1 && e[0] instanceof dt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(r, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let r = !1, i = !1, n, s = this.state;
    for (let m of e) {
      if (m.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = m.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let a = this.hasFocus, l = 0, u = null;
    e.some((m) => m.annotation(LS)) ? (this.inputState.notifiedFocused = a, l = 1) : a != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = a, u = QS(s, a), u || (l = 1));
    let h = this.observer.delayedAndroidKey, p = null;
    if (h ? (this.observer.clearDelayedAndroidKey(), p = this.observer.readChange(), (p && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (p = null)) : this.observer.clear(), s.facet(Be.phrases) != this.state.facet(Be.phrases))
      return this.setState(s);
    n = vc.create(this, s, e), n.flags |= l;
    let d = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let m of e) {
        if (d && (d = d.map(m.changes)), m.scrollIntoView) {
          let { main: y } = m.state.selection;
          d = new ga(y.empty ? y : Y.cursor(y.head, y.head > y.anchor ? -1 : 1));
        }
        for (let y of m.effects)
          y.is(xu) && (d = y.value.clip(this.state));
      }
      this.viewState.update(n, d), this.bidiCache = wc.update(this.bidiCache, n.changes), n.empty || (this.updatePlugins(n), this.inputState.update(n)), r = this.docView.update(n), this.state.facet(So) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(r, e.some((m) => m.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (n.startState.facet(Cu) != n.state.facet(Cu) && (this.viewState.mustMeasureContent = !0), (r || i || d || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !n.empty)
      for (let m of this.state.facet(bf))
        try {
          m(n);
        } catch (y) {
          Nr(this.state, y, "update listener");
        }
    (u || p) && Promise.resolve().then(() => {
      u && this.state == u.startState && this.dispatch(u), p && !XS(this, p) && h.force && ma(this.contentDOM, h.key, h.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let r = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new rO(e), this.plugins = e.facet(wo).map((i) => new Lp(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new L1(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    r && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let r = e.startState.facet(wo), i = e.state.facet(wo);
    if (r != i) {
      let n = [];
      for (let s of i) {
        let a = r.indexOf(s);
        if (a < 0)
          n.push(new Lp(s));
        else {
          let l = this.plugins[a];
          l.mustUpdate = e, n.push(l);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = n, this.pluginMap.clear();
    } else
      for (let n of this.plugins)
        n.mustUpdate = e;
    for (let n = 0; n < this.plugins.length; n++)
      this.plugins[n].update(this);
    r != i && this.inputState.ensureHandlers(this.plugins);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let r = null, i = this.scrollDOM, n = i.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: a } = this.viewState;
    Math.abs(n - this.viewState.scrollTop) > 1 && (a = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let l = 0; ; l++) {
        if (a < 0)
          if (tS(i))
            s = -1, a = this.viewState.heightMap.height;
          else {
            let y = this.viewState.scrollAnchorAt(n);
            s = y.from, a = y.top;
          }
        this.updateState = 1;
        let u = this.viewState.measure(this);
        if (!u && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let h = [];
        u & 4 || ([this.measureRequests, h] = [h, this.measureRequests]);
        let p = h.map((y) => {
          try {
            return y.read(this);
          } catch (O) {
            return Nr(this.state, O), oO;
          }
        }), d = vc.create(this, this.state, []), m = !1;
        d.flags |= u, r ? r.flags |= u : r = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), m = this.docView.update(d));
        for (let y = 0; y < h.length; y++)
          if (p[y] != oO)
            try {
              let O = h[y];
              O.write && O.write(p[y], this);
            } catch (O) {
              Nr(this.state, O);
            }
        if (m && this.docView.updateSelection(!0), !d.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, a = -1;
              continue;
            } else {
              let O = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - a;
              if (O > 1 || O < -1) {
                n = n + O, i.scrollTop = n / this.scaleY, a = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (r && !r.empty)
      for (let l of this.state.facet(bf))
        l(r);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Ef + " " + (this.state.facet(Cf) ? WS : ZS) + " " + this.state.facet(Cu);
  }
  updateAttrs() {
    let e = lO(this, SS, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), r = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(Lh) ? "true" : "false",
      class: "cm-content",
      style: `${ge.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (r["aria-readonly"] = "true"), lO(this, Mg, r);
    let i = this.observer.ignore(() => {
      let n = gf(this.contentDOM, this.contentAttrs, r), s = gf(this.dom, this.editorAttrs, e);
      return n || s;
    });
    return this.editorAttrs = e, this.contentAttrs = r, i;
  }
  showAnnouncements(e) {
    let r = !0;
    for (let i of e)
      for (let n of i.effects)
        if (n.is(le.announce)) {
          r && (this.announceDOM.textContent = ""), r = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = n.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(So);
    let e = this.state.facet(le.cspNonce);
    Ln.mount(this.root, this.styleModules.concat(aR).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let r = 0; r < this.measureRequests.length; r++)
          if (this.measureRequests[r].key === e.key) {
            this.measureRequests[r] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let r = this.pluginMap.get(e);
    return (r === void 0 || r && r.spec != e) && this.pluginMap.set(e, r = this.plugins.find((i) => i.spec == e) || null), r && r.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, r, i) {
    return jp(this, e, q1(this, e, r, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, r) {
    return jp(this, e, q1(this, e, r, (i) => Tj(this, e.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, r) {
    let i = this.bidiSpans(e), n = this.textDirectionAt(e.from), s = i[r ? i.length - 1 : 0];
    return Y.cursor(s.side(r, n) + e.from, s.forward(!r, n) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, r, i = !0) {
    return kj(this, e, r, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, r, i) {
    return jp(this, e, Pj(this, e, r, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, r = 0) {
    return this.docView.posFromDOM(e, r);
  }
  posAtCoords(e, r = !0) {
    return this.readMeasured(), FS(this, e, r);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, r = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, r);
    if (!i || i.left == i.right)
      return i;
    let n = this.state.doc.lineAt(e), s = this.bidiSpans(n), a = s[En.find(s, e - n.from, -1, r)];
    return _h(i, a.dir == tt.LTR == r > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(vS) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > yR)
      return fS(e.length);
    let r = this.textDirectionAt(e.from), i;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == r && (s.fresh || dS(s.isolates, i = M1(this, e))))
        return s.order;
    i || (i = M1(this, e));
    let n = pj(e.text, r, i);
    return this.bidiCache.push(new wc(e.from, e.to, r, i, !0, n)), n;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || ge.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      Kw(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, r = {}) {
    return xu.of(new ga(typeof e == "number" ? Y.cursor(e) : e, r.y, r.x, r.yMargin, r.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: r } = this.scrollDOM, i = this.viewState.scrollAnchorAt(e);
    return xu.of(new ga(Y.cursor(i.from), "start", "start", i.top - e, r, !0));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return ct.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return ct.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, r) {
    let i = Ln.newName(), n = [Cu.of(i), So.of(Af(`.${i}`, e))];
    return r && r.dark && n.push(Cf.of(!0)), n;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return js.lowest(So.of(Af("." + Ef, e, qS)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var r;
    let i = e.querySelector(".cm-content"), n = i && et.get(i) || et.get(e);
    return ((r = n == null ? void 0 : n.rootView) === null || r === void 0 ? void 0 : r.view) || null;
  }
}
le.styleModule = So;
le.inputHandler = DS;
le.focusChangeEffect = bS;
le.perLineTextDirection = vS;
le.exceptionSink = xS;
le.updateListener = bf;
le.editable = Lh;
le.mouseSelectionStyle = OS;
le.dragMovesSelection = yS;
le.clickAddsSelectionRange = gS;
le.decorations = sl;
le.outerDecorations = CS;
le.atomicRanges = Lg;
le.bidiIsolatedRanges = ES;
le.scrollMargins = AS;
le.darkTheme = Cf;
le.cspNonce = /* @__PURE__ */ fe.define({ combine: (t) => t.length ? t[0] : "" });
le.contentAttributes = Mg;
le.editorAttributes = SS;
le.lineWrapping = /* @__PURE__ */ le.contentAttributes.of({ class: "cm-lineWrapping" });
le.announce = /* @__PURE__ */ we.define();
const yR = 4096, oO = {};
class wc {
  constructor(e, r, i, n, s, a) {
    this.from = e, this.to = r, this.dir = i, this.isolates = n, this.fresh = s, this.order = a;
  }
  static update(e, r) {
    if (r.empty && !e.some((s) => s.fresh))
      return e;
    let i = [], n = e.length ? e[e.length - 1].dir : tt.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let a = e[s];
      a.dir == n && !r.touchesRange(a.from, a.to) && i.push(new wc(r.mapPos(a.from, 1), r.mapPos(a.to, -1), a.dir, a.isolates, !1, a.order));
    }
    return i;
  }
}
function lO(t, e, r) {
  for (let i = t.state.facet(e), n = i.length - 1; n >= 0; n--) {
    let s = i[n], a = typeof s == "function" ? s(t) : s;
    a && mf(a, r);
  }
  return r;
}
const OR = ge.mac ? "mac" : ge.windows ? "win" : ge.linux ? "linux" : "key";
function xR(t, e) {
  const r = t.split(/-(?!$)/);
  let i = r[r.length - 1];
  i == "Space" && (i = " ");
  let n, s, a, l;
  for (let u = 0; u < r.length - 1; ++u) {
    const h = r[u];
    if (/^(cmd|meta|m)$/i.test(h))
      l = !0;
    else if (/^a(lt)?$/i.test(h))
      n = !0;
    else if (/^(c|ctrl|control)$/i.test(h))
      s = !0;
    else if (/^s(hift)?$/i.test(h))
      a = !0;
    else if (/^mod$/i.test(h))
      e == "mac" ? l = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + h);
  }
  return n && (i = "Alt-" + i), s && (i = "Ctrl-" + i), l && (i = "Meta-" + i), a && (i = "Shift-" + i), i;
}
function Eu(t, e, r) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), r !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const DR = /* @__PURE__ */ js.default(/* @__PURE__ */ le.domEventHandlers({
  keydown(t, e) {
    return US(VS(e.state), t, e, "editor");
  }
})), _l = /* @__PURE__ */ fe.define({ enables: DR }), uO = /* @__PURE__ */ new WeakMap();
function VS(t) {
  let e = t.facet(_l), r = uO.get(e);
  return r || uO.set(e, r = wR(e.reduce((i, n) => i.concat(n), []))), r;
}
function bR(t, e, r) {
  return US(VS(t.state), e, t, r);
}
let vn = null;
const vR = 4e3;
function wR(t, e = OR) {
  let r = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), n = (a, l) => {
    let u = i[a];
    if (u == null)
      i[a] = l;
    else if (u != l)
      throw new Error("Key binding " + a + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (a, l, u, h, p) => {
    var d, m;
    let y = r[a] || (r[a] = /* @__PURE__ */ Object.create(null)), O = l.split(/ (?!$)/).map((w) => xR(w, e));
    for (let w = 1; w < O.length; w++) {
      let x = O.slice(0, w).join(" ");
      n(x, !0), y[x] || (y[x] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(S) => {
          let k = vn = { view: S, prefix: x, scope: a };
          return setTimeout(() => {
            vn == k && (vn = null);
          }, vR), !0;
        }]
      });
    }
    let D = O.join(" ");
    n(D, !1);
    let v = y[D] || (y[D] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((m = (d = y._any) === null || d === void 0 ? void 0 : d.run) === null || m === void 0 ? void 0 : m.slice()) || []
    });
    u && v.run.push(u), h && (v.preventDefault = !0), p && (v.stopPropagation = !0);
  };
  for (let a of t) {
    let l = a.scope ? a.scope.split(" ") : ["editor"];
    if (a.any)
      for (let h of l) {
        let p = r[h] || (r[h] = /* @__PURE__ */ Object.create(null));
        p._any || (p._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let d in p)
          p[d].run.push(a.any);
      }
    let u = a[e] || a.key;
    if (u)
      for (let h of l)
        s(h, u, a.run, a.preventDefault, a.stopPropagation), a.shift && s(h, "Shift-" + u, a.shift, a.preventDefault, a.stopPropagation);
  }
  return r;
}
function US(t, e, r, i) {
  let n = UQ(e), s = Et(n, 0), a = Br(s) == n.length && n != " ", l = "", u = !1, h = !1, p = !1;
  vn && vn.view == r && vn.scope == i && (l = vn.prefix + " ", BS.indexOf(e.keyCode) < 0 && (h = !0, vn = null));
  let d = /* @__PURE__ */ new Set(), m = (v) => {
    if (v) {
      for (let w of v.run)
        if (!d.has(w) && (d.add(w), w(r, e)))
          return v.stopPropagation && (p = !0), !0;
      v.preventDefault && (v.stopPropagation && (p = !0), h = !0);
    }
    return !1;
  }, y = t[i], O, D;
  return y && (m(y[l + Eu(n, e, !a)]) ? u = !0 : a && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(ge.windows && e.ctrlKey && e.altKey) && (O = Qn[e.keyCode]) && O != n ? (m(y[l + Eu(O, e, !0)]) || e.shiftKey && (D = il[e.keyCode]) != n && D != O && m(y[l + Eu(D, e, !1)])) && (u = !0) : a && e.shiftKey && m(y[l + Eu(n, e, !0)]) && (u = !0), !u && m(y._any) && (u = !0)), h && (u = !0), u && p && e.stopPropagation(), u;
}
class Ml {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, r, i, n, s) {
    this.className = e, this.left = r, this.top = i, this.width = n, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, r) {
    return r.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, r, i) {
    if (i.empty) {
      let n = e.coordsAtPos(i.head, i.assoc || 1);
      if (!n)
        return [];
      let s = YS(e);
      return [new Ml(r, n.left - s.left, n.top - s.top, null, n.bottom - n.top)];
    } else
      return SR(e, r, i);
  }
}
function YS(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == tt.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function cO(t, e, r) {
  let i = Y.cursor(e);
  return {
    from: Math.max(r.from, t.moveToLineBoundary(i, !1, !0).from),
    to: Math.min(r.to, t.moveToLineBoundary(i, !0, !0).from),
    type: Gt.Text
  };
}
function SR(t, e, r) {
  if (r.to <= t.viewport.from || r.from >= t.viewport.to)
    return [];
  let i = Math.max(r.from, t.viewport.from), n = Math.min(r.to, t.viewport.to), s = t.textDirection == tt.LTR, a = t.contentDOM, l = a.getBoundingClientRect(), u = YS(t), h = a.querySelector(".cm-line"), p = h && window.getComputedStyle(h), d = l.left + (p ? parseInt(p.paddingLeft) + Math.min(0, parseInt(p.textIndent)) : 0), m = l.right - (p ? parseInt(p.paddingRight) : 0), y = wf(t, i), O = wf(t, n), D = y.type == Gt.Text ? y : null, v = O.type == Gt.Text ? O : null;
  if (D && (t.lineWrapping || y.widgetLineBreaks) && (D = cO(t, i, D)), v && (t.lineWrapping || O.widgetLineBreaks) && (v = cO(t, n, v)), D && v && D.from == v.from)
    return x(S(r.from, r.to, D));
  {
    let C = D ? S(r.from, null, D) : k(y, !1), A = v ? S(null, r.to, v) : k(O, !0), P = [];
    return (D || y).to < (v || O).from - (D && v ? 1 : 0) || y.widgetLineBreaks > 1 && C.bottom + t.defaultLineHeight / 2 < A.top ? P.push(w(d, C.bottom, m, A.top)) : C.bottom < A.top && t.elementAtHeight((C.bottom + A.top) / 2).type == Gt.Text && (C.bottom = A.top = (C.bottom + A.top) / 2), x(C).concat(P).concat(x(A));
  }
  function w(C, A, P, I) {
    return new Ml(
      e,
      C - u.left,
      A - u.top - 0.01,
      P - C,
      I - A + 0.01
      /* C.Epsilon */
    );
  }
  function x({ top: C, bottom: A, horizontal: P }) {
    let I = [];
    for (let B = 0; B < P.length; B += 2)
      I.push(w(P[B], C, P[B + 1], A));
    return I;
  }
  function S(C, A, P) {
    let I = 1e9, B = -1e9, _ = [];
    function R(Q, q, X, K, ye) {
      let Ce = t.coordsAtPos(Q, Q == P.to ? -2 : 2), be = t.coordsAtPos(X, X == P.from ? 2 : -2);
      !Ce || !be || (I = Math.min(Ce.top, be.top, I), B = Math.max(Ce.bottom, be.bottom, B), ye == tt.LTR ? _.push(s && q ? d : Ce.left, s && K ? m : be.right) : _.push(!s && K ? d : be.left, !s && q ? m : Ce.right));
    }
    let G = C ?? P.from, J = A ?? P.to;
    for (let Q of t.visibleRanges)
      if (Q.to > G && Q.from < J)
        for (let q = Math.max(Q.from, G), X = Math.min(Q.to, J); ; ) {
          let K = t.state.doc.lineAt(q);
          for (let ye of t.bidiSpans(K)) {
            let Ce = ye.from + K.from, be = ye.to + K.from;
            if (Ce >= X)
              break;
            be > q && R(Math.max(Ce, q), C == null && Ce <= G, Math.min(be, X), A == null && be >= J, ye.dir);
          }
          if (q = K.to + 1, q >= X)
            break;
        }
    return _.length == 0 && R(G, C == null, J, A == null, t.textDirection), { top: I, bottom: B, horizontal: _ };
  }
  function k(C, A) {
    let P = l.top + (A ? C.top : C.bottom);
    return { top: P, bottom: P, horizontal: [] };
  }
}
function CR(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class ER {
  constructor(e, r) {
    this.view = e, this.layer = r, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), r.above && this.dom.classList.add("cm-layer-above"), r.class && this.dom.classList.add(r.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), r.mount && r.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Ku) != e.state.facet(Ku) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  setOrder(e) {
    let r = 0, i = e.facet(Ku);
    for (; r < i.length && i[r] != this.layer; )
      r++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - r);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: r } = this.view;
    (e != this.scaleX || r != this.scaleY) && (this.scaleX = e, this.scaleY = r, this.dom.style.transform = `scale(${1 / e}, ${1 / r})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((r, i) => !CR(r, this.drawn[i]))) {
      let r = this.dom.firstChild, i = 0;
      for (let n of e)
        n.update && r && n.constructor && this.drawn[i].constructor && n.update(r, this.drawn[i]) ? (r = r.nextSibling, i++) : this.dom.insertBefore(n.draw(), r);
      for (; r; ) {
        let n = r.nextSibling;
        r.remove(), r = n;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Ku = /* @__PURE__ */ fe.define();
function zS(t) {
  return [
    ct.define((e) => new ER(e, t)),
    Ku.of(t)
  ];
}
const GS = !ge.ios, al = /* @__PURE__ */ fe.define({
  combine(t) {
    return _i(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, r) => Math.min(e, r),
      drawRangeCursor: (e, r) => e || r
    });
  }
});
function AR(t = {}) {
  return [
    al.of(t),
    kR,
    TR,
    PR,
    wS.of(!0)
  ];
}
function HS(t) {
  return t.startState.facet(al) != t.state.facet(al);
}
const kR = /* @__PURE__ */ zS({
  above: !0,
  markers(t) {
    let { state: e } = t, r = e.facet(al), i = [];
    for (let n of e.selection.ranges) {
      let s = n == e.selection.main;
      if (n.empty ? !s || GS : r.drawRangeCursor) {
        let a = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", l = n.empty ? n : Y.cursor(n.head, n.head > n.anchor ? -1 : 1);
        for (let u of Ml.forRange(t, a, l))
          i.push(u);
      }
    }
    return i;
  },
  update(t, e) {
    t.transactions.some((i) => i.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let r = HS(t);
    return r && hO(t.state, e), t.docChanged || t.selectionSet || r;
  },
  mount(t, e) {
    hO(e.state, t);
  },
  class: "cm-cursorLayer"
});
function hO(t, e) {
  e.style.animationDuration = t.facet(al).cursorBlinkRate + "ms";
}
const TR = /* @__PURE__ */ zS({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : Ml.forRange(t, "cm-selectionBackground", e)).reduce((e, r) => e.concat(r));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || HS(t);
  },
  class: "cm-selectionLayer"
}), kf = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
GS && (kf[".cm-line"].caretColor = "transparent !important", kf[".cm-content"] = { caretColor: "transparent !important" });
const PR = /* @__PURE__ */ js.highest(/* @__PURE__ */ le.theme(kf)), JS = /* @__PURE__ */ we.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), Ao = /* @__PURE__ */ vt.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((r, i) => i.is(JS) ? i.value : r, t);
  }
}), FR = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let r = t.state.field(Ao);
    r == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(Ao) != r || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(Ao), r = e != null && t.coordsAtPos(e);
    if (!r)
      return null;
    let i = t.scrollDOM.getBoundingClientRect();
    return {
      left: r.left - i.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: r.top - i.top + t.scrollDOM.scrollTop * t.scaleY,
      height: r.bottom - r.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: r } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / r + "px", this.cursor.style.height = t.height / r + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(Ao) != t && this.view.dispatch({ effects: JS.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function $R() {
  return [Ao, FR];
}
function pO(t, e, r, i, n) {
  e.lastIndex = 0;
  for (let s = t.iterRange(r, i), a = r, l; !s.next().done; a += s.value.length)
    if (!s.lineBreak)
      for (; l = e.exec(s.value); )
        n(a + l.index, l);
}
function BR(t, e) {
  let r = t.visibleRanges;
  if (r.length == 1 && r[0].from == t.viewport.from && r[0].to == t.viewport.to)
    return r;
  let i = [];
  for (let { from: n, to: s } of r)
    n = Math.max(t.state.doc.lineAt(n).from, n - e), s = Math.min(t.state.doc.lineAt(s).to, s + e), i.length && i[i.length - 1].to >= n ? i[i.length - 1].to = s : i.push({ from: n, to: s });
  return i;
}
class IR {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: r, decoration: i, decorate: n, boundary: s, maxLength: a = 1e3 } = e;
    if (!r.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = r, n)
      this.addMatch = (l, u, h, p) => n(p, h, h + l[0].length, l, u);
    else if (typeof i == "function")
      this.addMatch = (l, u, h, p) => {
        let d = i(l, u, h);
        d && p(h, h + l[0].length, d);
      };
    else if (i)
      this.addMatch = (l, u, h, p) => p(h, h + l[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = a;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let r = new Mn(), i = r.add.bind(r);
    for (let { from: n, to: s } of BR(e, this.maxLength))
      pO(e.state.doc, this.regexp, n, s, (a, l) => this.addMatch(l, e, a, i));
    return r.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, r) {
    let i = 1e9, n = -1;
    return e.docChanged && e.changes.iterChanges((s, a, l, u) => {
      u > e.view.viewport.from && l < e.view.viewport.to && (i = Math.min(l, i), n = Math.max(u, n));
    }), e.viewportChanged || n - i > 1e3 ? this.createDeco(e.view) : n > -1 ? this.updateRange(e.view, r.map(e.changes), i, n) : r;
  }
  updateRange(e, r, i, n) {
    for (let s of e.visibleRanges) {
      let a = Math.max(s.from, i), l = Math.min(s.to, n);
      if (l > a) {
        let u = e.state.doc.lineAt(a), h = u.to < l ? e.state.doc.lineAt(l) : u, p = Math.max(s.from, u.from), d = Math.min(s.to, h.to);
        if (this.boundary) {
          for (; a > u.from; a--)
            if (this.boundary.test(u.text[a - 1 - u.from])) {
              p = a;
              break;
            }
          for (; l < h.to; l++)
            if (this.boundary.test(h.text[l - h.from])) {
              d = l;
              break;
            }
        }
        let m = [], y, O = (D, v, w) => m.push(w.range(D, v));
        if (u == h)
          for (this.regexp.lastIndex = p - u.from; (y = this.regexp.exec(u.text)) && y.index < d - u.from; )
            this.addMatch(y, e, y.index + u.from, O);
        else
          pO(e.state.doc, this.regexp, p, d, (D, v) => this.addMatch(v, e, D, O));
        r = r.update({ filterFrom: p, filterTo: d, filter: (D, v) => D < p || v > d, add: m });
      }
    }
    return r;
  }
}
const Tf = /x/.unicode != null ? "gu" : "g", NR = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, Tf), _R = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let Wp = null;
function MR() {
  var t;
  if (Wp == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    Wp = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return Wp || !1;
}
const ec = /* @__PURE__ */ fe.define({
  combine(t) {
    let e = _i(t, {
      render: null,
      specialChars: NR,
      addSpecialChars: null
    });
    return (e.replaceTabs = !MR()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, Tf)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, Tf)), e;
  }
});
function LR(t = {}) {
  return [ec.of(t), QR()];
}
let dO = null;
function QR() {
  return dO || (dO = ct.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = Oe.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(ec)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new IR({
        regexp: t.specialChars,
        decoration: (e, r, i) => {
          let { doc: n } = r.state, s = Et(e[0], 0);
          if (s == 9) {
            let a = n.lineAt(i), l = r.state.tabSize, u = Va(a.text, l, i - a.from);
            return Oe.replace({
              widget: new WR((l - u % l) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = Oe.replace({ widget: new ZR(t, s) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(ec);
      t.startState.facet(ec) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const jR = "•";
function RR(t) {
  return t >= 32 ? jR : t == 10 ? "␤" : String.fromCharCode(9216 + t);
}
class ZR extends Mi {
  constructor(e, r) {
    super(), this.options = e, this.code = r;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let r = RR(this.code), i = e.state.phrase("Control character") + " " + (_R[this.code] || "0x" + this.code.toString(16)), n = this.options.render && this.options.render(this.code, i, r);
    if (n)
      return n;
    let s = document.createElement("span");
    return s.textContent = r, s.title = i, s.setAttribute("aria-label", i), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class WR extends Mi {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function qR() {
  return VR;
}
const XR = /* @__PURE__ */ Oe.line({ class: "cm-activeLine" }), VR = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, r = [];
    for (let i of t.state.selection.ranges) {
      let n = t.lineBlockAt(i.head);
      n.from > e && (r.push(XR.range(n.from)), e = n.from);
    }
    return Oe.set(r);
  }
}, {
  decorations: (t) => t.decorations
});
class UR extends Mi {
  constructor(e) {
    super(), this.content = e;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content), typeof this.content == "string" ? e.setAttribute("aria-label", "placeholder " + this.content) : e.setAttribute("aria-hidden", "true"), e;
  }
  coordsAt(e) {
    let r = e.firstChild ? ka(e.firstChild) : [];
    if (!r.length)
      return null;
    let i = window.getComputedStyle(e.parentNode), n = _h(r[0], i.direction != "rtl"), s = parseInt(i.lineHeight);
    return n.bottom - n.top > s * 1.5 ? { left: n.left, right: n.right, top: n.top, bottom: n.top + s } : n;
  }
  ignoreEvent() {
    return !1;
  }
}
function YR(t) {
  return ct.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = t ? Oe.set([Oe.widget({ widget: new UR(t), side: 1 }).range(0)]) : Oe.none;
    }
    get decorations() {
      return this.view.state.doc.length ? Oe.none : this.placeholder;
    }
  }, { decorations: (e) => e.decorations });
}
const Pf = 2e3;
function zR(t, e, r) {
  let i = Math.min(e.line, r.line), n = Math.max(e.line, r.line), s = [];
  if (e.off > Pf || r.off > Pf || e.col < 0 || r.col < 0) {
    let a = Math.min(e.off, r.off), l = Math.max(e.off, r.off);
    for (let u = i; u <= n; u++) {
      let h = t.doc.line(u);
      h.length <= l && s.push(Y.range(h.from + a, h.to + l));
    }
  } else {
    let a = Math.min(e.col, r.col), l = Math.max(e.col, r.col);
    for (let u = i; u <= n; u++) {
      let h = t.doc.line(u), p = lf(h.text, a, t.tabSize, !0);
      if (p < 0)
        s.push(Y.cursor(h.to));
      else {
        let d = lf(h.text, l, t.tabSize);
        s.push(Y.range(h.from + p, h.from + d));
      }
    }
  }
  return s;
}
function GR(t, e) {
  let r = t.coordsAtPos(t.viewport.from);
  return r ? Math.round(Math.abs((r.left - e) / t.defaultCharacterWidth)) : -1;
}
function fO(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), i = t.state.doc.lineAt(r), n = r - i.from, s = n > Pf ? -1 : n == i.length ? GR(t, e.clientX) : Va(i.text, t.state.tabSize, r - i.from);
  return { line: i.number, col: s, off: n };
}
function HR(t, e) {
  let r = fO(t, e), i = t.state.selection;
  return r ? {
    update(n) {
      if (n.docChanged) {
        let s = n.changes.mapPos(n.startState.doc.line(r.line).from), a = n.state.doc.lineAt(s);
        r = { line: a.number, col: r.col, off: Math.min(r.off, a.length) }, i = i.map(n.changes);
      }
    },
    get(n, s, a) {
      let l = fO(t, n);
      if (!l)
        return i;
      let u = zR(t.state, r, l);
      return u.length ? a ? Y.create(u.concat(i.ranges)) : Y.create(u) : i;
    }
  } : null;
}
function JR(t) {
  let e = (t == null ? void 0 : t.eventFilter) || ((r) => r.altKey && r.button == 0);
  return le.mouseSelectionStyle.of((r, i) => e(i) ? HR(r, i) : null);
}
const KR = {
  Alt: [18, (t) => !!t.altKey],
  Control: [17, (t) => !!t.ctrlKey],
  Shift: [16, (t) => !!t.shiftKey],
  Meta: [91, (t) => !!t.metaKey]
}, eZ = { style: "cursor: crosshair" };
function tZ(t = {}) {
  let [e, r] = KR[t.key || "Alt"], i = ct.fromClass(class {
    constructor(n) {
      this.view = n, this.isDown = !1;
    }
    set(n) {
      this.isDown != n && (this.isDown = n, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(n) {
        this.set(n.keyCode == e || r(n));
      },
      keyup(n) {
        (n.keyCode == e || !r(n)) && this.set(!1);
      },
      mousemove(n) {
        this.set(r(n));
      }
    }
  });
  return [
    i,
    le.contentAttributes.of((n) => {
      var s;
      return !((s = n.plugin(i)) === null || s === void 0) && s.isDown ? eZ : null;
    })
  ];
}
const fo = "-10000px";
class KS {
  constructor(e, r, i, n) {
    this.facet = r, this.createTooltipView = i, this.removeTooltipView = n, this.input = e.state.facet(r), this.tooltips = this.input.filter((a) => a);
    let s = null;
    this.tooltipViews = this.tooltips.map((a) => s = i(a, s));
  }
  update(e, r) {
    var i;
    let n = e.state.facet(this.facet), s = n.filter((u) => u);
    if (n === this.input) {
      for (let u of this.tooltipViews)
        u.update && u.update(e);
      return !1;
    }
    let a = [], l = r ? [] : null;
    for (let u = 0; u < s.length; u++) {
      let h = s[u], p = -1;
      if (h) {
        for (let d = 0; d < this.tooltips.length; d++) {
          let m = this.tooltips[d];
          m && m.create == h.create && (p = d);
        }
        if (p < 0)
          a[u] = this.createTooltipView(h, u ? a[u - 1] : null), l && (l[u] = !!h.above);
        else {
          let d = a[u] = this.tooltipViews[p];
          l && (l[u] = r[p]), d.update && d.update(e);
        }
      }
    }
    for (let u of this.tooltipViews)
      a.indexOf(u) < 0 && (this.removeTooltipView(u), (i = u.destroy) === null || i === void 0 || i.call(u));
    return r && (l.forEach((u, h) => r[h] = u), r.length = l.length), this.input = n, this.tooltips = s, this.tooltipViews = a, !0;
  }
}
function rZ(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const qp = /* @__PURE__ */ fe.define({
  combine: (t) => {
    var e, r, i;
    return {
      position: ge.ios ? "absolute" : ((e = t.find((n) => n.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((r = t.find((n) => n.parent)) === null || r === void 0 ? void 0 : r.parent) || null,
      tooltipSpace: ((i = t.find((n) => n.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || rZ
    };
  }
}), mO = /* @__PURE__ */ new WeakMap(), jg = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(qp);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new KS(t, Rg, (r, i) => this.createTooltip(r, i), (r) => {
      this.resizeObserver && this.resizeObserver.unobserve(r.dom), r.dom.remove();
    }), this.above = this.manager.tooltips.map((r) => !!r.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((r) => {
      Date.now() > this.lastTransaction - 50 && r.length > 0 && r[r.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let r = e || t.geometryChanged, i = t.state.facet(qp);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let n of this.manager.tooltipViews)
        n.dom.style.position = this.position;
      r = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let n of this.manager.tooltipViews)
        this.container.appendChild(n.dom);
      r = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    r && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let r = t.create(this.view), i = e ? e.dom : null;
    if (r.dom.classList.add("cm-tooltip"), t.arrow && !r.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let n = document.createElement("div");
      n.className = "cm-tooltip-arrow", r.dom.insertBefore(n, i);
    }
    return r.dom.style.position = this.position, r.dom.style.top = fo, r.dom.style.left = "0px", this.container.insertBefore(r.dom, i), r.mount && r.mount(this.view), this.resizeObserver && this.resizeObserver.observe(r.dom), r;
  }
  destroy() {
    var t, e, r;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (t = i.destroy) === null || t === void 0 || t.call(i);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (r = this.intersectionObserver) === null || r === void 0 || r.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = this.view.dom.getBoundingClientRect(), e = 1, r = 1, i = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: n } = this.manager.tooltipViews[0];
      if (ge.gecko)
        i = n.offsetParent != this.container.ownerDocument.body;
      else if (n.style.top == fo && n.style.left == "0px") {
        let s = n.getBoundingClientRect();
        i = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (i || this.position == "absolute")
      if (this.parent) {
        let n = this.parent.getBoundingClientRect();
        n.width && n.height && (e = n.width / this.parent.offsetWidth, r = n.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: r } = this.view.viewState);
    return {
      editor: t,
      parent: this.parent ? this.container.getBoundingClientRect() : t,
      pos: this.manager.tooltips.map((n, s) => {
        let a = this.manager.tooltipViews[s];
        return a.getCoords ? a.getCoords(n.pos) : this.view.coordsAtPos(n.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: n }) => n.getBoundingClientRect()),
      space: this.view.state.facet(qp).tooltipSpace(this.view),
      scaleX: e,
      scaleY: r,
      makeAbsolute: i
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let l of this.manager.tooltipViews)
        l.dom.style.position = "absolute";
    }
    let { editor: r, space: i, scaleX: n, scaleY: s } = t, a = [];
    for (let l = 0; l < this.manager.tooltips.length; l++) {
      let u = this.manager.tooltips[l], h = this.manager.tooltipViews[l], { dom: p } = h, d = t.pos[l], m = t.size[l];
      if (!d || d.bottom <= Math.max(r.top, i.top) || d.top >= Math.min(r.bottom, i.bottom) || d.right < Math.max(r.left, i.left) - 0.1 || d.left > Math.min(r.right, i.right) + 0.1) {
        p.style.top = fo;
        continue;
      }
      let y = u.arrow ? h.dom.querySelector(".cm-tooltip-arrow") : null, O = y ? 7 : 0, D = m.right - m.left, v = (e = mO.get(h)) !== null && e !== void 0 ? e : m.bottom - m.top, w = h.offset || nZ, x = this.view.textDirection == tt.LTR, S = m.width > i.right - i.left ? x ? i.left : i.right - m.width : x ? Math.min(d.left - (y ? 14 : 0) + w.x, i.right - D) : Math.max(i.left, d.left - D + (y ? 14 : 0) - w.x), k = this.above[l];
      !u.strictSide && (k ? d.top - (m.bottom - m.top) - w.y < i.top : d.bottom + (m.bottom - m.top) + w.y > i.bottom) && k == i.bottom - d.bottom > d.top - i.top && (k = this.above[l] = !k);
      let C = (k ? d.top - i.top : i.bottom - d.bottom) - O;
      if (C < v && h.resize !== !1) {
        if (C < this.view.defaultLineHeight) {
          p.style.top = fo;
          continue;
        }
        mO.set(h, v), p.style.height = (v = C) / s + "px";
      } else
        p.style.height && (p.style.height = "");
      let A = k ? d.top - v - O - w.y : d.bottom + O + w.y, P = S + D;
      if (h.overlap !== !0)
        for (let I of a)
          I.left < P && I.right > S && I.top < A + v && I.bottom > A && (A = k ? I.top - v - 2 - O : I.bottom + O + 2);
      if (this.position == "absolute" ? (p.style.top = (A - t.parent.top) / s + "px", p.style.left = (S - t.parent.left) / n + "px") : (p.style.top = A / s + "px", p.style.left = S / n + "px"), y) {
        let I = d.left + (x ? w.x : -w.x) - (S + 14 - 7);
        y.style.left = I / n + "px";
      }
      h.overlap !== !0 && a.push({ left: S, top: A, right: P, bottom: A + v }), p.classList.toggle("cm-tooltip-above", k), p.classList.toggle("cm-tooltip-below", !k), h.positioned && h.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = fo;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), iZ = /* @__PURE__ */ le.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), nZ = { x: 0, y: 0 }, Rg = /* @__PURE__ */ fe.define({
  enables: [jg, iZ]
}), Sc = /* @__PURE__ */ fe.define({
  combine: (t) => t.reduce((e, r) => e.concat(r), [])
});
class Qh {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Qh(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new KS(e, Sc, (r, i) => this.createHostedView(r, i), (r) => r.dom.remove());
  }
  createHostedView(e, r) {
    let i = e.create(this.view);
    return i.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(i.dom, r ? r.dom.nextSibling : this.dom.firstChild), this.mounted && i.mount && i.mount(this.view), i;
  }
  mount(e) {
    for (let r of this.manager.tooltipViews)
      r.mount && r.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let r of this.manager.tooltipViews)
      r.positioned && r.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let r of this.manager.tooltipViews)
      (e = r.destroy) === null || e === void 0 || e.call(r);
  }
  passProp(e) {
    let r;
    for (let i of this.manager.tooltipViews) {
      let n = i[e];
      if (n !== void 0) {
        if (r === void 0)
          r = n;
        else if (r !== n)
          return;
      }
    }
    return r;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const sZ = /* @__PURE__ */ Rg.compute([Sc], (t) => {
  let e = t.facet(Sc);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((r) => r.pos)),
    end: Math.max(...e.map((r) => {
      var i;
      return (i = r.end) !== null && i !== void 0 ? i : r.pos;
    })),
    create: Qh.create,
    above: e[0].above,
    arrow: e.some((r) => r.arrow)
  };
});
class aZ {
  constructor(e, r, i, n, s) {
    this.view = e, this.source = r, this.field = i, this.setHover = n, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: r } = this, i = e.docView.nearest(r.target);
    if (!i)
      return;
    let n, s = 1;
    if (i instanceof Cn)
      n = i.posAtStart;
    else {
      if (n = e.posAtCoords(r), n == null)
        return;
      let l = e.coordsAtPos(n);
      if (!l || r.y < l.top || r.y > l.bottom || r.x < l.left - e.defaultCharacterWidth || r.x > l.right + e.defaultCharacterWidth)
        return;
      let u = e.bidiSpans(e.state.doc.lineAt(n)).find((p) => p.from <= n && p.to >= n), h = u && u.dir == tt.RTL ? -1 : 1;
      s = r.x < l.left ? -h : h;
    }
    let a = this.source(e, n, s);
    if (a != null && a.then) {
      let l = this.pending = { pos: n };
      a.then((u) => {
        this.pending == l && (this.pending = null, u && !(Array.isArray(u) && !u.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(u) ? u : [u]) }));
      }, (u) => Nr(e.state, u, "hover tooltip"));
    } else
      a && !(Array.isArray(a) && !a.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(a) ? a : [a]) });
  }
  get tooltip() {
    let e = this.view.plugin(jg), r = e ? e.manager.tooltips.findIndex((i) => i.create == Qh.create) : -1;
    return r > -1 ? e.manager.tooltipViews[r] : null;
  }
  mousemove(e) {
    var r, i;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: n, tooltip: s } = this;
    if (n.length && s && !oZ(s.dom, e) || this.pending) {
      let { pos: a } = n[0] || this.pending, l = (i = (r = n[0]) === null || r === void 0 ? void 0 : r.end) !== null && i !== void 0 ? i : a;
      (a == l ? this.view.posAtCoords(this.lastMove) != a : !lZ(this.view, a, l, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: r } = this;
    if (r.length) {
      let { tooltip: i } = this;
      i && i.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(i.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let r = (i) => {
      e.removeEventListener("mouseleave", r), this.active.length && !this.view.dom.contains(i.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", r);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const Au = 4;
function oZ(t, e) {
  let r = t.getBoundingClientRect();
  return e.clientX >= r.left - Au && e.clientX <= r.right + Au && e.clientY >= r.top - Au && e.clientY <= r.bottom + Au;
}
function lZ(t, e, r, i, n, s) {
  let a = t.scrollDOM.getBoundingClientRect(), l = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (a.left > i || a.right < i || a.top > n || Math.min(a.bottom, l) < n)
    return !1;
  let u = t.posAtCoords({ x: i, y: n }, !1);
  return u >= e && u <= r;
}
function uZ(t, e = {}) {
  let r = we.define(), i = vt.define({
    create() {
      return [];
    },
    update(n, s) {
      if (n.length && (e.hideOnChange && (s.docChanged || s.selection) ? n = [] : e.hideOn && (n = n.filter((a) => !e.hideOn(s, a))), s.docChanged))
        for (let a of n) {
          let l = s.changes.mapPos(a.pos, -1, Tt.TrackDel);
          if (l != null) {
            let u = Object.assign(/* @__PURE__ */ Object.create(null), a);
            u.pos = l, u.end != null && (u.end = s.changes.mapPos(u.end));
          }
        }
      for (let a of s.effects)
        a.is(r) && (n = a.value), a.is(cZ) && (n = []);
      return n;
    },
    provide: (n) => Sc.from(n)
  });
  return [
    i,
    ct.define((n) => new aZ(
      n,
      t,
      i,
      r,
      e.hoverTime || 300
      /* Hover.Time */
    )),
    sZ
  ];
}
function eC(t, e) {
  let r = t.plugin(jg);
  if (!r)
    return null;
  let i = r.manager.tooltips.indexOf(e);
  return i < 0 ? null : r.manager.tooltipViews[i];
}
const cZ = /* @__PURE__ */ we.define(), gO = /* @__PURE__ */ fe.define({
  combine(t) {
    let e, r;
    for (let i of t)
      e = e || i.topContainer, r = r || i.bottomContainer;
    return { topContainer: e, bottomContainer: r };
  }
});
function ol(t, e) {
  let r = t.plugin(tC), i = r ? r.specs.indexOf(e) : -1;
  return i > -1 ? r.panels[i] : null;
}
const tC = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(ll), this.specs = this.input.filter((r) => r), this.panels = this.specs.map((r) => r(t));
    let e = t.state.facet(gO);
    this.top = new ku(t, !0, e.topContainer), this.bottom = new ku(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((r) => r.top)), this.bottom.sync(this.panels.filter((r) => !r.top));
    for (let r of this.panels)
      r.dom.classList.add("cm-panel"), r.mount && r.mount();
  }
  update(t) {
    let e = t.state.facet(gO);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new ku(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new ku(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let r = t.state.facet(ll);
    if (r != this.input) {
      let i = r.filter((u) => u), n = [], s = [], a = [], l = [];
      for (let u of i) {
        let h = this.specs.indexOf(u), p;
        h < 0 ? (p = u(t.view), l.push(p)) : (p = this.panels[h], p.update && p.update(t)), n.push(p), (p.top ? s : a).push(p);
      }
      this.specs = i, this.panels = n, this.top.sync(s), this.bottom.sync(a);
      for (let u of l)
        u.dom.classList.add("cm-panel"), u.mount && u.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => le.scrollMargins.of((e) => {
    let r = e.plugin(t);
    return r && { top: r.top.scrollMargin(), bottom: r.bottom.scrollMargin() };
  })
});
class ku {
  constructor(e, r, i) {
    this.view = e, this.top = r, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let r of this.panels)
      r.destroy && e.indexOf(r) < 0 && r.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let r = this.container || this.view.dom;
      r.insertBefore(this.dom, this.top ? r.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let r of this.panels)
      if (r.dom.parentNode == this.dom) {
        for (; e != r.dom; )
          e = yO(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(r.dom, e);
    for (; e; )
      e = yO(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function yO(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const ll = /* @__PURE__ */ fe.define({
  enables: tC
});
class Ji extends ws {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
Ji.prototype.elementClass = "";
Ji.prototype.toDOM = void 0;
Ji.prototype.mapMode = Tt.TrackBefore;
Ji.prototype.startSide = Ji.prototype.endSide = -1;
Ji.prototype.point = !0;
const tc = /* @__PURE__ */ fe.define(), hZ = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Me.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, qo = /* @__PURE__ */ fe.define();
function pZ(t) {
  return [rC(), qo.of(Object.assign(Object.assign({}, hZ), t))];
}
const Ff = /* @__PURE__ */ fe.define({
  combine: (t) => t.some((e) => e)
});
function rC(t) {
  let e = [
    dZ
  ];
  return t && t.fixed === !1 && e.push(Ff.of(!0)), e;
}
const dZ = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(qo).map((e) => new xO(t, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !t.state.facet(Ff), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, r = t.view.viewport, i = Math.min(e.to, r.to) - Math.max(e.from, r.from);
      this.syncGutters(i < (r.to - r.from) * 0.8);
    }
    t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(Ff) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && this.dom.remove();
    let r = Me.iter(this.view.state.facet(tc), this.view.viewport.from), i = [], n = this.gutters.map((s) => new fZ(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(s.type)) {
        let a = !0;
        for (let l of s.type)
          if (l.type == Gt.Text && a) {
            $f(r, i, l.from);
            for (let u of n)
              u.line(this.view, l, i);
            a = !1;
          } else if (l.widget)
            for (let u of n)
              u.widget(this.view, l);
      } else if (s.type == Gt.Text) {
        $f(r, i, s.from);
        for (let a of n)
          a.line(this.view, s, i);
      } else if (s.widget)
        for (let a of n)
          a.widget(this.view, s);
    for (let s of n)
      s.finish();
    t && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(t) {
    let e = t.startState.facet(qo), r = t.state.facet(qo), i = t.docChanged || t.heightChanged || t.viewportChanged || !Me.eq(t.startState.facet(tc), t.state.facet(tc), t.view.viewport.from, t.view.viewport.to);
    if (e == r)
      for (let n of this.gutters)
        n.update(t) && (i = !0);
    else {
      i = !0;
      let n = [];
      for (let s of r) {
        let a = e.indexOf(s);
        a < 0 ? n.push(new xO(this.view, s)) : (this.gutters[a].update(t), n.push(this.gutters[a]));
      }
      for (let s of this.gutters)
        s.dom.remove(), n.indexOf(s) < 0 && s.destroy();
      for (let s of n)
        this.dom.appendChild(s.dom);
      this.gutters = n;
    }
    return i;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove();
  }
}, {
  provide: (t) => le.scrollMargins.of((e) => {
    let r = e.plugin(t);
    return !r || r.gutters.length == 0 || !r.fixed ? null : e.textDirection == tt.LTR ? { left: r.dom.offsetWidth * e.scaleX } : { right: r.dom.offsetWidth * e.scaleX };
  })
});
function OO(t) {
  return Array.isArray(t) ? t : [t];
}
function $f(t, e, r) {
  for (; t.value && t.from <= r; )
    t.from == r && e.push(t.value), t.next();
}
class fZ {
  constructor(e, r, i) {
    this.gutter = e, this.height = i, this.i = 0, this.cursor = Me.iter(e.markers, r.from);
  }
  addElement(e, r, i) {
    let { gutter: n } = this, s = (r.top - this.height) / e.scaleY, a = r.height / e.scaleY;
    if (this.i == n.elements.length) {
      let l = new iC(e, a, s, i);
      n.elements.push(l), n.dom.appendChild(l.dom);
    } else
      n.elements[this.i].update(e, a, s, i);
    this.height = r.bottom, this.i++;
  }
  line(e, r, i) {
    let n = [];
    $f(this.cursor, n, r.from), i.length && (n = n.concat(i));
    let s = this.gutter.config.lineMarker(e, r, n);
    s && n.unshift(s);
    let a = this.gutter;
    n.length == 0 && !a.config.renderEmptyElements || this.addElement(e, r, n);
  }
  widget(e, r) {
    let i = this.gutter.config.widgetMarker(e, r.widget, r);
    i && this.addElement(e, r, [i]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let r = e.elements.pop();
      e.dom.removeChild(r.dom), r.destroy();
    }
  }
}
class xO {
  constructor(e, r) {
    this.view = e, this.config = r, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in r.domEventHandlers)
      this.dom.addEventListener(i, (n) => {
        let s = n.target, a;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let u = s.getBoundingClientRect();
          a = (u.top + u.bottom) / 2;
        } else
          a = n.clientY;
        let l = e.lineBlockAtHeight(a - e.documentTop);
        r.domEventHandlers[i](e, l, n) && n.preventDefault();
      });
    this.markers = OO(r.markers(e)), r.initialSpacer && (this.spacer = new iC(e, 0, 0, [r.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let r = this.markers;
    if (this.markers = OO(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let n = this.config.updateSpacer(this.spacer.markers[0], e);
      n != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [n]);
    }
    let i = e.view.viewport;
    return !Me.eq(this.markers, r, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class iC {
  constructor(e, r, i, n) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, r, i, n);
  }
  update(e, r, i, n) {
    this.height != r && (this.height = r, this.dom.style.height = r + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), mZ(this.markers, n) || this.setMarkers(e, n);
  }
  setMarkers(e, r) {
    let i = "cm-gutterElement", n = this.dom.firstChild;
    for (let s = 0, a = 0; ; ) {
      let l = a, u = s < r.length ? r[s++] : null, h = !1;
      if (u) {
        let p = u.elementClass;
        p && (i += " " + p);
        for (let d = a; d < this.markers.length; d++)
          if (this.markers[d].compare(u)) {
            l = d, h = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; a < l; ) {
        let p = this.markers[a++];
        if (p.toDOM) {
          p.destroy(n);
          let d = n.nextSibling;
          n.remove(), n = d;
        }
      }
      if (!u)
        break;
      u.toDOM && (h ? n = n.nextSibling : this.dom.insertBefore(u.toDOM(e), n)), h && a++;
    }
    this.dom.className = i, this.markers = r;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function mZ(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!t[r].compare(e[r]))
      return !1;
  return !0;
}
const gZ = /* @__PURE__ */ fe.define(), ua = /* @__PURE__ */ fe.define({
  combine(t) {
    return _i(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, r) {
        let i = Object.assign({}, e);
        for (let n in r) {
          let s = i[n], a = r[n];
          i[n] = s ? (l, u, h) => s(l, u, h) || a(l, u, h) : a;
        }
        return i;
      }
    });
  }
});
class Xp extends Ji {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Vp(t, e) {
  return t.state.facet(ua).formatNumber(e, t.state);
}
const yZ = /* @__PURE__ */ qo.compute([ua], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(gZ);
  },
  lineMarker(e, r, i) {
    return i.some((n) => n.toDOM) ? null : new Xp(Vp(e, e.state.doc.lineAt(r.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(ua) != e.state.facet(ua),
  initialSpacer(e) {
    return new Xp(Vp(e, DO(e.state.doc.lines)));
  },
  updateSpacer(e, r) {
    let i = Vp(r.view, DO(r.view.state.doc.lines));
    return i == e.number ? e : new Xp(i);
  },
  domEventHandlers: t.facet(ua).domEventHandlers
}));
function OZ(t = {}) {
  return [
    ua.of(t),
    rC(),
    yZ
  ];
}
function DO(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const xZ = /* @__PURE__ */ new class extends Ji {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), DZ = /* @__PURE__ */ tc.compute(["selection"], (t) => {
  let e = [], r = -1;
  for (let i of t.selection.ranges) {
    let n = t.doc.lineAt(i.head).from;
    n > r && (r = n, e.push(xZ.range(n)));
  }
  return Me.of(e);
});
function bZ() {
  return DZ;
}
const nC = 1024;
let vZ = 0;
class Up {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
class Pe {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = vZ++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = or.match(e)), (r) => {
      let i = e(r);
      return i === void 0 ? null : [this, i];
    };
  }
}
Pe.closedBy = new Pe({ deserialize: (t) => t.split(" ") });
Pe.openedBy = new Pe({ deserialize: (t) => t.split(" ") });
Pe.group = new Pe({ deserialize: (t) => t.split(" ") });
Pe.isolate = new Pe({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
Pe.contextHash = new Pe({ perNode: !0 });
Pe.lookAhead = new Pe({ perNode: !0 });
Pe.mounted = new Pe({ perNode: !0 });
class Cc {
  constructor(e, r, i) {
    this.tree = e, this.overlay = r, this.parser = i;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[Pe.mounted.id];
  }
}
const wZ = /* @__PURE__ */ Object.create(null);
class or {
  /**
  @internal
  */
  constructor(e, r, i, n = 0) {
    this.name = e, this.props = r, this.id = i, this.flags = n;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let r = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : wZ, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), n = new or(e.name || "", r, e.id, i);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(n)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          r[s[0].id] = s[1];
        }
    }
    return n;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let r = this.prop(Pe.group);
      return r ? r.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in e)
      for (let n of i.split(" "))
        r[n] = e[i];
    return (i) => {
      for (let n = i.prop(Pe.group), s = -1; s < (n ? n.length : 0); s++) {
        let a = r[s < 0 ? i.name : n[s]];
        if (a)
          return a;
      }
    };
  }
}
or.none = new or(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class Zg {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let r = 0; r < e.length; r++)
      if (e[r].id != r)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let r = [];
    for (let i of this.types) {
      let n = null;
      for (let s of e) {
        let a = s(i);
        a && (n || (n = Object.assign({}, i.props)), n[a[0].id] = a[1]);
      }
      r.push(n ? new or(i.name, n, i.id, i.flags) : i);
    }
    return new Zg(r);
  }
}
const Tu = /* @__PURE__ */ new WeakMap(), bO = /* @__PURE__ */ new WeakMap();
var Ot;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Ot || (Ot = {}));
class ft {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, r, i, n, s) {
    if (this.type = e, this.children = r, this.positions = i, this.length = n, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [a, l] of s)
        this.props[typeof a == "number" ? a : a.id] = l;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = Cc.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let r = "";
    for (let i of this.children) {
      let n = i.toString();
      n && (r && (r += ","), r += n);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (r.length ? "(" + r + ")" : "") : r;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new If(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, r = 0, i = 0) {
    let n = Tu.get(this) || this.topNode, s = new If(n);
    return s.moveTo(e, r), Tu.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new nr(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, r = 0) {
    let i = ul(Tu.get(this) || this.topNode, e, r, !1);
    return Tu.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, r = 0) {
    let i = ul(bO.get(this) || this.topNode, e, r, !0);
    return bO.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, r = 0) {
    return EZ(this, e, r);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: r, leave: i, from: n = 0, to: s = this.length } = e, a = e.mode || 0, l = (a & Ot.IncludeAnonymous) > 0;
    for (let u = this.cursor(a | Ot.IncludeAnonymous); ; ) {
      let h = !1;
      if (u.from <= s && u.to >= n && (!l && u.type.isAnonymous || r(u) !== !1)) {
        if (u.firstChild())
          continue;
        h = !0;
      }
      for (; h && i && (l || !u.type.isAnonymous) && i(u), !u.nextSibling(); ) {
        if (!u.parent())
          return;
        h = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let r in this.props)
        e.push([+r, this.props[r]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : Xg(or.none, this.children, this.positions, 0, this.children.length, 0, this.length, (r, i, n) => new ft(this.type, r, i, n, this.propValues), e.makeTree || ((r, i, n) => new ft(or.none, r, i, n)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return AZ(e);
  }
}
ft.empty = new ft(or.none, [], [], 0);
class Wg {
  constructor(e, r) {
    this.buffer = e, this.index = r;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Wg(this.buffer, this.index);
  }
}
class Rn {
  /**
  Create a tree buffer.
  */
  constructor(e, r, i) {
    this.buffer = e, this.length = r, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return or.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let r = 0; r < this.buffer.length; )
      e.push(this.childString(r)), r = this.buffer[r + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let r = this.buffer[e], i = this.buffer[e + 3], n = this.set.types[r], s = n.name;
    if (/\W/.test(s) && !n.isError && (s = JSON.stringify(s)), e += 4, i == e)
      return s;
    let a = [];
    for (; e < i; )
      a.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + a.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, r, i, n, s) {
    let { buffer: a } = this, l = -1;
    for (let u = e; u != r && !(sC(s, n, a[u + 1], a[u + 2]) && (l = u, i > 0)); u = a[u + 3])
      ;
    return l;
  }
  /**
  @internal
  */
  slice(e, r, i) {
    let n = this.buffer, s = new Uint16Array(r - e), a = 0;
    for (let l = e, u = 0; l < r; ) {
      s[u++] = n[l++], s[u++] = n[l++] - i;
      let h = s[u++] = n[l++] - i;
      s[u++] = n[l++] - e, a = Math.max(a, h);
    }
    return new Rn(s, a, this.set);
  }
}
function sC(t, e, r, i) {
  switch (t) {
    case -2:
      return r < e;
    case -1:
      return i >= e && r < e;
    case 0:
      return r < e && i > e;
    case 1:
      return r <= e && i > e;
    case 2:
      return i > e;
    case 4:
      return !0;
  }
}
function ul(t, e, r, i) {
  for (var n; t.from == t.to || (r < 1 ? t.from >= e : t.from > e) || (r > -1 ? t.to <= e : t.to < e); ) {
    let a = !i && t instanceof nr && t.index < 0 ? null : t.parent;
    if (!a)
      return t;
    t = a;
  }
  let s = i ? 0 : Ot.IgnoreOverlays;
  if (i)
    for (let a = t, l = a.parent; l; a = l, l = a.parent)
      a instanceof nr && a.index < 0 && ((n = l.enter(e, r, s)) === null || n === void 0 ? void 0 : n.from) != a.from && (t = l);
  for (; ; ) {
    let a = t.enter(e, r, s);
    if (!a)
      return t;
    t = a;
  }
}
class aC {
  cursor(e = 0) {
    return new If(this, e);
  }
  getChild(e, r = null, i = null) {
    let n = vO(this, e, r, i);
    return n.length ? n[0] : null;
  }
  getChildren(e, r = null, i = null) {
    return vO(this, e, r, i);
  }
  resolve(e, r = 0) {
    return ul(this, e, r, !1);
  }
  resolveInner(e, r = 0) {
    return ul(this, e, r, !0);
  }
  matchContext(e) {
    return Bf(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let r = this.childBefore(e), i = this;
    for (; r; ) {
      let n = r.lastChild;
      if (!n || n.to != r.to)
        break;
      n.type.isError && n.from == n.to ? (i = r, r = n.prevSibling) : r = n;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class nr extends aC {
  constructor(e, r, i, n) {
    super(), this._tree = e, this.from = r, this.index = i, this._parent = n;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, r, i, n, s = 0) {
    for (let a = this; ; ) {
      for (let { children: l, positions: u } = a._tree, h = r > 0 ? l.length : -1; e != h; e += r) {
        let p = l[e], d = u[e] + a.from;
        if (sC(n, i, d, d + p.length)) {
          if (p instanceof Rn) {
            if (s & Ot.ExcludeBuffers)
              continue;
            let m = p.findChild(0, p.buffer.length, r, i - d, n);
            if (m > -1)
              return new vi(new SZ(a, p, e, d), null, m);
          } else if (s & Ot.IncludeAnonymous || !p.type.isAnonymous || qg(p)) {
            let m;
            if (!(s & Ot.IgnoreMounts) && (m = Cc.get(p)) && !m.overlay)
              return new nr(m.tree, d, e, a);
            let y = new nr(p, d, e, a);
            return s & Ot.IncludeAnonymous || !y.type.isAnonymous ? y : y.nextChild(r < 0 ? p.children.length - 1 : 0, r, i, n);
          }
        }
      }
      if (s & Ot.IncludeAnonymous || !a.type.isAnonymous || (a.index >= 0 ? e = a.index + r : e = r < 0 ? -1 : a._parent._tree.children.length, a = a._parent, !a))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, i = 0) {
    let n;
    if (!(i & Ot.IgnoreOverlays) && (n = Cc.get(this._tree)) && n.overlay) {
      let s = e - this.from;
      for (let { from: a, to: l } of n.overlay)
        if ((r > 0 ? a <= s : a < s) && (r < 0 ? l >= s : l > s))
          return new nr(n.tree, n.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, r, i);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function vO(t, e, r, i) {
  let n = t.cursor(), s = [];
  if (!n.firstChild())
    return s;
  if (r != null) {
    for (let a = !1; !a; )
      if (a = n.type.is(r), !n.nextSibling())
        return s;
  }
  for (; ; ) {
    if (i != null && n.type.is(i))
      return s;
    if (n.type.is(e) && s.push(n.node), !n.nextSibling())
      return i == null ? s : [];
  }
}
function Bf(t, e, r = e.length - 1) {
  for (let i = t.parent; r >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (e[r] && e[r] != i.name)
        return !1;
      r--;
    }
  }
  return !0;
}
class SZ {
  constructor(e, r, i, n) {
    this.parent = e, this.buffer = r, this.index = i, this.start = n;
  }
}
class vi extends aC {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, r, i) {
    super(), this.context = e, this._parent = r, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]];
  }
  child(e, r, i) {
    let { buffer: n } = this.context, s = n.findChild(this.index + 4, n.buffer[this.index + 3], e, r - this.context.start, i);
    return s < 0 ? null : new vi(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, i = 0) {
    if (i & Ot.ExcludeBuffers)
      return null;
    let { buffer: n } = this.context, s = n.findChild(this.index + 4, n.buffer[this.index + 3], r > 0 ? 1 : -1, e - this.context.start, r);
    return s < 0 ? null : new vi(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, r = e.buffer[this.index + 3];
    return r < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new vi(this.context, this._parent, r) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, r = this._parent ? this._parent.index + 4 : 0;
    return this.index == r ? this.externalSibling(-1) : new vi(this.context, this._parent, e.findChild(
      r,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], r = [], { buffer: i } = this.context, n = this.index + 4, s = i.buffer[this.index + 3];
    if (s > n) {
      let a = i.buffer[this.index + 1];
      e.push(i.slice(n, s, a)), r.push(0);
    }
    return new ft(this.type, e, r, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function oC(t) {
  if (!t.length)
    return null;
  let e = 0, r = t[0];
  for (let s = 1; s < t.length; s++) {
    let a = t[s];
    (a.from > r.from || a.to < r.to) && (r = a, e = s);
  }
  let i = r instanceof nr && r.index < 0 ? null : r.parent, n = t.slice();
  return i ? n[e] = i : n.splice(e, 1), new CZ(n, r);
}
class CZ {
  constructor(e, r) {
    this.heads = e, this.node = r;
  }
  get next() {
    return oC(this.heads);
  }
}
function EZ(t, e, r) {
  let i = t.resolveInner(e, r), n = null;
  for (let s = i instanceof nr ? i : i.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let a = s.parent;
      (n || (n = [i])).push(a.resolve(e, r)), s = a;
    } else {
      let a = Cc.get(s.tree);
      if (a && a.overlay && a.overlay[0].from <= e && a.overlay[a.overlay.length - 1].to >= e) {
        let l = new nr(a.tree, a.overlay[0].from + s.from, -1, s);
        (n || (n = [i])).push(ul(l, e, r, !1));
      }
    }
  return n ? oC(n) : i;
}
class If {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, r = 0) {
    if (this.mode = r, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof nr)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let i = e._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, r) {
    this.index = e;
    let { start: i, buffer: n } = this.buffer;
    return this.type = r || n.set.types[n.buffer[e]], this.from = i + n.buffer[e + 1], this.to = i + n.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof nr ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, r, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, r, i, this.mode));
    let { buffer: n } = this.buffer, s = n.findChild(this.index + 4, n.buffer[this.index + 3], e, r - this.buffer.start, i);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, r, i = this.mode) {
    return this.buffer ? i & Ot.ExcludeBuffers ? !1 : this.enterChild(1, e, r) : this.yield(this._tree.enter(e, r, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Ot.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Ot.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: r } = this.buffer, i = this.stack.length - 1;
    if (e < 0) {
      let n = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != n)
        return this.yieldBuf(r.findChild(
          n,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let n = r.buffer[this.index + 3];
      if (n < (i < 0 ? r.buffer.length : r.buffer[this.stack[i] + 3]))
        return this.yieldBuf(n);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let r, i, { buffer: n } = this;
    if (n) {
      if (e > 0) {
        if (this.index < n.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (n.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: r, parent: i } = n);
    } else
      ({ index: r, _parent: i } = this._tree);
    for (; i; { index: r, _parent: i } = i)
      if (r > -1)
        for (let s = r + e, a = e < 0 ? -1 : i._tree.children.length; s != a; s += e) {
          let l = i._tree.children[s];
          if (this.mode & Ot.IncludeAnonymous || l instanceof Rn || !l.type.isAnonymous || qg(l))
            return !1;
        }
    return !0;
  }
  move(e, r) {
    if (r && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, r = 0) {
    for (; (this.from == this.to || (r < 1 ? this.from >= e : this.from > e) || (r > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, r); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, r = null, i = 0;
    if (e && e.context == this.buffer)
      e:
        for (let n = this.index, s = this.stack.length; s >= 0; ) {
          for (let a = e; a; a = a._parent)
            if (a.index == n) {
              if (n == this.index)
                return a;
              r = a, i = s + 1;
              break e;
            }
          n = this.stack[--s];
        }
    for (let n = i; n < this.stack.length; n++)
      r = new vi(this.buffer, r, this.stack[n]);
    return this.bufferNode = new vi(this.buffer, r, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, r) {
    for (let i = 0; ; ) {
      let n = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (n = !0);
      }
      for (; n && r && r(this), n = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!i)
          return;
        this.parent(), i--, n = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return Bf(this.node, e);
    let { buffer: r } = this.buffer, { types: i } = r.set;
    for (let n = e.length - 1, s = this.stack.length - 1; n >= 0; s--) {
      if (s < 0)
        return Bf(this.node, e, n);
      let a = i[r.buffer[this.stack[s]]];
      if (!a.isAnonymous) {
        if (e[n] && e[n] != a.name)
          return !1;
        n--;
      }
    }
    return !0;
  }
}
function qg(t) {
  return t.children.some((e) => e instanceof Rn || !e.type.isAnonymous || qg(e));
}
function AZ(t) {
  var e;
  let { buffer: r, nodeSet: i, maxBufferLength: n = nC, reused: s = [], minRepeatType: a = i.types.length } = t, l = Array.isArray(r) ? new Wg(r, r.length) : r, u = i.types, h = 0, p = 0;
  function d(C, A, P, I, B, _) {
    let { id: R, start: G, end: J, size: Q } = l, q = p;
    for (; Q < 0; )
      if (l.next(), Q == -1) {
        let be = s[R];
        P.push(be), I.push(G - C);
        return;
      } else if (Q == -3) {
        h = R;
        return;
      } else if (Q == -4) {
        p = R;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${Q}`);
    let X = u[R], K, ye, Ce = G - C;
    if (J - G <= n && (ye = v(l.pos - A, B))) {
      let be = new Uint16Array(ye.size - ye.skip), Le = l.pos - ye.size, Ye = be.length;
      for (; l.pos > Le; )
        Ye = w(ye.start, be, Ye);
      K = new Rn(be, J - ye.start, i), Ce = ye.start - C;
    } else {
      let be = l.pos - Q;
      l.next();
      let Le = [], Ye = [], Je = R >= a ? R : -1, Te = 0, ht = J;
      for (; l.pos > be; )
        Je >= 0 && l.id == Je && l.size >= 0 ? (l.end <= ht - n && (O(Le, Ye, G, Te, l.end, ht, Je, q), Te = Le.length, ht = l.end), l.next()) : _ > 2500 ? m(G, be, Le, Ye) : d(G, be, Le, Ye, Je, _ + 1);
      if (Je >= 0 && Te > 0 && Te < Le.length && O(Le, Ye, G, Te, G, ht, Je, q), Le.reverse(), Ye.reverse(), Je > -1 && Te > 0) {
        let ue = y(X);
        K = Xg(X, Le, Ye, 0, Le.length, 0, J - G, ue, ue);
      } else
        K = D(X, Le, Ye, J - G, q - J);
    }
    P.push(K), I.push(Ce);
  }
  function m(C, A, P, I) {
    let B = [], _ = 0, R = -1;
    for (; l.pos > A; ) {
      let { id: G, start: J, end: Q, size: q } = l;
      if (q > 4)
        l.next();
      else {
        if (R > -1 && J < R)
          break;
        R < 0 && (R = Q - n), B.push(G, J, Q), _++, l.next();
      }
    }
    if (_) {
      let G = new Uint16Array(_ * 4), J = B[B.length - 2];
      for (let Q = B.length - 3, q = 0; Q >= 0; Q -= 3)
        G[q++] = B[Q], G[q++] = B[Q + 1] - J, G[q++] = B[Q + 2] - J, G[q++] = q;
      P.push(new Rn(G, B[2] - J, i)), I.push(J - C);
    }
  }
  function y(C) {
    return (A, P, I) => {
      let B = 0, _ = A.length - 1, R, G;
      if (_ >= 0 && (R = A[_]) instanceof ft) {
        if (!_ && R.type == C && R.length == I)
          return R;
        (G = R.prop(Pe.lookAhead)) && (B = P[_] + R.length + G);
      }
      return D(C, A, P, I, B);
    };
  }
  function O(C, A, P, I, B, _, R, G) {
    let J = [], Q = [];
    for (; C.length > I; )
      J.push(C.pop()), Q.push(A.pop() + P - B);
    C.push(D(i.types[R], J, Q, _ - B, G - _)), A.push(B - P);
  }
  function D(C, A, P, I, B = 0, _) {
    if (h) {
      let R = [Pe.contextHash, h];
      _ = _ ? [R].concat(_) : [R];
    }
    if (B > 25) {
      let R = [Pe.lookAhead, B];
      _ = _ ? [R].concat(_) : [R];
    }
    return new ft(C, A, P, I, _);
  }
  function v(C, A) {
    let P = l.fork(), I = 0, B = 0, _ = 0, R = P.end - n, G = { size: 0, start: 0, skip: 0 };
    e:
      for (let J = P.pos - C; P.pos > J; ) {
        let Q = P.size;
        if (P.id == A && Q >= 0) {
          G.size = I, G.start = B, G.skip = _, _ += 4, I += 4, P.next();
          continue;
        }
        let q = P.pos - Q;
        if (Q < 0 || q < J || P.start < R)
          break;
        let X = P.id >= a ? 4 : 0, K = P.start;
        for (P.next(); P.pos > q; ) {
          if (P.size < 0)
            if (P.size == -3)
              X += 4;
            else
              break e;
          else
            P.id >= a && (X += 4);
          P.next();
        }
        B = K, I += Q, _ += X;
      }
    return (A < 0 || I == C) && (G.size = I, G.start = B, G.skip = _), G.size > 4 ? G : void 0;
  }
  function w(C, A, P) {
    let { id: I, start: B, end: _, size: R } = l;
    if (l.next(), R >= 0 && I < a) {
      let G = P;
      if (R > 4) {
        let J = l.pos - (R - 4);
        for (; l.pos > J; )
          P = w(C, A, P);
      }
      A[--P] = G, A[--P] = _ - C, A[--P] = B - C, A[--P] = I;
    } else
      R == -3 ? h = I : R == -4 && (p = I);
    return P;
  }
  let x = [], S = [];
  for (; l.pos > 0; )
    d(t.start || 0, t.bufferStart || 0, x, S, -1, 0);
  let k = (e = t.length) !== null && e !== void 0 ? e : x.length ? S[0] + x[0].length : 0;
  return new ft(u[t.topID], x.reverse(), S.reverse(), k);
}
const wO = /* @__PURE__ */ new WeakMap();
function rc(t, e) {
  if (!t.isAnonymous || e instanceof Rn || e.type != t)
    return 1;
  let r = wO.get(e);
  if (r == null) {
    r = 1;
    for (let i of e.children) {
      if (i.type != t || !(i instanceof ft)) {
        r = 1;
        break;
      }
      r += rc(t, i);
    }
    wO.set(e, r);
  }
  return r;
}
function Xg(t, e, r, i, n, s, a, l, u) {
  let h = 0;
  for (let O = i; O < n; O++)
    h += rc(t, e[O]);
  let p = Math.ceil(
    h * 1.5 / 8
    /* Balance.BranchFactor */
  ), d = [], m = [];
  function y(O, D, v, w, x) {
    for (let S = v; S < w; ) {
      let k = S, C = D[S], A = rc(t, O[S]);
      for (S++; S < w; S++) {
        let P = rc(t, O[S]);
        if (A + P >= p)
          break;
        A += P;
      }
      if (S == k + 1) {
        if (A > p) {
          let P = O[k];
          y(P.children, P.positions, 0, P.children.length, D[k] + x);
          continue;
        }
        d.push(O[k]);
      } else {
        let P = D[S - 1] + O[S - 1].length - C;
        d.push(Xg(t, O, D, k, S, C, P, null, u));
      }
      m.push(C + x - s);
    }
  }
  return y(e, r, i, n, 0), (l || u)(d, m, a);
}
class kZ {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, r, i) {
    let n = this.map.get(e);
    n || this.map.set(e, n = /* @__PURE__ */ new Map()), n.set(r, i);
  }
  getBuffer(e, r) {
    let i = this.map.get(e);
    return i && i.get(r);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, r) {
    e instanceof vi ? this.setBuffer(e.context.buffer, e.index, r) : e instanceof nr && this.map.set(e.tree, r);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof vi ? this.getBuffer(e.context.buffer, e.index) : e instanceof nr ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, r) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, r) : this.map.set(e.tree, r);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class ps {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, r, i, n, s = !1, a = !1) {
    this.from = e, this.to = r, this.tree = i, this.offset = n, this.open = (s ? 1 : 0) | (a ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, r = [], i = !1) {
    let n = [new ps(0, e.length, e, 0, !1, i)];
    for (let s of r)
      s.to > e.length && n.push(s);
    return n;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, r, i = 128) {
    if (!r.length)
      return e;
    let n = [], s = 1, a = e.length ? e[0] : null;
    for (let l = 0, u = 0, h = 0; ; l++) {
      let p = l < r.length ? r[l] : null, d = p ? p.fromA : 1e9;
      if (d - u >= i)
        for (; a && a.from < d; ) {
          let m = a;
          if (u >= m.from || d <= m.to || h) {
            let y = Math.max(m.from, u) - h, O = Math.min(m.to, d) - h;
            m = y >= O ? null : new ps(y, O, m.tree, m.offset + h, l > 0, !!p);
          }
          if (m && n.push(m), a.to > d)
            break;
          a = s < e.length ? e[s++] : null;
        }
      if (!p)
        break;
      u = p.toA, h = p.toA - p.toB;
    }
    return n;
  }
}
class lC {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, r, i) {
    return typeof e == "string" && (e = new TZ(e)), i = i ? i.length ? i.map((n) => new Up(n.from, n.to)) : [new Up(0, 0)] : [new Up(0, e.length)], this.createParse(e, r || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, r, i) {
    let n = this.startParse(e, r, i);
    for (; ; ) {
      let s = n.advance();
      if (s)
        return s;
    }
  }
}
class TZ {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, r) {
    return this.string.slice(e, r);
  }
}
new Pe({ perNode: !0 });
let PZ = 0;
class Oi {
  /**
  @internal
  */
  constructor(e, r, i) {
    this.set = e, this.base = r, this.modified = i, this.id = PZ++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let r = new Oi([], null, []);
    if (r.set.push(r), e)
      for (let i of e.set)
        r.set.push(i);
    return r;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new Ec();
    return (r) => r.modified.indexOf(e) > -1 ? r : Ec.get(r.base || r, r.modified.concat(e).sort((i, n) => i.id - n.id));
  }
}
let FZ = 0;
class Ec {
  constructor() {
    this.instances = [], this.id = FZ++;
  }
  static get(e, r) {
    if (!r.length)
      return e;
    let i = r[0].instances.find((l) => l.base == e && $Z(r, l.modified));
    if (i)
      return i;
    let n = [], s = new Oi(n, e, r);
    for (let l of r)
      l.instances.push(s);
    let a = BZ(r);
    for (let l of e.set)
      if (!l.modified.length)
        for (let u of a)
          n.push(Ec.get(l, u));
    return s;
  }
}
function $Z(t, e) {
  return t.length == e.length && t.every((r, i) => r == e[i]);
}
function BZ(t) {
  let e = [[]];
  for (let r = 0; r < t.length; r++)
    for (let i = 0, n = e.length; i < n; i++)
      e.push(e[i].concat(t[r]));
  return e.sort((r, i) => i.length - r.length);
}
function uC(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let i = t[r];
    Array.isArray(i) || (i = [i]);
    for (let n of r.split(" "))
      if (n) {
        let s = [], a = 2, l = n;
        for (let d = 0; ; ) {
          if (l == "..." && d > 0 && d + 3 == n.length) {
            a = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!m)
            throw new RangeError("Invalid path: " + n);
          if (s.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]), d += m[0].length, d == n.length)
            break;
          let y = n[d++];
          if (d == n.length && y == "!") {
            a = 0;
            break;
          }
          if (y != "/")
            throw new RangeError("Invalid path: " + n);
          l = n.slice(d);
        }
        let u = s.length - 1, h = s[u];
        if (!h)
          throw new RangeError("Invalid path: " + n);
        let p = new Ac(i, a, u > 0 ? s.slice(0, u) : null);
        e[h] = p.sort(e[h]);
      }
  }
  return cC.add(e);
}
const cC = new Pe();
class Ac {
  constructor(e, r, i, n) {
    this.tags = e, this.mode = r, this.context = i, this.next = n;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Ac.empty = new Ac([], 2, null);
function hC(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let s of t)
    if (!Array.isArray(s.tag))
      r[s.tag.id] = s.class;
    else
      for (let a of s.tag)
        r[a.id] = s.class;
  let { scope: i, all: n = null } = e || {};
  return {
    style: (s) => {
      let a = n;
      for (let l of s)
        for (let u of l.set) {
          let h = r[u.id];
          if (h) {
            a = a ? a + " " + h : h;
            break;
          }
        }
      return a;
    },
    scope: i
  };
}
function IZ(t, e) {
  let r = null;
  for (let i of t) {
    let n = i.style(e);
    n && (r = r ? r + " " + n : n);
  }
  return r;
}
function NZ(t, e, r, i = 0, n = t.length) {
  let s = new _Z(i, Array.isArray(e) ? e : [e], r);
  s.highlightRange(t.cursor(), i, n, "", s.highlighters), s.flush(n);
}
class _Z {
  constructor(e, r, i) {
    this.at = e, this.highlighters = r, this.span = i, this.class = "";
  }
  startSpan(e, r) {
    r != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = r);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, r, i, n, s) {
    let { type: a, from: l, to: u } = e;
    if (l >= i || u <= r)
      return;
    a.isTop && (s = this.highlighters.filter((y) => !y.scope || y.scope(a)));
    let h = n, p = MZ(e) || Ac.empty, d = IZ(s, p.tags);
    if (d && (h && (h += " "), h += d, p.mode == 1 && (n += (n ? " " : "") + d)), this.startSpan(Math.max(r, l), h), p.opaque)
      return;
    let m = e.tree && e.tree.prop(Pe.mounted);
    if (m && m.overlay) {
      let y = e.node.enter(m.overlay[0].from + l, 1), O = this.highlighters.filter((v) => !v.scope || v.scope(m.tree.type)), D = e.firstChild();
      for (let v = 0, w = l; ; v++) {
        let x = v < m.overlay.length ? m.overlay[v] : null, S = x ? x.from + l : u, k = Math.max(r, w), C = Math.min(i, S);
        if (k < C && D)
          for (; e.from < C && (this.highlightRange(e, k, C, n, s), this.startSpan(Math.min(C, e.to), h), !(e.to >= S || !e.nextSibling())); )
            ;
        if (!x || S > i)
          break;
        w = x.to + l, w > r && (this.highlightRange(y.cursor(), Math.max(r, x.from + l), Math.min(i, w), "", O), this.startSpan(Math.min(i, w), h));
      }
      D && e.parent();
    } else if (e.firstChild()) {
      m && (n = "");
      do
        if (!(e.to <= r)) {
          if (e.from >= i)
            break;
          this.highlightRange(e, r, i, n, s), this.startSpan(Math.min(i, e.to), h);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function MZ(t) {
  let e = t.type.prop(cC);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const ae = Oi.define, Pu = ae(), xn = ae(), SO = ae(xn), CO = ae(xn), Dn = ae(), Fu = ae(Dn), Yp = ae(Dn), yi = ae(), Kn = ae(yi), di = ae(), fi = ae(), Nf = ae(), mo = ae(Nf), $u = ae(), M = {
  /**
  A comment.
  */
  comment: Pu,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: ae(Pu),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: ae(Pu),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: ae(Pu),
  /**
  Any kind of identifier.
  */
  name: xn,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: ae(xn),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: SO,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: ae(SO),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: CO,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: ae(CO),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: ae(xn),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: ae(xn),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: ae(xn),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: ae(xn),
  /**
  A literal value.
  */
  literal: Dn,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Fu,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: ae(Fu),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: ae(Fu),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: ae(Fu),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Yp,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: ae(Yp),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: ae(Yp),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: ae(Dn),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: ae(Dn),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: ae(Dn),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: ae(Dn),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: ae(Dn),
  /**
  A language keyword.
  */
  keyword: di,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: ae(di),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: ae(di),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: ae(di),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: ae(di),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: ae(di),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: ae(di),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: ae(di),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: ae(di),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: ae(di),
  /**
  An operator.
  */
  operator: fi,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: ae(fi),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: ae(fi),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: ae(fi),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: ae(fi),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: ae(fi),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: ae(fi),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: ae(fi),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: ae(fi),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: ae(fi),
  /**
  Program or markup punctuation.
  */
  punctuation: Nf,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: ae(Nf),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: mo,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: ae(mo),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: ae(mo),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: ae(mo),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: ae(mo),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: yi,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Kn,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: ae(Kn),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: ae(Kn),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: ae(Kn),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: ae(Kn),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: ae(Kn),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: ae(Kn),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: ae(yi),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: ae(yi),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: ae(yi),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: ae(yi),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: ae(yi),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: ae(yi),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: ae(yi),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: ae(yi),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: ae(),
  /**
  Deleted text.
  */
  deleted: ae(),
  /**
  Changed text.
  */
  changed: ae(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: ae(),
  /**
  Metadata or meta-instruction.
  */
  meta: $u,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: ae($u),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: ae($u),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: ae($u),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Oi.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Oi.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Oi.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Oi.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Oi.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Oi.defineModifier()
};
hC([
  { tag: M.link, class: "tok-link" },
  { tag: M.heading, class: "tok-heading" },
  { tag: M.emphasis, class: "tok-emphasis" },
  { tag: M.strong, class: "tok-strong" },
  { tag: M.keyword, class: "tok-keyword" },
  { tag: M.atom, class: "tok-atom" },
  { tag: M.bool, class: "tok-bool" },
  { tag: M.url, class: "tok-url" },
  { tag: M.labelName, class: "tok-labelName" },
  { tag: M.inserted, class: "tok-inserted" },
  { tag: M.deleted, class: "tok-deleted" },
  { tag: M.literal, class: "tok-literal" },
  { tag: M.string, class: "tok-string" },
  { tag: M.number, class: "tok-number" },
  { tag: [M.regexp, M.escape, M.special(M.string)], class: "tok-string2" },
  { tag: M.variableName, class: "tok-variableName" },
  { tag: M.local(M.variableName), class: "tok-variableName tok-local" },
  { tag: M.definition(M.variableName), class: "tok-variableName tok-definition" },
  { tag: M.special(M.variableName), class: "tok-variableName2" },
  { tag: M.definition(M.propertyName), class: "tok-propertyName tok-definition" },
  { tag: M.typeName, class: "tok-typeName" },
  { tag: M.namespace, class: "tok-namespace" },
  { tag: M.className, class: "tok-className" },
  { tag: M.macroName, class: "tok-macroName" },
  { tag: M.propertyName, class: "tok-propertyName" },
  { tag: M.operator, class: "tok-operator" },
  { tag: M.comment, class: "tok-comment" },
  { tag: M.meta, class: "tok-meta" },
  { tag: M.invalid, class: "tok-invalid" },
  { tag: M.punctuation, class: "tok-punctuation" }
]);
var zp;
const ca = /* @__PURE__ */ new Pe();
function pC(t) {
  return fe.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
const Vg = /* @__PURE__ */ new Pe();
class ri {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, r, i = [], n = "") {
    this.data = e, this.name = n, Be.prototype.hasOwnProperty("tree") || Object.defineProperty(Be.prototype, "tree", { get() {
      return xt(this);
    } }), this.parser = r, this.extension = [
      Zn.of(this),
      Be.languageData.of((s, a, l) => {
        let u = EO(s, a, l), h = u.type.prop(ca);
        if (!h)
          return [];
        let p = s.facet(h), d = u.type.prop(Vg);
        if (d) {
          let m = u.resolve(a - u.from, l);
          for (let y of d)
            if (y.test(m, s)) {
              let O = s.facet(y.facet);
              return y.type == "replace" ? O : O.concat(p);
            }
        }
        return p;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, r, i = -1) {
    return EO(e, r, i).type.prop(ca) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let r = e.facet(Zn);
    if ((r == null ? void 0 : r.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!r || !r.allowsNesting)
      return [];
    let i = [], n = (s, a) => {
      if (s.prop(ca) == this.data) {
        i.push({ from: a, to: a + s.length });
        return;
      }
      let l = s.prop(Pe.mounted);
      if (l) {
        if (l.tree.prop(ca) == this.data) {
          if (l.overlay)
            for (let u of l.overlay)
              i.push({ from: u.from + a, to: u.to + a });
          else
            i.push({ from: a, to: a + s.length });
          return;
        } else if (l.overlay) {
          let u = i.length;
          if (n(l.tree, l.overlay[0].from + a), i.length > u)
            return;
        }
      }
      for (let u = 0; u < s.children.length; u++) {
        let h = s.children[u];
        h instanceof ft && n(h, s.positions[u] + a);
      }
    };
    return n(xt(e), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
ri.setState = /* @__PURE__ */ we.define();
function EO(t, e, r) {
  let i = t.facet(Zn), n = xt(t).topNode;
  if (!i || i.allowsNesting)
    for (let s = n; s; s = s.enter(e, r, Ot.ExcludeBuffers))
      s.type.isTop && (n = s);
  return n;
}
class kc extends ri {
  constructor(e, r, i) {
    super(e, r, [], i), this.parser = r;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let r = pC(e.languageData);
    return new kc(r, e.parser.configure({
      props: [ca.add((i) => i.isTop ? r : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, r) {
    return new kc(this.data, this.parser.configure(e), r || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function xt(t) {
  let e = t.field(ri.state, !1);
  return e ? e.tree : ft.empty;
}
class LZ {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, r) {
    let i = this.cursorPos - this.string.length;
    return e < i || r >= this.cursorPos ? this.doc.sliceString(e, r) : this.string.slice(e - i, r - i);
  }
}
let go = null;
class Tc {
  constructor(e, r, i = [], n, s, a, l, u) {
    this.parser = e, this.state = r, this.fragments = i, this.tree = n, this.treeLen = s, this.viewport = a, this.skipped = l, this.scheduleOn = u, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, r, i) {
    return new Tc(e, r, [], ft.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new LZ(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, r) {
    return r != null && r >= this.state.doc.length && (r = void 0), this.tree != ft.empty && this.isDone(r ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof e == "number") {
        let n = Date.now() + e;
        e = () => Date.now() > n;
      }
      for (this.parse || (this.parse = this.startParse()), r != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > r) && r < this.state.doc.length && this.parse.stopAt(r); ; ) {
        let n = this.parse.advance();
        if (n)
          if (this.fragments = this.withoutTempSkipped(ps.addTree(n, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = n, this.parse = null, this.treeLen < (r ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, r;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(r = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = r, this.fragments = this.withoutTempSkipped(ps.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let r = go;
    go = this;
    try {
      return e();
    } finally {
      go = r;
    }
  }
  withoutTempSkipped(e) {
    for (let r; r = this.tempSkipped.pop(); )
      e = AO(e, r.from, r.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, r) {
    let { fragments: i, tree: n, treeLen: s, viewport: a, skipped: l } = this;
    if (this.takeTree(), !e.empty) {
      let u = [];
      if (e.iterChangedRanges((h, p, d, m) => u.push({ fromA: h, toA: p, fromB: d, toB: m })), i = ps.applyChanges(i, u), n = ft.empty, s = 0, a = { from: e.mapPos(a.from, -1), to: e.mapPos(a.to, 1) }, this.skipped.length) {
        l = [];
        for (let h of this.skipped) {
          let p = e.mapPos(h.from, 1), d = e.mapPos(h.to, -1);
          p < d && l.push({ from: p, to: d });
        }
      }
    }
    return new Tc(this.parser, r, i, n, s, a, l, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let r = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: n, to: s } = this.skipped[i];
      n < e.to && s > e.from && (this.fragments = AO(this.fragments, n, s), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= r ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, r) {
    this.skipped.push({ from: e, to: r });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends lC {
      createParse(r, i, n) {
        let s = n[0].from, a = n[n.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let u = go;
            if (u) {
              for (let h of n)
                u.tempSkipped.push(h);
              e && (u.scheduleOn = u.scheduleOn ? Promise.all([u.scheduleOn, e]) : e);
            }
            return this.parsedPos = a, new ft(or.none, [], [], a - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let r = this.fragments;
    return this.treeLen >= e && r.length && r[0].from == 0 && r[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return go;
  }
}
function AO(t, e, r) {
  return ps.applyChanges(t, [{ fromA: e, toA: r, fromB: e, toB: r }]);
}
class Pa {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let r = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), r.viewport.to);
    return r.work(20, i) || r.takeTree(), new Pa(r);
  }
  static init(e) {
    let r = Math.min(3e3, e.doc.length), i = Tc.create(e.facet(Zn).parser, e, { from: 0, to: r });
    return i.work(20, r) || i.takeTree(), new Pa(i);
  }
}
ri.state = /* @__PURE__ */ vt.define({
  create: Pa.init,
  update(t, e) {
    for (let r of e.effects)
      if (r.is(ri.setState))
        return r.value;
    return e.startState.facet(Zn) != e.state.facet(Zn) ? Pa.init(e.state) : t.apply(e);
  }
});
let dC = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (dC = (t) => {
  let e = -1, r = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(r) : cancelIdleCallback(e);
});
const Gp = typeof navigator < "u" && (!((zp = navigator.scheduling) === null || zp === void 0) && zp.isInputPending) ? () => navigator.scheduling.isInputPending() : null, QZ = /* @__PURE__ */ ct.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let r = this.view.state.field(ri.state).context;
    (r.updateViewport(e.view.viewport) || this.view.viewport.to > r.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(r);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, r = e.field(ri.state);
    (r.tree != r.context.tree || !r.context.isDone(e.doc.length)) && (this.working = dC(this.work));
  }
  work(e) {
    this.working = null;
    let r = Date.now();
    if (this.chunkEnd < r && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = r + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: n } } = this.view, s = i.field(ri.state);
    if (s.tree == s.context.tree && s.context.isDone(
      n + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let a = Date.now() + Math.min(this.chunkBudget, 100, e && !Gp ? Math.max(25, e.timeRemaining() - 5) : 1e9), l = s.context.treeLen < n && i.doc.length > n + 1e3, u = s.context.work(() => Gp && Gp() || Date.now() > a, n + (l ? 0 : 1e5));
    this.chunkBudget -= Date.now() - r, (u || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: ri.setState.of(new Pa(s.context)) })), this.chunkBudget > 0 && !(u && !l) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((r) => Nr(this.view.state, r)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Zn = /* @__PURE__ */ fe.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    ri.state,
    QZ,
    le.contentAttributes.compute([t], (e) => {
      let r = e.facet(t);
      return r && r.name ? { "data-language": r.name } : {};
    })
  ]
});
class jZ {
  /**
  Create a language support object.
  */
  constructor(e, r = []) {
    this.language = e, this.support = r, this.extension = [e, r];
  }
}
const RZ = /* @__PURE__ */ fe.define(), Ll = /* @__PURE__ */ fe.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((r) => r != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function Pc(t) {
  let e = t.facet(Ll);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function cl(t, e) {
  let r = "", i = t.tabSize, n = t.facet(Ll)[0];
  if (n == "	") {
    for (; e >= i; )
      r += "	", e -= i;
    n = " ";
  }
  for (let s = 0; s < e; s++)
    r += n;
  return r;
}
function Ug(t, e) {
  t instanceof Be && (t = new jh(t));
  for (let i of t.state.facet(RZ)) {
    let n = i(t, e);
    if (n !== void 0)
      return n;
  }
  let r = xt(t.state);
  return r.length >= e ? ZZ(t, r, e) : null;
}
class jh {
  /**
  Create an indent context.
  */
  constructor(e, r = {}) {
    this.state = e, this.options = r, this.unit = Pc(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, r = 1) {
    let i = this.state.doc.lineAt(e), { simulateBreak: n, simulateDoubleBreak: s } = this.options;
    return n != null && n >= i.from && n <= i.to ? s && n == e ? { text: "", from: e } : (r < 0 ? n < e : n <= e) ? { text: i.text.slice(n - i.from), from: n } : { text: i.text.slice(0, n - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, r = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: i, from: n } = this.lineAt(e, r);
    return i.slice(e - n, Math.min(i.length, e + 100 - n));
  }
  /**
  Find the column for the given position.
  */
  column(e, r = 1) {
    let { text: i, from: n } = this.lineAt(e, r), s = this.countColumn(i, e - n), a = this.options.overrideIndentation ? this.options.overrideIndentation(n) : -1;
    return a > -1 && (s += a - this.countColumn(i, i.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, r = e.length) {
    return Va(e, this.state.tabSize, r);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, r = 1) {
    let { text: i, from: n } = this.lineAt(e, r), s = this.options.overrideIndentation;
    if (s) {
      let a = s(n);
      if (a > -1)
        return a;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const fC = /* @__PURE__ */ new Pe();
function ZZ(t, e, r) {
  let i = e.resolveStack(r), n = i.node.enterUnfinishedNodesBefore(r);
  if (n != i.node) {
    let s = [];
    for (let a = n; a != i.node; a = a.parent)
      s.push(a);
    for (let a = s.length - 1; a >= 0; a--)
      i = { node: s[a], next: i };
  }
  return mC(i, t, r);
}
function mC(t, e, r) {
  for (let i = t; i; i = i.next) {
    let n = qZ(i.node);
    if (n)
      return n(Yg.create(e, r, i));
  }
  return 0;
}
function WZ(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function qZ(t) {
  let e = t.type.prop(fC);
  if (e)
    return e;
  let r = t.firstChild, i;
  if (r && (i = r.type.prop(Pe.closedBy))) {
    let n = t.lastChild, s = n && i.indexOf(n.name) > -1;
    return (a) => gC(a, !0, 1, void 0, s && !WZ(a) ? n.from : void 0);
  }
  return t.parent == null ? XZ : null;
}
function XZ() {
  return 0;
}
class Yg extends jh {
  constructor(e, r, i) {
    super(e.state, e.options), this.base = e, this.pos = r, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, r, i) {
    return new Yg(e, r, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let r = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let i = e.resolve(r.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (VZ(i, e))
        break;
      r = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(r.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return mC(this.context.next, this.base, this.pos);
  }
}
function VZ(t, e) {
  for (let r = e; r; r = r.parent)
    if (t == r)
      return !0;
  return !1;
}
function UZ(t) {
  let e = t.node, r = e.childAfter(e.from), i = e.lastChild;
  if (!r)
    return null;
  let n = t.options.simulateBreak, s = t.state.doc.lineAt(r.from), a = n == null || n <= s.from ? s.to : Math.min(s.to, n);
  for (let l = r.to; ; ) {
    let u = e.childAfter(l);
    if (!u || u == i)
      return null;
    if (!u.type.isSkipped)
      return u.from < a ? r : null;
    l = u.to;
  }
}
function YZ({ closing: t, align: e = !0, units: r = 1 }) {
  return (i) => gC(i, e, r, t);
}
function gC(t, e, r, i, n) {
  let s = t.textAfter, a = s.match(/^\s*/)[0].length, l = i && s.slice(a, a + i.length) == i || n == t.pos + a, u = e ? UZ(t) : null;
  return u ? l ? t.column(u.from) : t.column(u.to) : t.baseIndent + (l ? 0 : t.unit * r);
}
const zZ = (t) => t.baseIndent;
function Hp({ except: t, units: e = 1 } = {}) {
  return (r) => {
    let i = t && t.test(r.textAfter);
    return r.baseIndent + (i ? 0 : e * r.unit);
  };
}
const GZ = 200;
function HZ() {
  return Be.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let r = t.newDoc, { head: i } = t.newSelection.main, n = r.lineAt(i);
    if (i > n.from + GZ)
      return t;
    let s = r.sliceString(n.from, i);
    if (!e.some((h) => h.test(s)))
      return t;
    let { state: a } = t, l = -1, u = [];
    for (let { head: h } of a.selection.ranges) {
      let p = a.doc.lineAt(h);
      if (p.from == l)
        continue;
      l = p.from;
      let d = Ug(a, p.from);
      if (d == null)
        continue;
      let m = /^\s*/.exec(p.text)[0], y = cl(a, d);
      m != y && u.push({ from: p.from, to: p.from + m.length, insert: y });
    }
    return u.length ? [t, { changes: u, sequential: !0 }] : t;
  });
}
const JZ = /* @__PURE__ */ fe.define(), yC = /* @__PURE__ */ new Pe();
function KZ(t) {
  let e = t.firstChild, r = t.lastChild;
  return e && e.to < r.from ? { from: e.to, to: r.type.isError ? t.to : r.from } : null;
}
function eW(t, e, r) {
  let i = xt(t);
  if (i.length < r)
    return null;
  let n = i.resolveStack(r, 1), s = null;
  for (let a = n; a; a = a.next) {
    let l = a.node;
    if (l.to <= r || l.from > r)
      continue;
    if (s && l.from < e)
      break;
    let u = l.type.prop(yC);
    if (u && (l.to < i.length - 50 || i.length == t.doc.length || !tW(l))) {
      let h = u(l, t);
      h && h.from <= r && h.from >= e && h.to > r && (s = h);
    }
  }
  return s;
}
function tW(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function Fc(t, e, r) {
  for (let i of t.facet(JZ)) {
    let n = i(t, e, r);
    if (n)
      return n;
  }
  return eW(t, e, r);
}
function OC(t, e) {
  let r = e.mapPos(t.from, 1), i = e.mapPos(t.to, -1);
  return r >= i ? void 0 : { from: r, to: i };
}
const Rh = /* @__PURE__ */ we.define({ map: OC }), Ql = /* @__PURE__ */ we.define({ map: OC });
function xC(t) {
  let e = [];
  for (let { head: r } of t.state.selection.ranges)
    e.some((i) => i.from <= r && i.to >= r) || e.push(t.lineBlockAt(r));
  return e;
}
const Es = /* @__PURE__ */ vt.define({
  create() {
    return Oe.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let r of e.effects)
      if (r.is(Rh) && !rW(t, r.value.from, r.value.to)) {
        let { preparePlaceholder: i } = e.state.facet(zg), n = i ? Oe.replace({ widget: new uW(i(e.state, r.value)) }) : kO;
        t = t.update({ add: [n.range(r.value.from, r.value.to)] });
      } else
        r.is(Ql) && (t = t.update({
          filter: (i, n) => r.value.from != i || r.value.to != n,
          filterFrom: r.value.from,
          filterTo: r.value.to
        }));
    if (e.selection) {
      let r = !1, { head: i } = e.selection.main;
      t.between(i, i, (n, s) => {
        n < i && s > i && (r = !0);
      }), r && (t = t.update({
        filterFrom: i,
        filterTo: i,
        filter: (n, s) => s <= i || n >= i
      }));
    }
    return t;
  },
  provide: (t) => le.decorations.from(t),
  toJSON(t, e) {
    let r = [];
    return t.between(0, e.doc.length, (i, n) => {
      r.push(i, n);
    }), r;
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let r = 0; r < t.length; ) {
      let i = t[r++], n = t[r++];
      if (typeof i != "number" || typeof n != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(kO.range(i, n));
    }
    return Oe.set(e, !0);
  }
});
function $c(t, e, r) {
  var i;
  let n = null;
  return (i = t.field(Es, !1)) === null || i === void 0 || i.between(e, r, (s, a) => {
    (!n || n.from > s) && (n = { from: s, to: a });
  }), n;
}
function rW(t, e, r) {
  let i = !1;
  return t.between(e, e, (n, s) => {
    n == e && s == r && (i = !0);
  }), i;
}
function DC(t, e) {
  return t.field(Es, !1) ? e : e.concat(we.appendConfig.of(vC()));
}
const iW = (t) => {
  for (let e of xC(t)) {
    let r = Fc(t.state, e.from, e.to);
    if (r)
      return t.dispatch({ effects: DC(t.state, [Rh.of(r), bC(t, r)]) }), !0;
  }
  return !1;
}, nW = (t) => {
  if (!t.state.field(Es, !1))
    return !1;
  let e = [];
  for (let r of xC(t)) {
    let i = $c(t.state, r.from, r.to);
    i && e.push(Ql.of(i), bC(t, i, !1));
  }
  return e.length && t.dispatch({ effects: e }), e.length > 0;
};
function bC(t, e, r = !0) {
  let i = t.state.doc.lineAt(e.from).number, n = t.state.doc.lineAt(e.to).number;
  return le.announce.of(`${t.state.phrase(r ? "Folded lines" : "Unfolded lines")} ${i} ${t.state.phrase("to")} ${n}.`);
}
const sW = (t) => {
  let { state: e } = t, r = [];
  for (let i = 0; i < e.doc.length; ) {
    let n = t.lineBlockAt(i), s = Fc(e, n.from, n.to);
    s && r.push(Rh.of(s)), i = (s ? t.lineBlockAt(s.to) : n).to + 1;
  }
  return r.length && t.dispatch({ effects: DC(t.state, r) }), !!r.length;
}, aW = (t) => {
  let e = t.state.field(Es, !1);
  if (!e || !e.size)
    return !1;
  let r = [];
  return e.between(0, t.state.doc.length, (i, n) => {
    r.push(Ql.of({ from: i, to: n }));
  }), t.dispatch({ effects: r }), !0;
}, oW = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: iW },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: nW },
  { key: "Ctrl-Alt-[", run: sW },
  { key: "Ctrl-Alt-]", run: aW }
], lW = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, zg = /* @__PURE__ */ fe.define({
  combine(t) {
    return _i(t, lW);
  }
});
function vC(t) {
  let e = [Es, pW];
  return t && e.push(zg.of(t)), e;
}
function wC(t, e) {
  let { state: r } = t, i = r.facet(zg), n = (a) => {
    let l = t.lineBlockAt(t.posAtDOM(a.target)), u = $c(t.state, l.from, l.to);
    u && t.dispatch({ effects: Ql.of(u) }), a.preventDefault();
  };
  if (i.placeholderDOM)
    return i.placeholderDOM(t, n, e);
  let s = document.createElement("span");
  return s.textContent = i.placeholderText, s.setAttribute("aria-label", r.phrase("folded code")), s.title = r.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = n, s;
}
const kO = /* @__PURE__ */ Oe.replace({ widget: /* @__PURE__ */ new class extends Mi {
  toDOM(t) {
    return wC(t, null);
  }
}() });
class uW extends Mi {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return wC(e, this.value);
  }
}
const cW = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Jp extends Ji {
  constructor(e, r) {
    super(), this.config = e, this.open = r;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let r = document.createElement("span");
    return r.textContent = this.open ? this.config.openText : this.config.closedText, r.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), r;
  }
}
function hW(t = {}) {
  let e = Object.assign(Object.assign({}, cW), t), r = new Jp(e, !0), i = new Jp(e, !1), n = ct.fromClass(class {
    constructor(a) {
      this.from = a.viewport.from, this.markers = this.buildMarkers(a);
    }
    update(a) {
      (a.docChanged || a.viewportChanged || a.startState.facet(Zn) != a.state.facet(Zn) || a.startState.field(Es, !1) != a.state.field(Es, !1) || xt(a.startState) != xt(a.state) || e.foldingChanged(a)) && (this.markers = this.buildMarkers(a.view));
    }
    buildMarkers(a) {
      let l = new Mn();
      for (let u of a.viewportLineBlocks) {
        let h = $c(a.state, u.from, u.to) ? i : Fc(a.state, u.from, u.to) ? r : null;
        h && l.add(u.from, u.from, h);
      }
      return l.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    n,
    pZ({
      class: "cm-foldGutter",
      markers(a) {
        var l;
        return ((l = a.plugin(n)) === null || l === void 0 ? void 0 : l.markers) || Me.empty;
      },
      initialSpacer() {
        return new Jp(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, s), { click: (a, l, u) => {
        if (s.click && s.click(a, l, u))
          return !0;
        let h = $c(a.state, l.from, l.to);
        if (h)
          return a.dispatch({ effects: Ql.of(h) }), !0;
        let p = Fc(a.state, l.from, l.to);
        return p ? (a.dispatch({ effects: Rh.of(p) }), !0) : !1;
      } })
    }),
    vC()
  ];
}
const pW = /* @__PURE__ */ le.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class jl {
  constructor(e, r) {
    this.specs = e;
    let i;
    function n(l) {
      let u = Ln.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + u] = l, u;
    }
    const s = typeof r.all == "string" ? r.all : r.all ? n(r.all) : void 0, a = r.scope;
    this.scope = a instanceof ri ? (l) => l.prop(ca) == a.data : a ? (l) => l == a : void 0, this.style = hC(e.map((l) => ({
      tag: l.tag,
      class: l.class || n(Object.assign({}, l, { tag: null }))
    })), {
      all: s
    }).style, this.module = i ? new Ln(i) : null, this.themeType = r.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, r) {
    return new jl(e, r || {});
  }
}
const _f = /* @__PURE__ */ fe.define(), SC = /* @__PURE__ */ fe.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function Kp(t) {
  let e = t.facet(_f);
  return e.length ? e : t.facet(SC);
}
function CC(t, e) {
  let r = [fW], i;
  return t instanceof jl && (t.module && r.push(le.styleModule.of(t.module)), i = t.themeType), e != null && e.fallback ? r.push(SC.of(t)) : i ? r.push(_f.computeN([le.darkTheme], (n) => n.facet(le.darkTheme) == (i == "dark") ? [t] : [])) : r.push(_f.of(t)), r;
}
class dW {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = xt(e.state), this.decorations = this.buildDeco(e, Kp(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let r = xt(e.state), i = Kp(e.state), n = i != Kp(e.startState), { viewport: s } = e.view, a = e.changes.mapPos(this.decoratedTo, 1);
    r.length < s.to && !n && r.type == this.tree.type && a >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = a) : (r != this.tree || e.viewportChanged || n) && (this.tree = r, this.decorations = this.buildDeco(e.view, i), this.decoratedTo = s.to);
  }
  buildDeco(e, r) {
    if (!r || !this.tree.length)
      return Oe.none;
    let i = new Mn();
    for (let { from: n, to: s } of e.visibleRanges)
      NZ(this.tree, r, (a, l, u) => {
        i.add(a, l, this.markCache[u] || (this.markCache[u] = Oe.mark({ class: u })));
      }, n, s);
    return i.finish();
  }
}
const fW = /* @__PURE__ */ js.high(/* @__PURE__ */ ct.fromClass(dW, {
  decorations: (t) => t.decorations
})), mW = /* @__PURE__ */ jl.define([
  {
    tag: M.meta,
    color: "#404740"
  },
  {
    tag: M.link,
    textDecoration: "underline"
  },
  {
    tag: M.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: M.emphasis,
    fontStyle: "italic"
  },
  {
    tag: M.strong,
    fontWeight: "bold"
  },
  {
    tag: M.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: M.keyword,
    color: "#708"
  },
  {
    tag: [M.atom, M.bool, M.url, M.contentSeparator, M.labelName],
    color: "#219"
  },
  {
    tag: [M.literal, M.inserted],
    color: "#164"
  },
  {
    tag: [M.string, M.deleted],
    color: "#a11"
  },
  {
    tag: [M.regexp, M.escape, /* @__PURE__ */ M.special(M.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ M.definition(M.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ M.local(M.variableName),
    color: "#30a"
  },
  {
    tag: [M.typeName, M.namespace],
    color: "#085"
  },
  {
    tag: M.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ M.special(M.variableName), M.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ M.definition(M.propertyName),
    color: "#00c"
  },
  {
    tag: M.comment,
    color: "#940"
  },
  {
    tag: M.invalid,
    color: "#f00"
  }
]), gW = /* @__PURE__ */ le.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), EC = 1e4, AC = "()[]{}", kC = /* @__PURE__ */ fe.define({
  combine(t) {
    return _i(t, {
      afterCursor: !0,
      brackets: AC,
      maxScanDistance: EC,
      renderMatch: xW
    });
  }
}), yW = /* @__PURE__ */ Oe.mark({ class: "cm-matchingBracket" }), OW = /* @__PURE__ */ Oe.mark({ class: "cm-nonmatchingBracket" });
function xW(t) {
  let e = [], r = t.matched ? yW : OW;
  return e.push(r.range(t.start.from, t.start.to)), t.end && e.push(r.range(t.end.from, t.end.to)), e;
}
const DW = /* @__PURE__ */ vt.define({
  create() {
    return Oe.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let r = [], i = e.state.facet(kC);
    for (let n of e.state.selection.ranges) {
      if (!n.empty)
        continue;
      let s = wi(e.state, n.head, -1, i) || n.head > 0 && wi(e.state, n.head - 1, 1, i) || i.afterCursor && (wi(e.state, n.head, 1, i) || n.head < e.state.doc.length && wi(e.state, n.head + 1, -1, i));
      s && (r = r.concat(i.renderMatch(s, e.state)));
    }
    return Oe.set(r, !0);
  },
  provide: (t) => le.decorations.from(t)
}), bW = [
  DW,
  gW
];
function vW(t = {}) {
  return [kC.of(t), bW];
}
const wW = /* @__PURE__ */ new Pe();
function Mf(t, e, r) {
  let i = t.prop(e < 0 ? Pe.openedBy : Pe.closedBy);
  if (i)
    return i;
  if (t.name.length == 1) {
    let n = r.indexOf(t.name);
    if (n > -1 && n % 2 == (e < 0 ? 1 : 0))
      return [r[n + e]];
  }
  return null;
}
function Lf(t) {
  let e = t.type.prop(wW);
  return e ? e(t.node) : t;
}
function wi(t, e, r, i = {}) {
  let n = i.maxScanDistance || EC, s = i.brackets || AC, a = xt(t), l = a.resolveInner(e, r);
  for (let u = l; u; u = u.parent) {
    let h = Mf(u.type, r, s);
    if (h && u.from < u.to) {
      let p = Lf(u);
      if (p && (r > 0 ? e >= p.from && e < p.to : e > p.from && e <= p.to))
        return SW(t, e, r, u, p, h, s);
    }
  }
  return CW(t, e, r, a, l.type, n, s);
}
function SW(t, e, r, i, n, s, a) {
  let l = i.parent, u = { from: n.from, to: n.to }, h = 0, p = l == null ? void 0 : l.cursor();
  if (p && (r < 0 ? p.childBefore(i.from) : p.childAfter(i.to)))
    do
      if (r < 0 ? p.to <= i.from : p.from >= i.to) {
        if (h == 0 && s.indexOf(p.type.name) > -1 && p.from < p.to) {
          let d = Lf(p);
          return { start: u, end: d ? { from: d.from, to: d.to } : void 0, matched: !0 };
        } else if (Mf(p.type, r, a))
          h++;
        else if (Mf(p.type, -r, a)) {
          if (h == 0) {
            let d = Lf(p);
            return {
              start: u,
              end: d && d.from < d.to ? { from: d.from, to: d.to } : void 0,
              matched: !1
            };
          }
          h--;
        }
      }
    while (r < 0 ? p.prevSibling() : p.nextSibling());
  return { start: u, matched: !1 };
}
function CW(t, e, r, i, n, s, a) {
  let l = r < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), u = a.indexOf(l);
  if (u < 0 || u % 2 == 0 != r > 0)
    return null;
  let h = { from: r < 0 ? e - 1 : e, to: r > 0 ? e + 1 : e }, p = t.doc.iterRange(e, r > 0 ? t.doc.length : 0), d = 0;
  for (let m = 0; !p.next().done && m <= s; ) {
    let y = p.value;
    r < 0 && (m += y.length);
    let O = e + m * r;
    for (let D = r > 0 ? 0 : y.length - 1, v = r > 0 ? y.length : -1; D != v; D += r) {
      let w = a.indexOf(y[D]);
      if (!(w < 0 || i.resolveInner(O + D, 1).type != n))
        if (w % 2 == 0 == r > 0)
          d++;
        else {
          if (d == 1)
            return { start: h, end: { from: O + D, to: O + D + 1 }, matched: w >> 1 == u >> 1 };
          d--;
        }
    }
    r > 0 && (m += y.length);
  }
  return p.done ? { start: h, matched: !1 } : null;
}
const EW = /* @__PURE__ */ Object.create(null), TO = [or.none], PO = [], FO = /* @__PURE__ */ Object.create(null), AW = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  AW[t] = /* @__PURE__ */ kW(EW, e);
function ed(t, e) {
  PO.indexOf(t) > -1 || (PO.push(t), console.warn(e));
}
function kW(t, e) {
  let r = [];
  for (let l of e.split(" ")) {
    let u = [];
    for (let h of l.split(".")) {
      let p = t[h] || M[h];
      p ? typeof p == "function" ? u.length ? u = u.map(p) : ed(h, `Modifier ${h} used at start of tag`) : u.length ? ed(h, `Tag ${h} used as modifier`) : u = Array.isArray(p) ? p : [p] : ed(h, `Unknown highlighting tag ${h}`);
    }
    for (let h of u)
      r.push(h);
  }
  if (!r.length)
    return 0;
  let i = e.replace(/ /g, "_"), n = i + " " + r.map((l) => l.id), s = FO[n];
  if (s)
    return s.id;
  let a = FO[n] = or.define({
    id: TO.length,
    name: i,
    props: [uC({ [i]: r })]
  });
  return TO.push(a), a.id;
}
tt.RTL, tt.LTR;
const TW = (t) => {
  let { state: e } = t, r = e.doc.lineAt(e.selection.main.from), i = Hg(t.state, r.from);
  return i.line ? PW(t) : i.block ? $W(t) : !1;
};
function Gg(t, e) {
  return ({ state: r, dispatch: i }) => {
    if (r.readOnly)
      return !1;
    let n = t(e, r);
    return n ? (i(r.update(n)), !0) : !1;
  };
}
const PW = /* @__PURE__ */ Gg(
  NW,
  0
  /* CommentOption.Toggle */
), FW = /* @__PURE__ */ Gg(
  TC,
  0
  /* CommentOption.Toggle */
), $W = /* @__PURE__ */ Gg(
  (t, e) => TC(t, e, IW(e)),
  0
  /* CommentOption.Toggle */
);
function Hg(t, e) {
  let r = t.languageDataAt("commentTokens", e);
  return r.length ? r[0] : {};
}
const yo = 50;
function BW(t, { open: e, close: r }, i, n) {
  let s = t.sliceDoc(i - yo, i), a = t.sliceDoc(n, n + yo), l = /\s*$/.exec(s)[0].length, u = /^\s*/.exec(a)[0].length, h = s.length - l;
  if (s.slice(h - e.length, h) == e && a.slice(u, u + r.length) == r)
    return {
      open: { pos: i - l, margin: l && 1 },
      close: { pos: n + u, margin: u && 1 }
    };
  let p, d;
  n - i <= 2 * yo ? p = d = t.sliceDoc(i, n) : (p = t.sliceDoc(i, i + yo), d = t.sliceDoc(n - yo, n));
  let m = /^\s*/.exec(p)[0].length, y = /\s*$/.exec(d)[0].length, O = d.length - y - r.length;
  return p.slice(m, m + e.length) == e && d.slice(O, O + r.length) == r ? {
    open: {
      pos: i + m + e.length,
      margin: /\s/.test(p.charAt(m + e.length)) ? 1 : 0
    },
    close: {
      pos: n - y - r.length,
      margin: /\s/.test(d.charAt(O - 1)) ? 1 : 0
    }
  } : null;
}
function IW(t) {
  let e = [];
  for (let r of t.selection.ranges) {
    let i = t.doc.lineAt(r.from), n = r.to <= i.to ? i : t.doc.lineAt(r.to), s = e.length - 1;
    s >= 0 && e[s].to > i.from ? e[s].to = n.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: n.to });
  }
  return e;
}
function TC(t, e, r = e.selection.ranges) {
  let i = r.map((s) => Hg(e, s.from).block);
  if (!i.every((s) => s))
    return null;
  let n = r.map((s, a) => BW(e, i[a], s.from, s.to));
  if (t != 2 && !n.every((s) => s))
    return { changes: e.changes(r.map((s, a) => n[a] ? [] : [{ from: s.from, insert: i[a].open + " " }, { from: s.to, insert: " " + i[a].close }])) };
  if (t != 1 && n.some((s) => s)) {
    let s = [];
    for (let a = 0, l; a < n.length; a++)
      if (l = n[a]) {
        let u = i[a], { open: h, close: p } = l;
        s.push({ from: h.pos - u.open.length, to: h.pos + h.margin }, { from: p.pos - p.margin, to: p.pos + u.close.length });
      }
    return { changes: s };
  }
  return null;
}
function NW(t, e, r = e.selection.ranges) {
  let i = [], n = -1;
  for (let { from: s, to: a } of r) {
    let l = i.length, u = 1e9, h = Hg(e, s).line;
    if (h) {
      for (let p = s; p <= a; ) {
        let d = e.doc.lineAt(p);
        if (d.from > n && (s == a || a > d.from)) {
          n = d.from;
          let m = /^\s*/.exec(d.text)[0].length, y = m == d.length, O = d.text.slice(m, m + h.length) == h ? m : -1;
          m < d.text.length && m < u && (u = m), i.push({ line: d, comment: O, token: h, indent: m, empty: y, single: !1 });
        }
        p = d.to + 1;
      }
      if (u < 1e9)
        for (let p = l; p < i.length; p++)
          i[p].indent < i[p].line.text.length && (i[p].indent = u);
      i.length == l + 1 && (i[l].single = !0);
    }
  }
  if (t != 2 && i.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: l, token: u, indent: h, empty: p, single: d } of i)
      (d || !p) && s.push({ from: l.from + h, insert: u + " " });
    let a = e.changes(s);
    return { changes: a, selection: e.selection.map(a, 1) };
  } else if (t != 1 && i.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: a, comment: l, token: u } of i)
      if (l >= 0) {
        let h = a.from + l, p = h + u.length;
        a.text[p - a.from] == " " && p++, s.push({ from: h, to: p });
      }
    return { changes: s };
  }
  return null;
}
const Qf = /* @__PURE__ */ Ni.define(), _W = /* @__PURE__ */ Ni.define(), MW = /* @__PURE__ */ fe.define(), PC = /* @__PURE__ */ fe.define({
  combine(t) {
    return _i(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, r) => r
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, r) => (i, n) => e(i, n) || r(i, n)
    });
  }
}), FC = /* @__PURE__ */ vt.define({
  create() {
    return Si.empty;
  },
  update(t, e) {
    let r = e.state.facet(PC), i = e.annotation(Qf);
    if (i) {
      let u = ir.fromTransaction(e, i.selection), h = i.side, p = h == 0 ? t.undone : t.done;
      return u ? p = Bc(p, p.length, r.minDepth, u) : p = IC(p, e.startState.selection), new Si(h == 0 ? i.rest : p, h == 0 ? p : i.rest);
    }
    let n = e.annotation(_W);
    if ((n == "full" || n == "before") && (t = t.isolate()), e.annotation(dt.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let s = ir.fromTransaction(e), a = e.annotation(dt.time), l = e.annotation(dt.userEvent);
    return s ? t = t.addChanges(s, a, l, r, e) : e.selection && (t = t.addSelection(e.startState.selection, a, l, r.newGroupDelay)), (n == "full" || n == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new Si(t.done.map(ir.fromJSON), t.undone.map(ir.fromJSON));
  }
});
function LW(t = {}) {
  return [
    FC,
    PC.of(t),
    le.domEventHandlers({
      beforeinput(e, r) {
        let i = e.inputType == "historyUndo" ? $C : e.inputType == "historyRedo" ? jf : null;
        return i ? (e.preventDefault(), i(r)) : !1;
      }
    })
  ];
}
function Zh(t, e) {
  return function({ state: r, dispatch: i }) {
    if (!e && r.readOnly)
      return !1;
    let n = r.field(FC, !1);
    if (!n)
      return !1;
    let s = n.pop(t, r, e);
    return s ? (i(s), !0) : !1;
  };
}
const $C = /* @__PURE__ */ Zh(0, !1), jf = /* @__PURE__ */ Zh(1, !1), QW = /* @__PURE__ */ Zh(0, !0), jW = /* @__PURE__ */ Zh(1, !0);
class ir {
  constructor(e, r, i, n, s) {
    this.changes = e, this.effects = r, this.mapped = i, this.startSelection = n, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new ir(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, r, i;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (r = this.mapped) === null || r === void 0 ? void 0 : r.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((n) => n.toJSON())
    };
  }
  static fromJSON(e) {
    return new ir(e.changes && yt.fromJSON(e.changes), [], e.mapped && Ai.fromJSON(e.mapped), e.startSelection && Y.fromJSON(e.startSelection), e.selectionsAfter.map(Y.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, r) {
    let i = Ir;
    for (let n of e.startState.facet(MW)) {
      let s = n(e);
      s.length && (i = i.concat(s));
    }
    return !i.length && e.changes.empty ? null : new ir(e.changes.invert(e.startState.doc), i, void 0, r || e.startState.selection, Ir);
  }
  static selection(e) {
    return new ir(void 0, Ir, void 0, void 0, e);
  }
}
function Bc(t, e, r, i) {
  let n = e + 1 > r + 20 ? e - r - 1 : 0, s = t.slice(n, e);
  return s.push(i), s;
}
function RW(t, e) {
  let r = [], i = !1;
  return t.iterChangedRanges((n, s) => r.push(n, s)), e.iterChangedRanges((n, s, a, l) => {
    for (let u = 0; u < r.length; ) {
      let h = r[u++], p = r[u++];
      l >= h && a <= p && (i = !0);
    }
  }), i;
}
function ZW(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((r, i) => r.empty != e.ranges[i].empty).length === 0;
}
function BC(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const Ir = [], WW = 200;
function IC(t, e) {
  if (t.length) {
    let r = t[t.length - 1], i = r.selectionsAfter.slice(Math.max(0, r.selectionsAfter.length - WW));
    return i.length && i[i.length - 1].eq(e) ? t : (i.push(e), Bc(t, t.length - 1, 1e9, r.setSelAfter(i)));
  } else
    return [ir.selection([e])];
}
function qW(t) {
  let e = t[t.length - 1], r = t.slice();
  return r[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), r;
}
function td(t, e) {
  if (!t.length)
    return t;
  let r = t.length, i = Ir;
  for (; r; ) {
    let n = XW(t[r - 1], e, i);
    if (n.changes && !n.changes.empty || n.effects.length) {
      let s = t.slice(0, r);
      return s[r - 1] = n, s;
    } else
      e = n.mapped, r--, i = n.selectionsAfter;
  }
  return i.length ? [ir.selection(i)] : Ir;
}
function XW(t, e, r) {
  let i = BC(t.selectionsAfter.length ? t.selectionsAfter.map((l) => l.map(e)) : Ir, r);
  if (!t.changes)
    return ir.selection(i);
  let n = t.changes.map(e), s = e.mapDesc(t.changes, !0), a = t.mapped ? t.mapped.composeDesc(s) : s;
  return new ir(n, we.mapEffects(t.effects, e), a, t.startSelection.map(s), i);
}
const VW = /^(input\.type|delete)($|\.)/;
class Si {
  constructor(e, r, i = 0, n = void 0) {
    this.done = e, this.undone = r, this.prevTime = i, this.prevUserEvent = n;
  }
  isolate() {
    return this.prevTime ? new Si(this.done, this.undone) : this;
  }
  addChanges(e, r, i, n, s) {
    let a = this.done, l = a[a.length - 1];
    return l && l.changes && !l.changes.empty && e.changes && (!i || VW.test(i)) && (!l.selectionsAfter.length && r - this.prevTime < n.newGroupDelay && n.joinToEvent(s, RW(l.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? a = Bc(a, a.length - 1, n.minDepth, new ir(e.changes.compose(l.changes), BC(e.effects, l.effects), l.mapped, l.startSelection, Ir)) : a = Bc(a, a.length, n.minDepth, e), new Si(a, Ir, r, i);
  }
  addSelection(e, r, i, n) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Ir;
    return s.length > 0 && r - this.prevTime < n && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && ZW(s[s.length - 1], e) ? this : new Si(IC(this.done, e), this.undone, r, i);
  }
  addMapping(e) {
    return new Si(td(this.done, e), td(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, r, i) {
    let n = e == 0 ? this.done : this.undone;
    if (n.length == 0)
      return null;
    let s = n[n.length - 1], a = s.selectionsAfter[0] || r.selection;
    if (i && s.selectionsAfter.length)
      return r.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: Qf.of({ side: e, rest: qW(n), selection: a }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let l = n.length == 1 ? Ir : n.slice(0, n.length - 1);
      return s.mapped && (l = td(l, s.mapped)), r.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: Qf.of({ side: e, rest: l, selection: a }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Si.empty = /* @__PURE__ */ new Si(Ir, Ir);
const UW = [
  { key: "Mod-z", run: $C, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: jf, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: jf, preventDefault: !0 },
  { key: "Mod-u", run: QW, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: jW, preventDefault: !0 }
];
function Ua(t, e) {
  return Y.create(t.ranges.map(e), t.mainIndex);
}
function Li(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function oi({ state: t, dispatch: e }, r) {
  let i = Ua(t.selection, r);
  return i.eq(t.selection, !0) ? !1 : (e(Li(t, i)), !0);
}
function Wh(t, e) {
  return Y.cursor(e ? t.to : t.from);
}
function NC(t, e) {
  return oi(t, (r) => r.empty ? t.moveByChar(r, e) : Wh(r, e));
}
function Xt(t) {
  return t.textDirectionAt(t.state.selection.main.head) == tt.LTR;
}
const _C = (t) => NC(t, !Xt(t)), MC = (t) => NC(t, Xt(t));
function LC(t, e) {
  return oi(t, (r) => r.empty ? t.moveByGroup(r, e) : Wh(r, e));
}
const YW = (t) => LC(t, !Xt(t)), zW = (t) => LC(t, Xt(t));
function GW(t, e, r) {
  if (e.type.prop(r))
    return !0;
  let i = e.to - e.from;
  return i && (i > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function qh(t, e, r) {
  let i = xt(t).resolveInner(e.head), n = r ? Pe.closedBy : Pe.openedBy;
  for (let u = e.head; ; ) {
    let h = r ? i.childAfter(u) : i.childBefore(u);
    if (!h)
      break;
    GW(t, h, n) ? i = h : u = r ? h.to : h.from;
  }
  let s = i.type.prop(n), a, l;
  return s && (a = r ? wi(t, i.from, 1) : wi(t, i.to, -1)) && a.matched ? l = r ? a.end.to : a.end.from : l = r ? i.to : i.from, Y.cursor(l, r ? -1 : 1);
}
const HW = (t) => oi(t, (e) => qh(t.state, e, !Xt(t))), JW = (t) => oi(t, (e) => qh(t.state, e, Xt(t)));
function QC(t, e) {
  return oi(t, (r) => {
    if (!r.empty)
      return Wh(r, e);
    let i = t.moveVertically(r, e);
    return i.head != r.head ? i : t.moveToLineBoundary(r, e);
  });
}
const jC = (t) => QC(t, !1), RC = (t) => QC(t, !0);
function ZC(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, r = 0, i = 0, n;
  if (e) {
    for (let s of t.state.facet(le.scrollMargins)) {
      let a = s(t);
      a != null && a.top && (r = Math.max(a == null ? void 0 : a.top, r)), a != null && a.bottom && (i = Math.max(a == null ? void 0 : a.bottom, i));
    }
    n = t.scrollDOM.clientHeight - r - i;
  } else
    n = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: r,
    marginBottom: i,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, n - 5)
  };
}
function WC(t, e) {
  let r = ZC(t), { state: i } = t, n = Ua(i.selection, (a) => a.empty ? t.moveVertically(a, e, r.height) : Wh(a, e));
  if (n.eq(i.selection))
    return !1;
  let s;
  if (r.selfScroll) {
    let a = t.coordsAtPos(i.selection.main.head), l = t.scrollDOM.getBoundingClientRect(), u = l.top + r.marginTop, h = l.bottom - r.marginBottom;
    a && a.top > u && a.bottom < h && (s = le.scrollIntoView(n.main.head, { y: "start", yMargin: a.top - u }));
  }
  return t.dispatch(Li(i, n), { effects: s }), !0;
}
const $O = (t) => WC(t, !1), Rf = (t) => WC(t, !0);
function zn(t, e, r) {
  let i = t.lineBlockAt(e.head), n = t.moveToLineBoundary(e, r);
  if (n.head == e.head && n.head != (r ? i.to : i.from) && (n = t.moveToLineBoundary(e, r, !1)), !r && n.head == i.from && i.length) {
    let s = /^\s*/.exec(t.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    s && e.head != i.from + s && (n = Y.cursor(i.from + s));
  }
  return n;
}
const KW = (t) => oi(t, (e) => zn(t, e, !0)), eq = (t) => oi(t, (e) => zn(t, e, !1)), tq = (t) => oi(t, (e) => zn(t, e, !Xt(t))), rq = (t) => oi(t, (e) => zn(t, e, Xt(t))), iq = (t) => oi(t, (e) => Y.cursor(t.lineBlockAt(e.head).from, 1)), nq = (t) => oi(t, (e) => Y.cursor(t.lineBlockAt(e.head).to, -1));
function sq(t, e, r) {
  let i = !1, n = Ua(t.selection, (s) => {
    let a = wi(t, s.head, -1) || wi(t, s.head, 1) || s.head > 0 && wi(t, s.head - 1, 1) || s.head < t.doc.length && wi(t, s.head + 1, -1);
    if (!a || !a.end)
      return s;
    i = !0;
    let l = a.start.from == s.head ? a.end.to : a.end.from;
    return r ? Y.range(s.anchor, l) : Y.cursor(l);
  });
  return i ? (e(Li(t, n)), !0) : !1;
}
const aq = ({ state: t, dispatch: e }) => sq(t, e, !1);
function qr(t, e) {
  let r = Ua(t.state.selection, (i) => {
    let n = e(i);
    return Y.range(i.anchor, n.head, n.goalColumn, n.bidiLevel || void 0);
  });
  return r.eq(t.state.selection) ? !1 : (t.dispatch(Li(t.state, r)), !0);
}
function qC(t, e) {
  return qr(t, (r) => t.moveByChar(r, e));
}
const XC = (t) => qC(t, !Xt(t)), VC = (t) => qC(t, Xt(t));
function UC(t, e) {
  return qr(t, (r) => t.moveByGroup(r, e));
}
const oq = (t) => UC(t, !Xt(t)), lq = (t) => UC(t, Xt(t)), uq = (t) => qr(t, (e) => qh(t.state, e, !Xt(t))), cq = (t) => qr(t, (e) => qh(t.state, e, Xt(t)));
function YC(t, e) {
  return qr(t, (r) => t.moveVertically(r, e));
}
const zC = (t) => YC(t, !1), GC = (t) => YC(t, !0);
function HC(t, e) {
  return qr(t, (r) => t.moveVertically(r, e, ZC(t).height));
}
const BO = (t) => HC(t, !1), IO = (t) => HC(t, !0), hq = (t) => qr(t, (e) => zn(t, e, !0)), pq = (t) => qr(t, (e) => zn(t, e, !1)), dq = (t) => qr(t, (e) => zn(t, e, !Xt(t))), fq = (t) => qr(t, (e) => zn(t, e, Xt(t))), mq = (t) => qr(t, (e) => Y.cursor(t.lineBlockAt(e.head).from)), gq = (t) => qr(t, (e) => Y.cursor(t.lineBlockAt(e.head).to)), NO = ({ state: t, dispatch: e }) => (e(Li(t, { anchor: 0 })), !0), _O = ({ state: t, dispatch: e }) => (e(Li(t, { anchor: t.doc.length })), !0), MO = ({ state: t, dispatch: e }) => (e(Li(t, { anchor: t.selection.main.anchor, head: 0 })), !0), LO = ({ state: t, dispatch: e }) => (e(Li(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), yq = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), Oq = ({ state: t, dispatch: e }) => {
  let r = Xh(t).map(({ from: i, to: n }) => Y.range(i, Math.min(n + 1, t.doc.length)));
  return e(t.update({ selection: Y.create(r), userEvent: "select" })), !0;
}, xq = ({ state: t, dispatch: e }) => {
  let r = Ua(t.selection, (i) => {
    var n;
    let s = xt(t).resolveStack(i.from, 1);
    for (let a = s; a; a = a.next) {
      let { node: l } = a;
      if ((l.from < i.from && l.to >= i.to || l.to > i.to && l.from <= i.from) && (!((n = l.parent) === null || n === void 0) && n.parent))
        return Y.range(l.to, l.from);
    }
    return i;
  });
  return e(Li(t, r)), !0;
}, Dq = ({ state: t, dispatch: e }) => {
  let r = t.selection, i = null;
  return r.ranges.length > 1 ? i = Y.create([r.main]) : r.main.empty || (i = Y.create([Y.cursor(r.main.head)])), i ? (e(Li(t, i)), !0) : !1;
};
function Rl(t, e) {
  if (t.state.readOnly)
    return !1;
  let r = "delete.selection", { state: i } = t, n = i.changeByRange((s) => {
    let { from: a, to: l } = s;
    if (a == l) {
      let u = e(s);
      u < a ? (r = "delete.backward", u = Bu(t, u, !1)) : u > a && (r = "delete.forward", u = Bu(t, u, !0)), a = Math.min(a, u), l = Math.max(l, u);
    } else
      a = Bu(t, a, !1), l = Bu(t, l, !0);
    return a == l ? { range: s } : { changes: { from: a, to: l }, range: Y.cursor(a, a < s.head ? -1 : 1) };
  });
  return n.changes.empty ? !1 : (t.dispatch(i.update(n, {
    scrollIntoView: !0,
    userEvent: r,
    effects: r == "delete.selection" ? le.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function Bu(t, e, r) {
  if (t instanceof le)
    for (let i of t.state.facet(le.atomicRanges).map((n) => n(t)))
      i.between(e, e, (n, s) => {
        n < e && s > e && (e = r ? s : n);
      });
  return e;
}
const JC = (t, e) => Rl(t, (r) => {
  let i = r.from, { state: n } = t, s = n.doc.lineAt(i), a, l;
  if (!e && i > s.from && i < s.from + 200 && !/[^ \t]/.test(a = s.text.slice(0, i - s.from))) {
    if (a[a.length - 1] == "	")
      return i - 1;
    let u = Va(a, n.tabSize), h = u % Pc(n) || Pc(n);
    for (let p = 0; p < h && a[a.length - 1 - p] == " "; p++)
      i--;
    l = i;
  } else
    l = Ft(s.text, i - s.from, e, e) + s.from, l == i && s.number != (e ? n.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(l - s.from, i - s.from)) && (l = Ft(s.text, l - s.from, !1, !1) + s.from);
  return l;
}), Zf = (t) => JC(t, !1), KC = (t) => JC(t, !0), eE = (t, e) => Rl(t, (r) => {
  let i = r.head, { state: n } = t, s = n.doc.lineAt(i), a = n.charCategorizer(i);
  for (let l = null; ; ) {
    if (i == (e ? s.to : s.from)) {
      i == r.head && s.number != (e ? n.doc.lines : 1) && (i += e ? 1 : -1);
      break;
    }
    let u = Ft(s.text, i - s.from, e) + s.from, h = s.text.slice(Math.min(i, u) - s.from, Math.max(i, u) - s.from), p = a(h);
    if (l != null && p != l)
      break;
    (h != " " || i != r.head) && (l = p), i = u;
  }
  return i;
}), tE = (t) => eE(t, !1), bq = (t) => eE(t, !0), vq = (t) => Rl(t, (e) => {
  let r = t.lineBlockAt(e.head).to;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), wq = (t) => Rl(t, (e) => {
  let r = t.moveToLineBoundary(e, !1).head;
  return e.head > r ? r : Math.max(0, e.head - 1);
}), Sq = (t) => Rl(t, (e) => {
  let r = t.moveToLineBoundary(e, !0).head;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), Cq = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: je.of(["", ""]) },
    range: Y.cursor(i.from)
  }));
  return e(t.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
}, Eq = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == t.doc.length)
      return { range: i };
    let n = i.from, s = t.doc.lineAt(n), a = n == s.from ? n - 1 : Ft(s.text, n - s.from, !1) + s.from, l = n == s.to ? n + 1 : Ft(s.text, n - s.from, !0) + s.from;
    return {
      changes: { from: a, to: l, insert: t.doc.slice(n, l).append(t.doc.slice(a, n)) },
      range: Y.cursor(l)
    };
  });
  return r.changes.empty ? !1 : (e(t.update(r, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Xh(t) {
  let e = [], r = -1;
  for (let i of t.selection.ranges) {
    let n = t.doc.lineAt(i.from), s = t.doc.lineAt(i.to);
    if (!i.empty && i.to == s.from && (s = t.doc.lineAt(i.to - 1)), r >= n.number) {
      let a = e[e.length - 1];
      a.to = s.to, a.ranges.push(i);
    } else
      e.push({ from: n.from, to: s.to, ranges: [i] });
    r = s.number + 1;
  }
  return e;
}
function rE(t, e, r) {
  if (t.readOnly)
    return !1;
  let i = [], n = [];
  for (let s of Xh(t)) {
    if (r ? s.to == t.doc.length : s.from == 0)
      continue;
    let a = t.doc.lineAt(r ? s.to + 1 : s.from - 1), l = a.length + 1;
    if (r) {
      i.push({ from: s.to, to: a.to }, { from: s.from, insert: a.text + t.lineBreak });
      for (let u of s.ranges)
        n.push(Y.range(Math.min(t.doc.length, u.anchor + l), Math.min(t.doc.length, u.head + l)));
    } else {
      i.push({ from: a.from, to: s.from }, { from: s.to, insert: t.lineBreak + a.text });
      for (let u of s.ranges)
        n.push(Y.range(u.anchor - l, u.head - l));
    }
  }
  return i.length ? (e(t.update({
    changes: i,
    scrollIntoView: !0,
    selection: Y.create(n, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const Aq = ({ state: t, dispatch: e }) => rE(t, e, !1), kq = ({ state: t, dispatch: e }) => rE(t, e, !0);
function iE(t, e, r) {
  if (t.readOnly)
    return !1;
  let i = [];
  for (let n of Xh(t))
    r ? i.push({ from: n.from, insert: t.doc.slice(n.from, n.to) + t.lineBreak }) : i.push({ from: n.to, insert: t.lineBreak + t.doc.slice(n.from, n.to) });
  return e(t.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const Tq = ({ state: t, dispatch: e }) => iE(t, e, !1), Pq = ({ state: t, dispatch: e }) => iE(t, e, !0), Fq = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, r = e.changes(Xh(e).map(({ from: n, to: s }) => (n > 0 ? n-- : s < e.doc.length && s++, { from: n, to: s }))), i = Ua(e.selection, (n) => t.moveVertically(n, !0)).map(r);
  return t.dispatch({ changes: r, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function $q(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let r = xt(t).resolveInner(e), i = r.childBefore(e), n = r.childAfter(e), s;
  return i && n && i.to <= e && n.from >= e && (s = i.type.prop(Pe.closedBy)) && s.indexOf(n.name) > -1 && t.doc.lineAt(i.to).from == t.doc.lineAt(n.from).from && !/\S/.test(t.sliceDoc(i.to, n.from)) ? { from: i.to, to: n.from } : null;
}
const Bq = /* @__PURE__ */ nE(!1), Iq = /* @__PURE__ */ nE(!0);
function nE(t) {
  return ({ state: e, dispatch: r }) => {
    if (e.readOnly)
      return !1;
    let i = e.changeByRange((n) => {
      let { from: s, to: a } = n, l = e.doc.lineAt(s), u = !t && s == a && $q(e, s);
      t && (s = a = (a <= l.to ? l : e.doc.lineAt(a)).to);
      let h = new jh(e, { simulateBreak: s, simulateDoubleBreak: !!u }), p = Ug(h, s);
      for (p == null && (p = Va(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); a < l.to && /\s/.test(l.text[a - l.from]); )
        a++;
      u ? { from: s, to: a } = u : s > l.from && s < l.from + 100 && !/\S/.test(l.text.slice(0, s)) && (s = l.from);
      let d = ["", cl(e, p)];
      return u && d.push(cl(e, h.lineIndent(l.from, -1))), {
        changes: { from: s, to: a, insert: je.of(d) },
        range: Y.cursor(s + 1 + d[1].length)
      };
    });
    return r(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Jg(t, e) {
  let r = -1;
  return t.changeByRange((i) => {
    let n = [];
    for (let a = i.from; a <= i.to; ) {
      let l = t.doc.lineAt(a);
      l.number > r && (i.empty || i.to > l.from) && (e(l, n, i), r = l.number), a = l.to + 1;
    }
    let s = t.changes(n);
    return {
      changes: n,
      range: Y.range(s.mapPos(i.anchor, 1), s.mapPos(i.head, 1))
    };
  });
}
const Nq = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = /* @__PURE__ */ Object.create(null), i = new jh(t, { overrideIndentation: (s) => {
    let a = r[s];
    return a ?? -1;
  } }), n = Jg(t, (s, a, l) => {
    let u = Ug(i, s.from);
    if (u == null)
      return;
    /\S/.test(s.text) || (u = 0);
    let h = /^\s*/.exec(s.text)[0], p = cl(t, u);
    (h != p || l.from < s.from + h.length) && (r[s.from] = u, a.push({ from: s.from, to: s.from + h.length, insert: p }));
  });
  return n.changes.empty || e(t.update(n, { userEvent: "indent" })), !0;
}, sE = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Jg(t, (r, i) => {
  i.push({ from: r.from, insert: t.facet(Ll) });
}), { userEvent: "input.indent" })), !0), aE = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Jg(t, (r, i) => {
  let n = /^\s*/.exec(r.text)[0];
  if (!n)
    return;
  let s = Va(n, t.tabSize), a = 0, l = cl(t, Math.max(0, s - Pc(t)));
  for (; a < n.length && a < l.length && n.charCodeAt(a) == l.charCodeAt(a); )
    a++;
  i.push({ from: r.from + a, to: r.from + n.length, insert: l.slice(a) });
}), { userEvent: "delete.dedent" })), !0), _q = [
  { key: "Ctrl-b", run: _C, shift: XC, preventDefault: !0 },
  { key: "Ctrl-f", run: MC, shift: VC },
  { key: "Ctrl-p", run: jC, shift: zC },
  { key: "Ctrl-n", run: RC, shift: GC },
  { key: "Ctrl-a", run: iq, shift: mq },
  { key: "Ctrl-e", run: nq, shift: gq },
  { key: "Ctrl-d", run: KC },
  { key: "Ctrl-h", run: Zf },
  { key: "Ctrl-k", run: vq },
  { key: "Ctrl-Alt-h", run: tE },
  { key: "Ctrl-o", run: Cq },
  { key: "Ctrl-t", run: Eq },
  { key: "Ctrl-v", run: Rf }
], Mq = /* @__PURE__ */ [
  { key: "ArrowLeft", run: _C, shift: XC, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: YW, shift: oq, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: tq, shift: dq, preventDefault: !0 },
  { key: "ArrowRight", run: MC, shift: VC, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: zW, shift: lq, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: rq, shift: fq, preventDefault: !0 },
  { key: "ArrowUp", run: jC, shift: zC, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: NO, shift: MO },
  { mac: "Ctrl-ArrowUp", run: $O, shift: BO },
  { key: "ArrowDown", run: RC, shift: GC, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: _O, shift: LO },
  { mac: "Ctrl-ArrowDown", run: Rf, shift: IO },
  { key: "PageUp", run: $O, shift: BO },
  { key: "PageDown", run: Rf, shift: IO },
  { key: "Home", run: eq, shift: pq, preventDefault: !0 },
  { key: "Mod-Home", run: NO, shift: MO },
  { key: "End", run: KW, shift: hq, preventDefault: !0 },
  { key: "Mod-End", run: _O, shift: LO },
  { key: "Enter", run: Bq },
  { key: "Mod-a", run: yq },
  { key: "Backspace", run: Zf, shift: Zf },
  { key: "Delete", run: KC },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: tE },
  { key: "Mod-Delete", mac: "Alt-Delete", run: bq },
  { mac: "Mod-Backspace", run: wq },
  { mac: "Mod-Delete", run: Sq }
].concat(/* @__PURE__ */ _q.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), Lq = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: HW, shift: uq },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: JW, shift: cq },
  { key: "Alt-ArrowUp", run: Aq },
  { key: "Shift-Alt-ArrowUp", run: Tq },
  { key: "Alt-ArrowDown", run: kq },
  { key: "Shift-Alt-ArrowDown", run: Pq },
  { key: "Escape", run: Dq },
  { key: "Mod-Enter", run: Iq },
  { key: "Alt-l", mac: "Ctrl-l", run: Oq },
  { key: "Mod-i", run: xq, preventDefault: !0 },
  { key: "Mod-[", run: aE },
  { key: "Mod-]", run: sE },
  { key: "Mod-Alt-\\", run: Nq },
  { key: "Shift-Mod-k", run: Fq },
  { key: "Shift-Mod-\\", run: aq },
  { key: "Mod-/", run: TW },
  { key: "Alt-A", run: FW }
].concat(Mq), Qq = { key: "Tab", run: sE, shift: aE };
function He() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, r = arguments[1];
  if (r && typeof r == "object" && r.nodeType == null && !Array.isArray(r)) {
    for (var i in r)
      if (Object.prototype.hasOwnProperty.call(r, i)) {
        var n = r[i];
        typeof n == "string" ? t.setAttribute(i, n) : n != null && (t[i] = n);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    oE(t, arguments[e]);
  return t;
}
function oE(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      t.appendChild(e);
    else if (Array.isArray(e))
      for (var r = 0; r < e.length; r++)
        oE(t, e[r]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const QO = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class Fa {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, r, i = 0, n = e.length, s, a) {
    this.test = a, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, n), this.bufferStart = i, this.normalize = s ? (l) => s(QO(l)) : QO, this.query = this.normalize(r);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Et(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let r = Pg(e), i = this.bufferStart + this.bufferPos;
      this.bufferPos += Br(e);
      let n = this.normalize(r);
      for (let s = 0, a = i; ; s++) {
        let l = n.charCodeAt(s), u = this.match(l, a, this.bufferPos + this.bufferStart);
        if (s == n.length - 1) {
          if (u)
            return this.value = u, this;
          break;
        }
        a == i && s < r.length && r.charCodeAt(s) == l && a++;
      }
    }
  }
  match(e, r, i) {
    let n = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let a = this.matches[s], l = !1;
      this.query.charCodeAt(a) == e && (a == this.query.length - 1 ? n = { from: this.matches[s + 1], to: i } : (this.matches[s]++, l = !0)), l || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? n = { from: r, to: i } : this.matches.push(1, r)), n && this.test && !this.test(n.from, n.to, this.buffer, this.bufferStart) && (n = null), n;
  }
}
typeof Symbol < "u" && (Fa.prototype[Symbol.iterator] = function() {
  return this;
});
const lE = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Kg = "gm" + (/x/.unicode == null ? "" : "u");
class uE {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, r, i, n = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = lE, /\\[sWDnr]|\n|\r|\[\^/.test(r))
      return new cE(e, r, i, n, s);
    this.re = new RegExp(r, Kg + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = e.iter();
    let a = e.lineAt(n);
    this.curLineStart = a.from, this.matchPos = Ic(e, n), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let r = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (r) {
        let i = this.curLineStart + r.index, n = i + r[0].length;
        if (this.matchPos = Ic(this.text, n + (i == n ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < n || i > this.value.to) && (!this.test || this.test(i, n, r)))
          return this.value = { from: i, to: n, match: r }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const rd = /* @__PURE__ */ new WeakMap();
class ya {
  constructor(e, r) {
    this.from = e, this.text = r;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, r, i) {
    let n = rd.get(e);
    if (!n || n.from >= i || n.to <= r) {
      let l = new ya(r, e.sliceString(r, i));
      return rd.set(e, l), l;
    }
    if (n.from == r && n.to == i)
      return n;
    let { text: s, from: a } = n;
    return a > r && (s = e.sliceString(r, a) + s, a = r), n.to < i && (s += e.sliceString(n.to, i)), rd.set(e, new ya(a, s)), new ya(r, s.slice(r - a, i - a));
  }
}
class cE {
  constructor(e, r, i, n, s) {
    this.text = e, this.to = s, this.done = !1, this.value = lE, this.matchPos = Ic(e, n), this.re = new RegExp(r, Kg + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = ya.get(e, n, this.chunkEnd(
      n + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, r = this.re.exec(this.flat.text);
      if (r && !r[0] && r.index == e && (this.re.lastIndex = e + 1, r = this.re.exec(this.flat.text)), r) {
        let i = this.flat.from + r.index, n = i + r[0].length;
        if ((this.flat.to >= this.to || r.index + r[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, n, r)))
          return this.value = { from: i, to: n, match: r }, this.matchPos = Ic(this.text, n + (i == n ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = ya.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (uE.prototype[Symbol.iterator] = cE.prototype[Symbol.iterator] = function() {
  return this;
});
function jq(t) {
  try {
    return new RegExp(t, Kg), !0;
  } catch {
    return !1;
  }
}
function Ic(t, e) {
  if (e >= t.length)
    return e;
  let r = t.lineAt(e), i;
  for (; e < r.to && (i = r.text.charCodeAt(e - r.from)) >= 56320 && i < 57344; )
    e++;
  return e;
}
function Wf(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), r = He("input", { class: "cm-textfield", name: "line", value: e }), i = He("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), t.dispatch({ effects: Nc.of(!1) }), t.focus()) : s.keyCode == 13 && (s.preventDefault(), n());
    },
    onsubmit: (s) => {
      s.preventDefault(), n();
    }
  }, He("label", t.state.phrase("Go to line"), ": ", r), " ", He("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")));
  function n() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(r.value);
    if (!s)
      return;
    let { state: a } = t, l = a.doc.lineAt(a.selection.main.head), [, u, h, p, d] = s, m = p ? +p.slice(1) : 0, y = h ? +h : l.number;
    if (h && d) {
      let v = y / 100;
      u && (v = v * (u == "-" ? -1 : 1) + l.number / a.doc.lines), y = Math.round(a.doc.lines * v);
    } else
      h && u && (y = y * (u == "-" ? -1 : 1) + l.number);
    let O = a.doc.line(Math.max(1, Math.min(a.doc.lines, y))), D = Y.cursor(O.from + Math.max(0, Math.min(m, O.length)));
    t.dispatch({
      effects: [Nc.of(!1), le.scrollIntoView(D.from, { y: "center" })],
      selection: D
    }), t.focus();
  }
  return { dom: i };
}
const Nc = /* @__PURE__ */ we.define(), jO = /* @__PURE__ */ vt.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(Nc) && (t = r.value);
    return t;
  },
  provide: (t) => ll.from(t, (e) => e ? Wf : null)
}), Rq = (t) => {
  let e = ol(t, Wf);
  if (!e) {
    let r = [Nc.of(!0)];
    t.state.field(jO, !1) == null && r.push(we.appendConfig.of([jO, Zq])), t.dispatch({ effects: r }), e = ol(t, Wf);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, Zq = /* @__PURE__ */ le.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), Wq = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, hE = /* @__PURE__ */ fe.define({
  combine(t) {
    return _i(t, Wq, {
      highlightWordAroundCursor: (e, r) => e || r,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function qq(t) {
  let e = [zq, Yq];
  return t && e.push(hE.of(t)), e;
}
const Xq = /* @__PURE__ */ Oe.mark({ class: "cm-selectionMatch" }), Vq = /* @__PURE__ */ Oe.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function RO(t, e, r, i) {
  return (r == 0 || t(e.sliceDoc(r - 1, r)) != it.Word) && (i == e.doc.length || t(e.sliceDoc(i, i + 1)) != it.Word);
}
function Uq(t, e, r, i) {
  return t(e.sliceDoc(r, r + 1)) == it.Word && t(e.sliceDoc(i - 1, i)) == it.Word;
}
const Yq = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(hE), { state: r } = t, i = r.selection;
    if (i.ranges.length > 1)
      return Oe.none;
    let n = i.main, s, a = null;
    if (n.empty) {
      if (!e.highlightWordAroundCursor)
        return Oe.none;
      let u = r.wordAt(n.head);
      if (!u)
        return Oe.none;
      a = r.charCategorizer(n.head), s = r.sliceDoc(u.from, u.to);
    } else {
      let u = n.to - n.from;
      if (u < e.minSelectionLength || u > 200)
        return Oe.none;
      if (e.wholeWords) {
        if (s = r.sliceDoc(n.from, n.to), a = r.charCategorizer(n.head), !(RO(a, r, n.from, n.to) && Uq(a, r, n.from, n.to)))
          return Oe.none;
      } else if (s = r.sliceDoc(n.from, n.to), !s)
        return Oe.none;
    }
    let l = [];
    for (let u of t.visibleRanges) {
      let h = new Fa(r.doc, s, u.from, u.to);
      for (; !h.next().done; ) {
        let { from: p, to: d } = h.value;
        if ((!a || RO(a, r, p, d)) && (n.empty && p <= n.from && d >= n.to ? l.push(Vq.range(p, d)) : (p >= n.to || d <= n.from) && l.push(Xq.range(p, d)), l.length > e.maxMatches))
          return Oe.none;
      }
    }
    return Oe.set(l);
  }
}, {
  decorations: (t) => t.decorations
}), zq = /* @__PURE__ */ le.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), Gq = ({ state: t, dispatch: e }) => {
  let { selection: r } = t, i = Y.create(r.ranges.map((n) => t.wordAt(n.head) || Y.cursor(n.head)), r.mainIndex);
  return i.eq(r) ? !1 : (e(t.update({ selection: i })), !0);
};
function Hq(t, e) {
  let { main: r, ranges: i } = t.selection, n = t.wordAt(r.head), s = n && n.from == r.from && n.to == r.to;
  for (let a = !1, l = new Fa(t.doc, e, i[i.length - 1].to); ; )
    if (l.next(), l.done) {
      if (a)
        return null;
      l = new Fa(t.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), a = !0;
    } else {
      if (a && i.some((u) => u.from == l.value.from))
        continue;
      if (s) {
        let u = t.wordAt(l.value.from);
        if (!u || u.from != l.value.from || u.to != l.value.to)
          continue;
      }
      return l.value;
    }
}
const Jq = ({ state: t, dispatch: e }) => {
  let { ranges: r } = t.selection;
  if (r.some((s) => s.from === s.to))
    return Gq({ state: t, dispatch: e });
  let i = t.sliceDoc(r[0].from, r[0].to);
  if (t.selection.ranges.some((s) => t.sliceDoc(s.from, s.to) != i))
    return !1;
  let n = Hq(t, i);
  return n ? (e(t.update({
    selection: t.selection.addRange(Y.range(n.from, n.to), !1),
    effects: le.scrollIntoView(n.to)
  })), !0) : !1;
}, Ya = /* @__PURE__ */ fe.define({
  combine(t) {
    return _i(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new cX(e),
      scrollToMatch: (e) => le.scrollIntoView(e)
    });
  }
});
class pE {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || jq(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (r, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new rX(this) : new eX(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, r = 0, i) {
    let n = e.doc ? e : Be.create({ doc: e });
    return i == null && (i = n.doc.length), this.regexp ? na(this, n, r, i) : ia(this, n, r, i);
  }
}
class dE {
  constructor(e) {
    this.spec = e;
  }
}
function ia(t, e, r, i) {
  return new Fa(e.doc, t.unquoted, r, i, t.caseSensitive ? void 0 : (n) => n.toLowerCase(), t.wholeWord ? Kq(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function Kq(t, e) {
  return (r, i, n, s) => ((s > r || s + n.length < i) && (s = Math.max(0, r - 2), n = t.sliceString(s, Math.min(t.length, i + 2))), (e(_c(n, r - s)) != it.Word || e(Mc(n, r - s)) != it.Word) && (e(Mc(n, i - s)) != it.Word || e(_c(n, i - s)) != it.Word));
}
class eX extends dE {
  constructor(e) {
    super(e);
  }
  nextMatch(e, r, i) {
    let n = ia(this.spec, e, i, e.doc.length).nextOverlapping();
    return n.done && (n = ia(this.spec, e, 0, r).nextOverlapping()), n.done ? null : n.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, r, i) {
    for (let n = i; ; ) {
      let s = Math.max(r, n - 1e4 - this.spec.unquoted.length), a = ia(this.spec, e, s, n), l = null;
      for (; !a.nextOverlapping().done; )
        l = a.value;
      if (l)
        return l;
      if (s == r)
        return null;
      n -= 1e4;
    }
  }
  prevMatch(e, r, i) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, r) {
    let i = ia(this.spec, e, 0, e.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= r)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(e, r, i, n) {
    let s = ia(this.spec, e, Math.max(0, r - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      n(s.value.from, s.value.to);
  }
}
function na(t, e, r, i) {
  return new uE(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? tX(e.charCategorizer(e.selection.main.head)) : void 0
  }, r, i);
}
function _c(t, e) {
  return t.slice(Ft(t, e, !1), e);
}
function Mc(t, e) {
  return t.slice(e, Ft(t, e));
}
function tX(t) {
  return (e, r, i) => !i[0].length || (t(_c(i.input, i.index)) != it.Word || t(Mc(i.input, i.index)) != it.Word) && (t(Mc(i.input, i.index + i[0].length)) != it.Word || t(_c(i.input, i.index + i[0].length)) != it.Word);
}
class rX extends dE {
  nextMatch(e, r, i) {
    let n = na(this.spec, e, i, e.doc.length).next();
    return n.done && (n = na(this.spec, e, 0, r).next()), n.done ? null : n.value;
  }
  prevMatchInRange(e, r, i) {
    for (let n = 1; ; n++) {
      let s = Math.max(
        r,
        i - n * 1e4
        /* FindPrev.ChunkSize */
      ), a = na(this.spec, e, s, i), l = null;
      for (; !a.next().done; )
        l = a.value;
      if (l && (s == r || l.from > s + 10))
        return l;
      if (s == r)
        return null;
    }
  }
  prevMatch(e, r, i) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (r, i) => i == "$" ? "$" : i == "&" ? e.match[0] : i != "0" && +i < e.match.length ? e.match[i] : r);
  }
  matchAll(e, r) {
    let i = na(this.spec, e, 0, e.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= r)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(e, r, i, n) {
    let s = na(this.spec, e, Math.max(
      0,
      r - 250
      /* RegExp.HighlightMargin */
    ), Math.min(i + 250, e.doc.length));
    for (; !s.next().done; )
      n(s.value.from, s.value.to);
  }
}
const hl = /* @__PURE__ */ we.define(), ey = /* @__PURE__ */ we.define(), Pn = /* @__PURE__ */ vt.define({
  create(t) {
    return new id(qf(t).create(), null);
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(hl) ? t = new id(r.value.create(), t.panel) : r.is(ey) && (t = new id(t.query, r.value ? ty : null));
    return t;
  },
  provide: (t) => ll.from(t, (e) => e.panel)
});
class id {
  constructor(e, r) {
    this.query = e, this.panel = r;
  }
}
const iX = /* @__PURE__ */ Oe.mark({ class: "cm-searchMatch" }), nX = /* @__PURE__ */ Oe.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), sX = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(Pn));
  }
  update(t) {
    let e = t.state.field(Pn);
    (e != t.startState.field(Pn) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return Oe.none;
    let { view: r } = this, i = new Mn();
    for (let n = 0, s = r.visibleRanges, a = s.length; n < a; n++) {
      let { from: l, to: u } = s[n];
      for (; n < a - 1 && u > s[n + 1].from - 2 * 250; )
        u = s[++n].to;
      t.highlight(r.state, l, u, (h, p) => {
        let d = r.state.selection.ranges.some((m) => m.from == h && m.to == p);
        i.add(h, p, d ? nX : iX);
      });
    }
    return i.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function Zl(t) {
  return (e) => {
    let r = e.state.field(Pn, !1);
    return r && r.query.spec.valid ? t(e, r) : gE(e);
  };
}
const Lc = /* @__PURE__ */ Zl((t, { query: e }) => {
  let { to: r } = t.state.selection.main, i = e.nextMatch(t.state, r, r);
  if (!i)
    return !1;
  let n = Y.single(i.from, i.to), s = t.state.facet(Ya);
  return t.dispatch({
    selection: n,
    effects: [ry(t, i), s.scrollToMatch(n.main, t)],
    userEvent: "select.search"
  }), mE(t), !0;
}), Qc = /* @__PURE__ */ Zl((t, { query: e }) => {
  let { state: r } = t, { from: i } = r.selection.main, n = e.prevMatch(r, i, i);
  if (!n)
    return !1;
  let s = Y.single(n.from, n.to), a = t.state.facet(Ya);
  return t.dispatch({
    selection: s,
    effects: [ry(t, n), a.scrollToMatch(s.main, t)],
    userEvent: "select.search"
  }), mE(t), !0;
}), aX = /* @__PURE__ */ Zl((t, { query: e }) => {
  let r = e.matchAll(t.state, 1e3);
  return !r || !r.length ? !1 : (t.dispatch({
    selection: Y.create(r.map((i) => Y.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), oX = ({ state: t, dispatch: e }) => {
  let r = t.selection;
  if (r.ranges.length > 1 || r.main.empty)
    return !1;
  let { from: i, to: n } = r.main, s = [], a = 0;
  for (let l = new Fa(t.doc, t.sliceDoc(i, n)); !l.next().done; ) {
    if (s.length > 1e3)
      return !1;
    l.value.from == i && (a = s.length), s.push(Y.range(l.value.from, l.value.to));
  }
  return e(t.update({
    selection: Y.create(s, a),
    userEvent: "select.search.matches"
  })), !0;
}, ZO = /* @__PURE__ */ Zl((t, { query: e }) => {
  let { state: r } = t, { from: i, to: n } = r.selection.main;
  if (r.readOnly)
    return !1;
  let s = e.nextMatch(r, i, i);
  if (!s)
    return !1;
  let a = [], l, u, h = [];
  if (s.from == i && s.to == n && (u = r.toText(e.getReplacement(s)), a.push({ from: s.from, to: s.to, insert: u }), s = e.nextMatch(r, s.from, s.to), h.push(le.announce.of(r.phrase("replaced match on line $", r.doc.lineAt(i).number) + "."))), s) {
    let p = a.length == 0 || a[0].from >= s.to ? 0 : s.to - s.from - u.length;
    l = Y.single(s.from - p, s.to - p), h.push(ry(t, s)), h.push(r.facet(Ya).scrollToMatch(l.main, t));
  }
  return t.dispatch({
    changes: a,
    selection: l,
    effects: h,
    userEvent: "input.replace"
  }), !0;
}), lX = /* @__PURE__ */ Zl((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let r = e.matchAll(t.state, 1e9).map((n) => {
    let { from: s, to: a } = n;
    return { from: s, to: a, insert: e.getReplacement(n) };
  });
  if (!r.length)
    return !1;
  let i = t.state.phrase("replaced $ matches", r.length) + ".";
  return t.dispatch({
    changes: r,
    effects: le.announce.of(i),
    userEvent: "input.replace.all"
  }), !0;
});
function ty(t) {
  return t.state.facet(Ya).createPanel(t);
}
function qf(t, e) {
  var r, i, n, s, a;
  let l = t.selection.main, u = l.empty || l.to > l.from + 100 ? "" : t.sliceDoc(l.from, l.to);
  if (e && !u)
    return e;
  let h = t.facet(Ya);
  return new pE({
    search: ((r = e == null ? void 0 : e.literal) !== null && r !== void 0 ? r : h.literal) ? u : u.replace(/\n/g, "\\n"),
    caseSensitive: (i = e == null ? void 0 : e.caseSensitive) !== null && i !== void 0 ? i : h.caseSensitive,
    literal: (n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : h.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : h.regexp,
    wholeWord: (a = e == null ? void 0 : e.wholeWord) !== null && a !== void 0 ? a : h.wholeWord
  });
}
function fE(t) {
  let e = ol(t, ty);
  return e && e.dom.querySelector("[main-field]");
}
function mE(t) {
  let e = fE(t);
  e && e == t.root.activeElement && e.select();
}
const gE = (t) => {
  let e = t.state.field(Pn, !1);
  if (e && e.panel) {
    let r = fE(t);
    if (r && r != t.root.activeElement) {
      let i = qf(t.state, e.query.spec);
      i.valid && t.dispatch({ effects: hl.of(i) }), r.focus(), r.select();
    }
  } else
    t.dispatch({ effects: [
      ey.of(!0),
      e ? hl.of(qf(t.state, e.query.spec)) : we.appendConfig.of(pX)
    ] });
  return !0;
}, yE = (t) => {
  let e = t.state.field(Pn, !1);
  if (!e || !e.panel)
    return !1;
  let r = ol(t, ty);
  return r && r.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: ey.of(!1) }), !0;
}, uX = [
  { key: "Mod-f", run: gE, scope: "editor search-panel" },
  { key: "F3", run: Lc, shift: Qc, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Lc, shift: Qc, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: yE, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: oX },
  { key: "Mod-Alt-g", run: Rq },
  { key: "Mod-d", run: Jq, preventDefault: !0 }
];
class cX {
  constructor(e) {
    this.view = e;
    let r = this.query = e.state.field(Pn).query.spec;
    this.commit = this.commit.bind(this), this.searchField = He("input", {
      value: r.search,
      placeholder: hr(e, "Find"),
      "aria-label": hr(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = He("input", {
      value: r.replace,
      placeholder: hr(e, "Replace"),
      "aria-label": hr(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = He("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: r.caseSensitive,
      onchange: this.commit
    }), this.reField = He("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: r.regexp,
      onchange: this.commit
    }), this.wordField = He("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: r.wholeWord,
      onchange: this.commit
    });
    function i(n, s, a) {
      return He("button", { class: "cm-button", name: n, onclick: s, type: "button" }, a);
    }
    this.dom = He("div", { onkeydown: (n) => this.keydown(n), class: "cm-search" }, [
      this.searchField,
      i("next", () => Lc(e), [hr(e, "next")]),
      i("prev", () => Qc(e), [hr(e, "previous")]),
      i("select", () => aX(e), [hr(e, "all")]),
      He("label", null, [this.caseField, hr(e, "match case")]),
      He("label", null, [this.reField, hr(e, "regexp")]),
      He("label", null, [this.wordField, hr(e, "by word")]),
      ...e.state.readOnly ? [] : [
        He("br"),
        this.replaceField,
        i("replace", () => ZO(e), [hr(e, "replace")]),
        i("replaceAll", () => lX(e), [hr(e, "replace all")])
      ],
      He("button", {
        name: "close",
        onclick: () => yE(e),
        "aria-label": hr(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new pE({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: hl.of(e) }));
  }
  keydown(e) {
    bR(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Qc : Lc)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), ZO(this.view));
  }
  update(e) {
    for (let r of e.transactions)
      for (let i of r.effects)
        i.is(hl) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Ya).top;
  }
}
function hr(t, e) {
  return t.state.phrase(e);
}
const Iu = 30, Nu = /[\s\.,:;?!]/;
function ry(t, { from: e, to: r }) {
  let i = t.state.doc.lineAt(e), n = t.state.doc.lineAt(r).to, s = Math.max(i.from, e - Iu), a = Math.min(n, r + Iu), l = t.state.sliceDoc(s, a);
  if (s != i.from) {
    for (let u = 0; u < Iu; u++)
      if (!Nu.test(l[u + 1]) && Nu.test(l[u])) {
        l = l.slice(u);
        break;
      }
  }
  if (a != n) {
    for (let u = l.length - 1; u > l.length - Iu; u--)
      if (!Nu.test(l[u - 1]) && Nu.test(l[u])) {
        l = l.slice(0, u);
        break;
      }
  }
  return le.announce.of(`${t.state.phrase("current match")}. ${l} ${t.state.phrase("on line")} ${i.number}.`);
}
const hX = /* @__PURE__ */ le.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), pX = [
  Pn,
  /* @__PURE__ */ js.low(sX),
  hX
];
class OE {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, r, i) {
    this.state = e, this.pos = r, this.explicit = i, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let r = xt(this.state).resolveInner(this.pos, -1);
    for (; r && e.indexOf(r.name) < 0; )
      r = r.parent;
    return r ? {
      from: r.from,
      to: this.pos,
      text: this.state.sliceDoc(r.from, this.pos),
      type: r.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let r = this.state.doc.lineAt(this.pos), i = Math.max(r.from, this.pos - 250), n = r.text.slice(i - r.from, this.pos - r.from), s = n.search(DE(e, !1));
    return s < 0 ? null : { from: i + s, to: this.pos, text: n.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, r) {
    e == "abort" && this.abortListeners && this.abortListeners.push(r);
  }
}
function WO(t) {
  let e = Object.keys(t).join(""), r = /\w/.test(e);
  return r && (e = e.replace(/\w/g, "")), `[${r ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function dX(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  for (let { label: n } of t) {
    e[n[0]] = !0;
    for (let s = 1; s < n.length; s++)
      r[n[s]] = !0;
  }
  let i = WO(e) + WO(r) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function xE(t) {
  let e = t.map((n) => typeof n == "string" ? { label: n } : n), [r, i] = e.every((n) => /^\w+$/.test(n.label)) ? [/\w*$/, /\w+$/] : dX(e);
  return (n) => {
    let s = n.matchBefore(i);
    return s || n.explicit ? { from: s ? s.from : n.pos, options: e, validFor: r } : null;
  };
}
function fX(t, e) {
  return (r) => {
    for (let i = xt(r.state).resolveInner(r.pos, -1); i; i = i.parent) {
      if (t.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return e(r);
  };
}
class qO {
  constructor(e, r, i, n) {
    this.completion = e, this.source = r, this.match = i, this.score = n;
  }
}
function Fn(t) {
  return t.selection.main.from;
}
function DE(t, e) {
  var r;
  let { source: i } = t, n = e && i[0] != "^", s = i[i.length - 1] != "$";
  return !n && !s ? t : new RegExp(`${n ? "^" : ""}(?:${i})${s ? "$" : ""}`, (r = t.flags) !== null && r !== void 0 ? r : t.ignoreCase ? "i" : "");
}
const bE = /* @__PURE__ */ Ni.define();
function mX(t, e, r, i) {
  let { main: n } = t.selection, s = r - n.from, a = i - n.from;
  return Object.assign(Object.assign({}, t.changeByRange((l) => l != n && r != i && t.sliceDoc(l.from + s, l.from + a) != t.sliceDoc(r, i) ? { range: l } : {
    changes: { from: l.from + s, to: i == n.from ? l.to : l.from + a, insert: e },
    range: Y.cursor(l.from + s + e.length)
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const XO = /* @__PURE__ */ new WeakMap();
function gX(t) {
  if (!Array.isArray(t))
    return t;
  let e = XO.get(t);
  return e || XO.set(t, e = xE(t)), e;
}
const jc = /* @__PURE__ */ we.define(), pl = /* @__PURE__ */ we.define();
class yX {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let r = 0; r < e.length; ) {
      let i = Et(e, r), n = Br(i);
      this.chars.push(i);
      let s = e.slice(r, r + n), a = s.toUpperCase();
      this.folded.push(Et(a == s ? s.toLowerCase() : a, 0)), r += n;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, r) {
    return this.score = e, this.matched = r, !0;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return !1;
    let { chars: r, folded: i, any: n, precise: s, byWord: a } = this;
    if (r.length == 1) {
      let x = Et(e, 0), S = Br(x), k = S == e.length ? 0 : -100;
      if (x != r[0])
        if (x == i[0])
          k += -200;
        else
          return !1;
      return this.ret(k, [0, S]);
    }
    let l = e.indexOf(this.pattern);
    if (l == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let u = r.length, h = 0;
    if (l < 0) {
      for (let x = 0, S = Math.min(e.length, 200); x < S && h < u; ) {
        let k = Et(e, x);
        (k == r[h] || k == i[h]) && (n[h++] = x), x += Br(k);
      }
      if (h < u)
        return !1;
    }
    let p = 0, d = 0, m = !1, y = 0, O = -1, D = -1, v = /[a-z]/.test(e), w = !0;
    for (let x = 0, S = Math.min(e.length, 200), k = 0; x < S && d < u; ) {
      let C = Et(e, x);
      l < 0 && (p < u && C == r[p] && (s[p++] = x), y < u && (C == r[y] || C == i[y] ? (y == 0 && (O = x), D = x + 1, y++) : y = 0));
      let A, P = C < 255 ? C >= 48 && C <= 57 || C >= 97 && C <= 122 ? 2 : C >= 65 && C <= 90 ? 1 : 0 : (A = Pg(C)) != A.toLowerCase() ? 1 : A != A.toUpperCase() ? 2 : 0;
      (!x || P == 1 && v || k == 0 && P != 0) && (r[d] == C || i[d] == C && (m = !0) ? a[d++] = x : a.length && (w = !1)), k = P, x += Br(C);
    }
    return d == u && a[0] == 0 && w ? this.result(-100 + (m ? -200 : 0), a, e) : y == u && O == 0 ? this.ret(-200 - e.length + (D == e.length ? 0 : -100), [0, D]) : l > -1 ? this.ret(-700 - e.length, [l, l + this.pattern.length]) : y == u ? this.ret(-900 - e.length, [O, D]) : d == u ? this.result(-100 + (m ? -200 : 0) + -700 + (w ? 0 : -1100), a, e) : r.length == 2 ? !1 : this.result((n[0] ? -700 : 0) + -200 + -1100, n, e);
  }
  result(e, r, i) {
    let n = [], s = 0;
    for (let a of r) {
      let l = a + (this.astral ? Br(Et(i, a)) : 1);
      s && n[s - 1] == a ? n[s - 1] = l : (n[s++] = a, n[s++] = l);
    }
    return this.ret(e - i.length, n);
  }
}
const Pt = /* @__PURE__ */ fe.define({
  combine(t) {
    return _i(t, {
      activateOnTyping: !0,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: OX,
      compareCompletions: (e, r) => e.label.localeCompare(r.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, r) => e && r,
      closeOnBlur: (e, r) => e && r,
      icons: (e, r) => e && r,
      tooltipClass: (e, r) => (i) => VO(e(i), r(i)),
      optionClass: (e, r) => (i) => VO(e(i), r(i)),
      addToOptions: (e, r) => e.concat(r)
    });
  }
});
function VO(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function OX(t, e, r, i, n, s) {
  let a = t.textDirection == tt.RTL, l = a, u = !1, h = "top", p, d, m = e.left - n.left, y = n.right - e.right, O = i.right - i.left, D = i.bottom - i.top;
  if (l && m < Math.min(O, y) ? l = !1 : !l && y < Math.min(O, m) && (l = !0), O <= (l ? m : y))
    p = Math.max(n.top, Math.min(r.top, n.bottom - D)) - e.top, d = Math.min(400, l ? m : y);
  else {
    u = !0, d = Math.min(
      400,
      (a ? e.right : n.right - e.left) - 30
      /* Info.Margin */
    );
    let x = n.bottom - e.bottom;
    x >= D || x > e.top ? p = r.bottom - e.top : (h = "bottom", p = e.bottom - r.top);
  }
  let v = (e.bottom - e.top) / s.offsetHeight, w = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${h}: ${p / v}px; max-width: ${d / w}px`,
    class: "cm-completionInfo-" + (u ? a ? "left-narrow" : "right-narrow" : l ? "left" : "right")
  };
}
function xX(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(r) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), r.type && i.classList.add(...r.type.split(/\s+/g).map((n) => "cm-completionIcon-" + n)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), e.push({
    render(r, i, n, s) {
      let a = document.createElement("span");
      a.className = "cm-completionLabel";
      let l = r.displayLabel || r.label, u = 0;
      for (let h = 0; h < s.length; ) {
        let p = s[h++], d = s[h++];
        p > u && a.appendChild(document.createTextNode(l.slice(u, p)));
        let m = a.appendChild(document.createElement("span"));
        m.appendChild(document.createTextNode(l.slice(p, d))), m.className = "cm-completionMatchedText", u = d;
      }
      return u < l.length && a.appendChild(document.createTextNode(l.slice(u))), a;
    },
    position: 50
  }, {
    render(r) {
      if (!r.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = r.detail, i;
    },
    position: 80
  }), e.sort((r, i) => r.position - i.position).map((r) => r.render);
}
function nd(t, e, r) {
  if (t <= r)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let n = Math.floor(e / r);
    return { from: n * r, to: (n + 1) * r };
  }
  let i = Math.floor((t - e) / r);
  return { from: t - (i + 1) * r, to: t - i * r };
}
class DX {
  constructor(e, r, i) {
    this.view = e, this.stateField = r, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (u) => this.placeInfo(u),
      key: this
    }, this.space = null, this.currentClass = "";
    let n = e.state.field(r), { options: s, selected: a } = n.open, l = e.state.facet(Pt);
    this.optionContent = xX(l), this.optionClass = l.optionClass, this.tooltipClass = l.tooltipClass, this.range = nd(s.length, a, l.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (u) => {
      let { options: h } = e.state.field(r).open;
      for (let p = u.target, d; p && p != this.dom; p = p.parentNode)
        if (p.nodeName == "LI" && (d = /-(\d+)$/.exec(p.id)) && +d[1] < h.length) {
          this.applyCompletion(e, h[+d[1]]), u.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (u) => {
      let h = e.state.field(this.stateField, !1);
      h && h.tooltip && e.state.facet(Pt).closeOnBlur && u.relatedTarget != e.contentDOM && e.dispatch({ effects: pl.of(null) });
    }), this.showOptions(s, n.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, r) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, r, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var r;
    let i = e.state.field(this.stateField), n = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), i != n) {
      let { options: s, selected: a, disabled: l } = i.open;
      (!n.open || n.open.options != s) && (this.range = nd(s.length, a, e.state.facet(Pt).maxRenderedOptions), this.showOptions(s, i.id)), this.updateSel(), l != ((r = n.open) === null || r === void 0 ? void 0 : r.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!l);
    }
  }
  updateTooltipClass(e) {
    let r = this.tooltipClass(e);
    if (r != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of r.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = r;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), r = e.open;
    if ((r.selected > -1 && r.selected < this.range.from || r.selected >= this.range.to) && (this.range = nd(r.options.length, r.selected, this.view.state.facet(Pt).maxRenderedOptions), this.showOptions(r.options, e.id)), this.updateSelectedOption(r.selected)) {
      this.destroyInfo();
      let { completion: i } = r.options[r.selected], { info: n } = i;
      if (!n)
        return;
      let s = typeof n == "string" ? document.createTextNode(n) : n(i);
      if (!s)
        return;
      "then" in s ? s.then((a) => {
        a && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(a, i);
      }).catch((a) => Nr(this.view.state, a, "completion info")) : this.addInfoPane(s, i);
    }
  }
  addInfoPane(e, r) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      i.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: n, destroy: s } = e;
      i.appendChild(n), this.infoDestroy = s || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let r = null;
    for (let i = this.list.firstChild, n = this.range.from; i; i = i.nextSibling, n++)
      i.nodeName != "LI" || !i.id ? n-- : n == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), r = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return r && vX(this.list, r), r;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let r = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), n = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let a = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: a.innerWidth, bottom: a.innerHeight };
    }
    return n.top > Math.min(s.bottom, r.bottom) - 10 || n.bottom < Math.max(s.top, r.top) + 10 ? null : this.view.state.facet(Pt).positionInfo(this.view, r, n, i, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, r, i) {
    const n = document.createElement("ul");
    n.id = r, n.setAttribute("role", "listbox"), n.setAttribute("aria-expanded", "true"), n.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let s = null;
    for (let a = i.from; a < i.to; a++) {
      let { completion: l, match: u } = e[a], { section: h } = l;
      if (h) {
        let m = typeof h == "string" ? h : h.name;
        if (m != s && (a > i.from || i.from == 0))
          if (s = m, typeof h != "string" && h.header)
            n.appendChild(h.header(h));
          else {
            let y = n.appendChild(document.createElement("completion-section"));
            y.textContent = m;
          }
      }
      const p = n.appendChild(document.createElement("li"));
      p.id = r + "-" + a, p.setAttribute("role", "option");
      let d = this.optionClass(l);
      d && (p.className = d);
      for (let m of this.optionContent) {
        let y = m(l, this.view.state, this.view, u);
        y && p.appendChild(y);
      }
    }
    return i.from && n.classList.add("cm-completionListIncompleteTop"), i.to < e.length && n.classList.add("cm-completionListIncompleteBottom"), n;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function bX(t, e) {
  return (r) => new DX(r, t, e);
}
function vX(t, e) {
  let r = t.getBoundingClientRect(), i = e.getBoundingClientRect(), n = r.height / t.offsetHeight;
  i.top < r.top ? t.scrollTop -= (r.top - i.top) / n : i.bottom > r.bottom && (t.scrollTop += (i.bottom - r.bottom) / n);
}
function UO(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function wX(t, e) {
  let r = [], i = null, n = (u) => {
    r.push(u);
    let { section: h } = u.completion;
    if (h) {
      i || (i = []);
      let p = typeof h == "string" ? h : h.name;
      i.some((d) => d.name == p) || i.push(typeof h == "string" ? { name: p } : h);
    }
  };
  for (let u of t)
    if (u.hasResult()) {
      let h = u.result.getMatch;
      if (u.result.filter === !1)
        for (let p of u.result.options)
          n(new qO(p, u.source, h ? h(p) : [], 1e9 - r.length));
      else {
        let p = new yX(e.sliceDoc(u.from, u.to));
        for (let d of u.result.options)
          if (p.match(d.label)) {
            let m = d.displayLabel ? h ? h(d, p.matched) : [] : p.matched;
            n(new qO(d, u.source, m, p.score + (d.boost || 0)));
          }
      }
    }
  if (i) {
    let u = /* @__PURE__ */ Object.create(null), h = 0, p = (d, m) => {
      var y, O;
      return ((y = d.rank) !== null && y !== void 0 ? y : 1e9) - ((O = m.rank) !== null && O !== void 0 ? O : 1e9) || (d.name < m.name ? -1 : 1);
    };
    for (let d of i.sort(p))
      h -= 1e5, u[d.name] = h;
    for (let d of r) {
      let { section: m } = d.completion;
      m && (d.score += u[typeof m == "string" ? m : m.name]);
    }
  }
  let s = [], a = null, l = e.facet(Pt).compareCompletions;
  for (let u of r.sort((h, p) => p.score - h.score || l(h.completion, p.completion))) {
    let h = u.completion;
    !a || a.label != h.label || a.detail != h.detail || a.type != null && h.type != null && a.type != h.type || a.apply != h.apply || a.boost != h.boost ? s.push(u) : UO(u.completion) > UO(a) && (s[s.length - 1] = u), a = u.completion;
  }
  return s;
}
class ha {
  constructor(e, r, i, n, s, a) {
    this.options = e, this.attrs = r, this.tooltip = i, this.timestamp = n, this.selected = s, this.disabled = a;
  }
  setSelected(e, r) {
    return e == this.selected || e >= this.options.length ? this : new ha(this.options, YO(r, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, r, i, n, s) {
    let a = wX(e, r);
    if (!a.length)
      return n && e.some(
        (u) => u.state == 1
        /* State.Pending */
      ) ? new ha(n.options, n.attrs, n.tooltip, n.timestamp, n.selected, !0) : null;
    let l = r.facet(Pt).selectOnOpen ? 0 : -1;
    if (n && n.selected != l && n.selected != -1) {
      let u = n.options[n.selected].completion;
      for (let h = 0; h < a.length; h++)
        if (a[h].completion == u) {
          l = h;
          break;
        }
    }
    return new ha(a, YO(i, l), {
      pos: e.reduce((u, h) => h.hasResult() ? Math.min(u, h.from) : u, 1e8),
      create: kX,
      above: s.aboveCursor
    }, n ? n.timestamp : Date.now(), l, !1);
  }
  map(e) {
    return new ha(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class Rc {
  constructor(e, r, i) {
    this.active = e, this.id = r, this.open = i;
  }
  static start() {
    return new Rc(EX, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: r } = e, i = r.facet(Pt), s = (i.override || r.languageDataAt("autocomplete", Fn(r)).map(gX)).map((l) => (this.active.find((h) => h.source == l) || new rr(
      l,
      this.active.some(
        (h) => h.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, i));
    s.length == this.active.length && s.every((l, u) => l == this.active[u]) && (s = this.active);
    let a = this.open;
    a && e.docChanged && (a = a.map(e.changes)), e.selection || s.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !SX(s, this.active) ? a = ha.build(s, r, this.id, a, i) : a && a.disabled && !s.some(
      (l) => l.state == 1
      /* State.Pending */
    ) && (a = null), !a && s.every(
      (l) => l.state != 1
      /* State.Pending */
    ) && s.some((l) => l.hasResult()) && (s = s.map((l) => l.hasResult() ? new rr(
      l.source,
      0
      /* State.Inactive */
    ) : l));
    for (let l of e.effects)
      l.is(wE) && (a = a && a.setSelected(l.value, this.id));
    return s == this.active && a == this.open ? this : new Rc(s, this.id, a);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : CX;
  }
}
function SX(t, e) {
  if (t == e)
    return !0;
  for (let r = 0, i = 0; ; ) {
    for (; r < t.length && !t[r].hasResult; )
      r++;
    for (; i < e.length && !e[i].hasResult; )
      i++;
    let n = r == t.length, s = i == e.length;
    if (n || s)
      return n == s;
    if (t[r++].result != e[i++].result)
      return !1;
  }
}
const CX = {
  "aria-autocomplete": "list"
};
function YO(t, e) {
  let r = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (r["aria-activedescendant"] = t + "-" + e), r;
}
const EX = [];
function Xf(t) {
  return t.isUserEvent("input.type") ? "input" : t.isUserEvent("delete.backward") ? "delete" : null;
}
class rr {
  constructor(e, r, i = -1) {
    this.source = e, this.state = r, this.explicitPos = i;
  }
  hasResult() {
    return !1;
  }
  update(e, r) {
    let i = Xf(e), n = this;
    i ? n = n.handleUserEvent(e, i, r) : e.docChanged ? n = n.handleChange(e) : e.selection && n.state != 0 && (n = new rr(
      n.source,
      0
      /* State.Inactive */
    ));
    for (let s of e.effects)
      if (s.is(jc))
        n = new rr(n.source, 1, s.value ? Fn(e.state) : -1);
      else if (s.is(pl))
        n = new rr(
          n.source,
          0
          /* State.Inactive */
        );
      else if (s.is(vE))
        for (let a of s.value)
          a.source == n.source && (n = a);
    return n;
  }
  handleUserEvent(e, r, i) {
    return r == "delete" || !i.activateOnTyping ? this.map(e.changes) : new rr(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(Fn(e.startState)) ? new rr(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new rr(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class Oa extends rr {
  constructor(e, r, i, n, s) {
    super(e, 2, r), this.result = i, this.from = n, this.to = s;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, r, i) {
    var n;
    let s = e.changes.mapPos(this.from), a = e.changes.mapPos(this.to, 1), l = Fn(e.state);
    if ((this.explicitPos < 0 ? l <= s : l < this.from) || l > a || r == "delete" && Fn(e.startState) == this.from)
      return new rr(
        this.source,
        r == "input" && i.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let u = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), h;
    return AX(this.result.validFor, e.state, s, a) ? new Oa(this.source, u, this.result, s, a) : this.result.update && (h = this.result.update(this.result, s, a, new OE(e.state, l, u >= 0))) ? new Oa(this.source, u, h, h.from, (n = h.to) !== null && n !== void 0 ? n : Fn(e.state)) : new rr(this.source, 1, u);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new rr(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new Oa(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function AX(t, e, r, i) {
  if (!t)
    return !1;
  let n = e.sliceDoc(r, i);
  return typeof t == "function" ? t(n, r, i, e) : DE(t, !0).test(n);
}
const vE = /* @__PURE__ */ we.define({
  map(t, e) {
    return t.map((r) => r.map(e));
  }
}), wE = /* @__PURE__ */ we.define(), mr = /* @__PURE__ */ vt.define({
  create() {
    return Rc.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    Rg.from(t, (e) => e.tooltip),
    le.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function SE(t, e) {
  const r = e.completion.apply || e.completion.label;
  let i = t.state.field(mr).active.find((n) => n.source == e.source);
  return i instanceof Oa ? (typeof r == "string" ? t.dispatch(Object.assign(Object.assign({}, mX(t.state, r, i.from, i.to)), { annotations: bE.of(e.completion) })) : r(t, e.completion, i.from, i.to), !0) : !1;
}
const kX = /* @__PURE__ */ bX(mr, SE);
function _u(t, e = "option") {
  return (r) => {
    let i = r.state.field(mr, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < r.state.facet(Pt).interactionDelay)
      return !1;
    let n = 1, s;
    e == "page" && (s = eC(r, i.open.tooltip)) && (n = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: a } = i.open.options, l = i.open.selected > -1 ? i.open.selected + n * (t ? 1 : -1) : t ? 0 : a - 1;
    return l < 0 ? l = e == "page" ? 0 : a - 1 : l >= a && (l = e == "page" ? a - 1 : 0), r.dispatch({ effects: wE.of(l) }), !0;
  };
}
const TX = (t) => {
  let e = t.state.field(mr, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(Pt).interactionDelay ? !1 : SE(t, e.open.options[e.open.selected]);
}, PX = (t) => t.state.field(mr, !1) ? (t.dispatch({ effects: jc.of(!0) }), !0) : !1, FX = (t) => {
  let e = t.state.field(mr, !1);
  return !e || !e.active.some(
    (r) => r.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: pl.of(null) }), !0);
};
class $X {
  constructor(e, r) {
    this.active = e, this.context = r, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const BX = 50, IX = 1e3, NX = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(mr).active)
      e.state == 1 && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(mr);
    if (!t.selectionSet && !t.docChanged && t.startState.field(mr) == e)
      return;
    let r = t.transactions.some((n) => (n.selection || n.docChanged) && !Xf(n));
    for (let n = 0; n < this.running.length; n++) {
      let s = this.running[n];
      if (r || s.updates.length + t.transactions.length > BX && Date.now() - s.time > IX) {
        for (let a of s.context.abortListeners)
          try {
            a();
          } catch (l) {
            Nr(this.view.state, l);
          }
        s.context.abortListeners = null, this.running.splice(n--, 1);
      } else
        s.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((n) => n.effects.some((s) => s.is(jc))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : t.state.facet(Pt).activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((n) => n.state == 1 && !this.running.some((s) => s.active.source == n.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let n of t.transactions)
        Xf(n) == "input" ? this.composing = 2 : this.composing == 2 && n.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(mr);
    for (let r of e.active)
      r.state == 1 && !this.running.some((i) => i.active.source == r.source) && this.startQuery(r);
  }
  startQuery(t) {
    let { state: e } = this.view, r = Fn(e), i = new OE(e, r, t.explicitPos == r), n = new $X(t, i);
    this.running.push(n), Promise.resolve(t.source(i)).then((s) => {
      n.context.aborted || (n.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: pl.of(null) }), Nr(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Pt).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], r = this.view.state.facet(Pt);
    for (let i = 0; i < this.running.length; i++) {
      let n = this.running[i];
      if (n.done === void 0)
        continue;
      if (this.running.splice(i--, 1), n.done) {
        let a = new Oa(n.active.source, n.active.explicitPos, n.done, n.done.from, (t = n.done.to) !== null && t !== void 0 ? t : Fn(n.updates.length ? n.updates[0].startState : this.view.state));
        for (let l of n.updates)
          a = a.update(l, r);
        if (a.hasResult()) {
          e.push(a);
          continue;
        }
      }
      let s = this.view.state.field(mr).active.find((a) => a.source == n.active.source);
      if (s && s.state == 1)
        if (n.done == null) {
          let a = new rr(
            n.active.source,
            0
            /* State.Inactive */
          );
          for (let l of n.updates)
            a = a.update(l, r);
          a.state != 1 && e.push(a);
        } else
          this.startQuery(s);
    }
    e.length && this.view.dispatch({ effects: vE.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(mr, !1);
      if (e && e.tooltip && this.view.state.facet(Pt).closeOnBlur) {
        let r = e.open && eC(this.view, e.open.tooltip);
        (!r || !r.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: pl.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: jc.of(!1) }), 20), this.composing = 0;
    }
  }
}), CE = /* @__PURE__ */ le.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class _X {
  constructor(e, r, i, n) {
    this.field = e, this.line = r, this.from = i, this.to = n;
  }
}
class iy {
  constructor(e, r, i) {
    this.field = e, this.from = r, this.to = i;
  }
  map(e) {
    let r = e.mapPos(this.from, -1, Tt.TrackDel), i = e.mapPos(this.to, 1, Tt.TrackDel);
    return r == null || i == null ? null : new iy(this.field, r, i);
  }
}
class ny {
  constructor(e, r) {
    this.lines = e, this.fieldPositions = r;
  }
  instantiate(e, r) {
    let i = [], n = [r], s = e.doc.lineAt(r), a = /^\s*/.exec(s.text)[0];
    for (let u of this.lines) {
      if (i.length) {
        let h = a, p = /^\t*/.exec(u)[0].length;
        for (let d = 0; d < p; d++)
          h += e.facet(Ll);
        n.push(r + h.length - p), u = h + u.slice(p);
      }
      i.push(u), r += u.length + 1;
    }
    let l = this.fieldPositions.map((u) => new iy(u.field, n[u.line] + u.from, n[u.line] + u.to));
    return { text: i, ranges: l };
  }
  static parse(e) {
    let r = [], i = [], n = [], s;
    for (let a of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(a); ) {
        let l = s[1] ? +s[1] : null, u = s[2] || s[3] || "", h = -1;
        for (let p = 0; p < r.length; p++)
          (l != null ? r[p].seq == l : u && r[p].name == u) && (h = p);
        if (h < 0) {
          let p = 0;
          for (; p < r.length && (l == null || r[p].seq != null && r[p].seq < l); )
            p++;
          r.splice(p, 0, { seq: l, name: u }), h = p;
          for (let d of n)
            d.field >= h && d.field++;
        }
        n.push(new _X(h, i.length, s.index, s.index + u.length)), a = a.slice(0, s.index) + u + a.slice(s.index + s[0].length);
      }
      for (let l; l = /\\([{}])/.exec(a); ) {
        a = a.slice(0, l.index) + l[1] + a.slice(l.index + l[0].length);
        for (let u of n)
          u.line == i.length && u.from > l.index && (u.from--, u.to--);
      }
      i.push(a);
    }
    return new ny(i, n);
  }
}
let MX = /* @__PURE__ */ Oe.widget({ widget: /* @__PURE__ */ new class extends Mi {
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-snippetFieldPosition", t;
  }
  ignoreEvent() {
    return !1;
  }
}() }), LX = /* @__PURE__ */ Oe.mark({ class: "cm-snippetField" });
class za {
  constructor(e, r) {
    this.ranges = e, this.active = r, this.deco = Oe.set(e.map((i) => (i.from == i.to ? MX : LX).range(i.from, i.to)));
  }
  map(e) {
    let r = [];
    for (let i of this.ranges) {
      let n = i.map(e);
      if (!n)
        return null;
      r.push(n);
    }
    return new za(r, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((r) => this.ranges.some((i) => i.field == this.active && i.from <= r.from && i.to >= r.to));
  }
}
const Wl = /* @__PURE__ */ we.define({
  map(t, e) {
    return t && t.map(e);
  }
}), QX = /* @__PURE__ */ we.define(), dl = /* @__PURE__ */ vt.define({
  create() {
    return null;
  },
  update(t, e) {
    for (let r of e.effects) {
      if (r.is(Wl))
        return r.value;
      if (r.is(QX) && t)
        return new za(t.ranges, r.value);
    }
    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
  },
  provide: (t) => le.decorations.from(t, (e) => e ? e.deco : Oe.none)
});
function sy(t, e) {
  return Y.create(t.filter((r) => r.field == e).map((r) => Y.range(r.from, r.to)));
}
function jX(t) {
  let e = ny.parse(t);
  return (r, i, n, s) => {
    let { text: a, ranges: l } = e.instantiate(r.state, n), u = {
      changes: { from: n, to: s, insert: je.of(a) },
      scrollIntoView: !0,
      annotations: i ? [bE.of(i), dt.userEvent.of("input.complete")] : void 0
    };
    if (l.length && (u.selection = sy(l, 0)), l.some((h) => h.field > 0)) {
      let h = new za(l, 0), p = u.effects = [Wl.of(h)];
      r.state.field(dl, !1) === void 0 && p.push(we.appendConfig.of([dl, XX, VX, CE]));
    }
    r.dispatch(r.state.update(u));
  };
}
function EE(t) {
  return ({ state: e, dispatch: r }) => {
    let i = e.field(dl, !1);
    if (!i || t < 0 && i.active == 0)
      return !1;
    let n = i.active + t, s = t > 0 && !i.ranges.some((a) => a.field == n + t);
    return r(e.update({
      selection: sy(i.ranges, n),
      effects: Wl.of(s ? null : new za(i.ranges, n)),
      scrollIntoView: !0
    })), !0;
  };
}
const RX = ({ state: t, dispatch: e }) => t.field(dl, !1) ? (e(t.update({ effects: Wl.of(null) })), !0) : !1, ZX = /* @__PURE__ */ EE(1), WX = /* @__PURE__ */ EE(-1), qX = [
  { key: "Tab", run: ZX, shift: WX },
  { key: "Escape", run: RX }
], zO = /* @__PURE__ */ fe.define({
  combine(t) {
    return t.length ? t[0] : qX;
  }
}), XX = /* @__PURE__ */ js.highest(/* @__PURE__ */ _l.compute([zO], (t) => t.facet(zO)));
function Kt(t, e) {
  return Object.assign(Object.assign({}, e), { apply: jX(t) });
}
const VX = /* @__PURE__ */ le.domEventHandlers({
  mousedown(t, e) {
    let r = e.state.field(dl, !1), i;
    if (!r || (i = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)
      return !1;
    let n = r.ranges.find((s) => s.from <= i && s.to >= i);
    return !n || n.field == r.active ? !1 : (e.dispatch({
      selection: sy(r.ranges, n.field),
      effects: Wl.of(r.ranges.some((s) => s.field > n.field) ? new za(r.ranges, n.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), fl = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, us = /* @__PURE__ */ we.define({
  map(t, e) {
    let r = e.mapPos(t, -1, Tt.TrackAfter);
    return r ?? void 0;
  }
}), ay = /* @__PURE__ */ new class extends ws {
}();
ay.startSide = 1;
ay.endSide = -1;
const AE = /* @__PURE__ */ vt.define({
  create() {
    return Me.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let r = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (i) => i >= r.from && i <= r.to });
    }
    for (let r of e.effects)
      r.is(us) && (t = t.update({ add: [ay.range(r.value, r.value + 1)] }));
    return t;
  }
});
function UX() {
  return [zX, AE];
}
const sd = "()[]{}<>";
function kE(t) {
  for (let e = 0; e < sd.length; e += 2)
    if (sd.charCodeAt(e) == t)
      return sd.charAt(e + 1);
  return Pg(t < 128 ? t : t + 1);
}
function TE(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || fl;
}
const YX = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), zX = /* @__PURE__ */ le.inputHandler.of((t, e, r, i) => {
  if ((YX ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let n = t.state.selection.main;
  if (i.length > 2 || i.length == 2 && Br(Et(i, 0)) == 1 || e != n.from || r != n.to)
    return !1;
  let s = JX(t.state, i);
  return s ? (t.dispatch(s), !0) : !1;
}), GX = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let i = TE(t, t.selection.main.head).brackets || fl.brackets, n = null, s = t.changeByRange((a) => {
    if (a.empty) {
      let l = KX(t.doc, a.head);
      for (let u of i)
        if (u == l && Vh(t.doc, a.head) == kE(Et(u, 0)))
          return {
            changes: { from: a.head - u.length, to: a.head + u.length },
            range: Y.cursor(a.head - u.length)
          };
    }
    return { range: n = a };
  });
  return n || e(t.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !n;
}, HX = [
  { key: "Backspace", run: GX }
];
function JX(t, e) {
  let r = TE(t, t.selection.main.head), i = r.brackets || fl.brackets;
  for (let n of i) {
    let s = kE(Et(n, 0));
    if (e == n)
      return s == n ? rV(t, n, i.indexOf(n + n + n) > -1, r) : eV(t, n, s, r.before || fl.before);
    if (e == s && PE(t, t.selection.main.from))
      return tV(t, n, s);
  }
  return null;
}
function PE(t, e) {
  let r = !1;
  return t.field(AE).between(0, t.doc.length, (i) => {
    i == e && (r = !0);
  }), r;
}
function Vh(t, e) {
  let r = t.sliceString(e, e + 2);
  return r.slice(0, Br(Et(r, 0)));
}
function KX(t, e) {
  let r = t.sliceString(e - 2, e);
  return Br(Et(r, 0)) == r.length ? r : r.slice(1);
}
function eV(t, e, r, i) {
  let n = null, s = t.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: r, from: a.to }],
        effects: us.of(a.to + e.length),
        range: Y.range(a.anchor + e.length, a.head + e.length)
      };
    let l = Vh(t.doc, a.head);
    return !l || /\s/.test(l) || i.indexOf(l) > -1 ? {
      changes: { insert: e + r, from: a.head },
      effects: us.of(a.head + e.length),
      range: Y.cursor(a.head + e.length)
    } : { range: n = a };
  });
  return n ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function tV(t, e, r) {
  let i = null, n = t.changeByRange((s) => s.empty && Vh(t.doc, s.head) == r ? {
    changes: { from: s.head, to: s.head + r.length, insert: r },
    range: Y.cursor(s.head + r.length)
  } : i = { range: s });
  return i ? null : t.update(n, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function rV(t, e, r, i) {
  let n = i.stringPrefixes || fl.stringPrefixes, s = null, a = t.changeByRange((l) => {
    if (!l.empty)
      return {
        changes: [{ insert: e, from: l.from }, { insert: e, from: l.to }],
        effects: us.of(l.to + e.length),
        range: Y.range(l.anchor + e.length, l.head + e.length)
      };
    let u = l.head, h = Vh(t.doc, u), p;
    if (h == e) {
      if (GO(t, u))
        return {
          changes: { insert: e + e, from: u },
          effects: us.of(u + e.length),
          range: Y.cursor(u + e.length)
        };
      if (PE(t, u)) {
        let m = r && t.sliceDoc(u, u + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: u, to: u + m.length, insert: m },
          range: Y.cursor(u + m.length)
        };
      }
    } else {
      if (r && t.sliceDoc(u - 2 * e.length, u) == e + e && (p = HO(t, u - 2 * e.length, n)) > -1 && GO(t, p))
        return {
          changes: { insert: e + e + e + e, from: u },
          effects: us.of(u + e.length),
          range: Y.cursor(u + e.length)
        };
      if (t.charCategorizer(u)(h) != it.Word && HO(t, u, n) > -1 && !iV(t, u, e, n))
        return {
          changes: { insert: e + e, from: u },
          effects: us.of(u + e.length),
          range: Y.cursor(u + e.length)
        };
    }
    return { range: s = l };
  });
  return s ? null : t.update(a, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function GO(t, e) {
  let r = xt(t).resolveInner(e + 1);
  return r.parent && r.from == e;
}
function iV(t, e, r, i) {
  let n = xt(t).resolveInner(e, -1), s = i.reduce((a, l) => Math.max(a, l.length), 0);
  for (let a = 0; a < 5; a++) {
    let l = t.sliceDoc(n.from, Math.min(n.to, n.from + r.length + s)), u = l.indexOf(r);
    if (!u || u > -1 && i.indexOf(l.slice(0, u)) > -1) {
      let p = n.firstChild;
      for (; p && p.from == n.from && p.to - p.from > r.length + u; ) {
        if (t.sliceDoc(p.to - r.length, p.to) == r)
          return !1;
        p = p.firstChild;
      }
      return !0;
    }
    let h = n.to == e && n.parent;
    if (!h)
      break;
    n = h;
  }
  return !1;
}
function HO(t, e, r) {
  let i = t.charCategorizer(e);
  if (i(t.sliceDoc(e - 1, e)) != it.Word)
    return e;
  for (let n of r) {
    let s = e - n.length;
    if (t.sliceDoc(s, e) == n && i(t.sliceDoc(s - 1, s)) != it.Word)
      return s;
  }
  return -1;
}
function nV(t = {}) {
  return [
    mr,
    Pt.of(t),
    NX,
    sV,
    CE
  ];
}
const FE = [
  { key: "Ctrl-Space", run: PX },
  { key: "Escape", run: FX },
  { key: "ArrowDown", run: /* @__PURE__ */ _u(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ _u(!1) },
  { key: "PageDown", run: /* @__PURE__ */ _u(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ _u(!1, "page") },
  { key: "Enter", run: TX }
], sV = /* @__PURE__ */ js.highest(/* @__PURE__ */ _l.computeN([Pt], (t) => t.facet(Pt).defaultKeymap ? [FE] : []));
class aV {
  constructor(e, r, i) {
    this.from = e, this.to = r, this.diagnostic = i;
  }
}
class ns {
  constructor(e, r, i) {
    this.diagnostics = e, this.panel = r, this.selected = i;
  }
  static init(e, r, i) {
    let n = e, s = i.facet(IE).markerFilter;
    s && (n = s(n, i));
    let a = Oe.set(n.map((l) => l.from == l.to || l.from == l.to - 1 && i.doc.lineAt(l.from).to == l.from ? Oe.widget({
      widget: new mV(l),
      diagnostic: l
    }).range(l.from) : Oe.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + l.severity + (l.markClass ? " " + l.markClass : "") },
      diagnostic: l,
      inclusive: !0
    }).range(l.from, l.to)), !0);
    return new ns(a, r, $a(a));
  }
}
function $a(t, e = null, r = 0) {
  let i = null;
  return t.between(r, 1e9, (n, s, { spec: a }) => {
    if (!(e && a.diagnostic != e))
      return i = new aV(n, s, a.diagnostic), !1;
  }), i;
}
function oV(t, e) {
  let r = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((i) => i.is($E)) || t.changes.touchesRange(r.from, r.to));
}
function lV(t, e) {
  return t.field(Dr, !1) ? e : e.concat(we.appendConfig.of(OV));
}
const $E = /* @__PURE__ */ we.define(), oy = /* @__PURE__ */ we.define(), BE = /* @__PURE__ */ we.define(), Dr = /* @__PURE__ */ vt.define({
  create() {
    return new ns(Oe.none, null, null);
  },
  update(t, e) {
    if (e.docChanged) {
      let r = t.diagnostics.map(e.changes), i = null;
      if (t.selected) {
        let n = e.changes.mapPos(t.selected.from, 1);
        i = $a(r, t.selected.diagnostic, n) || $a(r, null, n);
      }
      t = new ns(r, t.panel, i);
    }
    for (let r of e.effects)
      r.is($E) ? t = ns.init(r.value, t.panel, e.state) : r.is(oy) ? t = new ns(t.diagnostics, r.value ? Uh.open : null, t.selected) : r.is(BE) && (t = new ns(t.diagnostics, t.panel, r.value));
    return t;
  },
  provide: (t) => [
    ll.from(t, (e) => e.panel),
    le.decorations.from(t, (e) => e.diagnostics)
  ]
}), uV = /* @__PURE__ */ Oe.mark({ class: "cm-lintRange cm-lintRange-active", inclusive: !0 });
function cV(t, e, r) {
  let { diagnostics: i } = t.state.field(Dr), n = [], s = 2e8, a = 0;
  i.between(e - (r < 0 ? 1 : 0), e + (r > 0 ? 1 : 0), (u, h, { spec: p }) => {
    e >= u && e <= h && (u == h || (e > u || r > 0) && (e < h || r < 0)) && (n.push(p.diagnostic), s = Math.min(u, s), a = Math.max(h, a));
  });
  let l = t.state.facet(IE).tooltipFilter;
  return l && (n = l(n, t.state)), n.length ? {
    pos: s,
    end: a,
    above: t.state.doc.lineAt(s).to < a,
    create() {
      return { dom: hV(t, n) };
    }
  } : null;
}
function hV(t, e) {
  return He("ul", { class: "cm-tooltip-lint" }, e.map((r) => _E(t, r, !1)));
}
const pV = (t) => {
  let e = t.state.field(Dr, !1);
  (!e || !e.panel) && t.dispatch({ effects: lV(t.state, [oy.of(!0)]) });
  let r = ol(t, Uh.open);
  return r && r.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, JO = (t) => {
  let e = t.state.field(Dr, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: oy.of(!1) }), !0);
}, dV = (t) => {
  let e = t.state.field(Dr, !1);
  if (!e)
    return !1;
  let r = t.state.selection.main, i = e.diagnostics.iter(r.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == r.from && i.to == r.to) ? !1 : (t.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, fV = [
  { key: "Mod-Shift-m", run: pV, preventDefault: !0 },
  { key: "F8", run: dV }
], IE = /* @__PURE__ */ fe.define({
  combine(t) {
    return Object.assign({ sources: t.map((e) => e.source).filter((e) => e != null) }, _i(t.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (e, r) => e ? r ? (i) => e(i) || r(i) : e : r
    }));
  }
});
function NE(t) {
  let e = [];
  if (t)
    e:
      for (let { name: r } of t) {
        for (let i = 0; i < r.length; i++) {
          let n = r[i];
          if (/[a-zA-Z]/.test(n) && !e.some((s) => s.toLowerCase() == n.toLowerCase())) {
            e.push(n);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function _E(t, e, r) {
  var i;
  let n = r ? NE(e.actions) : [];
  return He("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, He("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((s, a) => {
    let l = !1, u = (m) => {
      if (m.preventDefault(), l)
        return;
      l = !0;
      let y = $a(t.state.field(Dr).diagnostics, e);
      y && s.apply(t, y.from, y.to);
    }, { name: h } = s, p = n[a] ? h.indexOf(n[a]) : -1, d = p < 0 ? h : [
      h.slice(0, p),
      He("u", h.slice(p, p + 1)),
      h.slice(p + 1)
    ];
    return He("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: u,
      onmousedown: u,
      "aria-label": ` Action: ${h}${p < 0 ? "" : ` (access key "${n[a]})"`}.`
    }, d);
  }), e.source && He("div", { class: "cm-diagnosticSource" }, e.source));
}
class mV extends Mi {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return He("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class KO {
  constructor(e, r) {
    this.diagnostic = r, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = _E(e, r, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class Uh {
  constructor(e) {
    this.view = e, this.items = [];
    let r = (n) => {
      if (n.keyCode == 27)
        JO(this.view), this.view.focus();
      else if (n.keyCode == 38 || n.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (n.keyCode == 40 || n.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (n.keyCode == 36)
        this.moveSelection(0);
      else if (n.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (n.keyCode == 13)
        this.view.focus();
      else if (n.keyCode >= 65 && n.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], a = NE(s.actions);
        for (let l = 0; l < a.length; l++)
          if (a[l].toUpperCase().charCodeAt(0) == n.keyCode) {
            let u = $a(this.view.state.field(Dr).diagnostics, s);
            u && s.actions[l].apply(e, u.from, u.to);
          }
      } else
        return;
      n.preventDefault();
    }, i = (n) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(n.target) && this.moveSelection(s);
    };
    this.list = He("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: r,
      onclick: i
    }), this.dom = He("div", { class: "cm-panel-lint" }, this.list, He("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => JO(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Dr).selected;
    if (!e)
      return -1;
    for (let r = 0; r < this.items.length; r++)
      if (this.items[r].diagnostic == e.diagnostic)
        return r;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: r } = this.view.state.field(Dr), i = 0, n = !1, s = null;
    for (e.between(0, this.view.state.doc.length, (a, l, { spec: u }) => {
      let h = -1, p;
      for (let d = i; d < this.items.length; d++)
        if (this.items[d].diagnostic == u.diagnostic) {
          h = d;
          break;
        }
      h < 0 ? (p = new KO(this.view, u.diagnostic), this.items.splice(i, 0, p), n = !0) : (p = this.items[h], h > i && (this.items.splice(i, h - i), n = !0)), r && p.diagnostic == r.diagnostic ? p.dom.hasAttribute("aria-selected") || (p.dom.setAttribute("aria-selected", "true"), s = p) : p.dom.hasAttribute("aria-selected") && p.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      n = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new KO(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), n = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: a, panel: l }) => {
        let u = l.height / this.list.offsetHeight;
        a.top < l.top ? this.list.scrollTop -= (l.top - a.top) / u : a.bottom > l.bottom && (this.list.scrollTop += (a.bottom - l.bottom) / u);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), n && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function r() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          r();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      r();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let r = this.view.state.field(Dr), i = $a(r.diagnostics, this.items[e].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: BE.of(i)
    });
  }
  static open(e) {
    return new Uh(e);
  }
}
function gV(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function Mu(t) {
  return gV(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const yV = /* @__PURE__ */ le.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Mu("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Mu("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Mu("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Mu("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), OV = [
  Dr,
  /* @__PURE__ */ le.decorations.compute([Dr], (t) => {
    let { selected: e, panel: r } = t.field(Dr);
    return !e || !r || e.from == e.to ? Oe.none : Oe.set([
      uV.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ uZ(cV, { hideOn: oV }),
  yV
];
var ex = function(e) {
  e === void 0 && (e = {});
  var {
    crosshairCursor: r = !1
  } = e, i = [];
  e.closeBracketsKeymap !== !1 && (i = i.concat(HX)), e.defaultKeymap !== !1 && (i = i.concat(Lq)), e.searchKeymap !== !1 && (i = i.concat(uX)), e.historyKeymap !== !1 && (i = i.concat(UW)), e.foldKeymap !== !1 && (i = i.concat(oW)), e.completionKeymap !== !1 && (i = i.concat(FE)), e.lintKeymap !== !1 && (i = i.concat(fV));
  var n = [];
  return e.lineNumbers !== !1 && n.push(OZ()), e.highlightActiveLineGutter !== !1 && n.push(bZ()), e.highlightSpecialChars !== !1 && n.push(LR()), e.history !== !1 && n.push(LW()), e.foldGutter !== !1 && n.push(hW()), e.drawSelection !== !1 && n.push(AR()), e.dropCursor !== !1 && n.push($R()), e.allowMultipleSelections !== !1 && n.push(Be.allowMultipleSelections.of(!0)), e.indentOnInput !== !1 && n.push(HZ()), e.syntaxHighlighting !== !1 && n.push(CC(mW, {
    fallback: !0
  })), e.bracketMatching !== !1 && n.push(vW()), e.closeBrackets !== !1 && n.push(UX()), e.autocompletion !== !1 && n.push(nV()), e.rectangularSelection !== !1 && n.push(JR()), r !== !1 && n.push(tZ()), e.highlightActiveLine !== !1 && n.push(qR()), e.highlightSelectionMatches !== !1 && n.push(qq()), e.tabSize && typeof e.tabSize == "number" && n.push(Ll.of(" ".repeat(e.tabSize))), n.concat([_l.of(i.flat())]).filter(Boolean);
};
const xV = "#e5c07b", tx = "#e06c75", DV = "#56b6c2", bV = "#ffffff", ic = "#abb2bf", Vf = "#7d8799", vV = "#61afef", wV = "#98c379", rx = "#d19a66", SV = "#c678dd", CV = "#21252b", ix = "#2c313a", nx = "#282c34", ad = "#353a42", EV = "#3E4451", sx = "#528bff", AV = /* @__PURE__ */ le.theme({
  "&": {
    color: ic,
    backgroundColor: nx
  },
  ".cm-content": {
    caretColor: sx
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: sx },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: EV },
  ".cm-panels": { backgroundColor: CV, color: ic },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: nx,
    color: Vf,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: ix
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: ad
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: ad,
    borderBottomColor: ad
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: ix,
      color: ic
    }
  }
}, { dark: !0 }), kV = /* @__PURE__ */ jl.define([
  {
    tag: M.keyword,
    color: SV
  },
  {
    tag: [M.name, M.deleted, M.character, M.propertyName, M.macroName],
    color: tx
  },
  {
    tag: [/* @__PURE__ */ M.function(M.variableName), M.labelName],
    color: vV
  },
  {
    tag: [M.color, /* @__PURE__ */ M.constant(M.name), /* @__PURE__ */ M.standard(M.name)],
    color: rx
  },
  {
    tag: [/* @__PURE__ */ M.definition(M.name), M.separator],
    color: ic
  },
  {
    tag: [M.typeName, M.className, M.number, M.changed, M.annotation, M.modifier, M.self, M.namespace],
    color: xV
  },
  {
    tag: [M.operator, M.operatorKeyword, M.url, M.escape, M.regexp, M.link, /* @__PURE__ */ M.special(M.string)],
    color: DV
  },
  {
    tag: [M.meta, M.comment],
    color: Vf
  },
  {
    tag: M.strong,
    fontWeight: "bold"
  },
  {
    tag: M.emphasis,
    fontStyle: "italic"
  },
  {
    tag: M.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: M.link,
    color: Vf,
    textDecoration: "underline"
  },
  {
    tag: M.heading,
    fontWeight: "bold",
    color: tx
  },
  {
    tag: [M.atom, M.bool, /* @__PURE__ */ M.special(M.variableName)],
    color: rx
  },
  {
    tag: [M.processingInstruction, M.string, M.inserted],
    color: wV
  },
  {
    tag: M.invalid,
    color: bV
  }
]), TV = [AV, /* @__PURE__ */ CC(kV)];
var PV = le.theme({
  "&": {
    backgroundColor: "#fff"
  }
}, {
  dark: !1
}), FV = function(e) {
  e === void 0 && (e = {});
  var {
    indentWithTab: r = !0,
    editable: i = !0,
    readOnly: n = !1,
    theme: s = "light",
    placeholder: a = "",
    basicSetup: l = !0
  } = e, u = [];
  switch (r && u.unshift(_l.of([Qq])), l && (typeof l == "boolean" ? u.unshift(ex()) : u.unshift(ex(l))), a && u.unshift(YR(a)), s) {
    case "light":
      u.push(PV);
      break;
    case "dark":
      u.push(TV);
      break;
    case "none":
      break;
    default:
      u.push(s);
      break;
  }
  return i === !1 && u.push(le.editable.of(!1)), n && u.push(Be.readOnly.of(!0)), [...u];
}, $V = (t) => ({
  line: t.state.doc.lineAt(t.state.selection.main.from),
  lineCount: t.state.doc.lines,
  lineBreak: t.state.lineBreak,
  length: t.state.doc.length,
  readOnly: t.state.readOnly,
  tabSize: t.state.tabSize,
  selection: t.state.selection,
  selectionAsSingle: t.state.selection.asSingle().main,
  ranges: t.state.selection.ranges,
  selectionCode: t.state.sliceDoc(t.state.selection.main.from, t.state.selection.main.to),
  selections: t.state.selection.ranges.map((e) => t.state.sliceDoc(e.from, e.to)),
  selectedText: t.state.selection.ranges.some((e) => !e.empty)
}), ax = Ni.define(), BV = [];
function IV(t) {
  var {
    value: e,
    selection: r,
    onChange: i,
    onStatistics: n,
    onCreateEditor: s,
    onUpdate: a,
    extensions: l = BV,
    autoFocus: u,
    theme: h = "light",
    height: p = null,
    minHeight: d = null,
    maxHeight: m = null,
    width: y = null,
    minWidth: O = null,
    maxWidth: D = null,
    placeholder: v = "",
    editable: w = !0,
    readOnly: x = !1,
    indentWithTab: S = !0,
    basicSetup: k = !0,
    root: C,
    initialState: A
  } = t, [P, I] = An(), [B, _] = An(), [R, G] = An(), J = le.theme({
    "&": {
      height: p,
      minHeight: d,
      maxHeight: m,
      width: y,
      minWidth: O,
      maxWidth: D
    },
    "& .cm-scroller": {
      height: "100% !important"
    }
  }), Q = le.updateListener.of((K) => {
    if (K.docChanged && typeof i == "function" && // Fix echoing of the remote changes:
    // If transaction is market as remote we don't have to call `onChange` handler again
    !K.transactions.some((be) => be.annotation(ax))) {
      var ye = K.state.doc, Ce = ye.toString();
      i(Ce, K);
    }
    n && n($V(K));
  }), q = FV({
    theme: h,
    editable: w,
    readOnly: x,
    placeholder: v,
    indentWithTab: S,
    basicSetup: k
  }), X = [Q, J, ...q];
  return a && typeof a == "function" && X.push(le.updateListener.of(a)), X = X.concat(l), Jr(() => {
    if (P && !R) {
      var K = {
        doc: e,
        selection: r,
        extensions: X
      }, ye = A ? Be.fromJSON(A.json, K, A.fields) : Be.create(K);
      if (G(ye), !B) {
        var Ce = new le({
          state: ye,
          parent: P,
          root: C
        });
        _(Ce), s && s(Ce, ye);
      }
    }
    return () => {
      B && (G(void 0), _(void 0));
    };
  }, [P, R]), Jr(() => I(t.container), [t.container]), Jr(() => () => {
    B && (B.destroy(), _(void 0));
  }, [B]), Jr(() => {
    u && B && B.focus();
  }, [u, B]), Jr(() => {
    B && B.dispatch({
      effects: we.reconfigure.of(X)
    });
  }, [h, l, p, d, m, y, O, D, v, w, x, S, k, i, a]), Jr(() => {
    if (e !== void 0) {
      var K = B ? B.state.doc.toString() : "";
      B && e !== K && B.dispatch({
        changes: {
          from: 0,
          to: K.length,
          insert: e || ""
        },
        annotations: [ax.of(!0)]
      });
    }
  }, [e, B]), {
    state: R,
    setState: G,
    view: B,
    setView: _,
    container: P,
    setContainer: I
  };
}
var NV = ["className", "value", "selection", "extensions", "onChange", "onStatistics", "onCreateEditor", "onUpdate", "autoFocus", "theme", "height", "minHeight", "maxHeight", "width", "minWidth", "maxWidth", "basicSetup", "placeholder", "indentWithTab", "editable", "readOnly", "root", "initialState"], ME = /* @__PURE__ */ ak((t, e) => {
  var {
    className: r,
    value: i = "",
    selection: n,
    extensions: s = [],
    onChange: a,
    onStatistics: l,
    onCreateEditor: u,
    onUpdate: h,
    autoFocus: p,
    theme: d = "light",
    height: m,
    minHeight: y,
    maxHeight: O,
    width: D,
    minWidth: v,
    maxWidth: w,
    basicSetup: x,
    placeholder: S,
    indentWithTab: k,
    editable: C,
    readOnly: A,
    root: P,
    initialState: I
  } = t, B = AQ(t, NV), _ = Gf(null), {
    state: R,
    view: G,
    container: J
  } = IV({
    container: _.current,
    root: P,
    value: i,
    autoFocus: p,
    theme: d,
    height: m,
    minHeight: y,
    maxHeight: O,
    width: D,
    minWidth: v,
    maxWidth: w,
    basicSetup: x,
    placeholder: S,
    indentWithTab: k,
    editable: C,
    readOnly: A,
    selection: n,
    onChange: a,
    onStatistics: l,
    onCreateEditor: u,
    onUpdate: h,
    extensions: s,
    initialState: I
  });
  if (ok(e, () => ({
    editor: _.current,
    state: R,
    view: G
  }), [_, J, R, G]), typeof i != "string")
    throw new Error("value must be typeof string but got " + typeof i);
  var Q = typeof d == "string" ? "cm-theme-" + d : "cm-theme";
  return /* @__PURE__ */ z.jsx("div", zd({
    ref: _,
    className: "" + Q + (r ? " " + r : "")
  }, B));
});
ME.displayName = "CodeMirror";
class Zc {
  /**
  @internal
  */
  constructor(e, r, i, n, s, a, l, u, h, p = 0, d) {
    this.p = e, this.stack = r, this.state = i, this.reducePos = n, this.pos = s, this.score = a, this.buffer = l, this.bufferBase = u, this.curContext = h, this.lookAhead = p, this.parent = d;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, r) => r % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, r, i = 0) {
    let n = e.parser.context;
    return new Zc(e, [], r, i, i, 0, [], 0, n ? new ox(n, n.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, r) {
    this.stack.push(this.state, r, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var r;
    let i = e >> 19, n = e & 65535, { parser: s } = this.p, a = s.dynamicPrecedence(n);
    if (a && (this.score += a), i == 0) {
      this.pushState(s.getGoto(this.state, n, !0), this.reducePos), n < s.minRepeatTerm && this.storeNode(n, this.reducePos, this.reducePos, 4, !0), this.reduceContext(n, this.reducePos);
      return;
    }
    let l = this.stack.length - (i - 1) * 3 - (e & 262144 ? 6 : 0), u = l ? this.stack[l - 2] : this.p.ranges[0].from, h = this.reducePos - u;
    h >= 2e3 && !(!((r = this.p.parser.nodeSet.types[n]) === null || r === void 0) && r.isAnonymous) && (u == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = h) : this.p.lastBigReductionSize < h && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = u, this.p.lastBigReductionSize = h));
    let p = l ? this.stack[l - 1] : 0, d = this.bufferBase + this.buffer.length - p;
    if (n < s.minRepeatTerm || e & 131072) {
      let m = s.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(n, u, m, d + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[l];
    else {
      let m = this.stack[l - 3];
      this.state = s.getGoto(m, n, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(n, u);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, r, i, n = 4, s = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let a = this, l = this.buffer.length;
      if (l == 0 && a.parent && (l = a.bufferBase - a.parent.bufferBase, a = a.parent), l > 0 && a.buffer[l - 4] == 0 && a.buffer[l - 1] > -1) {
        if (r == i)
          return;
        if (a.buffer[l - 2] >= r) {
          a.buffer[l - 2] = i;
          return;
        }
      }
    }
    if (!s || this.pos == i)
      this.buffer.push(e, r, i, n);
    else {
      let a = this.buffer.length;
      if (a > 0 && this.buffer[a - 4] != 0)
        for (; a > 0 && this.buffer[a - 2] > i; )
          this.buffer[a] = this.buffer[a - 4], this.buffer[a + 1] = this.buffer[a - 3], this.buffer[a + 2] = this.buffer[a - 2], this.buffer[a + 3] = this.buffer[a - 1], a -= 4, n > 4 && (n -= 4);
      this.buffer[a] = e, this.buffer[a + 1] = r, this.buffer[a + 2] = i, this.buffer[a + 3] = n;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, r, i, n) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = n, this.shiftContext(r, i), r <= this.p.parser.maxNode && this.buffer.push(r, i, n, 4);
    else {
      let s = e, { parser: a } = this.p;
      (n > this.pos || r <= a.maxNode) && (this.pos = n, a.stateFlag(
        s,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = n)), this.pushState(s, i), this.shiftContext(r, i), r <= a.maxNode && this.buffer.push(r, i, n, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, r, i, n) {
    e & 65536 ? this.reduce(e) : this.shift(e, r, i, n);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, r) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++);
    let n = this.pos;
    this.reducePos = this.pos = n + e.length, this.pushState(r, n), this.buffer.push(
      i,
      n,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, r = e.buffer.length;
    for (; r > 0 && e.buffer[r - 2] > e.reducePos; )
      r -= 4;
    let i = e.buffer.slice(r), n = e.bufferBase + r;
    for (; e && n == e.bufferBase; )
      e = e.parent;
    return new Zc(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, n, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, r) {
    let i = e <= this.p.parser.maxNode;
    i && this.storeNode(e, this.pos, r, 4), this.storeNode(0, this.pos, r, i ? 8 : 4), this.pos = this.reducePos = r, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let r = new _V(this); ; ) {
      let i = this.p.parser.stateSlot(
        r.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(r.state, e);
      if (i == 0)
        return !1;
      if (!(i & 65536))
        return !0;
      r.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let r = this.p.parser.nextStates(this.state);
    if (r.length > 8 || this.stack.length >= 120) {
      let n = [];
      for (let s = 0, a; s < r.length; s += 2)
        (a = r[s + 1]) != this.state && this.p.parser.hasAction(a, e) && n.push(r[s], a);
      if (this.stack.length < 120)
        for (let s = 0; n.length < 8 && s < r.length; s += 2) {
          let a = r[s + 1];
          n.some((l, u) => u & 1 && l == a) || n.push(r[s], a);
        }
      r = n;
    }
    let i = [];
    for (let n = 0; n < r.length && i.length < 4; n += 2) {
      let s = r[n + 1];
      if (s == this.state)
        continue;
      let a = this.split();
      a.pushState(s, this.pos), a.storeNode(0, a.pos, a.pos, 4, !0), a.shiftContext(r[n], this.pos), a.reducePos = this.pos, a.score -= 200, i.push(a);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, r = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(r & 65536))
      return !1;
    if (!e.validAction(this.state, r)) {
      let i = r >> 19, n = r & 65535, s = this.stack.length - i * 3;
      if (s < 0 || e.getGoto(this.stack[s], n, !1) < 0) {
        let a = this.findForcedReduction();
        if (a == null)
          return !1;
        r = a;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(r), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, r = [], i = (n, s) => {
      if (!r.includes(n))
        return r.push(n), e.allActions(n, (a) => {
          if (!(a & 393216))
            if (a & 65536) {
              let l = (a >> 19) - s;
              if (l > 1) {
                let u = a & 65535, h = this.stack.length - l * 3;
                if (h >= 0 && e.getGoto(this.stack[h], u, !1) >= 0)
                  return l << 19 | 65536 | u;
              }
            } else {
              let l = i(a, s + 1);
              if (l != null)
                return l;
            }
        });
    };
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let r = 0; r < this.stack.length; r += 3)
      if (this.stack[r] != e.stack[r])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, r) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  reduceContext(e, r) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let r = new ox(this.curContext.tracker, e);
      r.hash != this.curContext.hash && this.emitContext(), this.curContext = r;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class ox {
  constructor(e, r) {
    this.tracker = e, this.context = r, this.hash = e.strict ? e.hash(r) : 0;
  }
}
class _V {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let r = e & 65535, i = e >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let n = this.start.p.parser.getGoto(this.stack[this.base - 3], r, !0);
    this.state = n;
  }
}
class Wc {
  constructor(e, r, i) {
    this.stack = e, this.pos = r, this.index = i, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, r = e.bufferBase + e.buffer.length) {
    return new Wc(e, r, r - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Wc(this.stack, this.pos, this.index);
  }
}
function ko(t, e = Uint16Array) {
  if (typeof t != "string")
    return t;
  let r = null;
  for (let i = 0, n = 0; i < t.length; ) {
    let s = 0;
    for (; ; ) {
      let a = t.charCodeAt(i++), l = !1;
      if (a == 126) {
        s = 65535;
        break;
      }
      a >= 92 && a--, a >= 34 && a--;
      let u = a - 32;
      if (u >= 46 && (u -= 46, l = !0), s += u, l)
        break;
      s *= 46;
    }
    r ? r[n++] = s : r = new e(s);
  }
  return r;
}
class nc {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const lx = new nc();
class MV {
  /**
  @internal
  */
  constructor(e, r) {
    this.input = e, this.ranges = r, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = lx, this.rangeIndex = 0, this.pos = this.chunkPos = r[0].from, this.range = r[0], this.end = r[r.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, r) {
    let i = this.range, n = this.rangeIndex, s = this.pos + e;
    for (; s < i.from; ) {
      if (!n)
        return null;
      let a = this.ranges[--n];
      s -= i.from - a.to, i = a;
    }
    for (; r < 0 ? s > i.to : s >= i.to; ) {
      if (n == this.ranges.length - 1)
        return null;
      let a = this.ranges[++n];
      s += a.from - i.to, i = a;
    }
    return s;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let r of this.ranges)
      if (r.to > e)
        return Math.max(e, r.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsing—when looking forward—or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let r = this.chunkOff + e, i, n;
    if (r >= 0 && r < this.chunk.length)
      i = this.pos + e, n = this.chunk.charCodeAt(r);
    else {
      let s = this.resolveOffset(e, 1);
      if (s == null)
        return -1;
      if (i = s, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        n = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let a = this.rangeIndex, l = this.range;
        for (; l.to <= i; )
          l = this.ranges[++a];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > l.to && (this.chunk2 = this.chunk2.slice(0, l.to - i)), n = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), n;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, r = 0) {
    let i = r ? this.resolveOffset(r, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, r) {
    this.token.value = e, this.token.end = r;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: r } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = r, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), r = this.pos + e.length;
      this.chunk = r > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, r) {
    if (r ? (this.token = r, r.start = e, r.lookAhead = e + 1, r.value = r.extended = -1) : this.token = lx, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, r) {
    if (e >= this.chunkPos && r <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, r - this.chunkPos);
    if (e >= this.chunk2Pos && r <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, r - this.chunk2Pos);
    if (e >= this.range.from && r <= this.range.to)
      return this.input.read(e, r);
    let i = "";
    for (let n of this.ranges) {
      if (n.from >= r)
        break;
      n.to > e && (i += this.input.read(Math.max(n.from, e), Math.min(n.to, r)));
    }
    return i;
  }
}
class xa {
  constructor(e, r) {
    this.data = e, this.id = r;
  }
  token(e, r) {
    let { parser: i } = r.p;
    LE(this.data, e, r, this.id, i.data, i.tokenPrecTable);
  }
}
xa.prototype.contextual = xa.prototype.fallback = xa.prototype.extend = !1;
class Uf {
  constructor(e, r, i) {
    this.precTable = r, this.elseToken = i, this.data = typeof e == "string" ? ko(e) : e;
  }
  token(e, r) {
    let i = e.pos, n = 0;
    for (; ; ) {
      let s = e.next < 0, a = e.resolveOffset(1, 1);
      if (LE(this.data, e, r, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (s || n++, a == null)
        break;
      e.reset(a, e.token);
    }
    n && (e.reset(i, e.token), e.acceptToken(this.elseToken, n));
  }
}
Uf.prototype.contextual = xa.prototype.fallback = xa.prototype.extend = !1;
class Yh {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, r = {}) {
    this.token = e, this.contextual = !!r.contextual, this.fallback = !!r.fallback, this.extend = !!r.extend;
  }
}
function LE(t, e, r, i, n, s) {
  let a = 0, l = 1 << i, { dialect: u } = r.p.parser;
  e:
    for (; l & t[a]; ) {
      let h = t[a + 1];
      for (let y = a + 3; y < h; y += 2)
        if ((t[y + 1] & l) > 0) {
          let O = t[y];
          if (u.allows(O) && (e.token.value == -1 || e.token.value == O || LV(O, e.token.value, n, s))) {
            e.acceptToken(O);
            break;
          }
        }
      let p = e.next, d = 0, m = t[a + 2];
      if (e.next < 0 && m > d && t[h + m * 3 - 3] == 65535) {
        a = t[h + m * 3 - 1];
        continue e;
      }
      for (; d < m; ) {
        let y = d + m >> 1, O = h + y + (y << 1), D = t[O], v = t[O + 1] || 65536;
        if (p < D)
          m = y;
        else if (p >= v)
          d = y + 1;
        else {
          a = t[O + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function ux(t, e, r) {
  for (let i = e, n; (n = t[i]) != 65535; i++)
    if (n == r)
      return i - e;
  return -1;
}
function LV(t, e, r, i) {
  let n = ux(r, i, e);
  return n < 0 || ux(r, i, t) < n;
}
const pr = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let od = null;
function cx(t, e, r) {
  let i = t.cursor(Ot.IncludeAnonymous);
  for (i.moveTo(e); ; )
    if (!(r < 0 ? i.childBefore(e) : i.childAfter(e)))
      for (; ; ) {
        if ((r < 0 ? i.to < e : i.from > e) && !i.type.isError)
          return r < 0 ? Math.max(0, Math.min(
            i.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(t.length, Math.max(
            i.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (r < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return r < 0 ? 0 : t.length;
      }
}
class QV {
  constructor(e, r) {
    this.fragments = e, this.nodeSet = r, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? cx(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? cx(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let r = this.trees.length - 1;
      if (r < 0)
        return this.nextFragment(), null;
      let i = this.trees[r], n = this.index[r];
      if (n == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = i.children[n], a = this.start[r] + i.positions[n];
      if (a > e)
        return this.nextStart = a, null;
      if (s instanceof ft) {
        if (a == e) {
          if (a < this.safeFrom)
            return null;
          let l = a + s.length;
          if (l <= this.safeTo) {
            let u = s.prop(Pe.lookAhead);
            if (!u || l + u < this.fragment.to)
              return s;
          }
        }
        this.index[r]++, a + s.length >= Math.max(this.safeFrom, e) && (this.trees.push(s), this.start.push(a), this.index.push(0));
      } else
        this.index[r]++, this.nextStart = a + s.length;
    }
  }
}
class jV {
  constructor(e, r) {
    this.stream = r, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((i) => new nc());
  }
  getActions(e) {
    let r = 0, i = null, { parser: n } = e.p, { tokenizers: s } = n, a = n.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), l = e.curContext ? e.curContext.hash : 0, u = 0;
    for (let h = 0; h < s.length; h++) {
      if (!(1 << h & a))
        continue;
      let p = s[h], d = this.tokens[h];
      if (!(i && !p.fallback) && ((p.contextual || d.start != e.pos || d.mask != a || d.context != l) && (this.updateCachedToken(d, p, e), d.mask = a, d.context = l), d.lookAhead > d.end + 25 && (u = Math.max(d.lookAhead, u)), d.value != 0)) {
        let m = r;
        if (d.extended > -1 && (r = this.addActions(e, d.extended, d.end, r)), r = this.addActions(e, d.value, d.end, r), !p.extend && (i = d, r > m))
          break;
      }
    }
    for (; this.actions.length > r; )
      this.actions.pop();
    return u && e.setLookAhead(u), !i && e.pos == this.stream.end && (i = new nc(), i.value = e.p.parser.eofTerm, i.start = i.end = e.pos, r = this.addActions(e, i.value, i.end, r)), this.mainToken = i, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let r = new nc(), { pos: i, p: n } = e;
    return r.start = i, r.end = Math.min(i + 1, n.stream.end), r.value = i == n.stream.end ? n.parser.eofTerm : 0, r;
  }
  updateCachedToken(e, r, i) {
    let n = this.stream.clipPos(i.pos);
    if (r.token(this.stream.reset(n, e), i), e.value > -1) {
      let { parser: s } = i.p;
      for (let a = 0; a < s.specialized.length; a++)
        if (s.specialized[a] == e.value) {
          let l = s.specializers[a](this.stream.read(e.start, e.end), i);
          if (l >= 0 && i.p.parser.dialect.allows(l >> 1)) {
            l & 1 ? e.extended = l >> 1 : e.value = l >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(n + 1);
  }
  putAction(e, r, i, n) {
    for (let s = 0; s < n; s += 3)
      if (this.actions[s] == e)
        return n;
    return this.actions[n++] = e, this.actions[n++] = r, this.actions[n++] = i, n;
  }
  addActions(e, r, i, n) {
    let { state: s } = e, { parser: a } = e.p, { data: l } = a;
    for (let u = 0; u < 2; u++)
      for (let h = a.stateSlot(
        s,
        u ? 2 : 1
        /* ParseState.Actions */
      ); ; h += 3) {
        if (l[h] == 65535)
          if (l[h + 1] == 1)
            h = qi(l, h + 2);
          else {
            n == 0 && l[h + 1] == 2 && (n = this.putAction(qi(l, h + 2), r, i, n));
            break;
          }
        l[h] == r && (n = this.putAction(qi(l, h + 1), r, i, n));
      }
    return n;
  }
}
class RV {
  constructor(e, r, i, n) {
    this.parser = e, this.input = r, this.ranges = n, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new MV(r, n), this.tokens = new jV(e, this.stream), this.topTerm = e.top[1];
    let { from: s } = n[0];
    this.stacks = [Zc.start(this, e.top[0], s)], this.fragments = i.length && this.stream.end - s > e.bufferLength * 4 ? new QV(i, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, r = this.minStackPos, i = this.stacks = [], n, s;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [a] = e;
      for (; a.forceReduce() && a.stack.length && a.stack[a.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let a = 0; a < e.length; a++) {
      let l = e[a];
      for (; ; ) {
        if (this.tokens.mainToken = null, l.pos > r)
          i.push(l);
        else {
          if (this.advanceStack(l, i, e))
            continue;
          {
            n || (n = [], s = []), n.push(l);
            let u = this.tokens.getMainToken(l);
            s.push(u.value, u.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let a = n && qV(n);
      if (a)
        return pr && console.log("Finish with " + this.stackID(a)), this.stackToTree(a);
      if (this.parser.strict)
        throw pr && n && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + r);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && n) {
      let a = this.stoppedAt != null && n[0].pos > this.stoppedAt ? n[0] : this.runRecovery(n, s, i);
      if (a)
        return pr && console.log("Force-finish " + this.stackID(a)), this.stackToTree(a.forceAll());
    }
    if (this.recovering) {
      let a = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > a)
        for (i.sort((l, u) => u.score - l.score); i.length > a; )
          i.pop();
      i.some((l) => l.reducePos > r) && this.recovering--;
    } else if (i.length > 1) {
      e:
        for (let a = 0; a < i.length - 1; a++) {
          let l = i[a];
          for (let u = a + 1; u < i.length; u++) {
            let h = i[u];
            if (l.sameState(h) || l.buffer.length > 500 && h.buffer.length > 500)
              if ((l.score - h.score || l.buffer.length - h.buffer.length) > 0)
                i.splice(u--, 1);
              else {
                i.splice(a--, 1);
                continue e;
              }
          }
        }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let a = 1; a < i.length; a++)
      i[a].pos < this.minStackPos && (this.minStackPos = i[a].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, r, i) {
    let n = e.pos, { parser: s } = this, a = pr ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && n > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let h = e.curContext && e.curContext.tracker.strict, p = h ? e.curContext.hash : 0;
      for (let d = this.fragments.nodeAt(n); d; ) {
        let m = this.parser.nodeSet.types[d.type.id] == d.type ? s.getGoto(e.state, d.type.id) : -1;
        if (m > -1 && d.length && (!h || (d.prop(Pe.contextHash) || 0) == p))
          return e.useNode(d, m), pr && console.log(a + this.stackID(e) + ` (via reuse of ${s.getName(d.type.id)})`), !0;
        if (!(d instanceof ft) || d.children.length == 0 || d.positions[0] > 0)
          break;
        let y = d.children[0];
        if (y instanceof ft && d.positions[0] == 0)
          d = y;
        else
          break;
      }
    }
    let l = s.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (l > 0)
      return e.reduce(l), pr && console.log(a + this.stackID(e) + ` (via always-reduce ${s.getName(
        l & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let u = this.tokens.getActions(e);
    for (let h = 0; h < u.length; ) {
      let p = u[h++], d = u[h++], m = u[h++], y = h == u.length || !i, O = y ? e : e.split(), D = this.tokens.mainToken;
      if (O.apply(p, d, D ? D.start : O.pos, m), pr && console.log(a + this.stackID(O) + ` (via ${p & 65536 ? `reduce of ${s.getName(
        p & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${s.getName(d)} @ ${n}${O == e ? "" : ", split"})`), y)
        return !0;
      O.pos > n ? r.push(O) : i.push(O);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, r) {
    let i = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > i)
        return hx(e, r), !0;
    }
  }
  runRecovery(e, r, i) {
    let n = null, s = !1;
    for (let a = 0; a < e.length; a++) {
      let l = e[a], u = r[a << 1], h = r[(a << 1) + 1], p = pr ? this.stackID(l) + " -> " : "";
      if (l.deadEnd && (s || (s = !0, l.restart(), pr && console.log(p + this.stackID(l) + " (restarted)"), this.advanceFully(l, i))))
        continue;
      let d = l.split(), m = p;
      for (let y = 0; d.forceReduce() && y < 10 && (pr && console.log(m + this.stackID(d) + " (via force-reduce)"), !this.advanceFully(d, i)); y++)
        pr && (m = this.stackID(d) + " -> ");
      for (let y of l.recoverByInsert(u))
        pr && console.log(p + this.stackID(y) + " (via recover-insert)"), this.advanceFully(y, i);
      this.stream.end > l.pos ? (h == l.pos && (h++, u = 0), l.recoverByDelete(u, h), pr && console.log(p + this.stackID(l) + ` (via recover-delete ${this.parser.getName(u)})`), hx(l, i)) : (!n || n.score < l.score) && (n = l);
    }
    return n;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), ft.build({
      buffer: Wc.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let r = (od || (od = /* @__PURE__ */ new WeakMap())).get(e);
    return r || od.set(e, r = String.fromCodePoint(this.nextStackID++)), r + e;
  }
}
function hx(t, e) {
  for (let r = 0; r < e.length; r++) {
    let i = e[r];
    if (i.pos == t.pos && i.sameState(t)) {
      e[r].score < t.score && (e[r] = t);
      return;
    }
  }
  e.push(t);
}
class ZV {
  constructor(e, r, i) {
    this.source = e, this.flags = r, this.disabled = i;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const ld = (t) => t;
class WV {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || ld, this.reduce = e.reduce || ld, this.reuse = e.reuse || ld, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class qc extends lC {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let r = e.nodeNames.split(" ");
    this.minRepeatTerm = r.length;
    for (let l = 0; l < e.repeatNodeCount; l++)
      r.push("");
    let i = Object.keys(e.topRules).map((l) => e.topRules[l][1]), n = [];
    for (let l = 0; l < r.length; l++)
      n.push([]);
    function s(l, u, h) {
      n[l].push([u, u.deserialize(String(h))]);
    }
    if (e.nodeProps)
      for (let l of e.nodeProps) {
        let u = l[0];
        typeof u == "string" && (u = Pe[u]);
        for (let h = 1; h < l.length; ) {
          let p = l[h++];
          if (p >= 0)
            s(p, u, l[h++]);
          else {
            let d = l[h + -p];
            for (let m = -p; m > 0; m--)
              s(l[h++], u, d);
            h++;
          }
        }
      }
    this.nodeSet = new Zg(r.map((l, u) => or.define({
      name: u >= this.minRepeatTerm ? void 0 : l,
      id: u,
      props: n[u],
      top: i.indexOf(u) > -1,
      error: u == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(u) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = nC;
    let a = ko(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let l = 0; l < this.specializerSpecs.length; l++)
      this.specialized[l] = this.specializerSpecs[l].term;
    this.specializers = this.specializerSpecs.map(px), this.states = ko(e.states, Uint32Array), this.data = ko(e.stateData), this.goto = ko(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((l) => typeof l == "number" ? new xa(a, l) : l), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, r, i) {
    let n = new RV(this, e, r, i);
    for (let s of this.wrappers)
      n = s(n, e, r, i);
    return n;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, r, i = !1) {
    let n = this.goto;
    if (r >= n[0])
      return -1;
    for (let s = n[r + 1]; ; ) {
      let a = n[s++], l = a & 1, u = n[s++];
      if (l && i)
        return u;
      for (let h = s + (a >> 1); s < h; s++)
        if (n[s] == e)
          return u;
      if (l)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, r) {
    let i = this.data;
    for (let n = 0; n < 2; n++)
      for (let s = this.stateSlot(
        e,
        n ? 2 : 1
        /* ParseState.Actions */
      ), a; ; s += 3) {
        if ((a = i[s]) == 65535)
          if (i[s + 1] == 1)
            a = i[s = qi(i, s + 2)];
          else {
            if (i[s + 1] == 2)
              return qi(i, s + 2);
            break;
          }
        if (a == r || a == 0)
          return qi(i, s + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, r) {
    return this.states[e * 6 + r];
  }
  /**
  @internal
  */
  stateFlag(e, r) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & r) > 0;
  }
  /**
  @internal
  */
  validAction(e, r) {
    return !!this.allActions(e, (i) => i == r ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, r) {
    let i = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), n = i ? r(i) : void 0;
    for (let s = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); n == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1)
          s = qi(this.data, s + 2);
        else
          break;
      n = r(qi(this.data, s + 1));
    }
    return n;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let r = [];
    for (let i = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = qi(this.data, i + 2);
        else
          break;
      if (!(this.data[i + 2] & 1)) {
        let n = this.data[i + 1];
        r.some((s, a) => a & 1 && s == n) || r.push(this.data[i], n);
      }
    }
    return r;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let r = Object.assign(Object.create(qc.prototype), this);
    if (e.props && (r.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let i = this.topRules[e.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      r.top = i;
    }
    return e.tokenizers && (r.tokenizers = this.tokenizers.map((i) => {
      let n = e.tokenizers.find((s) => s.from == i);
      return n ? n.to : i;
    })), e.specializers && (r.specializers = this.specializers.slice(), r.specializerSpecs = this.specializerSpecs.map((i, n) => {
      let s = e.specializers.find((l) => l.from == i.external);
      if (!s)
        return i;
      let a = Object.assign(Object.assign({}, i), { external: s.to });
      return r.specializers[n] = px(a), a;
    })), e.contextTracker && (r.context = e.contextTracker), e.dialect && (r.dialect = this.parseDialect(e.dialect)), e.strict != null && (r.strict = e.strict), e.wrap && (r.wrappers = r.wrappers.concat(e.wrap)), e.bufferLength != null && (r.bufferLength = e.bufferLength), r;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let r = this.dynamicPrecedences;
    return r == null ? 0 : r[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let r = Object.keys(this.dialects), i = r.map(() => !1);
    if (e)
      for (let s of e.split(" ")) {
        let a = r.indexOf(s);
        a >= 0 && (i[a] = !0);
      }
    let n = null;
    for (let s = 0; s < r.length; s++)
      if (!i[s])
        for (let a = this.dialects[r[s]], l; (l = this.data[a++]) != 65535; )
          (n || (n = new Uint8Array(this.maxTerm + 1)))[l] = 1;
    return new ZV(e, i, n);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new qc(e);
  }
}
function qi(t, e) {
  return t[e] | t[e + 1] << 16;
}
function qV(t) {
  let e = null;
  for (let r of t) {
    let i = r.p.stoppedAt;
    (r.pos == r.p.stream.end || i != null && r.pos > i) && r.p.parser.stateFlag(
      r.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < r.score) && (e = r);
  }
  return e;
}
function px(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (r, i) => t.external(r, i) << 1 | e;
  }
  return t.get;
}
const XV = 309, dx = 1, VV = 2, UV = 3, YV = 310, zV = 312, GV = 313, HV = 4, JV = 5, KV = 0, Yf = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], QE = 125, eU = 59, zf = 47, tU = 42, rU = 43, iU = 45, nU = 60, sU = 44, aU = new WV({
  start: !1,
  shift(t, e) {
    return e == HV || e == JV || e == zV ? t : e == GV;
  },
  strict: !1
}), oU = new Yh((t, e) => {
  let { next: r } = t;
  (r == QE || r == -1 || e.context) && t.acceptToken(YV);
}, { contextual: !0, fallback: !0 }), lU = new Yh((t, e) => {
  let { next: r } = t, i;
  Yf.indexOf(r) > -1 || r == zf && ((i = t.peek(1)) == zf || i == tU) || r != QE && r != eU && r != -1 && !e.context && t.acceptToken(XV);
}, { contextual: !0 }), uU = new Yh((t, e) => {
  let { next: r } = t;
  if ((r == rU || r == iU) && (t.advance(), r == t.next)) {
    t.advance();
    let i = !e.context && e.canShift(dx);
    t.acceptToken(i ? dx : VV);
  }
}, { contextual: !0 });
function ud(t, e) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t == 95 || t >= 192 || !e && t >= 48 && t <= 57;
}
const cU = new Yh((t, e) => {
  if (t.next != nU || !e.dialectEnabled(KV) || (t.advance(), t.next == zf))
    return;
  let r = 0;
  for (; Yf.indexOf(t.next) > -1; )
    t.advance(), r++;
  if (ud(t.next, !0)) {
    for (t.advance(), r++; ud(t.next, !1); )
      t.advance(), r++;
    for (; Yf.indexOf(t.next) > -1; )
      t.advance(), r++;
    if (t.next == sU)
      return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!ud(t.next, !0))
          return;
        break;
      }
      if (t.next != "extends".charCodeAt(i))
        break;
      t.advance(), r++;
    }
  }
  t.acceptToken(UV, -r);
}), hU = uC({
  "get set async static": M.modifier,
  "for while do if else switch try catch finally return throw break continue default case": M.controlKeyword,
  "in of await yield void typeof delete instanceof": M.operatorKeyword,
  "let var const using function class extends": M.definitionKeyword,
  "import export from": M.moduleKeyword,
  "with debugger as new": M.keyword,
  TemplateString: M.special(M.string),
  super: M.atom,
  BooleanLiteral: M.bool,
  this: M.self,
  null: M.null,
  Star: M.modifier,
  VariableName: M.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": M.function(M.variableName),
  VariableDefinition: M.definition(M.variableName),
  Label: M.labelName,
  PropertyName: M.propertyName,
  PrivatePropertyName: M.special(M.propertyName),
  "CallExpression/MemberExpression/PropertyName": M.function(M.propertyName),
  "FunctionDeclaration/VariableDefinition": M.function(M.definition(M.variableName)),
  "ClassDeclaration/VariableDefinition": M.definition(M.className),
  PropertyDefinition: M.definition(M.propertyName),
  PrivatePropertyDefinition: M.definition(M.special(M.propertyName)),
  UpdateOp: M.updateOperator,
  "LineComment Hashbang": M.lineComment,
  BlockComment: M.blockComment,
  Number: M.number,
  String: M.string,
  Escape: M.escape,
  ArithOp: M.arithmeticOperator,
  LogicOp: M.logicOperator,
  BitOp: M.bitwiseOperator,
  CompareOp: M.compareOperator,
  RegExp: M.regexp,
  Equals: M.definitionOperator,
  Arrow: M.function(M.punctuation),
  ": Spread": M.punctuation,
  "( )": M.paren,
  "[ ]": M.squareBracket,
  "{ }": M.brace,
  "InterpolationStart InterpolationEnd": M.special(M.brace),
  ".": M.derefOperator,
  ", ;": M.separator,
  "@": M.meta,
  TypeName: M.typeName,
  TypeDefinition: M.definition(M.typeName),
  "type enum interface implements namespace module declare": M.definitionKeyword,
  "abstract global Privacy readonly override": M.modifier,
  "is keyof unique infer": M.operatorKeyword,
  JSXAttributeValue: M.attributeValue,
  JSXText: M.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": M.angleBracket,
  "JSXIdentifier JSXNameSpacedName": M.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": M.attributeName,
  "JSXBuiltin/JSXIdentifier": M.standard(M.tagName)
}), pU = { __proto__: null, export: 18, as: 23, from: 31, default: 34, async: 39, function: 40, extends: 52, this: 56, true: 64, false: 64, null: 76, void: 80, typeof: 84, super: 102, new: 136, delete: 152, yield: 161, await: 165, class: 170, public: 227, private: 227, protected: 227, readonly: 229, instanceof: 248, satisfies: 251, in: 252, const: 254, import: 286, keyof: 339, unique: 343, infer: 349, is: 385, abstract: 405, implements: 407, type: 409, let: 412, var: 414, using: 417, interface: 423, enum: 427, namespace: 433, module: 435, declare: 439, global: 443, for: 462, of: 471, while: 474, with: 478, do: 482, if: 486, else: 488, switch: 492, case: 498, try: 504, catch: 508, finally: 512, return: 516, throw: 520, break: 524, continue: 528, debugger: 532 }, dU = { __proto__: null, async: 123, get: 125, set: 127, declare: 187, public: 189, private: 189, protected: 189, static: 191, abstract: 193, override: 195, readonly: 201, accessor: 203, new: 389 }, fU = { __proto__: null, "<": 143 }, mU = qc.deserialize({
  version: 14,
  states: "$<UO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ08SO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO?MpO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DyO0fQ^O'#EROOQ07b'#EZ'#EZO1PQWO'#EWOOQO'#El'#ElOOQO'#Ie'#IeO1XQWO'#GmO1dQWO'#EkO1iQWO'#EkO3kQ08SO'#JiO6[Q08SO'#JjO6xQWO'#FZO6}Q&jO'#FqOOQ07b'#Fc'#FcO7YO,YO'#FcO7hQ7[O'#FxO9UQWO'#FwOOQ07b'#Jj'#JjOOQ07`'#Ji'#JiO9ZQWO'#GqOOQU'#KU'#KUO9fQWO'#IRO9kQ07hO'#ISOOQU'#JW'#JWOOQU'#IW'#IWQ`Q^OOO`Q^OOO%[Q^O'#DqO9sQ^O'#D}O9zQ^O'#EPO9aQWO'#GmO:RQ7[O'#CnO:aQWO'#EjO:lQWO'#EuO:qQ7[O'#FbO;`QWO'#GmOOQO'#KV'#KVO;eQWO'#KVO;sQWO'#GuO;sQWO'#GvO;sQWO'#GxO9aQWO'#G{O<jQWO'#HOO>RQWO'#CdO>cQWO'#H[O>kQWO'#HbO>kQWO'#HdO`Q^O'#HfO>kQWO'#HhO>kQWO'#HkO>pQWO'#HqO>uQ07iO'#HwO%[Q^O'#HyO?QQ07iO'#H{O?]Q07iO'#H}O9kQ07hO'#IPO?hQ08SO'#ChO@jQ`O'#DiQOQWOOO%[Q^O'#EPOAQQWO'#ESO:RQ7[O'#EjOA]QWO'#EjOAhQpO'#FbOOQU'#Cf'#CfOOQ07`'#Dn'#DnOOQ07`'#Jm'#JmO%[Q^O'#JmOOQO'#Jq'#JqOOQO'#Ib'#IbOBhQ`O'#EcOOQ07`'#Eb'#EbOCdQ07pO'#EcOCnQ`O'#EVOOQO'#Jp'#JpODSQ`O'#JqOEaQ`O'#EVOCnQ`O'#EcPEnO!0LbO'#CaPOOO)CDu)CDuOOOO'#IX'#IXOEyO!bO,59TOOQ07b,59T,59TOOOO'#IY'#IYOFXO#tO,59TO%[Q^O'#D`OOOO'#I['#I[OFgO?MpO,59xOOQ07b,59x,59xOFuQ^O'#I]OGYQWO'#JkOI[QrO'#JkO+}Q^O'#JkOIcQWO,5:OOIyQWO'#ElOJWQWO'#JyOJcQWO'#JxOJcQWO'#JxOJkQWO,5;YOJpQWO'#JwOOQ07f,5:Z,5:ZOJwQ^O,5:ZOLxQ08SO,5:eOMiQWO,5:mONSQ07hO'#JvONZQWO'#JuO9ZQWO'#JuONoQWO'#JuONwQWO,5;XON|QWO'#JuO!#UQrO'#JjOOQ07b'#Ch'#ChO%[Q^O'#ERO!#tQpO,5:rOOQO'#Jr'#JrOOQO-E<c-E<cO9aQWO,5=XO!$[QWO,5=XO!$aQ^O,5;VO!&dQ7[O'#EgO!'}QWO,5;VO!)mQ7[O'#DsO!)tQ^O'#DxO!*OQ`O,5;`O!*WQ`O,5;`O%[Q^O,5;`OOQU'#FR'#FROOQU'#FT'#FTO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aOOQU'#FX'#FXO!*fQ^O,5;rOOQ07b,5;w,5;wOOQ07b,5;x,5;xO!,iQWO,5;xOOQ07b,5;y,5;yO%[Q^O'#IiO!,qQ07hO,5<eO!&dQ7[O,5;aO!-`Q7[O,5;aO%[Q^O,5;uO!-gQ&jO'#FgO!.dQ&jO'#J}O!.OQ&jO'#J}O!.kQ&jO'#J}OOQO'#J}'#J}O!/PQ&jO,5<POOOS,5<],5<]O!/bQ^O'#FsOOOS'#Ih'#IhO7YO,YO,5;}O!/iQ&jO'#FuOOQ07b,5;},5;}O!0YQMhO'#CuOOQ07b'#Cy'#CyO!0mQWO'#CyO!0rO?MpO'#C}O!1`Q7[O,5<bO!1gQWO,5<dO!3SQ!LQO'#GSO!3aQWO'#GTO!3fQWO'#GTO!3kQ!LQO'#GXO!4jQ`O'#G]OOQO'#Gh'#GhO!(SQ7[O'#GgOOQO'#Gj'#GjO!(SQ7[O'#GiO!5]QMhO'#JdOOQ07b'#Jd'#JdO!5gQWO'#JcO!5uQWO'#JbO!5}QWO'#CtOOQ07b'#Cw'#CwOOQ07b'#DR'#DROOQ07b'#DT'#DTO1SQWO'#DVO!(SQ7[O'#FzO!(SQ7[O'#F|O!6VQWO'#GOO!6[QWO'#GPO!3fQWO'#GVO!(SQ7[O'#G[O!6aQWO'#EmO!7OQWO,5<cOOQ07`'#Cq'#CqO!7WQWO'#EnO!8QQ`O'#EoOOQ07`'#Jw'#JwO!8XQ07hO'#KWO9kQ07hO,5=]O`Q^O,5>mOOQU'#J`'#J`OOQU,5>n,5>nOOQU-E<U-E<UO!:ZQ08SO,5:]O!<wQ08SO,5:iO%[Q^O,5:iO!?bQ08SO,5:kOOQO,5@q,5@qO!@RQ7[O,5=XO!@aQ07hO'#JaO9UQWO'#JaO!@rQ07hO,59YO!@}Q`O,59YO!AVQ7[O,59YO:RQ7[O,59YO!AbQWO,5;VO!AjQWO'#HZO!BOQWO'#KZO%[Q^O,5;zO!7{Q`O,5;|O!BWQWO,5=tO!B]QWO,5=tO!BbQWO,5=tO9kQ07hO,5=tO;sQWO,5=dOOQO'#Cu'#CuO!BpQ`O,5=aO!BxQ7[O,5=bO!CTQWO,5=dO!CYQpO,5=gO!CbQWO'#KVO>pQWO'#HQO9aQWO'#HSO!CgQWO'#HSO:RQ7[O'#HUO!ClQWO'#HUOOQU,5=j,5=jO!CqQWO'#HVO!DSQWO'#CnO!DXQWO,59OO!DcQWO,59OO!FhQ^O,59OOOQU,59O,59OO!FxQ07hO,59OO%[Q^O,59OO!ITQ^O'#H^OOQU'#H_'#H_OOQU'#H`'#H`O`Q^O,5=vO!IkQWO,5=vO`Q^O,5=|O`Q^O,5>OO!IpQWO,5>QO`Q^O,5>SO!IuQWO,5>VO!IzQ^O,5>]OOQU,5>c,5>cO%[Q^O,5>cO9kQ07hO,5>eOOQU,5>g,5>gO!NUQWO,5>gOOQU,5>i,5>iO!NUQWO,5>iOOQU,5>k,5>kO!NZQ`O'#D[O%[Q^O'#JmO!NxQ`O'#JmO# gQ`O'#DjO# xQ`O'#DjO#$ZQ^O'#DjO#$bQWO'#JlO#$jQWO,5:TO#$oQWO'#EpO#$}QWO'#JzO#%VQWO,5;ZO#%[Q`O'#DjO#%iQ`O'#EUOOQ07b,5:n,5:nO%[Q^O,5:nO#%pQWO,5:nO>pQWO,5;UO!@}Q`O,5;UO!AVQ7[O,5;UO:RQ7[O,5;UO#%xQWO,5@XO#%}Q$ISO,5:rOOQO-E<`-E<`O#'TQ07pO,5:}OCnQ`O,5:qO#'_Q`O,5:qOCnQ`O,5:}O!@rQ07hO,5:qOOQ07`'#Ef'#EfOOQO,5:},5:}O%[Q^O,5:}O#'lQ07hO,5:}O#'wQ07hO,5:}O!@}Q`O,5:qOOQO,5;T,5;TO#(VQ07hO,5:}POOO'#IV'#IVP#(kO!0LbO,58{POOO,58{,58{OOOO-E<V-E<VOOQ07b1G.o1G.oOOOO-E<W-E<WO#(vQpO,59zOOOO-E<Y-E<YOOQ07b1G/d1G/dO#({QrO,5>wO+}Q^O,5>wOOQO,5>},5>}O#)VQ^O'#I]OOQO-E<Z-E<ZO#)dQWO,5@VO#)lQrO,5@VO#)sQWO,5@dOOQ07b1G/j1G/jO%[Q^O,5@eO#){QWO'#IcOOQO-E<a-E<aO#)sQWO,5@dOOQ07`1G0t1G0tOOQ07f1G/u1G/uOOQ07f1G0X1G0XO%[Q^O,5@bO#*aQ07hO,5@bO#*rQ07hO,5@bO#*yQWO,5@aO9ZQWO,5@aO#+RQWO,5@aO#+aQWO'#IfO#*yQWO,5@aOOQ07`1G0s1G0sO!*OQ`O,5:tO!*ZQ`O,5:tOOQO,5:v,5:vO#,RQWO,5:vO#,ZQ7[O1G2sO9aQWO1G2sOOQ07b1G0q1G0qO#,iQ08SO1G0qO#-nQ08QO,5;ROOQ07b'#GR'#GRO#.[Q08SO'#JdO!$aQ^O1G0qO#0dQ7[O'#JnO#0nQWO,5:_O#0sQrO'#JoO%[Q^O'#JoO#0}QWO,5:dOOQ07b'#D['#D[OOQ07b1G0z1G0zO%[Q^O1G0zOOQ07b1G1d1G1dO#1SQWO1G0zO#3kQ08SO1G0{O#3rQ08SO1G0{O#6]Q08SO1G0{O#6dQ08SO1G0{O#8nQ08SO1G0{O#9UQ08SO1G0{O#<OQ08SO1G0{O#<VQ08SO1G0{O#>jQ08SO1G0{O#>wQ08SO1G0{O#@uQ08SO1G0{O#CuQ(CYO'#ChO#EsQ(CYO1G1^O#EzQ(CYO'#JjO!,lQWO1G1dO#F[Q08SO,5?TOOQ07`-E<g-E<gO#GOQ08SO1G0{OOQ07b1G0{1G0{O#IZQ08SO1G1aO#I}Q&jO,5<TO#JVQ&jO,5<UO#J_Q&jO'#FlO#JvQWO'#FkOOQO'#KO'#KOOOQO'#Ig'#IgO#J{Q&jO1G1kOOQ07b1G1k1G1kOOOS1G1v1G1vO#K^Q(CYO'#JiO#KhQWO,5<_O!*fQ^O,5<_OOOS-E<f-E<fOOQ07b1G1i1G1iO#KmQ`O'#J}OOQ07b,5<a,5<aO#KuQ`O,5<aOOQ07b,59e,59eO!&dQ7[O'#DPOOOO'#IZ'#IZO#KzO?MpO,59iOOQ07b,59i,59iO%[Q^O1G1|O!6[QWO'#IkO#LVQ7[O,5<uOOQ07b,5<r,5<rO!(SQ7[O'#InO#LuQ7[O,5=RO!(SQ7[O'#IpO#MhQ7[O,5=TO!&dQ7[O,5=VOOQO1G2O1G2OO#MrQpO'#CqO#NVQpO,5<nO#N^QWO'#KRO9aQWO'#KRO#NlQWO,5<pO!(SQ7[O,5<oO#NqQWO'#GUO#N|QWO,5<oO$ RQpO'#GRO$ `QpO'#KSO$ jQWO'#KSO!&dQ7[O'#KSO$ oQWO,5<sO$ tQ`O'#G^O!4eQ`O'#G^O$!VQWO'#G`O$![QWO'#GbO!3fQWO'#GeO$!aQ07hO'#ImO$!lQ`O,5<wOOQ07f,5<w,5<wO$!sQ`O'#G^O$#RQ`O'#G_O$#ZQ`O'#G_O$#`Q7[O,5=RO$#pQ7[O,5=TOOQ07b,5=W,5=WO!(SQ7[O,5?}O!(SQ7[O,5?}O$$QQWO'#IrO$$]QWO,5?|O$$eQWO,59`O$%UQ7[O,59qOOQ07b,59q,59qO$%wQ7[O,5<fO$&jQ7[O,5<hO@bQWO,5<jOOQ07b,5<k,5<kO$&tQWO,5<qO$&yQ7[O,5<vO$'ZQWO'#JuO!$aQ^O1G1}O$'`QWO1G1}O9ZQWO'#JxO9ZQWO'#EpO%[Q^O'#EpO9ZQWO'#ItO$'eQ07hO,5@rOOQU1G2w1G2wOOQU1G4X1G4XOOQ07b1G/w1G/wO!,iQWO1G/wO$)jQ08SO1G0TOOQU1G2s1G2sO!&dQ7[O1G2sO%[Q^O1G2sO#,^QWO1G2sO$+nQ7[O'#EgOOQ07`,5?{,5?{O$+xQ07hO,5?{OOQU1G.t1G.tO!@rQ07hO1G.tO!@}Q`O1G.tO!AVQ7[O1G.tO$,ZQWO1G0qO$,`QWO'#ChO$,kQWO'#K[O$,sQWO,5=uO$,xQWO'#K[O$,}QWO'#K[O$-]QWO'#IzO$-kQWO,5@uO$-sQrO1G1fOOQ07b1G1h1G1hO9aQWO1G3`O@bQWO1G3`O$-zQWO1G3`O$.PQWO1G3`OOQU1G3`1G3`O!CTQWO1G3OO!&dQ7[O1G2{O$.UQWO1G2{OOQU1G2|1G2|O!&dQ7[O1G2|O$.ZQWO1G2|O$.cQ`O'#GzOOQU1G3O1G3OO!4eQ`O'#IvO!CYQpO1G3ROOQU1G3R1G3ROOQU,5=l,5=lO$.kQ7[O,5=nO9aQWO,5=nO$![QWO,5=pO9UQWO,5=pO!@}Q`O,5=pO!AVQ7[O,5=pO:RQ7[O,5=pO$.yQWO'#KYO$/UQWO,5=qOOQU1G.j1G.jO$/ZQ07hO1G.jO@bQWO1G.jO$/fQWO1G.jO9kQ07hO1G.jO$1kQrO,5@wO$1{QWO,5@wO9ZQWO,5@wO$2WQ^O,5=xO$2_QWO,5=xOOQU1G3b1G3bO`Q^O1G3bOOQU1G3h1G3hOOQU1G3j1G3jO>kQWO1G3lO$2dQ^O1G3nO$6hQ^O'#HmOOQU1G3q1G3qO$6uQWO'#HsO>pQWO'#HuOOQU1G3w1G3wO$6}Q^O1G3wO9kQ07hO1G3}OOQU1G4P1G4POOQ07`'#GY'#GYO9kQ07hO1G4RO9kQ07hO1G4TO$;UQWO,5@XO!*fQ^O,5;[O9ZQWO,5;[O>pQWO,5:UO!*fQ^O,5:UO!@}Q`O,5:UO$;ZQ(CYO,5:UOOQO,5;[,5;[O$;eQ`O'#I^O$;{QWO,5@WOOQ07b1G/o1G/oO$<TQ`O'#IdO$<_QWO,5@fOOQ07`1G0u1G0uO# xQ`O,5:UOOQO'#Ia'#IaO$<gQ`O,5:pOOQ07f,5:p,5:pO#%sQWO1G0YOOQ07b1G0Y1G0YO%[Q^O1G0YOOQ07b1G0p1G0pO>pQWO1G0pO!@}Q`O1G0pO!AVQ7[O1G0pOOQ07`1G5s1G5sO!@rQ07hO1G0]OOQO1G0i1G0iO%[Q^O1G0iO$<nQ07hO1G0iO$<yQ07hO1G0iO!@}Q`O1G0]OCnQ`O1G0]O$=XQ07hO1G0iOOQO1G0]1G0]O$=mQ08SO1G0iPOOO-E<T-E<TPOOO1G.g1G.gOOOO1G/f1G/fO$=wQpO,5<eO$>PQrO1G4cOOQO1G4i1G4iO%[Q^O,5>wO$>ZQWO1G5qO$>cQWO1G6OO$>kQrO1G6PO9ZQWO,5>}O$>uQ08SO1G5|O%[Q^O1G5|O$?VQ07hO1G5|O$?hQWO1G5{O$?hQWO1G5{O9ZQWO1G5{O$?pQWO,5?QO9ZQWO,5?QOOQO,5?Q,5?QO$@UQWO,5?QO$'ZQWO,5?QOOQO-E<d-E<dOOQO1G0`1G0`OOQO1G0b1G0bO!,lQWO1G0bOOQU7+(_7+(_O!&dQ7[O7+(_O%[Q^O7+(_O$@dQWO7+(_O$@oQ7[O7+(_O$@}Q08SO,5=RO$CYQ08SO,5=TO$EeQ08SO,5=RO$GvQ08SO,5=TO$JXQ08SO,59qO$LaQ08SO,5<fO$NlQ08SO,5<hO%!wQ08SO,5<vOOQ07b7+&]7+&]O%%YQ08SO7+&]O%%|Q7[O'#I_O%&WQWO,5@YOOQ07b1G/y1G/yO%&`Q^O'#I`O%&mQWO,5@ZO%&uQrO,5@ZOOQ07b1G0O1G0OO%'PQWO7+&fOOQ07b7+&f7+&fO%'UQ(CYO,5:eO%[Q^O7+&xO%'`Q(CYO,5:]O%'mQ(CYO,5:iO%'wQ(CYO,5:kOOQ07b7+'O7+'OOOQO1G1o1G1oOOQO1G1p1G1pO%(RQtO,5<WO!*fQ^O,5<VOOQO-E<e-E<eOOQ07b7+'V7+'VOOOS7+'b7+'bOOOS1G1y1G1yO%(^QWO1G1yOOQ07b1G1{1G1{O%(cQpO,59kOOOO-E<X-E<XOOQ07b1G/T1G/TO%(jQ08SO7+'hOOQ07b,5?V,5?VO%)^QpO,5?VOOQ07b1G2a1G2aP!&dQ7[O'#IkPOQ07b-E<i-E<iO%)|Q7[O,5?YOOQ07b-E<l-E<lO%*oQ7[O,5?[OOQ07b-E<n-E<nO%*yQpO1G2qOOQ07b1G2Y1G2YO%+QQWO'#IjO%+`QWO,5@mO%+`QWO,5@mO%+hQWO,5@mO%+sQWO,5@mOOQO1G2[1G2[O%,RQ7[O1G2ZO!(SQ7[O1G2ZO%,cQ!LQO'#IlO%,sQWO,5@nO!&dQ7[O,5@nO%,{QpO,5@nOOQ07b1G2_1G2_OOQ07`,5<x,5<xOOQ07`,5<y,5<yO$'ZQWO,5<yOC_QWO,5<yO!@}Q`O,5<xOOQO'#Ga'#GaO%-VQWO,5<zOOQ07`,5<|,5<|O$'ZQWO,5=POOQO,5?X,5?XOOQO-E<k-E<kOOQ07f1G2c1G2cO!4eQ`O,5<xO%-_QWO,5<yO$!VQWO,5<zO!4eQ`O,5<yO!(SQ7[O'#InO%.RQ7[O1G2mO!(SQ7[O'#IpO%.tQ7[O1G2oO%/OQ7[O1G5iO%/YQ7[O1G5iOOQO,5?^,5?^OOQO-E<p-E<pOOQO1G.z1G.zO!7{Q`O,59sO%[Q^O,59sO%/gQWO1G2UO!(SQ7[O1G2]O%/lQ08SO7+'iOOQ07b7+'i7+'iO!$aQ^O7+'iO%0`QWO,5;[OOQ07`,5?`,5?`OOQ07`-E<r-E<rOOQ07b7+%c7+%cO%0eQpO'#KTO#%sQWO7+(_O%0oQrO7+(_O$@gQWO7+(_O%0vQ08QO'#ChO%1ZQ08QO,5<}O%1{QWO,5<}OOQ07`1G5g1G5gOOQU7+$`7+$`O!@rQ07hO7+$`O!@}Q`O7+$`O!$aQ^O7+&]O%2QQWO'#IyO%2iQWO,5@vOOQO1G3a1G3aO9aQWO,5@vO%2iQWO,5@vO%2qQWO,5@vOOQO,5?f,5?fOOQO-E<x-E<xOOQ07b7+'Q7+'QO%2vQWO7+(zO9kQ07hO7+(zO9aQWO7+(zO@bQWO7+(zOOQU7+(j7+(jO%2{Q08QO7+(gO!&dQ7[O7+(gO%3VQpO7+(hOOQU7+(h7+(hO!&dQ7[O7+(hO%3^QWO'#KXO%3iQWO,5=fOOQO,5?b,5?bOOQO-E<t-E<tOOQU7+(m7+(mO%4xQ`O'#HTOOQU1G3Y1G3YO!&dQ7[O1G3YO%[Q^O1G3YO%5PQWO1G3YO%5[Q7[O1G3YO9kQ07hO1G3[O$![QWO1G3[O9UQWO1G3[O!@}Q`O1G3[O!AVQ7[O1G3[O%5jQWO'#IxO%6OQWO,5@tO%6WQ`O,5@tOOQ07`1G3]1G3]OOQU7+$U7+$UO@bQWO7+$UO9kQ07hO7+$UO%6cQWO7+$UO%[Q^O1G6cO%[Q^O1G6dO%6hQ07hO1G6cO%6rQ^O1G3dO%6yQWO1G3dO%7OQ^O1G3dOOQU7+(|7+(|O9kQ07hO7+)WO`Q^O7+)YOOQU'#K_'#K_OOQU'#I{'#I{O%7VQ^O,5>XOOQU,5>X,5>XO%[Q^O'#HnO%7dQWO'#HpOOQU,5>_,5>_O9ZQWO,5>_OOQU,5>a,5>aOOQU7+)c7+)cOOQU7+)i7+)iOOQU7+)m7+)mOOQU7+)o7+)oO%7iQ`O1G5sO%7}Q(CYO1G0vO%8XQWO1G0vOOQO1G/p1G/pO%8dQ(CYO1G/pO>pQWO1G/pO!*fQ^O'#DjOOQO,5>x,5>xOOQO-E<[-E<[OOQO,5?O,5?OOOQO-E<b-E<bO!@}Q`O1G/pOOQO-E<_-E<_OOQ07f1G0[1G0[OOQ07b7+%t7+%tO#%sQWO7+%tOOQ07b7+&[7+&[O>pQWO7+&[O!@}Q`O7+&[OOQO7+%w7+%wO$=mQ08SO7+&TOOQO7+&T7+&TO%[Q^O7+&TO%8nQ07hO7+&TO!@rQ07hO7+%wO!@}Q`O7+%wO%8yQ07hO7+&TO%9XQ08SO7++hO%[Q^O7++hO%9iQWO7++gO%9iQWO7++gOOQO1G4l1G4lO9ZQWO1G4lO%9qQWO1G4lOOQO7+%|7+%|O#%sQWO<<KyO%0oQrO<<KyO%:PQWO<<KyOOQU<<Ky<<KyO!&dQ7[O<<KyO%[Q^O<<KyO%:XQWO<<KyO%:dQ08SO,5?YO%<oQ08SO,5?[O%>zQ08SO1G2ZO%A]Q08SO1G2mO%ChQ08SO1G2oO%EsQ7[O,5>yOOQO-E<]-E<]O%E}QrO,5>zO%[Q^O,5>zOOQO-E<^-E<^O%FXQWO1G5uOOQ07b<<JQ<<JQO%FaQ(CYO1G0qO%HkQ(CYO1G0{O%HrQ(CYO1G0{O%JvQ(CYO1G0{O%J}Q(CYO1G0{O%LrQ(CYO1G0{O%MYQ(CYO1G0{O& mQ(CYO1G0{O& tQ(CYO1G0{O&#rQ(CYO1G0{O&$PQ(CYO1G0{O&%}Q(CYO1G0{O&&bQ08SO<<JdO&'gQ(CYO1G0{O&)]Q(CYO'#JdO&+`Q(CYO1G1aO&+mQ(CYO1G0TO!*fQ^O'#FnOOQO'#KP'#KPOOQO1G1r1G1rO&+wQWO1G1qO&+|Q(CYO,5?TOOOS7+'e7+'eOOOO1G/V1G/VOOQ07b1G4q1G4qO!(SQ7[O7+(]O&,WQWO,5?UO9aQWO,5?UOOQO-E<h-E<hO&,fQWO1G6XO&,fQWO1G6XO&,nQWO1G6XO&,yQ7[O7+'uO&-ZQpO,5?WO&-eQWO,5?WO!&dQ7[O,5?WOOQO-E<j-E<jO&-jQpO1G6YO&-tQWO1G6YOOQ07`1G2e1G2eO$'ZQWO1G2eOOQ07`1G2d1G2dO&-|QWO1G2fO!&dQ7[O1G2fOOQ07`1G2k1G2kO!@}Q`O1G2dOC_QWO1G2eO&.RQWO1G2fO&.ZQWO1G2eO&.}Q7[O,5?YOOQ07b-E<m-E<mO&/pQ7[O,5?[OOQ07b-E<o-E<oO!(SQ7[O7++TOOQ07b1G/_1G/_O&/zQWO1G/_OOQ07b7+'p7+'pO&0PQ7[O7+'wO&0aQ08SO<<KTOOQ07b<<KT<<KTO&1TQWO1G0vO!&dQ7[O'#IsO&1YQWO,5@oO!&dQ7[O1G2iOOQU<<Gz<<GzO!@rQ07hO<<GzO&1bQ08SO<<IwOOQ07b<<Iw<<IwOOQO,5?e,5?eO&2UQWO,5?eO&2ZQWO,5?eOOQO-E<w-E<wO&2iQWO1G6bO&2iQWO1G6bO9aQWO1G6bO@bQWO<<LfOOQU<<Lf<<LfO&2qQWO<<LfO9kQ07hO<<LfOOQU<<LR<<LRO%2{Q08QO<<LROOQU<<LS<<LSO%3VQpO<<LSO&2vQ`O'#IuO&3RQWO,5@sO!*fQ^O,5@sOOQU1G3Q1G3QO&3ZQ^O'#JmOOQO'#Iw'#IwO9kQ07hO'#IwO&3eQ`O,5=oOOQU,5=o,5=oO&3lQ`O'#EcO&4QQWO7+(tO&4VQWO7+(tOOQU7+(t7+(tO!&dQ7[O7+(tO%[Q^O7+(tO&4_QWO7+(tOOQU7+(v7+(vO9kQ07hO7+(vO$![QWO7+(vO9UQWO7+(vO!@}Q`O7+(vO&4jQWO,5?dOOQO-E<v-E<vOOQO'#HW'#HWO&4uQWO1G6`O9kQ07hO<<GpOOQU<<Gp<<GpO@bQWO<<GpO&4}QWO7++}O&5SQWO7+,OO%[Q^O7++}O%[Q^O7+,OOOQU7+)O7+)OO&5XQWO7+)OO&5^Q^O7+)OO&5eQWO7+)OOOQU<<Lr<<LrOOQU<<Lt<<LtOOQU-E<y-E<yOOQU1G3s1G3sO&5jQWO,5>YOOQU,5>[,5>[O&5oQWO1G3yO9ZQWO7+&bO!*fQ^O7+&bOOQO7+%[7+%[O&5tQ(CYO1G6PO>pQWO7+%[OOQ07b<<I`<<I`OOQ07b<<Iv<<IvO>pQWO<<IvOOQO<<Io<<IoO$=mQ08SO<<IoO%[Q^O<<IoOOQO<<Ic<<IcO!@rQ07hO<<IcO&6OQ07hO<<IoO&6ZQ08SO<= SO&6kQWO<= ROOQO7+*W7+*WO9ZQWO7+*WOOQUANAeANAeO&6sQWOANAeO!&dQ7[OANAeO#%sQWOANAeO%0oQrOANAeO%[Q^OANAeO&6{Q08SO7+'uO&9^Q08SO,5?YO&;iQ08SO,5?[O&=tQ08SO7+'wO&@VQrO1G4fO&@aQ(CYO7+&]O&BeQ(CYO,5=RO&DlQ(CYO,5=TO&D|Q(CYO,5=RO&E^Q(CYO,5=TO&EnQ(CYO,59qO&GqQ(CYO,5<fO&ItQ(CYO,5<hO&KwQ(CYO,5<vO&MmQ(CYO7+'hO&MzQ(CYO7+'iO&NXQWO,5<YOOQO7+']7+']O&N^Q7[O<<KwOOQO1G4p1G4pO&NeQWO1G4pO&NpQWO1G4pO' OQWO7++sO' OQWO7++sO!&dQ7[O1G4rO' WQpO1G4rO' bQWO7++tOOQ07`7+(P7+(PO$'ZQWO7+(QO' jQpO7+(QOOQ07`7+(O7+(OO$'ZQWO7+(PO' qQWO7+(QO!&dQ7[O7+(QOC_QWO7+(PO' vQ7[O<<NoOOQ07b7+$y7+$yO'!QQpO,5?_OOQO-E<q-E<qO'![Q08QO7+(TOOQUAN=fAN=fO9aQWO1G5POOQO1G5P1G5PO'!lQWO1G5PO'!qQWO7++|O'!qQWO7++|O9kQ07hOANBQO@bQWOANBQOOQUANBQANBQOOQUANAmANAmOOQUANAnANAnO'!yQWO,5?aOOQO-E<s-E<sO'#UQ(CYO1G6_O'%fQrO'#ChOOQO,5?c,5?cOOQO-E<u-E<uOOQU1G3Z1G3ZO&3ZQ^O,5<zOOQU<<L`<<L`O!&dQ7[O<<L`O&4QQWO<<L`O'%pQWO<<L`O%[Q^O<<L`OOQU<<Lb<<LbO9kQ07hO<<LbO$![QWO<<LbO9UQWO<<LbO'%xQ`O1G5OO'&TQWO7++zOOQUAN=[AN=[O9kQ07hOAN=[OOQU<= i<= iOOQU<= j<= jO'&]QWO<= iO'&bQWO<= jOOQU<<Lj<<LjO'&gQWO<<LjO'&lQ^O<<LjOOQU1G3t1G3tO>pQWO7+)eO'&sQWO<<I|O''OQ(CYO<<I|OOQO<<Hv<<HvOOQ07bAN?bAN?bOOQOAN?ZAN?ZO$=mQ08SOAN?ZOOQOAN>}AN>}O%[Q^OAN?ZOOQO<<Mr<<MrOOQUG27PG27PO!&dQ7[OG27PO#%sQWOG27PO''YQWOG27PO%0oQrOG27PO''bQ(CYO<<JdO''oQ(CYO1G2ZO')eQ(CYO,5?YO'+hQ(CYO,5?[O'-kQ(CYO1G2mO'/nQ(CYO1G2oO'1qQ(CYO<<KTO'2OQ(CYO<<IwOOQO1G1t1G1tO!(SQ7[OANAcOOQO7+*[7+*[O'2]QWO7+*[O'2hQWO<= _O'2pQpO7+*^OOQ07`<<Kl<<KlO$'ZQWO<<KlOOQ07`<<Kk<<KkO'2zQpO<<KlO$'ZQWO<<KkOOQO7+*k7+*kO9aQWO7+*kO'3RQWO<= hOOQUG27lG27lO9kQ07hOG27lO!*fQ^O1G4{O'3ZQWO7++yO&4QQWOANAzOOQUANAzANAzO!&dQ7[OANAzO'3cQWOANAzOOQUANA|ANA|O9kQ07hOANA|O$![QWOANA|OOQO'#HX'#HXOOQO7+*j7+*jOOQUG22vG22vOOQUANETANETOOQUANEUANEUOOQUANBUANBUO'3kQWOANBUOOQU<<MP<<MPO!*fQ^OAN?hOOQOG24uG24uO$=mQ08SOG24uO#%sQWOLD,kOOQULD,kLD,kO!&dQ7[OLD,kO'3pQWOLD,kO'3xQ(CYO7+'uO'5nQ(CYO,5?YO'7qQ(CYO,5?[O'9tQ(CYO7+'wO';jQ7[OG26}OOQO<<Mv<<MvOOQ07`ANAWANAWO$'ZQWOANAWOOQ07`ANAVANAVOOQO<<NV<<NVOOQULD-WLD-WO';zQ(CYO7+*gOOQUG27fG27fO&4QQWOG27fO!&dQ7[OG27fOOQUG27hG27hO9kQ07hOG27hOOQUG27pG27pO'<UQ(CYOG25SOOQOLD*aLD*aOOQU!$(!V!$(!VO#%sQWO!$(!VO!&dQ7[O!$(!VO'<`Q08SOG26}OOQ07`G26rG26rOOQULD-QLD-QO&4QQWOLD-QOOQULD-SLD-SOOQU!)9Eq!)9EqO#%sQWO!)9EqOOQU!$(!l!$(!lOOQU!.K;]!.K;]O'>qQ(CYOG26}O!*fQ^O'#DyO1PQWO'#EWO'@gQrO'#JiO!*fQ^O'#DqO'@nQ^O'#D}O'@uQrO'#ChO'C]QrO'#ChO!*fQ^O'#EPO'CmQ^O,5;VO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O'#IiO'EpQWO,5<eO'ExQ7[O,5;aO'GcQ7[O,5;aO!*fQ^O,5;uO!&dQ7[O'#GgO'ExQ7[O'#GgO!&dQ7[O'#GiO'ExQ7[O'#GiO1SQWO'#DVO1SQWO'#DVO!&dQ7[O'#FzO'ExQ7[O'#FzO!&dQ7[O'#F|O'ExQ7[O'#F|O!&dQ7[O'#G[O'ExQ7[O'#G[O!*fQ^O,5:iO!*fQ^O,5@eO'CmQ^O1G0qO'GjQ(CYO'#ChO!*fQ^O1G1|O!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O,5<oO'ExQ7[O,5<oO'CmQ^O1G1}O!*fQ^O7+&xO!&dQ7[O1G2ZO'ExQ7[O1G2ZO!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O1G2]O'ExQ7[O1G2]O'CmQ^O7+'iO'CmQ^O7+&]O!&dQ7[OANAcO'ExQ7[OANAcO'GtQWO'#EkO'GyQWO'#EkO'HRQWO'#FZO'HWQWO'#EuO'H]QWO'#JyO'HhQWO'#JwO'HsQWO,5;VO'HxQ7[O,5<bO'IPQWO'#GTO'IUQWO'#GTO'IZQWO,5<cO'IcQWO,5;VO'IkQ(CYO1G1^O'IrQWO,5<oO'IwQWO,5<oO'I|QWO,5<qO'JRQWO,5<qO'JWQWO1G1}O'J]QWO1G0qO'JbQ7[O<<KwO'JiQ7[O<<KwO7hQ7[O'#FxO9UQWO'#FwOA]QWO'#EjO!*fQ^O,5;rO!3fQWO'#GTO!3fQWO'#GTO!3fQWO'#GVO!3fQWO'#GVO!(SQ7[O7+(]O!(SQ7[O7+(]O%*yQpO1G2qO%*yQpO1G2qO!&dQ7[O,5=VO!&dQ7[O,5=V",
  stateData: "'Km~O'tOS'uOSSOS'vRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!twO!wxO!{]O#s!PO$T|O%b}O%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO&P!WO&V!XO&X!YO&Z!ZO&]![O&`!]O&f!^O&l!_O&n!`O&p!aO&r!bO&t!cO'{SO'}TO(QUO(XVO(g[O(tiO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`!vOo!nO!P!oO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!wO#S!pO#T!pO#W!yO#X!yO'|!lO'}TO(QUO([!mO(g!sO~O'v!zO~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X'r[X(X[X(h[X(o[X(p[X~O!d$|X~P(qO^!|O'}#OO(O!|O(P#OO~O^#PO(P#OO(Q#OO(R#PO~Ot#RO!R#SO(Y#SO(Z#UO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{:hO'}TO(QUO(XVO(g[O(tiO~O!X#YO!Y#VO!V(_P!V(lP~P+}O!Z#bO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'}TO(QUO(XVO(g[O(tiO~Ol#lO!X#hO!{]O#e#kO#f#hO'{:iO!j(iP~P.iO!k#nO'{#mO~O!w#rO!{]O%b#sO~O#g#tO~O!d#uO#g#tO~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y$aO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`(]X'r(]X'p(]X!j(]X!V(]X![(]X%c(]X!d(]X~P1qO#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X![(^X%c(^X~O`(^X!i(^X'r(^X'p(^X!V(^X!j(^Xr(^X!d(^X~P4XO#[$eO~O$Y$gO$[$fO$c$lO~ORfO![$mO$f$nO$h$pO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{$rO'}TO(QUO(X$uO(o$}O(p%POf(UP~O!k%bO~O!P%eO![%fO'{%dO~O!d%jO~O`%kO'r%kO~O'|!lO~P%[O%h%rO~P%[Og%VO!k%bO'{%dO'|!lO~Od%yO!k%bO'{%dO~O#r$SO~O|&OO![%{O!k%}O%d&RO'{%dO'|!lO'}TO(QUO_(}P~O!w#rO~O%m&TO!P(yX![(yX'{(yX~O'{&UO~O!t&ZO#s!PO%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO~Oc&`Od&_O!w&]O%b&^O%u&[O~P;xOc&cOdyO![&bO!t&ZO!wxO!{]O#s!PO%b}O%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO~Oa&fO#[&iO%d&dO'|!lO~P<}O!k&jO!t&nO~O!k#nO~O![XO~O`%kO'q&vO'r%kO~O`%kO'q&yO'r%kO~O`%kO'q&{O'r%kO~O'p[X!V[Xr[X!j[X&T[X![[X%c[X!d[X~P(qO!_'YO!`'RO!a'RO'|!lO'}TO(QUO~Oo'PO!P'OO!X'SO([&}O!Z(`P!Z(nP~P@UOj']O!['ZO'{%dO~Od'bO!k%bO'{%dO~O|&OO!k%}O~Oo!nO!P!oO!{:dO#P!pO#Q!pO#S!pO#T!pO'|!lO'}TO(QUO([!mO(g!sO~O!_'hO!`'gO!a'gO#R!pO#W'iO#X'iO~PApO`%kOg%VO!d#uO!k%bO'r%kO(h'kO~O!o'oO#['mO~PCOOo!nO!P!oO'}TO(QUO([!mO(g!sO~O![XOo(eX!P(eX!_(eX!`(eX!a(eX!{(eX#P(eX#Q(eX#R(eX#S(eX#T(eX#W(eX#X(eX'|(eX'}(eX(Q(eX([(eX(g(eX~O!`'gO!a'gO'|!lO~PCnO'w'sO'x'sO'y'uO~O^!|O'}'wO(O!|O(P'wO~O^#PO(P'wO(Q'wO(R#PO~Ot#RO!R#SO(Y#SO(Z'{O~O!X'}O!V'PX!V'VX!Y'PX!Y'VX~P+}O!Y(PO!V(_X~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y(PO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O!V(_X~PGbO!V(UO~O!V(kX!Y(kX!d(kX!j(kX(h(kX~O#[(kX#g#`X!Z(kX~PIhO#[(VO!V(mX!Y(mX~O!Y(WO!V(lX~O!V(ZO~O#[$eO~PIhO!Z([O~P`O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!maZ!man!ma!Y!ma!h!ma!o!ma#j!ma#k!ma#l!ma#m!ma#n!ma#o!ma#p!ma#q!ma#r!ma#t!ma#v!ma#x!ma#y!ma(h!ma(o!ma(p!ma~O`!ma'r!ma'p!ma!V!ma!j!mar!ma![!ma%c!ma!d!ma~PKOO!j(]O~O!d#uO#[(^O(h'kO!Y(jX`(jX'r(jX~O!j(jX~PMnO!P%eO![%fO!{]O#e(cO#f(bO'{%dO~O!Y(dO!j(iX~O!j(fO~O!P%eO![%fO#f(bO'{%dO~OP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!i(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O!d#uO!j(^X~P! [O|(gO}(hO!i#wO!k#xO!{!za!P!za~O!w!za%b!za![!za#e!za#f!za'{!za~P!#`O!w(lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#g(rO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~Of(bP~P!(SO!X(vO!j(cP~P%[O([(xO(g[O~O!P(zO!k#xO([(xO(g[O~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O})]O!k#xO~O!Y$aO`$ma'r$ma'p$ma!j$ma!V$ma![$ma%c$ma!d$ma~O#s)aO~P!&dO|)dO!d)cO![$ZX$W$ZX$Y$ZX$[$ZX$c$ZX~O!d)cO![(qX$W(qX$Y(qX$[(qX$c(qX~O|)dO~P!.OO|)dO![(qX$W(qX$Y(qX$[(qX$c(qX~O![)fO$W)jO$Y)eO$[)eO$c)kO~O!X)nO~P!*fO$Y$gO$[$fO$c)rO~Oj$uX|$uX!P$uX!i$uX(o$uX(p$uX~OfiXf$uXjiX!YiX#[iX~P!/tOo)tO~Ot)uO(Y)vO(Z)xO~Oj*RO|)zO!P){O(o$}O(p%PO~Of)yO~P!0}Of*SO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~O!X*WO'{*TO!j(uP~P!1lO#g*YO~O!k*ZO~O!X*`O'{*]O!V(vP~P!1lOn*lO!P*dO!_*jO!`*cO!a*cO!k*ZO#W*kO%Y*fO'|!lO([!mO~O!Z*iO~P!3xO!i#wOj(WX|(WX!P(WX(o(WX(p(WX!Y(WX#[(WX~Of(WX#|(WX~P!4qOj*qO#[*pOf(VX!Y(VX~O!Y*rOf(UX~O'{&UOf(UP~O!k*yO~O'{(pO~Ol*}O!P%eO!X#hO![%fO!{]O#e#kO#f#hO'{%dO!j(iP~O!d#uO#g+OO~O!P%eO!X+QO!Y(WO![%fO'{%dO!V(lP~Oo'VO!P+SO!X+RO'}TO(QUO([(xO~O!Z(nP~P!7lO!Y+TO`(zX'r(zX~OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`!ea!Y!ea'r!ea'p!ea!V!ea!j!ear!ea![!ea%c!ea!d!ea~P!8dO|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qaZ!qan!qa!Y!qa!h!qa!o!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#t!qa#v!qa#x!qa#y!qa(h!qa(o!qa(p!qa~O`!qa'r!qa'p!qa!V!qa!j!qar!qa![!qa%c!qa!d!qa~P!:}O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!saZ!san!sa!Y!sa!h!sa!o!sa#j!sa#k!sa#l!sa#m!sa#n!sa#o!sa#p!sa#q!sa#r!sa#t!sa#v!sa#x!sa#y!sa(h!sa(o!sa(p!sa~O`!sa'r!sa'p!sa!V!sa!j!sar!sa![!sa%c!sa!d!sa~P!=hOg%VOj+^O!['ZO%c+]O~O!d+`O`(TX![(TX'r(TX!Y(TX~O`%kO![XO'r%kO~Og%VO!k%bO~Og%VO!k%bO'{%dO~O!d#uO#g(rO~Oa+kO%d+lO'{+hO'}TO(QUO!Z)OP~O!Y+mO_(}X~OZ+qO~O_+rO~O![%{O'{%dO'|!lO_(}P~Og%VO#[+wO~Og%VOj+zO![$|O~O![+|O~O|,OO![XO~O%h%rO~O!w,TO~Od,YO~Oa,ZO'{#mO'}TO(QUO!Z(|P~Od%yO~O%d!QO'{&UO~P<}OZ,`O_,_O~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!kZO!nYO!oYO!pYO!rvO!wxO!{]O%b}O'}TO(QUO(XVO(g[O(tiO~O![!eO!t!gO$T!kO'{!dO~P!DkO_,_O`%kO'r%kO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`,eO!twO#s!OO%f!OO%g!OO%h!OO~P!GTO!k&jO~O&V,kO~O![,mO~O&h,oO&j,pOP&eaQ&eaR&eaX&ea`&eac&ead&eal&ean&eao&eap&eav&eax&eaz&ea!P&ea!T&ea!U&ea![&ea!f&ea!k&ea!n&ea!o&ea!p&ea!r&ea!t&ea!w&ea!{&ea#s&ea$T&ea%b&ea%d&ea%f&ea%g&ea%h&ea%k&ea%m&ea%p&ea%q&ea%s&ea&P&ea&V&ea&X&ea&Z&ea&]&ea&`&ea&f&ea&l&ea&n&ea&p&ea&r&ea&t&ea'p&ea'{&ea'}&ea(Q&ea(X&ea(g&ea(t&ea!Z&ea&^&eaa&ea&c&ea~O'{,uO~Og!bX!Y!OX!Y!bX!Z!OX!Z!bX!d!OX!d!bX!k!bX#[!OX~O!d,zO#[,yOg(aX!Y#dX!Y(aX!Z#dX!Z(aX!d(aX!k(aX~Og%VO!d,|O!k%bO!Y!^X!Z!^X~Oo!nO!P!oO'}TO(QUO([!mO~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'}TO(QUO(XVO(g[O(t<YO~O'{;]O~P#!ZO!Y-QO!Z(`X~O!Z-SO~O!d,zO#[,yO!Y#dX!Z#dX~O!Y-TO!Z(nX~O!Z-VO~O!`-WO!a-WO'|!lO~P# xO!Z-ZO~P'_Oj-^O!['ZO~O!V-cO~Oo!za!_!za!`!za!a!za#P!za#Q!za#R!za#S!za#T!za#W!za#X!za'|!za'}!za(Q!za([!za(g!za~P!#`O!o-hO#[-fO~PCOO!`-jO!a-jO'|!lO~PCnO`%kO#[-fO'r%kO~O`%kO!d#uO#[-fO'r%kO~O`%kO!d#uO!o-hO#[-fO'r%kO(h'kO~O'w'sO'x'sO'y-oO~Or-pO~O!V'Pa!Y'Pa~P!8dO!X-tO!V'PX!Y'PX~P%[O!Y(PO!V(_a~O!V(_a~PGbO!Y(WO!V(la~O!P%eO!X-xO![%fO'{%dO!V'VX!Y'VX~O#[-zO!Y(ja!j(ja`(ja'r(ja~O!d#uO~P#*aO!Y(dO!j(ia~O!P%eO![%fO#f.OO'{%dO~Ol.TO!P%eO!X.QO![%fO!{]O#e.SO#f.QO'{%dO!Y'YX!j'YX~O}.XO!k#xO~Og%VOj.[O!['ZO%c.ZO~O`#_i!Y#_i'r#_i'p#_i!V#_i!j#_ir#_i![#_i%c#_i!d#_i~P!8dOj<fO|)zO!P){O(o$}O(p%PO~O#g#Za`#Za#[#Za'r#Za!Y#Za!j#Za![#Za!V#Za~P#-]O#g(WXP(WXZ(WX`(WXn(WX}(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX'r(WX(X(WX(h(WX!j(WX!V(WX'p(WXr(WX![(WX%c(WX!d(WX~P!4qO!Y.iOf(bX~P!0}Of.kO~O!Y.lO!j(cX~P!8dO!j.oO~O!V.qO~OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#ii`#iin#ii!Y#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#j#ii~P#1XO#j$OO~P#1XOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO(XVOZ#ii`#ii!Y#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~On#ii~P#3yOn$QO~P#3yOP$]On$QO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO(XVO`#ii!Y#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P#6kOZ$dO!h$SO#o$SO#p$SO#q$cO#r$SO~P#6kOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO(p#}O`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii(o#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v$VO~P#9lO#v#ii~P#9lOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v#ii(o#ii(p#ii~P#<^O#v$VO(o#|O(p#}O~P#<^OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO(XVO(o#|O(p#}O~O`#ii!Y#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#?UOP[XZ[Xn[X|[X}[X!P[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X!Y[X!Z[X~O#|[X~P#AoOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO#y:vO(XVO(h$ZO(o#|O(p#}O~O#|.sO~P#C|O#[:{O$O:{O#|(^X!Z(^X~P! [O`']a!Y']a'r']a'p']a!j']a!V']ar']a![']a%c']a!d']a~P!8dOP#iiZ#ii`#iin#ii}#ii!Y#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(X#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#-]O`#}i!Y#}i'r#}i'p#}i!V#}i!j#}ir#}i![#}i%c#}i!d#}i~P!8dO$Y.xO$[.xO~O$Y.yO$[.yO~O!d)cO#[.zO![$`X$W$`X$Y$`X$[$`X$c$`X~O!X.{O~O![)fO$W.}O$Y)eO$[)eO$c/OO~O!Y:wO!Z(]X~P#C|O!Z/PO~O!d)cO$c(qX~O$c/RO~Ot)uO(Y)vO(Z/UO~O!V/YO~P!&dO(o$}Oj%Za|%Za!P%Za(p%Za!Y%Za#[%Za~Of%Za#|%Za~P#L^O(p%POj%]a|%]a!P%]a(o%]a!Y%]a#[%]a~Of%]a#|%]a~P#MPO!YeX!deX!jeX!j$uX(heX~P!/tO!j/bO~P#-]O!Y/cO!d#uO(h'kO!j(uX~O!j/hO~O!X*WO'{%dO!j(uP~O#g/jO~O!V$uX!Y$uX!d$|X~P!/tO!Y/kO!V(vX~P#-]O!d/mO~O!V/oO~Og%VOn/sO!d#uO!k%bO(h'kO~O'{/uO~O!d+`O~O`%kO!Y/yO'r%kO~O!Z/{O~P!3xO!`/|O!a/|O'|!lO([!mO~O!P0OO([!mO~O#W0PO~Of%Za!Y%Za#[%Za#|%Za~P!0}Of%]a!Y%]a#[%]a#|%]a~P!0}O'{&UOf'fX!Y'fX~O!Y*rOf(Ua~Of0YO~O|0ZO}0ZO!P0[Ojya(oya(pya!Yya#[ya~Ofya#|ya~P$$jO|)zO!P){Oj$na(o$na(p$na!Y$na#[$na~Of$na#|$na~P$%`O|)zO!P){Oj$pa(o$pa(p$pa!Y$pa#[$pa~Of$pa#|$pa~P$&RO#g0^O~Of%Oa!Y%Oa#[%Oa#|%Oa~P!0}O!d#uO~O#g0aO~O!Y+TO`(za'r(za~O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qiZ!qin!qi!Y!qi!h!qi!o!qi#j!qi#k!qi#l!qi#m!qi#n!qi#o!qi#p!qi#q!qi#r!qi#t!qi#v!qi#x!qi#y!qi(h!qi(o!qi(p!qi~O`!qi'r!qi'p!qi!V!qi!j!qir!qi![!qi%c!qi!d!qi~P$'pOg%VOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~Ol0kO'{0jO~P$*ZO!d+`O`(Ta![(Ta'r(Ta!Y(Ta~O#g0qO~OZ[X!YeX!ZeX~O!Y0rO!Z)OX~O!Z0tO~OZ0uO~Oa0wO'{+hO'}TO(QUO~O![%{O'{%dO_'nX!Y'nX~O!Y+mO_(}a~O!j0zO~P!8dOZ0}O~O_1OO~O#[1RO~Oj1UO![$|O~O([(xO!Z({P~Og%VOj1_O![1[O%c1^O~OZ1iO!Y1gO!Z(|X~O!Z1jO~O_1lO`%kO'r%kO~O'{#mO'}TO(QUO~O#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O#r1oO&T1pO`(^X!i(^X~P$/qO#[$eO#r1oO&T1pO~O`1rO~P%[O`1tO~O&^1wOP&[iQ&[iR&[iX&[i`&[ic&[id&[il&[in&[io&[ip&[iv&[ix&[iz&[i!P&[i!T&[i!U&[i![&[i!f&[i!k&[i!n&[i!o&[i!p&[i!r&[i!t&[i!w&[i!{&[i#s&[i$T&[i%b&[i%d&[i%f&[i%g&[i%h&[i%k&[i%m&[i%p&[i%q&[i%s&[i&P&[i&V&[i&X&[i&Z&[i&]&[i&`&[i&f&[i&l&[i&n&[i&p&[i&r&[i&t&[i'p&[i'{&[i'}&[i(Q&[i(X&[i(g&[i(t&[i!Z&[ia&[i&c&[i~Oa1}O!Z1{O&c1|O~P`O![XO!k2PO~O&j,pOP&eiQ&eiR&eiX&ei`&eic&eid&eil&ein&eio&eip&eiv&eix&eiz&ei!P&ei!T&ei!U&ei![&ei!f&ei!k&ei!n&ei!o&ei!p&ei!r&ei!t&ei!w&ei!{&ei#s&ei$T&ei%b&ei%d&ei%f&ei%g&ei%h&ei%k&ei%m&ei%p&ei%q&ei%s&ei&P&ei&V&ei&X&ei&Z&ei&]&ei&`&ei&f&ei&l&ei&n&ei&p&ei&r&ei&t&ei'p&ei'{&ei'}&ei(Q&ei(X&ei(g&ei(t&ei!Z&ei&^&eia&ei&c&ei~O!V2VO~O!Y!^a!Z!^a~P#C|Oo!nO!P!oO!X2]O([!mO!Y'QX!Z'QX~P@UO!Y-QO!Z(`a~O!Y'WX!Z'WX~P!7lO!Y-TO!Z(na~O!Z2dO~P'_O`%kO#[2mO'r%kO~O`%kO!d#uO#[2mO'r%kO~O`%kO!d#uO!o2qO#[2mO'r%kO(h'kO~O`%kO'r%kO~P!8dO!Y$aOr$ma~O!V'Pi!Y'Pi~P!8dO!Y(PO!V(_i~O!Y(WO!V(li~O!V(mi!Y(mi~P!8dO!Y(ji!j(ji`(ji'r(ji~P!8dO#[2sO!Y(ji!j(ji`(ji'r(ji~O!Y(dO!j(ii~O!P%eO![%fO!{]O#e2xO#f2wO'{%dO~O!P%eO![%fO#f2wO'{%dO~Oj3PO!['ZO%c3OO~Og%VOj3PO!['ZO%c3OO~O#g%ZaP%ZaZ%Za`%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Zar%Za![%Za%c%Za!d%Za~P#L^O#g%]aP%]aZ%]a`%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]ar%]a![%]a%c%]a!d%]a~P#MPO#g%ZaP%ZaZ%Za`%Zan%Za}%Za!Y%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Za#[%Zar%Za![%Za%c%Za!d%Za~P#-]O#g%]aP%]aZ%]a`%]an%]a}%]a!Y%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]a#[%]ar%]a![%]a%c%]a!d%]a~P#-]O#gyaPyaZya`yanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya'rya(Xya(hya!jya!Vya'pyarya![ya%cya!dya~P$$jO#g$naP$naZ$na`$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na'r$na(X$na(h$na!j$na!V$na'p$nar$na![$na%c$na!d$na~P$%`O#g$paP$paZ$pa`$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa'r$pa(X$pa(h$pa!j$pa!V$pa'p$par$pa![$pa%c$pa!d$pa~P$&RO#g%OaP%OaZ%Oa`%Oan%Oa}%Oa!Y%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa'r%Oa(X%Oa(h%Oa!j%Oa!V%Oa'p%Oa#[%Oar%Oa![%Oa%c%Oa!d%Oa~P#-]O`#_q!Y#_q'r#_q'p#_q!V#_q!j#_qr#_q![#_q%c#_q!d#_q~P!8dOf'RX!Y'RX~P!(SO!Y.iOf(ba~O!X3ZO!Y'SX!j'SX~P%[O!Y.lO!j(ca~O!Y.lO!j(ca~P!8dO!V3^O~O#|!ma!Z!ma~PKOO#|!ea!Y!ea!Z!ea~P#C|O#|!qa!Z!qa~P!:}O#|!sa!Z!sa~P!=hORfO![3pO$a3qO~O!Z3uO~Or3vO~P#-]O`$jq!Y$jq'r$jq'p$jq!V$jq!j$jqr$jq![$jq%c$jq!d$jq~P!8dO!V3wO~P#-]O|)zO!P){O(p%POj'ba(o'ba!Y'ba#['ba~Of'ba#|'ba~P%)eO|)zO!P){Oj'da(o'da(p'da!Y'da#['da~Of'da#|'da~P%*WO(h$ZO~P#-]O!X3zO'{%dO!Y'^X!j'^X~O!Y/cO!j(ua~O!Y/cO!d#uO!j(ua~O!Y/cO!d#uO(h'kO!j(ua~Of$wi!Y$wi#[$wi#|$wi~P!0}O!X4SO'{*]O!V'`X!Y'`X~P!1lO!Y/kO!V(va~O!Y/kO!V(va~P#-]O!d#uO#r4[O~On4_O!d#uO(h'kO~O(o$}Oj%Zi|%Zi!P%Zi(p%Zi!Y%Zi#[%Zi~Of%Zi#|%Zi~P%-jO(p%POj%]i|%]i!P%]i(o%]i!Y%]i#[%]i~Of%]i#|%]i~P%.]Of(Vi!Y(Vi~P!0}O#[4fOf(Vi!Y(Vi~P!0}O!j4iO~O`$kq!Y$kq'r$kq'p$kq!V$kq!j$kqr$kq![$kq%c$kq!d$kq~P!8dO!V4mO~O!Y4nO![(wX~P#-]O!i#wO~P4XO`$uX![$uX%W[X'r$uX!Y$uX~P!/tO%W4pO`kXjkX|kX!PkX![kX'rkX(okX(pkX!YkX~O%W4pO~Oa4vO%d4wO'{+hO'}TO(QUO!Y'mX!Z'mX~O!Y0rO!Z)Oa~OZ4{O~O_4|O~O`%kO'r%kO~P#-]O![$|O~P#-]O!Y5UO#[5WO!Z({X~O!Z5XO~Oo!nO!P5YO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!pO#S!pO#T!pO#W5_O#X!yO'|!lO'}TO(QUO([!mO(g!sO~O!Z5^O~P%3nOj5dO![1[O%c5cO~Og%VOj5dO![1[O%c5cO~Oa5kO'{#mO'}TO(QUO!Y'lX!Z'lX~O!Y1gO!Z(|a~O'}TO(QUO([5mO~O_5qO~O#r5tO&T5uO~PMnO!j5vO~P%[O`5xO~O`5xO~P%[Oa1}O!Z5}O&c1|O~P`O!d6PO~O!d6ROg(ai!Y(ai!Z(ai!d(ai!k(ai~O!Y#di!Z#di~P#C|O#[6SO!Y#di!Z#di~O!Y!^i!Z!^i~P#C|O`%kO#[6]O'r%kO~O`%kO!d#uO#[6]O'r%kO~O!Y(jq!j(jq`(jq'r(jq~P!8dO!Y(dO!j(iq~O!P%eO![%fO#f6dO'{%dO~O!['ZO%c6gO~Oj6jO!['ZO%c6gO~O#g'baP'baZ'ba`'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba'r'ba(X'ba(h'ba!j'ba!V'ba'p'bar'ba!['ba%c'ba!d'ba~P%)eO#g'daP'daZ'da`'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da'r'da(X'da(h'da!j'da!V'da'p'dar'da!['da%c'da!d'da~P%*WO#g$wiP$wiZ$wi`$win$wi}$wi!Y$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi'r$wi(X$wi(h$wi!j$wi!V$wi'p$wi#[$wir$wi![$wi%c$wi!d$wi~P#-]O#g%ZiP%ZiZ%Zi`%Zin%Zi}%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi'r%Zi(X%Zi(h%Zi!j%Zi!V%Zi'p%Zir%Zi![%Zi%c%Zi!d%Zi~P%-jO#g%]iP%]iZ%]i`%]in%]i}%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i'r%]i(X%]i(h%]i!j%]i!V%]i'p%]ir%]i![%]i%c%]i!d%]i~P%.]Of'Ra!Y'Ra~P!0}O!Y'Sa!j'Sa~P!8dO!Y.lO!j(ci~O#|#_i!Y#_i!Z#_i~P#C|OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#iin#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~O#j#ii~P%FnO#j:lO~P%FnOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO(XVOZ#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~On#ii~P%HyOn:nO~P%HyOP$]On:nO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO(XVO#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P%KUOZ:zO!h:pO#o:pO#p:pO#q:yO#r:pO~P%KUOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO(p#}O#x#ii#y#ii#|#ii(h#ii(o#ii!Y#ii!Z#ii~O#v:sO~P%MpO#v#ii~P%MpOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO#x#ii#y#ii#|#ii(h#ii!Y#ii!Z#ii~O#v#ii(o#ii(p#ii~P& {O#v:sO(o#|O(p#}O~P& {OP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO(XVO(o#|O(p#}O~O#y#ii#|#ii(h#ii!Y#ii!Z#ii~P&$^O`#zy!Y#zy'r#zy'p#zy!V#zy!j#zyr#zy![#zy%c#zy!d#zy~P!8dOj<gO|)zO!P){O(o$}O(p%PO~OP#iiZ#iin#ii}#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(X#ii(h#ii!Y#ii!Z#ii~P&'UO!i#wOP(WXZ(WXj(WXn(WX|(WX}(WX!P(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX#|(WX(X(WX(h(WX(o(WX(p(WX!Y(WX!Z(WX~O#|#}i!Y#}i!Z#}i~P#C|O#|!qi!Z!qi~P$'pO!Z6|O~O!Y']a!Z']a~P#C|O!d#uO(h'kO!Y'^a!j'^a~O!Y/cO!j(ui~O!Y/cO!d#uO!j(ui~Of$wq!Y$wq#[$wq#|$wq~P!0}O!V'`a!Y'`a~P#-]O!d7TO~O!Y/kO!V(vi~P#-]O!Y/kO!V(vi~O!V7XO~O!d#uO#r7^O~On7_O!d#uO(h'kO~O|)zO!P){O(p%POj'ca(o'ca!Y'ca#['ca~Of'ca#|'ca~P&.fO|)zO!P){Oj'ea(o'ea(p'ea!Y'ea#['ea~Of'ea#|'ea~P&/XO!V7aO~Of$yq!Y$yq#[$yq#|$yq~P!0}O`$ky!Y$ky'r$ky'p$ky!V$ky!j$kyr$ky![$ky%c$ky!d$ky~P!8dO!d6RO~O!Y4nO![(wa~O`#_y!Y#_y'r#_y'p#_y!V#_y!j#_yr#_y![#_y%c#_y!d#_y~P!8dOZ7fO~Oa7hO'{+hO'}TO(QUO~O!Y0rO!Z)Oi~O_7lO~O([(xO!Y'iX!Z'iX~O!Y5UO!Z({a~OlkO'{7sO~P.iO!Z7vO~P%3nOo!nO!P7wO'}TO(QUO([!mO(g!sO~O![1[O~O![1[O%c7yO~Oj7|O![1[O%c7yO~OZ8RO!Y'la!Z'la~O!Y1gO!Z(|i~O!j8VO~O!j8WO~O!j8ZO~O!j8ZO~P%[O`8]O~O!d8^O~O!j8_O~O!Y(mi!Z(mi~P#C|O`%kO#[8gO'r%kO~O!Y(jy!j(jy`(jy'r(jy~P!8dO!Y(dO!j(iy~O!['ZO%c8jO~O#g$wqP$wqZ$wq`$wqn$wq}$wq!Y$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq'r$wq(X$wq(h$wq!j$wq!V$wq'p$wq#[$wqr$wq![$wq%c$wq!d$wq~P#-]O#g'caP'caZ'ca`'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca'r'ca(X'ca(h'ca!j'ca!V'ca'p'car'ca!['ca%c'ca!d'ca~P&.fO#g'eaP'eaZ'ea`'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea'r'ea(X'ea(h'ea!j'ea!V'ea'p'ear'ea!['ea%c'ea!d'ea~P&/XO#g$yqP$yqZ$yq`$yqn$yq}$yq!Y$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq'r$yq(X$yq(h$yq!j$yq!V$yq'p$yq#[$yqr$yq![$yq%c$yq!d$yq~P#-]O!Y'Si!j'Si~P!8dO#|#_q!Y#_q!Z#_q~P#C|O(o$}OP%ZaZ%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za#|%Za(X%Za(h%Za!Y%Za!Z%Za~Oj%Za|%Za!P%Za(p%Za~P&@nO(p%POP%]aZ%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a#|%]a(X%]a(h%]a!Y%]a!Z%]a~Oj%]a|%]a!P%]a(o%]a~P&BuOj<gO|)zO!P){O(p%PO~P&@nOj<gO|)zO!P){O(o$}O~P&BuO|0ZO}0ZO!P0[OPyaZyajyanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya#|ya(Xya(hya(oya(pya!Yya!Zya~O|)zO!P){OP$naZ$naj$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na#|$na(X$na(h$na(o$na(p$na!Y$na!Z$na~O|)zO!P){OP$paZ$paj$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa#|$pa(X$pa(h$pa(o$pa(p$pa!Y$pa!Z$pa~OP%OaZ%Oan%Oa}%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa#|%Oa(X%Oa(h%Oa!Y%Oa!Z%Oa~P&'UO#|$jq!Y$jq!Z$jq~P#C|O#|$kq!Y$kq!Z$kq~P#C|O!Z8vO~O#|8wO~P!0}O!d#uO!Y'^i!j'^i~O!d#uO(h'kO!Y'^i!j'^i~O!Y/cO!j(uq~O!V'`i!Y'`i~P#-]O!Y/kO!V(vq~O!V8}O~P#-]O!V8}O~Of(Vy!Y(Vy~P!0}O!Y'ga!['ga~P#-]O`%Vq![%Vq'r%Vq!Y%Vq~P#-]OZ9SO~O!Y0rO!Z)Oq~O#[9WO!Y'ia!Z'ia~O!Y5UO!Z({i~P#C|OP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!d%TX#r%TX~P'#`O![1[O%c9[O~O'}TO(QUO([9aO~O!Y1gO!Z(|q~O!j9dO~O!j9eO~O!j9fO~O!j9fO~P%[O#[9iO!Y#dy!Z#dy~O!Y#dy!Z#dy~P#C|O!['ZO%c9nO~O#|#zy!Y#zy!Z#zy~P#C|OP$wiZ$win$wi}$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi#|$wi(X$wi(h$wi!Y$wi!Z$wi~P&'UO|)zO!P){O(p%POP'baZ'baj'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba#|'ba(X'ba(h'ba(o'ba!Y'ba!Z'ba~O|)zO!P){OP'daZ'daj'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da#|'da(X'da(h'da(o'da(p'da!Y'da!Z'da~O(o$}OP%ZiZ%Zij%Zin%Zi|%Zi}%Zi!P%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi#|%Zi(X%Zi(h%Zi(p%Zi!Y%Zi!Z%Zi~O(p%POP%]iZ%]ij%]in%]i|%]i}%]i!P%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i#|%]i(X%]i(h%]i(o%]i!Y%]i!Z%]i~O#|$ky!Y$ky!Z$ky~P#C|O#|#_y!Y#_y!Z#_y~P#C|O!d#uO!Y'^q!j'^q~O!Y/cO!j(uy~O!V'`q!Y'`q~P#-]O!V9wO~P#-]O!Y0rO!Z)Oy~O!Y5UO!Z({q~O![1[O%c:OO~O!j:RO~O!['ZO%c:WO~OP$wqZ$wqn$wq}$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq#|$wq(X$wq(h$wq!Y$wq!Z$wq~P&'UO|)zO!P){O(p%POP'caZ'caj'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca#|'ca(X'ca(h'ca(o'ca!Y'ca!Z'ca~O|)zO!P){OP'eaZ'eaj'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea#|'ea(X'ea(h'ea(o'ea(p'ea!Y'ea!Z'ea~OP$yqZ$yqn$yq}$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq#|$yq(X$yq(h$yq!Y$yq!Z$yq~P&'UOf%_!Z!Y%_!Z#[%_!Z#|%_!Z~P!0}O!Y'iq!Z'iq~P#C|O!Y#d!Z!Z#d!Z~P#C|O#g%_!ZP%_!ZZ%_!Z`%_!Zn%_!Z}%_!Z!Y%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z'r%_!Z(X%_!Z(h%_!Z!j%_!Z!V%_!Z'p%_!Z#[%_!Zr%_!Z![%_!Z%c%_!Z!d%_!Z~P#-]OP%_!ZZ%_!Zn%_!Z}%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z#|%_!Z(X%_!Z(h%_!Z!Y%_!Z!Z%_!Z~P&'UOr(]X~P1qO'|!lO~P!*fO!VeX!YeX#[eX~P'#`OP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!h[X!i[X!k[X!o[X#[[X#[eX#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!deX!j[X!jeX(heX~P'ASOP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![XO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O!Y:wO!Z$ma~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;RO!P${O![$|O!f<aO!k$xO#f;XO$T%^O$o;TO$q;VO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#s)aO~P'ExO!Z[X!ZeX~P'ASO#g:kO~O!d#uO#g:kO~O#[:{O~O#r:pO~O#[;ZO!Y(mX!Z(mX~O#[:{O!Y(kX!Z(kX~O#g;[O~Of;^O~P!0}O#g;cO~O#g;dO~O!d#uO#g;eO~O!d#uO#g;[O~O#|;fO~P#C|O#g;gO~O#g;hO~O#g;mO~O#g;nO~O#g;oO~O#g;pO~O#|;qO~P!0}O#|;rO~P!0}O!i#P#Q#S#T#W#e#f#q(t$o$q$t%W%b%c%d%k%m%p%q%s%u~'vS#k!U't'|#lo#j#mn|'u$Y'u'{$[([~",
  goto: "$2p)SPPPPP)TPP)WP)iP*x.|PPPP5pPP6WPP<S?gP?zP?zPPP?zPAxP?zP?zP?zPA|PPBRPBlPGdPPPGhPPPPGhJiPPPJoKjPGhPMxPPPP!!WGhPPPGhPGhP!$fGhP!'z!(|!)VP!)y!)}!)yPPPPP!-Y!(|PP!-v!.pP!1dGhGh!1i!4s!9Y!9Y!=OPPP!=VGhPPPPPPPPPPP!@dP!AqPPGh!CSPGhPGhGhGhGhPGh!DfP!GnP!JrP!Jv!KQ!KU!KUP!GkP!KY!KYP!N^P!NbGhGh!Nh##k?zP?zP?z?zP#$v?z?z#'O?z#)k?z#+m?z?z#,[#.f#.f#.j#.r#.f#.zP#.fP?z#/d?z#3R?z?z5pPPP#6vPPP#7a#7aP#7aP#7w#7aPP#7}P#7tP#7t#8b#7t#8|#9S5m)W#9V)WP#9^#9^#9^P)WP)WP)WP)WPP)WP#9d#9gP#9g)WP#9kP#9nP)WP)WP)WP)WP)WP)W)WPP#9t#9z#:V#:]#:c#:i#:o#:}#;T#;Z#;e#;k#;u#<U#<[#<|#=`#=f#=l#=z#>a#@O#@^#@d#Ax#BW#Cr#DQ#DW#D^#Dd#Dn#Dt#Dz#EU#Eh#EnPPPPPPPPPP#EtPPPPPPP#Fi#Ip#KP#KW#K`PPPP$!d$%Z$+r$+u$+x$,q$,t$,w$-O$-WPP$-^$-b$.Y$/X$/]$/qPP$/u$/{$0PP$0S$0W$0Z$1P$1h$2P$2T$2W$2Z$2a$2d$2h$2lR!{RoqOXst!Z#c%j&m&o&p&r,h,m1w1zY!uQ'Z-Y1[5]Q%pvQ%xyQ&P|Q&e!VS'R!e-QQ'a!iS'g!r!xS*c$|*hQ+f%yQ+s&RQ,X&_Q-W'YQ-b'bQ-j'hQ/|*jQ1f,YR;Y:g%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8gS#p]:d!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q*u%ZQ+k%{Q,Z&bQ,b&jQ.c;QQ0h+^Q0l+`Q0w+lQ1n,`Q2{.[Q4v0rQ5k1gQ6i3PQ6u;RQ7h4wR8m6j&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]t!nQ!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_$v$si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ&S|Q'P!eS'V%f-TQ+k%{Q,Z&bQ0]*yQ0w+lQ0|+rQ1m,_Q1n,`Q4v0rQ5P1OQ5k1gQ5n1iQ5o1lQ7h4wQ7k4|Q8U5qQ9V7lR9b8RrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR,]&f&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O']'m(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<[<][#[WZ#V#Y'S'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ%sxQ%wyS%||&RQ&Y!TQ'^!hQ'`!iQ(k#rS*V$x*ZS+e%x%yQ+i%{Q,S&]Q,W&_S-a'a'bQ.^(lQ/g*WQ0p+fQ0v+lQ0x+mQ0{+qQ1a,TS1e,X,YQ2i-bQ3y/cQ4u0rQ4y0uQ5O0}Q5j1fQ7Q3zQ7g4wQ7j4{Q9R7fR9y9S!O$zi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c!S%uy!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^Q+_%sQ+x&VQ+{&WQ,V&_Q.](kQ1`,SU1d,W,X,YQ3Q.^Q5e1aS5i1e1fQ8Q5j#W<^#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go<_:y:z:};P;T;V;X;`;b;d;h;j;l;n;rW%Ti%V*r<YS&V!Q&dQ&W!RQ&X!SR+v&T$w%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gT)v$u)wV*v%Z;Q;RU'V!e%f-TS(y#y#zQ+p&OS.V(g(hQ1V+|Q4g0ZR7p5U&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]$i$`c#X#d%n%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.t.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q'T!eR2^-Qv!nQ!e!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_S*b$|*hS/t*c*jQ/}*kQ1X,OQ4^/|R4a0PnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&t!^Q'q!wS(m#t:kQ+c%vQ,Q&YQ,R&[Q-_'_Q-l'jS.g(r;[S0`+O;eQ0n+dQ1Z,PQ2O,oQ2Q,pQ2Y,{Q2g-`Q2j-dS4l0a;oQ4q0oS4t0q;pQ6T2[Q6X2hQ6^2oQ7e4rQ8b6VQ8c6YQ8f6_R9h8_$d$_c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(j#o'dU*o%R(q3mS+Y%n.tQ2|0hQ6f2{Q8l6iR9o8m$d$^c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(i#o'dS({#z$_S+X%n.tS.W(h(jQ.w)]Q0e+YR2y.X&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S#p]:dQ&o!XQ&p!YQ&r![Q&s!]R1v,kQ'[!hQ+[%sQ-]'^S.Y(k+_Q2e-[W2}.].^0g0iQ6W2fU6e2z2|3QS8i6f6hS9m8k8lS:U9l9oQ:^:VR:a:_U!vQ'Z-YT5Z1[5]!Q_OXZ`st!V!Z#c#g%b%j&d&f&m&o&p&r(d,h,m.P1w1z]!pQ!r'Z-Y1[5]T#p]:d%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS(y#y#zS.V(g(h!s;v$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Y!tQ'Z-Y1[5]Q'f!rS'p!u!xS'r!y5_S-i'g'hQ-k'iR2p-jQ'o!tS(`#f1qS-h'f'rQ/f*VQ/r*bQ2q-kQ4O/gS4X/s/}Q7P3yS7[4_4aQ8y7QR9Q7_Q#vbQ'n!tS(_#f1qS(a#l*}Q+P%cQ+a%tQ+g%zU-g'f'o'rQ-{(`Q/e*VQ/q*bQ/w*eQ0m+bQ1b,US2n-h-kQ2v.TS3}/f/gS4W/r/}Q4Z/vQ4]/xQ5g1cQ6`2qQ7O3yQ7S4OS7W4X4aQ7]4`Q8O5hS8x7P7QQ8|7XQ9O7[Q9_8PQ9u8yQ9v8}Q9x9QQ:Q9`Q:Y9wQ;y;tQ<U;}R<V<OV!vQ'Z-Y%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS#vz!j!r;s$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;y<[%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gQ%cj!S%ty!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^S%zz!jQ+b%uQ,U&_W1c,V,W,X,YU5h1d1e1fS8P5i5jQ9`8Q!r;t$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q;}<ZR<O<[$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gY#aWZ#V#Y'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ,c&j!p;u$[$m)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;x'SS'W!e%fR2`-T%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8g!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q,b&jQ0h+^Q2{.[Q6i3PR8m6j!b$Uc#X%n'|(S(n(u)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!P:r)Z)l-O.t2W2Z3_3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!f$Wc#X%n'|(S(n(u)T)U)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!T:t)Z)l-O.t2W2Z3_3f3g3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!^$[c#X%n'|(S(n(u)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:eQ3x/az<])Z)l-O.t2W2Z3_3n3t6U6p6y6z7r8a8n8t8u9{:S<PQ<b<dR<c<e&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S$nh$oR3q.z'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$jf$pQ$hfS)e$k)iR)q$pT$if$pT)g$k)i'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$nh$oQ$qhR)p$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8g!s<Z$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]#clOPXZst!Z!`!o#R#c#n#{$m%j&f&i&j&m&o&p&r&v'O'](z)n+S+^,e,h,m-^.[.{0[1_1o1p1r1t1w1z1|3P3p5Y5d5t5u5x6j7w7|8]!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gQ*z%_Q/W)zo3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!O$yi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cQ*[$zS*e$|*hQ*{%`Q/x*f#W;{#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;|:y:z:};P;T;V;X;`;b;d;h;j;l;n;rQ<Q<^Q<R<_Q<S<`R<T<a!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;rnoOXst!Z#c%j&m&o&p&r,h,m1w1zQ*_${Q,v&yQ,w&{R4R/k$v%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ+y&WQ1T+{Q5S1SR7o5TT*g$|*hS*g$|*hT5[1[5]S/v*d5YT4`0O7wQ+a%tQ/w*eQ0m+bQ1b,UQ5g1cQ8O5hQ9_8PR:Q9`!O%Oi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cr)}$v(s*O*n*|/i0U0V3W4P4j6}7`9t;z<W<XS0Q*m0R#W:|#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn:}:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!^;_(o)`*U*^._.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<e`;`3l6q6t6x8o9p9s:bS;i.a3UT;j6s8r!O%Qi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cv*P$v(s*Q*m*|/]/i0U0V3W4P4b4j6}7`9t;z<W<XS0S*n0T#W;O#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;P:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!b;a(o)`*U*^.`.a.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<ed;b3l6r6s6x8o8p9p9q9s:bS;k.b3VT;l6t8srnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ&a!UR,e&jrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR&a!UQ+}&XR1P+vsnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ1],SS5b1`1aU7x5`5a5eS9Z7z7{S9|9Y9]Q:Z9}R:`:[Q&h!VR,^&dR5n1iS%||&RR0x+mQ&m!WR,h&nR,n&sT1x,m1zR,r&tQ,q&tR2R,rQ't!zR-n'tSsOtQ#cXT%ms#cQ!}TR'v!}Q#QUR'x#QQ)w$uR/T)wQ#TVR'z#TQ#WWU(Q#W(R-uQ(R#XR-u(SQ-R'TR2_-RQ.j(sR3X.jQ.m(uS3[.m3]R3].nQ-Y'ZR2c-YY!rQ'Z-Y1[5]R'e!rS#^W%eU(X#^(Y-vQ(Y#_R-v(TQ-U'WR2a-Ut`OXst!V!Z#c%j&d&f&m&o&p&r,h,m1w1zS#gZ%bU#q`#g.PR.P(dQ(e#iQ-|(aW.U(e-|2t6bQ2t-}R6b2uQ)i$kR.|)iQ$ohR)o$oQ$bcU)_$b-q:xQ-q:eR:x)lQ/d*VW3{/d3|7R8zU3|/e/f/gS7R3}4OR8z7S$X)|$v(o(s)`*U*^*m*n*w*x*|.a.b.d.e.f/S/X/]/_/a/i/n0U0V0f1Q1S3R3S3T3W3l4P4Q4U4b4d4j5R5T6k6l6m6n6s6t6v6w6x6}7U7Y7`7b7d8o8p8q8{9P9p9q9r9s9t:X:b;z<W<X<d<eQ/l*^U4T/l4V7VQ4V/nR7V4UQ*h$|R/z*hr*O$v(s*m*n*|/i0U0V3W4P4j6}7`9t;z<W<X!^._(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<eU/^*O._6qa6q3l6s6t6x8o9p9s:bQ0R*mQ3U.aU4c0R3U8rR8r6sv*Q$v(s*m*n*|/]/i0U0V3W4P4b4j6}7`9t;z<W<X!b.`(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<eU/`*Q.`6re6r3l6s6t6x8o8p9p9q9s:bQ0T*nQ3V.bU4e0T3V8sR8s6tQ*s%UR0X*sQ4o0fR7c4oQ+U%hR0d+UQ5V1VS7q5V9XR9X7rQ,P&YR1Y,PQ5]1[R7u5]Q1h,ZS5l1h8SR8S5nQ0s+iW4x0s4z7i9TQ4z0vQ7i4yR9T7jQ+n%|R0y+nQ1z,mR5|1zYrOXst#cQ&q!ZQ+W%jQ,g&mQ,i&oQ,j&pQ,l&rQ1u,hS1x,m1zR5{1wQ%lpQ&u!_Q&x!aQ&z!bQ&|!cQ'l!tQ+V%iQ+c%vQ+u&SQ,]&hQ,t&wW-e'f'n'o'rQ-l'jQ/y*gQ0n+dS1k,^,aQ2S,sQ2T,vQ2U,wQ2j-dW2l-g-h-k-mQ4q0oQ4}0|Q5Q1QQ5f1bQ5p1mQ5z1vU6Z2k2n2qQ6^2oQ7e4rQ7m5PQ7n5RQ7t5[Q7}5gQ8T5oS8d6[6`Q8f6_Q9U7kQ9^8OQ9c8UQ9j8eQ9z9VQ:P9_Q:T9kR:]:QQ%vyQ'_!iQ'j!tU+d%w%x%yQ,{'QU-`'`'a'bS-d'f'pQ/p*bS0o+e+fQ2[,}S2h-a-bQ2o-iQ4Y/tQ4r0pQ6V2bQ6Y2iQ6_2pR7Z4^S$wi<YR*t%VU%Ui%V<YR0W*rQ$viS(o#u+`Q(s#wS)`$c$dQ*U$xQ*^${Q*m%OQ*n%QQ*w%[Q*x%]Q*|%aQ.a:|Q.b;OQ.d;SQ.e;UQ.f;WQ/S)uS/X){/ZQ/])}Q/_*PQ/a*RQ/i*YQ/n*`Q0U*pQ0V*qh0f+].Z1^3O5c6g7y8j9[9n:O:WQ1Q+wQ1S+zQ3R;_Q3S;aQ3T;cQ3W.iS3l:y:zQ4P/jQ4Q/kQ4U/mQ4b0QQ4d0SQ4j0^Q5R1RQ5T1UQ6k;gQ6l;iQ6m;kQ6n;mQ6s:}Q6t;PQ6v;TQ6w;VQ6x;XQ6}3xQ7U4SQ7Y4[Q7`4fQ7b4nQ7d4pQ8o;dQ8p;`Q8q;bQ8{7TQ9P7^Q9p;hQ9q;jQ9r;lQ9s;nQ9t8wQ:X;qQ:b;rQ;z<YQ<W<bQ<X<cQ<d<fR<e<gnpOXst!Z#c%j&m&o&p&r,h,m1w1zQ!fPS#eZ#nQ&w!`U'c!o5Y7wQ'y#RQ(|#{Q)m$mS,a&f&iQ,f&jQ,s&vQ,x'OQ-[']Q.p(zQ/Q)nQ0b+SQ0i+^Q1s,eQ2f-^Q2|.[Q3s.{Q4h0[Q5a1_Q5r1oQ5s1pQ5w1rQ5y1tQ6O1|Q6f3PQ6{3pQ7{5dQ8X5tQ8Y5uQ8[5xQ8l6jQ9]7|R9g8]#WcOPXZst!Z!`!o#c#n#{%j&f&i&j&m&o&p&r&v'O'](z+S+^,e,h,m-^.[0[1_1o1p1r1t1w1z1|3P5Y5d5t5u5x6j7w7|8]Q#XWQ#dYQ%nuQ%ovS%qw!gS'|#V(PQ(S#YQ(n#tQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)X$YQ)Z$[Q)^$aQ)b$eW)l$m)n.{3pQ+Z%pQ+o%}S-O'S2]Q-m'mS-r'}-tQ-w(VQ-y(^Q.h(rQ.n(vQ.r:cQ.t:fQ.u:gQ.v:jQ/V)yQ0_+OQ2W,yQ2Z,|Q2k-fQ2r-zQ3Y.lQ3_:kQ3`:lQ3a:mQ3b:nQ3c:oQ3d:pQ3e:qQ3f:rQ3g:sQ3h:tQ3i:uQ3j:vQ3k.sQ3n:{Q3o;YQ3t:wQ4k0aQ4s0qQ6U;ZQ6[2mQ6a2sQ6o3ZQ6p;[Q6y;^Q6z;eQ7r5WQ8a6SQ8e6]Q8n;fQ8t;oQ8u;pQ9k8gQ9{9WQ:S9iQ:e#RR<P<]R#ZWR'U!eY!tQ'Z-Y1[5]S'Q!e-QQ'f!rS'p!u!xS'r!y5_S,}'R'YS-i'g'hQ-k'iQ2b-WR2p-jR(t#wR(w#xQ!fQT-X'Z-Y]!qQ!r'Z-Y1[5]Q#o]R'd:dT#jZ%bS#iZ%bS%hm,dU(a#g#h#kS-}(b(cQ.R(dQ0c+TQ2u.OU2v.P.Q.SS6c2w2xR8h6d`#]W#V#Y%e'}(W+Q-xr#fZm#g#h#k%b(b(c(d+T.O.P.Q.S2w2x6dQ1q,dQ2X,zQ6Q2PQ8`6RT;w'S+RT#`W%eS#_W%eS(O#V(WS(T#Y+QS-P'S+RT-s'}-xT'X!e%fQ$kfR)s$pT)h$k)iR3r.zT*X$x*ZR*a${Q0g+]Q2z.ZQ5`1^Q6h3OQ7z5cQ8k6gQ9Y7yQ9l8jQ9}9[Q:V9nQ:[:OR:_:WnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&g!VR,]&dtmOXst!U!V!Z#c%j&d&m&o&p&r,h,m1w1zR,d&jT%im,dR1W+|R,[&bQ&Q|R+t&RR+j%{T&k!W&nT&l!W&nT1y,m1z",
  nodeNames: "⚠ ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 371,
  context: aU,
  nodeProps: [
    ["isolate", -8, 4, 5, 13, 33, 35, 48, 50, 52, ""],
    ["group", -26, 8, 16, 18, 65, 201, 205, 209, 210, 212, 215, 218, 228, 230, 236, 238, 240, 242, 245, 251, 257, 259, 261, 263, 265, 267, 268, "Statement", -32, 12, 13, 28, 31, 32, 38, 48, 51, 52, 54, 59, 67, 75, 79, 81, 83, 84, 106, 107, 116, 117, 134, 137, 139, 140, 141, 142, 144, 145, 164, 165, 167, "Expression", -23, 27, 29, 33, 37, 39, 41, 168, 170, 172, 173, 175, 176, 177, 179, 180, 181, 183, 184, 185, 195, 197, 199, 200, "Type", -3, 87, 99, 105, "ClassItem"],
    ["openedBy", 22, "<", 34, "InterpolationStart", 53, "[", 57, "{", 72, "(", 157, "JSXStartCloseTag"],
    ["closedBy", 23, ">", 36, "InterpolationEnd", 47, "]", 58, "}", 73, ")", 162, "JSXEndTag"]
  ],
  propSources: [hU],
  skippedNodes: [0, 4, 5, 271],
  repeatNodeCount: 37,
  tokenData: "$Fj(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Ns!`!a$#_!a!b$(l!b!c$,k!c!}Er!}#O$-u#O#P$/P#P#Q$4h#Q#R$5r#R#SEr#S#T$7P#T#o$8Z#o#p$<k#p#q$=a#q#r$>q#r#s$?}#s$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$I|Er$I|$I}$Dd$I}$JO$Dd$JO$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(n%d_$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$f&j(Op(R!b't(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST(P#S$f&j'u(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$f&j(Op(R!b'u(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$f&j!o$Ip(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|3l_'}$(n$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$f&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$a`$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$a``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$a`$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(R!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$a`(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k#%|:hh$f&j(Op(R!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$f&j(Op(R!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$f&j(R!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$f&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(R!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$f&j(OpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(OpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Op(R!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$f&j(g!L^(Op(R!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$f&j(Op(R!b$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$f&j(Op(R!b$Y#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$f&j(Op(R!b#l$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$f&j$O$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&COLva(p&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$f&j#x$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|! c_(Q$)`$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$f&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$a`$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(OpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$a`(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b(*Q!'t_!k(!b$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!jM|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$f&j(Op(R!b'|#)d#m$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$f&j(Op(R!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$f&j(Op(R!bn&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!Y&;l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$f&j(Op(R!b|'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!XMt$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$f&j(Op(R!b#k$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$f&j(R!b!USOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$f&j!USOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$f&j!USO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!USOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!US#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$f&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$f&j(R!b!USOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ(R!b!USOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb(R!b!USOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX(R!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$f&j(R!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$f&j(Op!USOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$f&j(Op!USOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ(Op!USOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb(Op!USOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX(OpOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$f&j(OpOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$f&j(Op(R!b!USOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d](Op(R!b!USOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe(Op(R!b!USOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ(Op(R!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$f&j(Op(R!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$f&j(Op(R!b'v(;d!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$f&j(Op(R!bS(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$f&j(R!bS(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$f&jS(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSS(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW(R!bS(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$f&j(OpS(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW(OpS(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY(Op(R!bS(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$f&j$O$Id(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$W#t$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!d$b$f&j#|%<f(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I__`l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^#Jk^g!*v!h'.r(Op(R!b(tSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Kg!Q!^*g!^!_#L]!_!`#M}!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KpX$h&j(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LfZ#n$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MX!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MbX$O$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NWX#o$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Oa#[%?x$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!T!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!`_#g$Ih$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#nafBf#o$Id$c#|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$s!`!a$%}!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%O_#o$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&Ya#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'_!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'j`#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(wc(h$Ip$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*S!P!^%Z!^!_*g!_!a%Z!a!b$+^!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*__}'#p$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+i`$f&j#y$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,v_!{!Ln$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.Q_!P(8n$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/UZ$f&jO!^$/w!^!_$0_!_#i$/w#i#j$0d#j#l$/w#l#m$2V#m#o$/w#o#p$0_#p;'S$/w;'S;=`$4b<%lO$/w(n$0OT^#S$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0dO^#S(n$0i[$f&jO!Q&c!Q![$1_![!^&c!_!c&c!c!i$1_!i#T&c#T#Z$1_#Z#o&c#o#p$3u#p;'S&c;'S;=`&w<%lO&c(n$1dZ$f&jO!Q&c!Q![$2V![!^&c!_!c&c!c!i$2V!i#T&c#T#Z$2V#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2[Z$f&jO!Q&c!Q![$2}![!^&c!_!c&c!c!i$2}!i#T&c#T#Z$2}#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3SZ$f&jO!Q&c!Q![$/w![!^&c!_!c&c!c!i$/w!i#T&c#T#Z$/w#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3xR!Q![$4R!c!i$4R#T#Z$4R#S$4US!Q![$4R!c!i$4R#T#Z$4R#q#r$0_(n$4eP;=`<%l$/w!2r$4s_!V!+S$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$5}`#v$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7[_$f&j(Op(R!b(X&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8jk$f&j(Op(R!b'{&;d$[#t([!LYOY%ZYZ&cZr%Zrs&}st%Ztu$8Zuw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$8Z![!^%Z!^!_*g!_!c%Z!c!}$8Z!}#O%Z#O#P&c#P#R%Z#R#S$8Z#S#T%Z#T#o$8Z#o#p*g#p$g%Z$g;'S$8Z;'S;=`$<e<%lO$8Z+d$:jk$f&j(Op(R!b$[#tOY%ZYZ&cZr%Zrs&}st%Ztu$:_uw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$:_![!^%Z!^!_*g!_!c%Z!c!}$:_!}#O%Z#O#P&c#P#R%Z#R#S$:_#S#T%Z#T#o$:_#o#p*g#p$g%Z$g;'S$:_;'S;=`$<_<%lO$:_+d$<bP;=`<%l$:_(CS$<hP;=`<%l$8Z!5p$<tX![!3l(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g&CO$=la(o&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+^#q;'S%Z;'S;=`+a<%lO%Z%#`$?O_!Z$I`r`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@Y_!pS$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Aj|$f&j(Op(R!b't(;d$Y#t'{&;d([!LYOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(CS$Duk$f&j(Op(R!b'u(;d$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [lU, uU, cU, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, oU, new Uf("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(Z~~", 141, 332), new Uf("j~RQYZXz{^~^O'x~~aP!P!Qd~iO'y~~", 25, 315)],
  topRules: { Script: [0, 6], SingleExpression: [1, 269], SingleClassItem: [2, 270] },
  dialects: { jsx: 0, ts: 14614 },
  dynamicPrecedences: { 69: 1, 79: 1, 81: 1, 165: 1, 193: 1 },
  specialized: [{ term: 319, get: (t) => pU[t] || -1 }, { term: 334, get: (t) => dU[t] || -1 }, { term: 70, get: (t) => fU[t] || -1 }],
  tokenPrec: 14638
}), jE = [
  /* @__PURE__ */ Kt("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], gU = /* @__PURE__ */ jE.concat([
  /* @__PURE__ */ Kt("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Kt("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), fx = /* @__PURE__ */ new kZ(), RE = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Oo(t) {
  return (e, r) => {
    let i = e.node.getChild("VariableDefinition");
    return i && r(i, t), !0;
  };
}
const yU = ["FunctionDeclaration"], OU = {
  FunctionDeclaration: /* @__PURE__ */ Oo("function"),
  ClassDeclaration: /* @__PURE__ */ Oo("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ Oo("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ Oo("type"),
  NamespaceDeclaration: /* @__PURE__ */ Oo("namespace"),
  VariableDefinition(t, e) {
    t.matchContext(yU) || e(t, "variable");
  },
  TypeDefinition(t, e) {
    e(t, "type");
  },
  __proto__: null
};
function ZE(t, e) {
  let r = fx.get(e);
  if (r)
    return r;
  let i = [], n = !0;
  function s(a, l) {
    let u = t.sliceString(a.from, a.to);
    i.push({ label: u, type: l });
  }
  return e.cursor(Ot.IncludeAnonymous).iterate((a) => {
    if (n)
      n = !1;
    else if (a.name) {
      let l = OU[a.name];
      if (l && l(a, s) || RE.has(a.name))
        return !1;
    } else if (a.to - a.from > 8192) {
      for (let l of ZE(t, a.node))
        i.push(l);
      return !1;
    }
  }), fx.set(e, i), i;
}
const mx = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, WE = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function xU(t) {
  let e = xt(t.state).resolveInner(t.pos, -1);
  if (WE.indexOf(e.name) > -1)
    return null;
  let r = e.name == "VariableName" || e.to - e.from < 20 && mx.test(t.state.sliceDoc(e.from, e.to));
  if (!r && !t.explicit)
    return null;
  let i = [];
  for (let n = e; n; n = n.parent)
    RE.has(n.name) && (i = i.concat(ZE(t.state.doc, n)));
  return {
    options: i,
    from: r ? e.from : t.pos,
    validFor: mx
  };
}
const ds = /* @__PURE__ */ kc.define({
  name: "javascript",
  parser: /* @__PURE__ */ mU.configure({
    props: [
      /* @__PURE__ */ fC.add({
        IfStatement: /* @__PURE__ */ Hp({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Hp({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: zZ,
        SwitchBody: (t) => {
          let e = t.textAfter, r = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (r ? 0 : i ? 1 : 2) * t.unit;
        },
        Block: /* @__PURE__ */ YZ({ closing: "}" }),
        ArrowFunction: (t) => t.baseIndent + t.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ Hp({ except: /^{/ }),
        JSXElement(t) {
          let e = /^\s*<\//.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        JSXEscape(t) {
          let e = /\s*\}/.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        }
      }),
      /* @__PURE__ */ yC.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": KZ,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), qE = {
  test: (t) => /^JSX/.test(t.name),
  facet: /* @__PURE__ */ pC({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, DU = /* @__PURE__ */ ds.configure({ dialect: "ts" }, "typescript"), bU = /* @__PURE__ */ ds.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ Vg.add((t) => t.isTop ? [qE] : void 0)]
}), vU = /* @__PURE__ */ ds.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ Vg.add((t) => t.isTop ? [qE] : void 0)]
}, "typescript");
let XE = (t) => ({ label: t, type: "keyword" });
const VE = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(XE), wU = /* @__PURE__ */ VE.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(XE));
function SU(t = {}) {
  let e = t.jsx ? t.typescript ? vU : bU : t.typescript ? DU : ds, r = t.typescript ? gU.concat(wU) : jE.concat(VE);
  return new jZ(e, [
    ds.data.of({
      autocomplete: fX(WE, xE(r))
    }),
    ds.data.of({
      autocomplete: xU
    }),
    t.jsx ? AU : []
  ]);
}
function CU(t) {
  for (; ; ) {
    if (t.name == "JSXOpenTag" || t.name == "JSXSelfClosingTag" || t.name == "JSXFragmentTag")
      return t;
    if (t.name == "JSXEscape" || !t.parent)
      return null;
    t = t.parent;
  }
}
function gx(t, e, r = t.length) {
  for (let i = e == null ? void 0 : e.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return t.sliceString(i.from, Math.min(i.to, r));
  return "";
}
const EU = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), AU = /* @__PURE__ */ le.inputHandler.of((t, e, r, i, n) => {
  if ((EU ? t.composing : t.compositionStarted) || t.state.readOnly || e != r || i != ">" && i != "/" || !ds.isActiveAt(t.state, e, -1))
    return !1;
  let s = n(), { state: a } = s, l = a.changeByRange((u) => {
    var h;
    let { head: p } = u, d = xt(a).resolveInner(p - 1, -1), m;
    if (d.name == "JSXStartTag" && (d = d.parent), !(a.doc.sliceString(p - 1, p) != i || d.name == "JSXAttributeValue" && d.to > p)) {
      if (i == ">" && d.name == "JSXFragmentTag")
        return { range: u, changes: { from: p, insert: "</>" } };
      if (i == "/" && d.name == "JSXStartCloseTag") {
        let y = d.parent, O = y.parent;
        if (O && y.from == p - 2 && ((m = gx(a.doc, O.firstChild, p)) || ((h = O.firstChild) === null || h === void 0 ? void 0 : h.name) == "JSXFragmentTag")) {
          let D = `${m}>`;
          return { range: Y.cursor(p + D.length, -1), changes: { from: p, insert: D } };
        }
      } else if (i == ">") {
        let y = CU(d);
        if (y && !/^\/?>|^<\//.test(a.doc.sliceString(p, p + 2)) && (m = gx(a.doc, y, p)))
          return { range: u, changes: { from: p, insert: `</${m}>` } };
      }
    }
    return { range: u };
  });
  return l.changes.empty ? !1 : (t.dispatch([
    s,
    a.update(l, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
}), kU = () => {
  const { config: t } = Cr();
  return bk(t);
}, TU = {
  html: ck(),
  css: hk(),
  js: SU(),
  json: pk()
}, PU = () => {
  var h;
  const [t, e] = An("light"), {
    project: r,
    saveFile: i,
    config: { editableFileTypes: n }
  } = Cr(), s = kU(), a = (h = Object.values(r.files).filter((p) => p.active)) == null ? void 0 : h[0], l = lk(
    (p) => {
      i(a.id, p);
    },
    [i, a]
  ), u = async () => {
    try {
      const p = await pQ(a.contents, a.language);
      i(a.id, p);
    } catch (p) {
      console.log("FAILURE : ", p);
    }
  };
  return a ? bx(a.language, n) ? /* @__PURE__ */ z.jsxs("div", { className: "editor-container", children: [
    /* @__PURE__ */ z.jsx("button", { onClick: () => u(), children: "Format" }),
    /* @__PURE__ */ z.jsxs("select", { onChange: (p) => e(p.target.value), children: [
      /* @__PURE__ */ z.jsx("option", { value: "light", children: "light theme" }),
      /* @__PURE__ */ z.jsx("option", { value: "dark", children: "dark theme" })
    ] }),
    a && /* @__PURE__ */ z.jsx(
      ME,
      {
        value: a.contents,
        width: "100%",
        height: "100%",
        extensions: [TU[a.language]],
        onChange: l,
        theme: t
      }
    )
  ] }) : /* @__PURE__ */ z.jsxs("div", { children: [
    "Can only edit html, css, or javascript files. Cannot edit",
    " ",
    a.language,
    " files."
  ] }) : /* @__PURE__ */ z.jsx(s, {});
}, FU = () => {
  const { config: t } = Cr(), e = t.EditorComponent || PU;
  return /* @__PURE__ */ z.jsxs("div", { className: "center-pane", children: [
    /* @__PURE__ */ z.jsx("div", { className: "center-nav", children: /* @__PURE__ */ z.jsx(EQ, {}) }),
    /* @__PURE__ */ z.jsx("div", { className: "center-main", children: /* @__PURE__ */ z.jsx(e, {}) })
  ] });
}, $U = ({ file: t }) => {
  const e = Gf(null), {
    project: { files: r, folders: i }
  } = Cr(), n = xx(() => t ? t.contents.replace(
    new RegExp('<link rel="stylesheet" href="([^"]+)"\\s*/>', "g"),
    (a, l) => {
      const u = l.split("/"), h = u.pop(), p = vx(u, {
        folders: Object.values(i)
      }), d = Object.values(r).find(
        (m) => m.name === h && m.folderId === p
      );
      return `
          <style>
            ${d == null ? void 0 : d.contents}
          </style>
      `;
    }
  ) : "", [r, t]);
  return /* @__PURE__ */ z.jsx(z.Fragment, { children: t && /* @__PURE__ */ z.jsx(
    "iframe",
    {
      allow: "self",
      title: "Web Preview",
      ref: e,
      id: "preview",
      style: { width: "100%", height: "100%" },
      srcDoc: n
    }
  ) });
};
var UE = { exports: {} };
(function(t, e) {
  (function(i, n) {
    t.exports = n();
  })(dk, function() {
    return (
      /******/
      function(r) {
        var i = {};
        function n(s) {
          if (i[s])
            return i[s].exports;
          var a = i[s] = {
            /******/
            i: s,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return r[s].call(a.exports, a, a.exports, n), a.l = !0, a.exports;
        }
        return n.m = r, n.c = i, n.i = function(s) {
          return s;
        }, n.d = function(s, a, l) {
          n.o(s, a) || Object.defineProperty(s, a, {
            /******/
            configurable: !1,
            /******/
            enumerable: !0,
            /******/
            get: l
            /******/
          });
        }, n.n = function(s) {
          var a = s && s.__esModule ? (
            /******/
            function() {
              return s.default;
            }
          ) : (
            /******/
            function() {
              return s;
            }
          );
          return n.d(a, "a", a), a;
        }, n.o = function(s, a) {
          return Object.prototype.hasOwnProperty.call(s, a);
        }, n.p = "", n(n.s = 3);
      }([
        /* 0 */
        /***/
        function(r, i, n) {
          Object.defineProperty(i, "__esModule", {
            value: !0
          });
          var s = Object.assign || function(v) {
            for (var w = 1; w < arguments.length; w++) {
              var x = arguments[w];
              for (var S in x)
                Object.prototype.hasOwnProperty.call(x, S) && (v[S] = x[S]);
            }
            return v;
          }, a = /* @__PURE__ */ function() {
            function v(w, x) {
              for (var S = 0; S < x.length; S++) {
                var k = x[S];
                k.enumerable = k.enumerable || !1, k.configurable = !0, "value" in k && (k.writable = !0), Object.defineProperty(w, k.key, k);
              }
            }
            return function(w, x, S) {
              return x && v(w.prototype, x), S && v(w, S), w;
            };
          }();
          function l(v) {
            if (Array.isArray(v)) {
              for (var w = 0, x = Array(v.length); w < v.length; w++)
                x[w] = v[w];
              return x;
            } else
              return Array.from(v);
          }
          function u(v, w) {
            if (!(v instanceof w))
              throw new TypeError("Cannot call a class as a function");
          }
          var h = i.TYPE_MESSAGE = "message", p = i.TYPE_RESPONSE = "response", d = i.TYPE_SET_INTERFACE = "set-interface", m = i.TYPE_SERVICE_MESSAGE = "service-message", y = !!window.MSInputMethodContext && !!document.documentMode, O = {
            //Will not affect IE11 because there sandboxed iframe has not 'null' origin
            //but base URL of iframe's src
            allowedSenderOrigin: void 0
          }, D = function() {
            function v(w, x, S) {
              var k = this;
              u(this, v), this.options = s({}, O, S), this.incrementalID = Math.floor(Math.random() * 1e5), this.postMessage = w, this.remote = {}, this.callbacks = {}, this.remoteMethodsWaitPromise = new Promise(function(C) {
                k._resolveRemoteMethodsPromise = C;
              }), x(function() {
                return k.onMessageListener.apply(k, arguments);
              });
            }
            return a(v, [{
              key: "onMessageListener",
              value: function(x) {
                var S = this, k = x.data, C = this.options.allowedSenderOrigin;
                C && x.origin !== C && !y || (k.type === p ? this.popCallback(k.callId, k.success, k.result) : k.type === h ? this.callLocalApi(k.methodName, k.arguments).then(function(A) {
                  return S.responseOtherSide(k.callId, A);
                }).catch(function(A) {
                  return S.responseOtherSide(k.callId, A, !1);
                }) : k.type === d ? (this.setInterface(k.apiMethods), this.responseOtherSide(k.callId)) : k.type === m && this.callLocalServiceMethod(k.methodName, k.arguments).then(function(A) {
                  return S.responseOtherSide(k.callId, A);
                }).catch(function(A) {
                  return S.responseOtherSide(k.callId, A, !1);
                }));
              }
            }, {
              key: "postMessageToOtherSide",
              value: function(x) {
                this.postMessage(x, "*");
              }
              /**
                 * Sets remote interface methods
                 * @param remote - hash with keys of remote API methods. Values is ignored
                 */
            }, {
              key: "setInterface",
              value: function(x) {
                var S = this;
                this.remote = {}, x.forEach(function(k) {
                  return S.remote[k] = S.createMethodWrapper(k);
                }), this._resolveRemoteMethodsPromise();
              }
            }, {
              key: "setLocalApi",
              value: function(x) {
                var S = this;
                return new Promise(function(k, C) {
                  var A = S.registerCallback(k, C);
                  S.postMessageToOtherSide({
                    callId: A,
                    apiMethods: Object.keys(x),
                    type: d
                  });
                }).then(function() {
                  return S.localApi = x;
                });
              }
            }, {
              key: "setServiceMethods",
              value: function(x) {
                this.serviceMethods = x;
              }
              /**
                 * Calls local method
                 * @param methodName
                 * @param args
                 * @returns {Promise.<*>|string}
                 */
            }, {
              key: "callLocalApi",
              value: function(x, S) {
                var k;
                return Promise.resolve((k = this.localApi)[x].apply(k, l(S)));
              }
              /**
                 * Calls local method registered as "service method"
                 * @param methodName
                 * @param args
                 * @returns {Promise.<*>}
                 */
            }, {
              key: "callLocalServiceMethod",
              value: function(x, S) {
                var k;
                if (!this.serviceMethods[x])
                  throw new Error("Serivce method " + x + " is not registered");
                return Promise.resolve((k = this.serviceMethods)[x].apply(k, l(S)));
              }
              /**
                 * Wraps remote method with callback storing code
                 * @param methodName - method to wrap
                 * @returns {Function} - function to call as remote API interface
                 */
            }, {
              key: "createMethodWrapper",
              value: function(x) {
                var S = this;
                return function() {
                  for (var k = arguments.length, C = Array(k), A = 0; A < k; A++)
                    C[A] = arguments[A];
                  return S.callRemoteMethod.apply(S, [x].concat(C));
                };
              }
              /**
                 * Calls other side with arguments provided
                 * @param id
                 * @param methodName
                 * @param args
                 */
            }, {
              key: "callRemoteMethod",
              value: function(x) {
                for (var S = this, k = arguments.length, C = Array(k > 1 ? k - 1 : 0), A = 1; A < k; A++)
                  C[A - 1] = arguments[A];
                return new Promise(function(P, I) {
                  var B = S.registerCallback(P, I);
                  S.postMessageToOtherSide({
                    callId: B,
                    methodName: x,
                    type: h,
                    arguments: C
                  });
                });
              }
              /**
                 * Calls remote service method
                 * @param methodName
                 * @param args
                 * @returns {*}
                 */
            }, {
              key: "callRemoteServiceMethod",
              value: function(x) {
                for (var S = this, k = arguments.length, C = Array(k > 1 ? k - 1 : 0), A = 1; A < k; A++)
                  C[A - 1] = arguments[A];
                return new Promise(function(P, I) {
                  var B = S.registerCallback(P, I);
                  S.postMessageToOtherSide({
                    callId: B,
                    methodName: x,
                    type: m,
                    arguments: C
                  });
                });
              }
              /**
                 * Respond to remote call
                 * @param id - remote call ID
                 * @param result - result to pass to calling function
                 */
            }, {
              key: "responseOtherSide",
              value: function(x, S) {
                var k = this, C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
                S instanceof Error && (S = [].concat(l(Object.keys(S)), ["message"]).reduce(function(P, I) {
                  return P[I] = S[I], P;
                }, {}));
                var A = function() {
                  return k.postMessage({
                    callId: x,
                    type: p,
                    success: C,
                    result: S
                  }, "*");
                };
                try {
                  A();
                } catch (P) {
                  console.error("Failed to post response, recovering...", P), P instanceof DOMException && (S = JSON.parse(JSON.stringify(S)), A());
                }
              }
              /**
                 * Stores callbacks to call later when remote call will be answered
                 * @param successCallback
                 * @param failureCallback
                 */
            }, {
              key: "registerCallback",
              value: function(x, S) {
                var k = (++this.incrementalID).toString();
                return this.callbacks[k] = { successCallback: x, failureCallback: S }, k;
              }
              /**
                 * Calls and delete stored callback
                 * @param id - call id
                 * @param success - was call successful
                 * @param result - result of remote call
                 */
            }, {
              key: "popCallback",
              value: function(x, S, k) {
                S ? this.callbacks[x].successCallback(k) : this.callbacks[x].failureCallback(k), delete this.callbacks[x];
              }
            }]), v;
          }();
          i.default = D;
        },
        /* 1 */
        /***/
        function(r, i) {
          r.exports = `/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TYPE_MESSAGE = exports.TYPE_MESSAGE = 'message';
var TYPE_RESPONSE = exports.TYPE_RESPONSE = 'response';
var TYPE_SET_INTERFACE = exports.TYPE_SET_INTERFACE = 'set-interface';
var TYPE_SERVICE_MESSAGE = exports.TYPE_SERVICE_MESSAGE = 'service-message';

var isIE11 = !!window.MSInputMethodContext && !!document.documentMode;

var defaultOptions = {
  //Will not affect IE11 because there sandboxed iframe has not 'null' origin
  //but base URL of iframe's src
  allowedSenderOrigin: undefined
};

var Connection = function () {
  function Connection(postMessage, registerOnMessageListener, options) {
    var _this = this;

    _classCallCheck(this, Connection);

    this.options = _extends({}, defaultOptions, options);
    //Random number between 0 and 100000
    this.incrementalID = Math.floor(Math.random() * 100000);

    this.postMessage = postMessage;
    this.remote = {};
    this.callbacks = {};

    this.remoteMethodsWaitPromise = new Promise(function (resolve) {
      _this._resolveRemoteMethodsPromise = resolve;
    });

    registerOnMessageListener(function () {
      return _this.onMessageListener.apply(_this, arguments);
    });
  }

  /**
     * Listens to remote messages. Calls local method if it is called outside or call stored callback if it is response.
     * @param e - onMessage event
     */


  _createClass(Connection, [{
    key: 'onMessageListener',
    value: function onMessageListener(e) {
      var _this2 = this;

      var data = e.data;

      var allowedSenderOrigin = this.options.allowedSenderOrigin;

      if (allowedSenderOrigin && e.origin !== allowedSenderOrigin && !isIE11) {
        return;
      }

      if (data.type === TYPE_RESPONSE) {
        this.popCallback(data.callId, data.success, data.result);
      } else if (data.type === TYPE_MESSAGE) {
        this.callLocalApi(data.methodName, data.arguments).then(function (res) {
          return _this2.responseOtherSide(data.callId, res);
        }).catch(function (err) {
          return _this2.responseOtherSide(data.callId, err, false);
        });
      } else if (data.type === TYPE_SET_INTERFACE) {
        this.setInterface(data.apiMethods);
        this.responseOtherSide(data.callId);
      } else if (data.type === TYPE_SERVICE_MESSAGE) {
        this.callLocalServiceMethod(data.methodName, data.arguments).then(function (res) {
          return _this2.responseOtherSide(data.callId, res);
        }).catch(function (err) {
          return _this2.responseOtherSide(data.callId, err, false);
        });
      }
    }
  }, {
    key: 'postMessageToOtherSide',
    value: function postMessageToOtherSide(dataToPost) {
      this.postMessage(dataToPost, '*');
    }

    /**
       * Sets remote interface methods
       * @param remote - hash with keys of remote API methods. Values is ignored
       */

  }, {
    key: 'setInterface',
    value: function setInterface(remoteMethods) {
      var _this3 = this;

      this.remote = {};

      remoteMethods.forEach(function (key) {
        return _this3.remote[key] = _this3.createMethodWrapper(key);
      });

      this._resolveRemoteMethodsPromise();
    }
  }, {
    key: 'setLocalApi',
    value: function setLocalApi(api) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        var id = _this4.registerCallback(resolve, reject);
        _this4.postMessageToOtherSide({
          callId: id,
          apiMethods: Object.keys(api),
          type: TYPE_SET_INTERFACE
        });
      }).then(function () {
        return _this4.localApi = api;
      });
    }
  }, {
    key: 'setServiceMethods',
    value: function setServiceMethods(api) {
      this.serviceMethods = api;
    }

    /**
       * Calls local method
       * @param methodName
       * @param args
       * @returns {Promise.<*>|string}
       */

  }, {
    key: 'callLocalApi',
    value: function callLocalApi(methodName, args) {
      var _localApi;

      return Promise.resolve((_localApi = this.localApi)[methodName].apply(_localApi, _toConsumableArray(args)));
    }

    /**
       * Calls local method registered as "service method"
       * @param methodName
       * @param args
       * @returns {Promise.<*>}
       */

  }, {
    key: 'callLocalServiceMethod',
    value: function callLocalServiceMethod(methodName, args) {
      var _serviceMethods;

      if (!this.serviceMethods[methodName]) {
        throw new Error('Serivce method ' + methodName + ' is not registered');
      }
      return Promise.resolve((_serviceMethods = this.serviceMethods)[methodName].apply(_serviceMethods, _toConsumableArray(args)));
    }

    /**
       * Wraps remote method with callback storing code
       * @param methodName - method to wrap
       * @returns {Function} - function to call as remote API interface
       */

  }, {
    key: 'createMethodWrapper',
    value: function createMethodWrapper(methodName) {
      var _this5 = this;

      return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _this5.callRemoteMethod.apply(_this5, [methodName].concat(args));
      };
    }

    /**
       * Calls other side with arguments provided
       * @param id
       * @param methodName
       * @param args
       */

  }, {
    key: 'callRemoteMethod',
    value: function callRemoteMethod(methodName) {
      var _this6 = this;

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return new Promise(function (resolve, reject) {
        var id = _this6.registerCallback(resolve, reject);
        _this6.postMessageToOtherSide({
          callId: id,
          methodName: methodName,
          type: TYPE_MESSAGE,
          arguments: args
        });
      });
    }

    /**
       * Calls remote service method
       * @param methodName
       * @param args
       * @returns {*}
       */

  }, {
    key: 'callRemoteServiceMethod',
    value: function callRemoteServiceMethod(methodName) {
      var _this7 = this;

      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return new Promise(function (resolve, reject) {
        var id = _this7.registerCallback(resolve, reject);
        _this7.postMessageToOtherSide({
          callId: id,
          methodName: methodName,
          type: TYPE_SERVICE_MESSAGE,
          arguments: args
        });
      });
    }

    /**
       * Respond to remote call
       * @param id - remote call ID
       * @param result - result to pass to calling function
       */

  }, {
    key: 'responseOtherSide',
    value: function responseOtherSide(id, result) {
      var _this8 = this;

      var success = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (result instanceof Error) {
        // Error could be non-serializable, so we copy properties manually
        result = [].concat(_toConsumableArray(Object.keys(result)), ['message']).reduce(function (acc, it) {
          acc[it] = result[it];
          return acc;
        }, {});
      }

      var doPost = function doPost() {
        return _this8.postMessage({
          callId: id,
          type: TYPE_RESPONSE,
          success: success,
          result: result
        }, '*');
      };

      try {
        doPost();
      } catch (err) {
        console.error('Failed to post response, recovering...', err); // eslint-disable-line no-console
        if (err instanceof DOMException) {
          result = JSON.parse(JSON.stringify(result));
          doPost();
        }
      }
    }

    /**
       * Stores callbacks to call later when remote call will be answered
       * @param successCallback
       * @param failureCallback
       */

  }, {
    key: 'registerCallback',
    value: function registerCallback(successCallback, failureCallback) {
      var id = (++this.incrementalID).toString();
      this.callbacks[id] = { successCallback: successCallback, failureCallback: failureCallback };
      return id;
    }

    /**
       * Calls and delete stored callback
       * @param id - call id
       * @param success - was call successful
       * @param result - result of remote call
       */

  }, {
    key: 'popCallback',
    value: function popCallback(id, success, result) {
      if (success) {
        this.callbacks[id].successCallback(result);
      } else {
        this.callbacks[id].failureCallback(result);
      }
      delete this.callbacks[id];
    }
  }]);

  return Connection;
}();

exports.default = Connection;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _connection = __webpack_require__(0);

var _connection2 = _interopRequireDefault(_connection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Frame = function () {
  function Frame() {
    var _this = this;

    _classCallCheck(this, Frame);

    this.connection = new _connection2.default(window.parent.postMessage.bind(window.parent), function (listener) {
      window.addEventListener('message', listener);
    });

    this.connection.setServiceMethods({
      runCode: function runCode(code) {
        return _this.runCode(code);
      },
      importScript: function importScript(path) {
        return _this.importScript(path);
      },
      injectStyle: function injectStyle(style) {
        return _this.injectStyle(style);
      },
      importStyle: function importStyle(path) {
        return _this.importStyle(path);
      }
    });

    this.connection.callRemoteServiceMethod('iframeInitialized');
  }

  /**
     * Creates script tag with passed code and attaches it. Runs synchronous
     * @param code
     */


  _createClass(Frame, [{
    key: 'runCode',
    value: function runCode(code) {
      var scriptTag = document.createElement('script');
      scriptTag.innerHTML = code;
      document.getElementsByTagName('head')[0].appendChild(scriptTag);
    }
  }, {
    key: 'importScript',
    value: function importScript(scriptUrl) {
      var scriptTag = document.createElement('script');
      scriptTag.src = scriptUrl;
      document.getElementsByTagName('head')[0].appendChild(scriptTag);
      return new Promise(function (resolve) {
        return scriptTag.onload = function () {
          return resolve();
        };
      });
    }
  }, {
    key: 'injectStyle',
    value: function injectStyle(style) {
      var styleTag = document.createElement('style');
      styleTag.innerHTML = style;
      document.getElementsByTagName('head')[0].appendChild(styleTag);
    }
  }, {
    key: 'importStyle',
    value: function importStyle(styleUrl) {
      var linkTag = document.createElement('link');
      linkTag.rel = 'stylesheet';
      linkTag.href = styleUrl;
      document.getElementsByTagName('head')[0].appendChild(linkTag);
    }
  }]);

  return Frame;
}();

var Websandbox = new Frame();
window.Websandbox = window.Websandbox || Websandbox;
module.exports = Websandbox; // eslint-disable-line

/***/ })
/******/ ]);
//# sourceMappingURL=compile-loader-file-name.js.map`;
        },
        ,
        /* 3 */
        /***/
        function(r, i, n) {
          Object.defineProperty(i, "__esModule", {
            value: !0
          }), i.BaseOptions = void 0;
          var s = Object.assign || function(D) {
            for (var v = 1; v < arguments.length; v++) {
              var w = arguments[v];
              for (var x in w)
                Object.prototype.hasOwnProperty.call(w, x) && (D[x] = w[x]);
            }
            return D;
          }, a = /* @__PURE__ */ function() {
            function D(v, w) {
              for (var x = 0; x < w.length; x++) {
                var S = w[x];
                S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(v, S.key, S);
              }
            }
            return function(v, w, x) {
              return w && D(v.prototype, w), x && D(v, x), v;
            };
          }(), l = n(0), u = d(l), h = n(1), p = d(h);
          function d(D) {
            return D && D.__esModule ? D : { default: D };
          }
          function m(D, v) {
            if (!(D instanceof v))
              throw new TypeError("Cannot call a class as a function");
          }
          var y = i.BaseOptions = {
            frameContainer: "body",
            frameClassName: "websandbox__frame",
            frameSrc: null,
            frameContent: `
<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"></head>
<body></body>
</html>
  `,
            codeToRunBeforeInit: null,
            initialStyles: null,
            baseUrl: null,
            allowPointerLock: !1,
            allowFullScreen: !1,
            sandboxAdditionalAttributes: ""
          }, O = function() {
            a(D, null, [{
              key: "create",
              /**
               * Creates sandbox instancea
               * @param {?Object} localApi Api of this side. Will be available for sandboxed code as remoteApi
               * @param {?SandboxOptions} options Options of created sandbox
               */
              value: function(w) {
                var x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                return new D(w, s(y, x));
              }
              /**
               * {Constructor}
               * @param {?Object} localApi
               * @param {?SandboxOptions} options
               */
            }]);
            function D(v, w) {
              var x = this;
              m(this, D), this.options = w, this.iframe = this.createIframe(), this.promise = new Promise(function(S) {
                x.connection = new u.default(x.iframe.contentWindow.postMessage.bind(x.iframe.contentWindow), function(k) {
                  var C = function(P) {
                    if (P.source === x.iframe.contentWindow)
                      return k(P);
                  };
                  window.addEventListener("message", C), x.removeMessageListener = function() {
                    return window.removeEventListener("message", C);
                  };
                }, { allowedSenderOrigin: "null" }), x.connection.setServiceMethods({
                  iframeInitialized: function() {
                    return x.connection.setLocalApi(v).then(function() {
                      return S(x);
                    });
                  }
                });
              });
            }
            return a(D, [{
              key: "_prepareFrameContent",
              value: function(w) {
                var x = w.frameContent.replace("</head>", "<script>" + p.default + `<\/script>
</head>`);
                return w.initialStyles && (x = x.replace("</head>", "<style>" + w.initialStyles + `</style>
</head>`)), w.baseUrl && (x = x.replace("<head>", `<head>
<base href="` + w.baseUrl + '"/>')), w.codeToRunBeforeInit && (x = x.replace("<head>", `<head>
<script>` + w.codeToRunBeforeInit + "<\/script>")), x;
              }
            }, {
              key: "createIframe",
              value: function() {
                var w = this.options.frameContainer, x = typeof w == "string" ? document.querySelector(w) : w;
                if (!x)
                  throw new Error("Websandbox: Cannot find container for sandbox " + x);
                var S = document.createElement("iframe");
                if (S.sandbox = "allow-scripts " + this.options.sandboxAdditionalAttributes, S.className = this.options.frameClassName, this.options.allowFullScreen && (S.allowfullscreen = "true"), this.options.frameSrc)
                  return S.src = this.options.frameSrc, x.appendChild(S), S;
                if (this.options.frameContent.indexOf("<head>") < 0)
                  throw new Error('Websandbox: iFrame content must have "<head>" tag.');
                return S.setAttribute("srcdoc", this._prepareFrameContent(this.options)), x.appendChild(S), S;
              }
            }, {
              key: "destroy",
              value: function() {
                this.iframe.remove(), this.removeMessageListener();
              }
            }, {
              key: "_runCode",
              value: function(w) {
                return this.connection.callRemoteServiceMethod("runCode", w);
              }
            }, {
              key: "_runFunction",
              value: function(w) {
                return this._runCode("(" + w.toString() + ")()");
              }
            }, {
              key: "run",
              value: function(w) {
                return w.name ? this._runFunction(w) : this._runCode(w);
              }
            }, {
              key: "importScript",
              value: function(w) {
                return this.connection.callRemoteServiceMethod("importScript", w);
              }
            }, {
              key: "injectStyle",
              value: function(w) {
                return this.connection.callRemoteServiceMethod("injectStyle", w);
              }
            }]), D;
          }();
          i.default = O;
        }
        /******/
      ])
    );
  });
})(UE);
var BU = UE.exports;
const IU = /* @__PURE__ */ fk(BU), NU = ({ output: t }) => {
  const [e, r] = An(t);
  return Jr(() => r(t), [t]), /* @__PURE__ */ z.jsxs("div", { className: "debugger-pane", children: [
    /* @__PURE__ */ z.jsxs("div", { className: "debugger-title-bar", children: [
      /* @__PURE__ */ z.jsx("div", { className: "debugger-title", children: "Console" }),
      /* @__PURE__ */ z.jsx("button", { type: "button", onClick: () => r(void 0), children: "Clear console" })
    ] }),
    /* @__PURE__ */ z.jsx("div", { className: "debugger-view", children: e == null ? void 0 : e.map((i) => i.join(", ")).join(`
`) })
  ] });
}, _U = ({
  contentFrameHeight: t = "1fr",
  debuggerOutput: e,
  children: r
}) => {
  const { config: i } = Cr();
  return /* @__PURE__ */ z.jsxs(
    "div",
    {
      className: "debugger-wrapper",
      style: {
        gridTemplateRows: i.showDebug ? `${t} 1fr` : "auto"
      },
      children: [
        /* @__PURE__ */ z.jsx("div", { className: "debugger-wrapper-child", children: r }),
        /* @__PURE__ */ z.jsx(NU, { output: e })
      ]
    }
  );
}, MU = ({ file: t }) => {
  const [e, r] = An([]), i = () => {
    const n = {
      consoleLog: (...s) => (r((a) => [...a, s]), Promise.resolve("messaged"))
    };
    for (let s of document.getElementsByClassName("js-preview-output"))
      s.innerHTML = "";
    IU.create(n, {
      frameContainer: ".js-preview-output"
    }).promise.then(function(s) {
      r([]), s.run(
        `
        console.log = Websandbox.connection.remote.consoleLog;
        ${t.contents}
      `
      );
    });
  };
  return /* @__PURE__ */ z.jsx(_U, { contentFrameHeight: "1fr", debuggerOutput: e, children: /* @__PURE__ */ z.jsxs("div", { className: "js-preview-container", children: [
    /* @__PURE__ */ z.jsx("div", { className: "js-preview-output", children: "pending..." }),
    /* @__PURE__ */ z.jsx("div", { className: "button-bar", children: /* @__PURE__ */ z.jsx("button", { onClick: i, children: "Run" }) })
  ] }) });
}, LU = ({ file: t }) => {
  let e = "";
  try {
    e = JSON.stringify(JSON.parse(t.contents), void 0, 2);
  } catch (r) {
    const i = wx(r);
    return /* @__PURE__ */ z.jsxs("div", { className: "json-preview", children: [
      "Cannot display json: invalid format.",
      i
    ] });
  }
  return /* @__PURE__ */ z.jsx("div", { className: "json-preview", children: e });
}, yx = {
  html: $U,
  js: MU,
  json: LU
}, QU = (t, e = {}) => t ? e[t == null ? void 0 : t.language] ? e[t == null ? void 0 : t.language] : yx[t == null ? void 0 : t.language] ? yx[t == null ? void 0 : t.language] : () => /* @__PURE__ */ z.jsxs("div", { children: [
  "Cannot preview files of type ",
  t == null ? void 0 : t.language
] }) : () => "", jU = () => {
  const {
    project: { files: t },
    config: { previewFileTypes: e, PreviewComponents: r }
  } = Cr(), [i, n] = An(
    Object.values(t).find((l) => l.name === "index.html" && !l.folderId)
  ), s = Object.values(t).find(
    (l) => l.active && Kl(l.language)
  );
  Jr(() => {
    Kl(s == null ? void 0 : s.language, e) && n(s);
  }, [s]), Jr(() => {
    i && !t[i.id] && n(
      Object.values(t).find(
        (l) => Kl(l.language, e)
      )
    );
  }, [i, t]);
  const a = QU(i, r);
  return /* @__PURE__ */ z.jsxs("div", { className: "right-pane", children: [
    /* @__PURE__ */ z.jsx(
      "select",
      {
        onChange: (l) => {
          const u = Object.values(t).find(
            (h) => h.id === l.target.value
          );
          n(u);
        },
        value: i == null ? void 0 : i.id,
        children: Object.values(t).sort().filter((l) => Kl(l.language, e)).map((l) => /* @__PURE__ */ z.jsx("option", { value: l.id, children: l.name }, l.id))
      }
    ),
    i && /* @__PURE__ */ z.jsx(a, { file: i })
  ] });
}, RU = () => /* @__PURE__ */ z.jsxs("div", { className: "run-bar", children: [
  /* @__PURE__ */ z.jsx("div", { children: /* @__PURE__ */ z.jsx("button", { type: "button", onClick: () => alert("not implemented"), children: "Share" }) }),
  /* @__PURE__ */ z.jsx("div", { children: /* @__PURE__ */ z.jsx("button", { type: "button", onClick: () => alert("not implemented"), children: "Finish" }) })
] }), ZU = {
  showPreview: !0,
  showEditor: !0,
  showLeftNav: !0,
  showRunBar: !1
}, Js = (t, e) => e[t] ?? ZU[t] ?? !1, WU = [
  { key: "showLeftNav", width: "1fr" },
  { key: "showPreview", width: "2fr" },
  { key: "showEditor", width: "2fr" }
], qU = [
  { key: "showRunBar", height: "40px" }
], qY = ({
  project: t,
  config: e,
  setProject: r,
  setConfig: i
}) => {
  const n = Gf(!0), [s, a] = uk(OQ, t), l = yQ(a);
  Jr(() => {
    n.current && r(s), n.current = !0;
  }, [s]), Jr(() => {
    l.replaceProject(t, n);
  }, [t, l.replaceProject]);
  const u = ["auto"];
  qU.forEach((p) => {
    Js(p.key, e) && u.push(p.height);
  });
  const h = [];
  return WU.forEach((p) => {
    Js(p.key, e) && h.push(p.width);
  }), /* @__PURE__ */ z.jsx(
    yk,
    {
      value: {
        project: s,
        config: e,
        setProject: r,
        setConfig: i,
        ...l
      },
      children: /* @__PURE__ */ z.jsxs(
        "div",
        {
          className: "cdo-ide-outer",
          style: { gridTemplateRows: u.join(" ") },
          children: [
            /* @__PURE__ */ z.jsxs(
              "div",
              {
                className: "cdo-ide-inner",
                style: {
                  gridTemplateColumns: h.join(" ")
                },
                children: [
                  Js("showLeftNav", e) && /* @__PURE__ */ z.jsx("div", { className: "cdo-ide-area", children: /* @__PURE__ */ z.jsx(CQ, {}) }),
                  Js("showEditor", e) && /* @__PURE__ */ z.jsx("div", { className: "cdo-ide-area", children: /* @__PURE__ */ z.jsx(FU, {}) }),
                  Js("showPreview", e) && /* @__PURE__ */ z.jsx(jU, {})
                ]
              }
            ),
            Js("showRunBar", e) && /* @__PURE__ */ z.jsx(RU, {})
          ]
        }
      )
    }
  );
};
export {
  qY as CDOIDE,
  Dx as CDOIDEContext,
  yk as CDOIDEContextProvider,
  bx as editableFileType,
  gQ as findFiles,
  vx as findFolder,
  Tg as findSubFolders,
  bk as getEmptyEditor,
  GU as getEmptyProject,
  wx as getErrorMessage,
  fQ as getNextFileId,
  mQ as getNextFolderId,
  pQ as prettify,
  Kl as previewFileType,
  OQ as projectReducer,
  $w as sortFilesByName,
  Cr as useCDOIDEContext,
  yQ as useProjectUtilities
};
//# sourceMappingURL=cdo-ide-poc.js.map
