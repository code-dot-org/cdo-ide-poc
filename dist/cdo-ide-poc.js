import './style.css';
var ET = Object.defineProperty;
var kT = (t, e, r) => e in t ? ET(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var Gr = (t, e, r) => (kT(t, typeof e != "symbol" ? e + "" : e, r), r);
import yb, { createContext as TT, useContext as PT, useMemo as Ob, useState as In, useEffect as ti, forwardRef as FT, useRef as Sm, useImperativeHandle as $T, useCallback as BT, useReducer as IT } from "react";
var NT = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function _T(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var _d = { exports: {} }, Js = {};
/** @license React v16.14.0
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var u0;
function QT() {
  if (u0)
    return Js;
  u0 = 1;
  var t = yb, e = 60103;
  if (Js.Fragment = 60107, typeof Symbol == "function" && Symbol.for) {
    var r = Symbol.for;
    e = r("react.element"), Js.Fragment = r("react.fragment");
  }
  var i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n = Object.prototype.hasOwnProperty, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(o, u, c) {
    var h, d = {}, m = null, y = null;
    c !== void 0 && (m = "" + c), u.key !== void 0 && (m = "" + u.key), u.ref !== void 0 && (y = u.ref);
    for (h in u)
      n.call(u, h) && !s.hasOwnProperty(h) && (d[h] = u[h]);
    if (o && o.defaultProps)
      for (h in u = o.defaultProps, u)
        d[h] === void 0 && (d[h] = u[h]);
    return { $$typeof: e, type: o, key: m, ref: y, props: d, _owner: i.current };
  }
  return Js.jsx = a, Js.jsxs = a, Js;
}
var Ap = {};
/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var c0;
function MT() {
  return c0 || (c0 = 1, function(t) {
    process.env.NODE_ENV !== "production" && function() {
      var e = yb, r = 60103, i = 60106;
      t.Fragment = 60107;
      var n = 60108, s = 60114, a = 60109, o = 60110, u = 60112, c = 60113, h = 60120, d = 60115, m = 60116, y = 60121, O = 60122, b = 60117, v = 60129, S = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var x = Symbol.for;
        r = x("react.element"), i = x("react.portal"), t.Fragment = x("react.fragment"), n = x("react.strict_mode"), s = x("react.profiler"), a = x("react.provider"), o = x("react.context"), u = x("react.forward_ref"), c = x("react.suspense"), h = x("react.suspense_list"), d = x("react.memo"), m = x("react.lazy"), y = x("react.block"), O = x("react.server.block"), b = x("react.fundamental"), x("react.scope"), x("react.opaque.id"), v = x("react.debug_trace_mode"), x("react.offscreen"), S = x("react.legacy_hidden");
      }
      var w = typeof Symbol == "function" && Symbol.iterator, k = "@@iterator";
      function C(M) {
        if (M === null || typeof M != "object")
          return null;
        var ne = w && M[w] || M[k];
        return typeof ne == "function" ? ne : null;
      }
      var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function P(M) {
        {
          for (var ne = arguments.length, pe = new Array(ne > 1 ? ne - 1 : 0), $e = 1; $e < ne; $e++)
            pe[$e - 1] = arguments[$e];
          I("error", M, pe);
        }
      }
      function I(M, ne, pe) {
        {
          var $e = E.ReactDebugCurrentFrame, Ye = "";
          if (Oe) {
            var _e = X(Oe.type), Be = Oe._owner;
            Ye += G(_e, Oe._source, Be && X(Be.type));
          }
          Ye += $e.getStackAddendum(), Ye !== "" && (ne += "%s", pe = pe.concat([Ye]));
          var Pe = pe.map(function(Lt) {
            return "" + Lt;
          });
          Pe.unshift("Warning: " + ne), Function.prototype.apply.call(console[M], console, Pe);
        }
      }
      var B = !1;
      function Q(M) {
        return !!(typeof M == "string" || typeof M == "function" || M === t.Fragment || M === s || M === v || M === n || M === c || M === h || M === S || B || typeof M == "object" && M !== null && (M.$$typeof === m || M.$$typeof === d || M.$$typeof === a || M.$$typeof === o || M.$$typeof === u || M.$$typeof === b || M.$$typeof === y || M[0] === O));
      }
      var j = /^(.*)[\\\/]/;
      function G(M, ne, pe) {
        var $e = "";
        if (ne) {
          var Ye = ne.fileName, _e = Ye.replace(j, "");
          if (/^index\./.test(_e)) {
            var Be = Ye.match(j);
            if (Be) {
              var Pe = Be[1];
              if (Pe) {
                var Lt = Pe.replace(j, "");
                _e = Lt + "/" + _e;
              }
            }
          }
          $e = " (at " + _e + ":" + ne.lineNumber + ")";
        } else
          pe && ($e = " (created by " + pe + ")");
        return `
    in ` + (M || "Unknown") + $e;
      }
      var J = 1;
      function L(M) {
        return M._status === J ? M._result : null;
      }
      function q(M, ne, pe) {
        var $e = ne.displayName || ne.name || "";
        return M.displayName || ($e !== "" ? pe + "(" + $e + ")" : pe);
      }
      function X(M) {
        if (M == null)
          return null;
        if (typeof M.tag == "number" && P("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof M == "function")
          return M.displayName || M.name || null;
        if (typeof M == "string")
          return M;
        switch (M) {
          case t.Fragment:
            return "Fragment";
          case i:
            return "Portal";
          case s:
            return "Profiler";
          case n:
            return "StrictMode";
          case c:
            return "Suspense";
          case h:
            return "SuspenseList";
        }
        if (typeof M == "object")
          switch (M.$$typeof) {
            case o:
              return "Context.Consumer";
            case a:
              return "Context.Provider";
            case u:
              return q(M, M.render, "ForwardRef");
            case d:
              return X(M.type);
            case y:
              return X(M.render);
            case m: {
              var ne = M, pe = L(ne);
              if (pe)
                return X(pe);
              break;
            }
          }
        return null;
      }
      var K = {};
      E.ReactDebugCurrentFrame;
      var Oe = null;
      function Ae(M) {
        Oe = M;
      }
      function ve(M, ne, pe, $e, Ye) {
        {
          var _e = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var Be in M)
            if (_e(M, Be)) {
              var Pe = void 0;
              try {
                if (typeof M[Be] != "function") {
                  var Lt = Error(($e || "React class") + ": " + pe + " type `" + Be + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof M[Be] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Lt.name = "Invariant Violation", Lt;
                }
                Pe = M[Be](ne, Be, $e, pe, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Fr) {
                Pe = Fr;
              }
              Pe && !(Pe instanceof Error) && (Ae(Ye), P("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", $e || "React class", pe, Be, typeof Pe), Ae(null)), Pe instanceof Error && !(Pe.message in K) && (K[Pe.message] = !0, Ae(Ye), P("Failed %s type: %s", pe, Pe.message), Ae(null));
            }
        }
      }
      var Le = E.ReactCurrentOwner, ze = Object.prototype.hasOwnProperty, et = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Fe, mt, ue;
      ue = {};
      function V(M) {
        if (ze.call(M, "ref")) {
          var ne = Object.getOwnPropertyDescriptor(M, "ref").get;
          if (ne && ne.isReactWarning)
            return !1;
        }
        return M.ref !== void 0;
      }
      function W(M) {
        if (ze.call(M, "key")) {
          var ne = Object.getOwnPropertyDescriptor(M, "key").get;
          if (ne && ne.isReactWarning)
            return !1;
        }
        return M.key !== void 0;
      }
      function R(M, ne) {
        if (typeof M.ref == "string" && Le.current && ne && Le.current.stateNode !== ne) {
          var pe = X(Le.current.type);
          ue[pe] || (P('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', X(Le.current.type), M.ref), ue[pe] = !0);
        }
      }
      function Se(M, ne) {
        {
          var pe = function() {
            Fe || (Fe = !0, P("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ne));
          };
          pe.isReactWarning = !0, Object.defineProperty(M, "key", {
            get: pe,
            configurable: !0
          });
        }
      }
      function De(M, ne) {
        {
          var pe = function() {
            mt || (mt = !0, P("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ne));
          };
          pe.isReactWarning = !0, Object.defineProperty(M, "ref", {
            get: pe,
            configurable: !0
          });
        }
      }
      var Te = function(M, ne, pe, $e, Ye, _e, Be) {
        var Pe = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: r,
          // Built-in properties that belong on the element
          type: M,
          key: ne,
          ref: pe,
          props: Be,
          // Record the component responsible for creating this element.
          _owner: _e
        };
        return Pe._store = {}, Object.defineProperty(Pe._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(Pe, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: $e
        }), Object.defineProperty(Pe, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Ye
        }), Object.freeze && (Object.freeze(Pe.props), Object.freeze(Pe)), Pe;
      };
      function tr(M, ne, pe, $e, Ye) {
        {
          var _e, Be = {}, Pe = null, Lt = null;
          pe !== void 0 && (Pe = "" + pe), W(ne) && (Pe = "" + ne.key), V(ne) && (Lt = ne.ref, R(ne, Ye));
          for (_e in ne)
            ze.call(ne, _e) && !et.hasOwnProperty(_e) && (Be[_e] = ne[_e]);
          if (M && M.defaultProps) {
            var Fr = M.defaultProps;
            for (_e in Fr)
              Be[_e] === void 0 && (Be[_e] = Fr[_e]);
          }
          if (Pe || Lt) {
            var fi = typeof M == "function" ? M.displayName || M.name || "Unknown" : M;
            Pe && Se(Be, fi), Lt && De(Be, fi);
          }
          return Te(M, Pe, Lt, Ye, $e, Le.current, Be);
        }
      }
      var Mt = E.ReactCurrentOwner;
      E.ReactDebugCurrentFrame;
      function wt(M) {
        Oe = M;
      }
      var Ur;
      Ur = !1;
      function fn(M) {
        return typeof M == "object" && M !== null && M.$$typeof === r;
      }
      function cr() {
        {
          if (Mt.current) {
            var M = X(Mt.current.type);
            if (M)
              return `

Check the render method of \`` + M + "`.";
          }
          return "";
        }
      }
      function Pr(M) {
        {
          if (M !== void 0) {
            var ne = M.fileName.replace(/^.*[\\\/]/, ""), pe = M.lineNumber;
            return `

Check your code at ` + ne + ":" + pe + ".";
          }
          return "";
        }
      }
      var pi = {};
      function mn(M) {
        {
          var ne = cr();
          if (!ne) {
            var pe = typeof M == "string" ? M : M.displayName || M.name;
            pe && (ne = `

Check the top-level render call using <` + pe + ">.");
          }
          return ne;
        }
      }
      function qi(M, ne) {
        {
          if (!M._store || M._store.validated || M.key != null)
            return;
          M._store.validated = !0;
          var pe = mn(ne);
          if (pi[pe])
            return;
          pi[pe] = !0;
          var $e = "";
          M && M._owner && M._owner !== Mt.current && ($e = " It was passed a child from " + X(M._owner.type) + "."), wt(M), P('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', pe, $e), wt(null);
        }
      }
      function Xi(M, ne) {
        {
          if (typeof M != "object")
            return;
          if (Array.isArray(M))
            for (var pe = 0; pe < M.length; pe++) {
              var $e = M[pe];
              fn($e) && qi($e, ne);
            }
          else if (fn(M))
            M._store && (M._store.validated = !0);
          else if (M) {
            var Ye = C(M);
            if (typeof Ye == "function" && Ye !== M.entries)
              for (var _e = Ye.call(M), Be; !(Be = _e.next()).done; )
                fn(Be.value) && qi(Be.value, ne);
          }
        }
      }
      function di(M) {
        {
          var ne = M.type;
          if (ne == null || typeof ne == "string")
            return;
          var pe;
          if (typeof ne == "function")
            pe = ne.propTypes;
          else if (typeof ne == "object" && (ne.$$typeof === u || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          ne.$$typeof === d))
            pe = ne.propTypes;
          else
            return;
          if (pe) {
            var $e = X(ne);
            ve(pe, M.props, "prop", $e, M);
          } else if (ne.PropTypes !== void 0 && !Ur) {
            Ur = !0;
            var Ye = X(ne);
            P("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ye || "Unknown");
          }
          typeof ne.getDefaultProps == "function" && !ne.getDefaultProps.isReactClassApproved && P("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Us(M) {
        {
          for (var ne = Object.keys(M.props), pe = 0; pe < ne.length; pe++) {
            var $e = ne[pe];
            if ($e !== "children" && $e !== "key") {
              wt(M), P("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", $e), wt(null);
              break;
            }
          }
          M.ref !== null && (wt(M), P("Invalid attribute `ref` supplied to `React.Fragment`."), wt(null));
        }
      }
      function au(M, ne, pe, $e, Ye, _e) {
        {
          var Be = Q(M);
          if (!Be) {
            var Pe = "";
            (M === void 0 || typeof M == "object" && M !== null && Object.keys(M).length === 0) && (Pe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var Lt = Pr(Ye);
            Lt ? Pe += Lt : Pe += cr();
            var Fr;
            M === null ? Fr = "null" : Array.isArray(M) ? Fr = "array" : M !== void 0 && M.$$typeof === r ? (Fr = "<" + (X(M.type) || "Unknown") + " />", Pe = " Did you accidentally export a JSX literal instead of a component?") : Fr = typeof M, P("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Fr, Pe);
          }
          var fi = tr(M, ne, pe, Ye, _e);
          if (fi == null)
            return fi;
          if (Be) {
            var Vi = ne.children;
            if (Vi !== void 0)
              if ($e)
                if (Array.isArray(Vi)) {
                  for (var Gs = 0; Gs < Vi.length; Gs++)
                    Xi(Vi[Gs], M);
                  Object.freeze && Object.freeze(Vi);
                } else
                  P("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                Xi(Vi, M);
          }
          return M === t.Fragment ? Us(fi) : di(fi), fi;
        }
      }
      function zs(M, ne, pe) {
        return au(M, ne, pe, !0);
      }
      function zr(M, ne, pe) {
        return au(M, ne, pe, !1);
      }
      var ao = zr, ou = zs;
      t.jsx = ao, t.jsxs = ou;
    }();
  }(Ap)), Ap;
}
process.env.NODE_ENV === "production" ? _d.exports = QT() : _d.exports = MT();
var z = _d.exports;
const xb = TT(null), Er = () => {
  const t = PT(xb);
  if (t === null)
    throw new Error("CDO IDE Context has not been provided!");
  return t;
}, LT = ({
  children: t,
  value: e
}) => /* @__PURE__ */ z.jsx(xb.Provider, { value: e, children: t }), RT = ["html", "css", "js", "json"], bb = (t, e = RT) => new Set(e).has(t), ys = "0", Db = (t = [], e) => t.reduce((r, i) => {
  if (!i.length)
    return r;
  const n = Object.values(e.folders).find(
    (s) => s.name === i && s.parentId === r
  );
  if (!n) {
    if (e.required)
      throw new Error(`Could not find folder ${t.join("/")}`);
    return ys;
  }
  return n.id;
}, ys), jT = () => /* @__PURE__ */ z.jsx("div", { children: "No files are open. Choose a file from the browser to the left." }), ZT = () => /* @__PURE__ */ z.jsx("div", {}), WT = (t) => t.EmptyEditorComponent ? t.EmptyEditorComponent : t.blankEmptyEditor ? ZT : jT, QG = () => ({ files: {}, folders: {} }), vb = (t) => typeof t == "string" ? t : t instanceof Error ? t.message : "", qT = ["html", "js", "json"], mu = (t, e = qT) => new Set(e).has(t);
var XT = Object.create, ph = Object.defineProperty, VT = Object.getOwnPropertyDescriptor, YT = Object.getOwnPropertyNames, UT = Object.getPrototypeOf, zT = Object.prototype.hasOwnProperty, GT = (t, e) => () => (t && (e = t(t = 0)), e), dh = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), fh = (t, e) => {
  for (var r in e)
    ph(t, r, { get: e[r], enumerable: !0 });
}, Sb = (t, e, r, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of YT(e))
      !zT.call(t, n) && n !== r && ph(t, n, { get: () => e[n], enumerable: !(i = VT(e, n)) || i.enumerable });
  return t;
}, kl = (t, e, r) => (r = t != null ? XT(UT(t)) : {}, Sb(e || !t || !t.__esModule ? ph(r, "default", { value: t, enumerable: !0 }) : r, t)), HT = (t) => Sb(ph({}, "__esModule", { value: !0 }), t), JT = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, h0 = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, po = (t, e, r) => (JT(t, e, "access private method"), r), KT = dh((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = e;
  function e() {
  }
  e.prototype = { diff: function(n, s) {
    var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = a.callback;
    typeof a == "function" && (o = a, a = {}), this.options = a;
    var u = this;
    function c(x) {
      return o ? (setTimeout(function() {
        o(void 0, x);
      }, 0), !0) : x;
    }
    n = this.castInput(n), s = this.castInput(s), n = this.removeEmpty(this.tokenize(n)), s = this.removeEmpty(this.tokenize(s));
    var h = s.length, d = n.length, m = 1, y = h + d;
    a.maxEditLength && (y = Math.min(y, a.maxEditLength));
    var O = [{ newPos: -1, components: [] }], b = this.extractCommon(O[0], s, n, 0);
    if (O[0].newPos + 1 >= h && b + 1 >= d)
      return c([{ value: this.join(s), count: s.length }]);
    function v() {
      for (var x = -1 * m; x <= m; x += 2) {
        var w = void 0, k = O[x - 1], C = O[x + 1], E = (C ? C.newPos : 0) - x;
        k && (O[x - 1] = void 0);
        var P = k && k.newPos + 1 < h, I = C && 0 <= E && E < d;
        if (!P && !I) {
          O[x] = void 0;
          continue;
        }
        if (!P || I && k.newPos < C.newPos ? (w = i(C), u.pushComponent(w.components, void 0, !0)) : (w = k, w.newPos++, u.pushComponent(w.components, !0, void 0)), E = u.extractCommon(w, s, n, x), w.newPos + 1 >= h && E + 1 >= d)
          return c(r(u, w.components, s, n, u.useLongestToken));
        O[x] = w;
      }
      m++;
    }
    if (o)
      (function x() {
        setTimeout(function() {
          if (m > y)
            return o();
          v() || x();
        }, 0);
      })();
    else
      for (; m <= y; ) {
        var S = v();
        if (S)
          return S;
      }
  }, pushComponent: function(n, s, a) {
    var o = n[n.length - 1];
    o && o.added === s && o.removed === a ? n[n.length - 1] = { count: o.count + 1, added: s, removed: a } : n.push({ count: 1, added: s, removed: a });
  }, extractCommon: function(n, s, a, o) {
    for (var u = s.length, c = a.length, h = n.newPos, d = h - o, m = 0; h + 1 < u && d + 1 < c && this.equals(s[h + 1], a[d + 1]); )
      h++, d++, m++;
    return m && n.components.push({ count: m }), n.newPos = h, d;
  }, equals: function(n, s) {
    return this.options.comparator ? this.options.comparator(n, s) : n === s || this.options.ignoreCase && n.toLowerCase() === s.toLowerCase();
  }, removeEmpty: function(n) {
    for (var s = [], a = 0; a < n.length; a++)
      n[a] && s.push(n[a]);
    return s;
  }, castInput: function(n) {
    return n;
  }, tokenize: function(n) {
    return n.split("");
  }, join: function(n) {
    return n.join("");
  } };
  function r(n, s, a, o, u) {
    for (var c = 0, h = s.length, d = 0, m = 0; c < h; c++) {
      var y = s[c];
      if (y.removed) {
        if (y.value = n.join(o.slice(m, m + y.count)), m += y.count, c && s[c - 1].added) {
          var O = s[c - 1];
          s[c - 1] = s[c], s[c] = O;
        }
      } else {
        if (!y.added && u) {
          var b = a.slice(d, d + y.count);
          b = b.map(function(S, x) {
            var w = o[m + x];
            return w.length > S.length ? w : S;
          }), y.value = n.join(b);
        } else
          y.value = n.join(a.slice(d, d + y.count));
        d += y.count, y.added || (m += y.count);
      }
    }
    var v = s[h - 1];
    return h > 1 && typeof v.value == "string" && (v.added || v.removed) && n.equals("", v.value) && (s[h - 2].value += v.value, s.pop()), s;
  }
  function i(n) {
    return { newPos: n.newPos, components: n.components.slice(0) };
  }
}), eP = dh((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.diffArrays = n, t.arrayDiff = void 0;
  var e = r(KT());
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  var i = new e.default();
  t.arrayDiff = i, i.tokenize = function(s) {
    return s.slice();
  }, i.join = i.removeEmpty = function(s) {
    return s;
  };
  function n(s, a, o) {
    return i.diff(s, a, o);
  }
}), mh = dh((t, e) => {
  var r = new Proxy(String, { get: () => r });
  e.exports = r;
}), wb = {};
fh(wb, { default: () => Ab, shouldHighlight: () => Cb });
var Cb, Ab, tP = GT(() => {
  Cb = () => !1, Ab = String;
}), rP = dh((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.codeFrameColumns = d, t.default = m;
  var e = (tP(), HT(wb)), r = n(mh(), !0);
  function i(y) {
    if (typeof WeakMap != "function")
      return null;
    var O = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap();
    return (i = function(v) {
      return v ? b : O;
    })(y);
  }
  function n(y, O) {
    if (!O && y && y.__esModule)
      return y;
    if (y === null || typeof y != "object" && typeof y != "function")
      return { default: y };
    var b = i(O);
    if (b && b.has(y))
      return b.get(y);
    var v = { __proto__: null }, S = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var x in y)
      if (x !== "default" && Object.prototype.hasOwnProperty.call(y, x)) {
        var w = S ? Object.getOwnPropertyDescriptor(y, x) : null;
        w && (w.get || w.set) ? Object.defineProperty(v, x, w) : v[x] = y[x];
      }
    return v.default = y, b && b.set(y, v), v;
  }
  var s;
  function a(y) {
    return y ? (s != null || (s = new r.default.constructor({ enabled: !0, level: 1 })), s) : r.default;
  }
  var o = !1;
  function u(y) {
    return { gutter: y.grey, marker: y.red.bold, message: y.red.bold };
  }
  var c = /\r\n|[\n\r\u2028\u2029]/;
  function h(y, O, b) {
    let v = Object.assign({ column: 0, line: -1 }, y.start), S = Object.assign({}, v, y.end), { linesAbove: x = 2, linesBelow: w = 3 } = b || {}, k = v.line, C = v.column, E = S.line, P = S.column, I = Math.max(k - (x + 1), 0), B = Math.min(O.length, E + w);
    k === -1 && (I = 0), E === -1 && (B = O.length);
    let Q = E - k, j = {};
    if (Q)
      for (let G = 0; G <= Q; G++) {
        let J = G + k;
        if (!C)
          j[J] = !0;
        else if (G === 0) {
          let L = O[J - 1].length;
          j[J] = [C, L - C + 1];
        } else if (G === Q)
          j[J] = [0, P];
        else {
          let L = O[J - G].length;
          j[J] = [0, L];
        }
      }
    else
      C === P ? C ? j[k] = [C, 0] : j[k] = !0 : j[k] = [C, P - C];
    return { start: I, end: B, markerLines: j };
  }
  function d(y, O, b = {}) {
    let v = (b.highlightCode || b.forceColor) && (0, e.shouldHighlight)(b), S = a(b.forceColor), x = u(S), w = (j, G) => v ? j(G) : G, k = y.split(c), { start: C, end: E, markerLines: P } = h(O, k, b), I = O.start && typeof O.start.column == "number", B = String(E).length, Q = (v ? (0, e.default)(y, b) : y).split(c, E).slice(C, E).map((j, G) => {
      let J = C + 1 + G, L = ` ${` ${J}`.slice(-B)} |`, q = P[J], X = !P[J + 1];
      if (q) {
        let K = "";
        if (Array.isArray(q)) {
          let Oe = j.slice(0, Math.max(q[0] - 1, 0)).replace(/[^\t]/g, " "), Ae = q[1] || 1;
          K = [`
 `, w(x.gutter, L.replace(/\d/g, " ")), " ", Oe, w(x.marker, "^").repeat(Ae)].join(""), X && b.message && (K += " " + w(x.message, b.message));
        }
        return [w(x.marker, ">"), w(x.gutter, L), j.length > 0 ? ` ${j}` : "", K].join("");
      } else
        return ` ${w(x.gutter, L)}${j.length > 0 ? ` ${j}` : ""}`;
    }).join(`
`);
    return b.message && !I && (Q = `${" ".repeat(B + 1)}${b.message}
${Q}`), v ? S.reset(Q) : Q;
  }
  function m(y, O, b, v = {}) {
    if (!o) {
      o = !0;
      let S = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      {
        let x = new Error(S);
        x.name = "DeprecationWarning", console.warn(new Error(S));
      }
    }
    return b = Math.max(b, 0), d(y, { start: { column: b, line: O } }, v);
  }
}), Eb = {};
fh(Eb, { __debug: () => K$, check: () => H$, doc: () => hD, format: () => fD, formatWithCursor: () => dD, getSupportInfo: () => J$, util: () => pD, version: () => E$ });
var iP = (t, e, r, i) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, i) : r.global ? e.replace(r, i) : e.split(r).join(i);
}, gh = iP, nP = kl(eP(), 1);
function sP(t) {
  let e = t.indexOf("\r");
  return e >= 0 ? t.charAt(e + 1) === `
` ? "crlf" : "cr" : "lf";
}
function wm(t) {
  switch (t) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function kb(t, e) {
  let r;
  switch (e) {
    case `
`:
      r = /\n/g;
      break;
    case "\r":
      r = /\r/g;
      break;
    case `\r
`:
      r = /\r\n/g;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(e)}.`);
  }
  let i = t.match(r);
  return i ? i.length : 0;
}
function aP(t) {
  return gh(!1, t, /\r\n?/g, `
`);
}
var Is = "string", Ln = "array", Ns = "cursor", an = "indent", on = "align", ln = "trim", or = "group", Rr = "fill", Sr = "if-break", un = "indent-if-break", cn = "line-suffix", hn = "line-suffix-boundary", Nt = "line", Mi = "label", jr = "break-parent", Tb = /* @__PURE__ */ new Set([Ns, an, on, ln, or, Rr, Sr, un, cn, hn, Nt, Mi, jr]);
function oP(t) {
  if (typeof t == "string")
    return Is;
  if (Array.isArray(t))
    return Ln;
  if (!t)
    return;
  let { type: e } = t;
  if (Tb.has(e))
    return e;
}
var _s = oP, lP = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function uP(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (_s(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let i = lP([...Tb].map((n) => `'${n}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${i}.`;
}
var cP = class extends Error {
  constructor(r) {
    super(uP(r));
    Gr(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, ka = cP, p0 = {};
function hP(t, e, r, i) {
  let n = [t];
  for (; n.length > 0; ) {
    let s = n.pop();
    if (s === p0) {
      r(n.pop());
      continue;
    }
    r && n.push(s, p0);
    let a = _s(s);
    if (!a)
      throw new ka(s);
    if ((e == null ? void 0 : e(s)) !== !1)
      switch (a) {
        case Ln:
        case Rr: {
          let o = a === Ln ? s : s.parts;
          for (let u = o.length, c = u - 1; c >= 0; --c)
            n.push(o[c]);
          break;
        }
        case Sr:
          n.push(s.flatContents, s.breakContents);
          break;
        case or:
          if (i && s.expandedStates)
            for (let o = s.expandedStates.length, u = o - 1; u >= 0; --u)
              n.push(s.expandedStates[u]);
          else
            n.push(s.contents);
          break;
        case on:
        case an:
        case un:
        case Mi:
        case cn:
          n.push(s.contents);
          break;
        case Is:
        case Ns:
        case ln:
        case hn:
        case Nt:
        case jr:
          break;
        default:
          throw new ka(s);
      }
  }
}
var Cm = hP, pP = () => {
}, dP = pP;
function Sc(t) {
  return { type: an, contents: t };
}
function Ta(t, e) {
  return { type: on, contents: e, n: t };
}
function Pb(t, e = {}) {
  return dP(e.expandedStates), { type: or, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function fP(t) {
  return Ta(Number.NEGATIVE_INFINITY, t);
}
function mP(t) {
  return Ta({ type: "root" }, t);
}
function gP(t) {
  return Ta(-1, t);
}
function yP(t, e) {
  return Pb(t[0], { ...e, expandedStates: t });
}
function Fb(t) {
  return { type: Rr, parts: t };
}
function OP(t, e = "", r = {}) {
  return { type: Sr, breakContents: t, flatContents: e, groupId: r.groupId };
}
function xP(t, e) {
  return { type: un, contents: t, groupId: e.groupId, negate: e.negate };
}
function Qd(t) {
  return { type: cn, contents: t };
}
var bP = { type: hn }, yh = { type: jr }, DP = { type: ln }, Am = { type: Nt, hard: !0 }, $b = { type: Nt, hard: !0, literal: !0 }, Bb = { type: Nt }, vP = { type: Nt, soft: !0 }, Os = [Am, yh], Ib = [$b, yh], Md = { type: Ns };
function Nb(t, e) {
  let r = [];
  for (let i = 0; i < e.length; i++)
    i !== 0 && r.push(t), r.push(e[i]);
  return r;
}
function _b(t, e, r) {
  let i = t;
  if (e > 0) {
    for (let n = 0; n < Math.floor(e / r); ++n)
      i = Sc(i);
    i = Ta(e % r, i), i = Ta(Number.NEGATIVE_INFINITY, i);
  }
  return i;
}
function SP(t, e) {
  return t ? { type: Mi, label: t, contents: e } : e;
}
function Ui(t) {
  var e;
  if (!t)
    return "";
  if (Array.isArray(t)) {
    let r = [];
    for (let i of t)
      if (Array.isArray(i))
        r.push(...Ui(i));
      else {
        let n = Ui(i);
        n !== "" && r.push(n);
      }
    return r;
  }
  return t.type === Sr ? { ...t, breakContents: Ui(t.breakContents), flatContents: Ui(t.flatContents) } : t.type === or ? { ...t, contents: Ui(t.contents), expandedStates: (e = t.expandedStates) == null ? void 0 : e.map(Ui) } : t.type === Rr ? { type: "fill", parts: t.parts.map(Ui) } : t.contents ? { ...t, contents: Ui(t.contents) } : t;
}
function wP(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Set();
  return i(Ui(t));
  function i(s, a, o) {
    var u, c;
    if (typeof s == "string")
      return JSON.stringify(s);
    if (Array.isArray(s)) {
      let h = s.map(i).filter(Boolean);
      return h.length === 1 ? h[0] : `[${h.join(", ")}]`;
    }
    if (s.type === Nt) {
      let h = ((u = o == null ? void 0 : o[a + 1]) == null ? void 0 : u.type) === jr;
      return s.literal ? h ? "literalline" : "literallineWithoutBreakParent" : s.hard ? h ? "hardline" : "hardlineWithoutBreakParent" : s.soft ? "softline" : "line";
    }
    if (s.type === jr)
      return ((c = o == null ? void 0 : o[a - 1]) == null ? void 0 : c.type) === Nt && o[a - 1].hard ? void 0 : "breakParent";
    if (s.type === ln)
      return "trim";
    if (s.type === an)
      return "indent(" + i(s.contents) + ")";
    if (s.type === on)
      return s.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + i(s.contents) + ")" : s.n < 0 ? "dedent(" + i(s.contents) + ")" : s.n.type === "root" ? "markAsRoot(" + i(s.contents) + ")" : "align(" + JSON.stringify(s.n) + ", " + i(s.contents) + ")";
    if (s.type === Sr)
      return "ifBreak(" + i(s.breakContents) + (s.flatContents ? ", " + i(s.flatContents) : "") + (s.groupId ? (s.flatContents ? "" : ', ""') + `, { groupId: ${n(s.groupId)} }` : "") + ")";
    if (s.type === un) {
      let h = [];
      s.negate && h.push("negate: true"), s.groupId && h.push(`groupId: ${n(s.groupId)}`);
      let d = h.length > 0 ? `, { ${h.join(", ")} }` : "";
      return `indentIfBreak(${i(s.contents)}${d})`;
    }
    if (s.type === or) {
      let h = [];
      s.break && s.break !== "propagated" && h.push("shouldBreak: true"), s.id && h.push(`id: ${n(s.id)}`);
      let d = h.length > 0 ? `, { ${h.join(", ")} }` : "";
      return s.expandedStates ? `conditionalGroup([${s.expandedStates.map((m) => i(m)).join(",")}]${d})` : `group(${i(s.contents)}${d})`;
    }
    if (s.type === Rr)
      return `fill([${s.parts.map((h) => i(h)).join(", ")}])`;
    if (s.type === cn)
      return "lineSuffix(" + i(s.contents) + ")";
    if (s.type === hn)
      return "lineSuffixBoundary";
    if (s.type === Mi)
      return `label(${JSON.stringify(s.label)}, ${i(s.contents)})`;
    throw new Error("Unknown doc type " + s.type);
  }
  function n(s) {
    if (typeof s != "symbol")
      return JSON.stringify(String(s));
    if (s in e)
      return e[s];
    let a = s.description || "symbol";
    for (let o = 0; ; o++) {
      let u = a + (o > 0 ? ` #${o}` : "");
      if (!r.has(u))
        return r.add(u), e[s] = `Symbol.for(${JSON.stringify(u)})`;
    }
  }
}
var CP = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, Dt = CP, AP = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function EP(t) {
  return t === 12288 || t >= 65281 && t <= 65376 || t >= 65504 && t <= 65510;
}
function kP(t) {
  return t >= 4352 && t <= 4447 || t === 8986 || t === 8987 || t === 9001 || t === 9002 || t >= 9193 && t <= 9196 || t === 9200 || t === 9203 || t === 9725 || t === 9726 || t === 9748 || t === 9749 || t >= 9800 && t <= 9811 || t === 9855 || t === 9875 || t === 9889 || t === 9898 || t === 9899 || t === 9917 || t === 9918 || t === 9924 || t === 9925 || t === 9934 || t === 9940 || t === 9962 || t === 9970 || t === 9971 || t === 9973 || t === 9978 || t === 9981 || t === 9989 || t === 9994 || t === 9995 || t === 10024 || t === 10060 || t === 10062 || t >= 10067 && t <= 10069 || t === 10071 || t >= 10133 && t <= 10135 || t === 10160 || t === 10175 || t === 11035 || t === 11036 || t === 11088 || t === 11093 || t >= 11904 && t <= 11929 || t >= 11931 && t <= 12019 || t >= 12032 && t <= 12245 || t >= 12272 && t <= 12287 || t >= 12289 && t <= 12350 || t >= 12353 && t <= 12438 || t >= 12441 && t <= 12543 || t >= 12549 && t <= 12591 || t >= 12593 && t <= 12686 || t >= 12688 && t <= 12771 || t >= 12783 && t <= 12830 || t >= 12832 && t <= 12871 || t >= 12880 && t <= 19903 || t >= 19968 && t <= 42124 || t >= 42128 && t <= 42182 || t >= 43360 && t <= 43388 || t >= 44032 && t <= 55203 || t >= 63744 && t <= 64255 || t >= 65040 && t <= 65049 || t >= 65072 && t <= 65106 || t >= 65108 && t <= 65126 || t >= 65128 && t <= 65131 || t >= 94176 && t <= 94180 || t === 94192 || t === 94193 || t >= 94208 && t <= 100343 || t >= 100352 && t <= 101589 || t >= 101632 && t <= 101640 || t >= 110576 && t <= 110579 || t >= 110581 && t <= 110587 || t === 110589 || t === 110590 || t >= 110592 && t <= 110882 || t === 110898 || t >= 110928 && t <= 110930 || t === 110933 || t >= 110948 && t <= 110951 || t >= 110960 && t <= 111355 || t === 126980 || t === 127183 || t === 127374 || t >= 127377 && t <= 127386 || t >= 127488 && t <= 127490 || t >= 127504 && t <= 127547 || t >= 127552 && t <= 127560 || t === 127568 || t === 127569 || t >= 127584 && t <= 127589 || t >= 127744 && t <= 127776 || t >= 127789 && t <= 127797 || t >= 127799 && t <= 127868 || t >= 127870 && t <= 127891 || t >= 127904 && t <= 127946 || t >= 127951 && t <= 127955 || t >= 127968 && t <= 127984 || t === 127988 || t >= 127992 && t <= 128062 || t === 128064 || t >= 128066 && t <= 128252 || t >= 128255 && t <= 128317 || t >= 128331 && t <= 128334 || t >= 128336 && t <= 128359 || t === 128378 || t === 128405 || t === 128406 || t === 128420 || t >= 128507 && t <= 128591 || t >= 128640 && t <= 128709 || t === 128716 || t >= 128720 && t <= 128722 || t >= 128725 && t <= 128727 || t >= 128732 && t <= 128735 || t === 128747 || t === 128748 || t >= 128756 && t <= 128764 || t >= 128992 && t <= 129003 || t === 129008 || t >= 129292 && t <= 129338 || t >= 129340 && t <= 129349 || t >= 129351 && t <= 129535 || t >= 129648 && t <= 129660 || t >= 129664 && t <= 129672 || t >= 129680 && t <= 129725 || t >= 129727 && t <= 129733 || t >= 129742 && t <= 129755 || t >= 129760 && t <= 129768 || t >= 129776 && t <= 129784 || t >= 131072 && t <= 196605 || t >= 196608 && t <= 262141;
}
var TP = (t) => !(EP(t) || kP(t)), PP = /[^\x20-\x7F]/;
function FP(t) {
  if (!t)
    return 0;
  if (!PP.test(t))
    return t.length;
  t = t.replace(AP(), "  ");
  let e = 0;
  for (let r of t) {
    let i = r.codePointAt(0);
    i <= 31 || i >= 127 && i <= 159 || i >= 768 && i <= 879 || (e += TP(i) ? 1 : 2);
  }
  return e;
}
var Em = FP, $P = (t) => {
  if (Array.isArray(t))
    return t;
  if (t.type !== Rr)
    throw new Error(`Expect doc to be 'array' or '${Rr}'.`);
  return t.parts;
};
function Oh(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return i(t);
  function i(s) {
    if (r.has(s))
      return r.get(s);
    let a = n(s);
    return r.set(s, a), a;
  }
  function n(s) {
    switch (_s(s)) {
      case Ln:
        return e(s.map(i));
      case Rr:
        return e({ ...s, parts: s.parts.map(i) });
      case Sr:
        return e({ ...s, breakContents: i(s.breakContents), flatContents: i(s.flatContents) });
      case or: {
        let { expandedStates: a, contents: o } = s;
        return a ? (a = a.map(i), o = a[0]) : o = i(o), e({ ...s, contents: o, expandedStates: a });
      }
      case on:
      case an:
      case un:
      case Mi:
      case cn:
        return e({ ...s, contents: i(s.contents) });
      case Is:
      case Ns:
      case ln:
      case hn:
      case Nt:
      case jr:
        return e(s);
      default:
        throw new ka(s);
    }
  }
}
function km(t, e, r) {
  let i = r, n = !1;
  function s(a) {
    if (n)
      return !1;
    let o = e(a);
    o !== void 0 && (n = !0, i = o);
  }
  return Cm(t, s), i;
}
function BP(t) {
  if (t.type === or && t.break || t.type === Nt && t.hard || t.type === jr)
    return !0;
}
function IP(t) {
  return km(t, BP, !1);
}
function d0(t) {
  if (t.length > 0) {
    let e = Dt(!1, t, -1);
    !e.expandedStates && !e.break && (e.break = "propagated");
  }
  return null;
}
function NP(t) {
  let e = /* @__PURE__ */ new Set(), r = [];
  function i(s) {
    if (s.type === jr && d0(r), s.type === or) {
      if (r.push(s), e.has(s))
        return !1;
      e.add(s);
    }
  }
  function n(s) {
    s.type === or && r.pop().break && d0(r);
  }
  Cm(t, i, n, !0);
}
function _P(t) {
  return t.type === Nt && !t.hard ? t.soft ? "" : " " : t.type === Sr ? t.flatContents : t;
}
function QP(t) {
  return Oh(t, _P);
}
function f0(t) {
  for (t = [...t]; t.length >= 2 && Dt(!1, t, -2).type === Nt && Dt(!1, t, -1).type === jr; )
    t.length -= 2;
  if (t.length > 0) {
    let e = Ro(Dt(!1, t, -1));
    t[t.length - 1] = e;
  }
  return t;
}
function Ro(t) {
  switch (_s(t)) {
    case on:
    case an:
    case un:
    case or:
    case cn:
    case Mi: {
      let e = Ro(t.contents);
      return { ...t, contents: e };
    }
    case Sr:
      return { ...t, breakContents: Ro(t.breakContents), flatContents: Ro(t.flatContents) };
    case Rr:
      return { ...t, parts: f0(t.parts) };
    case Ln:
      return f0(t);
    case Is:
      return t.replace(/[\n\r]*$/, "");
    case Ns:
    case ln:
    case hn:
    case Nt:
    case jr:
      break;
    default:
      throw new ka(t);
  }
  return t;
}
function Qb(t) {
  return Ro(LP(t));
}
function MP(t) {
  switch (_s(t)) {
    case Rr:
      if (t.parts.every((e) => e === ""))
        return "";
      break;
    case or:
      if (!t.contents && !t.id && !t.break && !t.expandedStates)
        return "";
      if (t.contents.type === or && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates)
        return t.contents;
      break;
    case on:
    case an:
    case un:
    case cn:
      if (!t.contents)
        return "";
      break;
    case Sr:
      if (!t.flatContents && !t.breakContents)
        return "";
      break;
    case Ln: {
      let e = [];
      for (let r of t) {
        if (!r)
          continue;
        let [i, ...n] = Array.isArray(r) ? r : [r];
        typeof i == "string" && typeof Dt(!1, e, -1) == "string" ? e[e.length - 1] += i : e.push(i), e.push(...n);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case Is:
    case Ns:
    case ln:
    case hn:
    case Nt:
    case Mi:
    case jr:
      break;
    default:
      throw new ka(t);
  }
  return t;
}
function LP(t) {
  return Oh(t, (e) => MP(e));
}
function RP(t, e = Ib) {
  return Oh(t, (r) => typeof r == "string" ? Nb(e, r.split(`
`)) : r);
}
function jP(t) {
  if (t.type === Nt)
    return !0;
}
function ZP(t) {
  return km(t, jP, !1);
}
function Mb(t, e) {
  return t.type === Mi ? { ...t, contents: e(t.contents) } : e(t);
}
var ir = Symbol("MODE_BREAK"), xi = Symbol("MODE_FLAT"), jo = Symbol("cursor");
function Lb() {
  return { value: "", length: 0, queue: [] };
}
function WP(t, e) {
  return Ld(t, { type: "indent" }, e);
}
function qP(t, e, r) {
  return e === Number.NEGATIVE_INFINITY ? t.root || Lb() : e < 0 ? Ld(t, { type: "dedent" }, r) : e ? e.type === "root" ? { ...t, root: t } : Ld(t, { type: typeof e == "string" ? "stringAlign" : "numberAlign", n: e }, r) : t;
}
function Ld(t, e, r) {
  let i = e.type === "dedent" ? t.queue.slice(0, -1) : [...t.queue, e], n = "", s = 0, a = 0, o = 0;
  for (let O of i)
    switch (O.type) {
      case "indent":
        h(), r.useTabs ? u(1) : c(r.tabWidth);
        break;
      case "stringAlign":
        h(), n += O.n, s += O.n.length;
        break;
      case "numberAlign":
        a += 1, o += O.n;
        break;
      default:
        throw new Error(`Unexpected type '${O.type}'`);
    }
  return m(), { ...t, value: n, length: s, queue: i };
  function u(O) {
    n += "	".repeat(O), s += r.tabWidth * O;
  }
  function c(O) {
    n += " ".repeat(O), s += O;
  }
  function h() {
    r.useTabs ? d() : m();
  }
  function d() {
    a > 0 && u(a), y();
  }
  function m() {
    o > 0 && c(o), y();
  }
  function y() {
    a = 0, o = 0;
  }
}
function Rd(t) {
  let e = 0, r = 0, i = t.length;
  e:
    for (; i--; ) {
      let n = t[i];
      if (n === jo) {
        r++;
        continue;
      }
      for (let s = n.length - 1; s >= 0; s--) {
        let a = n[s];
        if (a === " " || a === "	")
          e++;
        else {
          t[i] = n.slice(0, s + 1);
          break e;
        }
      }
    }
  if (e > 0 || r > 0)
    for (t.length = i + 1; r-- > 0; )
      t.push(jo);
  return e;
}
function gu(t, e, r, i, n, s) {
  if (r === Number.POSITIVE_INFINITY)
    return !0;
  let a = e.length, o = [t], u = [];
  for (; r >= 0; ) {
    if (o.length === 0) {
      if (a === 0)
        return !0;
      o.push(e[--a]);
      continue;
    }
    let { mode: c, doc: h } = o.pop();
    switch (_s(h)) {
      case Is:
        u.push(h), r -= Em(h);
        break;
      case Ln:
      case Rr: {
        let d = $P(h);
        for (let m = d.length - 1; m >= 0; m--)
          o.push({ mode: c, doc: d[m] });
        break;
      }
      case an:
      case on:
      case un:
      case Mi:
        o.push({ mode: c, doc: h.contents });
        break;
      case ln:
        r += Rd(u);
        break;
      case or: {
        if (s && h.break)
          return !1;
        let d = h.break ? ir : c, m = h.expandedStates && d === ir ? Dt(!1, h.expandedStates, -1) : h.contents;
        o.push({ mode: d, doc: m });
        break;
      }
      case Sr: {
        let d = (h.groupId ? n[h.groupId] || xi : c) === ir ? h.breakContents : h.flatContents;
        d && o.push({ mode: c, doc: d });
        break;
      }
      case Nt:
        if (c === ir || h.hard)
          return !0;
        h.soft || (u.push(" "), r--);
        break;
      case cn:
        i = !0;
        break;
      case hn:
        if (i)
          return !1;
        break;
    }
  }
  return !1;
}
function xh(t, e) {
  let r = {}, i = e.printWidth, n = wm(e.endOfLine), s = 0, a = [{ ind: Lb(), mode: ir, doc: t }], o = [], u = !1, c = [], h = 0;
  for (NP(t); a.length > 0; ) {
    let { ind: m, mode: y, doc: O } = a.pop();
    switch (_s(O)) {
      case Is: {
        let b = n !== `
` ? gh(!1, O, `
`, n) : O;
        o.push(b), a.length > 0 && (s += Em(b));
        break;
      }
      case Ln:
        for (let b = O.length - 1; b >= 0; b--)
          a.push({ ind: m, mode: y, doc: O[b] });
        break;
      case Ns:
        if (h >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        o.push(jo), h++;
        break;
      case an:
        a.push({ ind: WP(m, e), mode: y, doc: O.contents });
        break;
      case on:
        a.push({ ind: qP(m, O.n, e), mode: y, doc: O.contents });
        break;
      case ln:
        s -= Rd(o);
        break;
      case or:
        switch (y) {
          case xi:
            if (!u) {
              a.push({ ind: m, mode: O.break ? ir : xi, doc: O.contents });
              break;
            }
          case ir: {
            u = !1;
            let b = { ind: m, mode: xi, doc: O.contents }, v = i - s, S = c.length > 0;
            if (!O.break && gu(b, a, v, S, r))
              a.push(b);
            else if (O.expandedStates) {
              let x = Dt(!1, O.expandedStates, -1);
              if (O.break) {
                a.push({ ind: m, mode: ir, doc: x });
                break;
              } else
                for (let w = 1; w < O.expandedStates.length + 1; w++)
                  if (w >= O.expandedStates.length) {
                    a.push({ ind: m, mode: ir, doc: x });
                    break;
                  } else {
                    let k = O.expandedStates[w], C = { ind: m, mode: xi, doc: k };
                    if (gu(C, a, v, S, r)) {
                      a.push(C);
                      break;
                    }
                  }
            } else
              a.push({ ind: m, mode: ir, doc: O.contents });
            break;
          }
        }
        O.id && (r[O.id] = Dt(!1, a, -1).mode);
        break;
      case Rr: {
        let b = i - s, { parts: v } = O;
        if (v.length === 0)
          break;
        let [S, x] = v, w = { ind: m, mode: xi, doc: S }, k = { ind: m, mode: ir, doc: S }, C = gu(w, [], b, c.length > 0, r, !0);
        if (v.length === 1) {
          C ? a.push(w) : a.push(k);
          break;
        }
        let E = { ind: m, mode: xi, doc: x }, P = { ind: m, mode: ir, doc: x };
        if (v.length === 2) {
          C ? a.push(E, w) : a.push(P, k);
          break;
        }
        v.splice(0, 2);
        let I = { ind: m, mode: y, doc: Fb(v) }, B = v[0];
        gu({ ind: m, mode: xi, doc: [S, x, B] }, [], b, c.length > 0, r, !0) ? a.push(I, E, w) : C ? a.push(I, P, w) : a.push(I, P, k);
        break;
      }
      case Sr:
      case un: {
        let b = O.groupId ? r[O.groupId] : y;
        if (b === ir) {
          let v = O.type === Sr ? O.breakContents : O.negate ? O.contents : Sc(O.contents);
          v && a.push({ ind: m, mode: y, doc: v });
        }
        if (b === xi) {
          let v = O.type === Sr ? O.flatContents : O.negate ? Sc(O.contents) : O.contents;
          v && a.push({ ind: m, mode: y, doc: v });
        }
        break;
      }
      case cn:
        c.push({ ind: m, mode: y, doc: O.contents });
        break;
      case hn:
        c.length > 0 && a.push({ ind: m, mode: y, doc: Am });
        break;
      case Nt:
        switch (y) {
          case xi:
            if (O.hard)
              u = !0;
            else {
              O.soft || (o.push(" "), s += 1);
              break;
            }
          case ir:
            if (c.length > 0) {
              a.push({ ind: m, mode: y, doc: O }, ...c.reverse()), c.length = 0;
              break;
            }
            O.literal ? m.root ? (o.push(n, m.root.value), s = m.root.length) : (o.push(n), s = 0) : (s -= Rd(o), o.push(n + m.value), s = m.length);
            break;
        }
        break;
      case Mi:
        a.push({ ind: m, mode: y, doc: O.contents });
        break;
      case jr:
        break;
      default:
        throw new ka(O);
    }
    a.length === 0 && c.length > 0 && (a.push(...c.reverse()), c.length = 0);
  }
  let d = o.indexOf(jo);
  if (d !== -1) {
    let m = o.indexOf(jo, d + 1), y = o.slice(0, d).join(""), O = o.slice(d + 1, m).join(""), b = o.slice(m + 1).join("");
    return { formatted: y + O + b, cursorNodeStart: y.length, cursorNodeText: O };
  }
  return { formatted: o.join("") };
}
function XP(t, e, r = 0) {
  let i = 0;
  for (let n = r; n < t.length; ++n)
    t[n] === "	" ? i = i + e - i % e : i++;
  return i;
}
var Tm = XP, ec, jd, Po, tc, VP = class {
  constructor(e) {
    h0(this, ec), h0(this, Po), this.stack = [e];
  }
  get key() {
    let { stack: e, siblings: r } = this;
    return Dt(!1, e, r === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : Dt(!1, this.stack, -2);
  }
  get node() {
    return Dt(!1, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: e } = this, r = Dt(!1, e, -3);
    return Array.isArray(r) ? r : null;
  }
  get next() {
    let { siblings: e } = this;
    return e === null ? null : e[this.index + 1];
  }
  get previous() {
    let { siblings: e } = this;
    return e === null ? null : e[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: e, index: r } = this;
    return e !== null && r === e.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...po(this, Po, tc).call(this)];
  }
  getName() {
    let { stack: e } = this, { length: r } = e;
    return r > 1 ? Dt(!1, e, -2) : null;
  }
  getValue() {
    return Dt(!1, this.stack, -1);
  }
  getNode(e = 0) {
    let r = po(this, ec, jd).call(this, e);
    return r === -1 ? null : this.stack[r];
  }
  getParentNode(e = 0) {
    return this.getNode(e + 1);
  }
  call(e, ...r) {
    let { stack: i } = this, { length: n } = i, s = Dt(!1, i, -1);
    for (let a of r)
      s = s[a], i.push(a, s);
    try {
      return e(this);
    } finally {
      i.length = n;
    }
  }
  callParent(e, r = 0) {
    let i = po(this, ec, jd).call(this, r + 1), n = this.stack.splice(i + 1);
    try {
      return e(this);
    } finally {
      this.stack.push(...n);
    }
  }
  each(e, ...r) {
    let { stack: i } = this, { length: n } = i, s = Dt(!1, i, -1);
    for (let a of r)
      s = s[a], i.push(a, s);
    try {
      for (let a = 0; a < s.length; ++a)
        i.push(a, s[a]), e(this, a, s), i.length -= 2;
    } finally {
      i.length = n;
    }
  }
  map(e, ...r) {
    let i = [];
    return this.each((n, s, a) => {
      i[s] = e(n, s, a);
    }, ...r), i;
  }
  match(...e) {
    let r = this.stack.length - 1, i = null, n = this.stack[r--];
    for (let s of e) {
      if (n === void 0)
        return !1;
      let a = null;
      if (typeof i == "number" && (a = i, i = this.stack[r--], n = this.stack[r--]), s && !s(n, i, a))
        return !1;
      i = this.stack[r--], n = this.stack[r--];
    }
    return !0;
  }
  findAncestor(e) {
    for (let r of po(this, Po, tc).call(this))
      if (e(r))
        return r;
  }
  hasAncestor(e) {
    for (let r of po(this, Po, tc).call(this))
      if (e(r))
        return !0;
    return !1;
  }
};
ec = /* @__PURE__ */ new WeakSet(), jd = function(t) {
  let { stack: e } = this;
  for (let r = e.length - 1; r >= 0; r -= 2)
    if (!Array.isArray(e[r]) && --t < 0)
      return r;
  return -1;
}, Po = /* @__PURE__ */ new WeakSet(), tc = function* () {
  let { stack: t } = this;
  for (let e = t.length - 3; e >= 0; e -= 2) {
    let r = t[e];
    Array.isArray(r) || (yield r);
  }
};
var YP = VP, Rb = new Proxy(() => {
}, { get: () => Rb }), Zd = Rb;
function UP(t) {
  return t !== null && typeof t == "object";
}
var zP = UP;
function* jb(t, e) {
  let { getVisitorKeys: r, filter: i = () => !0 } = e, n = (s) => zP(s) && i(s);
  for (let s of r(t)) {
    let a = t[s];
    if (Array.isArray(a))
      for (let o of a)
        n(o) && (yield o);
    else
      n(a) && (yield a);
  }
}
function* GP(t, e) {
  let r = [t];
  for (let i = 0; i < r.length; i++) {
    let n = r[i];
    for (let s of jb(n, e))
      yield s, r.push(s);
  }
}
function Tl(t) {
  return (e, r, i) => {
    let n = !!(i != null && i.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, a = r;
    for (; a >= 0 && a < s; ) {
      let o = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(o))
          return a;
      } else if (!t.includes(o))
        return a;
      n ? a-- : a++;
    }
    return a === -1 || a === s ? a : !1;
  };
}
var HP = Tl(/\s/), Rn = Tl(" 	"), Zb = Tl(",; 	"), Wb = Tl(/[^\n\r]/);
function JP(t, e, r) {
  let i = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let n = t.charAt(e);
  if (i) {
    if (t.charAt(e - 1) === "\r" && n === `
`)
      return e - 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e - 1;
  } else {
    if (n === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e + 1;
  }
  return e;
}
var xs = JP;
function KP(t, e, r = {}) {
  let i = Rn(t, r.backwards ? e - 1 : e, r), n = xs(t, i, r);
  return i !== n;
}
var Nn = KP;
function eF(t) {
  return Array.isArray(t) && t.length > 0;
}
var tF = eF, qb = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]), rF = (t) => Object.keys(t).filter((e) => !qb.has(e));
function iF(t) {
  return t ? (e) => t(e, qb) : rF;
}
var bh = iF;
function nF(t) {
  let e = t.type || t.kind || "(unknown type)", r = String(t.name || t.id && (typeof t.id == "object" ? t.id.name : t.id) || t.key && (typeof t.key == "object" ? t.key.name : t.key) || t.value && (typeof t.value == "object" ? "" : String(t.value)) || t.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + ""), e + (r ? " " + r : "");
}
function Pm(t, e) {
  (t.comments ?? (t.comments = [])).push(e), e.printed = !1, e.nodeDescription = nF(t);
}
function pa(t, e) {
  e.leading = !0, e.trailing = !1, Pm(t, e);
}
function os(t, e, r) {
  e.leading = !1, e.trailing = !1, r && (e.marker = r), Pm(t, e);
}
function da(t, e) {
  e.leading = !1, e.trailing = !0, Pm(t, e);
}
var Ep = /* @__PURE__ */ new WeakMap();
function Fm(t, e) {
  if (Ep.has(t))
    return Ep.get(t);
  let { printer: { getCommentChildNodes: r, canAttachComment: i, getVisitorKeys: n }, locStart: s, locEnd: a } = e;
  if (!i)
    return [];
  let o = ((r == null ? void 0 : r(t, e)) ?? [...jb(t, { getVisitorKeys: bh(n) })]).flatMap((u) => i(u) ? [u] : Fm(u, e));
  return o.sort((u, c) => s(u) - s(c) || a(u) - a(c)), Ep.set(t, o), o;
}
function Xb(t, e, r, i) {
  let { locStart: n, locEnd: s } = r, a = n(e), o = s(e), u = Fm(t, r), c, h, d = 0, m = u.length;
  for (; d < m; ) {
    let y = d + m >> 1, O = u[y], b = n(O), v = s(O);
    if (b <= a && o <= v)
      return Xb(O, e, r, O);
    if (v <= a) {
      c = O, d = y + 1;
      continue;
    }
    if (o <= b) {
      h = O, m = y;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((i == null ? void 0 : i.type) === "TemplateLiteral") {
    let { quasis: y } = i, O = Tp(y, e, r);
    c && Tp(y, c, r) !== O && (c = null), h && Tp(y, h, r) !== O && (h = null);
  }
  return { enclosingNode: i, precedingNode: c, followingNode: h };
}
var kp = () => !1;
function sF(t, e) {
  let { comments: r } = t;
  if (delete t.comments, !tF(r) || !e.printer.canAttachComment)
    return;
  let i = [], { locStart: n, locEnd: s, printer: { experimentalFeatures: { avoidAstMutation: a = !1 } = {}, handleComments: o = {} }, originalText: u } = e, { ownLine: c = kp, endOfLine: h = kp, remaining: d = kp } = o, m = r.map((y, O) => ({ ...Xb(t, y, e), comment: y, text: u, options: e, ast: t, isLastComment: r.length - 1 === O }));
  for (let [y, O] of m.entries()) {
    let { comment: b, precedingNode: v, enclosingNode: S, followingNode: x, text: w, options: k, ast: C, isLastComment: E } = O;
    if (k.parser === "json" || k.parser === "json5" || k.parser === "jsonc" || k.parser === "__js_expression" || k.parser === "__ts_expression" || k.parser === "__vue_expression" || k.parser === "__vue_ts_expression") {
      if (n(b) - n(C) <= 0) {
        pa(C, b);
        continue;
      }
      if (s(b) - s(C) >= 0) {
        da(C, b);
        continue;
      }
    }
    let P;
    if (a ? P = [O] : (b.enclosingNode = S, b.precedingNode = v, b.followingNode = x, P = [b, w, k, C, E]), aF(w, k, m, y))
      b.placement = "ownLine", c(...P) || (x ? pa(x, b) : v ? da(v, b) : os(S || C, b));
    else if (oF(w, k, m, y))
      b.placement = "endOfLine", h(...P) || (v ? da(v, b) : x ? pa(x, b) : os(S || C, b));
    else if (b.placement = "remaining", !d(...P))
      if (v && x) {
        let I = i.length;
        I > 0 && i[I - 1].followingNode !== x && m0(i, k), i.push(O);
      } else
        v ? da(v, b) : x ? pa(x, b) : os(S || C, b);
  }
  if (m0(i, e), !a)
    for (let y of r)
      delete y.precedingNode, delete y.enclosingNode, delete y.followingNode;
}
var Vb = (t) => !/[\S\n\u2028\u2029]/.test(t);
function aF(t, e, r, i) {
  let { comment: n, precedingNode: s } = r[i], { locStart: a, locEnd: o } = e, u = a(n);
  if (s)
    for (let c = i - 1; c >= 0; c--) {
      let { comment: h, precedingNode: d } = r[c];
      if (d !== s || !Vb(t.slice(o(h), u)))
        break;
      u = a(h);
    }
  return Nn(t, u, { backwards: !0 });
}
function oF(t, e, r, i) {
  let { comment: n, followingNode: s } = r[i], { locStart: a, locEnd: o } = e, u = o(n);
  if (s)
    for (let c = i + 1; c < r.length; c++) {
      let { comment: h, followingNode: d } = r[c];
      if (d !== s || !Vb(t.slice(u, a(h))))
        break;
      u = o(h);
    }
  return Nn(t, u);
}
function m0(t, e) {
  var r, i;
  let n = t.length;
  if (n === 0)
    return;
  let { precedingNode: s, followingNode: a } = t[0], o = e.locStart(a), u;
  for (u = n; u > 0; --u) {
    let { comment: c, precedingNode: h, followingNode: d } = t[u - 1];
    Zd.strictEqual(h, s), Zd.strictEqual(d, a);
    let m = e.originalText.slice(e.locEnd(c), o);
    if (((i = (r = e.printer).isGap) == null ? void 0 : i.call(r, m, e)) ?? /^[\s(]*$/.test(m))
      o = e.locStart(c);
    else
      break;
  }
  for (let [c, { comment: h }] of t.entries())
    c < u ? da(s, h) : pa(a, h);
  for (let c of [s, a])
    c.comments && c.comments.length > 1 && c.comments.sort((h, d) => e.locStart(h) - e.locStart(d));
  t.length = 0;
}
function Tp(t, e, r) {
  let i = r.locStart(e) - 1;
  for (let n = 1; n < t.length; ++n)
    if (i < r.locStart(t[n]))
      return n - 1;
  return 0;
}
function lF(t, e) {
  let r = e - 1;
  r = Rn(t, r, { backwards: !0 }), r = xs(t, r, { backwards: !0 }), r = Rn(t, r, { backwards: !0 });
  let i = xs(t, r, { backwards: !0 });
  return r !== i;
}
var $m = lF;
function Yb(t, e) {
  let r = t.node;
  return r.printed = !0, e.printer.printComment(t, e);
}
function uF(t, e) {
  var r;
  let i = t.node, n = [Yb(t, e)], { printer: s, originalText: a, locStart: o, locEnd: u } = e;
  if ((r = s.isBlockComment) != null && r.call(s, i)) {
    let h = Nn(a, u(i)) ? Nn(a, o(i), { backwards: !0 }) ? Os : Bb : " ";
    n.push(h);
  } else
    n.push(Os);
  let c = xs(a, Rn(a, u(i)));
  return c !== !1 && Nn(a, c) && n.push(Os), n;
}
function cF(t, e, r) {
  var i;
  let n = t.node, s = Yb(t, e), { printer: a, originalText: o, locStart: u } = e, c = (i = a.isBlockComment) == null ? void 0 : i.call(a, n);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || Nn(o, u(n), { backwards: !0 })) {
    let h = $m(o, u(n));
    return { doc: Qd([Os, h ? Os : "", s]), isBlock: c, hasLineSuffix: !0 };
  }
  return !c || r != null && r.hasLineSuffix ? { doc: [Qd([" ", s]), yh], isBlock: c, hasLineSuffix: !0 } : { doc: [" ", s], isBlock: c, hasLineSuffix: !1 };
}
function hF(t, e) {
  let r = t.node;
  if (!r)
    return {};
  let i = e[Symbol.for("printedComments")];
  if ((r.comments || []).filter((o) => !i.has(o)).length === 0)
    return { leading: "", trailing: "" };
  let n = [], s = [], a;
  return t.each(() => {
    let o = t.node;
    if (i != null && i.has(o))
      return;
    let { leading: u, trailing: c } = o;
    u ? n.push(uF(t, e)) : c && (a = cF(t, e, a), s.push(a.doc));
  }, "comments"), { leading: n, trailing: s };
}
function pF(t, e, r) {
  let { leading: i, trailing: n } = hF(t, r);
  return !i && !n ? e : Mb(e, (s) => [i, s, n]);
}
function dF(t) {
  let { [Symbol.for("comments")]: e, [Symbol.for("printedComments")]: r } = t;
  for (let i of e) {
    if (!i.printed && !r.has(i))
      throw new Error('Comment "' + i.value.trim() + '" was not printed. Please report this error!');
    delete i.printed;
  }
}
var Ub = class extends Error {
  constructor() {
    super(...arguments);
    Gr(this, "name", "ConfigError");
  }
}, g0 = class extends Error {
  constructor() {
    super(...arguments);
    Gr(this, "name", "UndefinedParserError");
  }
}, fF = { cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (t) => typeof t == "string" || typeof t == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }] }, plugins: { type: "path", array: !0, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (t) => typeof t == "string" || typeof t == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: !1, description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: !1, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function zb({ plugins: t = [], showDeprecated: e = !1 } = {}) {
  let r = t.flatMap((n) => n.languages ?? []), i = [];
  for (let n of gF(Object.assign({}, ...t.map(({ options: s }) => s), fF)))
    !e && n.deprecated || (Array.isArray(n.choices) && (e || (n.choices = n.choices.filter((s) => !s.deprecated)), n.name === "parser" && (n.choices = [...n.choices, ...mF(n.choices, r, t)])), n.pluginDefaults = Object.fromEntries(t.filter((s) => {
      var a;
      return ((a = s.defaultOptions) == null ? void 0 : a[n.name]) !== void 0;
    }).map((s) => [s.name, s.defaultOptions[n.name]])), i.push(n));
  return { languages: r, options: i };
}
function* mF(t, e, r) {
  let i = new Set(t.map((n) => n.value));
  for (let n of e)
    if (n.parsers) {
      for (let s of n.parsers)
        if (!i.has(s)) {
          i.add(s);
          let a = r.find((u) => u.parsers && Object.prototype.hasOwnProperty.call(u.parsers, s)), o = n.name;
          a != null && a.name && (o += ` (plugin: ${a.name})`), yield { value: s, description: o };
        }
    }
}
function gF(t) {
  let e = [];
  for (let [r, i] of Object.entries(t)) {
    let n = { name: r, ...i };
    Array.isArray(n.default) && (n.default = Dt(!1, n.default, -1).value), e.push(n);
  }
  return e;
}
var yF = (t) => String(t).split(/[/\\]/).pop();
function y0(t, e) {
  if (!e)
    return;
  let r = yF(e).toLowerCase();
  return t.find(({ filenames: i }) => i == null ? void 0 : i.some((n) => n.toLowerCase() === r)) ?? t.find(({ extensions: i }) => i == null ? void 0 : i.some((n) => r.endsWith(n)));
}
function OF(t, e) {
  if (e)
    return t.find(({ name: r }) => r.toLowerCase() === e) ?? t.find(({ aliases: r }) => r == null ? void 0 : r.includes(e)) ?? t.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${e}`));
}
function xF(t, e) {
  let r = t.plugins.flatMap((n) => n.languages ?? []), i = OF(r, e.language) ?? y0(r, e.physicalFile) ?? y0(r, e.file) ?? (e.physicalFile, void 0);
  return i == null ? void 0 : i.parsers[0];
}
var bF = xF, fa = { key: (t) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(t) ? t : JSON.stringify(t), value(t) {
  if (t === null || typeof t != "object")
    return JSON.stringify(t);
  if (Array.isArray(t))
    return `[${t.map((r) => fa.value(r)).join(", ")}]`;
  let e = Object.keys(t);
  return e.length === 0 ? "{}" : `{ ${e.map((r) => `${fa.key(r)}: ${fa.value(t[r])}`).join(", ")} }`;
}, pair: ({ key: t, value: e }) => fa.value({ [t]: e }) }, O0 = kl(mh(), 1), DF = (t, e, { descriptor: r }) => {
  let i = [`${O0.default.yellow(typeof t == "string" ? r.key(t) : r.pair(t))} is deprecated`];
  return e && i.push(`we now treat it as ${O0.default.blue(typeof e == "string" ? r.key(e) : r.pair(e))}`), i.join("; ") + ".";
}, ma = kl(mh(), 1), Gb = Symbol.for("vnopts.VALUE_NOT_EXIST"), rc = Symbol.for("vnopts.VALUE_UNCHANGED"), x0 = " ".repeat(2), vF = (t, e, r) => {
  let { text: i, list: n } = r.normalizeExpectedResult(r.schemas[t].expected(r)), s = [];
  return i && s.push(b0(t, e, i, r.descriptor)), n && s.push([b0(t, e, n.title, r.descriptor)].concat(n.values.map((a) => Hb(a, r.loggerPrintWidth))).join(`
`)), Jb(s, r.loggerPrintWidth);
};
function b0(t, e, r, i) {
  return [`Invalid ${ma.default.red(i.key(t))} value.`, `Expected ${ma.default.blue(r)},`, `but received ${e === Gb ? ma.default.gray("nothing") : ma.default.red(i.value(e))}.`].join(" ");
}
function Hb({ text: t, list: e }, r) {
  let i = [];
  return t && i.push(`- ${ma.default.blue(t)}`), e && i.push([`- ${ma.default.blue(e.title)}:`].concat(e.values.map((n) => Hb(n, r - x0.length).replace(/^|\n/g, `$&${x0}`))).join(`
`)), Jb(i, r);
}
function Jb(t, e) {
  if (t.length === 1)
    return t[0];
  let [r, i] = t, [n, s] = t.map((a) => a.split(`
`, 1)[0].length);
  return n > e && n > s ? i : r;
}
var D0 = kl(mh(), 1), Pp = [], v0 = [];
function SF(t, e) {
  if (t === e)
    return 0;
  let r = t;
  t.length > e.length && (t = e, e = r);
  let i = t.length, n = e.length;
  for (; i > 0 && t.charCodeAt(~-i) === e.charCodeAt(~-n); )
    i--, n--;
  let s = 0;
  for (; s < i && t.charCodeAt(s) === e.charCodeAt(s); )
    s++;
  if (i -= s, n -= s, i === 0)
    return n;
  let a, o, u, c, h = 0, d = 0;
  for (; h < i; )
    v0[h] = t.charCodeAt(s + h), Pp[h] = ++h;
  for (; d < n; )
    for (a = e.charCodeAt(s + d), u = d++, o = d, h = 0; h < i; h++)
      c = a === v0[h] ? u : u + 1, u = Pp[h], o = Pp[h] = u > o ? c > o ? o + 1 : c : c > u ? u + 1 : c;
  return o;
}
var Kb = (t, e, { descriptor: r, logger: i, schemas: n }) => {
  let s = [`Ignored unknown option ${D0.default.yellow(r.pair({ key: t, value: e }))}.`], a = Object.keys(n).sort().find((o) => SF(t, o) < 3);
  a && s.push(`Did you mean ${D0.default.blue(r.key(a))}?`), i.warn(s.join(" "));
}, wF = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function CF(t, e) {
  let r = new t(e), i = Object.create(r);
  for (let n of wF)
    n in e && (i[n] = AF(e[n], r, Gn.prototype[n].length));
  return i;
}
var Gn = class {
  static create(e) {
    return CF(this, e);
  }
  constructor(e) {
    this.name = e.name;
  }
  default(e) {
  }
  expected(e) {
    return "nothing";
  }
  validate(e, r) {
    return !1;
  }
  deprecated(e, r) {
    return !1;
  }
  forward(e, r) {
  }
  redirect(e, r) {
  }
  overlap(e, r, i) {
    return e;
  }
  preprocess(e, r) {
    return e;
  }
  postprocess(e, r) {
    return rc;
  }
};
function AF(t, e, r) {
  return typeof t == "function" ? (...i) => t(...i.slice(0, r - 1), e, ...i.slice(r - 1)) : () => t;
}
var EF = class extends Gn {
  constructor(e) {
    super(e), this._sourceName = e.sourceName;
  }
  expected(e) {
    return e.schemas[this._sourceName].expected(e);
  }
  validate(e, r) {
    return r.schemas[this._sourceName].validate(e, r);
  }
  redirect(e, r) {
    return this._sourceName;
  }
}, kF = class extends Gn {
  expected() {
    return "anything";
  }
  validate() {
    return !0;
  }
}, TF = class extends Gn {
  constructor({ valueSchema: e, name: r = e.name, ...i }) {
    super({ ...i, name: r }), this._valueSchema = e;
  }
  expected(e) {
    let { text: r, list: i } = e.normalizeExpectedResult(this._valueSchema.expected(e));
    return { text: r && `an array of ${r}`, list: i && { title: "an array of the following values", values: [{ list: i }] } };
  }
  validate(e, r) {
    if (!Array.isArray(e))
      return !1;
    let i = [];
    for (let n of e) {
      let s = r.normalizeValidateResult(this._valueSchema.validate(n, r), n);
      s !== !0 && i.push(s.value);
    }
    return i.length === 0 ? !0 : { value: i };
  }
  deprecated(e, r) {
    let i = [];
    for (let n of e) {
      let s = r.normalizeDeprecatedResult(this._valueSchema.deprecated(n, r), n);
      s !== !1 && i.push(...s.map(({ value: a }) => ({ value: [a] })));
    }
    return i;
  }
  forward(e, r) {
    let i = [];
    for (let n of e) {
      let s = r.normalizeForwardResult(this._valueSchema.forward(n, r), n);
      i.push(...s.map(S0));
    }
    return i;
  }
  redirect(e, r) {
    let i = [], n = [];
    for (let s of e) {
      let a = r.normalizeRedirectResult(this._valueSchema.redirect(s, r), s);
      "remain" in a && i.push(a.remain), n.push(...a.redirect.map(S0));
    }
    return i.length === 0 ? { redirect: n } : { redirect: n, remain: i };
  }
  overlap(e, r) {
    return e.concat(r);
  }
};
function S0({ from: t, to: e }) {
  return { from: [t], to: e };
}
var PF = class extends Gn {
  expected() {
    return "true or false";
  }
  validate(e) {
    return typeof e == "boolean";
  }
};
function FF(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let i of t) {
    let n = i[e];
    if (r[n])
      throw new Error(`Duplicate ${e} ${JSON.stringify(n)}`);
    r[n] = i;
  }
  return r;
}
function $F(t, e) {
  let r = /* @__PURE__ */ new Map();
  for (let i of t) {
    let n = i[e];
    if (r.has(n))
      throw new Error(`Duplicate ${e} ${JSON.stringify(n)}`);
    r.set(n, i);
  }
  return r;
}
function BF() {
  let t = /* @__PURE__ */ Object.create(null);
  return (e) => {
    let r = JSON.stringify(e);
    return t[r] ? !0 : (t[r] = !0, !1);
  };
}
function IF(t, e) {
  let r = [], i = [];
  for (let n of t)
    e(n) ? r.push(n) : i.push(n);
  return [r, i];
}
function NF(t) {
  return t === Math.floor(t);
}
function _F(t, e) {
  if (t === e)
    return 0;
  let r = typeof t, i = typeof e, n = ["undefined", "object", "boolean", "number", "string"];
  return r !== i ? n.indexOf(r) - n.indexOf(i) : r !== "string" ? Number(t) - Number(e) : t.localeCompare(e);
}
function QF(t) {
  return (...e) => {
    let r = t(...e);
    return typeof r == "string" ? new Error(r) : r;
  };
}
function w0(t) {
  return t === void 0 ? {} : t;
}
function eD(t) {
  if (typeof t == "string")
    return { text: t };
  let { text: e, list: r } = t;
  return MF((e || r) !== void 0, "Unexpected `expected` result, there should be at least one field."), r ? { text: e, list: { title: r.title, values: r.values.map(eD) } } : { text: e };
}
function C0(t, e) {
  return t === !0 ? !0 : t === !1 ? { value: e } : t;
}
function A0(t, e, r = !1) {
  return t === !1 ? !1 : t === !0 ? r ? !0 : [{ value: e }] : "value" in t ? [t] : t.length === 0 ? !1 : t;
}
function E0(t, e) {
  return typeof t == "string" || "key" in t ? { from: e, to: t } : "from" in t ? { from: t.from, to: t.to } : { from: e, to: t.to };
}
function Wd(t, e) {
  return t === void 0 ? [] : Array.isArray(t) ? t.map((r) => E0(r, e)) : [E0(t, e)];
}
function k0(t, e) {
  let r = Wd(typeof t == "object" && "redirect" in t ? t.redirect : t, e);
  return r.length === 0 ? { remain: e, redirect: r } : typeof t == "object" && "remain" in t ? { remain: t.remain, redirect: r } : { redirect: r };
}
function MF(t, e) {
  if (!t)
    throw new Error(e);
}
var LF = class extends Gn {
  constructor(e) {
    super(e), this._choices = $F(e.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
  }
  expected({ descriptor: e }) {
    let r = Array.from(this._choices.keys()).map((s) => this._choices.get(s)).filter(({ hidden: s }) => !s).map((s) => s.value).sort(_F).map(e.value), i = r.slice(0, -2), n = r.slice(-2);
    return { text: i.concat(n.join(" or ")).join(", "), list: { title: "one of the following values", values: r } };
  }
  validate(e) {
    return this._choices.has(e);
  }
  deprecated(e) {
    let r = this._choices.get(e);
    return r && r.deprecated ? { value: e } : !1;
  }
  forward(e) {
    let r = this._choices.get(e);
    return r ? r.forward : void 0;
  }
  redirect(e) {
    let r = this._choices.get(e);
    return r ? r.redirect : void 0;
  }
}, RF = class extends Gn {
  expected() {
    return "a number";
  }
  validate(e, r) {
    return typeof e == "number";
  }
}, jF = class extends RF {
  expected() {
    return "an integer";
  }
  validate(e, r) {
    return r.normalizeValidateResult(super.validate(e, r), e) === !0 && NF(e);
  }
}, T0 = class extends Gn {
  expected() {
    return "a string";
  }
  validate(e) {
    return typeof e == "string";
  }
}, ZF = fa, WF = Kb, qF = vF, XF = DF, VF = class {
  constructor(e, r) {
    let { logger: i = console, loggerPrintWidth: n = 80, descriptor: s = ZF, unknown: a = WF, invalid: o = qF, deprecated: u = XF, missing: c = () => !1, required: h = () => !1, preprocess: d = (y) => y, postprocess: m = () => rc } = r || {};
    this._utils = { descriptor: s, logger: i || { warn: () => {
    } }, loggerPrintWidth: n, schemas: FF(e, "name"), normalizeDefaultResult: w0, normalizeExpectedResult: eD, normalizeDeprecatedResult: A0, normalizeForwardResult: Wd, normalizeRedirectResult: k0, normalizeValidateResult: C0 }, this._unknownHandler = a, this._invalidHandler = QF(o), this._deprecatedHandler = u, this._identifyMissing = (y, O) => !(y in O) || c(y, O), this._identifyRequired = h, this._preprocess = d, this._postprocess = m, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = BF();
  }
  normalize(e) {
    let r = {}, i = [this._preprocess(e, this._utils)], n = () => {
      for (; i.length !== 0; ) {
        let s = i.shift(), a = this._applyNormalization(s, r);
        i.push(...a);
      }
    };
    n();
    for (let s of Object.keys(this._utils.schemas)) {
      let a = this._utils.schemas[s];
      if (!(s in r)) {
        let o = w0(a.default(this._utils));
        "value" in o && i.push({ [s]: o.value });
      }
    }
    n();
    for (let s of Object.keys(this._utils.schemas)) {
      if (!(s in r))
        continue;
      let a = this._utils.schemas[s], o = r[s], u = a.postprocess(o, this._utils);
      u !== rc && (this._applyValidation(u, s, a), r[s] = u);
    }
    return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
  }
  _applyNormalization(e, r) {
    let i = [], { knownKeys: n, unknownKeys: s } = this._partitionOptionKeys(e);
    for (let a of n) {
      let o = this._utils.schemas[a], u = o.preprocess(e[a], this._utils);
      this._applyValidation(u, a, o);
      let c = ({ from: m, to: y }) => {
        i.push(typeof y == "string" ? { [y]: m } : { [y.key]: y.value });
      }, h = ({ value: m, redirectTo: y }) => {
        let O = A0(o.deprecated(m, this._utils), u, !0);
        if (O !== !1)
          if (O === !0)
            this._hasDeprecationWarned(a) || this._utils.logger.warn(this._deprecatedHandler(a, y, this._utils));
          else
            for (let { value: b } of O) {
              let v = { key: a, value: b };
              if (!this._hasDeprecationWarned(v)) {
                let S = typeof y == "string" ? { key: y, value: b } : y;
                this._utils.logger.warn(this._deprecatedHandler(v, S, this._utils));
              }
            }
      };
      Wd(o.forward(u, this._utils), u).forEach(c);
      let d = k0(o.redirect(u, this._utils), u);
      if (d.redirect.forEach(c), "remain" in d) {
        let m = d.remain;
        r[a] = a in r ? o.overlap(r[a], m, this._utils) : m, h({ value: m });
      }
      for (let { from: m, to: y } of d.redirect)
        h({ value: m, redirectTo: y });
    }
    for (let a of s) {
      let o = e[a];
      this._applyUnknownHandler(a, o, r, (u, c) => {
        i.push({ [u]: c });
      });
    }
    return i;
  }
  _applyRequiredCheck(e) {
    for (let r of Object.keys(this._utils.schemas))
      if (this._identifyMissing(r, e) && this._identifyRequired(r))
        throw this._invalidHandler(r, Gb, this._utils);
  }
  _partitionOptionKeys(e) {
    let [r, i] = IF(Object.keys(e).filter((n) => !this._identifyMissing(n, e)), (n) => n in this._utils.schemas);
    return { knownKeys: r, unknownKeys: i };
  }
  _applyValidation(e, r, i) {
    let n = C0(i.validate(e, this._utils), e);
    if (n !== !0)
      throw this._invalidHandler(r, n.value, this._utils);
  }
  _applyUnknownHandler(e, r, i, n) {
    let s = this._unknownHandler(e, r, this._utils);
    if (s)
      for (let a of Object.keys(s)) {
        if (this._identifyMissing(a, s))
          continue;
        let o = s[a];
        a in this._utils.schemas ? n(a, o) : i[a] = o;
      }
  }
  _applyPostprocess(e) {
    let r = this._postprocess(e, this._utils);
    if (r !== rc) {
      if (r.delete)
        for (let i of r.delete)
          delete e[i];
      if (r.override) {
        let { knownKeys: i, unknownKeys: n } = this._partitionOptionKeys(r.override);
        for (let s of i) {
          let a = r.override[s];
          this._applyValidation(a, s, this._utils.schemas[s]), e[s] = a;
        }
        for (let s of n) {
          let a = r.override[s];
          this._applyUnknownHandler(s, a, e, (o, u) => {
            let c = this._utils.schemas[o];
            this._applyValidation(u, o, c), e[o] = u;
          });
        }
      }
    }
  }
}, Fp;
function YF(t, e, { logger: r = !1, isCLI: i = !1, passThrough: n = !1, FlagSchema: s, descriptor: a } = {}) {
  if (i) {
    if (!s)
      throw new Error("'FlagSchema' option is required.");
    if (!a)
      throw new Error("'descriptor' option is required.");
  } else
    a = fa;
  let o = n ? Array.isArray(n) ? (m, y) => n.includes(m) ? { [m]: y } : void 0 : (m, y) => ({ [m]: y }) : (m, y, O) => {
    let { _: b, ...v } = O.schemas;
    return Kb(m, y, { ...O, schemas: v });
  }, u = UF(e, { isCLI: i, FlagSchema: s }), c = new VF(u, { logger: r, unknown: o, descriptor: a }), h = r !== !1;
  h && Fp && (c._hasDeprecationWarned = Fp);
  let d = c.normalize(t);
  return h && (Fp = c._hasDeprecationWarned), d;
}
function UF(t, { isCLI: e, FlagSchema: r }) {
  let i = [];
  e && i.push(kF.create({ name: "_" }));
  for (let n of t)
    i.push(zF(n, { isCLI: e, optionInfos: t, FlagSchema: r })), n.alias && e && i.push(EF.create({ name: n.alias, sourceName: n.name }));
  return i;
}
function zF(t, { isCLI: e, optionInfos: r, FlagSchema: i }) {
  let { name: n } = t, s = { name: n }, a, o = {};
  switch (t.type) {
    case "int":
      a = jF, e && (s.preprocess = Number);
      break;
    case "string":
      a = T0;
      break;
    case "choice":
      a = LF, s.choices = t.choices.map((u) => u != null && u.redirect ? { ...u, redirect: { to: { key: t.name, value: u.redirect } } } : u);
      break;
    case "boolean":
      a = PF;
      break;
    case "flag":
      a = i, s.flags = r.flatMap((u) => [u.alias, u.description && u.name, u.oppositeDescription && `no-${u.name}`].filter(Boolean));
      break;
    case "path":
      a = T0;
      break;
    default:
      throw new Error(`Unexpected type ${t.type}`);
  }
  if (t.exception ? s.validate = (u, c, h) => t.exception(u) || c.validate(u, h) : s.validate = (u, c, h) => u === void 0 || c.validate(u, h), t.redirect && (o.redirect = (u) => u ? { to: { key: t.redirect.option, value: t.redirect.value } } : void 0), t.deprecated && (o.deprecated = !0), e && !t.array) {
    let u = s.preprocess || ((c) => c);
    s.preprocess = (c, h, d) => h.preprocess(u(Array.isArray(c) ? Dt(!1, c, -1) : c), d);
  }
  return t.array ? TF.create({ ...e ? { preprocess: (u) => Array.isArray(u) ? u : [u] } : {}, ...o, valueSchema: a.create(s) }) : a.create({ ...s, ...o });
}
var GF = YF, HF = (t, e, r) => {
  if (!(t && e == null)) {
    if (e.findLast)
      return e.findLast(r);
    for (let i = e.length - 1; i >= 0; i--) {
      let n = e[i];
      if (r(n, i, e))
        return n;
    }
  }
}, tD = HF;
function rD(t, e) {
  if (!e)
    throw new Error("parserName is required.");
  let r = tD(!1, t, (n) => n.parsers && Object.prototype.hasOwnProperty.call(n.parsers, e));
  if (r)
    return r;
  let i = `Couldn't resolve parser "${e}".`;
  throw i += " Plugins must be explicitly added to the standalone bundle.", new Ub(i);
}
function JF(t, e) {
  if (!e)
    throw new Error("astFormat is required.");
  let r = tD(!1, t, (n) => n.printers && Object.prototype.hasOwnProperty.call(n.printers, e));
  if (r)
    return r;
  let i = `Couldn't find plugin for AST format "${e}".`;
  throw i += " Plugins must be explicitly added to the standalone bundle.", new Ub(i);
}
function iD({ plugins: t, parser: e }) {
  let r = rD(t, e);
  return nD(r, e);
}
function nD(t, e) {
  let r = t.parsers[e];
  return typeof r == "function" ? r() : r;
}
function KF(t, e) {
  let r = t.printers[e];
  return typeof r == "function" ? r() : r;
}
var P0 = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
async function e$(t, e = {}) {
  var r;
  let i = { ...t };
  if (!i.parser)
    if (i.filepath) {
      if (i.parser = bF(i, { physicalFile: i.filepath }), !i.parser)
        throw new g0(`No parser could be inferred for file "${i.filepath}".`);
    } else
      throw new g0("No parser and no file path given, couldn't infer a parser.");
  let n = zb({ plugins: t.plugins, showDeprecated: !0 }).options, s = { ...P0, ...Object.fromEntries(n.filter((m) => m.default !== void 0).map((m) => [m.name, m.default])) }, a = rD(i.plugins, i.parser), o = await nD(a, i.parser);
  i.astFormat = o.astFormat, i.locEnd = o.locEnd, i.locStart = o.locStart;
  let u = (r = a.printers) != null && r[o.astFormat] ? a : JF(i.plugins, o.astFormat), c = await KF(u, o.astFormat);
  i.printer = c;
  let h = u.defaultOptions ? Object.fromEntries(Object.entries(u.defaultOptions).filter(([, m]) => m !== void 0)) : {}, d = { ...s, ...h };
  for (let [m, y] of Object.entries(d))
    (i[m] === null || i[m] === void 0) && (i[m] = y);
  return i.parser === "json" && (i.trailingComma = "none"), GF(i, n, { passThrough: Object.keys(P0), ...e });
}
var Wa = e$, t$ = kl(rP(), 1);
async function r$(t, e) {
  let r = await iD(e), i = r.preprocess ? r.preprocess(t, e) : t;
  e.originalText = i;
  let n;
  try {
    n = await r.parse(i, e, e);
  } catch (s) {
    i$(s, t);
  }
  return { text: i, ast: n };
}
function i$(t, e) {
  let { loc: r } = t;
  if (r) {
    let i = (0, t$.codeFrameColumns)(e, r, { highlightCode: !0 });
    throw t.message += `
` + i, t.codeFrame = i, t;
  }
  throw t;
}
var Pl = r$;
async function n$(t, e, r, i, n) {
  let { embeddedLanguageFormatting: s, printer: { embed: a, hasPrettierIgnore: o = () => !1, getVisitorKeys: u } } = r;
  if (!a || s !== "auto")
    return;
  if (a.length > 2)
    throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed");
  let c = bh(a.getVisitorKeys ?? u), h = [];
  y();
  let d = t.stack;
  for (let { print: O, node: b, pathStack: v } of h)
    try {
      t.stack = v;
      let S = await O(m, e, t, r);
      S && n.set(b, S);
    } catch (S) {
      if (globalThis.PRETTIER_DEBUG)
        throw S;
    }
  t.stack = d;
  function m(O, b) {
    return s$(O, b, r, i);
  }
  function y() {
    let { node: O } = t;
    if (O === null || typeof O != "object" || o(t))
      return;
    for (let v of c(O))
      Array.isArray(O[v]) ? t.each(y, v) : t.call(y, v);
    let b = a(t, r);
    if (b) {
      if (typeof b == "function") {
        h.push({ print: b, node: O, pathStack: [...t.stack] });
        return;
      }
      n.set(O, b);
    }
  }
}
async function s$(t, e, r, i) {
  let n = await Wa({ ...r, ...e, parentParser: r.parser, originalText: t }, { passThrough: !0 }), { ast: s } = await Pl(t, n), a = await i(s, n);
  return Qb(a);
}
function a$(t, e) {
  let { originalText: r, [Symbol.for("comments")]: i, locStart: n, locEnd: s, [Symbol.for("printedComments")]: a } = e, { node: o } = t, u = n(o), c = s(o);
  for (let h of i)
    n(h) >= u && s(h) <= c && a.add(h);
  return r.slice(u, c);
}
var o$ = a$;
async function Dh(t, e) {
  ({ ast: t } = await sD(t, e));
  let r = /* @__PURE__ */ new Map(), i = new YP(t), n = /* @__PURE__ */ new Map();
  await n$(i, a, e, Dh, n);
  let s = await F0(i, e, a, void 0, n);
  return dF(e), s;
  function a(u, c) {
    return u === void 0 || u === i ? o(c) : Array.isArray(u) ? i.call(() => o(c), ...u) : i.call(() => o(c), u);
  }
  function o(u) {
    let c = i.node;
    if (c == null)
      return "";
    let h = c && typeof c == "object" && u === void 0;
    if (h && r.has(c))
      return r.get(c);
    let d = F0(i, e, a, u, n);
    return h && r.set(c, d), d;
  }
}
function F0(t, e, r, i, n) {
  var s;
  let { node: a } = t, { printer: o } = e, u;
  return (s = o.hasPrettierIgnore) != null && s.call(o, t) ? u = o$(t, e) : n.has(a) ? u = n.get(a) : u = o.print(t, e, r, i), a === e.cursorNode && (u = Mb(u, (c) => [Md, c, Md])), o.printComment && (!o.willPrintOwnComments || !o.willPrintOwnComments(t, e)) && (u = pF(t, u, e)), u;
}
async function sD(t, e) {
  let r = t.comments ?? [];
  e[Symbol.for("comments")] = r, e[Symbol.for("tokens")] = t.tokens ?? [], e[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), sF(t, e);
  let { printer: { preprocess: i } } = e;
  return t = i ? await i(t, e) : t, { ast: t, comments: r };
}
function l$(t, e) {
  let { cursorOffset: r, locStart: i, locEnd: n } = e, s = bh(e.printer.getVisitorKeys), a = (u) => i(u) <= r && n(u) >= r, o = t;
  for (let u of GP(t, { getVisitorKeys: s, filter: a }))
    o = u;
  return o;
}
var u$ = l$;
function c$(t, e) {
  let { printer: { massageAstNode: r, getVisitorKeys: i } } = e;
  if (!r)
    return t;
  let n = bh(i), s = r.ignoredProperties ?? /* @__PURE__ */ new Set();
  return a(t);
  function a(o, u) {
    if (!(o !== null && typeof o == "object"))
      return o;
    if (Array.isArray(o))
      return o.map((m) => a(m, u)).filter(Boolean);
    let c = {}, h = new Set(n(o));
    for (let m in o)
      !Object.prototype.hasOwnProperty.call(o, m) || s.has(m) || (h.has(m) ? c[m] = a(o[m], o) : c[m] = o[m]);
    let d = r(o, c, u);
    if (d !== null)
      return d ?? c;
  }
}
var h$ = c$, p$ = ({ parser: t }) => t === "json" || t === "json5" || t === "jsonc" || t === "json-stringify";
function d$(t, e) {
  let r = [t.node, ...t.parentNodes], i = /* @__PURE__ */ new Set([e.node, ...e.parentNodes]);
  return r.find((n) => aD.has(n.type) && i.has(n));
}
function $0(t) {
  let e = t.length - 1;
  for (; ; ) {
    let r = t[e];
    if ((r == null ? void 0 : r.type) === "Program" || (r == null ? void 0 : r.type) === "File")
      e--;
    else
      break;
  }
  return t.slice(0, e + 1);
}
function f$(t, e, { locStart: r, locEnd: i }) {
  let n = t.node, s = e.node;
  if (n === s)
    return { startNode: n, endNode: s };
  let a = r(t.node);
  for (let u of $0(e.parentNodes))
    if (r(u) >= a)
      s = u;
    else
      break;
  let o = i(e.node);
  for (let u of $0(t.parentNodes)) {
    if (i(u) <= o)
      n = u;
    else
      break;
    if (n === s)
      break;
  }
  return { startNode: n, endNode: s };
}
function qd(t, e, r, i, n = [], s) {
  let { locStart: a, locEnd: o } = r, u = a(t), c = o(t);
  if (!(e > c || e < u || s === "rangeEnd" && e === u || s === "rangeStart" && e === c)) {
    for (let h of Fm(t, r)) {
      let d = qd(h, e, r, i, [t, ...n], s);
      if (d)
        return d;
    }
    if (!i || i(t, n[0]))
      return { node: t, parentNodes: n };
  }
}
function m$(t, e) {
  return e !== "DeclareExportDeclaration" && t !== "TypeParameterDeclaration" && (t === "Directive" || t === "TypeAlias" || t === "TSExportAssignment" || t.startsWith("Declare") || t.startsWith("TSDeclare") || t.endsWith("Statement") || t.endsWith("Declaration"));
}
var aD = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), g$ = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function B0(t, e, r) {
  if (!e)
    return !1;
  switch (t.parser) {
    case "flow":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "__babel_estree":
      return m$(e.type, r == null ? void 0 : r.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return aD.has(e.type);
    case "graphql":
      return g$.has(e.kind);
    case "vue":
      return e.tag !== "root";
  }
  return !1;
}
function y$(t, e, r) {
  let { rangeStart: i, rangeEnd: n, locStart: s, locEnd: a } = e;
  Zd.ok(n > i);
  let o = t.slice(i, n).search(/\S/), u = o === -1;
  if (!u)
    for (i += o; n > i && !/\S/.test(t[n - 1]); --n)
      ;
  let c = qd(r, i, e, (y, O) => B0(e, y, O), [], "rangeStart"), h = u ? c : qd(r, n, e, (y) => B0(e, y), [], "rangeEnd");
  if (!c || !h)
    return { rangeStart: 0, rangeEnd: 0 };
  let d, m;
  if (p$(e)) {
    let y = d$(c, h);
    d = y, m = y;
  } else
    ({ startNode: d, endNode: m } = f$(c, h, e));
  return { rangeStart: Math.min(s(d), s(m)), rangeEnd: Math.max(a(d), a(m)) };
}
var oD = "\uFEFF", I0 = Symbol("cursor");
async function lD(t, e, r = 0) {
  if (!t || t.trim().length === 0)
    return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: i, text: n } = await Pl(t, e);
  e.cursorOffset >= 0 && (e.cursorNode = u$(i, e));
  let s = await Dh(i, e);
  r > 0 && (s = _b([Os, s], r, e.tabWidth));
  let a = xh(s, e);
  if (r > 0) {
    let u = a.formatted.trim();
    a.cursorNodeStart !== void 0 && (a.cursorNodeStart -= a.formatted.indexOf(u)), a.formatted = u + wm(e.endOfLine);
  }
  let o = e[Symbol.for("comments")];
  if (e.cursorOffset >= 0) {
    let u, c, h, d, m;
    if (e.cursorNode && a.cursorNodeText ? (u = e.locStart(e.cursorNode), c = n.slice(u, e.locEnd(e.cursorNode)), h = e.cursorOffset - u, d = a.cursorNodeStart, m = a.cursorNodeText) : (u = 0, c = n, h = e.cursorOffset, d = 0, m = a.formatted), c === m)
      return { formatted: a.formatted, cursorOffset: d + h, comments: o };
    let y = c.split("");
    y.splice(h, 0, I0);
    let O = m.split(""), b = (0, nP.diffArrays)(y, O), v = d;
    for (let S of b)
      if (S.removed) {
        if (S.value.includes(I0))
          break;
      } else
        v += S.count;
    return { formatted: a.formatted, cursorOffset: v, comments: o };
  }
  return { formatted: a.formatted, cursorOffset: -1, comments: o };
}
async function O$(t, e) {
  let { ast: r, text: i } = await Pl(t, e), { rangeStart: n, rangeEnd: s } = y$(i, e, r), a = i.slice(n, s), o = Math.min(n, i.lastIndexOf(`
`, n) + 1), u = i.slice(o, n).match(/^\s*/)[0], c = Tm(u, e.tabWidth), h = await lD(a, { ...e, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: e.cursorOffset > n && e.cursorOffset <= s ? e.cursorOffset - n : -1, endOfLine: "lf" }, c), d = h.formatted.trimEnd(), { cursorOffset: m } = e;
  m > s ? m += d.length - a.length : h.cursorOffset >= 0 && (m = h.cursorOffset + n);
  let y = i.slice(0, n) + d + i.slice(s);
  if (e.endOfLine !== "lf") {
    let O = wm(e.endOfLine);
    m >= 0 && O === `\r
` && (m += kb(y.slice(0, m), `
`)), y = gh(!1, y, `
`, O);
  }
  return { formatted: y, cursorOffset: m, comments: h.comments };
}
function $p(t, e, r) {
  return typeof e != "number" || Number.isNaN(e) || e < 0 || e > t.length ? r : e;
}
function N0(t, e) {
  let { cursorOffset: r, rangeStart: i, rangeEnd: n } = e;
  return r = $p(t, r, -1), i = $p(t, i, 0), n = $p(t, n, t.length), { ...e, cursorOffset: r, rangeStart: i, rangeEnd: n };
}
function uD(t, e) {
  let { cursorOffset: r, rangeStart: i, rangeEnd: n, endOfLine: s } = N0(t, e), a = t.charAt(0) === oD;
  if (a && (t = t.slice(1), r--, i--, n--), s === "auto" && (s = sP(t)), t.includes("\r")) {
    let o = (u) => kb(t.slice(0, Math.max(u, 0)), `\r
`);
    r -= o(r), i -= o(i), n -= o(n), t = aP(t);
  }
  return { hasBOM: a, text: t, options: N0(t, { ...e, cursorOffset: r, rangeStart: i, rangeEnd: n, endOfLine: s }) };
}
async function _0(t, e) {
  let r = await iD(e);
  return !r.hasPragma || r.hasPragma(t);
}
async function cD(t, e) {
  let { hasBOM: r, text: i, options: n } = uD(t, await Wa(e));
  if (n.rangeStart >= n.rangeEnd && i !== "" || n.requirePragma && !await _0(i, n))
    return { formatted: t, cursorOffset: e.cursorOffset, comments: [] };
  let s;
  return n.rangeStart > 0 || n.rangeEnd < i.length ? s = await O$(i, n) : (!n.requirePragma && n.insertPragma && n.printer.insertPragma && !await _0(i, n) && (i = n.printer.insertPragma(i)), s = await lD(i, n)), r && (s.formatted = oD + s.formatted, s.cursorOffset >= 0 && s.cursorOffset++), s;
}
async function x$(t, e, r) {
  let { text: i, options: n } = uD(t, await Wa(e)), s = await Pl(i, n);
  return r && (r.preprocessForPrint && (s.ast = await sD(s.ast, n)), r.massage && (s.ast = h$(s.ast, n))), s;
}
async function b$(t, e) {
  e = await Wa(e);
  let r = await Dh(t, e);
  return xh(r, e);
}
async function D$(t, e) {
  let r = wP(t), { formatted: i } = await cD(r, { ...e, parser: "__js_expression" });
  return i;
}
async function v$(t, e) {
  e = await Wa(e);
  let { ast: r } = await Pl(t, e);
  return Dh(r, e);
}
async function S$(t, e) {
  return xh(t, await Wa(e));
}
var hD = {};
fh(hD, { builders: () => w$, printer: () => C$, utils: () => A$ });
var w$ = { join: Nb, line: Bb, softline: vP, hardline: Os, literalline: Ib, group: Pb, conditionalGroup: yP, fill: Fb, lineSuffix: Qd, lineSuffixBoundary: bP, cursor: Md, breakParent: yh, ifBreak: OP, trim: DP, indent: Sc, indentIfBreak: xP, align: Ta, addAlignmentToDoc: _b, markAsRoot: mP, dedentToRoot: fP, dedent: gP, hardlineWithoutBreakParent: Am, literallineWithoutBreakParent: $b, label: SP, concat: (t) => t }, C$ = { printDocToString: xh }, A$ = { willBreak: IP, traverseDoc: Cm, findInDoc: km, mapDoc: Oh, removeLines: QP, stripTrailingHardline: Qb, replaceEndOfLine: RP, canBreak: ZP }, E$ = "3.2.5", pD = {};
fh(pD, { addDanglingComment: () => os, addLeadingComment: () => pa, addTrailingComment: () => da, getAlignmentSize: () => Tm, getIndentSize: () => B$, getMaxContinuousCount: () => _$, getNextNonSpaceNonCommentCharacter: () => M$, getNextNonSpaceNonCommentCharacterIndex: () => V$, getStringWidth: () => Em, hasNewline: () => Nn, hasNewlineInRange: () => R$, hasSpaces: () => Z$, isNextLineEmpty: () => G$, isNextLineEmptyAfterIndex: () => _m, isPreviousLineEmpty: () => U$, makeString: () => q$, skip: () => Tl, skipEverythingButNewLine: () => Wb, skipInlineComment: () => Bm, skipNewline: () => xs, skipSpaces: () => Rn, skipToLineEnd: () => Zb, skipTrailingComment: () => Im, skipWhitespace: () => HP });
function k$(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var Bm = k$;
function T$(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? Wb(t, e) : e;
}
var Im = T$;
function P$(t, e) {
  let r = null, i = e;
  for (; i !== r; )
    r = i, i = Rn(t, i), i = Bm(t, i), i = Im(t, i), i = xs(t, i);
  return i;
}
var Nm = P$;
function F$(t, e) {
  let r = null, i = e;
  for (; i !== r; )
    r = i, i = Zb(t, i), i = Bm(t, i), i = Rn(t, i);
  return i = Im(t, i), i = xs(t, i), i !== !1 && Nn(t, i);
}
var _m = F$;
function $$(t, e) {
  let r = t.lastIndexOf(`
`);
  return r === -1 ? 0 : Tm(t.slice(r + 1).match(/^[\t ]*/)[0], e);
}
var B$ = $$;
function I$(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function N$(t, e) {
  let r = t.match(new RegExp(`(${I$(e)})+`, "g"));
  return r === null ? 0 : r.reduce((i, n) => Math.max(i, n.length / e.length), 0);
}
var _$ = N$;
function Q$(t, e) {
  let r = Nm(t, e);
  return r === !1 ? "" : t.charAt(r);
}
var M$ = Q$;
function L$(t, e, r) {
  for (let i = e; i < r; ++i)
    if (t.charAt(i) === `
`)
      return !0;
  return !1;
}
var R$ = L$;
function j$(t, e, r = {}) {
  return Rn(t, r.backwards ? e - 1 : e, r) !== e;
}
var Z$ = j$;
function W$(t, e, r) {
  let i = e === '"' ? "'" : '"', n = gh(!1, t, /\\(.)|(["'])/gs, (s, a, o) => a === i ? a : o === e ? "\\" + o : o || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(a) ? a : "\\" + a));
  return e + n + e;
}
var q$ = W$;
function X$(t, e, r) {
  return Nm(t, r(e));
}
function V$(t, e) {
  return arguments.length === 2 || typeof e == "number" ? Nm(t, e) : X$(...arguments);
}
function Y$(t, e, r) {
  return $m(t, r(e));
}
function U$(t, e) {
  return arguments.length === 2 || typeof e == "number" ? $m(t, e) : Y$(...arguments);
}
function z$(t, e, r) {
  return _m(t, r(e));
}
function G$(t, e) {
  return arguments.length === 2 || typeof e == "number" ? _m(t, e) : z$(...arguments);
}
function us(t, e = 1) {
  return async (...r) => {
    let i = r[e] ?? {}, n = i.plugins ?? [];
    return r[e] = { ...i, plugins: Array.isArray(n) ? n : Object.values(n) }, t(...r);
  };
}
var dD = us(cD);
async function fD(t, e) {
  let { formatted: r } = await dD(t, { ...e, cursorOffset: -1 });
  return r;
}
async function H$(t, e) {
  return await fD(t, e) === t;
}
var J$ = us(zb, 0), K$ = { parse: us(x$), formatAST: us(b$), formatDoc: us(D$), printToDoc: us(v$), printDocToString: us(S$) }, e3 = Eb, t3 = Object.defineProperty, mD = (t, e) => {
  for (var r in e)
    t3(t, r, { get: e[r], enumerable: !0 });
}, gD = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, xn = (t, e, r) => (gD(t, e, "read from private field"), r ? r.call(t) : e.get(t)), r3 = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, i3 = (t, e, r, i) => (gD(t, e, "write to private field"), i ? i.call(t, r) : e.set(t, r), r), yD = {};
mD(yD, { languages: () => Z8, options: () => q8, parsers: () => HD, printers: () => zI });
var n3 = (t, e, r, i) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, i) : r.global ? e.replace(r, i) : e.split(r).join(i);
}, wr = n3, Qm = "string", Mm = "array", Lm = "cursor", vh = "indent", Sh = "align", Rm = "trim", rl = "group", wh = "fill", Ch = "if-break", Ah = "indent-if-break", jm = "line-suffix", Zm = "line-suffix-boundary", Qs = "line", Wm = "label", Eh = "break-parent", OD = /* @__PURE__ */ new Set([Lm, vh, Sh, Rm, rl, wh, Ch, Ah, jm, Zm, Qs, Wm, Eh]);
function s3(t) {
  if (typeof t == "string")
    return Qm;
  if (Array.isArray(t))
    return Mm;
  if (!t)
    return;
  let { type: e } = t;
  if (OD.has(e))
    return e;
}
var qm = s3, a3 = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function o3(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (qm(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let i = a3([...OD].map((n) => `'${n}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${i}.`;
}
var l3 = class extends Error {
  constructor(r) {
    super(o3(r));
    Gr(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, xD = l3, u3 = () => {
}, c3 = u3;
function pn(t) {
  return { type: vh, contents: t };
}
function bD(t, e) {
  return { type: Sh, contents: e, n: t };
}
function qt(t, e = {}) {
  return c3(e.expandedStates), { type: rl, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function h3(t) {
  return bD(Number.NEGATIVE_INFINITY, t);
}
function p3(t) {
  return bD({ type: "root" }, t);
}
function DD(t) {
  return { type: wh, parts: t };
}
function wc(t, e = "", r = {}) {
  return { type: Ch, breakContents: t, flatContents: e, groupId: r.groupId };
}
function d3(t, e) {
  return { type: Ah, contents: t, groupId: e.groupId, negate: e.negate };
}
var Fl = { type: Eh }, f3 = { type: Qs, hard: !0 }, m3 = { type: Qs, hard: !0, literal: !0 }, Bt = { type: Qs }, Zt = { type: Qs, soft: !0 }, nt = [f3, Fl], g3 = [m3, Fl];
function qa(t, e) {
  let r = [];
  for (let i = 0; i < e.length; i++)
    i !== 0 && r.push(t), r.push(e[i]);
  return r;
}
var y3 = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, $l = y3;
function Xm(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return i(t);
  function i(s) {
    if (r.has(s))
      return r.get(s);
    let a = n(s);
    return r.set(s, a), a;
  }
  function n(s) {
    switch (qm(s)) {
      case Mm:
        return e(s.map(i));
      case wh:
        return e({ ...s, parts: s.parts.map(i) });
      case Ch:
        return e({ ...s, breakContents: i(s.breakContents), flatContents: i(s.flatContents) });
      case rl: {
        let { expandedStates: a, contents: o } = s;
        return a ? (a = a.map(i), o = a[0]) : o = i(o), e({ ...s, contents: o, expandedStates: a });
      }
      case Sh:
      case vh:
      case Ah:
      case Wm:
      case jm:
        return e({ ...s, contents: i(s.contents) });
      case Qm:
      case Lm:
      case Rm:
      case Zm:
      case Qs:
      case Eh:
        return e(s);
      default:
        throw new xD(s);
    }
  }
}
function O3(t) {
  switch (qm(t)) {
    case wh:
      if (t.parts.every((e) => e === ""))
        return "";
      break;
    case rl:
      if (!t.contents && !t.id && !t.break && !t.expandedStates)
        return "";
      if (t.contents.type === rl && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates)
        return t.contents;
      break;
    case Sh:
    case vh:
    case Ah:
    case jm:
      if (!t.contents)
        return "";
      break;
    case Ch:
      if (!t.flatContents && !t.breakContents)
        return "";
      break;
    case Mm: {
      let e = [];
      for (let r of t) {
        if (!r)
          continue;
        let [i, ...n] = Array.isArray(r) ? r : [r];
        typeof i == "string" && typeof $l(!1, e, -1) == "string" ? e[e.length - 1] += i : e.push(i), e.push(...n);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case Qm:
    case Lm:
    case Rm:
    case Zm:
    case Qs:
    case Wm:
    case Eh:
      break;
    default:
      throw new xD(t);
  }
  return t;
}
function x3(t) {
  return Xm(t, (e) => O3(e));
}
function ni(t, e = g3) {
  return Xm(t, (r) => typeof r == "string" ? qa(e, r.split(`
`)) : r);
}
var yu = "'", Q0 = '"';
function b3(t, e) {
  let r = e === !0 || e === yu ? yu : Q0, i = r === yu ? Q0 : yu, n = 0, s = 0;
  for (let a of t)
    a === r ? n++ : a === i && s++;
  return n > s ? i : r;
}
var D3 = b3;
function v3(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var Hr, S3 = class {
  constructor(e) {
    r3(this, Hr, void 0), i3(this, Hr, new Set(e));
  }
  getLeadingWhitespaceCount(e) {
    let r = xn(this, Hr), i = 0;
    for (let n = 0; n < e.length && r.has(e.charAt(n)); n++)
      i++;
    return i;
  }
  getTrailingWhitespaceCount(e) {
    let r = xn(this, Hr), i = 0;
    for (let n = e.length - 1; n >= 0 && r.has(e.charAt(n)); n--)
      i++;
    return i;
  }
  getLeadingWhitespace(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(0, r);
  }
  getTrailingWhitespace(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(e.length - r);
  }
  hasLeadingWhitespace(e) {
    return xn(this, Hr).has(e.charAt(0));
  }
  hasTrailingWhitespace(e) {
    return xn(this, Hr).has($l(!1, e, -1));
  }
  trimStart(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(r);
  }
  trimEnd(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(0, e.length - r);
  }
  trim(e) {
    return this.trimEnd(this.trimStart(e));
  }
  split(e, r = !1) {
    let i = `[${v3([...xn(this, Hr)].join(""))}]+`, n = new RegExp(r ? `(${i})` : i);
    return e.split(n);
  }
  hasWhitespaceCharacter(e) {
    let r = xn(this, Hr);
    return Array.prototype.some.call(e, (i) => r.has(i));
  }
  hasNonWhitespaceCharacter(e) {
    let r = xn(this, Hr);
    return Array.prototype.some.call(e, (i) => !r.has(i));
  }
  isWhitespaceOnly(e) {
    let r = xn(this, Hr);
    return Array.prototype.every.call(e, (i) => r.has(i));
  }
};
Hr = /* @__PURE__ */ new WeakMap();
var w3 = S3, C3 = ["	", `
`, "\f", "\r", " "], A3 = new w3(C3), Bi = A3, E3 = class extends Error {
  constructor(r, i, n = "type") {
    super(`Unexpected ${i} node ${n}: ${JSON.stringify(r[n])}.`);
    Gr(this, "name", "UnexpectedNodeError");
    this.node = r;
  }
}, k3 = E3;
function T3(t) {
  return (t == null ? void 0 : t.type) === "front-matter";
}
var kh = T3, P3 = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "keySpan", "tagDefinition", "tokens", "valueTokens", "switchValueSourceSpan", "expSourceSpan", "valueSourceSpan"]), F3 = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function vD(t, e) {
  var r;
  if (t.type === "text" || t.type === "comment" || kh(t) || t.type === "yaml" || t.type === "toml")
    return null;
  if (t.type === "attribute" && delete e.value, t.type === "docType" && delete e.value, t.type === "angularControlFlowBlock" && (r = e.parameters) != null && r.children)
    for (let i of e.parameters.children)
      F3.has(t.name) ? delete i.expression : i.expression = i.expression.trim();
  t.type === "angularIcuExpression" && (e.switchValue = t.switchValue.trim());
}
vD.ignoredProperties = P3;
var $3 = vD;
async function B3(t, e) {
  if (t.lang === "yaml") {
    let r = t.value.trim(), i = r ? await e(r, { parser: "yaml" }) : "";
    return p3([t.startDelimiter, nt, i, i ? nt : "", t.endDelimiter]);
  }
}
var I3 = B3;
function Th(t, e = !0) {
  return [pn([Zt, t]), e ? Zt : ""];
}
function Xa(t, e) {
  let r = t.type === "NGRoot" ? t.node.type === "NGMicrosyntax" && t.node.body.length === 1 && t.node.body[0].type === "NGMicrosyntaxExpression" ? t.node.body[0].expression : t.node : t.type === "JsExpressionRoot" ? t.node : t;
  return r && (r.type === "ObjectExpression" || r.type === "ArrayExpression" || (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && (r.type === "TemplateLiteral" || r.type === "StringLiteral"));
}
async function Ii(t, e, r, i) {
  r = { __isInHtmlAttribute: !0, __embeddedInHtml: !0, ...r };
  let n = !0;
  i && (r.__onHtmlBindingRoot = (a, o) => {
    n = i(a, o);
  });
  let s = await e(t, r, e);
  return n ? qt(s) : Th(s);
}
function N3(t, e, r, i) {
  let { node: n } = r, s = i.originalText.slice(n.sourceSpan.start.offset, n.sourceSpan.end.offset);
  return /^\s*$/.test(s) ? "" : Ii(s, t, { parser: "__ng_directive", __isInHtmlAttribute: !1, trailingComma: "none" }, Xa);
}
var _3 = N3, Q3 = (t) => String(t).split(/[/\\]/).pop();
function M0(t, e) {
  if (!e)
    return;
  let r = Q3(e).toLowerCase();
  return t.find(({ filenames: i }) => i == null ? void 0 : i.some((n) => n.toLowerCase() === r)) ?? t.find(({ extensions: i }) => i == null ? void 0 : i.some((n) => r.endsWith(n)));
}
function M3(t, e) {
  if (e)
    return t.find(({ name: r }) => r.toLowerCase() === e) ?? t.find(({ aliases: r }) => r == null ? void 0 : r.includes(e)) ?? t.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${e}`));
}
function L3(t, e) {
  let r = t.plugins.flatMap((n) => n.languages ?? []), i = M3(r, e.language) ?? M0(r, e.physicalFile) ?? M0(r, e.file) ?? (e.physicalFile, void 0);
  return i == null ? void 0 : i.parsers[0];
}
var Ph = L3, R3 = "inline", j3 = { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", style: "none", template: "inline", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", dialog: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", search: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", menu: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", input: "inline-block", button: "inline-block", fieldset: "block", marquee: "inline-block", source: "block", track: "block", details: "block", summary: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, Z3 = "normal", W3 = { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" };
function q3(t) {
  return t.type === "element" && !t.hasExplicitNamespace && !["html", "svg"].includes(t.namespace);
}
var il = q3, X3 = (t) => wr(!1, t, /^[\t\f\r ]*\n/g, ""), SD = (t) => X3(Bi.trimEnd(t)), V3 = (t) => {
  let e = t, r = Bi.getLeadingWhitespace(e);
  r && (e = e.slice(r.length));
  let i = Bi.getTrailingWhitespace(e);
  return i && (e = e.slice(0, -i.length)), { leadingWhitespace: r, trailingWhitespace: i, text: e };
};
function wD(t, e) {
  return !!(t.type === "ieConditionalComment" && t.lastChild && !t.lastChild.isSelfClosing && !t.lastChild.endSourceSpan || t.type === "ieConditionalComment" && !t.complete || Pa(t) && t.children.some((r) => r.type !== "text" && r.type !== "interpolation") || Ym(t, e) && !Hi(t) && t.type !== "interpolation");
}
function Fh(t) {
  return t.type === "attribute" || !t.parent || !t.prev ? !1 : Y3(t.prev);
}
function Y3(t) {
  return t.type === "comment" && t.value.trim() === "prettier-ignore";
}
function Br(t) {
  return t.type === "text" || t.type === "comment";
}
function Hi(t) {
  return t.type === "element" && (t.fullName === "script" || t.fullName === "style" || t.fullName === "svg:style" || t.fullName === "svg:script" || il(t) && (t.name === "script" || t.name === "style"));
}
function U3(t) {
  return t.children && !Hi(t);
}
function z3(t) {
  return Hi(t) || t.type === "interpolation" || CD(t);
}
function CD(t) {
  return $D(t).startsWith("pre");
}
function G3(t, e) {
  var r, i;
  let n = s();
  if (n && !t.prev && (i = (r = t.parent) == null ? void 0 : r.tagDefinition) != null && i.ignoreFirstLf)
    return t.type === "interpolation";
  return n;
  function s() {
    return kh(t) || t.type === "angularControlFlowBlock" ? !1 : (t.type === "text" || t.type === "interpolation") && t.prev && (t.prev.type === "text" || t.prev.type === "interpolation") ? !0 : !t.parent || t.parent.cssDisplay === "none" ? !1 : Pa(t.parent) ? !0 : !(!t.prev && (t.parent.type === "root" || Pa(t) && t.parent || Hi(t.parent) || $h(t.parent, e) || !sB(t.parent.cssDisplay)) || t.prev && !lB(t.prev.cssDisplay));
  }
}
function H3(t, e) {
  return kh(t) || t.type === "angularControlFlowBlock" ? !1 : (t.type === "text" || t.type === "interpolation") && t.next && (t.next.type === "text" || t.next.type === "interpolation") ? !0 : !t.parent || t.parent.cssDisplay === "none" ? !1 : Pa(t.parent) ? !0 : !(!t.next && (t.parent.type === "root" || Pa(t) && t.parent || Hi(t.parent) || $h(t.parent, e) || !aB(t.parent.cssDisplay)) || t.next && !oB(t.next.cssDisplay));
}
function J3(t) {
  return uB(t.cssDisplay) && !Hi(t);
}
function Ou(t) {
  return kh(t) || t.next && t.sourceSpan.end && t.sourceSpan.end.line + 1 < t.next.sourceSpan.start.line;
}
function K3(t) {
  return AD(t) || t.type === "element" && t.children.length > 0 && (["body", "script", "style"].includes(t.name) || t.children.some((e) => tB(e))) || t.firstChild && t.firstChild === t.lastChild && t.firstChild.type !== "text" && kD(t.firstChild) && (!t.lastChild.isTrailingSpaceSensitive || TD(t.lastChild));
}
function AD(t) {
  return t.type === "element" && t.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(t.name) || t.cssDisplay.startsWith("table") && t.cssDisplay !== "table-cell");
}
function Bp(t) {
  return PD(t) || t.prev && eB(t.prev) || ED(t);
}
function eB(t) {
  return PD(t) || t.type === "element" && t.fullName === "br" || ED(t);
}
function ED(t) {
  return kD(t) && TD(t);
}
function kD(t) {
  return t.hasLeadingSpaces && (t.prev ? t.prev.sourceSpan.end.line < t.sourceSpan.start.line : t.parent.type === "root" || t.parent.startSourceSpan.end.line < t.sourceSpan.start.line);
}
function TD(t) {
  return t.hasTrailingSpaces && (t.next ? t.next.sourceSpan.start.line > t.sourceSpan.end.line : t.parent.type === "root" || t.parent.endSourceSpan && t.parent.endSourceSpan.start.line > t.sourceSpan.end.line);
}
function PD(t) {
  switch (t.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return !0;
    case "element":
      return ["script", "select"].includes(t.name);
  }
  return !1;
}
function Vm(t) {
  return t.lastChild ? Vm(t.lastChild) : t;
}
function tB(t) {
  var e;
  return (e = t.children) == null ? void 0 : e.some((r) => r.type !== "text");
}
function FD(t) {
  if (t)
    switch (t) {
      case "module":
      case "text/javascript":
      case "text/babel":
      case "application/javascript":
        return "babel";
      case "application/x-typescript":
        return "typescript";
      case "text/markdown":
        return "markdown";
      case "text/html":
        return "html";
      case "text/x-handlebars-template":
        return "glimmer";
      default:
        if (t.endsWith("json") || t.endsWith("importmap") || t === "speculationrules")
          return "json";
    }
}
function rB(t, e) {
  let { name: r, attrMap: i } = t;
  if (r !== "script" || Object.prototype.hasOwnProperty.call(i, "src"))
    return;
  let { type: n, lang: s } = t.attrMap;
  return !s && !n ? "babel" : Ph(e, { language: s }) ?? FD(n);
}
function iB(t, e) {
  if (!Ym(t, e))
    return;
  let { attrMap: r } = t;
  if (Object.prototype.hasOwnProperty.call(r, "src"))
    return;
  let { type: i, lang: n } = r;
  return Ph(e, { language: n }) ?? FD(i);
}
function nB(t, e) {
  if (t.name !== "style")
    return;
  let { lang: r } = t.attrMap;
  return r ? Ph(e, { language: r }) : "css";
}
function L0(t, e) {
  return rB(t, e) ?? nB(t, e) ?? iB(t, e);
}
function Bl(t) {
  return t === "block" || t === "list-item" || t.startsWith("table");
}
function sB(t) {
  return !Bl(t) && t !== "inline-block";
}
function aB(t) {
  return !Bl(t) && t !== "inline-block";
}
function oB(t) {
  return !Bl(t);
}
function lB(t) {
  return !Bl(t);
}
function uB(t) {
  return !Bl(t) && t !== "inline-block";
}
function Pa(t) {
  return $D(t).startsWith("pre");
}
function cB(t, e) {
  let r = t;
  for (; r; ) {
    if (e(r))
      return !0;
    r = r.parent;
  }
  return !1;
}
function hB(t, e) {
  var r;
  if (Va(t, e))
    return "block";
  if (((r = t.prev) == null ? void 0 : r.type) === "comment") {
    let n = t.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
    if (n)
      return n[1];
  }
  let i = !1;
  if (t.type === "element" && t.namespace === "svg")
    if (cB(t, (n) => n.fullName === "svg:foreignObject"))
      i = !0;
    else
      return t.name === "svg" ? "inline-block" : "block";
  switch (e.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      return t.type === "element" && (!t.namespace || i || il(t)) && j3[t.name] || R3;
  }
}
function $D(t) {
  return t.type === "element" && (!t.namespace || il(t)) && W3[t.name] || Z3;
}
function pB(t) {
  let e = Number.POSITIVE_INFINITY;
  for (let r of t.split(`
`)) {
    if (r.length === 0)
      continue;
    let i = Bi.getLeadingWhitespaceCount(r);
    if (i === 0)
      return 0;
    r.length !== i && i < e && (e = i);
  }
  return e === Number.POSITIVE_INFINITY ? 0 : e;
}
function BD(t, e = pB(t)) {
  return e === 0 ? t : t.split(`
`).map((r) => r.slice(e)).join(`
`);
}
function ID(t) {
  return wr(!1, wr(!1, t, "&apos;", "'"), "&quot;", '"');
}
function Hn(t) {
  return ID(t.value);
}
var dB = /* @__PURE__ */ new Set(["template", "style", "script"]);
function $h(t, e) {
  return Va(t, e) && !dB.has(t.fullName);
}
function Va(t, e) {
  return e.parser === "vue" && t.type === "element" && t.parent.type === "root" && t.fullName.toLowerCase() !== "html";
}
function Ym(t, e) {
  return Va(t, e) && ($h(t, e) || t.attrMap.lang && t.attrMap.lang !== "html");
}
function fB(t) {
  let e = t.fullName;
  return e.charAt(0) === "#" || e === "slot-scope" || e === "v-slot" || e.startsWith("v-slot:");
}
function mB(t, e) {
  let r = t.parent;
  if (!Va(r, e))
    return !1;
  let i = r.fullName, n = t.fullName;
  return i === "script" && n === "setup" || i === "style" && n === "vars";
}
function ND(t, e = t.value) {
  return t.parent.isWhitespaceSensitive ? t.parent.isIndentationSensitive ? ni(e) : ni(BD(SD(e)), nt) : qa(Bt, Bi.split(e));
}
function _D(t, e) {
  return Va(t, e) && t.name === "script";
}
var QD = /{{(.+?)}}/s;
async function gB(t, e) {
  let r = [];
  for (let [i, n] of t.split(QD).entries())
    if (i % 2 === 0)
      r.push(ni(n));
    else
      try {
        r.push(qt(["{{", pn([Bt, await Ii(n, e, { parser: "__ng_interpolation", __isInHtmlInterpolation: !0, trailingComma: "none" })]), Bt, "}}"]));
      } catch {
        r.push("{{", ni(n), "}}");
      }
  return r;
}
function Um({ parser: t }) {
  return (e, r, i) => Ii(Hn(i.node), e, { parser: t, trailingComma: "none" }, Xa);
}
var yB = Um({ parser: "__ng_action" }), OB = Um({ parser: "__ng_binding" }), xB = Um({ parser: "__ng_directive" });
function bB(t, e) {
  if (e.parser !== "angular")
    return;
  let { node: r } = t, i = r.fullName;
  if (i.startsWith("(") && i.endsWith(")") || i.startsWith("on-"))
    return yB;
  if (i.startsWith("[") && i.endsWith("]") || /^bind(?:on)?-/.test(i) || /^ng-(?:if|show|hide|class|style)$/.test(i))
    return OB;
  if (i.startsWith("*"))
    return xB;
  let n = Hn(r);
  if (/^i18n(?:-.+)?$/.test(i))
    return () => Th(DD(ND(r, n.trim())), !n.includes("@@"));
  if (QD.test(n))
    return (s) => gB(n, s);
}
var DB = bB;
function vB(t, e) {
  let { node: r } = t, i = Hn(r);
  if (r.fullName === "class" && !e.parentParser && !i.includes("{{"))
    return () => i.trim().split(/\s+/).join(" ");
}
var SB = vB;
function R0(t) {
  return t === "	" || t === `
` || t === "\f" || t === "\r" || t === " ";
}
var wB = /^[ \t\n\r\u000c]+/, CB = /^[, \t\n\r\u000c]+/, AB = /^[^ \t\n\r\u000c]+/, EB = /[,]+$/, j0 = /^\d+$/, kB = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
function TB(t) {
  let e = t.length, r, i, n, s, a, o = 0, u;
  function c(y) {
    let O, b = y.exec(t.substring(o));
    if (b)
      return [O] = b, o += O.length, O;
  }
  let h = [];
  for (; ; ) {
    if (c(CB), o >= e) {
      if (h.length === 0)
        throw new Error("Must contain one or more image candidate strings.");
      return h;
    }
    u = o, r = c(AB), i = [], r.slice(-1) === "," ? (r = r.replace(EB, ""), m()) : d();
  }
  function d() {
    for (c(wB), n = "", s = "in descriptor"; ; ) {
      if (a = t.charAt(o), s === "in descriptor")
        if (R0(a))
          n && (i.push(n), n = "", s = "after descriptor");
        else if (a === ",") {
          o += 1, n && i.push(n), m();
          return;
        } else if (a === "(")
          n += a, s = "in parens";
        else if (a === "") {
          n && i.push(n), m();
          return;
        } else
          n += a;
      else if (s === "in parens")
        if (a === ")")
          n += a, s = "in descriptor";
        else if (a === "") {
          i.push(n), m();
          return;
        } else
          n += a;
      else if (s === "after descriptor" && !R0(a))
        if (a === "") {
          m();
          return;
        } else
          s = "in descriptor", o -= 1;
      o += 1;
    }
  }
  function m() {
    let y = !1, O, b, v, S, x = {}, w, k, C, E, P;
    for (S = 0; S < i.length; S++)
      w = i[S], k = w[w.length - 1], C = w.substring(0, w.length - 1), E = parseInt(C, 10), P = parseFloat(C), j0.test(C) && k === "w" ? ((O || b) && (y = !0), E === 0 ? y = !0 : O = E) : kB.test(C) && k === "x" ? ((O || b || v) && (y = !0), P < 0 ? y = !0 : b = P) : j0.test(C) && k === "h" ? ((v || b) && (y = !0), E === 0 ? y = !0 : v = E) : y = !0;
    if (!y)
      x.source = { value: r, startOffset: u }, O && (x.width = { value: O }), b && (x.density = { value: b }), v && (x.height = { value: v }), h.push(x);
    else
      throw new Error(`Invalid srcset descriptor found in "${t}" at "${w}".`);
  }
}
var PB = TB;
function FB(t) {
  if (t.node.fullName === "srcset" && (t.parent.fullName === "img" || t.parent.fullName === "source"))
    return () => BB(Hn(t.node));
}
var MD = { width: "w", height: "h", density: "x" }, $B = Object.keys(MD);
function BB(t) {
  let e = PB(t), r = $B.filter((h) => e.some((d) => Object.prototype.hasOwnProperty.call(d, h)));
  if (r.length > 1)
    throw new Error("Mixed descriptor in srcset is not supported");
  let [i] = r, n = MD[i], s = e.map((h) => h.source.value), a = Math.max(...s.map((h) => h.length)), o = e.map((h) => h[i] ? String(h[i].value) : ""), u = o.map((h) => {
    let d = h.indexOf(".");
    return d === -1 ? h.length : d;
  }), c = Math.max(...u);
  return Th(qa([",", Bt], s.map((h, d) => {
    let m = [h], y = o[d];
    if (y) {
      let O = a - h.length + 1, b = c - u[d], v = " ".repeat(O + b);
      m.push(wc(v, " "), y + n);
    }
    return m;
  })));
}
var IB = FB;
function NB(t, e) {
  let { node: r } = t, i = Hn(t.node).trim();
  if (r.fullName === "style" && !e.parentParser && !i.includes("{{"))
    return async (n) => Th(await n(i, { parser: "css", __isHTMLStyleAttribute: !0 }));
}
var Ip = /* @__PURE__ */ new WeakMap();
function _B(t, e) {
  let { root: r } = t;
  return Ip.has(r) || Ip.set(r, r.children.some((i) => _D(i, e) && ["ts", "typescript"].includes(i.attrMap.lang))), Ip.get(r);
}
var zm = _B;
function QB(t, e, r) {
  let { node: i } = r, n = Hn(i);
  return Ii(`type T<${n}> = any`, t, { parser: "babel-ts", __isEmbeddedTypescriptGenericParameters: !0 }, Xa);
}
function MB(t, e, { parseWithTs: r }) {
  return Ii(`function _(${t}) {}`, e, { parser: r ? "babel-ts" : "babel", __isVueBindings: !0 });
}
function LB(t) {
  let e = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, r = /^[$_a-z][\w$]*(?:\.[$_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$_a-z][\w$]*])*$/i, i = t.trim();
  return e.test(i) || r.test(i);
}
async function RB(t, e, r, i) {
  let n = Hn(r.node), { left: s, operator: a, right: o } = jB(n), u = zm(r, i);
  return [qt(await Ii(`function _(${s}) {}`, t, { parser: u ? "babel-ts" : "babel", __isVueForBindingLeft: !0 })), " ", a, " ", await Ii(o, t, { parser: u ? "__ts_expression" : "__js_expression" })];
}
function jB(t) {
  let e = /(.*?)\s+(in|of)\s+(.*)/s, r = /,([^,\]}]*)(?:,([^,\]}]*))?$/, i = /^\(|\)$/g, n = t.match(e);
  if (!n)
    return;
  let s = {};
  if (s.for = n[3].trim(), !s.for)
    return;
  let a = wr(!1, n[1].trim(), i, ""), o = a.match(r);
  o ? (s.alias = a.replace(r, ""), s.iterator1 = o[1].trim(), o[2] && (s.iterator2 = o[2].trim())) : s.alias = a;
  let u = [s.alias, s.iterator1, s.iterator2];
  if (!u.some((c, h) => !c && (h === 0 || u.slice(h + 1).some(Boolean))))
    return { left: u.filter(Boolean).join(","), operator: n[2], right: s.for };
}
function ZB(t, e) {
  if (e.parser !== "vue")
    return;
  let { node: r } = t, i = r.fullName;
  if (i === "v-for")
    return RB;
  if (i === "generic" && _D(r.parent, e))
    return QB;
  let n = Hn(r), s = zm(t, e);
  if (fB(r) || mB(r, e))
    return (a) => MB(n, a, { parseWithTs: s });
  if (i.startsWith("@") || i.startsWith("v-on:"))
    return (a) => WB(n, a, { parseWithTs: s });
  if (i.startsWith(":") || i.startsWith("v-bind:"))
    return (a) => qB(n, a, { parseWithTs: s });
  if (i.startsWith("v-"))
    return (a) => LD(n, a, { parseWithTs: s });
}
function WB(t, e, { parseWithTs: r }) {
  return LB(t) ? LD(t, e, { parseWithTs: r }) : Ii(t, e, { parser: r ? "__vue_ts_event_binding" : "__vue_event_binding" }, Xa);
}
function qB(t, e, { parseWithTs: r }) {
  return Ii(t, e, { parser: r ? "__vue_ts_expression" : "__vue_expression" }, Xa);
}
function LD(t, e, { parseWithTs: r }) {
  return Ii(t, e, { parser: r ? "__ts_expression" : "__js_expression" }, Xa);
}
var XB = ZB;
function VB(t, e) {
  let { node: r } = t;
  if (r.value) {
    if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(e.originalText.slice(r.valueSpan.start.offset, r.valueSpan.end.offset)) || e.parser === "lwc" && r.value.startsWith("{") && r.value.endsWith("}"))
      return [r.rawName, "=", r.value];
    for (let i of [IB, NB, SB, XB, DB]) {
      let n = i(t, e);
      if (n)
        return YB(n);
    }
  }
}
function YB(t) {
  return async (e, r, i, n) => {
    let s = await t(e, r, i, n);
    if (s)
      return s = Xm(s, (a) => typeof a == "string" ? wr(!1, a, '"', "&quot;") : a), [i.node.rawName, '="', qt(s), '"'];
  };
}
var UB = VB, RD = new Proxy(() => {
}, { get: () => RD }), jD = RD;
function zB(t) {
  return Array.isArray(t) && t.length > 0;
}
var Gm = zB;
function Bh(t) {
  return t.sourceSpan.start.offset;
}
function Ih(t) {
  return t.sourceSpan.end.offset;
}
function Xd(t, e) {
  return [t.isSelfClosing ? "" : GB(t, e), Zo(t, e)];
}
function GB(t, e) {
  return t.lastChild && nl(t.lastChild) ? "" : [HB(t, e), Hm(t, e)];
}
function Zo(t, e) {
  return (t.next ? Ds(t.next) : Nl(t.parent)) ? "" : [Il(t, e), bs(t, e)];
}
function HB(t, e) {
  return Nl(t) ? Il(t.lastChild, e) : "";
}
function bs(t, e) {
  return nl(t) ? Hm(t.parent, e) : Nh(t) ? Jm(t.next) : "";
}
function Hm(t, e) {
  if (jD(!t.isSelfClosing), ZD(t, e))
    return "";
  switch (t.type) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (t.hasHtmComponentClosingTag)
        return "<//";
    default:
      return `</${t.rawName}`;
  }
}
function Il(t, e) {
  if (ZD(t, e))
    return "";
  switch (t.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "angularIcuExpression":
      return "}";
    case "element":
      if (t.isSelfClosing)
        return "/>";
    default:
      return ">";
  }
}
function ZD(t, e) {
  return !t.isSelfClosing && !t.endSourceSpan && (Fh(t) || wD(t.parent, e));
}
function Ds(t) {
  return t.prev && t.prev.type !== "docType" && t.type !== "angularControlFlowBlock" && !Br(t.prev) && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
}
function Nl(t) {
  var e;
  return ((e = t.lastChild) == null ? void 0 : e.isTrailingSpaceSensitive) && !t.lastChild.hasTrailingSpaces && !Br(Vm(t.lastChild)) && !Pa(t);
}
function nl(t) {
  return !t.next && !t.hasTrailingSpaces && t.isTrailingSpaceSensitive && Br(Vm(t));
}
function Nh(t) {
  return t.next && !Br(t.next) && Br(t) && t.isTrailingSpaceSensitive && !t.hasTrailingSpaces;
}
function JB(t) {
  let e = t.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
  return e ? e[1] ? e[1].split(/\s+/) : !0 : !1;
}
function _h(t) {
  return !t.prev && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
}
function KB(t, e, r) {
  var i;
  let { node: n } = t;
  if (!Gm(n.attrs))
    return n.isSelfClosing ? " " : "";
  let s = ((i = n.prev) == null ? void 0 : i.type) === "comment" && JB(n.prev.value), a = typeof s == "boolean" ? () => s : Array.isArray(s) ? (d) => s.includes(d.rawName) : () => !1, o = t.map(({ node: d }) => a(d) ? ni(e.originalText.slice(Bh(d), Ih(d))) : r(), "attrs"), u = n.type === "element" && n.fullName === "script" && n.attrs.length === 1 && n.attrs[0].fullName === "src" && n.children.length === 0, c = e.singleAttributePerLine && n.attrs.length > 1 && !Va(n, e) ? nt : Bt, h = [pn([u ? " " : Bt, qa(c, o)])];
  return n.firstChild && _h(n.firstChild) || n.isSelfClosing && Nl(n.parent) || u ? h.push(n.isSelfClosing ? " " : "") : h.push(e.bracketSameLine ? n.isSelfClosing ? " " : "" : n.isSelfClosing ? Bt : Zt), h;
}
function e8(t) {
  return t.firstChild && _h(t.firstChild) ? "" : Km(t);
}
function Vd(t, e, r) {
  let { node: i } = t;
  return [Wo(i, e), KB(t, e, r), i.isSelfClosing ? "" : e8(i)];
}
function Wo(t, e) {
  return t.prev && Nh(t.prev) ? "" : [vs(t, e), Jm(t)];
}
function vs(t, e) {
  return _h(t) ? Km(t.parent) : Ds(t) ? Il(t.prev, e) : "";
}
function Jm(t) {
  switch (t.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${t.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType":
      return t.value === "html" ? "<!doctype" : "<!DOCTYPE";
    case "angularIcuExpression":
      return "{";
    case "element":
      if (t.condition)
        return `<!--[if ${t.condition}]><!--><${t.rawName}`;
    default:
      return `<${t.rawName}`;
  }
}
function Km(t) {
  switch (jD(!t.isSelfClosing), t.type) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (t.condition)
        return "><!--<![endif]-->";
    default:
      return ">";
  }
}
function t8(t, e) {
  if (!t.endSourceSpan)
    return "";
  let r = t.startSourceSpan.end.offset;
  t.firstChild && _h(t.firstChild) && (r -= Km(t).length);
  let i = t.endSourceSpan.start.offset;
  return t.lastChild && nl(t.lastChild) ? i += Hm(t, e).length : Nl(t) && (i -= Il(t.lastChild, e).length), e.originalText.slice(r, i);
}
var WD = t8, r8 = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function i8(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "element":
      if (Hi(r) || r.type === "interpolation")
        return;
      if (!r.isSelfClosing && Ym(r, e)) {
        let i = L0(r, e);
        return i ? async (n, s) => {
          let a = WD(r, e), o = /^\s*$/.test(a), u = "";
          return o || (u = await n(SD(a), { parser: i, __embeddedInHtml: !0 }), o = u === ""), [vs(r, e), qt(Vd(t, e, s)), o ? "" : nt, u, o ? "" : nt, Xd(r, e), bs(r, e)];
        } : void 0;
      }
      break;
    case "text":
      if (Hi(r.parent)) {
        let i = L0(r.parent, e);
        if (i)
          return async (n) => {
            let s = i === "markdown" ? BD(r.value.replace(/^[^\S\n]*\n/, "")) : r.value, a = { parser: i, __embeddedInHtml: !0 };
            if (e.parser === "html" && i === "babel") {
              let o = "script", { attrMap: u } = r.parent;
              u && (u.type === "module" || u.type === "text/babel" && u["data-type"] === "module") && (o = "module"), a.__babelSourceType = o;
            }
            return [Fl, vs(r, e), await n(s, a), bs(r, e)];
          };
      } else if (r.parent.type === "interpolation")
        return async (i) => {
          let n = { __isInHtmlInterpolation: !0, __embeddedInHtml: !0 };
          return e.parser === "angular" ? (n.parser = "__ng_interpolation", n.trailingComma = "none") : e.parser === "vue" ? n.parser = zm(t, e) ? "__vue_ts_expression" : "__vue_expression" : n.parser = "__js_expression", [pn([Bt, await i(r.value, n)]), r.parent.next && Ds(r.parent.next) ? " " : Bt];
        };
      break;
    case "attribute":
      return UB(t, e);
    case "front-matter":
      return (i) => I3(r, i);
    case "angularControlFlowBlockParameters":
      return r8.has(t.parent.name) ? _3 : void 0;
  }
}
var n8 = i8, fo = null;
function qo(t) {
  if (fo !== null && typeof fo.property) {
    let e = fo;
    return fo = qo.prototype = null, e;
  }
  return fo = qo.prototype = t ?? /* @__PURE__ */ Object.create(null), new qo();
}
var s8 = 10;
for (let t = 0; t <= s8; t++)
  qo();
function a8(t) {
  return qo(t);
}
function o8(t, e = "type") {
  a8(t);
  function r(i) {
    let n = i[e], s = t[n];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: i });
    return s;
  }
  return r;
}
var l8 = o8, u8 = { "front-matter": [], root: ["children"], element: ["attrs", "children"], ieConditionalComment: ["children"], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ["children"], text: ["children"], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ["children", "parameters"], angularControlFlowBlockParameters: ["children"], angularControlFlowBlockParameter: [], angularIcuExpression: ["cases"], angularIcuCase: ["expression"] }, c8 = u8, h8 = l8(c8), p8 = h8;
function d8(t) {
  return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(t);
}
function f8(t) {
  return `<!-- @format -->

` + t;
}
var m8 = /* @__PURE__ */ new Map([["if", /* @__PURE__ */ new Set(["else if", "else"])], ["else if", /* @__PURE__ */ new Set(["else if", "else"])], ["for", /* @__PURE__ */ new Set(["empty"])], ["defer", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["placeholder", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["error", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["loading", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])]]);
function qD(t) {
  let e = Ih(t);
  return t.type === "element" && !t.endSourceSpan && Gm(t.children) ? Math.max(e, qD($l(!1, t.children, -1))) : e;
}
function mo(t, e, r) {
  let i = t.node;
  if (Fh(i)) {
    let n = qD(i);
    return [vs(i, e), ni(Bi.trimEnd(e.originalText.slice(Bh(i) + (i.prev && Nh(i.prev) ? Jm(i).length : 0), n - (i.next && Ds(i.next) ? Il(i, e).length : 0)))), bs(i, e)];
  }
  return r();
}
function xu(t, e) {
  return Br(t) && Br(e) ? t.isTrailingSpaceSensitive ? t.hasTrailingSpaces ? Bp(e) ? nt : Bt : "" : Bp(e) ? nt : Zt : Nh(t) && (Fh(e) || e.firstChild || e.isSelfClosing || e.type === "element" && e.attrs.length > 0) || t.type === "element" && t.isSelfClosing && Ds(e) ? "" : !e.isLeadingSpaceSensitive || Bp(e) || Ds(e) && t.lastChild && nl(t.lastChild) && t.lastChild.lastChild && nl(t.lastChild.lastChild) ? nt : e.hasLeadingSpaces ? Bt : Zt;
}
function eg(t, e, r) {
  let { node: i } = t;
  if (AD(i))
    return [Fl, ...t.map((s) => {
      let a = s.node, o = a.prev ? xu(a.prev, a) : "";
      return [o ? [o, Ou(a.prev) ? nt : ""] : "", mo(s, e, r)];
    }, "children")];
  let n = i.children.map(() => Symbol(""));
  return t.map((s, a) => {
    let o = s.node;
    if (Br(o)) {
      if (o.prev && Br(o.prev)) {
        let O = xu(o.prev, o);
        if (O)
          return Ou(o.prev) ? [nt, nt, mo(s, e, r)] : [O, mo(s, e, r)];
      }
      return mo(s, e, r);
    }
    let u = [], c = [], h = [], d = [], m = o.prev ? xu(o.prev, o) : "", y = o.next ? xu(o, o.next) : "";
    return m && (Ou(o.prev) ? u.push(nt, nt) : m === nt ? u.push(nt) : Br(o.prev) ? c.push(m) : c.push(wc("", Zt, { groupId: n[a - 1] }))), y && (Ou(o) ? Br(o.next) && d.push(nt, nt) : y === nt ? Br(o.next) && d.push(nt) : h.push(y)), [...u, qt([...c, qt([mo(s, e, r), ...h], { id: n[a] })]), ...d];
  }, "children");
}
function g8(t, e, r) {
  let { node: i } = t, n = [];
  y8(t) && n.push("} "), n.push("@", i.name), i.parameters && n.push(" (", qt(r("parameters")), ")"), n.push(" {");
  let s = XD(i);
  return i.children.length > 0 ? (i.firstChild.hasLeadingSpaces = !0, i.lastChild.hasTrailingSpaces = !0, n.push(pn([nt, eg(t, e, r)])), s && n.push(nt, "}")) : s && n.push("}"), qt(n, { shouldBreak: !0 });
}
function XD(t) {
  var e, r;
  return !(((e = t.next) == null ? void 0 : e.type) === "angularControlFlowBlock" && (r = m8.get(t.name)) != null && r.has(t.next.name));
}
function y8(t) {
  let { previous: e } = t;
  return (e == null ? void 0 : e.type) === "angularControlFlowBlock" && !Fh(e) && !XD(e);
}
function O8(t, e, r) {
  return [pn([Zt, qa([";", Bt], t.map(r, "children"))]), Zt];
}
function x8(t, e, r) {
  let { node: i } = t;
  return [Wo(i, e), qt([i.switchValue.trim(), ", ", i.clause, i.cases.length > 0 ? [",", pn([Bt, qa(Bt, t.map(r, "cases"))])] : "", Zt]), Zo(i, e)];
}
function b8(t, e, r) {
  let { node: i } = t;
  return [i.value, " {", qt([pn([Zt, t.map(({ node: n }) => n.type === "text" && !Bi.trim(n.value) ? "" : r(), "expression")]), Zt]), "}"];
}
function D8(t, e, r) {
  let { node: i } = t;
  if (wD(i, e))
    return [vs(i, e), qt(Vd(t, e, r)), ni(WD(i, e)), ...Xd(i, e), bs(i, e)];
  let n = i.children.length === 1 && (i.firstChild.type === "interpolation" || i.firstChild.type === "angularIcuExpression") && i.firstChild.isLeadingSpaceSensitive && !i.firstChild.hasLeadingSpaces && i.lastChild.isTrailingSpaceSensitive && !i.lastChild.hasTrailingSpaces, s = Symbol("element-attr-group-id"), a = (h) => qt([qt(Vd(t, e, r), { id: s }), h, Xd(i, e)]), o = (h) => n ? d3(h, { groupId: s }) : (Hi(i) || $h(i, e)) && i.parent.type === "root" && e.parser === "vue" && !e.vueIndentScriptAndStyle ? h : pn(h), u = () => n ? wc(Zt, "", { groupId: s }) : i.firstChild.hasLeadingSpaces && i.firstChild.isLeadingSpaceSensitive ? Bt : i.firstChild.type === "text" && i.isWhitespaceSensitive && i.isIndentationSensitive ? h3(Zt) : Zt, c = () => (i.next ? Ds(i.next) : Nl(i.parent)) ? i.lastChild.hasTrailingSpaces && i.lastChild.isTrailingSpaceSensitive ? " " : "" : n ? wc(Zt, "", { groupId: s }) : i.lastChild.hasTrailingSpaces && i.lastChild.isTrailingSpaceSensitive ? Bt : (i.lastChild.type === "comment" || i.lastChild.type === "text" && i.isWhitespaceSensitive && i.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${e.tabWidth * (t.ancestors.length - 1)}}$`).test(i.lastChild.value) ? "" : Zt;
  return i.children.length === 0 ? a(i.hasDanglingSpaces && i.isDanglingSpaceSensitive ? Bt : "") : a([K3(i) ? Fl : "", o([u(), eg(t, e, r)]), c()]);
}
function tg(t) {
  return t >= 9 && t <= 32 || t == 160;
}
function VD(t) {
  return 48 <= t && t <= 57;
}
function rg(t) {
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function v8(t) {
  return t >= 97 && t <= 102 || t >= 65 && t <= 70 || VD(t);
}
function YD(t) {
  return t === 10 || t === 13;
}
function Z0(t) {
  return 48 <= t && t <= 55;
}
function W0(t) {
  return t === 39 || t === 34 || t === 96;
}
var S8 = /-+([a-z0-9])/g;
function w8(t) {
  return t.replace(S8, (...e) => e[1].toUpperCase());
}
var Yd = class UD {
  constructor(e, r, i, n) {
    this.file = e, this.offset = r, this.line = i, this.col = n;
  }
  toString() {
    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
  }
  moveBy(e) {
    let r = this.file.content, i = r.length, n = this.offset, s = this.line, a = this.col;
    for (; n > 0 && e < 0; )
      if (n--, e++, r.charCodeAt(n) == 10) {
        s--;
        let o = r.substring(0, n - 1).lastIndexOf(`
`);
        a = o > 0 ? n - o : n;
      } else
        a--;
    for (; n < i && e > 0; ) {
      let o = r.charCodeAt(n);
      n++, e--, o == 10 ? (s++, a = 0) : a++;
    }
    return new UD(this.file, n, s, a);
  }
  getContext(e, r) {
    let i = this.file.content, n = this.offset;
    if (n != null) {
      n > i.length - 1 && (n = i.length - 1);
      let s = n, a = 0, o = 0;
      for (; a < e && n > 0 && (n--, a++, !(i[n] == `
` && ++o == r)); )
        ;
      for (a = 0, o = 0; a < e && s < i.length - 1 && (s++, a++, !(i[s] == `
` && ++o == r)); )
        ;
      return { before: i.substring(n, this.offset), after: i.substring(this.offset, s + 1) };
    }
    return null;
  }
}, zD = class {
  constructor(e, r) {
    this.content = e, this.url = r;
  }
}, Qe = class {
  constructor(t, e, r = t, i = null) {
    this.start = t, this.end = e, this.fullStart = r, this.details = i;
  }
  toString() {
    return this.start.file.content.substring(this.start.offset, this.end.offset);
  }
}, Cc;
(function(t) {
  t[t.WARNING = 0] = "WARNING", t[t.ERROR = 1] = "ERROR";
})(Cc || (Cc = {}));
var GD = class {
  constructor(e, r, i = Cc.ERROR) {
    this.span = e, this.msg = r, this.level = i;
  }
  contextualMessage() {
    let e = this.span.start.getContext(100, 3);
    return e ? `${this.msg} ("${e.before}[${Cc[this.level]} ->]${e.after}")` : this.msg;
  }
  toString() {
    let e = this.span.details ? `, ${this.span.details}` : "";
    return `${this.contextualMessage()}: ${this.span.start}${e}`;
  }
}, C8 = [E8, k8, P8, $8, B8, _8, I8, N8, Q8, F8];
function A8(t, e) {
  for (let r of C8)
    r(t, e);
  return t;
}
function E8(t) {
  t.walk((e) => {
    if (e.type === "element" && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && e.children[0].type === "text" && e.children[0].value[0] === `
`) {
      let r = e.children[0];
      r.value.length === 1 ? e.removeChild(r) : r.value = r.value.slice(1);
    }
  });
}
function k8(t) {
  let e = (r) => {
    var i, n;
    return r.type === "element" && ((i = r.prev) == null ? void 0 : i.type) === "ieConditionalStartComment" && r.prev.sourceSpan.end.offset === r.startSourceSpan.start.offset && ((n = r.firstChild) == null ? void 0 : n.type) === "ieConditionalEndComment" && r.firstChild.sourceSpan.start.offset === r.startSourceSpan.end.offset;
  };
  t.walk((r) => {
    if (r.children)
      for (let i = 0; i < r.children.length; i++) {
        let n = r.children[i];
        if (!e(n))
          continue;
        let s = n.prev, a = n.firstChild;
        r.removeChild(s), i--;
        let o = new Qe(s.sourceSpan.start, a.sourceSpan.end), u = new Qe(o.start, n.sourceSpan.end);
        n.condition = s.condition, n.sourceSpan = u, n.startSourceSpan = o, n.removeChild(a);
      }
  });
}
function T8(t, e, r) {
  t.walk((i) => {
    if (i.children)
      for (let n = 0; n < i.children.length; n++) {
        let s = i.children[n];
        if (s.type !== "text" && !e(s))
          continue;
        s.type !== "text" && (s.type = "text", s.value = r(s));
        let a = s.prev;
        !a || a.type !== "text" || (a.value += s.value, a.sourceSpan = new Qe(a.sourceSpan.start, s.sourceSpan.end), i.removeChild(s), n--);
      }
  });
}
function P8(t) {
  return T8(t, (e) => e.type === "cdata", (e) => `<![CDATA[${e.value}]]>`);
}
function F8(t) {
  let e = (r) => {
    var i, n;
    return r.type === "element" && r.attrs.length === 0 && r.children.length === 1 && r.firstChild.type === "text" && !Bi.hasWhitespaceCharacter(r.children[0].value) && !r.firstChild.hasLeadingSpaces && !r.firstChild.hasTrailingSpaces && r.isLeadingSpaceSensitive && !r.hasLeadingSpaces && r.isTrailingSpaceSensitive && !r.hasTrailingSpaces && ((i = r.prev) == null ? void 0 : i.type) === "text" && ((n = r.next) == null ? void 0 : n.type) === "text";
  };
  t.walk((r) => {
    if (r.children)
      for (let i = 0; i < r.children.length; i++) {
        let n = r.children[i];
        if (!e(n))
          continue;
        let s = n.prev, a = n.next;
        s.value += `<${n.rawName}>` + n.firstChild.value + `</${n.rawName}>` + a.value, s.sourceSpan = new Qe(s.sourceSpan.start, a.sourceSpan.end), s.isTrailingSpaceSensitive = a.isTrailingSpaceSensitive, s.hasTrailingSpaces = a.hasTrailingSpaces, r.removeChild(n), i--, r.removeChild(a);
      }
  });
}
function $8(t, e) {
  if (e.parser === "html")
    return;
  let r = /{{(.+?)}}/s;
  t.walk((i) => {
    if (U3(i))
      for (let n of i.children) {
        if (n.type !== "text")
          continue;
        let s = n.sourceSpan.start, a = null, o = n.value.split(r);
        for (let u = 0; u < o.length; u++, s = a) {
          let c = o[u];
          if (u % 2 === 0) {
            a = s.moveBy(c.length), c.length > 0 && i.insertChildBefore(n, { type: "text", value: c, sourceSpan: new Qe(s, a) });
            continue;
          }
          a = s.moveBy(c.length + 4), i.insertChildBefore(n, { type: "interpolation", sourceSpan: new Qe(s, a), children: c.length === 0 ? [] : [{ type: "text", value: c, sourceSpan: new Qe(s.moveBy(2), a.moveBy(-2)) }] });
        }
        i.removeChild(n);
      }
  });
}
function B8(t) {
  t.walk((e) => {
    if (!e.children)
      return;
    if (e.children.length === 0 || e.children.length === 1 && e.children[0].type === "text" && Bi.trim(e.children[0].value).length === 0) {
      e.hasDanglingSpaces = e.children.length > 0, e.children = [];
      return;
    }
    let r = z3(e), i = CD(e);
    if (!r)
      for (let n = 0; n < e.children.length; n++) {
        let s = e.children[n];
        if (s.type !== "text")
          continue;
        let { leadingWhitespace: a, text: o, trailingWhitespace: u } = V3(s.value), c = s.prev, h = s.next;
        o ? (s.value = o, s.sourceSpan = new Qe(s.sourceSpan.start.moveBy(a.length), s.sourceSpan.end.moveBy(-u.length)), a && (c && (c.hasTrailingSpaces = !0), s.hasLeadingSpaces = !0), u && (s.hasTrailingSpaces = !0, h && (h.hasLeadingSpaces = !0))) : (e.removeChild(s), n--, (a || u) && (c && (c.hasTrailingSpaces = !0), h && (h.hasLeadingSpaces = !0)));
      }
    e.isWhitespaceSensitive = r, e.isIndentationSensitive = i;
  });
}
function I8(t) {
  t.walk((e) => {
    e.isSelfClosing = !e.children || e.type === "element" && (e.tagDefinition.isVoid || e.endSourceSpan && e.startSourceSpan.start === e.endSourceSpan.start && e.startSourceSpan.end === e.endSourceSpan.end);
  });
}
function N8(t, e) {
  t.walk((r) => {
    r.type === "element" && (r.hasHtmComponentClosingTag = r.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(e.originalText.slice(r.endSourceSpan.start.offset, r.endSourceSpan.end.offset)));
  });
}
function _8(t, e) {
  t.walk((r) => {
    r.cssDisplay = hB(r, e);
  });
}
function Q8(t, e) {
  t.walk((r) => {
    let { children: i } = r;
    if (i) {
      if (i.length === 0) {
        r.isDanglingSpaceSensitive = J3(r);
        return;
      }
      for (let n of i)
        n.isLeadingSpaceSensitive = G3(n, e), n.isTrailingSpaceSensitive = H3(n, e);
      for (let n = 0; n < i.length; n++) {
        let s = i[n];
        s.isLeadingSpaceSensitive = (n === 0 || s.prev.isTrailingSpaceSensitive) && s.isLeadingSpaceSensitive, s.isTrailingSpaceSensitive = (n === i.length - 1 || s.next.isLeadingSpaceSensitive) && s.isTrailingSpaceSensitive;
      }
    }
  });
}
var M8 = A8;
function L8(t, e, r) {
  let { node: i } = t;
  switch (i.type) {
    case "front-matter":
      return ni(i.raw);
    case "root":
      return e.__onHtmlRoot && e.__onHtmlRoot(i), [qt(eg(t, e, r)), nt];
    case "element":
    case "ieConditionalComment":
      return D8(t, e, r);
    case "angularControlFlowBlock":
      return g8(t, e, r);
    case "angularControlFlowBlockParameters":
      return O8(t, e, r);
    case "angularControlFlowBlockParameter":
      return Bi.trim(i.expression);
    case "angularIcuExpression":
      return x8(t, e, r);
    case "angularIcuCase":
      return b8(t, e, r);
    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return [Wo(i), Zo(i)];
    case "interpolation":
      return [Wo(i, e), ...t.map(r, "children"), Zo(i, e)];
    case "text": {
      if (i.parent.type === "interpolation") {
        let s = /\n[^\S\n]*$/, a = s.test(i.value), o = a ? i.value.replace(s, "") : i.value;
        return [ni(o), a ? nt : ""];
      }
      let n = x3([vs(i, e), ...ND(i), bs(i, e)]);
      return Array.isArray(n) ? DD(n) : n;
    }
    case "docType":
      return [qt([Wo(i, e), " ", wr(!1, i.value.replace(/^html\b/i, "html"), /\s+/g, " ")]), Zo(i, e)];
    case "comment":
      return [vs(i, e), ni(e.originalText.slice(Bh(i), Ih(i))), bs(i, e)];
    case "attribute": {
      if (i.value === null)
        return i.rawName;
      let n = ID(i.value), s = D3(n, '"');
      return [i.rawName, "=", s, ni(s === '"' ? wr(!1, n, '"', "&quot;") : wr(!1, n, "'", "&apos;")), s];
    }
    case "cdata":
    default:
      throw new k3(i, "HTML");
  }
}
var R8 = { preprocess: M8, print: L8, insertPragma: f8, massageAstNode: $3, embed: n8, getVisitorKeys: p8 }, j8 = R8, Z8 = [{ linguistLanguageId: 146, name: "Angular", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".component.html"], parsers: ["angular"], vscodeLanguageIds: ["html"], filenames: [] }, { linguistLanguageId: 146, name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml", ".mjml"], parsers: ["html"], vscodeLanguageIds: ["html"] }, { linguistLanguageId: 146, name: "Lightning Web Components", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [], parsers: ["lwc"], vscodeLanguageIds: ["html"], filenames: [] }, { linguistLanguageId: 391, name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", parsers: ["vue"], vscodeLanguageIds: ["vue"] }], q0 = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, X0 = "HTML", W8 = { bracketSameLine: q0.bracketSameLine, htmlWhitespaceSensitivity: { category: X0, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: q0.singleAttributePerLine, vueIndentScriptAndStyle: { category: X0, type: "boolean", default: !1, description: "Indent script and style tags in Vue files." } }, q8 = W8, HD = {};
mD(HD, { angular: () => VI, html: () => XI, lwc: () => UI, vue: () => YI });
var V0;
(function(t) {
  t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom";
})(V0 || (V0 = {}));
var Y0;
(function(t) {
  t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default";
})(Y0 || (Y0 = {}));
var U0 = { name: "custom-elements" }, z0 = { name: "no-errors-schema" }, ps;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL";
})(ps || (ps = {}));
var G0;
(function(t) {
  t[t.Error = 0] = "Error", t[t.Warning = 1] = "Warning", t[t.Ignore = 2] = "Ignore";
})(G0 || (G0 = {}));
var ii;
(function(t) {
  t[t.RAW_TEXT = 0] = "RAW_TEXT", t[t.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", t[t.PARSABLE_DATA = 2] = "PARSABLE_DATA";
})(ii || (ii = {}));
function Qh(t) {
  if (t[0] != ":")
    return [null, t];
  let e = t.indexOf(":", 1);
  if (e === -1)
    throw new Error(`Unsupported format "${t}" expecting ":namespace:name"`);
  return [t.slice(1, e), t.slice(e + 1)];
}
function H0(t) {
  return Qh(t)[1] === "ng-container";
}
function J0(t) {
  return Qh(t)[1] === "ng-content";
}
function ic(t) {
  return t === null ? null : Qh(t)[0];
}
function Ac(t, e) {
  return t ? `:${t}:${e}` : e;
}
var nc;
function K0() {
  return nc || (nc = {}, bu(ps.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), bu(ps.STYLE, ["*|style"]), bu(ps.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), bu(ps.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), nc;
}
function bu(t, e) {
  for (let r of e)
    nc[r.toLowerCase()] = t;
}
var X8 = class {
}, V8 = "boolean", Y8 = "number", U8 = "string", z8 = "object", G8 = ["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|"], JD = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" })), H8 = Array.from(JD).reduce((t, [e, r]) => (t.set(e, r), t), /* @__PURE__ */ new Map()), J8 = class extends X8 {
  constructor() {
    super(), this._schema = /* @__PURE__ */ new Map(), this._eventSchema = /* @__PURE__ */ new Map(), G8.forEach((e) => {
      let r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), [n, s] = e.split("|"), a = s.split(","), [o, u] = n.split("^");
      o.split(",").forEach((h) => {
        this._schema.set(h.toLowerCase(), r), this._eventSchema.set(h.toLowerCase(), i);
      });
      let c = u && this._schema.get(u.toLowerCase());
      if (c) {
        for (let [h, d] of c)
          r.set(h, d);
        for (let h of this._eventSchema.get(u.toLowerCase()))
          i.add(h);
      }
      a.forEach((h) => {
        if (h.length > 0)
          switch (h[0]) {
            case "*":
              i.add(h.substring(1));
              break;
            case "!":
              r.set(h.substring(1), V8);
              break;
            case "#":
              r.set(h.substring(1), Y8);
              break;
            case "%":
              r.set(h.substring(1), z8);
              break;
            default:
              r.set(h, U8);
          }
      });
    });
  }
  hasProperty(e, r, i) {
    if (i.some((n) => n.name === z0.name))
      return !0;
    if (e.indexOf("-") > -1) {
      if (H0(e) || J0(e))
        return !1;
      if (i.some((n) => n.name === U0.name))
        return !0;
    }
    return (this._schema.get(e.toLowerCase()) || this._schema.get("unknown")).has(r);
  }
  hasElement(e, r) {
    return r.some((i) => i.name === z0.name) || e.indexOf("-") > -1 && (H0(e) || J0(e) || r.some((i) => i.name === U0.name)) ? !0 : this._schema.has(e.toLowerCase());
  }
  securityContext(e, r, i) {
    i && (r = this.getMappedPropName(r)), e = e.toLowerCase(), r = r.toLowerCase();
    let n = K0()[e + "|" + r];
    return n || (n = K0()["*|" + r], n || ps.NONE);
  }
  getMappedPropName(e) {
    return JD.get(e) ?? e;
  }
  getDefaultComponentElementName() {
    return "ng-component";
  }
  validateProperty(e) {
    return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...
If '${e}' is a directive input, make sure the directive is imported by the current module.` } : { error: !1 };
  }
  validateAttribute(e) {
    return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...` } : { error: !1 };
  }
  allKnownElementNames() {
    return Array.from(this._schema.keys());
  }
  allKnownAttributesOfElement(e) {
    let r = this._schema.get(e.toLowerCase()) || this._schema.get("unknown");
    return Array.from(r.keys()).map((i) => H8.get(i) ?? i);
  }
  allKnownEventsOfElement(e) {
    return Array.from(this._eventSchema.get(e.toLowerCase()) ?? []);
  }
  normalizeAnimationStyleProperty(e) {
    return w8(e);
  }
  normalizeAnimationStyleValue(e, r, i) {
    let n = "", s = i.toString().trim(), a = null;
    if (K8(e) && i !== 0 && i !== "0")
      if (typeof i == "number")
        n = "px";
      else {
        let o = i.match(/^[+-]?[\d\.]+([a-z]*)$/);
        o && o[1].length == 0 && (a = `Please provide a CSS unit value for ${r}:${i}`);
      }
    return { error: a, value: s + n };
  }
};
function K8(t) {
  switch (t) {
    case "width":
    case "height":
    case "minWidth":
    case "minHeight":
    case "maxWidth":
    case "maxHeight":
    case "left":
    case "top":
    case "bottom":
    case "right":
    case "fontSize":
    case "outlineWidth":
    case "outlineOffset":
    case "paddingTop":
    case "paddingLeft":
    case "paddingBottom":
    case "paddingRight":
    case "marginTop":
    case "marginLeft":
    case "marginBottom":
    case "marginRight":
    case "borderRadius":
    case "borderWidth":
    case "borderTopWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderBottomWidth":
    case "textIndent":
      return !0;
    default:
      return !1;
  }
}
var Ce = class {
  constructor({ closedByChildren: t, implicitNamespacePrefix: e, contentType: r = ii.PARSABLE_DATA, closedByParent: i = !1, isVoid: n = !1, ignoreFirstLf: s = !1, preventNamespaceInheritance: a = !1, canSelfClose: o = !1 } = {}) {
    this.closedByChildren = {}, this.closedByParent = !1, t && t.length > 0 && t.forEach((u) => this.closedByChildren[u] = !0), this.isVoid = n, this.closedByParent = i || n, this.implicitNamespacePrefix = e || null, this.contentType = r, this.ignoreFirstLf = s, this.preventNamespaceInheritance = a, this.canSelfClose = o ?? n;
  }
  isClosedByChild(t) {
    return this.isVoid || t.toLowerCase() in this.closedByChildren;
  }
  getContentType(t) {
    return typeof this.contentType == "object" ? (t === void 0 ? void 0 : this.contentType[t]) ?? this.contentType.default : this.contentType;
  }
}, eO, go;
function Ud(t) {
  return go || (eO = new Ce({ canSelfClose: !0 }), go = Object.assign(/* @__PURE__ */ Object.create(null), { base: new Ce({ isVoid: !0 }), meta: new Ce({ isVoid: !0 }), area: new Ce({ isVoid: !0 }), embed: new Ce({ isVoid: !0 }), link: new Ce({ isVoid: !0 }), img: new Ce({ isVoid: !0 }), input: new Ce({ isVoid: !0 }), param: new Ce({ isVoid: !0 }), hr: new Ce({ isVoid: !0 }), br: new Ce({ isVoid: !0 }), source: new Ce({ isVoid: !0 }), track: new Ce({ isVoid: !0 }), wbr: new Ce({ isVoid: !0 }), p: new Ce({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: !0 }), thead: new Ce({ closedByChildren: ["tbody", "tfoot"] }), tbody: new Ce({ closedByChildren: ["tbody", "tfoot"], closedByParent: !0 }), tfoot: new Ce({ closedByChildren: ["tbody"], closedByParent: !0 }), tr: new Ce({ closedByChildren: ["tr"], closedByParent: !0 }), td: new Ce({ closedByChildren: ["td", "th"], closedByParent: !0 }), th: new Ce({ closedByChildren: ["td", "th"], closedByParent: !0 }), col: new Ce({ isVoid: !0 }), svg: new Ce({ implicitNamespacePrefix: "svg" }), foreignObject: new Ce({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: !0 }), math: new Ce({ implicitNamespacePrefix: "math" }), li: new Ce({ closedByChildren: ["li"], closedByParent: !0 }), dt: new Ce({ closedByChildren: ["dt", "dd"] }), dd: new Ce({ closedByChildren: ["dt", "dd"], closedByParent: !0 }), rb: new Ce({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rt: new Ce({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rtc: new Ce({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: !0 }), rp: new Ce({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), optgroup: new Ce({ closedByChildren: ["optgroup"], closedByParent: !0 }), option: new Ce({ closedByChildren: ["option", "optgroup"], closedByParent: !0 }), pre: new Ce({ ignoreFirstLf: !0 }), listing: new Ce({ ignoreFirstLf: !0 }), style: new Ce({ contentType: ii.RAW_TEXT }), script: new Ce({ contentType: ii.RAW_TEXT }), title: new Ce({ contentType: { default: ii.ESCAPABLE_RAW_TEXT, svg: ii.PARSABLE_DATA } }), textarea: new Ce({ contentType: ii.ESCAPABLE_RAW_TEXT, ignoreFirstLf: !0 }) }), new J8().allKnownElementNames().forEach((e) => {
    !go[e] && ic(e) === null && (go[e] = new Ce({ canSelfClose: !1 }));
  })), go[t] ?? eO;
}
var _l = class {
  constructor(e, r) {
    this.sourceSpan = e, this.i18n = r;
  }
}, eI = class extends _l {
  constructor(e, r, i, n) {
    super(r, n), this.value = e, this.tokens = i, this.type = "text";
  }
  visit(e, r) {
    return e.visitText(this, r);
  }
}, tI = class extends _l {
  constructor(e, r, i, n) {
    super(r, n), this.value = e, this.tokens = i, this.type = "cdata";
  }
  visit(e, r) {
    return e.visitCdata(this, r);
  }
}, rI = class extends _l {
  constructor(e, r, i, n, s, a) {
    super(n, a), this.switchValue = e, this.type = r, this.cases = i, this.switchValueSourceSpan = s;
  }
  visit(e, r) {
    return e.visitExpansion(this, r);
  }
}, iI = class {
  constructor(e, r, i, n, s) {
    this.value = e, this.expression = r, this.sourceSpan = i, this.valueSourceSpan = n, this.expSourceSpan = s, this.type = "expansionCase";
  }
  visit(e, r) {
    return e.visitExpansionCase(this, r);
  }
}, nI = class extends _l {
  constructor(e, r, i, n, s, a, o) {
    super(i, o), this.name = e, this.value = r, this.keySpan = n, this.valueSpan = s, this.valueTokens = a, this.type = "attribute";
  }
  visit(e, r) {
    return e.visitAttribute(this, r);
  }
  get nameSpan() {
    return this.keySpan;
  }
}, bn = class extends _l {
  constructor(e, r, i, n, s, a = null, o = null, u) {
    super(n, u), this.name = e, this.attrs = r, this.children = i, this.startSourceSpan = s, this.endSourceSpan = a, this.nameSpan = o, this.type = "element";
  }
  visit(e, r) {
    return e.visitElement(this, r);
  }
}, sI = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "comment";
  }
  visit(e, r) {
    return e.visitComment(this, r);
  }
}, aI = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "docType";
  }
  visit(e, r) {
    return e.visitDocType(this, r);
  }
}, Ks = class {
  constructor(e, r, i, n, s, a = null) {
    this.name = e, this.parameters = r, this.children = i, this.sourceSpan = n, this.startSourceSpan = s, this.endSourceSpan = a, this.type = "block";
  }
  visit(e, r) {
    return e.visitBlock(this, r);
  }
}, tO = class {
  constructor(e, r) {
    this.expression = e, this.sourceSpan = r, this.type = "blockParameter", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e, r) {
    return e.visitBlockParameter(this, r);
  }
};
function KD(t, e, r = null) {
  let i = [], n = t.visit ? (s) => t.visit(s, r) || s.visit(t, r) : (s) => s.visit(t, r);
  return e.forEach((s) => {
    let a = n(s);
    a && i.push(a);
  }), i;
}
var oI = class {
  constructor() {
  }
  visitElement(e, r) {
    this.visitChildren(r, (i) => {
      i(e.attrs), i(e.children);
    });
  }
  visitAttribute(e, r) {
  }
  visitText(e, r) {
  }
  visitCdata(e, r) {
  }
  visitComment(e, r) {
  }
  visitDocType(e, r) {
  }
  visitExpansion(e, r) {
    return this.visitChildren(r, (i) => {
      i(e.cases);
    });
  }
  visitExpansionCase(e, r) {
  }
  visitBlock(e, r) {
    this.visitChildren(r, (i) => {
      i(e.parameters), i(e.children);
    });
  }
  visitBlockParameter(e, r) {
  }
  visitChildren(e, r) {
    let i = [], n = this;
    function s(a) {
      a && i.push(KD(n, a, e));
    }
    return r(s), Array.prototype.concat.apply([], i);
  }
}, Ec = { AElig: "", AMP: "&", amp: "&", Aacute: "", Abreve: "", Acirc: "", Acy: "", Afr: "", Agrave: "", Alpha: "", Amacr: "", And: "", Aogon: "", Aopf: "", ApplyFunction: "", af: "", Aring: "", angst: "", Ascr: "", Assign: "", colone: "", coloneq: "", Atilde: "", Auml: "", Backslash: "", setminus: "", setmn: "", smallsetminus: "", ssetmn: "", Barv: "", Barwed: "", doublebarwedge: "", Bcy: "", Because: "", becaus: "", because: "", Bernoullis: "", Bscr: "", bernou: "", Beta: "", Bfr: "", Bopf: "", Breve: "", breve: "", Bumpeq: "", HumpDownHump: "", bump: "", CHcy: "", COPY: "", copy: "", Cacute: "", Cap: "", CapitalDifferentialD: "", DD: "", Cayleys: "", Cfr: "", Ccaron: "", Ccedil: "", Ccirc: "", Cconint: "", Cdot: "", Cedilla: "", cedil: "", CenterDot: "", centerdot: "", middot: "", Chi: "", CircleDot: "", odot: "", CircleMinus: "", ominus: "", CirclePlus: "", oplus: "", CircleTimes: "", otimes: "", ClockwiseContourIntegral: "", cwconint: "", CloseCurlyDoubleQuote: "", rdquo: "", rdquor: "", CloseCurlyQuote: "", rsquo: "", rsquor: "", Colon: "", Proportion: "", Colone: "", Congruent: "", equiv: "", Conint: "", DoubleContourIntegral: "", ContourIntegral: "", conint: "", oint: "", Copf: "", complexes: "", Coproduct: "", coprod: "", CounterClockwiseContourIntegral: "", awconint: "", Cross: "", Cscr: "", Cup: "", CupCap: "", asympeq: "", DDotrahd: "", DJcy: "", DScy: "", DZcy: "", Dagger: "", ddagger: "", Darr: "", Dashv: "", DoubleLeftTee: "", Dcaron: "", Dcy: "", Del: "", nabla: "", Delta: "", Dfr: "", DiacriticalAcute: "", acute: "", DiacriticalDot: "", dot: "", DiacriticalDoubleAcute: "", dblac: "", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "", tilde: "", Diamond: "", diam: "", diamond: "", DifferentialD: "", dd: "", Dopf: "", Dot: "", DoubleDot: "", die: "", uml: "", DotDot: "", DotEqual: "", doteq: "", esdot: "", DoubleDownArrow: "", Downarrow: "", dArr: "", DoubleLeftArrow: "", Leftarrow: "", lArr: "", DoubleLeftRightArrow: "", Leftrightarrow: "", hArr: "", iff: "", DoubleLongLeftArrow: "", Longleftarrow: "", xlArr: "", DoubleLongLeftRightArrow: "", Longleftrightarrow: "", xhArr: "", DoubleLongRightArrow: "", Longrightarrow: "", xrArr: "", DoubleRightArrow: "", Implies: "", Rightarrow: "", rArr: "", DoubleRightTee: "", vDash: "", DoubleUpArrow: "", Uparrow: "", uArr: "", DoubleUpDownArrow: "", Updownarrow: "", vArr: "", DoubleVerticalBar: "", par: "", parallel: "", shortparallel: "", spar: "", DownArrow: "", ShortDownArrow: "", darr: "", downarrow: "", DownArrowBar: "", DownArrowUpArrow: "", duarr: "", DownBreve: "", DownLeftRightVector: "", DownLeftTeeVector: "", DownLeftVector: "", leftharpoondown: "", lhard: "", DownLeftVectorBar: "", DownRightTeeVector: "", DownRightVector: "", rhard: "", rightharpoondown: "", DownRightVectorBar: "", DownTee: "", top: "", DownTeeArrow: "", mapstodown: "", Dscr: "", Dstrok: "", ENG: "", ETH: "", Eacute: "", Ecaron: "", Ecirc: "", Ecy: "", Edot: "", Efr: "", Egrave: "", Element: "", in: "", isin: "", isinv: "", Emacr: "", EmptySmallSquare: "", EmptyVerySmallSquare: "", Eogon: "", Eopf: "", Epsilon: "", Equal: "", EqualTilde: "", eqsim: "", esim: "", Equilibrium: "", rightleftharpoons: "", rlhar: "", Escr: "", expectation: "", Esim: "", Eta: "", Euml: "", Exists: "", exist: "", ExponentialE: "", ee: "", exponentiale: "", Fcy: "", Ffr: "", FilledSmallSquare: "", FilledVerySmallSquare: "", blacksquare: "", squarf: "", squf: "", Fopf: "", ForAll: "", forall: "", Fouriertrf: "", Fscr: "", GJcy: "", GT: ">", gt: ">", Gamma: "", Gammad: "", Gbreve: "", Gcedil: "", Gcirc: "", Gcy: "", Gdot: "", Gfr: "", Gg: "", ggg: "", Gopf: "", GreaterEqual: "", ge: "", geq: "", GreaterEqualLess: "", gel: "", gtreqless: "", GreaterFullEqual: "", gE: "", geqq: "", GreaterGreater: "", GreaterLess: "", gl: "", gtrless: "", GreaterSlantEqual: "", geqslant: "", ges: "", GreaterTilde: "", gsim: "", gtrsim: "", Gscr: "", Gt: "", NestedGreaterGreater: "", gg: "", HARDcy: "", Hacek: "", caron: "", Hat: "^", Hcirc: "", Hfr: "", Poincareplane: "", HilbertSpace: "", Hscr: "", hamilt: "", Hopf: "", quaternions: "", HorizontalLine: "", boxh: "", Hstrok: "", HumpEqual: "", bumpe: "", bumpeq: "", IEcy: "", IJlig: "", IOcy: "", Iacute: "", Icirc: "", Icy: "", Idot: "", Ifr: "", Im: "", image: "", imagpart: "", Igrave: "", Imacr: "", ImaginaryI: "", ii: "", Int: "", Integral: "", int: "", Intersection: "", bigcap: "", xcap: "", InvisibleComma: "", ic: "", InvisibleTimes: "", it: "", Iogon: "", Iopf: "", Iota: "", Iscr: "", imagline: "", Itilde: "", Iukcy: "", Iuml: "", Jcirc: "", Jcy: "", Jfr: "", Jopf: "", Jscr: "", Jsercy: "", Jukcy: "", KHcy: "", KJcy: "", Kappa: "", Kcedil: "", Kcy: "", Kfr: "", Kopf: "", Kscr: "", LJcy: "", LT: "<", lt: "<", Lacute: "", Lambda: "", Lang: "", Laplacetrf: "", Lscr: "", lagran: "", Larr: "", twoheadleftarrow: "", Lcaron: "", Lcedil: "", Lcy: "", LeftAngleBracket: "", lang: "", langle: "", LeftArrow: "", ShortLeftArrow: "", larr: "", leftarrow: "", slarr: "", LeftArrowBar: "", larrb: "", LeftArrowRightArrow: "", leftrightarrows: "", lrarr: "", LeftCeiling: "", lceil: "", LeftDoubleBracket: "", lobrk: "", LeftDownTeeVector: "", LeftDownVector: "", dharl: "", downharpoonleft: "", LeftDownVectorBar: "", LeftFloor: "", lfloor: "", LeftRightArrow: "", harr: "", leftrightarrow: "", LeftRightVector: "", LeftTee: "", dashv: "", LeftTeeArrow: "", mapstoleft: "", LeftTeeVector: "", LeftTriangle: "", vartriangleleft: "", vltri: "", LeftTriangleBar: "", LeftTriangleEqual: "", ltrie: "", trianglelefteq: "", LeftUpDownVector: "", LeftUpTeeVector: "", LeftUpVector: "", uharl: "", upharpoonleft: "", LeftUpVectorBar: "", LeftVector: "", leftharpoonup: "", lharu: "", LeftVectorBar: "", LessEqualGreater: "", leg: "", lesseqgtr: "", LessFullEqual: "", lE: "", leqq: "", LessGreater: "", lessgtr: "", lg: "", LessLess: "", LessSlantEqual: "", leqslant: "", les: "", LessTilde: "", lesssim: "", lsim: "", Lfr: "", Ll: "", Lleftarrow: "", lAarr: "", Lmidot: "", LongLeftArrow: "", longleftarrow: "", xlarr: "", LongLeftRightArrow: "", longleftrightarrow: "", xharr: "", LongRightArrow: "", longrightarrow: "", xrarr: "", Lopf: "", LowerLeftArrow: "", swarr: "", swarrow: "", LowerRightArrow: "", searr: "", searrow: "", Lsh: "", lsh: "", Lstrok: "", Lt: "", NestedLessLess: "", ll: "", Map: "", Mcy: "", MediumSpace: "", Mellintrf: "", Mscr: "", phmmat: "", Mfr: "", MinusPlus: "", mnplus: "", mp: "", Mopf: "", Mu: "", NJcy: "", Nacute: "", Ncaron: "", Ncedil: "", Ncy: "", NegativeMediumSpace: "", NegativeThickSpace: "", NegativeThinSpace: "", NegativeVeryThinSpace: "", ZeroWidthSpace: "", NewLine: `
`, Nfr: "", NoBreak: "", NonBreakingSpace: "", nbsp: "", Nopf: "", naturals: "", Not: "", NotCongruent: "", nequiv: "", NotCupCap: "", NotDoubleVerticalBar: "", npar: "", nparallel: "", nshortparallel: "", nspar: "", NotElement: "", notin: "", notinva: "", NotEqual: "", ne: "", NotEqualTilde: "", nesim: "", NotExists: "", nexist: "", nexists: "", NotGreater: "", ngt: "", ngtr: "", NotGreaterEqual: "", nge: "", ngeq: "", NotGreaterFullEqual: "", ngE: "", ngeqq: "", NotGreaterGreater: "", nGtv: "", NotGreaterLess: "", ntgl: "", NotGreaterSlantEqual: "", ngeqslant: "", nges: "", NotGreaterTilde: "", ngsim: "", NotHumpDownHump: "", nbump: "", NotHumpEqual: "", nbumpe: "", NotLeftTriangle: "", nltri: "", ntriangleleft: "", NotLeftTriangleBar: "", NotLeftTriangleEqual: "", nltrie: "", ntrianglelefteq: "", NotLess: "", nless: "", nlt: "", NotLessEqual: "", nle: "", nleq: "", NotLessGreater: "", ntlg: "", NotLessLess: "", nLtv: "", NotLessSlantEqual: "", nleqslant: "", nles: "", NotLessTilde: "", nlsim: "", NotNestedGreaterGreater: "", NotNestedLessLess: "", NotPrecedes: "", npr: "", nprec: "", NotPrecedesEqual: "", npre: "", npreceq: "", NotPrecedesSlantEqual: "", nprcue: "", NotReverseElement: "", notni: "", notniva: "", NotRightTriangle: "", nrtri: "", ntriangleright: "", NotRightTriangleBar: "", NotRightTriangleEqual: "", nrtrie: "", ntrianglerighteq: "", NotSquareSubset: "", NotSquareSubsetEqual: "", nsqsube: "", NotSquareSuperset: "", NotSquareSupersetEqual: "", nsqsupe: "", NotSubset: "", nsubset: "", vnsub: "", NotSubsetEqual: "", nsube: "", nsubseteq: "", NotSucceeds: "", nsc: "", nsucc: "", NotSucceedsEqual: "", nsce: "", nsucceq: "", NotSucceedsSlantEqual: "", nsccue: "", NotSucceedsTilde: "", NotSuperset: "", nsupset: "", vnsup: "", NotSupersetEqual: "", nsupe: "", nsupseteq: "", NotTilde: "", nsim: "", NotTildeEqual: "", nsime: "", nsimeq: "", NotTildeFullEqual: "", ncong: "", NotTildeTilde: "", nap: "", napprox: "", NotVerticalBar: "", nmid: "", nshortmid: "", nsmid: "", Nscr: "", Ntilde: "", Nu: "", OElig: "", Oacute: "", Ocirc: "", Ocy: "", Odblac: "", Ofr: "", Ograve: "", Omacr: "", Omega: "", ohm: "", Omicron: "", Oopf: "", OpenCurlyDoubleQuote: "", ldquo: "", OpenCurlyQuote: "", lsquo: "", Or: "", Oscr: "", Oslash: "", Otilde: "", Otimes: "", Ouml: "", OverBar: "", oline: "", OverBrace: "", OverBracket: "", tbrk: "", OverParenthesis: "", PartialD: "", part: "", Pcy: "", Pfr: "", Phi: "", Pi: "", PlusMinus: "", plusmn: "", pm: "", Popf: "", primes: "", Pr: "", Precedes: "", pr: "", prec: "", PrecedesEqual: "", pre: "", preceq: "", PrecedesSlantEqual: "", prcue: "", preccurlyeq: "", PrecedesTilde: "", precsim: "", prsim: "", Prime: "", Product: "", prod: "", Proportional: "", prop: "", propto: "", varpropto: "", vprop: "", Pscr: "", Psi: "", QUOT: '"', quot: '"', Qfr: "", Qopf: "", rationals: "", Qscr: "", RBarr: "", drbkarow: "", REG: "", circledR: "", reg: "", Racute: "", Rang: "", Rarr: "", twoheadrightarrow: "", Rarrtl: "", Rcaron: "", Rcedil: "", Rcy: "", Re: "", Rfr: "", real: "", realpart: "", ReverseElement: "", SuchThat: "", ni: "", niv: "", ReverseEquilibrium: "", leftrightharpoons: "", lrhar: "", ReverseUpEquilibrium: "", duhar: "", Rho: "", RightAngleBracket: "", rang: "", rangle: "", RightArrow: "", ShortRightArrow: "", rarr: "", rightarrow: "", srarr: "", RightArrowBar: "", rarrb: "", RightArrowLeftArrow: "", rightleftarrows: "", rlarr: "", RightCeiling: "", rceil: "", RightDoubleBracket: "", robrk: "", RightDownTeeVector: "", RightDownVector: "", dharr: "", downharpoonright: "", RightDownVectorBar: "", RightFloor: "", rfloor: "", RightTee: "", vdash: "", RightTeeArrow: "", map: "", mapsto: "", RightTeeVector: "", RightTriangle: "", vartriangleright: "", vrtri: "", RightTriangleBar: "", RightTriangleEqual: "", rtrie: "", trianglerighteq: "", RightUpDownVector: "", RightUpTeeVector: "", RightUpVector: "", uharr: "", upharpoonright: "", RightUpVectorBar: "", RightVector: "", rharu: "", rightharpoonup: "", RightVectorBar: "", Ropf: "", reals: "", RoundImplies: "", Rrightarrow: "", rAarr: "", Rscr: "", realine: "", Rsh: "", rsh: "", RuleDelayed: "", SHCHcy: "", SHcy: "", SOFTcy: "", Sacute: "", Sc: "", Scaron: "", Scedil: "", Scirc: "", Scy: "", Sfr: "", ShortUpArrow: "", UpArrow: "", uarr: "", uparrow: "", Sigma: "", SmallCircle: "", compfn: "", Sopf: "", Sqrt: "", radic: "", Square: "", squ: "", square: "", SquareIntersection: "", sqcap: "", SquareSubset: "", sqsub: "", sqsubset: "", SquareSubsetEqual: "", sqsube: "", sqsubseteq: "", SquareSuperset: "", sqsup: "", sqsupset: "", SquareSupersetEqual: "", sqsupe: "", sqsupseteq: "", SquareUnion: "", sqcup: "", Sscr: "", Star: "", sstarf: "", Sub: "", Subset: "", SubsetEqual: "", sube: "", subseteq: "", Succeeds: "", sc: "", succ: "", SucceedsEqual: "", sce: "", succeq: "", SucceedsSlantEqual: "", sccue: "", succcurlyeq: "", SucceedsTilde: "", scsim: "", succsim: "", Sum: "", sum: "", Sup: "", Supset: "", Superset: "", sup: "", supset: "", SupersetEqual: "", supe: "", supseteq: "", THORN: "", TRADE: "", trade: "", TSHcy: "", TScy: "", Tab: "	", Tau: "", Tcaron: "", Tcedil: "", Tcy: "", Tfr: "", Therefore: "", there4: "", therefore: "", Theta: "", ThickSpace: "", ThinSpace: "", thinsp: "", Tilde: "", sim: "", thicksim: "", thksim: "", TildeEqual: "", sime: "", simeq: "", TildeFullEqual: "", cong: "", TildeTilde: "", ap: "", approx: "", asymp: "", thickapprox: "", thkap: "", Topf: "", TripleDot: "", tdot: "", Tscr: "", Tstrok: "", Uacute: "", Uarr: "", Uarrocir: "", Ubrcy: "", Ubreve: "", Ucirc: "", Ucy: "", Udblac: "", Ufr: "", Ugrave: "", Umacr: "", UnderBar: "_", lowbar: "_", UnderBrace: "", UnderBracket: "", bbrk: "", UnderParenthesis: "", Union: "", bigcup: "", xcup: "", UnionPlus: "", uplus: "", Uogon: "", Uopf: "", UpArrowBar: "", UpArrowDownArrow: "", udarr: "", UpDownArrow: "", updownarrow: "", varr: "", UpEquilibrium: "", udhar: "", UpTee: "", bot: "", bottom: "", perp: "", UpTeeArrow: "", mapstoup: "", UpperLeftArrow: "", nwarr: "", nwarrow: "", UpperRightArrow: "", nearr: "", nearrow: "", Upsi: "", upsih: "", Upsilon: "", Uring: "", Uscr: "", Utilde: "", Uuml: "", VDash: "", Vbar: "", Vcy: "", Vdash: "", Vdashl: "", Vee: "", bigvee: "", xvee: "", Verbar: "", Vert: "", VerticalBar: "", mid: "", shortmid: "", smid: "", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "", VerticalTilde: "", wr: "", wreath: "", VeryThinSpace: "", hairsp: "", Vfr: "", Vopf: "", Vscr: "", Vvdash: "", Wcirc: "", Wedge: "", bigwedge: "", xwedge: "", Wfr: "", Wopf: "", Wscr: "", Xfr: "", Xi: "", Xopf: "", Xscr: "", YAcy: "", YIcy: "", YUcy: "", Yacute: "", Ycirc: "", Ycy: "", Yfr: "", Yopf: "", Yscr: "", Yuml: "", ZHcy: "", Zacute: "", Zcaron: "", Zcy: "", Zdot: "", Zeta: "", Zfr: "", zeetrf: "", Zopf: "", integers: "", Zscr: "", aacute: "", abreve: "", ac: "", mstpos: "", acE: "", acd: "", acirc: "", acy: "", aelig: "", afr: "", agrave: "", alefsym: "", aleph: "", alpha: "", amacr: "", amalg: "", and: "", wedge: "", andand: "", andd: "", andslope: "", andv: "", ang: "", angle: "", ange: "", angmsd: "", measuredangle: "", angmsdaa: "", angmsdab: "", angmsdac: "", angmsdad: "", angmsdae: "", angmsdaf: "", angmsdag: "", angmsdah: "", angrt: "", angrtvb: "", angrtvbd: "", angsph: "", angzarr: "", aogon: "", aopf: "", apE: "", apacir: "", ape: "", approxeq: "", apid: "", apos: "'", aring: "", ascr: "", ast: "*", midast: "*", atilde: "", auml: "", awint: "", bNot: "", backcong: "", bcong: "", backepsilon: "", bepsi: "", backprime: "", bprime: "", backsim: "", bsim: "", backsimeq: "", bsime: "", barvee: "", barwed: "", barwedge: "", bbrktbrk: "", bcy: "", bdquo: "", ldquor: "", bemptyv: "", beta: "", beth: "", between: "", twixt: "", bfr: "", bigcirc: "", xcirc: "", bigodot: "", xodot: "", bigoplus: "", xoplus: "", bigotimes: "", xotime: "", bigsqcup: "", xsqcup: "", bigstar: "", starf: "", bigtriangledown: "", xdtri: "", bigtriangleup: "", xutri: "", biguplus: "", xuplus: "", bkarow: "", rbarr: "", blacklozenge: "", lozf: "", blacktriangle: "", utrif: "", blacktriangledown: "", dtrif: "", blacktriangleleft: "", ltrif: "", blacktriangleright: "", rtrif: "", blank: "", blk12: "", blk14: "", blk34: "", block: "", bne: "=", bnequiv: "", bnot: "", bopf: "", bowtie: "", boxDL: "", boxDR: "", boxDl: "", boxDr: "", boxH: "", boxHD: "", boxHU: "", boxHd: "", boxHu: "", boxUL: "", boxUR: "", boxUl: "", boxUr: "", boxV: "", boxVH: "", boxVL: "", boxVR: "", boxVh: "", boxVl: "", boxVr: "", boxbox: "", boxdL: "", boxdR: "", boxdl: "", boxdr: "", boxhD: "", boxhU: "", boxhd: "", boxhu: "", boxminus: "", minusb: "", boxplus: "", plusb: "", boxtimes: "", timesb: "", boxuL: "", boxuR: "", boxul: "", boxur: "", boxv: "", boxvH: "", boxvL: "", boxvR: "", boxvh: "", boxvl: "", boxvr: "", brvbar: "", bscr: "", bsemi: "", bsol: "\\", bsolb: "", bsolhsub: "", bull: "", bullet: "", bumpE: "", cacute: "", cap: "", capand: "", capbrcup: "", capcap: "", capcup: "", capdot: "", caps: "", caret: "", ccaps: "", ccaron: "", ccedil: "", ccirc: "", ccups: "", ccupssm: "", cdot: "", cemptyv: "", cent: "", cfr: "", chcy: "", check: "", checkmark: "", chi: "", cir: "", cirE: "", circ: "", circeq: "", cire: "", circlearrowleft: "", olarr: "", circlearrowright: "", orarr: "", circledS: "", oS: "", circledast: "", oast: "", circledcirc: "", ocir: "", circleddash: "", odash: "", cirfnint: "", cirmid: "", cirscir: "", clubs: "", clubsuit: "", colon: ":", comma: ",", commat: "@", comp: "", complement: "", congdot: "", copf: "", copysr: "", crarr: "", cross: "", cscr: "", csub: "", csube: "", csup: "", csupe: "", ctdot: "", cudarrl: "", cudarrr: "", cuepr: "", curlyeqprec: "", cuesc: "", curlyeqsucc: "", cularr: "", curvearrowleft: "", cularrp: "", cup: "", cupbrcap: "", cupcap: "", cupcup: "", cupdot: "", cupor: "", cups: "", curarr: "", curvearrowright: "", curarrm: "", curlyvee: "", cuvee: "", curlywedge: "", cuwed: "", curren: "", cwint: "", cylcty: "", dHar: "", dagger: "", daleth: "", dash: "", hyphen: "", dbkarow: "", rBarr: "", dcaron: "", dcy: "", ddarr: "", downdownarrows: "", ddotseq: "", eDDot: "", deg: "", delta: "", demptyv: "", dfisht: "", dfr: "", diamondsuit: "", diams: "", digamma: "", gammad: "", disin: "", div: "", divide: "", divideontimes: "", divonx: "", djcy: "", dlcorn: "", llcorner: "", dlcrop: "", dollar: "$", dopf: "", doteqdot: "", eDot: "", dotminus: "", minusd: "", dotplus: "", plusdo: "", dotsquare: "", sdotb: "", drcorn: "", lrcorner: "", drcrop: "", dscr: "", dscy: "", dsol: "", dstrok: "", dtdot: "", dtri: "", triangledown: "", dwangle: "", dzcy: "", dzigrarr: "", eacute: "", easter: "", ecaron: "", ecir: "", eqcirc: "", ecirc: "", ecolon: "", eqcolon: "", ecy: "", edot: "", efDot: "", fallingdotseq: "", efr: "", eg: "", egrave: "", egs: "", eqslantgtr: "", egsdot: "", el: "", elinters: "", ell: "", els: "", eqslantless: "", elsdot: "", emacr: "", empty: "", emptyset: "", emptyv: "", varnothing: "", emsp13: "", emsp14: "", emsp: "", eng: "", ensp: "", eogon: "", eopf: "", epar: "", eparsl: "", eplus: "", epsi: "", epsilon: "", epsiv: "", straightepsilon: "", varepsilon: "", equals: "=", equest: "", questeq: "", equivDD: "", eqvparsl: "", erDot: "", risingdotseq: "", erarr: "", escr: "", eta: "", eth: "", euml: "", euro: "", excl: "!", fcy: "", female: "", ffilig: "", fflig: "", ffllig: "", ffr: "", filig: "", fjlig: "fj", flat: "", fllig: "", fltns: "", fnof: "", fopf: "", fork: "", pitchfork: "", forkv: "", fpartint: "", frac12: "", half: "", frac13: "", frac14: "", frac15: "", frac16: "", frac18: "", frac23: "", frac25: "", frac34: "", frac35: "", frac38: "", frac45: "", frac56: "", frac58: "", frac78: "", frasl: "", frown: "", sfrown: "", fscr: "", gEl: "", gtreqqless: "", gacute: "", gamma: "", gap: "", gtrapprox: "", gbreve: "", gcirc: "", gcy: "", gdot: "", gescc: "", gesdot: "", gesdoto: "", gesdotol: "", gesl: "", gesles: "", gfr: "", gimel: "", gjcy: "", glE: "", gla: "", glj: "", gnE: "", gneqq: "", gnap: "", gnapprox: "", gne: "", gneq: "", gnsim: "", gopf: "", gscr: "", gsime: "", gsiml: "", gtcc: "", gtcir: "", gtdot: "", gtrdot: "", gtlPar: "", gtquest: "", gtrarr: "", gvertneqq: "", gvnE: "", hardcy: "", harrcir: "", harrw: "", leftrightsquigarrow: "", hbar: "", hslash: "", planck: "", plankv: "", hcirc: "", hearts: "", heartsuit: "", hellip: "", mldr: "", hercon: "", hfr: "", hksearow: "", searhk: "", hkswarow: "", swarhk: "", hoarr: "", homtht: "", hookleftarrow: "", larrhk: "", hookrightarrow: "", rarrhk: "", hopf: "", horbar: "", hscr: "", hstrok: "", hybull: "", iacute: "", icirc: "", icy: "", iecy: "", iexcl: "", ifr: "", igrave: "", iiiint: "", qint: "", iiint: "", tint: "", iinfin: "", iiota: "", ijlig: "", imacr: "", imath: "", inodot: "", imof: "", imped: "", incare: "", infin: "", infintie: "", intcal: "", intercal: "", intlarhk: "", intprod: "", iprod: "", iocy: "", iogon: "", iopf: "", iota: "", iquest: "", iscr: "", isinE: "", isindot: "", isins: "", isinsv: "", itilde: "", iukcy: "", iuml: "", jcirc: "", jcy: "", jfr: "", jmath: "", jopf: "", jscr: "", jsercy: "", jukcy: "", kappa: "", kappav: "", varkappa: "", kcedil: "", kcy: "", kfr: "", kgreen: "", khcy: "", kjcy: "", kopf: "", kscr: "", lAtail: "", lBarr: "", lEg: "", lesseqqgtr: "", lHar: "", lacute: "", laemptyv: "", lambda: "", langd: "", lap: "", lessapprox: "", laquo: "", larrbfs: "", larrfs: "", larrlp: "", looparrowleft: "", larrpl: "", larrsim: "", larrtl: "", leftarrowtail: "", lat: "", latail: "", late: "", lates: "", lbarr: "", lbbrk: "", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "", lbrksld: "", lbrkslu: "", lcaron: "", lcedil: "", lcy: "", ldca: "", ldrdhar: "", ldrushar: "", ldsh: "", le: "", leq: "", leftleftarrows: "", llarr: "", leftthreetimes: "", lthree: "", lescc: "", lesdot: "", lesdoto: "", lesdotor: "", lesg: "", lesges: "", lessdot: "", ltdot: "", lfisht: "", lfr: "", lgE: "", lharul: "", lhblk: "", ljcy: "", llhard: "", lltri: "", lmidot: "", lmoust: "", lmoustache: "", lnE: "", lneqq: "", lnap: "", lnapprox: "", lne: "", lneq: "", lnsim: "", loang: "", loarr: "", longmapsto: "", xmap: "", looparrowright: "", rarrlp: "", lopar: "", lopf: "", loplus: "", lotimes: "", lowast: "", loz: "", lozenge: "", lpar: "(", lparlt: "", lrhard: "", lrm: "", lrtri: "", lsaquo: "", lscr: "", lsime: "", lsimg: "", lsquor: "", sbquo: "", lstrok: "", ltcc: "", ltcir: "", ltimes: "", ltlarr: "", ltquest: "", ltrPar: "", ltri: "", triangleleft: "", lurdshar: "", luruhar: "", lvertneqq: "", lvnE: "", mDDot: "", macr: "", strns: "", male: "", malt: "", maltese: "", marker: "", mcomma: "", mcy: "", mdash: "", mfr: "", mho: "", micro: "", midcir: "", minus: "", minusdu: "", mlcp: "", models: "", mopf: "", mscr: "", mu: "", multimap: "", mumap: "", nGg: "", nGt: "", nLeftarrow: "", nlArr: "", nLeftrightarrow: "", nhArr: "", nLl: "", nLt: "", nRightarrow: "", nrArr: "", nVDash: "", nVdash: "", nacute: "", nang: "", napE: "", napid: "", napos: "", natur: "", natural: "", ncap: "", ncaron: "", ncedil: "", ncongdot: "", ncup: "", ncy: "", ndash: "", neArr: "", nearhk: "", nedot: "", nesear: "", toea: "", nfr: "", nharr: "", nleftrightarrow: "", nhpar: "", nis: "", nisd: "", njcy: "", nlE: "", nleqq: "", nlarr: "", nleftarrow: "", nldr: "", nopf: "", not: "", notinE: "", notindot: "", notinvb: "", notinvc: "", notnivb: "", notnivc: "", nparsl: "", npart: "", npolint: "", nrarr: "", nrightarrow: "", nrarrc: "", nrarrw: "", nscr: "", nsub: "", nsubE: "", nsubseteqq: "", nsup: "", nsupE: "", nsupseteqq: "", ntilde: "", nu: "", num: "#", numero: "", numsp: "", nvDash: "", nvHarr: "", nvap: "", nvdash: "", nvge: "", nvgt: ">", nvinfin: "", nvlArr: "", nvle: "", nvlt: "<", nvltrie: "", nvrArr: "", nvrtrie: "", nvsim: "", nwArr: "", nwarhk: "", nwnear: "", oacute: "", ocirc: "", ocy: "", odblac: "", odiv: "", odsold: "", oelig: "", ofcir: "", ofr: "", ogon: "", ograve: "", ogt: "", ohbar: "", olcir: "", olcross: "", olt: "", omacr: "", omega: "", omicron: "", omid: "", oopf: "", opar: "", operp: "", or: "", vee: "", ord: "", order: "", orderof: "", oscr: "", ordf: "", ordm: "", origof: "", oror: "", orslope: "", orv: "", oslash: "", osol: "", otilde: "", otimesas: "", ouml: "", ovbar: "", para: "", parsim: "", parsl: "", pcy: "", percnt: "%", period: ".", permil: "", pertenk: "", pfr: "", phi: "", phiv: "", straightphi: "", varphi: "", phone: "", pi: "", piv: "", varpi: "", planckh: "", plus: "+", plusacir: "", pluscir: "", plusdu: "", pluse: "", plussim: "", plustwo: "", pointint: "", popf: "", pound: "", prE: "", prap: "", precapprox: "", precnapprox: "", prnap: "", precneqq: "", prnE: "", precnsim: "", prnsim: "", prime: "", profalar: "", profline: "", profsurf: "", prurel: "", pscr: "", psi: "", puncsp: "", qfr: "", qopf: "", qprime: "", qscr: "", quatint: "", quest: "?", rAtail: "", rHar: "", race: "", racute: "", raemptyv: "", rangd: "", range: "", raquo: "", rarrap: "", rarrbfs: "", rarrc: "", rarrfs: "", rarrpl: "", rarrsim: "", rarrtl: "", rightarrowtail: "", rarrw: "", rightsquigarrow: "", ratail: "", ratio: "", rbbrk: "", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "", rbrksld: "", rbrkslu: "", rcaron: "", rcedil: "", rcy: "", rdca: "", rdldhar: "", rdsh: "", rect: "", rfisht: "", rfr: "", rharul: "", rho: "", rhov: "", varrho: "", rightrightarrows: "", rrarr: "", rightthreetimes: "", rthree: "", ring: "", rlm: "", rmoust: "", rmoustache: "", rnmid: "", roang: "", roarr: "", ropar: "", ropf: "", roplus: "", rotimes: "", rpar: ")", rpargt: "", rppolint: "", rsaquo: "", rscr: "", rtimes: "", rtri: "", triangleright: "", rtriltri: "", ruluhar: "", rx: "", sacute: "", scE: "", scap: "", succapprox: "", scaron: "", scedil: "", scirc: "", scnE: "", succneqq: "", scnap: "", succnapprox: "", scnsim: "", succnsim: "", scpolint: "", scy: "", sdot: "", sdote: "", seArr: "", sect: "", semi: ";", seswar: "", tosa: "", sext: "", sfr: "", sharp: "", shchcy: "", shcy: "", shy: "", sigma: "", sigmaf: "", sigmav: "", varsigma: "", simdot: "", simg: "", simgE: "", siml: "", simlE: "", simne: "", simplus: "", simrarr: "", smashp: "", smeparsl: "", smile: "", ssmile: "", smt: "", smte: "", smtes: "", softcy: "", sol: "/", solb: "", solbar: "", sopf: "", spades: "", spadesuit: "", sqcaps: "", sqcups: "", sscr: "", star: "", sub: "", subset: "", subE: "", subseteqq: "", subdot: "", subedot: "", submult: "", subnE: "", subsetneqq: "", subne: "", subsetneq: "", subplus: "", subrarr: "", subsim: "", subsub: "", subsup: "", sung: "", sup1: "", sup2: "", sup3: "", supE: "", supseteqq: "", supdot: "", supdsub: "", supedot: "", suphsol: "", suphsub: "", suplarr: "", supmult: "", supnE: "", supsetneqq: "", supne: "", supsetneq: "", supplus: "", supsim: "", supsub: "", supsup: "", swArr: "", swnwar: "", szlig: "", target: "", tau: "", tcaron: "", tcedil: "", tcy: "", telrec: "", tfr: "", theta: "", thetasym: "", thetav: "", vartheta: "", thorn: "", times: "", timesbar: "", timesd: "", topbot: "", topcir: "", topf: "", topfork: "", tprime: "", triangle: "", utri: "", triangleq: "", trie: "", tridot: "", triminus: "", triplus: "", trisb: "", tritime: "", trpezium: "", tscr: "", tscy: "", tshcy: "", tstrok: "", uHar: "", uacute: "", ubrcy: "", ubreve: "", ucirc: "", ucy: "", udblac: "", ufisht: "", ufr: "", ugrave: "", uhblk: "", ulcorn: "", ulcorner: "", ulcrop: "", ultri: "", umacr: "", uogon: "", uopf: "", upsi: "", upsilon: "", upuparrows: "", uuarr: "", urcorn: "", urcorner: "", urcrop: "", uring: "", urtri: "", uscr: "", utdot: "", utilde: "", uuml: "", uwangle: "", vBar: "", vBarv: "", vangrt: "", varsubsetneq: "", vsubne: "", varsubsetneqq: "", vsubnE: "", varsupsetneq: "", vsupne: "", varsupsetneqq: "", vsupnE: "", vcy: "", veebar: "", veeeq: "", vellip: "", vfr: "", vopf: "", vscr: "", vzigzag: "", wcirc: "", wedbar: "", wedgeq: "", weierp: "", wp: "", wfr: "", wopf: "", wscr: "", xfr: "", xi: "", xnis: "", xopf: "", xscr: "", yacute: "", yacy: "", ycirc: "", ycy: "", yen: "", yfr: "", yicy: "", yopf: "", yscr: "", yucy: "", yuml: "", zacute: "", zcaron: "", zcy: "", zdot: "", zeta: "", zfr: "", zhcy: "", zigrarr: "", zopf: "", zscr: "", zwj: "", zwnj: "" }, lI = "";
Ec.ngsp = lI;
var uI = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
function cI(t, e) {
  if (e != null && !(Array.isArray(e) && e.length == 2))
    throw new Error(`Expected '${t}' to be an array, [start, end].`);
  if (e != null) {
    let r = e[0], i = e[1];
    uI.forEach((n) => {
      if (n.test(r) || n.test(i))
        throw new Error(`['${r}', '${i}'] contains unusable interpolation symbol.`);
    });
  }
}
var hI = class e2 {
  static fromArray(e) {
    return e ? (cI("interpolation", e), new e2(e[0], e[1])) : t2;
  }
  constructor(e, r) {
    this.start = e, this.end = r;
  }
}, t2 = new hI("{{", "}}"), Np = class extends GD {
  constructor(e, r, i) {
    super(i, e), this.tokenType = r;
  }
}, pI = class {
  constructor(e, r, i) {
    this.tokens = e, this.errors = r, this.nonNormalizedIcuExpressions = i;
  }
};
function dI(t, e, r, i = {}) {
  let n = new gI(new zD(t, e), r, i);
  return n.tokenize(), new pI(vI(n.tokens), n.errors, n.nonNormalizedIcuExpressions);
}
var fI = /\r\n?/g;
function ea(t) {
  return `Unexpected character "${t === 0 ? "EOF" : String.fromCharCode(t)}"`;
}
function rO(t) {
  return `Unknown entity "${t}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
}
function mI(t, e) {
  return `Unable to parse entity "${e}" - ${t} character reference entities must end with ";"`;
}
var kc;
(function(t) {
  t.HEX = "hexadecimal", t.DEC = "decimal";
})(kc || (kc = {}));
var _p = class {
  constructor(e) {
    this.error = e;
  }
}, gI = class {
  constructor(e, r, i) {
    this._getTagContentType = r, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = !1, this._fullNameStack = [], this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = i.tokenizeExpansionForms || !1, this._interpolationConfig = i.interpolationConfig || t2, this._leadingTriviaCodePoints = i.leadingTriviaChars && i.leadingTriviaChars.map((s) => s.codePointAt(0) || 0), this._canSelfClose = i.canSelfClose || !1, this._allowHtmComponentClosingTags = i.allowHtmComponentClosingTags || !1;
    let n = i.range || { endPos: e.content.length, startPos: 0, startLine: 0, startCol: 0 };
    this._cursor = i.escapedString ? new SI(e, n) : new r2(e, n), this._preserveLineEndings = i.preserveLineEndings || !1, this._i18nNormalizeLineEndingsInICUs = i.i18nNormalizeLineEndingsInICUs || !1, this._tokenizeBlocks = i.tokenizeBlocks ?? !0;
    try {
      this._cursor.init();
    } catch (s) {
      this.handleError(s);
    }
  }
  _processCarriageReturns(e) {
    return this._preserveLineEndings ? e : e.replace(fI, `
`);
  }
  tokenize() {
    for (; this._cursor.peek() !== 0; ) {
      let e = this._cursor.clone();
      try {
        if (this._attemptCharCode(60))
          if (this._attemptCharCode(33))
            this._attemptStr("[CDATA[") ? this._consumeCdata(e) : this._attemptStr("--") ? this._consumeComment(e) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e) : this._consumeBogusComment(e);
          else if (this._attemptCharCode(47))
            this._consumeTagClose(e);
          else {
            let r = this._cursor.clone();
            this._attemptCharCode(63) ? (this._cursor = r, this._consumeBogusComment(e)) : this._consumeTagOpen(e);
          }
        else
          this._tokenizeBlocks && this._attemptCharCode(64) ? this._consumeBlockStart(e) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(125) ? this._consumeBlockEnd(e) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
      } catch (r) {
        this.handleError(r);
      }
    }
    this._beginToken(30), this._endToken([]);
  }
  _getBlockName() {
    let e = !1, r = this._cursor.clone();
    return this._attemptCharCodeUntilFn((i) => tg(i) ? !e : sO(i) ? (e = !0, !1) : !0), this._cursor.getChars(r).trim();
  }
  _consumeBlockStart(e) {
    this._beginToken(25, e);
    let r = this._endToken([this._getBlockName()]);
    if (this._cursor.peek() === 40)
      if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(Ct), this._attemptCharCode(41))
        this._attemptCharCodeUntilFn(Ct);
      else {
        r.type = 29;
        return;
      }
    this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : r.type = 29;
  }
  _consumeBlockEnd(e) {
    this._beginToken(27, e), this._endToken([]);
  }
  _consumeBlockParameters() {
    for (this._attemptCharCodeUntilFn(aO); this._cursor.peek() !== 41 && this._cursor.peek() !== 0; ) {
      this._beginToken(28);
      let e = this._cursor.clone(), r = null, i = 0;
      for (; this._cursor.peek() !== 59 && this._cursor.peek() !== 0 || r !== null; ) {
        let n = this._cursor.peek();
        if (n === 92)
          this._cursor.advance();
        else if (n === r)
          r = null;
        else if (r === null && W0(n))
          r = n;
        else if (n === 40 && r === null)
          i++;
        else if (n === 41 && r === null) {
          if (i === 0)
            break;
          i > 0 && i--;
        }
        this._cursor.advance();
      }
      this._endToken([this._cursor.getChars(e)]), this._attemptCharCodeUntilFn(aO);
    }
  }
  _tokenizeExpansionForm() {
    if (this.isExpansionFormStart())
      return this._consumeExpansionFormStart(), !0;
    if (bI(this._cursor.peek()) && this._isInExpansionForm())
      return this._consumeExpansionCaseStart(), !0;
    if (this._cursor.peek() === 125) {
      if (this._isInExpansionCase())
        return this._consumeExpansionCaseEnd(), !0;
      if (this._isInExpansionForm())
        return this._consumeExpansionFormEnd(), !0;
    }
    return !1;
  }
  _beginToken(e, r = this._cursor.clone()) {
    this._currentTokenStart = r, this._currentTokenType = e;
  }
  _endToken(e, r) {
    if (this._currentTokenStart === null)
      throw new Np("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(r));
    if (this._currentTokenType === null)
      throw new Np("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
    let i = { type: this._currentTokenType, parts: e, sourceSpan: (r ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
    return this.tokens.push(i), this._currentTokenStart = null, this._currentTokenType = null, i;
  }
  _createError(e, r) {
    this._isInExpansionForm() && (e += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
    let i = new Np(e, this._currentTokenType, r);
    return this._currentTokenStart = null, this._currentTokenType = null, new _p(i);
  }
  handleError(e) {
    if (e instanceof ig && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), e instanceof _p)
      this.errors.push(e.error);
    else
      throw e;
  }
  _attemptCharCode(e) {
    return this._cursor.peek() === e ? (this._cursor.advance(), !0) : !1;
  }
  _attemptCharCodeCaseInsensitive(e) {
    return DI(this._cursor.peek(), e) ? (this._cursor.advance(), !0) : !1;
  }
  _requireCharCode(e) {
    let r = this._cursor.clone();
    if (!this._attemptCharCode(e))
      throw this._createError(ea(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptStr(e) {
    let r = e.length;
    if (this._cursor.charsLeft() < r)
      return !1;
    let i = this._cursor.clone();
    for (let n = 0; n < r; n++)
      if (!this._attemptCharCode(e.charCodeAt(n)))
        return this._cursor = i, !1;
    return !0;
  }
  _attemptStrCaseInsensitive(e) {
    for (let r = 0; r < e.length; r++)
      if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(r)))
        return !1;
    return !0;
  }
  _requireStr(e) {
    let r = this._cursor.clone();
    if (!this._attemptStr(e))
      throw this._createError(ea(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _requireStrCaseInsensitive(e) {
    let r = this._cursor.clone();
    if (!this._attemptStrCaseInsensitive(e))
      throw this._createError(ea(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptCharCodeUntilFn(e) {
    for (; !e(this._cursor.peek()); )
      this._cursor.advance();
  }
  _requireCharCodeUntilFn(e, r) {
    let i = this._cursor.clone();
    if (this._attemptCharCodeUntilFn(e), this._cursor.diff(i) < r)
      throw this._createError(ea(this._cursor.peek()), this._cursor.getSpan(i));
  }
  _attemptUntilChar(e) {
    for (; this._cursor.peek() !== e; )
      this._cursor.advance();
  }
  _readChar() {
    let e = String.fromCodePoint(this._cursor.peek());
    return this._cursor.advance(), e;
  }
  _consumeEntity(e) {
    this._beginToken(9);
    let r = this._cursor.clone();
    if (this._cursor.advance(), this._attemptCharCode(35)) {
      let i = this._attemptCharCode(120) || this._attemptCharCode(88), n = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(OI), this._cursor.peek() != 59) {
        this._cursor.advance();
        let a = i ? kc.HEX : kc.DEC;
        throw this._createError(mI(a, this._cursor.getChars(r)), this._cursor.getSpan());
      }
      let s = this._cursor.getChars(n);
      this._cursor.advance();
      try {
        let a = parseInt(s, i ? 16 : 10);
        this._endToken([String.fromCharCode(a), this._cursor.getChars(r)]);
      } catch {
        throw this._createError(rO(this._cursor.getChars(r)), this._cursor.getSpan());
      }
    } else {
      let i = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(xI), this._cursor.peek() != 59)
        this._beginToken(e, r), this._cursor = i, this._endToken(["&"]);
      else {
        let n = this._cursor.getChars(i);
        this._cursor.advance();
        let s = Ec[n];
        if (!s)
          throw this._createError(rO(n), this._cursor.getSpan(r));
        this._endToken([s, `&${n};`]);
      }
    }
  }
  _consumeRawText(e, r) {
    this._beginToken(e ? 6 : 7);
    let i = [];
    for (; ; ) {
      let n = this._cursor.clone(), s = r();
      if (this._cursor = n, s)
        break;
      e && this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(i.join(""))]), i.length = 0, this._consumeEntity(6), this._beginToken(6)) : i.push(this._readChar());
    }
    this._endToken([this._processCarriageReturns(i.join(""))]);
  }
  _consumeComment(e) {
    this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("-->")), this._beginToken(11), this._requireStr("-->"), this._endToken([]);
  }
  _consumeBogusComment(e) {
    this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._cursor.peek() === 62), this._beginToken(11), this._cursor.advance(), this._endToken([]);
  }
  _consumeCdata(e) {
    this._beginToken(12, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]);
  }
  _consumeDocType(e) {
    this._beginToken(18, e), this._endToken([]), this._consumeRawText(!1, () => this._cursor.peek() === 62), this._beginToken(19), this._cursor.advance(), this._endToken([]);
  }
  _consumePrefixAndName() {
    let e = this._cursor.clone(), r = "";
    for (; this._cursor.peek() !== 58 && !yI(this._cursor.peek()); )
      this._cursor.advance();
    let i;
    this._cursor.peek() === 58 ? (r = this._cursor.getChars(e), this._cursor.advance(), i = this._cursor.clone()) : i = e, this._requireCharCodeUntilFn(iO, r === "" ? 0 : 1);
    let n = this._cursor.getChars(i);
    return [r, n];
  }
  _consumeTagOpen(e) {
    let r, i, n, s = [];
    try {
      if (!rg(this._cursor.peek()))
        throw this._createError(ea(this._cursor.peek()), this._cursor.getSpan(e));
      for (n = this._consumeTagOpenStart(e), i = n.parts[0], r = n.parts[1], this._attemptCharCodeUntilFn(Ct); this._cursor.peek() !== 47 && this._cursor.peek() !== 62 && this._cursor.peek() !== 60 && this._cursor.peek() !== 0; ) {
        let [o, u] = this._consumeAttributeName();
        if (this._attemptCharCodeUntilFn(Ct), this._attemptCharCode(61)) {
          this._attemptCharCodeUntilFn(Ct);
          let c = this._consumeAttributeValue();
          s.push({ prefix: o, name: u, value: c });
        } else
          s.push({ prefix: o, name: u });
        this._attemptCharCodeUntilFn(Ct);
      }
      this._consumeTagOpenEnd();
    } catch (o) {
      if (o instanceof _p) {
        n ? n.type = 4 : (this._beginToken(5, e), this._endToken(["<"]));
        return;
      }
      throw o;
    }
    if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === 2)
      return;
    let a = this._getTagContentType(r, i, this._fullNameStack.length > 0, s);
    this._handleFullNameStackForTagOpen(i, r), a === ii.RAW_TEXT ? this._consumeRawTextWithTagClose(i, r, !1) : a === ii.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(i, r, !0);
  }
  _consumeRawTextWithTagClose(e, r, i) {
    this._consumeRawText(i, () => !this._attemptCharCode(60) || !this._attemptCharCode(47) || (this._attemptCharCodeUntilFn(Ct), !this._attemptStrCaseInsensitive(e ? `${e}:${r}` : r)) ? !1 : (this._attemptCharCodeUntilFn(Ct), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((n) => n === 62, 3), this._cursor.advance(), this._endToken([e, r]), this._handleFullNameStackForTagClose(e, r);
  }
  _consumeTagOpenStart(e) {
    this._beginToken(0, e);
    let r = this._consumePrefixAndName();
    return this._endToken(r);
  }
  _consumeAttributeName() {
    let e = this._cursor.peek();
    if (e === 39 || e === 34)
      throw this._createError(ea(e), this._cursor.getSpan());
    this._beginToken(14);
    let r = this._consumePrefixAndName();
    return this._endToken(r), r;
  }
  _consumeAttributeValue() {
    let e;
    if (this._cursor.peek() === 39 || this._cursor.peek() === 34) {
      let r = this._cursor.peek();
      this._consumeQuote(r);
      let i = () => this._cursor.peek() === r;
      e = this._consumeWithInterpolation(16, 17, i, i), this._consumeQuote(r);
    } else {
      let r = () => iO(this._cursor.peek());
      e = this._consumeWithInterpolation(16, 17, r, r);
    }
    return e;
  }
  _consumeQuote(e) {
    this._beginToken(15), this._requireCharCode(e), this._endToken([String.fromCodePoint(e)]);
  }
  _consumeTagOpenEnd() {
    let e = this._attemptCharCode(47) ? 2 : 1;
    this._beginToken(e), this._requireCharCode(62), this._endToken([]);
  }
  _consumeTagClose(e) {
    if (this._beginToken(3, e), this._attemptCharCodeUntilFn(Ct), this._allowHtmComponentClosingTags && this._attemptCharCode(47))
      this._attemptCharCodeUntilFn(Ct), this._requireCharCode(62), this._endToken([]);
    else {
      let [r, i] = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(Ct), this._requireCharCode(62), this._endToken([r, i]), this._handleFullNameStackForTagClose(r, i);
    }
  }
  _consumeExpansionFormStart() {
    this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
    let e = this._readUntil(44), r = this._processCarriageReturns(e);
    if (this._i18nNormalizeLineEndingsInICUs)
      this._endToken([r]);
    else {
      let n = this._endToken([e]);
      r !== e && this.nonNormalizedIcuExpressions.push(n);
    }
    this._requireCharCode(44), this._attemptCharCodeUntilFn(Ct), this._beginToken(7);
    let i = this._readUntil(44);
    this._endToken([i]), this._requireCharCode(44), this._attemptCharCodeUntilFn(Ct);
  }
  _consumeExpansionCaseStart() {
    this._beginToken(21);
    let e = this._readUntil(123).trim();
    this._endToken([e]), this._attemptCharCodeUntilFn(Ct), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(Ct), this._expansionCaseStack.push(22);
  }
  _consumeExpansionCaseEnd() {
    this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(Ct), this._expansionCaseStack.pop();
  }
  _consumeExpansionFormEnd() {
    this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
  }
  _consumeWithInterpolation(e, r, i, n) {
    this._beginToken(e);
    let s = [];
    for (; !i(); ) {
      let o = this._cursor.clone();
      this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(s.join(""))], o), s.length = 0, this._consumeInterpolation(r, o, n), this._beginToken(e)) : this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(s.join(""))]), s.length = 0, this._consumeEntity(e), this._beginToken(e)) : s.push(this._readChar());
    }
    this._inInterpolation = !1;
    let a = this._processCarriageReturns(s.join(""));
    return this._endToken([a]), a;
  }
  _consumeInterpolation(e, r, i) {
    let n = [];
    this._beginToken(e, r), n.push(this._interpolationConfig.start);
    let s = this._cursor.clone(), a = null, o = !1;
    for (; this._cursor.peek() !== 0 && (i === null || !i()); ) {
      let u = this._cursor.clone();
      if (this._isTagStart()) {
        this._cursor = u, n.push(this._getProcessedChars(s, u)), this._endToken(n);
        return;
      }
      if (a === null)
        if (this._attemptStr(this._interpolationConfig.end)) {
          n.push(this._getProcessedChars(s, u)), n.push(this._interpolationConfig.end), this._endToken(n);
          return;
        } else
          this._attemptStr("//") && (o = !0);
      let c = this._cursor.peek();
      this._cursor.advance(), c === 92 ? this._cursor.advance() : c === a ? a = null : !o && a === null && W0(c) && (a = c);
    }
    n.push(this._getProcessedChars(s, this._cursor)), this._endToken(n);
  }
  _getProcessedChars(e, r) {
    return this._processCarriageReturns(r.getChars(e));
  }
  _isTextEnd() {
    return !!(this._isTagStart() || this._cursor.peek() === 0 || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === 125 && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._cursor.peek() === 125));
  }
  _isTagStart() {
    if (this._cursor.peek() === 60) {
      let e = this._cursor.clone();
      e.advance();
      let r = e.peek();
      if (97 <= r && r <= 122 || 65 <= r && r <= 90 || r === 47 || r === 33)
        return !0;
    }
    return !1;
  }
  _isBlockStart() {
    if (this._tokenizeBlocks && this._cursor.peek() === 64) {
      let e = this._cursor.clone();
      if (e.advance(), sO(e.peek()))
        return !0;
    }
    return !1;
  }
  _readUntil(e) {
    let r = this._cursor.clone();
    return this._attemptUntilChar(e), this._cursor.getChars(r);
  }
  _isInExpansion() {
    return this._isInExpansionCase() || this._isInExpansionForm();
  }
  _isInExpansionCase() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 22;
  }
  _isInExpansionForm() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 20;
  }
  isExpansionFormStart() {
    if (this._cursor.peek() !== 123)
      return !1;
    if (this._interpolationConfig) {
      let e = this._cursor.clone(), r = this._attemptStr(this._interpolationConfig.start);
      return this._cursor = e, !r;
    }
    return !0;
  }
  _handleFullNameStackForTagOpen(e, r) {
    let i = Ac(e, r);
    (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === i) && this._fullNameStack.push(i);
  }
  _handleFullNameStackForTagClose(e, r) {
    let i = Ac(e, r);
    this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === i && this._fullNameStack.pop();
  }
};
function Ct(t) {
  return !tg(t) || t === 0;
}
function iO(t) {
  return tg(t) || t === 62 || t === 60 || t === 47 || t === 39 || t === 34 || t === 61 || t === 0;
}
function yI(t) {
  return (t < 97 || 122 < t) && (t < 65 || 90 < t) && (t < 48 || t > 57);
}
function OI(t) {
  return t === 59 || t === 0 || !v8(t);
}
function xI(t) {
  return t === 59 || t === 0 || !rg(t);
}
function bI(t) {
  return t !== 125;
}
function DI(t, e) {
  return nO(t) === nO(e);
}
function nO(t) {
  return t >= 97 && t <= 122 ? t - 97 + 65 : t;
}
function sO(t) {
  return rg(t) || VD(t) || t === 95;
}
function aO(t) {
  return t !== 59 && Ct(t);
}
function vI(t) {
  let e = [], r;
  for (let i = 0; i < t.length; i++) {
    let n = t[i];
    r && r.type === 5 && n.type === 5 || r && r.type === 16 && n.type === 16 ? (r.parts[0] += n.parts[0], r.sourceSpan.end = n.sourceSpan.end) : (r = n, e.push(r));
  }
  return e;
}
var r2 = class zd {
  constructor(e, r) {
    if (e instanceof zd) {
      this.file = e.file, this.input = e.input, this.end = e.end;
      let i = e.state;
      this.state = { peek: i.peek, offset: i.offset, line: i.line, column: i.column };
    } else {
      if (!r)
        throw new Error("Programming error: the range argument must be provided with a file argument.");
      this.file = e, this.input = e.content, this.end = r.endPos, this.state = { peek: -1, offset: r.startPos, line: r.startLine, column: r.startCol };
    }
  }
  clone() {
    return new zd(this);
  }
  peek() {
    return this.state.peek;
  }
  charsLeft() {
    return this.end - this.state.offset;
  }
  diff(e) {
    return this.state.offset - e.state.offset;
  }
  advance() {
    this.advanceState(this.state);
  }
  init() {
    this.updatePeek(this.state);
  }
  getSpan(e, r) {
    e = e || this;
    let i = e;
    if (r)
      for (; this.diff(e) > 0 && r.indexOf(e.peek()) !== -1; )
        i === e && (e = e.clone()), e.advance();
    let n = this.locationFromCursor(e), s = this.locationFromCursor(this), a = i !== e ? this.locationFromCursor(i) : n;
    return new Qe(n, s, a);
  }
  getChars(e) {
    return this.input.substring(e.state.offset, this.state.offset);
  }
  charAt(e) {
    return this.input.charCodeAt(e);
  }
  advanceState(e) {
    if (e.offset >= this.end)
      throw this.state = e, new ig('Unexpected character "EOF"', this);
    let r = this.charAt(e.offset);
    r === 10 ? (e.line++, e.column = 0) : YD(r) || e.column++, e.offset++, this.updatePeek(e);
  }
  updatePeek(e) {
    e.peek = e.offset >= this.end ? 0 : this.charAt(e.offset);
  }
  locationFromCursor(e) {
    return new Yd(e.file, e.state.offset, e.state.line, e.state.column);
  }
}, SI = class Gd extends r2 {
  constructor(e, r) {
    e instanceof Gd ? (super(e), this.internalState = { ...e.internalState }) : (super(e, r), this.internalState = this.state);
  }
  advance() {
    this.state = this.internalState, super.advance(), this.processEscapeSequence();
  }
  init() {
    super.init(), this.processEscapeSequence();
  }
  clone() {
    return new Gd(this);
  }
  getChars(e) {
    let r = e.clone(), i = "";
    for (; r.internalState.offset < this.internalState.offset; )
      i += String.fromCodePoint(r.peek()), r.advance();
    return i;
  }
  processEscapeSequence() {
    let e = () => this.internalState.peek;
    if (e() === 92)
      if (this.internalState = { ...this.state }, this.advanceState(this.internalState), e() === 110)
        this.state.peek = 10;
      else if (e() === 114)
        this.state.peek = 13;
      else if (e() === 118)
        this.state.peek = 11;
      else if (e() === 116)
        this.state.peek = 9;
      else if (e() === 98)
        this.state.peek = 8;
      else if (e() === 102)
        this.state.peek = 12;
      else if (e() === 117)
        if (this.advanceState(this.internalState), e() === 123) {
          this.advanceState(this.internalState);
          let r = this.clone(), i = 0;
          for (; e() !== 125; )
            this.advanceState(this.internalState), i++;
          this.state.peek = this.decodeHexDigits(r, i);
        } else {
          let r = this.clone();
          this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 4);
        }
      else if (e() === 120) {
        this.advanceState(this.internalState);
        let r = this.clone();
        this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 2);
      } else if (Z0(e())) {
        let r = "", i = 0, n = this.clone();
        for (; Z0(e()) && i < 3; )
          n = this.clone(), r += String.fromCodePoint(e()), this.advanceState(this.internalState), i++;
        this.state.peek = parseInt(r, 8), this.internalState = n.internalState;
      } else
        YD(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
  }
  decodeHexDigits(e, r) {
    let i = this.input.slice(e.internalState.offset, e.internalState.offset + r), n = parseInt(i, 16);
    if (isNaN(n))
      throw e.state = e.internalState, new ig("Invalid hexadecimal escape sequence", e);
    return n;
  }
}, ig = class {
  constructor(e, r) {
    this.msg = e, this.cursor = r;
  }
}, $r = class i2 extends GD {
  static create(e, r, i) {
    return new i2(e, r, i);
  }
  constructor(e, r, i) {
    super(r, i), this.elementName = e;
  }
}, wI = class {
  constructor(e, r) {
    this.rootNodes = e, this.errors = r;
  }
}, CI = class {
  constructor(e) {
    this.getTagDefinition = e;
  }
  parse(e, r, i, n = !1, s) {
    let a = (O) => (b, ...v) => O(b.toLowerCase(), ...v), o = n ? this.getTagDefinition : a(this.getTagDefinition), u = (O) => o(O).getContentType(), c = n ? s : a(s), h = dI(e, r, s ? (O, b, v, S) => {
      let x = c(O, b, v, S);
      return x !== void 0 ? x : u(O);
    } : u, i), d = i && i.canSelfClose || !1, m = i && i.allowHtmComponentClosingTags || !1, y = new AI(h.tokens, o, d, m, n);
    return y.build(), new wI(y.rootNodes, h.errors.concat(y.errors));
  }
}, AI = class n2 {
  constructor(e, r, i, n, s) {
    this.tokens = e, this.getTagDefinition = r, this.canSelfClose = i, this.allowHtmComponentClosingTags = n, this.isTagNameCaseSensitive = s, this._index = -1, this._containerStack = [], this.rootNodes = [], this.errors = [], this._advance();
  }
  build() {
    for (; this._peek.type !== 30; )
      this._peek.type === 0 || this._peek.type === 4 ? this._consumeStartTag(this._advance()) : this._peek.type === 3 ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === 12 ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === 10 ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6 ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === 20 ? this._consumeExpansion(this._advance()) : this._peek.type === 25 ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === 27 ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === 29 ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === 18 ? this._consumeDocType(this._advance()) : this._advance();
    for (let e of this._containerStack)
      e instanceof Ks && this.errors.push($r.create(e.name, e.sourceSpan, `Unclosed block "${e.name}"`));
  }
  _advance() {
    let e = this._peek;
    return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e;
  }
  _advanceIf(e) {
    return this._peek.type === e ? this._advance() : null;
  }
  _consumeCdata(e) {
    let r = this._advance(), i = this._getText(r), n = this._advanceIf(13);
    this._addToParent(new tI(i, new Qe(e.sourceSpan.start, (n || r).sourceSpan.end), [r]));
  }
  _consumeComment(e) {
    let r = this._advanceIf(7), i = this._advanceIf(11), n = r != null ? r.parts[0].trim() : null, s = new Qe(e.sourceSpan.start, (i || r || e).sourceSpan.end);
    this._addToParent(new sI(n, s));
  }
  _consumeDocType(e) {
    let r = this._advanceIf(7), i = this._advanceIf(19), n = r != null ? r.parts[0].trim() : null, s = new Qe(e.sourceSpan.start, (i || r || e).sourceSpan.end);
    this._addToParent(new aI(n, s));
  }
  _consumeExpansion(e) {
    let r = this._advance(), i = this._advance(), n = [];
    for (; this._peek.type === 21; ) {
      let a = this._parseExpansionCase();
      if (!a)
        return;
      n.push(a);
    }
    if (this._peek.type !== 24) {
      this.errors.push($r.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      return;
    }
    let s = new Qe(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart);
    this._addToParent(new rI(r.parts[0], i.parts[0], n, s, r.sourceSpan)), this._advance();
  }
  _parseExpansionCase() {
    let e = this._advance();
    if (this._peek.type !== 22)
      return this.errors.push($r.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
    let r = this._advance(), i = this._collectExpansionExpTokens(r);
    if (!i)
      return null;
    let n = this._advance();
    i.push({ type: 30, parts: [], sourceSpan: n.sourceSpan });
    let s = new n2(i, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
    if (s.build(), s.errors.length > 0)
      return this.errors = this.errors.concat(s.errors), null;
    let a = new Qe(e.sourceSpan.start, n.sourceSpan.end, e.sourceSpan.fullStart), o = new Qe(r.sourceSpan.start, n.sourceSpan.end, r.sourceSpan.fullStart);
    return new iI(e.parts[0], s.rootNodes, a, e.sourceSpan, o);
  }
  _collectExpansionExpTokens(e) {
    let r = [], i = [22];
    for (; ; ) {
      if ((this._peek.type === 20 || this._peek.type === 22) && i.push(this._peek.type), this._peek.type === 23)
        if (oO(i, 22)) {
          if (i.pop(), i.length === 0)
            return r;
        } else
          return this.errors.push($r.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 24)
        if (oO(i, 20))
          i.pop();
        else
          return this.errors.push($r.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 30)
        return this.errors.push($r.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      r.push(this._advance());
    }
  }
  _getText(e) {
    let r = e.parts[0];
    if (r.length > 0 && r[0] == `
`) {
      let i = this._getClosestParentElement();
      i != null && i.children.length == 0 && this.getTagDefinition(i.name).ignoreFirstLf && (r = r.substring(1));
    }
    return r;
  }
  _consumeText(e) {
    let r = [e], i = e.sourceSpan, n = e.parts[0];
    if (n.length > 0 && n[0] === `
`) {
      let s = this._getContainer();
      s != null && s.children.length === 0 && this.getTagDefinition(s.name).ignoreFirstLf && (n = n.substring(1), r[0] = { type: e.type, sourceSpan: e.sourceSpan, parts: [n] });
    }
    for (; this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9; )
      e = this._advance(), r.push(e), e.type === 8 ? n += e.parts.join("").replace(/&([^;]+);/g, lO) : e.type === 9 ? n += e.parts[0] : n += e.parts.join("");
    if (n.length > 0) {
      let s = e.sourceSpan;
      this._addToParent(new eI(n, new Qe(i.start, s.end, i.fullStart, i.details), r));
    }
  }
  _closeVoidElement() {
    let e = this._getContainer();
    e instanceof bn && this.getTagDefinition(e.name).isVoid && this._containerStack.pop();
  }
  _consumeStartTag(e) {
    let [r, i] = e.parts, n = [];
    for (; this._peek.type === 14; )
      n.push(this._consumeAttr(this._advance()));
    let s = this._getElementFullName(r, i, this._getClosestParentElement()), a = !1;
    if (this._peek.type === 2) {
      this._advance(), a = !0;
      let y = this.getTagDefinition(s);
      this.canSelfClose || y.canSelfClose || ic(s) !== null || y.isVoid || this.errors.push($r.create(s, e.sourceSpan, `Only void, custom and foreign elements can be self closed "${e.parts[1]}"`));
    } else
      this._peek.type === 1 && (this._advance(), a = !1);
    let o = this._peek.sourceSpan.fullStart, u = new Qe(e.sourceSpan.start, o, e.sourceSpan.fullStart), c = new Qe(e.sourceSpan.start, o, e.sourceSpan.fullStart), h = new Qe(e.sourceSpan.start.moveBy(1), e.sourceSpan.end), d = new bn(s, n, [], u, c, void 0, h), m = this._getContainer();
    this._pushContainer(d, m instanceof bn && this.getTagDefinition(m.name).isClosedByChild(d.name)), a ? this._popContainer(s, bn, u) : e.type === 4 && (this._popContainer(s, bn, null), this.errors.push($r.create(s, u, `Opening tag "${s}" not terminated.`)));
  }
  _pushContainer(e, r) {
    r && this._containerStack.pop(), this._addToParent(e), this._containerStack.push(e);
  }
  _consumeEndTag(e) {
    let r = this.allowHtmComponentClosingTags && e.parts.length === 0 ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getClosestParentElement());
    if (r && this.getTagDefinition(r).isVoid)
      this.errors.push($r.create(r, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
    else if (!this._popContainer(r, bn, e.sourceSpan)) {
      let i = `Unexpected closing tag "${r}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
      this.errors.push($r.create(r, e.sourceSpan, i));
    }
  }
  _popContainer(e, r, i) {
    let n = !1;
    for (let s = this._containerStack.length - 1; s >= 0; s--) {
      let a = this._containerStack[s];
      if (ic(a.name) ? a.name === e : (e == null || a.name.toLowerCase() === e.toLowerCase()) && a instanceof r)
        return a.endSourceSpan = i, a.sourceSpan.end = i !== null ? i.end : a.sourceSpan.end, this._containerStack.splice(s, this._containerStack.length - s), !n;
      (a instanceof Ks || a instanceof bn && !this.getTagDefinition(a.name).closedByParent) && (n = !0);
    }
    return !1;
  }
  _consumeAttr(e) {
    let r = Ac(e.parts[0], e.parts[1]), i = e.sourceSpan.end, n;
    this._peek.type === 15 && (n = this._advance());
    let s = "", a = [], o, u;
    if (this._peek.type === 16)
      for (o = this._peek.sourceSpan, u = this._peek.sourceSpan.end; this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9; ) {
        let h = this._advance();
        a.push(h), h.type === 17 ? s += h.parts.join("").replace(/&([^;]+);/g, lO) : h.type === 9 ? s += h.parts[0] : s += h.parts.join(""), u = i = h.sourceSpan.end;
      }
    this._peek.type === 15 && (u = i = this._advance().sourceSpan.end);
    let c = o && u && new Qe((n == null ? void 0 : n.sourceSpan.start) ?? o.start, u, (n == null ? void 0 : n.sourceSpan.fullStart) ?? o.fullStart);
    return new nI(r, s, new Qe(e.sourceSpan.start, i, e.sourceSpan.fullStart), e.sourceSpan, c, a.length > 0 ? a : void 0, void 0);
  }
  _consumeBlockOpen(e) {
    let r = [];
    for (; this._peek.type === 28; ) {
      let o = this._advance();
      r.push(new tO(o.parts[0], o.sourceSpan));
    }
    this._peek.type === 26 && this._advance();
    let i = this._peek.sourceSpan.fullStart, n = new Qe(e.sourceSpan.start, i, e.sourceSpan.fullStart), s = new Qe(e.sourceSpan.start, i, e.sourceSpan.fullStart), a = new Ks(e.parts[0], r, [], n, s);
    this._pushContainer(a, !1);
  }
  _consumeBlockClose(e) {
    this._popContainer(null, Ks, e.sourceSpan) || this.errors.push($r.create(null, e.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
  }
  _consumeIncompleteBlock(e) {
    let r = [];
    for (; this._peek.type === 28; ) {
      let o = this._advance();
      r.push(new tO(o.parts[0], o.sourceSpan));
    }
    let i = this._peek.sourceSpan.fullStart, n = new Qe(e.sourceSpan.start, i, e.sourceSpan.fullStart), s = new Qe(e.sourceSpan.start, i, e.sourceSpan.fullStart), a = new Ks(e.parts[0], r, [], n, s);
    this._pushContainer(a, !1), this._popContainer(null, Ks, null), this.errors.push($r.create(e.parts[0], n, `Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
  }
  _getContainer() {
    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
  }
  _getClosestParentElement() {
    for (let e = this._containerStack.length - 1; e > -1; e--)
      if (this._containerStack[e] instanceof bn)
        return this._containerStack[e];
    return null;
  }
  _addToParent(e) {
    let r = this._getContainer();
    r === null ? this.rootNodes.push(e) : r.children.push(e);
  }
  _getElementFullName(e, r, i) {
    if (e === "" && (e = this.getTagDefinition(r).implicitNamespacePrefix || "", e === "" && i != null)) {
      let n = Qh(i.name)[1];
      this.getTagDefinition(n).preventNamespaceInheritance || (e = ic(i.name));
    }
    return Ac(e, r);
  }
};
function oO(t, e) {
  return t.length > 0 && t[t.length - 1] === e;
}
function lO(t, e) {
  return Ec[e] !== void 0 ? Ec[e] || t : /^#x[a-f0-9]+$/i.test(e) ? String.fromCodePoint(parseInt(e.slice(2), 16)) : /^#\d+$/.test(e) ? String.fromCodePoint(parseInt(e.slice(1), 10)) : t;
}
var EI = class extends CI {
  constructor() {
    super(Ud);
  }
  parse(e, r, i, n = !1, s) {
    return super.parse(e, r, i, n, s);
  }
}, Qp = null, kI = () => (Qp || (Qp = new EI()), Qp);
function uO(t, e = {}) {
  let { canSelfClose: r = !1, allowHtmComponentClosingTags: i = !1, isTagNameCaseSensitive: n = !1, getTagContentType: s, tokenizeAngularBlocks: a = !1 } = e;
  return kI().parse(t, "angular-html-parser", { tokenizeExpansionForms: a, interpolationConfig: void 0, canSelfClose: r, allowHtmComponentClosingTags: i, tokenizeBlocks: a }, n, s);
}
function TI(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var PI = TI, FI = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
function $I(t) {
  let e = t.match(FI);
  if (!e)
    return { content: t };
  let { startDelimiter: r, language: i, value: n = "", endDelimiter: s } = e.groups, a = i.trim() || "yaml";
  if (r === "+++" && (a = "toml"), a !== "yaml" && r !== s)
    return { content: t };
  let [o] = e;
  return { frontMatter: { type: "front-matter", lang: a, value: n, startDelimiter: r, endDelimiter: s, raw: o.replace(/\n$/, "") }, content: wr(!1, o, /[^\n]/g, " ") + t.slice(o.length) };
}
var BI = $I, Du = { attrs: !0, children: !0, cases: !0, expression: !0 }, cO = /* @__PURE__ */ new Set(["parent"]), II = class Fo {
  constructor(e = {}) {
    for (let r of /* @__PURE__ */ new Set([...cO, ...Object.keys(e)]))
      this.setProperty(r, e[r]);
  }
  setProperty(e, r) {
    if (this[e] !== r) {
      if (e in Du && (r = r.map((i) => this.createChild(i))), !cO.has(e)) {
        this[e] = r;
        return;
      }
      Object.defineProperty(this, e, { value: r, enumerable: !1, configurable: !0 });
    }
  }
  map(e) {
    let r;
    for (let i in Du) {
      let n = this[i];
      if (n) {
        let s = NI(n, (a) => a.map(e));
        r !== n && (r || (r = new Fo({ parent: this.parent })), r.setProperty(i, s));
      }
    }
    if (r)
      for (let i in this)
        i in Du || (r[i] = this[i]);
    return e(r || this);
  }
  walk(e) {
    for (let r in Du) {
      let i = this[r];
      if (i)
        for (let n = 0; n < i.length; n++)
          i[n].walk(e);
    }
    e(this);
  }
  createChild(e) {
    let r = e instanceof Fo ? e.clone() : new Fo(e);
    return r.setProperty("parent", this), r;
  }
  insertChildBefore(e, r) {
    this.children.splice(this.children.indexOf(e), 0, this.createChild(r));
  }
  removeChild(e) {
    this.children.splice(this.children.indexOf(e), 1);
  }
  replaceChild(e, r) {
    this.children[this.children.indexOf(e)] = this.createChild(r);
  }
  clone() {
    return new Fo(this);
  }
  get firstChild() {
    var e;
    return (e = this.children) == null ? void 0 : e[0];
  }
  get lastChild() {
    var e;
    return (e = this.children) == null ? void 0 : e[this.children.length - 1];
  }
  get prev() {
    var e, r;
    return (r = (e = this.parent) == null ? void 0 : e.children) == null ? void 0 : r[this.parent.children.indexOf(this) - 1];
  }
  get next() {
    var e, r;
    return (r = (e = this.parent) == null ? void 0 : e.children) == null ? void 0 : r[this.parent.children.indexOf(this) + 1];
  }
  get rawName() {
    return this.hasExplicitNamespace ? this.fullName : this.name;
  }
  get fullName() {
    return this.namespace ? this.namespace + ":" + this.name : this.name;
  }
  get attrMap() {
    return Object.fromEntries(this.attrs.map((e) => [e.fullName, e.value]));
  }
};
function NI(t, e) {
  let r = t.map(e);
  return r.some((i, n) => i !== t[n]) ? r : t;
}
var _I = [{ regex: /^(\[if([^\]]*)]>)(.*?)<!\s*\[endif]$/s, parse: MI }, { regex: /^\[if([^\]]*)]><!$/, parse: LI }, { regex: /^<!\s*\[endif]$/, parse: RI }];
function QI(t, e) {
  if (t.value)
    for (let { regex: r, parse: i } of _I) {
      let n = t.value.match(r);
      if (n)
        return i(t, e, n);
    }
  return null;
}
function MI(t, e, r) {
  let [, i, n, s] = r, a = 4 + i.length, o = t.sourceSpan.start.moveBy(a), u = o.moveBy(s.length), [c, h] = (() => {
    try {
      return [!0, e(s, o).children];
    } catch {
      return [!1, [{ type: "text", value: s, sourceSpan: new Qe(o, u) }]];
    }
  })();
  return { type: "ieConditionalComment", complete: c, children: h, condition: wr(!1, n.trim(), /\s+/g, " "), sourceSpan: t.sourceSpan, startSourceSpan: new Qe(t.sourceSpan.start, o), endSourceSpan: new Qe(u, t.sourceSpan.end) };
}
function LI(t, e, r) {
  let [, i] = r;
  return { type: "ieConditionalStartComment", condition: wr(!1, i.trim(), /\s+/g, " "), sourceSpan: t.sourceSpan };
}
function RI(t) {
  return { type: "ieConditionalEndComment", sourceSpan: t.sourceSpan };
}
var Mp = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set(["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "slot", "spellcheck", "style", "tabindex", "title", "translate"])], ["a", /* @__PURE__ */ new Set(["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"])], ["applet", /* @__PURE__ */ new Set(["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"])], ["area", /* @__PURE__ */ new Set(["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"])], ["audio", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"])], ["base", /* @__PURE__ */ new Set(["href", "target"])], ["basefont", /* @__PURE__ */ new Set(["color", "face", "size"])], ["blockquote", /* @__PURE__ */ new Set(["cite"])], ["body", /* @__PURE__ */ new Set(["alink", "background", "bgcolor", "link", "text", "vlink"])], ["br", /* @__PURE__ */ new Set(["clear"])], ["button", /* @__PURE__ */ new Set(["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "popovertarget", "popovertargetaction", "type", "value"])], ["canvas", /* @__PURE__ */ new Set(["height", "width"])], ["caption", /* @__PURE__ */ new Set(["align"])], ["col", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["colgroup", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["data", /* @__PURE__ */ new Set(["value"])], ["del", /* @__PURE__ */ new Set(["cite", "datetime"])], ["details", /* @__PURE__ */ new Set(["name", "open"])], ["dialog", /* @__PURE__ */ new Set(["open"])], ["dir", /* @__PURE__ */ new Set(["compact"])], ["div", /* @__PURE__ */ new Set(["align"])], ["dl", /* @__PURE__ */ new Set(["compact"])], ["embed", /* @__PURE__ */ new Set(["height", "src", "type", "width"])], ["fieldset", /* @__PURE__ */ new Set(["disabled", "form", "name"])], ["font", /* @__PURE__ */ new Set(["color", "face", "size"])], ["form", /* @__PURE__ */ new Set(["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"])], ["frame", /* @__PURE__ */ new Set(["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"])], ["frameset", /* @__PURE__ */ new Set(["cols", "rows"])], ["h1", /* @__PURE__ */ new Set(["align"])], ["h2", /* @__PURE__ */ new Set(["align"])], ["h3", /* @__PURE__ */ new Set(["align"])], ["h4", /* @__PURE__ */ new Set(["align"])], ["h5", /* @__PURE__ */ new Set(["align"])], ["h6", /* @__PURE__ */ new Set(["align"])], ["head", /* @__PURE__ */ new Set(["profile"])], ["hr", /* @__PURE__ */ new Set(["align", "noshade", "size", "width"])], ["html", /* @__PURE__ */ new Set(["manifest", "version"])], ["iframe", /* @__PURE__ */ new Set(["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"])], ["img", /* @__PURE__ */ new Set(["align", "alt", "border", "crossorigin", "decoding", "fetchpriority", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"])], ["input", /* @__PURE__ */ new Set(["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "popovertarget", "popovertargetaction", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"])], ["ins", /* @__PURE__ */ new Set(["cite", "datetime"])], ["isindex", /* @__PURE__ */ new Set(["prompt"])], ["label", /* @__PURE__ */ new Set(["for", "form"])], ["legend", /* @__PURE__ */ new Set(["align"])], ["li", /* @__PURE__ */ new Set(["type", "value"])], ["link", /* @__PURE__ */ new Set(["as", "blocking", "charset", "color", "crossorigin", "disabled", "fetchpriority", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"])], ["map", /* @__PURE__ */ new Set(["name"])], ["menu", /* @__PURE__ */ new Set(["compact"])], ["meta", /* @__PURE__ */ new Set(["charset", "content", "http-equiv", "media", "name", "scheme"])], ["meter", /* @__PURE__ */ new Set(["high", "low", "max", "min", "optimum", "value"])], ["object", /* @__PURE__ */ new Set(["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"])], ["ol", /* @__PURE__ */ new Set(["compact", "reversed", "start", "type"])], ["optgroup", /* @__PURE__ */ new Set(["disabled", "label"])], ["option", /* @__PURE__ */ new Set(["disabled", "label", "selected", "value"])], ["output", /* @__PURE__ */ new Set(["for", "form", "name"])], ["p", /* @__PURE__ */ new Set(["align"])], ["param", /* @__PURE__ */ new Set(["name", "type", "value", "valuetype"])], ["pre", /* @__PURE__ */ new Set(["width"])], ["progress", /* @__PURE__ */ new Set(["max", "value"])], ["q", /* @__PURE__ */ new Set(["cite"])], ["script", /* @__PURE__ */ new Set(["async", "blocking", "charset", "crossorigin", "defer", "fetchpriority", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"])], ["select", /* @__PURE__ */ new Set(["autocomplete", "disabled", "form", "multiple", "name", "required", "size"])], ["slot", /* @__PURE__ */ new Set(["name"])], ["source", /* @__PURE__ */ new Set(["height", "media", "sizes", "src", "srcset", "type", "width"])], ["style", /* @__PURE__ */ new Set(["blocking", "media", "type"])], ["table", /* @__PURE__ */ new Set(["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"])], ["tbody", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["td", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["template", /* @__PURE__ */ new Set(["shadowrootdelegatesfocus", "shadowrootmode"])], ["textarea", /* @__PURE__ */ new Set(["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"])], ["tfoot", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["th", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["thead", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["time", /* @__PURE__ */ new Set(["datetime"])], ["tr", /* @__PURE__ */ new Set(["align", "bgcolor", "char", "charoff", "valign"])], ["track", /* @__PURE__ */ new Set(["default", "kind", "label", "src", "srclang"])], ["ul", /* @__PURE__ */ new Set(["compact", "type"])], ["video", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"])]]), jI = /* @__PURE__ */ new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
function ZI(t) {
  if (t.type === "block") {
    if (t.name = wr(!1, t.name.toLowerCase(), /\s+/g, " ").trim(), t.type = "angularControlFlowBlock", !Gm(t.parameters)) {
      delete t.parameters;
      return;
    }
    for (let e of t.parameters)
      e.type = "angularControlFlowBlockParameter";
    t.parameters = { type: "angularControlFlowBlockParameters", children: t.parameters, sourceSpan: new Qe(t.parameters[0].sourceSpan.start, $l(!1, t.parameters, -1).sourceSpan.end) };
  }
}
function WI(t) {
  (t.type === "plural" || t.type === "select") && (t.clause = t.type, t.type = "angularIcuExpression"), t.type === "expansionCase" && (t.type = "angularIcuCase");
}
function s2(t, e, r) {
  let { name: i, canSelfClose: n = !0, normalizeTagName: s = !1, normalizeAttributeName: a = !1, allowHtmComponentClosingTags: o = !1, isTagNameCaseSensitive: u = !1, shouldParseAsRawText: c } = e, { rootNodes: h, errors: d } = uO(t, { canSelfClose: n, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u, getTagContentType: c ? (...x) => c(...x) ? ii.RAW_TEXT : void 0 : void 0, tokenizeAngularBlocks: i === "angular" ? !0 : void 0 });
  if (i === "vue") {
    if (h.some((C) => C.type === "docType" && C.value === "html" || C.type === "element" && C.name.toLowerCase() === "html"))
      return s2(t, o2, r);
    let x, w = () => x ?? (x = uO(t, { canSelfClose: n, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u })), k = (C) => w().rootNodes.find(({ startSourceSpan: E }) => E && E.start.offset === C.startSourceSpan.start.offset) ?? C;
    for (let [C, E] of h.entries()) {
      let { endSourceSpan: P, startSourceSpan: I } = E;
      if (P === null)
        d = w().errors, h[C] = k(E);
      else if (qI(E, r)) {
        let B = w().errors.find((Q) => Q.span.start.offset > I.start.offset && Q.span.start.offset < P.end.offset);
        B && hO(B), h[C] = k(E);
      }
    }
  }
  d.length > 0 && hO(d[0]);
  let m = (x) => {
    let w = x.name.startsWith(":") ? x.name.slice(1).split(":")[0] : null, k = x.nameSpan.toString(), C = w !== null && k.startsWith(`${w}:`), E = C ? k.slice(w.length + 1) : k;
    x.name = E, x.namespace = w, x.hasExplicitNamespace = C;
  }, y = (x) => {
    switch (x.type) {
      case "element":
        m(x);
        for (let w of x.attrs)
          m(w), w.valueSpan ? (w.value = w.valueSpan.toString(), /["']/.test(w.value[0]) && (w.value = w.value.slice(1, -1))) : w.value = null;
        break;
      case "comment":
        x.value = x.sourceSpan.toString().slice(4, -3);
        break;
      case "text":
        x.value = x.sourceSpan.toString();
        break;
    }
  }, O = (x, w) => {
    let k = x.toLowerCase();
    return w(k) ? k : x;
  }, b = (x) => {
    if (x.type === "element" && (s && (!x.namespace || x.namespace === x.tagDefinition.implicitNamespacePrefix || il(x)) && (x.name = O(x.name, (w) => jI.has(w))), a))
      for (let w of x.attrs)
        w.namespace || (w.name = O(w.name, (k) => Mp.has(x.name) && (Mp.get("*").has(k) || Mp.get(x.name).has(k))));
  }, v = (x) => {
    x.sourceSpan && x.endSourceSpan && (x.sourceSpan = new Qe(x.sourceSpan.start, x.endSourceSpan.end));
  }, S = (x) => {
    if (x.type === "element") {
      let w = Ud(u ? x.name : x.name.toLowerCase());
      !x.namespace || x.namespace === w.implicitNamespacePrefix || il(x) ? x.tagDefinition = w : x.tagDefinition = Ud("");
    }
  };
  return KD(new class extends oI {
    visitExpansionCase(x, w) {
      i === "angular" && this.visitChildren(w, (k) => {
        k(x.expression);
      });
    }
    visit(x) {
      y(x), S(x), b(x), v(x);
    }
  }(), h), h;
}
function qI(t, e) {
  var r;
  if (t.type !== "element" || t.name !== "template")
    return !1;
  let i = (r = t.attrs.find((n) => n.name === "lang")) == null ? void 0 : r.value;
  return !i || Ph(e, { language: i }) === "html";
}
function hO(t) {
  let { msg: e, span: { start: r, end: i } } = t;
  throw PI(e, { loc: { start: { line: r.line + 1, column: r.col + 1 }, end: { line: i.line + 1, column: i.col + 1 } }, cause: t });
}
function a2(t, e, r = {}, i = !0) {
  let { frontMatter: n, content: s } = i ? BI(t) : { frontMatter: null, content: t }, a = new zD(t, r.filepath), o = new Yd(a, 0, 0, 0), u = o.moveBy(t.length), c = { type: "root", sourceSpan: new Qe(o, u), children: s2(s, e, r) };
  if (n) {
    let m = new Yd(a, 0, 0, 0), y = m.moveBy(n.raw.length);
    n.sourceSpan = new Qe(m, y), c.children.unshift(n);
  }
  let h = new II(c), d = (m, y) => {
    let { offset: O } = y, b = wr(!1, t.slice(0, O), /[^\n\r]/g, " "), v = a2(b + m, e, r, !1);
    v.sourceSpan = new Qe(y, $l(!1, v.children, -1).sourceSpan.end);
    let S = v.children[0];
    return S.length === O ? v.children.shift() : (S.sourceSpan = new Qe(S.sourceSpan.start.moveBy(O), S.sourceSpan.end), S.value = S.value.slice(O)), v;
  };
  return h.walk((m) => {
    if (m.type === "comment") {
      let y = QI(m, d);
      y && m.parent.replaceChild(m, y);
    }
    ZI(m), WI(m);
  }), h;
}
function Mh(t) {
  return { parse: (e, r) => a2(e, t, r), hasPragma: d8, astFormat: "html", locStart: Bh, locEnd: Ih };
}
var o2 = { name: "html", normalizeTagName: !0, normalizeAttributeName: !0, allowHtmComponentClosingTags: !0 }, XI = Mh(o2), VI = Mh({ name: "angular" }), YI = Mh({ name: "vue", isTagNameCaseSensitive: !0, shouldParseAsRawText(t, e, r, i) {
  return t.toLowerCase() !== "html" && !r && (t !== "template" || i.some(({ name: n, value: s }) => n === "lang" && s !== "html" && s !== "" && s !== void 0));
} }), UI = Mh({ name: "lwc", canSelfClose: !1 }), zI = { html: j8 }, GI = yD, HI = Object.create, ng = Object.defineProperty, JI = Object.getOwnPropertyDescriptor, KI = Object.getOwnPropertyNames, e5 = Object.getPrototypeOf, t5 = Object.prototype.hasOwnProperty, re = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), l2 = (t, e) => {
  for (var r in e)
    ng(t, r, { get: e[r], enumerable: !0 });
}, r5 = (t, e, r, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of KI(e))
      !t5.call(t, n) && n !== r && ng(t, n, { get: () => e[n], enumerable: !(i = JI(e, n)) || i.enumerable });
  return t;
}, Ms = (t, e, r) => (r = t != null ? HI(e5(t)) : {}, r5(e || !t || !t.__esModule ? ng(r, "default", { value: t, enumerable: !0 }) : r, t)), i5 = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = h, t.parse = m, t.parseWithComments = y, t.print = O, t.strip = d;
  var e = /\*\/$/, r = /^\/\*\*?/, i = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, n = /(^|\s+)\/\/([^\r\n]*)/g, s = /^(\r?\n)+/, a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, o = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, u = /(\r?\n|^) *\* ?/g, c = [];
  function h(v) {
    let S = v.match(i);
    return S ? S[0].trimLeft() : "";
  }
  function d(v) {
    let S = v.match(i);
    return S && S[0] ? v.substring(S[0].length) : v;
  }
  function m(v) {
    return y(v).pragmas;
  }
  function y(v) {
    let S = `
`;
    v = v.replace(r, "").replace(e, "").replace(u, "$1");
    let x = "";
    for (; x !== v; )
      x = v, v = v.replace(a, `${S}$1 $2${S}`);
    v = v.replace(s, "").trimRight();
    let w = /* @__PURE__ */ Object.create(null), k = v.replace(o, "").replace(s, "").trimRight(), C;
    for (; C = o.exec(v); ) {
      let E = C[2].replace(n, "");
      typeof w[C[1]] == "string" || Array.isArray(w[C[1]]) ? w[C[1]] = c.concat(w[C[1]], E) : w[C[1]] = E;
    }
    return { comments: k, pragmas: w };
  }
  function O({ comments: v = "", pragmas: S = {} }) {
    let x = `
`, w = "/**", k = " *", C = " */", E = Object.keys(S), P = E.flatMap((B) => b(B, S[B])).map((B) => `${k} ${B}${x}`).join("");
    if (!v) {
      if (E.length === 0)
        return "";
      if (E.length === 1 && !Array.isArray(S[E[0]])) {
        let B = S[E[0]];
        return `${w} ${b(E[0], B)[0]}${C}`;
      }
    }
    let I = v.split(x).map((B) => `${k} ${B}`).join(x) + x;
    return w + x + (v ? I : "") + (v && E.length ? k + x : "") + P + C;
  }
  function b(v, S) {
    return c.concat(S).map((x) => `@${v} ${x}`.trim());
  }
}), sg = re((t, e) => {
  e.exports.isClean = Symbol("isClean"), e.exports.my = Symbol("my");
}), n5 = re((t, e) => {
  var r = String, i = function() {
    return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r };
  };
  e.exports = i(), e.exports.createColors = i;
}), u2 = re(() => {
}), ag = re((t, e) => {
  var r = n5(), i = u2(), n = class c2 extends Error {
    constructor(a, o, u, c, h, d) {
      super(a), this.name = "CssSyntaxError", this.reason = a, h && (this.file = h), c && (this.source = c), d && (this.plugin = d), typeof o < "u" && typeof u < "u" && (typeof o == "number" ? (this.line = o, this.column = u) : (this.line = o.line, this.column = o.column, this.endLine = u.line, this.endColumn = u.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, c2);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(a) {
      if (!this.source)
        return "";
      let o = this.source;
      a == null && (a = r.isColorSupported), i && a && (o = i(o));
      let u = o.split(/\r?\n/), c = Math.max(this.line - 3, 0), h = Math.min(this.line + 2, u.length), d = String(h).length, m, y;
      if (a) {
        let { bold: O, gray: b, red: v } = r.createColors(!0);
        m = (S) => O(v(S)), y = (S) => b(S);
      } else
        m = y = (O) => O;
      return u.slice(c, h).map((O, b) => {
        let v = c + 1 + b, S = " " + (" " + v).slice(-d) + " | ";
        if (v === this.line) {
          let x = y(S.replace(/\d/g, " ")) + O.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return m(">") + y(S) + O + `
 ` + x + m("^");
        }
        return " " + y(S) + O;
      }).join(`
`);
    }
    toString() {
      let a = this.showSourceCode();
      return a && (a = `

` + a + `
`), this.name + ": " + this.message + a;
    }
  };
  e.exports = n, n.default = n;
}), og = re((t, e) => {
  var r = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: !1 };
  function i(s) {
    return s[0].toUpperCase() + s.slice(1);
  }
  var n = class {
    constructor(s) {
      this.builder = s;
    }
    atrule(s, a) {
      let o = "@" + s.name, u = s.params ? this.rawValue(s, "params") : "";
      if (typeof s.raws.afterName < "u" ? o += s.raws.afterName : u && (o += " "), s.nodes)
        this.block(s, o + u);
      else {
        let c = (s.raws.between || "") + (a ? ";" : "");
        this.builder(o + u + c, s);
      }
    }
    beforeAfter(s, a) {
      let o;
      s.type === "decl" ? o = this.raw(s, null, "beforeDecl") : s.type === "comment" ? o = this.raw(s, null, "beforeComment") : a === "before" ? o = this.raw(s, null, "beforeRule") : o = this.raw(s, null, "beforeClose");
      let u = s.parent, c = 0;
      for (; u && u.type !== "root"; )
        c += 1, u = u.parent;
      if (o.includes(`
`)) {
        let h = this.raw(s, null, "indent");
        if (h.length)
          for (let d = 0; d < c; d++)
            o += h;
      }
      return o;
    }
    block(s, a) {
      let o = this.raw(s, "between", "beforeOpen");
      this.builder(a + o + "{", s, "start");
      let u;
      s.nodes && s.nodes.length ? (this.body(s), u = this.raw(s, "after")) : u = this.raw(s, "after", "emptyBody"), u && this.builder(u), this.builder("}", s, "end");
    }
    body(s) {
      let a = s.nodes.length - 1;
      for (; a > 0 && s.nodes[a].type === "comment"; )
        a -= 1;
      let o = this.raw(s, "semicolon");
      for (let u = 0; u < s.nodes.length; u++) {
        let c = s.nodes[u], h = this.raw(c, "before");
        h && this.builder(h), this.stringify(c, a !== u || o);
      }
    }
    comment(s) {
      let a = this.raw(s, "left", "commentLeft"), o = this.raw(s, "right", "commentRight");
      this.builder("/*" + a + s.text + o + "*/", s);
    }
    decl(s, a) {
      let o = this.raw(s, "between", "colon"), u = s.prop + o + this.rawValue(s, "value");
      s.important && (u += s.raws.important || " !important"), a && (u += ";"), this.builder(u, s);
    }
    document(s) {
      this.body(s);
    }
    raw(s, a, o) {
      let u;
      if (o || (o = a), a && (u = s.raws[a], typeof u < "u"))
        return u;
      let c = s.parent;
      if (o === "before" && (!c || c.type === "root" && c.first === s || c && c.type === "document"))
        return "";
      if (!c)
        return r[o];
      let h = s.root();
      if (h.rawCache || (h.rawCache = {}), typeof h.rawCache[o] < "u")
        return h.rawCache[o];
      if (o === "before" || o === "after")
        return this.beforeAfter(s, o);
      {
        let d = "raw" + i(o);
        this[d] ? u = this[d](h, s) : h.walk((m) => {
          if (u = m.raws[a], typeof u < "u")
            return !1;
        });
      }
      return typeof u > "u" && (u = r[o]), h.rawCache[o] = u, u;
    }
    rawBeforeClose(s) {
      let a;
      return s.walk((o) => {
        if (o.nodes && o.nodes.length > 0 && typeof o.raws.after < "u")
          return a = o.raws.after, a.includes(`
`) && (a = a.replace(/[^\n]+$/, "")), !1;
      }), a && (a = a.replace(/\S/g, "")), a;
    }
    rawBeforeComment(s, a) {
      let o;
      return s.walkComments((u) => {
        if (typeof u.raws.before < "u")
          return o = u.raws.before, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), !1;
      }), typeof o > "u" ? o = this.raw(a, null, "beforeDecl") : o && (o = o.replace(/\S/g, "")), o;
    }
    rawBeforeDecl(s, a) {
      let o;
      return s.walkDecls((u) => {
        if (typeof u.raws.before < "u")
          return o = u.raws.before, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), !1;
      }), typeof o > "u" ? o = this.raw(a, null, "beforeRule") : o && (o = o.replace(/\S/g, "")), o;
    }
    rawBeforeOpen(s) {
      let a;
      return s.walk((o) => {
        if (o.type !== "decl" && (a = o.raws.between, typeof a < "u"))
          return !1;
      }), a;
    }
    rawBeforeRule(s) {
      let a;
      return s.walk((o) => {
        if (o.nodes && (o.parent !== s || s.first !== o) && typeof o.raws.before < "u")
          return a = o.raws.before, a.includes(`
`) && (a = a.replace(/[^\n]+$/, "")), !1;
      }), a && (a = a.replace(/\S/g, "")), a;
    }
    rawColon(s) {
      let a;
      return s.walkDecls((o) => {
        if (typeof o.raws.between < "u")
          return a = o.raws.between.replace(/[^\s:]/g, ""), !1;
      }), a;
    }
    rawEmptyBody(s) {
      let a;
      return s.walk((o) => {
        if (o.nodes && o.nodes.length === 0 && (a = o.raws.after, typeof a < "u"))
          return !1;
      }), a;
    }
    rawIndent(s) {
      if (s.raws.indent)
        return s.raws.indent;
      let a;
      return s.walk((o) => {
        let u = o.parent;
        if (u && u !== s && u.parent && u.parent === s && typeof o.raws.before < "u") {
          let c = o.raws.before.split(`
`);
          return a = c[c.length - 1], a = a.replace(/\S/g, ""), !1;
        }
      }), a;
    }
    rawSemicolon(s) {
      let a;
      return s.walk((o) => {
        if (o.nodes && o.nodes.length && o.last.type === "decl" && (a = o.raws.semicolon, typeof a < "u"))
          return !1;
      }), a;
    }
    rawValue(s, a) {
      let o = s[a], u = s.raws[a];
      return u && u.value === o ? u.raw : o;
    }
    root(s) {
      this.body(s), s.raws.after && this.builder(s.raws.after);
    }
    rule(s) {
      this.block(s, this.rawValue(s, "selector")), s.raws.ownSemicolon && this.builder(s.raws.ownSemicolon, s, "end");
    }
    stringify(s, a) {
      if (!this[s.type])
        throw new Error("Unknown AST node type " + s.type + ". Maybe you need to change PostCSS stringifier.");
      this[s.type](s, a);
    }
  };
  e.exports = n, n.default = n;
}), Lh = re((t, e) => {
  var r = og();
  function i(n, s) {
    new r(s).stringify(n);
  }
  e.exports = i, i.default = i;
}), Rh = re((t, e) => {
  var { isClean: r, my: i } = sg(), n = ag(), s = og(), a = Lh();
  function o(c, h) {
    let d = new c.constructor();
    for (let m in c) {
      if (!Object.prototype.hasOwnProperty.call(c, m) || m === "proxyCache")
        continue;
      let y = c[m], O = typeof y;
      m === "parent" && O === "object" ? h && (d[m] = h) : m === "source" ? d[m] = y : Array.isArray(y) ? d[m] = y.map((b) => o(b, d)) : (O === "object" && y !== null && (y = o(y)), d[m] = y);
    }
    return d;
  }
  var u = class {
    constructor(c = {}) {
      this.raws = {}, this[r] = !1, this[i] = !0;
      for (let h in c)
        if (h === "nodes") {
          this.nodes = [];
          for (let d of c[h])
            typeof d.clone == "function" ? this.append(d.clone()) : this.append(d);
        } else
          this[h] = c[h];
    }
    addToError(c) {
      if (c.postcssNode = this, c.stack && this.source && /\n\s{4}at /.test(c.stack)) {
        let h = this.source;
        c.stack = c.stack.replace(/\n\s{4}at /, `$&${h.input.from}:${h.start.line}:${h.start.column}$&`);
      }
      return c;
    }
    after(c) {
      return this.parent.insertAfter(this, c), this;
    }
    assign(c = {}) {
      for (let h in c)
        this[h] = c[h];
      return this;
    }
    before(c) {
      return this.parent.insertBefore(this, c), this;
    }
    cleanRaws(c) {
      delete this.raws.before, delete this.raws.after, c || delete this.raws.between;
    }
    clone(c = {}) {
      let h = o(this);
      for (let d in c)
        h[d] = c[d];
      return h;
    }
    cloneAfter(c = {}) {
      let h = this.clone(c);
      return this.parent.insertAfter(this, h), h;
    }
    cloneBefore(c = {}) {
      let h = this.clone(c);
      return this.parent.insertBefore(this, h), h;
    }
    error(c, h = {}) {
      if (this.source) {
        let { end: d, start: m } = this.rangeBy(h);
        return this.source.input.error(c, { column: m.column, line: m.line }, { column: d.column, line: d.line }, h);
      }
      return new n(c);
    }
    getProxyProcessor() {
      return { get(c, h) {
        return h === "proxyOf" ? c : h === "root" ? () => c.root().toProxy() : c[h];
      }, set(c, h, d) {
        return c[h] === d || (c[h] = d, (h === "prop" || h === "value" || h === "name" || h === "params" || h === "important" || h === "text") && c.markDirty()), !0;
      } };
    }
    markDirty() {
      if (this[r]) {
        this[r] = !1;
        let c = this;
        for (; c = c.parent; )
          c[r] = !1;
      }
    }
    next() {
      if (!this.parent)
        return;
      let c = this.parent.index(this);
      return this.parent.nodes[c + 1];
    }
    positionBy(c, h) {
      let d = this.source.start;
      if (c.index)
        d = this.positionInside(c.index, h);
      else if (c.word) {
        h = this.toString();
        let m = h.indexOf(c.word);
        m !== -1 && (d = this.positionInside(m, h));
      }
      return d;
    }
    positionInside(c, h) {
      let d = h || this.toString(), m = this.source.start.column, y = this.source.start.line;
      for (let O = 0; O < c; O++)
        d[O] === `
` ? (m = 1, y += 1) : m += 1;
      return { column: m, line: y };
    }
    prev() {
      if (!this.parent)
        return;
      let c = this.parent.index(this);
      return this.parent.nodes[c - 1];
    }
    rangeBy(c) {
      let h = { column: this.source.start.column, line: this.source.start.line }, d = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: h.column + 1, line: h.line };
      if (c.word) {
        let m = this.toString(), y = m.indexOf(c.word);
        y !== -1 && (h = this.positionInside(y, m), d = this.positionInside(y + c.word.length, m));
      } else
        c.start ? h = { column: c.start.column, line: c.start.line } : c.index && (h = this.positionInside(c.index)), c.end ? d = { column: c.end.column, line: c.end.line } : c.endIndex ? d = this.positionInside(c.endIndex) : c.index && (d = this.positionInside(c.index + 1));
      return (d.line < h.line || d.line === h.line && d.column <= h.column) && (d = { column: h.column + 1, line: h.line }), { end: d, start: h };
    }
    raw(c, h) {
      return new s().raw(this, c, h);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith(...c) {
      if (this.parent) {
        let h = this, d = !1;
        for (let m of c)
          m === this ? d = !0 : d ? (this.parent.insertAfter(h, m), h = m) : this.parent.insertBefore(h, m);
        d || this.remove();
      }
      return this;
    }
    root() {
      let c = this;
      for (; c.parent && c.parent.type !== "document"; )
        c = c.parent;
      return c;
    }
    toJSON(c, h) {
      let d = {}, m = h == null;
      h = h || /* @__PURE__ */ new Map();
      let y = 0;
      for (let O in this) {
        if (!Object.prototype.hasOwnProperty.call(this, O) || O === "parent" || O === "proxyCache")
          continue;
        let b = this[O];
        if (Array.isArray(b))
          d[O] = b.map((v) => typeof v == "object" && v.toJSON ? v.toJSON(null, h) : v);
        else if (typeof b == "object" && b.toJSON)
          d[O] = b.toJSON(null, h);
        else if (O === "source") {
          let v = h.get(b.input);
          v == null && (v = y, h.set(b.input, y), y++), d[O] = { end: b.end, inputId: v, start: b.start };
        } else
          d[O] = b;
      }
      return m && (d.inputs = [...h.keys()].map((O) => O.toJSON())), d;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(c = a) {
      c.stringify && (c = c.stringify);
      let h = "";
      return c(this, (d) => {
        h += d;
      }), h;
    }
    warn(c, h, d) {
      let m = { node: this };
      for (let y in d)
        m[y] = d[y];
      return c.warn(h, m);
    }
    get proxyOf() {
      return this;
    }
  };
  e.exports = u, u.default = u;
}), jh = re((t, e) => {
  var r = Rh(), i = class extends r {
    constructor(n) {
      n && typeof n.value < "u" && typeof n.value != "string" && (n = { ...n, value: String(n.value) }), super(n), this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
  };
  e.exports = i, i.default = i;
}), Ql = re((t, e) => {
  var r = Rh(), i = class extends r {
    constructor(n) {
      super(n), this.type = "comment";
    }
  };
  e.exports = i, i.default = i;
}), Ls = re((t, e) => {
  var { isClean: r, my: i } = sg(), n = jh(), s = Ql(), a = Rh(), o, u, c, h;
  function d(O) {
    return O.map((b) => (b.nodes && (b.nodes = d(b.nodes)), delete b.source, b));
  }
  function m(O) {
    if (O[r] = !1, O.proxyOf.nodes)
      for (let b of O.proxyOf.nodes)
        m(b);
  }
  var y = class h2 extends a {
    append(...b) {
      for (let v of b) {
        let S = this.normalize(v, this.last);
        for (let x of S)
          this.proxyOf.nodes.push(x);
      }
      return this.markDirty(), this;
    }
    cleanRaws(b) {
      if (super.cleanRaws(b), this.nodes)
        for (let v of this.nodes)
          v.cleanRaws(b);
    }
    each(b) {
      if (!this.proxyOf.nodes)
        return;
      let v = this.getIterator(), S, x;
      for (; this.indexes[v] < this.proxyOf.nodes.length && (S = this.indexes[v], x = b(this.proxyOf.nodes[S], S), x !== !1); )
        this.indexes[v] += 1;
      return delete this.indexes[v], x;
    }
    every(b) {
      return this.nodes.every(b);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let b = this.lastEach;
      return this.indexes[b] = 0, b;
    }
    getProxyProcessor() {
      return { get(b, v) {
        return v === "proxyOf" ? b : b[v] ? v === "each" || typeof v == "string" && v.startsWith("walk") ? (...S) => b[v](...S.map((x) => typeof x == "function" ? (w, k) => x(w.toProxy(), k) : x)) : v === "every" || v === "some" ? (S) => b[v]((x, ...w) => S(x.toProxy(), ...w)) : v === "root" ? () => b.root().toProxy() : v === "nodes" ? b.nodes.map((S) => S.toProxy()) : v === "first" || v === "last" ? b[v].toProxy() : b[v] : b[v];
      }, set(b, v, S) {
        return b[v] === S || (b[v] = S, (v === "name" || v === "params" || v === "selector") && b.markDirty()), !0;
      } };
    }
    index(b) {
      return typeof b == "number" ? b : (b.proxyOf && (b = b.proxyOf), this.proxyOf.nodes.indexOf(b));
    }
    insertAfter(b, v) {
      let S = this.index(b), x = this.normalize(v, this.proxyOf.nodes[S]).reverse();
      S = this.index(b);
      for (let k of x)
        this.proxyOf.nodes.splice(S + 1, 0, k);
      let w;
      for (let k in this.indexes)
        w = this.indexes[k], S < w && (this.indexes[k] = w + x.length);
      return this.markDirty(), this;
    }
    insertBefore(b, v) {
      let S = this.index(b), x = S === 0 ? "prepend" : !1, w = this.normalize(v, this.proxyOf.nodes[S], x).reverse();
      S = this.index(b);
      for (let C of w)
        this.proxyOf.nodes.splice(S, 0, C);
      let k;
      for (let C in this.indexes)
        k = this.indexes[C], S <= k && (this.indexes[C] = k + w.length);
      return this.markDirty(), this;
    }
    normalize(b, v) {
      if (typeof b == "string")
        b = d(o(b).nodes);
      else if (Array.isArray(b)) {
        b = b.slice(0);
        for (let S of b)
          S.parent && S.parent.removeChild(S, "ignore");
      } else if (b.type === "root" && this.type !== "document") {
        b = b.nodes.slice(0);
        for (let S of b)
          S.parent && S.parent.removeChild(S, "ignore");
      } else if (b.type)
        b = [b];
      else if (b.prop) {
        if (typeof b.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof b.value != "string" && (b.value = String(b.value)), b = [new n(b)];
      } else if (b.selector)
        b = [new u(b)];
      else if (b.name)
        b = [new c(b)];
      else if (b.text)
        b = [new s(b)];
      else
        throw new Error("Unknown node type in node creation");
      return b.map((S) => (S[i] || h2.rebuild(S), S = S.proxyOf, S.parent && S.parent.removeChild(S), S[r] && m(S), typeof S.raws.before > "u" && v && typeof v.raws.before < "u" && (S.raws.before = v.raws.before.replace(/\S/g, "")), S.parent = this.proxyOf, S));
    }
    prepend(...b) {
      b = b.reverse();
      for (let v of b) {
        let S = this.normalize(v, this.first, "prepend").reverse();
        for (let x of S)
          this.proxyOf.nodes.unshift(x);
        for (let x in this.indexes)
          this.indexes[x] = this.indexes[x] + S.length;
      }
      return this.markDirty(), this;
    }
    push(b) {
      return b.parent = this, this.proxyOf.nodes.push(b), this;
    }
    removeAll() {
      for (let b of this.proxyOf.nodes)
        b.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(b) {
      b = this.index(b), this.proxyOf.nodes[b].parent = void 0, this.proxyOf.nodes.splice(b, 1);
      let v;
      for (let S in this.indexes)
        v = this.indexes[S], v >= b && (this.indexes[S] = v - 1);
      return this.markDirty(), this;
    }
    replaceValues(b, v, S) {
      return S || (S = v, v = {}), this.walkDecls((x) => {
        v.props && !v.props.includes(x.prop) || v.fast && !x.value.includes(v.fast) || (x.value = x.value.replace(b, S));
      }), this.markDirty(), this;
    }
    some(b) {
      return this.nodes.some(b);
    }
    walk(b) {
      return this.each((v, S) => {
        let x;
        try {
          x = b(v, S);
        } catch (w) {
          throw v.addToError(w);
        }
        return x !== !1 && v.walk && (x = v.walk(b)), x;
      });
    }
    walkAtRules(b, v) {
      return v ? b instanceof RegExp ? this.walk((S, x) => {
        if (S.type === "atrule" && b.test(S.name))
          return v(S, x);
      }) : this.walk((S, x) => {
        if (S.type === "atrule" && S.name === b)
          return v(S, x);
      }) : (v = b, this.walk((S, x) => {
        if (S.type === "atrule")
          return v(S, x);
      }));
    }
    walkComments(b) {
      return this.walk((v, S) => {
        if (v.type === "comment")
          return b(v, S);
      });
    }
    walkDecls(b, v) {
      return v ? b instanceof RegExp ? this.walk((S, x) => {
        if (S.type === "decl" && b.test(S.prop))
          return v(S, x);
      }) : this.walk((S, x) => {
        if (S.type === "decl" && S.prop === b)
          return v(S, x);
      }) : (v = b, this.walk((S, x) => {
        if (S.type === "decl")
          return v(S, x);
      }));
    }
    walkRules(b, v) {
      return v ? b instanceof RegExp ? this.walk((S, x) => {
        if (S.type === "rule" && b.test(S.selector))
          return v(S, x);
      }) : this.walk((S, x) => {
        if (S.type === "rule" && S.selector === b)
          return v(S, x);
      }) : (v = b, this.walk((S, x) => {
        if (S.type === "rule")
          return v(S, x);
      }));
    }
    get first() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
  };
  y.registerParse = (O) => {
    o = O;
  }, y.registerRule = (O) => {
    u = O;
  }, y.registerAtRule = (O) => {
    c = O;
  }, y.registerRoot = (O) => {
    h = O;
  }, e.exports = y, y.default = y, y.rebuild = (O) => {
    O.type === "atrule" ? Object.setPrototypeOf(O, c.prototype) : O.type === "rule" ? Object.setPrototypeOf(O, u.prototype) : O.type === "decl" ? Object.setPrototypeOf(O, n.prototype) : O.type === "comment" ? Object.setPrototypeOf(O, s.prototype) : O.type === "root" && Object.setPrototypeOf(O, h.prototype), O[i] = !0, O.nodes && O.nodes.forEach((b) => {
      y.rebuild(b);
    });
  };
}), lg = re((t, e) => {
  var r = /[\t\n\f\r "#'()/;[\\\]{}]/g, i = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, n = /.[\r\n"'(/\\]/, s = /[\da-f]/i;
  e.exports = function(a, o = {}) {
    let u = a.css.valueOf(), c = o.ignoreErrors, h, d, m, y, O, b, v, S, x, w, k = u.length, C = 0, E = [], P = [];
    function I() {
      return C;
    }
    function B(J) {
      throw a.error("Unclosed " + J, C);
    }
    function Q() {
      return P.length === 0 && C >= k;
    }
    function j(J) {
      if (P.length)
        return P.pop();
      if (C >= k)
        return;
      let L = J ? J.ignoreUnclosed : !1;
      switch (h = u.charCodeAt(C), h) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12: {
          d = C;
          do
            d += 1, h = u.charCodeAt(d);
          while (h === 32 || h === 10 || h === 9 || h === 13 || h === 12);
          w = ["space", u.slice(C, d)], C = d - 1;
          break;
        }
        case 91:
        case 93:
        case 123:
        case 125:
        case 58:
        case 59:
        case 41: {
          let q = String.fromCharCode(h);
          w = [q, q, C];
          break;
        }
        case 40: {
          if (S = E.length ? E.pop()[1] : "", x = u.charCodeAt(C + 1), S === "url" && x !== 39 && x !== 34 && x !== 32 && x !== 10 && x !== 9 && x !== 12 && x !== 13) {
            d = C;
            do {
              if (b = !1, d = u.indexOf(")", d + 1), d === -1)
                if (c || L) {
                  d = C;
                  break;
                } else
                  B("bracket");
              for (v = d; u.charCodeAt(v - 1) === 92; )
                v -= 1, b = !b;
            } while (b);
            w = ["brackets", u.slice(C, d + 1), C, d], C = d;
          } else
            d = u.indexOf(")", C + 1), y = u.slice(C, d + 1), d === -1 || n.test(y) ? w = ["(", "(", C] : (w = ["brackets", y, C, d], C = d);
          break;
        }
        case 39:
        case 34: {
          m = h === 39 ? "'" : '"', d = C;
          do {
            if (b = !1, d = u.indexOf(m, d + 1), d === -1)
              if (c || L) {
                d = C + 1;
                break;
              } else
                B("string");
            for (v = d; u.charCodeAt(v - 1) === 92; )
              v -= 1, b = !b;
          } while (b);
          w = ["string", u.slice(C, d + 1), C, d], C = d;
          break;
        }
        case 64: {
          r.lastIndex = C + 1, r.test(u), r.lastIndex === 0 ? d = u.length - 1 : d = r.lastIndex - 2, w = ["at-word", u.slice(C, d + 1), C, d], C = d;
          break;
        }
        case 92: {
          for (d = C, O = !0; u.charCodeAt(d + 1) === 92; )
            d += 1, O = !O;
          if (h = u.charCodeAt(d + 1), O && h !== 47 && h !== 32 && h !== 10 && h !== 9 && h !== 13 && h !== 12 && (d += 1, s.test(u.charAt(d)))) {
            for (; s.test(u.charAt(d + 1)); )
              d += 1;
            u.charCodeAt(d + 1) === 32 && (d += 1);
          }
          w = ["word", u.slice(C, d + 1), C, d], C = d;
          break;
        }
        default: {
          h === 47 && u.charCodeAt(C + 1) === 42 ? (d = u.indexOf("*/", C + 2) + 1, d === 0 && (c || L ? d = u.length : B("comment")), w = ["comment", u.slice(C, d + 1), C, d], C = d) : (i.lastIndex = C + 1, i.test(u), i.lastIndex === 0 ? d = u.length - 1 : d = i.lastIndex - 2, w = ["word", u.slice(C, d + 1), C, d], E.push(w), C = d);
          break;
        }
      }
      return C++, w;
    }
    function G(J) {
      P.push(J);
    }
    return { back: G, endOfFile: Q, nextToken: j, position: I };
  };
}), ug = re((t, e) => {
  var r = Ls(), i = class extends r {
    constructor(n) {
      super(n), this.type = "atrule";
    }
    append(...n) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...n);
    }
    prepend(...n) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...n);
    }
  };
  e.exports = i, i.default = i, r.registerAtRule(i);
}), Ml = re((t, e) => {
  var r = Ls(), i, n, s = class extends r {
    constructor(a) {
      super(a), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(a, o, u) {
      let c = super.normalize(a);
      if (o) {
        if (u === "prepend")
          this.nodes.length > 1 ? o.raws.before = this.nodes[1].raws.before : delete o.raws.before;
        else if (this.first !== o)
          for (let h of c)
            h.raws.before = o.raws.before;
      }
      return c;
    }
    removeChild(a, o) {
      let u = this.index(a);
      return !o && u === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[u].raws.before), super.removeChild(a);
    }
    toResult(a = {}) {
      return new i(new n(), this, a).stringify();
    }
  };
  s.registerLazyResult = (a) => {
    i = a;
  }, s.registerProcessor = (a) => {
    n = a;
  }, e.exports = s, s.default = s, r.registerRoot(s);
}), p2 = re((t, e) => {
  var r = { comma(i) {
    return r.split(i, [","], !0);
  }, space(i) {
    let n = [" ", `
`, "	"];
    return r.split(i, n);
  }, split(i, n, s) {
    let a = [], o = "", u = !1, c = 0, h = !1, d = "", m = !1;
    for (let y of i)
      m ? m = !1 : y === "\\" ? m = !0 : h ? y === d && (h = !1) : y === '"' || y === "'" ? (h = !0, d = y) : y === "(" ? c += 1 : y === ")" ? c > 0 && (c -= 1) : c === 0 && n.includes(y) && (u = !0), u ? (o !== "" && a.push(o.trim()), o = "", u = !1) : o += y;
    return (s || o !== "") && a.push(o.trim()), a;
  } };
  e.exports = r, r.default = r;
}), cg = re((t, e) => {
  var r = Ls(), i = p2(), n = class extends r {
    constructor(s) {
      super(s), this.type = "rule", this.nodes || (this.nodes = []);
    }
    get selectors() {
      return i.comma(this.selector);
    }
    set selectors(s) {
      let a = this.selector ? this.selector.match(/,\s*/) : null, o = a ? a[0] : "," + this.raw("between", "beforeOpen");
      this.selector = s.join(o);
    }
  };
  e.exports = n, n.default = n, r.registerRule(n);
}), hg = re((t, e) => {
  var r = jh(), i = lg(), n = Ql(), s = ug(), a = Ml(), o = cg(), u = { empty: !0, space: !0 };
  function c(d) {
    for (let m = d.length - 1; m >= 0; m--) {
      let y = d[m], O = y[3] || y[2];
      if (O)
        return O;
    }
  }
  var h = class {
    constructor(d) {
      this.input = d, this.root = new a(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.customProperty = !1, this.createTokenizer(), this.root.source = { input: d, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(d) {
      let m = new s();
      m.name = d[1].slice(1), m.name === "" && this.unnamedAtrule(m, d), this.init(m, d[2]);
      let y, O, b, v = !1, S = !1, x = [], w = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (d = this.tokenizer.nextToken(), y = d[0], y === "(" || y === "[" ? w.push(y === "(" ? ")" : "]") : y === "{" && w.length > 0 ? w.push("}") : y === w[w.length - 1] && w.pop(), w.length === 0)
          if (y === ";") {
            m.source.end = this.getPosition(d[2]), m.source.end.offset++, this.semicolon = !0;
            break;
          } else if (y === "{") {
            S = !0;
            break;
          } else if (y === "}") {
            if (x.length > 0) {
              for (b = x.length - 1, O = x[b]; O && O[0] === "space"; )
                O = x[--b];
              O && (m.source.end = this.getPosition(O[3] || O[2]), m.source.end.offset++);
            }
            this.end(d);
            break;
          } else
            x.push(d);
        else
          x.push(d);
        if (this.tokenizer.endOfFile()) {
          v = !0;
          break;
        }
      }
      m.raws.between = this.spacesAndCommentsFromEnd(x), x.length ? (m.raws.afterName = this.spacesAndCommentsFromStart(x), this.raw(m, "params", x), v && (d = x[x.length - 1], m.source.end = this.getPosition(d[3] || d[2]), m.source.end.offset++, this.spaces = m.raws.between, m.raws.between = "")) : (m.raws.afterName = "", m.params = ""), S && (m.nodes = [], this.current = m);
    }
    checkMissedSemicolon(d) {
      let m = this.colon(d);
      if (m === !1)
        return;
      let y = 0, O;
      for (let b = m - 1; b >= 0 && (O = d[b], !(O[0] !== "space" && (y += 1, y === 2))); b--)
        ;
      throw this.input.error("Missed semicolon", O[0] === "word" ? O[3] + 1 : O[2]);
    }
    colon(d) {
      let m = 0, y, O, b;
      for (let [v, S] of d.entries()) {
        if (y = S, O = y[0], O === "(" && (m += 1), O === ")" && (m -= 1), m === 0 && O === ":")
          if (!b)
            this.doubleColon(y);
          else {
            if (b[0] === "word" && b[1] === "progid")
              continue;
            return v;
          }
        b = y;
      }
      return !1;
    }
    comment(d) {
      let m = new n();
      this.init(m, d[2]), m.source.end = this.getPosition(d[3] || d[2]), m.source.end.offset++;
      let y = d[1].slice(2, -2);
      if (/^\s*$/.test(y))
        m.text = "", m.raws.left = y, m.raws.right = "";
      else {
        let O = y.match(/^(\s*)([^]*\S)(\s*)$/);
        m.text = O[2], m.raws.left = O[1], m.raws.right = O[3];
      }
    }
    createTokenizer() {
      this.tokenizer = i(this.input);
    }
    decl(d, m) {
      let y = new r();
      this.init(y, d[0][2]);
      let O = d[d.length - 1];
      for (O[0] === ";" && (this.semicolon = !0, d.pop()), y.source.end = this.getPosition(O[3] || O[2] || c(d)), y.source.end.offset++; d[0][0] !== "word"; )
        d.length === 1 && this.unknownWord(d), y.raws.before += d.shift()[1];
      for (y.source.start = this.getPosition(d[0][2]), y.prop = ""; d.length; ) {
        let x = d[0][0];
        if (x === ":" || x === "space" || x === "comment")
          break;
        y.prop += d.shift()[1];
      }
      y.raws.between = "";
      let b;
      for (; d.length; )
        if (b = d.shift(), b[0] === ":") {
          y.raws.between += b[1];
          break;
        } else
          b[0] === "word" && /\w/.test(b[1]) && this.unknownWord([b]), y.raws.between += b[1];
      (y.prop[0] === "_" || y.prop[0] === "*") && (y.raws.before += y.prop[0], y.prop = y.prop.slice(1));
      let v = [], S;
      for (; d.length && (S = d[0][0], !(S !== "space" && S !== "comment")); )
        v.push(d.shift());
      this.precheckMissedSemicolon(d);
      for (let x = d.length - 1; x >= 0; x--) {
        if (b = d[x], b[1].toLowerCase() === "!important") {
          y.important = !0;
          let w = this.stringFrom(d, x);
          w = this.spacesFromEnd(d) + w, w !== " !important" && (y.raws.important = w);
          break;
        } else if (b[1].toLowerCase() === "important") {
          let w = d.slice(0), k = "";
          for (let C = x; C > 0; C--) {
            let E = w[C][0];
            if (k.trim().indexOf("!") === 0 && E !== "space")
              break;
            k = w.pop()[1] + k;
          }
          k.trim().indexOf("!") === 0 && (y.important = !0, y.raws.important = k, d = w);
        }
        if (b[0] !== "space" && b[0] !== "comment")
          break;
      }
      d.some((x) => x[0] !== "space" && x[0] !== "comment") && (y.raws.between += v.map((x) => x[1]).join(""), v = []), this.raw(y, "value", v.concat(d), m), y.value.includes(":") && !m && this.checkMissedSemicolon(d);
    }
    doubleColon(d) {
      throw this.input.error("Double colon", { offset: d[2] }, { offset: d[2] + d[1].length });
    }
    emptyRule(d) {
      let m = new o();
      this.init(m, d[2]), m.selector = "", m.raws.between = "", this.current = m;
    }
    end(d) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(d[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(d);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(d) {
      if (this.spaces += d[1], this.current.nodes) {
        let m = this.current.nodes[this.current.nodes.length - 1];
        m && m.type === "rule" && !m.raws.ownSemicolon && (m.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }
    getPosition(d) {
      let m = this.input.fromOffset(d);
      return { column: m.col, line: m.line, offset: d };
    }
    init(d, m) {
      this.current.push(d), d.source = { input: this.input, start: this.getPosition(m) }, d.raws.before = this.spaces, this.spaces = "", d.type !== "comment" && (this.semicolon = !1);
    }
    other(d) {
      let m = !1, y = null, O = !1, b = null, v = [], S = d[1].startsWith("--"), x = [], w = d;
      for (; w; ) {
        if (y = w[0], x.push(w), y === "(" || y === "[")
          b || (b = w), v.push(y === "(" ? ")" : "]");
        else if (S && O && y === "{")
          b || (b = w), v.push("}");
        else if (v.length === 0)
          if (y === ";")
            if (O) {
              this.decl(x, S);
              return;
            } else
              break;
          else if (y === "{") {
            this.rule(x);
            return;
          } else if (y === "}") {
            this.tokenizer.back(x.pop()), m = !0;
            break;
          } else
            y === ":" && (O = !0);
        else
          y === v[v.length - 1] && (v.pop(), v.length === 0 && (b = null));
        w = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (m = !0), v.length > 0 && this.unclosedBracket(b), m && O) {
        if (!S)
          for (; x.length && (w = x[x.length - 1][0], !(w !== "space" && w !== "comment")); )
            this.tokenizer.back(x.pop());
        this.decl(x, S);
      } else
        this.unknownWord(x);
    }
    parse() {
      let d;
      for (; !this.tokenizer.endOfFile(); )
        switch (d = this.tokenizer.nextToken(), d[0]) {
          case "space":
            this.spaces += d[1];
            break;
          case ";":
            this.freeSemicolon(d);
            break;
          case "}":
            this.end(d);
            break;
          case "comment":
            this.comment(d);
            break;
          case "at-word":
            this.atrule(d);
            break;
          case "{":
            this.emptyRule(d);
            break;
          default:
            this.other(d);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(d, m, y, O) {
      let b, v, S = y.length, x = "", w = !0, k, C;
      for (let E = 0; E < S; E += 1)
        b = y[E], v = b[0], v === "space" && E === S - 1 && !O ? w = !1 : v === "comment" ? (C = y[E - 1] ? y[E - 1][0] : "empty", k = y[E + 1] ? y[E + 1][0] : "empty", !u[C] && !u[k] ? x.slice(-1) === "," ? w = !1 : x += b[1] : w = !1) : x += b[1];
      if (!w) {
        let E = y.reduce((P, I) => P + I[1], "");
        d.raws[m] = { raw: E, value: x };
      }
      d[m] = x;
    }
    rule(d) {
      d.pop();
      let m = new o();
      this.init(m, d[0][2]), m.raws.between = this.spacesAndCommentsFromEnd(d), this.raw(m, "selector", d), this.current = m;
    }
    spacesAndCommentsFromEnd(d) {
      let m, y = "";
      for (; d.length && (m = d[d.length - 1][0], !(m !== "space" && m !== "comment")); )
        y = d.pop()[1] + y;
      return y;
    }
    spacesAndCommentsFromStart(d) {
      let m, y = "";
      for (; d.length && (m = d[0][0], !(m !== "space" && m !== "comment")); )
        y += d.shift()[1];
      return y;
    }
    spacesFromEnd(d) {
      let m, y = "";
      for (; d.length && (m = d[d.length - 1][0], m === "space"); )
        y = d.pop()[1] + y;
      return y;
    }
    stringFrom(d, m) {
      let y = "";
      for (let O = m; O < d.length; O++)
        y += d[O][1];
      return d.splice(m, d.length - m), y;
    }
    unclosedBlock() {
      let d = this.current.source.start;
      throw this.input.error("Unclosed block", d.line, d.column);
    }
    unclosedBracket(d) {
      throw this.input.error("Unclosed bracket", { offset: d[2] }, { offset: d[2] + 1 });
    }
    unexpectedClose(d) {
      throw this.input.error("Unexpected }", { offset: d[2] }, { offset: d[2] + 1 });
    }
    unknownWord(d) {
      throw this.input.error("Unknown word", { offset: d[0][2] }, { offset: d[0][2] + d[0][1].length });
    }
    unnamedAtrule(d, m) {
      throw this.input.error("At-rule without name", { offset: m[2] }, { offset: m[2] + m[1].length });
    }
  };
  e.exports = h;
}), s5 = re(() => {
}), a5 = re((t, e) => {
  var r = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", i = (s, a = 21) => (o = a) => {
    let u = "", c = o;
    for (; c--; )
      u += s[Math.random() * s.length | 0];
    return u;
  }, n = (s = 21) => {
    let a = "", o = s;
    for (; o--; )
      a += r[Math.random() * 64 | 0];
    return a;
  };
  e.exports = { nanoid: n, customAlphabet: i };
}), d2 = re((t, e) => {
  e.exports = class {
  };
}), Ll = re((t, e) => {
  var { SourceMapConsumer: r, SourceMapGenerator: i } = s5(), { fileURLToPath: n, pathToFileURL: s } = {}, { isAbsolute: a, resolve: o } = {}, { nanoid: u } = a5(), c = u2(), h = ag(), d = d2(), m = Symbol("fromOffsetCache"), y = !!(r && i), O = !!(o && a), b = class {
    constructor(v, S = {}) {
      if (v === null || typeof v > "u" || typeof v == "object" && !v.toString)
        throw new Error(`PostCSS received ${v} instead of CSS string`);
      if (this.css = v.toString(), this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, S.from && (!O || /^\w+:\/\//.test(S.from) || a(S.from) ? this.file = S.from : this.file = o(S.from)), O && y) {
        let x = new d(this.css, S);
        if (x.text) {
          this.map = x;
          let w = x.consumer().file;
          !this.file && w && (this.file = this.mapResolve(w));
        }
      }
      this.file || (this.id = "<input css " + u(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(v, S, x, w = {}) {
      let k, C, E;
      if (S && typeof S == "object") {
        let I = S, B = x;
        if (typeof I.offset == "number") {
          let Q = this.fromOffset(I.offset);
          S = Q.line, x = Q.col;
        } else
          S = I.line, x = I.column;
        if (typeof B.offset == "number") {
          let Q = this.fromOffset(B.offset);
          C = Q.line, E = Q.col;
        } else
          C = B.line, E = B.column;
      } else if (!x) {
        let I = this.fromOffset(S);
        S = I.line, x = I.col;
      }
      let P = this.origin(S, x, C, E);
      return P ? k = new h(v, P.endLine === void 0 ? P.line : { column: P.column, line: P.line }, P.endLine === void 0 ? P.column : { column: P.endColumn, line: P.endLine }, P.source, P.file, w.plugin) : k = new h(v, C === void 0 ? S : { column: x, line: S }, C === void 0 ? x : { column: E, line: C }, this.css, this.file, w.plugin), k.input = { column: x, endColumn: E, endLine: C, line: S, source: this.css }, this.file && (s && (k.input.url = s(this.file).toString()), k.input.file = this.file), k;
    }
    fromOffset(v) {
      let S, x;
      if (this[m])
        x = this[m];
      else {
        let k = this.css.split(`
`);
        x = new Array(k.length);
        let C = 0;
        for (let E = 0, P = k.length; E < P; E++)
          x[E] = C, C += k[E].length + 1;
        this[m] = x;
      }
      S = x[x.length - 1];
      let w = 0;
      if (v >= S)
        w = x.length - 1;
      else {
        let k = x.length - 2, C;
        for (; w < k; )
          if (C = w + (k - w >> 1), v < x[C])
            k = C - 1;
          else if (v >= x[C + 1])
            w = C + 1;
          else {
            w = C;
            break;
          }
      }
      return { col: v - x[w] + 1, line: w + 1 };
    }
    mapResolve(v) {
      return /^\w+:\/\//.test(v) ? v : o(this.map.consumer().sourceRoot || this.map.root || ".", v);
    }
    origin(v, S, x, w) {
      if (!this.map)
        return !1;
      let k = this.map.consumer(), C = k.originalPositionFor({ column: S, line: v });
      if (!C.source)
        return !1;
      let E;
      typeof x == "number" && (E = k.originalPositionFor({ column: w, line: x }));
      let P;
      a(C.source) ? P = s(C.source) : P = new URL(C.source, this.map.consumer().sourceRoot || s(this.map.mapFile));
      let I = { column: C.column, endColumn: E && E.column, endLine: E && E.line, line: C.line, url: P.toString() };
      if (P.protocol === "file:")
        if (n)
          I.file = n(P);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let B = k.sourceContentFor(C.source);
      return B && (I.source = B), I;
    }
    toJSON() {
      let v = {};
      for (let S of ["hasBOM", "css", "file", "id"])
        this[S] != null && (v[S] = this[S]);
      return this.map && (v.map = { ...this.map }, v.map.consumerCache && (v.map.consumerCache = void 0)), v;
    }
    get from() {
      return this.file || this.id;
    }
  };
  e.exports = b, b.default = b, c && c.registerInput && c.registerInput(b);
}), Zh = re((t, e) => {
  var r = Ls(), i = hg(), n = Ll();
  function s(a, o) {
    let u = new n(a, o), c = new i(u);
    try {
      c.parse();
    } catch (h) {
      throw h;
    }
    return c.root;
  }
  e.exports = s, s.default = s, r.registerParse(s);
}), o5 = re((t, e) => {
  var r = lg(), i = Ll();
  e.exports = { isInlineComment(n) {
    if (n[0] === "word" && n[1].slice(0, 2) === "//") {
      let s = n, a = [], o, u;
      for (; n; ) {
        if (/\r?\n/.test(n[1])) {
          if (/['"].*\r?\n/.test(n[1])) {
            a.push(n[1].substring(0, n[1].indexOf(`
`))), u = n[1].substring(n[1].indexOf(`
`));
            let h = this.input.css.valueOf().substring(this.tokenizer.position());
            u += h, o = n[3] + h.length - u.length;
          } else
            this.tokenizer.back(n);
          break;
        }
        a.push(n[1]), o = n[2], n = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
      }
      let c = ["comment", a.join(""), s[2], o];
      return this.inlineComment(c), u && (this.input = new i(u), this.tokenizer = r(this.input)), !0;
    } else if (n[1] === "/") {
      let s = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
      if (s[0] === "comment" && /^\/\*/.test(s[1]))
        return s[0] = "word", s[1] = s[1].slice(1), n[1] = "//", this.tokenizer.back(s), e.exports.isInlineComment.bind(this)(n);
    }
    return !1;
  } };
}), l5 = re((t, e) => {
  e.exports = { interpolation(r) {
    let i = [r, this.tokenizer.nextToken()], n = ["word", "}"];
    if (i[0][1].length > 1 || i[1][0] !== "{")
      return this.tokenizer.back(i[1]), !1;
    for (r = this.tokenizer.nextToken(); r && n.includes(r[0]); )
      i.push(r), r = this.tokenizer.nextToken();
    let s = i.map((c) => c[1]), [a] = i, o = i.pop(), u = ["word", s.join(""), a[2], o[2]];
    return this.tokenizer.back(r), this.tokenizer.back(u), !0;
  } };
}), u5 = re((t, e) => {
  var r = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, i = /\.[0-9]/, n = (s) => {
    let [, a] = s, [o] = a;
    return (o === "." || o === "#") && r.test(a) === !1 && i.test(a) === !1;
  };
  e.exports = { isMixinToken: n };
}), c5 = re((t, e) => {
  var r = lg(), i = /^url\((.+)\)/;
  e.exports = (n) => {
    let { name: s, params: a = "" } = n;
    if (s === "import" && a.length) {
      n.import = !0;
      let o = r({ css: a });
      for (n.filename = a.replace(i, "$1"); !o.endOfFile(); ) {
        let [u, c] = o.nextToken();
        if (u === "word" && c === "url")
          return;
        if (u === "brackets") {
          n.options = c, n.filename = a.replace(c, "").trim();
          break;
        }
      }
    }
  };
}), h5 = re((t, e) => {
  var r = /:$/, i = /^:(\s+)?/;
  e.exports = (n) => {
    let { name: s, params: a = "" } = n;
    if (n.name.slice(-1) === ":") {
      if (r.test(s)) {
        let [o] = s.match(r);
        n.name = s.replace(o, ""), n.raws.afterName = o + (n.raws.afterName || ""), n.variable = !0, n.value = n.params;
      }
      if (i.test(a)) {
        let [o] = a.match(i);
        n.value = a.replace(o, ""), n.raws.afterName = (n.raws.afterName || "") + o, n.variable = !0;
      }
    }
  };
}), p5 = re((t, e) => {
  var r = Ql(), i = hg(), { isInlineComment: n } = o5(), { interpolation: s } = l5(), { isMixinToken: a } = u5(), o = c5(), u = h5(), c = /(!\s*important)$/i;
  e.exports = class extends i {
    constructor(...h) {
      super(...h), this.lastNode = null;
    }
    atrule(h) {
      s.bind(this)(h) || (super.atrule(h), o(this.lastNode), u(this.lastNode));
    }
    decl(...h) {
      super.decl(...h), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = !0);
    }
    each(h) {
      h[0][1] = ` ${h[0][1]}`;
      let d = h.findIndex((b) => b[0] === "("), m = h.reverse().find((b) => b[0] === ")"), y = h.reverse().indexOf(m), O = h.splice(d, y).map((b) => b[1]).join("");
      for (let b of h.reverse())
        this.tokenizer.back(b);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.function = !0, this.lastNode.params = O;
    }
    init(h, d, m) {
      super.init(h, d, m), this.lastNode = h;
    }
    inlineComment(h) {
      let d = new r(), m = h[1].slice(2);
      if (this.init(d, h[2]), d.source.end = this.getPosition(h[3] || h[2]), d.inline = !0, d.raws.begin = "//", /^\s*$/.test(m))
        d.text = "", d.raws.left = m, d.raws.right = "";
      else {
        let y = m.match(/^(\s*)([^]*[^\s])(\s*)$/);
        [, d.raws.left, d.text, d.raws.right] = y;
      }
    }
    mixin(h) {
      let [d] = h, m = d[1].slice(0, 1), y = h.findIndex((x) => x[0] === "brackets"), O = h.findIndex((x) => x[0] === "("), b = "";
      if ((y < 0 || y > 3) && O > 0) {
        let x = h.reduce((j, G, J) => G[0] === ")" ? J : j), w = h.slice(O, x + O).map((j) => j[1]).join(""), [k] = h.slice(O), C = [k[2], k[3]], [E] = h.slice(x, x + 1), P = [E[2], E[3]], I = ["brackets", w].concat(C, P), B = h.slice(0, O), Q = h.slice(x + 1);
        h = B, h.push(I), h = h.concat(Q);
      }
      let v = [];
      for (let x of h)
        if ((x[1] === "!" || v.length) && v.push(x), x[1] === "important")
          break;
      if (v.length) {
        let [x] = v, w = h.indexOf(x), k = v[v.length - 1], C = [x[2], x[3]], E = [k[4], k[5]], P = ["word", v.map((I) => I[1]).join("")].concat(C, E);
        h.splice(w, v.length, P);
      }
      let S = h.findIndex((x) => c.test(x[1]));
      S > 0 && ([, b] = h[S], h.splice(S, 1));
      for (let x of h.reverse())
        this.tokenizer.back(x);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = !0, this.lastNode.raws.identifier = m, b && (this.lastNode.important = !0, this.lastNode.raws.important = b);
    }
    other(h) {
      n.bind(this)(h) || super.other(h);
    }
    rule(h) {
      let d = h[h.length - 1], m = h[h.length - 2];
      if (m[0] === "at-word" && d[0] === "{" && (this.tokenizer.back(d), s.bind(this)(m))) {
        let y = this.tokenizer.nextToken();
        h = h.slice(0, h.length - 2).concat([y]);
        for (let O of h.reverse())
          this.tokenizer.back(O);
        return;
      }
      super.rule(h), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = !0);
    }
    unknownWord(h) {
      let [d] = h;
      if (h[0][1] === "each" && h[1][0] === "(") {
        this.each(h);
        return;
      }
      if (a(d)) {
        this.mixin(h);
        return;
      }
      super.unknownWord(h);
    }
  };
}), d5 = re((t, e) => {
  var r = og();
  e.exports = class extends r {
    atrule(i, n) {
      if (!i.mixin && !i.variable && !i.function) {
        super.atrule(i, n);
        return;
      }
      let s = `${i.function ? "" : i.raws.identifier || "@"}${i.name}`, a = i.params ? this.rawValue(i, "params") : "", o = i.raws.important || "";
      if (i.variable && (a = i.value), typeof i.raws.afterName < "u" ? s += i.raws.afterName : a && (s += " "), i.nodes)
        this.block(i, s + a + o);
      else {
        let u = (i.raws.between || "") + o + (n ? ";" : "");
        this.builder(s + a + u, i);
      }
    }
    comment(i) {
      if (i.inline) {
        let n = this.raw(i, "left", "commentLeft"), s = this.raw(i, "right", "commentRight");
        this.builder(`//${n}${i.text}${s}`, i);
      } else
        super.comment(i);
    }
  };
}), f5 = re((t, e) => {
  var r = Ll(), i = p5(), n = d5();
  e.exports = { parse(s, a) {
    let o = new r(s, a), u = new i(o);
    return u.parse(), u.root.walk((c) => {
      let h = o.css.lastIndexOf(c.source.input.css);
      if (h === 0)
        return;
      if (h + c.source.input.css.length !== o.css.length)
        throw new Error("Invalid state detected in postcss-less");
      let d = h + c.source.start.offset, m = o.fromOffset(h + c.source.start.offset);
      if (c.source.start = { offset: d, line: m.line, column: m.col }, c.source.end) {
        let y = h + c.source.end.offset, O = o.fromOffset(h + c.source.end.offset);
        c.source.end = { offset: y, line: O.line, column: O.col };
      }
    }), u.root;
  }, stringify(s, a) {
    new n(a).stringify(s);
  }, nodeToString(s) {
    let a = "";
    return e.exports.stringify(s, (o) => {
      a += o;
    }), a;
  } };
}), f2 = re((t, e) => {
  e.exports = class {
    generate() {
    }
  };
}), pg = re((t, e) => {
  var r = Ls(), i, n, s = class extends r {
    constructor(a) {
      super({ type: "document", ...a }), this.nodes || (this.nodes = []);
    }
    toResult(a = {}) {
      return new i(new n(), this, a).stringify();
    }
  };
  s.registerLazyResult = (a) => {
    i = a;
  }, s.registerProcessor = (a) => {
    n = a;
  }, e.exports = s, s.default = s;
}), m2 = re((t, e) => {
  var r = {};
  e.exports = function(i) {
    r[i] || (r[i] = !0, typeof console < "u" && console.warn && console.warn(i));
  };
}), g2 = re((t, e) => {
  var r = class {
    constructor(i, n = {}) {
      if (this.type = "warning", this.text = i, n.node && n.node.source) {
        let s = n.node.rangeBy(n);
        this.line = s.start.line, this.column = s.start.column, this.endLine = s.end.line, this.endColumn = s.end.column;
      }
      for (let s in n)
        this[s] = n[s];
    }
    toString() {
      return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  };
  e.exports = r, r.default = r;
}), dg = re((t, e) => {
  var r = g2(), i = class {
    constructor(n, s, a) {
      this.processor = n, this.messages = [], this.root = s, this.opts = a, this.css = void 0, this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(n, s = {}) {
      s.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (s.plugin = this.lastPlugin.postcssPlugin);
      let a = new r(n, s);
      return this.messages.push(a), a;
    }
    warnings() {
      return this.messages.filter((n) => n.type === "warning");
    }
    get content() {
      return this.css;
    }
  };
  e.exports = i, i.default = i;
}), y2 = re((t, e) => {
  var { isClean: r, my: i } = sg(), n = f2(), s = Lh(), a = Ls(), o = pg();
  m2();
  var u = dg(), c = Zh(), h = Ml(), d = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, m = { AtRule: !0, AtRuleExit: !0, Comment: !0, CommentExit: !0, Declaration: !0, DeclarationExit: !0, Document: !0, DocumentExit: !0, Once: !0, OnceExit: !0, postcssPlugin: !0, prepare: !0, Root: !0, RootExit: !0, Rule: !0, RuleExit: !0 }, y = { Once: !0, postcssPlugin: !0, prepare: !0 }, O = 0;
  function b(C) {
    return typeof C == "object" && typeof C.then == "function";
  }
  function v(C) {
    let E = !1, P = d[C.type];
    return C.type === "decl" ? E = C.prop.toLowerCase() : C.type === "atrule" && (E = C.name.toLowerCase()), E && C.append ? [P, P + "-" + E, O, P + "Exit", P + "Exit-" + E] : E ? [P, P + "-" + E, P + "Exit", P + "Exit-" + E] : C.append ? [P, O, P + "Exit"] : [P, P + "Exit"];
  }
  function S(C) {
    let E;
    return C.type === "document" ? E = ["Document", O, "DocumentExit"] : C.type === "root" ? E = ["Root", O, "RootExit"] : E = v(C), { eventIndex: 0, events: E, iterator: 0, node: C, visitorIndex: 0, visitors: [] };
  }
  function x(C) {
    return C[r] = !1, C.nodes && C.nodes.forEach((E) => x(E)), C;
  }
  var w = {}, k = class O2 {
    constructor(E, P, I) {
      this.stringified = !1, this.processed = !1;
      let B;
      if (typeof P == "object" && P !== null && (P.type === "root" || P.type === "document"))
        B = x(P);
      else if (P instanceof O2 || P instanceof u)
        B = x(P.root), P.map && (typeof I.map > "u" && (I.map = {}), I.map.inline || (I.map.inline = !1), I.map.prev = P.map);
      else {
        let Q = c;
        I.syntax && (Q = I.syntax.parse), I.parser && (Q = I.parser), Q.parse && (Q = Q.parse);
        try {
          B = Q(P, I);
        } catch (j) {
          this.processed = !0, this.error = j;
        }
        B && !B[i] && a.rebuild(B);
      }
      this.result = new u(E, B, I), this.helpers = { ...w, postcss: w, result: this.result }, this.plugins = this.processor.plugins.map((Q) => typeof Q == "object" && Q.prepare ? { ...Q, ...Q.prepare(this.result) } : Q);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(E) {
      return this.async().catch(E);
    }
    finally(E) {
      return this.async().then(E, E);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(E, P) {
      let I = this.result.lastPlugin;
      try {
        P && P.addToError(E), this.error = E, E.name === "CssSyntaxError" && !E.plugin ? (E.plugin = I.postcssPlugin, E.setMessage()) : I.postcssVersion;
      } catch (B) {
        console && console.error && console.error(B);
      }
      return E;
    }
    prepareVisitors() {
      this.listeners = {};
      let E = (P, I, B) => {
        this.listeners[I] || (this.listeners[I] = []), this.listeners[I].push([P, B]);
      };
      for (let P of this.plugins)
        if (typeof P == "object")
          for (let I in P) {
            if (!m[I] && /^[A-Z]/.test(I))
              throw new Error(`Unknown event ${I} in ${P.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
            if (!y[I])
              if (typeof P[I] == "object")
                for (let B in P[I])
                  B === "*" ? E(P, I, P[I][B]) : E(P, I + "-" + B.toLowerCase(), P[I][B]);
              else
                typeof P[I] == "function" && E(P, I, P[I]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let E = 0; E < this.plugins.length; E++) {
        let P = this.plugins[E], I = this.runOnRoot(P);
        if (b(I))
          try {
            await I;
          } catch (B) {
            throw this.handleError(B);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let E = this.result.root;
        for (; !E[r]; ) {
          E[r] = !0;
          let P = [S(E)];
          for (; P.length > 0; ) {
            let I = this.visitTick(P);
            if (b(I))
              try {
                await I;
              } catch (B) {
                let Q = P[P.length - 1].node;
                throw this.handleError(B, Q);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [P, I] of this.listeners.OnceExit) {
            this.result.lastPlugin = P;
            try {
              if (E.type === "document") {
                let B = E.nodes.map((Q) => I(Q, this.helpers));
                await Promise.all(B);
              } else
                await I(E, this.helpers);
            } catch (B) {
              throw this.handleError(B);
            }
          }
      }
      return this.processed = !0, this.stringify();
    }
    runOnRoot(E) {
      this.result.lastPlugin = E;
      try {
        if (typeof E == "object" && E.Once) {
          if (this.result.root.type === "document") {
            let P = this.result.root.nodes.map((I) => E.Once(I, this.helpers));
            return b(P[0]) ? Promise.all(P) : P;
          }
          return E.Once(this.result.root, this.helpers);
        } else if (typeof E == "function")
          return E(this.result.root, this.result);
      } catch (P) {
        throw this.handleError(P);
      }
    }
    stringify() {
      if (this.error)
        throw this.error;
      if (this.stringified)
        return this.result;
      this.stringified = !0, this.sync();
      let E = this.result.opts, P = s;
      E.syntax && (P = E.syntax.stringify), E.stringifier && (P = E.stringifier), P.stringify && (P = P.stringify);
      let I = new n(P, this.result.root, this.result.opts).generate();
      return this.result.css = I[0], this.result.map = I[1], this.result;
    }
    sync() {
      if (this.error)
        throw this.error;
      if (this.processed)
        return this.result;
      if (this.processed = !0, this.processing)
        throw this.getAsyncError();
      for (let E of this.plugins) {
        let P = this.runOnRoot(E);
        if (b(P))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let E = this.result.root;
        for (; !E[r]; )
          E[r] = !0, this.walkSync(E);
        if (this.listeners.OnceExit)
          if (E.type === "document")
            for (let P of E.nodes)
              this.visitSync(this.listeners.OnceExit, P);
          else
            this.visitSync(this.listeners.OnceExit, E);
      }
      return this.result;
    }
    then(E, P) {
      return this.async().then(E, P);
    }
    toString() {
      return this.css;
    }
    visitSync(E, P) {
      for (let [I, B] of E) {
        this.result.lastPlugin = I;
        let Q;
        try {
          Q = B(P, this.helpers);
        } catch (j) {
          throw this.handleError(j, P.proxyOf);
        }
        if (P.type !== "root" && P.type !== "document" && !P.parent)
          return !0;
        if (b(Q))
          throw this.getAsyncError();
      }
    }
    visitTick(E) {
      let P = E[E.length - 1], { node: I, visitors: B } = P;
      if (I.type !== "root" && I.type !== "document" && !I.parent) {
        E.pop();
        return;
      }
      if (B.length > 0 && P.visitorIndex < B.length) {
        let [j, G] = B[P.visitorIndex];
        P.visitorIndex += 1, P.visitorIndex === B.length && (P.visitors = [], P.visitorIndex = 0), this.result.lastPlugin = j;
        try {
          return G(I.toProxy(), this.helpers);
        } catch (J) {
          throw this.handleError(J, I);
        }
      }
      if (P.iterator !== 0) {
        let j = P.iterator, G;
        for (; G = I.nodes[I.indexes[j]]; )
          if (I.indexes[j] += 1, !G[r]) {
            G[r] = !0, E.push(S(G));
            return;
          }
        P.iterator = 0, delete I.indexes[j];
      }
      let Q = P.events;
      for (; P.eventIndex < Q.length; ) {
        let j = Q[P.eventIndex];
        if (P.eventIndex += 1, j === O) {
          I.nodes && I.nodes.length && (I[r] = !0, P.iterator = I.getIterator());
          return;
        } else if (this.listeners[j]) {
          P.visitors = this.listeners[j];
          return;
        }
      }
      E.pop();
    }
    walkSync(E) {
      E[r] = !0;
      let P = v(E);
      for (let I of P)
        if (I === O)
          E.nodes && E.each((B) => {
            B[r] || this.walkSync(B);
          });
        else {
          let B = this.listeners[I];
          if (B && this.visitSync(B, E.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
  };
  k.registerPostcss = (C) => {
    w = C;
  }, e.exports = k, k.default = k, h.registerLazyResult(k), o.registerLazyResult(k);
}), m5 = re((t, e) => {
  var r = f2(), i = Lh();
  m2();
  var n = Zh(), s = dg(), a = class {
    constructor(o, u, c) {
      u = u.toString(), this.stringified = !1, this._processor = o, this._css = u, this._opts = c, this._map = void 0;
      let h, d = i;
      this.result = new s(this._processor, h, this._opts), this.result.css = u;
      let m = this;
      Object.defineProperty(this.result, "root", { get() {
        return m.root;
      } });
      let y = new r(d, h, this._opts, u);
      if (y.isMap()) {
        let [O, b] = y.generate();
        O && (this.result.css = O), b && (this.result.map = b);
      } else
        y.clearAnnotation(), this.result.css = y.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(o) {
      return this.async().catch(o);
    }
    finally(o) {
      return this.async().then(o, o);
    }
    sync() {
      if (this.error)
        throw this.error;
      return this.result;
    }
    then(o, u) {
      return this.async().then(o, u);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let o, u = n;
      try {
        o = u(this._css, this._opts);
      } catch (c) {
        this.error = c;
      }
      if (this.error)
        throw this.error;
      return this._root = o, o;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
  };
  e.exports = a, a.default = a;
}), g5 = re((t, e) => {
  var r = m5(), i = y2(), n = pg(), s = Ml(), a = class {
    constructor(o = []) {
      this.version = "8.4.33", this.plugins = this.normalize(o);
    }
    normalize(o) {
      let u = [];
      for (let c of o)
        if (c.postcss === !0 ? c = c() : c.postcss && (c = c.postcss), typeof c == "object" && Array.isArray(c.plugins))
          u = u.concat(c.plugins);
        else if (typeof c == "object" && c.postcssPlugin)
          u.push(c);
        else if (typeof c == "function")
          u.push(c);
        else if (!(typeof c == "object" && (c.parse || c.stringify)))
          throw new Error(c + " is not a PostCSS plugin");
      return u;
    }
    process(o, u = {}) {
      return !this.plugins.length && !u.parser && !u.stringifier && !u.syntax ? new r(this, o, u) : new i(this, o, u);
    }
    use(o) {
      return this.plugins = this.plugins.concat(this.normalize([o])), this;
    }
  };
  e.exports = a, a.default = a, s.registerProcessor(a), n.registerProcessor(a);
}), y5 = re((t, e) => {
  var r = jh(), i = d2(), n = Ql(), s = ug(), a = Ll(), o = Ml(), u = cg();
  function c(h, d) {
    if (Array.isArray(h))
      return h.map((O) => c(O));
    let { inputs: m, ...y } = h;
    if (m) {
      d = [];
      for (let O of m) {
        let b = { ...O, __proto__: a.prototype };
        b.map && (b.map = { ...b.map, __proto__: i.prototype }), d.push(b);
      }
    }
    if (y.nodes && (y.nodes = h.nodes.map((O) => c(O, d))), y.source) {
      let { inputId: O, ...b } = y.source;
      y.source = b, O != null && (y.source.input = d[O]);
    }
    if (y.type === "root")
      return new o(y);
    if (y.type === "decl")
      return new r(y);
    if (y.type === "rule")
      return new u(y);
    if (y.type === "comment")
      return new n(y);
    if (y.type === "atrule")
      return new s(y);
    throw new Error("Unknown node type: " + h.type);
  }
  e.exports = c, c.default = c;
}), fg = re((t, e) => {
  var r = ag(), i = jh(), n = y2(), s = Ls(), a = g5(), o = Lh(), u = y5(), c = pg(), h = g2(), d = Ql(), m = ug(), y = dg(), O = Ll(), b = Zh(), v = p2(), S = cg(), x = Ml(), w = Rh();
  function k(...C) {
    return C.length === 1 && Array.isArray(C[0]) && (C = C[0]), new a(C);
  }
  k.plugin = function(C, E) {
    let P = !1;
    function I(...Q) {
      console && console.warn && !P && (P = !0, console.warn(C + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`));
      let j = E(...Q);
      return j.postcssPlugin = C, j.postcssVersion = new a().version, j;
    }
    let B;
    return Object.defineProperty(I, "postcss", { get() {
      return B || (B = I()), B;
    } }), I.process = function(Q, j, G) {
      return k([I(G)]).process(Q, j);
    }, I;
  }, k.stringify = o, k.parse = b, k.fromJSON = u, k.list = v, k.comment = (C) => new d(C), k.atRule = (C) => new m(C), k.decl = (C) => new i(C), k.rule = (C) => new S(C), k.root = (C) => new x(C), k.document = (C) => new c(C), k.CssSyntaxError = r, k.Declaration = i, k.Container = s, k.Processor = a, k.Document = c, k.Comment = d, k.Warning = h, k.AtRule = m, k.Result = y, k.Input = O, k.Rule = S, k.Root = x, k.Node = w, n.registerPostcss(k), e.exports = k, k.default = k;
}), O5 = re((t, e) => {
  var { Container: r } = fg(), i = class extends r {
    constructor(n) {
      super(n), this.type = "decl", this.isNested = !0, this.nodes || (this.nodes = []);
    }
  };
  e.exports = i;
}), x5 = re((t, e) => {
  var r = /[\t\n\f\r "#'()/;[\\\]{}]/g, i = /[,\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, n = /.[\r\n"'(/\\]/, s = /[\da-f]/i, a = /[\n\f\r]/g;
  e.exports = function(o, u = {}) {
    let c = o.css.valueOf(), h = u.ignoreErrors, d, m, y, O, b, v, S, x, w, k = c.length, C = 0, E = [], P = [], I;
    function B() {
      return C;
    }
    function Q(q) {
      throw o.error("Unclosed " + q, C);
    }
    function j() {
      return P.length === 0 && C >= k;
    }
    function G() {
      let q = 1, X = !1, K = !1;
      for (; q > 0; )
        m += 1, c.length <= m && Q("interpolation"), d = c.charCodeAt(m), x = c.charCodeAt(m + 1), X ? !K && d === X ? (X = !1, K = !1) : d === 92 ? K = !K : K && (K = !1) : d === 39 || d === 34 ? X = d : d === 125 ? q -= 1 : d === 35 && x === 123 && (q += 1);
    }
    function J(q) {
      if (P.length)
        return P.pop();
      if (C >= k)
        return;
      let X = q ? q.ignoreUnclosed : !1;
      switch (d = c.charCodeAt(C), d) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12: {
          m = C;
          do
            m += 1, d = c.charCodeAt(m);
          while (d === 32 || d === 10 || d === 9 || d === 13 || d === 12);
          w = ["space", c.slice(C, m)], C = m - 1;
          break;
        }
        case 91:
        case 93:
        case 123:
        case 125:
        case 58:
        case 59:
        case 41: {
          let K = String.fromCharCode(d);
          w = [K, K, C];
          break;
        }
        case 44: {
          w = ["word", ",", C, C + 1];
          break;
        }
        case 40: {
          if (S = E.length ? E.pop()[1] : "", x = c.charCodeAt(C + 1), S === "url" && x !== 39 && x !== 34) {
            for (I = 1, v = !1, m = C + 1; m <= c.length - 1; ) {
              if (x = c.charCodeAt(m), x === 92)
                v = !v;
              else if (x === 40)
                I += 1;
              else if (x === 41 && (I -= 1, I === 0))
                break;
              m += 1;
            }
            O = c.slice(C, m + 1), w = ["brackets", O, C, m], C = m;
          } else
            m = c.indexOf(")", C + 1), O = c.slice(C, m + 1), m === -1 || n.test(O) ? w = ["(", "(", C] : (w = ["brackets", O, C, m], C = m);
          break;
        }
        case 39:
        case 34: {
          for (y = d, m = C, v = !1; m < k && (m++, m === k && Q("string"), d = c.charCodeAt(m), x = c.charCodeAt(m + 1), !(!v && d === y)); )
            d === 92 ? v = !v : v ? v = !1 : d === 35 && x === 123 && G();
          w = ["string", c.slice(C, m + 1), C, m], C = m;
          break;
        }
        case 64: {
          r.lastIndex = C + 1, r.test(c), r.lastIndex === 0 ? m = c.length - 1 : m = r.lastIndex - 2, w = ["at-word", c.slice(C, m + 1), C, m], C = m;
          break;
        }
        case 92: {
          for (m = C, b = !0; c.charCodeAt(m + 1) === 92; )
            m += 1, b = !b;
          if (d = c.charCodeAt(m + 1), b && d !== 47 && d !== 32 && d !== 10 && d !== 9 && d !== 13 && d !== 12 && (m += 1, s.test(c.charAt(m)))) {
            for (; s.test(c.charAt(m + 1)); )
              m += 1;
            c.charCodeAt(m + 1) === 32 && (m += 1);
          }
          w = ["word", c.slice(C, m + 1), C, m], C = m;
          break;
        }
        default:
          x = c.charCodeAt(C + 1), d === 35 && x === 123 ? (m = C, G(), O = c.slice(C, m + 1), w = ["word", O, C, m], C = m) : d === 47 && x === 42 ? (m = c.indexOf("*/", C + 2) + 1, m === 0 && (h || X ? m = c.length : Q("comment")), w = ["comment", c.slice(C, m + 1), C, m], C = m) : d === 47 && x === 47 ? (a.lastIndex = C + 1, a.test(c), a.lastIndex === 0 ? m = c.length - 1 : m = a.lastIndex - 2, O = c.slice(C, m + 1), w = ["comment", O, C, m, "inline"], C = m) : (i.lastIndex = C + 1, i.test(c), i.lastIndex === 0 ? m = c.length - 1 : m = i.lastIndex - 2, w = ["word", c.slice(C, m + 1), C, m], E.push(w), C = m);
          break;
      }
      return C++, w;
    }
    function L(q) {
      P.push(q);
    }
    return { back: L, endOfFile: j, nextToken: J, position: B };
  };
}), b5 = re((t, e) => {
  var { Comment: r } = fg(), i = hg(), n = O5(), s = x5(), a = class extends i {
    atrule(o) {
      let u = o[1], c = o;
      for (; !this.tokenizer.endOfFile(); ) {
        let h = this.tokenizer.nextToken();
        if (h[0] === "word" && h[2] === c[3] + 1)
          u += h[1], c = h;
        else {
          this.tokenizer.back(h);
          break;
        }
      }
      super.atrule(["at-word", u, o[2], c[3]]);
    }
    comment(o) {
      if (o[4] === "inline") {
        let u = new r();
        this.init(u, o[2]), u.raws.inline = !0;
        let c = this.input.fromOffset(o[3]);
        u.source.end = { column: c.col, line: c.line, offset: o[3] + 1 };
        let h = o[1].slice(2);
        if (/^\s*$/.test(h))
          u.text = "", u.raws.left = h, u.raws.right = "";
        else {
          let d = h.match(/^(\s*)([^]*\S)(\s*)$/), m = d[2].replace(/(\*\/|\/\*)/g, "*//*");
          u.text = m, u.raws.left = d[1], u.raws.right = d[3], u.raws.text = d[2];
        }
      } else
        super.comment(o);
    }
    createTokenizer() {
      this.tokenizer = s(this.input);
    }
    raw(o, u, c, h) {
      if (super.raw(o, u, c, h), o.raws[u]) {
        let d = o.raws[u].raw;
        o.raws[u].raw = c.reduce((m, y) => {
          if (y[0] === "comment" && y[4] === "inline") {
            let O = y[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*");
            return m + "/*" + O + "*/";
          } else
            return m + y[1];
        }, ""), d !== o.raws[u].raw && (o.raws[u].scss = d);
      }
    }
    rule(o) {
      let u = !1, c = 0, h = "";
      for (let d of o)
        if (u)
          d[0] !== "comment" && d[0] !== "{" && (h += d[1]);
        else {
          if (d[0] === "space" && d[1].includes(`
`))
            break;
          d[0] === "(" ? c += 1 : d[0] === ")" ? c -= 1 : c === 0 && d[0] === ":" && (u = !0);
        }
      if (!u || h.trim() === "" || /^[#:A-Za-z-]/.test(h))
        super.rule(o);
      else {
        o.pop();
        let d = new n();
        this.init(d, o[0][2]);
        let m;
        for (let O = o.length - 1; O >= 0; O--)
          if (o[O][0] !== "space") {
            m = o[O];
            break;
          }
        if (m[3]) {
          let O = this.input.fromOffset(m[3]);
          d.source.end = { column: O.col, line: O.line, offset: m[3] + 1 };
        } else {
          let O = this.input.fromOffset(m[2]);
          d.source.end = { column: O.col, line: O.line, offset: m[2] + 1 };
        }
        for (; o[0][0] !== "word"; )
          d.raws.before += o.shift()[1];
        if (o[0][2]) {
          let O = this.input.fromOffset(o[0][2]);
          d.source.start = { column: O.col, line: O.line, offset: o[0][2] };
        }
        for (d.prop = ""; o.length; ) {
          let O = o[0][0];
          if (O === ":" || O === "space" || O === "comment")
            break;
          d.prop += o.shift()[1];
        }
        d.raws.between = "";
        let y;
        for (; o.length; )
          if (y = o.shift(), y[0] === ":") {
            d.raws.between += y[1];
            break;
          } else
            d.raws.between += y[1];
        (d.prop[0] === "_" || d.prop[0] === "*") && (d.raws.before += d.prop[0], d.prop = d.prop.slice(1)), d.raws.between += this.spacesAndCommentsFromStart(o), this.precheckMissedSemicolon(o);
        for (let O = o.length - 1; O > 0; O--) {
          if (y = o[O], y[1] === "!important") {
            d.important = !0;
            let b = this.stringFrom(o, O);
            b = this.spacesFromEnd(o) + b, b !== " !important" && (d.raws.important = b);
            break;
          } else if (y[1] === "important") {
            let b = o.slice(0), v = "";
            for (let S = O; S > 0; S--) {
              let x = b[S][0];
              if (v.trim().indexOf("!") === 0 && x !== "space")
                break;
              v = b.pop()[1] + v;
            }
            v.trim().indexOf("!") === 0 && (d.important = !0, d.raws.important = v, o = b);
          }
          if (y[0] !== "space" && y[0] !== "comment")
            break;
        }
        this.raw(d, "value", o), d.value.includes(":") && this.checkMissedSemicolon(o), this.current = d;
      }
    }
  };
  e.exports = a;
}), D5 = re((t, e) => {
  var { Input: r } = fg(), i = b5();
  e.exports = function(n, s) {
    let a = new r(n, s), o = new i(a);
    return o.parse(), o.root;
  };
}), x2 = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(r) {
    this.after = r.after, this.before = r.before, this.type = r.type, this.value = r.value, this.sourceIndex = r.sourceIndex;
  }
  t.default = e;
}), b2 = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = x2(), r = i(e);
  function i(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function n(s) {
    var a = this;
    this.constructor(s), this.nodes = s.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(o) {
      o.parent = a;
    });
  }
  n.prototype = Object.create(r.default.prototype), n.constructor = r.default, n.prototype.walk = function(s, a) {
    for (var o = typeof s == "string" || s instanceof RegExp, u = o ? a : s, c = typeof s == "string" ? new RegExp(s) : s, h = 0; h < this.nodes.length; h++) {
      var d = this.nodes[h], m = o ? c.test(d.type) : !0;
      if (m && u && u(d, h, this.nodes) === !1 || d.nodes && d.walk(s, a) === !1)
        return !1;
    }
    return !0;
  }, n.prototype.each = function() {
    for (var s = arguments.length <= 0 || arguments[0] === void 0 ? function() {
    } : arguments[0], a = 0; a < this.nodes.length; a++) {
      var o = this.nodes[a];
      if (s(o, a, this.nodes) === !1)
        return !1;
    }
    return !0;
  }, t.default = n;
}), v5 = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.parseMediaFeature = a, t.parseMediaQuery = o, t.parseMediaList = u;
  var e = x2(), r = s(e), i = b2(), n = s(i);
  function s(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function a(c) {
    var h = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], d = [{ mode: "normal", character: null }], m = [], y = 0, O = "", b = null, v = null, S = h, x = c;
    c[0] === "(" && c[c.length - 1] === ")" && (x = c.substring(1, c.length - 1), S++);
    for (var w = 0; w < x.length; w++) {
      var k = x[w];
      if ((k === "'" || k === '"') && (d[y].isCalculationEnabled === !0 ? (d.push({ mode: "string", isCalculationEnabled: !1, character: k }), y++) : d[y].mode === "string" && d[y].character === k && x[w - 1] !== "\\" && (d.pop(), y--)), k === "{" ? (d.push({ mode: "interpolation", isCalculationEnabled: !0 }), y++) : k === "}" && (d.pop(), y--), d[y].mode === "normal" && k === ":") {
        var C = x.substring(w + 1);
        v = { type: "value", before: /^(\s*)/.exec(C)[1], after: /(\s*)$/.exec(C)[1], value: C.trim() }, v.sourceIndex = v.before.length + w + 1 + S, b = { type: "colon", sourceIndex: w + S, after: v.before, value: ":" };
        break;
      }
      O += k;
    }
    return O = { type: "media-feature", before: /^(\s*)/.exec(O)[1], after: /(\s*)$/.exec(O)[1], value: O.trim() }, O.sourceIndex = O.before.length + S, m.push(O), b !== null && (b.before = O.after, m.push(b)), v !== null && m.push(v), m;
  }
  function o(c) {
    var h = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], d = [], m = 0, y = !1, O = void 0;
    function b() {
      return { before: "", after: "", value: "" };
    }
    O = b();
    for (var v = 0; v < c.length; v++) {
      var S = c[v];
      y ? (O.value += S, (S === "{" || S === "(") && m++, (S === ")" || S === "}") && m--) : S.search(/\s/) !== -1 ? O.before += S : (S === "(" && (O.type = "media-feature-expression", m++), O.value = S, O.sourceIndex = h + v, y = !0), y && m === 0 && (S === ")" || v === c.length - 1 || c[v + 1].search(/\s/) !== -1) && (["not", "only", "and"].indexOf(O.value) !== -1 && (O.type = "keyword"), O.type === "media-feature-expression" && (O.nodes = a(O.value, O.sourceIndex)), d.push(Array.isArray(O.nodes) ? new n.default(O) : new r.default(O)), O = b(), y = !1);
    }
    for (var x = 0; x < d.length; x++)
      if (O = d[x], x > 0 && (d[x - 1].after = O.before), O.type === void 0) {
        if (x > 0) {
          if (d[x - 1].type === "media-feature-expression") {
            O.type = "keyword";
            continue;
          }
          if (d[x - 1].value === "not" || d[x - 1].value === "only") {
            O.type = "media-type";
            continue;
          }
          if (d[x - 1].value === "and") {
            O.type = "media-feature-expression";
            continue;
          }
          d[x - 1].type === "media-type" && (d[x + 1] ? O.type = d[x + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : O.type = "media-feature-expression");
        }
        if (x === 0) {
          if (!d[x + 1]) {
            O.type = "media-type";
            continue;
          }
          if (d[x + 1] && (d[x + 1].type === "media-feature-expression" || d[x + 1].type === "keyword")) {
            O.type = "media-type";
            continue;
          }
          if (d[x + 2]) {
            if (d[x + 2].type === "media-feature-expression") {
              O.type = "media-type", d[x + 1].type = "keyword";
              continue;
            }
            if (d[x + 2].type === "keyword") {
              O.type = "keyword", d[x + 1].type = "media-type";
              continue;
            }
          }
          if (d[x + 3] && d[x + 3].type === "media-feature-expression") {
            O.type = "keyword", d[x + 1].type = "media-type", d[x + 2].type = "keyword";
            continue;
          }
        }
      }
    return d;
  }
  function u(c) {
    var h = [], d = 0, m = 0, y = /^(\s*)url\s*\(/.exec(c);
    if (y !== null) {
      for (var O = y[0].length, b = 1; b > 0; ) {
        var v = c[O];
        v === "(" && b++, v === ")" && b--, O++;
      }
      h.unshift(new r.default({ type: "url", value: c.substring(0, O).trim(), sourceIndex: y[1].length, before: y[1], after: /^(\s*)/.exec(c.substring(O))[1] })), d = O;
    }
    for (var S = d; S < c.length; S++) {
      var x = c[S];
      if (x === "(" && m++, x === ")" && m--, m === 0 && x === ",") {
        var w = c.substring(d, S), k = /^(\s*)/.exec(w)[1];
        h.push(new n.default({ type: "media-query", value: w.trim(), sourceIndex: d + k.length, nodes: o(w, d), before: k, after: /(\s*)$/.exec(w)[1] })), d = S + 1;
      }
    }
    var C = c.substring(d), E = /^(\s*)/.exec(C)[1];
    return h.push(new n.default({ type: "media-query", value: C.trim(), sourceIndex: d + E.length, nodes: o(C, d), before: E, after: /(\s*)$/.exec(C)[1] })), h;
  }
}), S5 = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = s;
  var e = b2(), r = n(e), i = v5();
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function s(a) {
    return new r.default({ nodes: (0, i.parseMediaList)(a), type: "media-query-list", value: a.trim() });
  }
}), D2 = re((t, e) => {
  e.exports = function(r, i) {
    if (i = typeof i == "number" ? i : 1 / 0, !i)
      return Array.isArray(r) ? r.map(function(s) {
        return s;
      }) : r;
    return n(r, 1);
    function n(s, a) {
      return s.reduce(function(o, u) {
        return Array.isArray(u) && a < i ? o.concat(n(u, a + 1)) : o.concat(u);
      }, []);
    }
  };
}), v2 = re((t, e) => {
  e.exports = function(r, i) {
    for (var n = -1, s = []; (n = r.indexOf(i, n + 1)) !== -1; )
      s.push(n);
    return s;
  };
}), S2 = re((t, e) => {
  function r(s, a) {
    for (var o = 1, u = s.length, c = s[0], h = s[0], d = 1; d < u; ++d)
      if (h = c, c = s[d], a(c, h)) {
        if (d === o) {
          o++;
          continue;
        }
        s[o++] = c;
      }
    return s.length = o, s;
  }
  function i(s) {
    for (var a = 1, o = s.length, u = s[0], c = s[0], h = 1; h < o; ++h, c = u)
      if (c = u, u = s[h], u !== c) {
        if (h === a) {
          a++;
          continue;
        }
        s[a++] = u;
      }
    return s.length = a, s;
  }
  function n(s, a, o) {
    return s.length === 0 ? s : a ? (o || s.sort(a), r(s, a)) : (o || s.sort(), i(s));
  }
  e.exports = n;
}), Ya = re((t, e) => {
  t.__esModule = !0;
  var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
    return typeof a;
  } : function(a) {
    return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
  };
  function i(a, o) {
    if (!(a instanceof o))
      throw new TypeError("Cannot call a class as a function");
  }
  var n = function a(o, u) {
    if ((typeof o > "u" ? "undefined" : r(o)) !== "object")
      return o;
    var c = new o.constructor();
    for (var h in o)
      if (o.hasOwnProperty(h)) {
        var d = o[h], m = typeof d > "u" ? "undefined" : r(d);
        h === "parent" && m === "object" ? u && (c[h] = u) : d instanceof Array ? c[h] = d.map(function(y) {
          return a(y, c);
        }) : c[h] = a(d, c);
      }
    return c;
  }, s = function() {
    function a() {
      var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      i(this, a);
      for (var u in o)
        this[u] = o[u];
      var c = o.spaces;
      c = c === void 0 ? {} : c;
      var h = c.before, d = h === void 0 ? "" : h, m = c.after, y = m === void 0 ? "" : m;
      this.spaces = { before: d, after: y };
    }
    return a.prototype.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, a.prototype.replaceWith = function() {
      if (this.parent) {
        for (var o in arguments)
          this.parent.insertBefore(this, arguments[o]);
        this.remove();
      }
      return this;
    }, a.prototype.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, a.prototype.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, a.prototype.clone = function() {
      var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = n(this);
      for (var c in o)
        u[c] = o[c];
      return u;
    }, a.prototype.toString = function() {
      return [this.spaces.before, String(this.value), this.spaces.after].join("");
    }, a;
  }();
  t.default = s, e.exports = t.default;
}), ur = re((t) => {
  t.__esModule = !0, t.TAG = "tag", t.STRING = "string", t.SELECTOR = "selector", t.ROOT = "root", t.PSEUDO = "pseudo", t.NESTING = "nesting", t.ID = "id", t.COMMENT = "comment", t.COMBINATOR = "combinator", t.CLASS = "class", t.ATTRIBUTE = "attribute", t.UNIVERSAL = "universal";
}), mg = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function y(O, b) {
      for (var v = 0; v < b.length; v++) {
        var S = b[v];
        S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(O, S.key, S);
      }
    }
    return function(O, b, v) {
      return b && y(O.prototype, b), v && y(O, v), O;
    };
  }(), i = Ya(), n = u(i), s = ur(), a = o(s);
  function o(y) {
    if (y && y.__esModule)
      return y;
    var O = {};
    if (y != null)
      for (var b in y)
        Object.prototype.hasOwnProperty.call(y, b) && (O[b] = y[b]);
    return O.default = y, O;
  }
  function u(y) {
    return y && y.__esModule ? y : { default: y };
  }
  function c(y, O) {
    if (!(y instanceof O))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(y, O) {
    if (!y)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return O && (typeof O == "object" || typeof O == "function") ? O : y;
  }
  function d(y, O) {
    if (typeof O != "function" && O !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof O);
    y.prototype = Object.create(O && O.prototype, { constructor: { value: y, enumerable: !1, writable: !0, configurable: !0 } }), O && (Object.setPrototypeOf ? Object.setPrototypeOf(y, O) : y.__proto__ = O);
  }
  var m = function(y) {
    d(O, y);
    function O(b) {
      c(this, O);
      var v = h(this, y.call(this, b));
      return v.nodes || (v.nodes = []), v;
    }
    return O.prototype.append = function(b) {
      return b.parent = this, this.nodes.push(b), this;
    }, O.prototype.prepend = function(b) {
      return b.parent = this, this.nodes.unshift(b), this;
    }, O.prototype.at = function(b) {
      return this.nodes[b];
    }, O.prototype.index = function(b) {
      return typeof b == "number" ? b : this.nodes.indexOf(b);
    }, O.prototype.removeChild = function(b) {
      b = this.index(b), this.at(b).parent = void 0, this.nodes.splice(b, 1);
      var v = void 0;
      for (var S in this.indexes)
        v = this.indexes[S], v >= b && (this.indexes[S] = v - 1);
      return this;
    }, O.prototype.removeAll = function() {
      for (var S = this.nodes, b = Array.isArray(S), v = 0, S = b ? S : S[Symbol.iterator](); ; ) {
        var x;
        if (b) {
          if (v >= S.length)
            break;
          x = S[v++];
        } else {
          if (v = S.next(), v.done)
            break;
          x = v.value;
        }
        var w = x;
        w.parent = void 0;
      }
      return this.nodes = [], this;
    }, O.prototype.empty = function() {
      return this.removeAll();
    }, O.prototype.insertAfter = function(b, v) {
      var S = this.index(b);
      this.nodes.splice(S + 1, 0, v);
      var x = void 0;
      for (var w in this.indexes)
        x = this.indexes[w], S <= x && (this.indexes[w] = x + this.nodes.length);
      return this;
    }, O.prototype.insertBefore = function(b, v) {
      var S = this.index(b);
      this.nodes.splice(S, 0, v);
      var x = void 0;
      for (var w in this.indexes)
        x = this.indexes[w], S <= x && (this.indexes[w] = x + this.nodes.length);
      return this;
    }, O.prototype.each = function(b) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var v = this.lastEach;
      if (this.indexes[v] = 0, !!this.length) {
        for (var S = void 0, x = void 0; this.indexes[v] < this.length && (S = this.indexes[v], x = b(this.at(S), S), x !== !1); )
          this.indexes[v] += 1;
        if (delete this.indexes[v], x === !1)
          return !1;
      }
    }, O.prototype.walk = function(b) {
      return this.each(function(v, S) {
        var x = b(v, S);
        if (x !== !1 && v.length && (x = v.walk(b)), x === !1)
          return !1;
      });
    }, O.prototype.walkAttributes = function(b) {
      var v = this;
      return this.walk(function(S) {
        if (S.type === a.ATTRIBUTE)
          return b.call(v, S);
      });
    }, O.prototype.walkClasses = function(b) {
      var v = this;
      return this.walk(function(S) {
        if (S.type === a.CLASS)
          return b.call(v, S);
      });
    }, O.prototype.walkCombinators = function(b) {
      var v = this;
      return this.walk(function(S) {
        if (S.type === a.COMBINATOR)
          return b.call(v, S);
      });
    }, O.prototype.walkComments = function(b) {
      var v = this;
      return this.walk(function(S) {
        if (S.type === a.COMMENT)
          return b.call(v, S);
      });
    }, O.prototype.walkIds = function(b) {
      var v = this;
      return this.walk(function(S) {
        if (S.type === a.ID)
          return b.call(v, S);
      });
    }, O.prototype.walkNesting = function(b) {
      var v = this;
      return this.walk(function(S) {
        if (S.type === a.NESTING)
          return b.call(v, S);
      });
    }, O.prototype.walkPseudos = function(b) {
      var v = this;
      return this.walk(function(S) {
        if (S.type === a.PSEUDO)
          return b.call(v, S);
      });
    }, O.prototype.walkTags = function(b) {
      var v = this;
      return this.walk(function(S) {
        if (S.type === a.TAG)
          return b.call(v, S);
      });
    }, O.prototype.walkUniversals = function(b) {
      var v = this;
      return this.walk(function(S) {
        if (S.type === a.UNIVERSAL)
          return b.call(v, S);
      });
    }, O.prototype.split = function(b) {
      var v = this, S = [];
      return this.reduce(function(x, w, k) {
        var C = b.call(v, w);
        return S.push(w), C ? (x.push(S), S = []) : k === v.length - 1 && x.push(S), x;
      }, []);
    }, O.prototype.map = function(b) {
      return this.nodes.map(b);
    }, O.prototype.reduce = function(b, v) {
      return this.nodes.reduce(b, v);
    }, O.prototype.every = function(b) {
      return this.nodes.every(b);
    }, O.prototype.some = function(b) {
      return this.nodes.some(b);
    }, O.prototype.filter = function(b) {
      return this.nodes.filter(b);
    }, O.prototype.sort = function(b) {
      return this.nodes.sort(b);
    }, O.prototype.toString = function() {
      return this.map(String).join("");
    }, r(O, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), O;
  }(n.default);
  t.default = m, e.exports = t.default;
}), w5 = re((t, e) => {
  t.__esModule = !0;
  var r = mg(), i = s(r), n = ur();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, d) {
    if (!(h instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, d) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : h;
  }
  function u(h, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    h.prototype = Object.create(d && d.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(h, d) : h.__proto__ = d);
  }
  var c = function(h) {
    u(d, h);
    function d(m) {
      a(this, d);
      var y = o(this, h.call(this, m));
      return y.type = n.ROOT, y;
    }
    return d.prototype.toString = function() {
      var m = this.reduce(function(y, O) {
        var b = String(O);
        return b ? y + b + "," : "";
      }, "").slice(0, -1);
      return this.trailingComma ? m + "," : m;
    }, d;
  }(i.default);
  t.default = c, e.exports = t.default;
}), C5 = re((t, e) => {
  t.__esModule = !0;
  var r = mg(), i = s(r), n = ur();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, d) {
    if (!(h instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, d) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : h;
  }
  function u(h, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    h.prototype = Object.create(d && d.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(h, d) : h.__proto__ = d);
  }
  var c = function(h) {
    u(d, h);
    function d(m) {
      a(this, d);
      var y = o(this, h.call(this, m));
      return y.type = n.SELECTOR, y;
    }
    return d;
  }(i.default);
  t.default = c, e.exports = t.default;
}), Rl = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function h(d, m) {
      for (var y = 0; y < m.length; y++) {
        var O = m[y];
        O.enumerable = O.enumerable || !1, O.configurable = !0, "value" in O && (O.writable = !0), Object.defineProperty(d, O.key, O);
      }
    }
    return function(d, m, y) {
      return m && h(d.prototype, m), y && h(d, y), d;
    };
  }(), i = Ya(), n = s(i);
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, d) {
    if (!(h instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, d) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : h;
  }
  function u(h, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    h.prototype = Object.create(d && d.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(h, d) : h.__proto__ = d);
  }
  var c = function(h) {
    u(d, h);
    function d() {
      return a(this, d), o(this, h.apply(this, arguments));
    }
    return d.prototype.toString = function() {
      return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
    }, r(d, [{ key: "ns", get: function() {
      var m = this.namespace;
      return m ? (typeof m == "string" ? m : "") + "|" : "";
    } }]), d;
  }(n.default);
  t.default = c, e.exports = t.default;
}), A5 = re((t, e) => {
  t.__esModule = !0;
  var r = Rl(), i = s(r), n = ur();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, d) {
    if (!(h instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, d) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : h;
  }
  function u(h, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    h.prototype = Object.create(d && d.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(h, d) : h.__proto__ = d);
  }
  var c = function(h) {
    u(d, h);
    function d(m) {
      a(this, d);
      var y = o(this, h.call(this, m));
      return y.type = n.CLASS, y;
    }
    return d.prototype.toString = function() {
      return [this.spaces.before, this.ns, "." + this.value, this.spaces.after].join("");
    }, d;
  }(i.default);
  t.default = c, e.exports = t.default;
}), E5 = re((t, e) => {
  t.__esModule = !0;
  var r = Ya(), i = s(r), n = ur();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, d) {
    if (!(h instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, d) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : h;
  }
  function u(h, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    h.prototype = Object.create(d && d.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(h, d) : h.__proto__ = d);
  }
  var c = function(h) {
    u(d, h);
    function d(m) {
      a(this, d);
      var y = o(this, h.call(this, m));
      return y.type = n.COMMENT, y;
    }
    return d;
  }(i.default);
  t.default = c, e.exports = t.default;
}), k5 = re((t, e) => {
  t.__esModule = !0;
  var r = Rl(), i = s(r), n = ur();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, d) {
    if (!(h instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, d) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : h;
  }
  function u(h, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    h.prototype = Object.create(d && d.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(h, d) : h.__proto__ = d);
  }
  var c = function(h) {
    u(d, h);
    function d(m) {
      a(this, d);
      var y = o(this, h.call(this, m));
      return y.type = n.ID, y;
    }
    return d.prototype.toString = function() {
      return [this.spaces.before, this.ns, "#" + this.value, this.spaces.after].join("");
    }, d;
  }(i.default);
  t.default = c, e.exports = t.default;
}), T5 = re((t, e) => {
  t.__esModule = !0;
  var r = Rl(), i = s(r), n = ur();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, d) {
    if (!(h instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, d) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : h;
  }
  function u(h, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    h.prototype = Object.create(d && d.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(h, d) : h.__proto__ = d);
  }
  var c = function(h) {
    u(d, h);
    function d(m) {
      a(this, d);
      var y = o(this, h.call(this, m));
      return y.type = n.TAG, y;
    }
    return d;
  }(i.default);
  t.default = c, e.exports = t.default;
}), P5 = re((t, e) => {
  t.__esModule = !0;
  var r = Ya(), i = s(r), n = ur();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, d) {
    if (!(h instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, d) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : h;
  }
  function u(h, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    h.prototype = Object.create(d && d.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(h, d) : h.__proto__ = d);
  }
  var c = function(h) {
    u(d, h);
    function d(m) {
      a(this, d);
      var y = o(this, h.call(this, m));
      return y.type = n.STRING, y;
    }
    return d;
  }(i.default);
  t.default = c, e.exports = t.default;
}), F5 = re((t, e) => {
  t.__esModule = !0;
  var r = mg(), i = s(r), n = ur();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, d) {
    if (!(h instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, d) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : h;
  }
  function u(h, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    h.prototype = Object.create(d && d.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(h, d) : h.__proto__ = d);
  }
  var c = function(h) {
    u(d, h);
    function d(m) {
      a(this, d);
      var y = o(this, h.call(this, m));
      return y.type = n.PSEUDO, y;
    }
    return d.prototype.toString = function() {
      var m = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.spaces.before, String(this.value), m, this.spaces.after].join("");
    }, d;
  }(i.default);
  t.default = c, e.exports = t.default;
}), $5 = re((t, e) => {
  t.__esModule = !0;
  var r = Rl(), i = s(r), n = ur();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, d) {
    if (!(h instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, d) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : h;
  }
  function u(h, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    h.prototype = Object.create(d && d.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(h, d) : h.__proto__ = d);
  }
  var c = function(h) {
    u(d, h);
    function d(m) {
      a(this, d);
      var y = o(this, h.call(this, m));
      return y.type = n.ATTRIBUTE, y.raws = {}, y;
    }
    return d.prototype.toString = function() {
      var m = [this.spaces.before, "[", this.ns, this.attribute];
      return this.operator && m.push(this.operator), this.value && m.push(this.value), this.raws.insensitive ? m.push(this.raws.insensitive) : this.insensitive && m.push(" i"), m.push("]"), m.concat(this.spaces.after).join("");
    }, d;
  }(i.default);
  t.default = c, e.exports = t.default;
}), B5 = re((t, e) => {
  t.__esModule = !0;
  var r = Rl(), i = s(r), n = ur();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, d) {
    if (!(h instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, d) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : h;
  }
  function u(h, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    h.prototype = Object.create(d && d.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(h, d) : h.__proto__ = d);
  }
  var c = function(h) {
    u(d, h);
    function d(m) {
      a(this, d);
      var y = o(this, h.call(this, m));
      return y.type = n.UNIVERSAL, y.value = "*", y;
    }
    return d;
  }(i.default);
  t.default = c, e.exports = t.default;
}), I5 = re((t, e) => {
  t.__esModule = !0;
  var r = Ya(), i = s(r), n = ur();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, d) {
    if (!(h instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, d) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : h;
  }
  function u(h, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    h.prototype = Object.create(d && d.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(h, d) : h.__proto__ = d);
  }
  var c = function(h) {
    u(d, h);
    function d(m) {
      a(this, d);
      var y = o(this, h.call(this, m));
      return y.type = n.COMBINATOR, y;
    }
    return d;
  }(i.default);
  t.default = c, e.exports = t.default;
}), N5 = re((t, e) => {
  t.__esModule = !0;
  var r = Ya(), i = s(r), n = ur();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, d) {
    if (!(h instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, d) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : h;
  }
  function u(h, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    h.prototype = Object.create(d && d.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(h, d) : h.__proto__ = d);
  }
  var c = function(h) {
    u(d, h);
    function d(m) {
      a(this, d);
      var y = o(this, h.call(this, m));
      return y.type = n.NESTING, y.value = "&", y;
    }
    return d;
  }(i.default);
  t.default = c, e.exports = t.default;
}), _5 = re((t, e) => {
  t.__esModule = !0, t.default = r;
  function r(i) {
    return i.sort(function(n, s) {
      return n - s;
    });
  }
  e.exports = t.default;
}), Q5 = re((t, e) => {
  t.__esModule = !0, t.default = j;
  var r = 39, i = 34, n = 92, s = 47, a = 10, o = 32, u = 12, c = 9, h = 13, d = 43, m = 62, y = 126, O = 124, b = 44, v = 40, S = 41, x = 91, w = 93, k = 59, C = 42, E = 58, P = 38, I = 64, B = /[ \n\t\r\{\(\)'"\\;/]/g, Q = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
  function j(G) {
    for (var J = [], L = G.css.valueOf(), q = void 0, X = void 0, K = void 0, Oe = void 0, Ae = void 0, ve = void 0, Le = void 0, ze = void 0, et = void 0, Fe = void 0, mt = void 0, ue = L.length, V = -1, W = 1, R = 0, Se = function(De, Te) {
      if (G.safe)
        L += Te, X = L.length - 1;
      else
        throw G.error("Unclosed " + De, W, R - V, R);
    }; R < ue; ) {
      switch (q = L.charCodeAt(R), q === a && (V = R, W += 1), q) {
        case a:
        case o:
        case c:
        case h:
        case u:
          X = R;
          do
            X += 1, q = L.charCodeAt(X), q === a && (V = X, W += 1);
          while (q === o || q === a || q === c || q === h || q === u);
          J.push(["space", L.slice(R, X), W, R - V, R]), R = X - 1;
          break;
        case d:
        case m:
        case y:
        case O:
          X = R;
          do
            X += 1, q = L.charCodeAt(X);
          while (q === d || q === m || q === y || q === O);
          J.push(["combinator", L.slice(R, X), W, R - V, R]), R = X - 1;
          break;
        case C:
          J.push(["*", "*", W, R - V, R]);
          break;
        case P:
          J.push(["&", "&", W, R - V, R]);
          break;
        case b:
          J.push([",", ",", W, R - V, R]);
          break;
        case x:
          J.push(["[", "[", W, R - V, R]);
          break;
        case w:
          J.push(["]", "]", W, R - V, R]);
          break;
        case E:
          J.push([":", ":", W, R - V, R]);
          break;
        case k:
          J.push([";", ";", W, R - V, R]);
          break;
        case v:
          J.push(["(", "(", W, R - V, R]);
          break;
        case S:
          J.push([")", ")", W, R - V, R]);
          break;
        case r:
        case i:
          K = q === r ? "'" : '"', X = R;
          do
            for (Fe = !1, X = L.indexOf(K, X + 1), X === -1 && Se("quote", K), mt = X; L.charCodeAt(mt - 1) === n; )
              mt -= 1, Fe = !Fe;
          while (Fe);
          J.push(["string", L.slice(R, X + 1), W, R - V, W, X - V, R]), R = X;
          break;
        case I:
          B.lastIndex = R + 1, B.test(L), B.lastIndex === 0 ? X = L.length - 1 : X = B.lastIndex - 2, J.push(["at-word", L.slice(R, X + 1), W, R - V, W, X - V, R]), R = X;
          break;
        case n:
          for (X = R, Le = !0; L.charCodeAt(X + 1) === n; )
            X += 1, Le = !Le;
          q = L.charCodeAt(X + 1), Le && q !== s && q !== o && q !== a && q !== c && q !== h && q !== u && (X += 1), J.push(["word", L.slice(R, X + 1), W, R - V, W, X - V, R]), R = X;
          break;
        default:
          q === s && L.charCodeAt(R + 1) === C ? (X = L.indexOf("*/", R + 2) + 1, X === 0 && Se("comment", "*/"), ve = L.slice(R, X + 1), Oe = ve.split(`
`), Ae = Oe.length - 1, Ae > 0 ? (ze = W + Ae, et = X - Oe[Ae].length) : (ze = W, et = V), J.push(["comment", ve, W, R - V, ze, X - et, R]), V = et, W = ze, R = X) : (Q.lastIndex = R + 1, Q.test(L), Q.lastIndex === 0 ? X = L.length - 1 : X = Q.lastIndex - 2, J.push(["word", L.slice(R, X + 1), W, R - V, W, X - V, R]), R = X);
          break;
      }
      R++;
    }
    return J;
  }
  e.exports = t.default;
}), M5 = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function V(W, R) {
      for (var Se = 0; Se < R.length; Se++) {
        var De = R[Se];
        De.enumerable = De.enumerable || !1, De.configurable = !0, "value" in De && (De.writable = !0), Object.defineProperty(W, De.key, De);
      }
    }
    return function(W, R, Se) {
      return R && V(W.prototype, R), Se && V(W, Se), W;
    };
  }(), i = D2(), n = Fe(i), s = v2(), a = Fe(s), o = S2(), u = Fe(o), c = w5(), h = Fe(c), d = C5(), m = Fe(d), y = A5(), O = Fe(y), b = E5(), v = Fe(b), S = k5(), x = Fe(S), w = T5(), k = Fe(w), C = P5(), E = Fe(C), P = F5(), I = Fe(P), B = $5(), Q = Fe(B), j = B5(), G = Fe(j), J = I5(), L = Fe(J), q = N5(), X = Fe(q), K = _5(), Oe = Fe(K), Ae = Q5(), ve = Fe(Ae), Le = ur(), ze = et(Le);
  function et(V) {
    if (V && V.__esModule)
      return V;
    var W = {};
    if (V != null)
      for (var R in V)
        Object.prototype.hasOwnProperty.call(V, R) && (W[R] = V[R]);
    return W.default = V, W;
  }
  function Fe(V) {
    return V && V.__esModule ? V : { default: V };
  }
  function mt(V, W) {
    if (!(V instanceof W))
      throw new TypeError("Cannot call a class as a function");
  }
  var ue = function() {
    function V(W) {
      mt(this, V), this.input = W, this.lossy = W.options.lossless === !1, this.position = 0, this.root = new h.default();
      var R = new m.default();
      return this.root.append(R), this.current = R, this.lossy ? this.tokens = (0, ve.default)({ safe: W.safe, css: W.css.trim() }) : this.tokens = (0, ve.default)(W), this.loop();
    }
    return V.prototype.attribute = function() {
      var W = "", R = void 0, Se = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; )
        W += this.tokens[this.position][1], this.position++;
      this.position === this.tokens.length && !~W.indexOf("]") && this.error("Expected a closing square bracket.");
      var De = W.split(/((?:[*~^$|]?=))([^]*)/), Te = De[0].split(/(\|)/g), tr = { operator: De[1], value: De[2], source: { start: { line: Se[2], column: Se[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: Se[4] };
      if (Te.length > 1 ? (Te[0] === "" && (Te[0] = !0), tr.attribute = this.parseValue(Te[2]), tr.namespace = this.parseNamespace(Te[0])) : tr.attribute = this.parseValue(De[0]), R = new Q.default(tr), De[2]) {
        var Mt = De[2].split(/(\s+i\s*?)$/), wt = Mt[0].trim();
        R.value = this.lossy ? wt : Mt[0], Mt[1] && (R.insensitive = !0, this.lossy || (R.raws.insensitive = Mt[1])), R.quoted = wt[0] === "'" || wt[0] === '"', R.raws.unquoted = R.quoted ? wt.slice(1, -1) : wt;
      }
      this.newNode(R), this.position++;
    }, V.prototype.combinator = function() {
      if (this.currToken[1] === "|")
        return this.namespace();
      for (var W = new L.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); )
        this.nextToken && this.nextToken[0] === "combinator" ? (W.spaces.before = this.parseSpace(this.currToken[1]), W.source.start.line = this.nextToken[2], W.source.start.column = this.nextToken[3], W.source.end.column = this.nextToken[3], W.source.end.line = this.nextToken[2], W.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? W.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? W.value = this.currToken[1] : this.currToken[0] === "space" && (W.value = this.parseSpace(this.currToken[1], " ")), this.position++;
      return this.newNode(W);
    }, V.prototype.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = !0, this.position++;
        return;
      }
      var W = new m.default();
      this.current.parent.append(W), this.current = W, this.position++;
    }, V.prototype.comment = function() {
      var W = new v.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
      this.newNode(W), this.position++;
    }, V.prototype.error = function(W) {
      throw new this.input.error(W);
    }, V.prototype.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.");
    }, V.prototype.missingParenthesis = function() {
      return this.error("Expected opening parenthesis.");
    }, V.prototype.missingSquareBracket = function() {
      return this.error("Expected opening square bracket.");
    }, V.prototype.namespace = function() {
      var W = this.prevToken && this.prevToken[1] || !0;
      if (this.nextToken[0] === "word")
        return this.position++, this.word(W);
      if (this.nextToken[0] === "*")
        return this.position++, this.universal(W);
    }, V.prototype.nesting = function() {
      this.newNode(new X.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
    }, V.prototype.parentheses = function() {
      var W = this.current.last;
      if (W && W.type === ze.PSEUDO) {
        var R = new m.default(), Se = this.current;
        W.append(R), this.current = R;
        var De = 1;
        for (this.position++; this.position < this.tokens.length && De; )
          this.currToken[0] === "(" && De++, this.currToken[0] === ")" && De--, De ? this.parse() : (R.parent.source.end.line = this.currToken[2], R.parent.source.end.column = this.currToken[3], this.position++);
        De && this.error("Expected closing parenthesis."), this.current = Se;
      } else {
        var Te = 1;
        for (this.position++, W.value += "("; this.position < this.tokens.length && Te; )
          this.currToken[0] === "(" && Te++, this.currToken[0] === ")" && Te--, W.value += this.parseParenthesisToken(this.currToken), this.position++;
        Te && this.error("Expected closing parenthesis.");
      }
    }, V.prototype.pseudo = function() {
      for (var W = this, R = "", Se = this.currToken; this.currToken && this.currToken[0] === ":"; )
        R += this.currToken[1], this.position++;
      if (!this.currToken)
        return this.error("Expected pseudo-class or pseudo-element");
      if (this.currToken[0] === "word") {
        var De = void 0;
        this.splitWord(!1, function(Te, tr) {
          R += Te, De = new I.default({ value: R, source: { start: { line: Se[2], column: Se[3] }, end: { line: W.currToken[4], column: W.currToken[5] } }, sourceIndex: Se[4] }), W.newNode(De), tr > 1 && W.nextToken && W.nextToken[0] === "(" && W.error("Misplaced parenthesis.");
        });
      } else
        this.error('Unexpected "' + this.currToken[0] + '" found.');
    }, V.prototype.space = function() {
      var W = this.currToken;
      this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(W[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(W[1]), this.position++) : this.combinator();
    }, V.prototype.string = function() {
      var W = this.currToken;
      this.newNode(new E.default({ value: this.currToken[1], source: { start: { line: W[2], column: W[3] }, end: { line: W[4], column: W[5] } }, sourceIndex: W[6] })), this.position++;
    }, V.prototype.universal = function(W) {
      var R = this.nextToken;
      if (R && R[1] === "|")
        return this.position++, this.namespace();
      this.newNode(new G.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), W), this.position++;
    }, V.prototype.splitWord = function(W, R) {
      for (var Se = this, De = this.nextToken, Te = this.currToken[1]; De && De[0] === "word"; ) {
        this.position++;
        var tr = this.currToken[1];
        if (Te += tr, tr.lastIndexOf("\\") === tr.length - 1) {
          var Mt = this.nextToken;
          Mt && Mt[0] === "space" && (Te += this.parseSpace(Mt[1], " "), this.position++);
        }
        De = this.nextToken;
      }
      var wt = (0, a.default)(Te, "."), Ur = (0, a.default)(Te, "#"), fn = (0, a.default)(Te, "#{");
      fn.length && (Ur = Ur.filter(function(Pr) {
        return !~fn.indexOf(Pr);
      }));
      var cr = (0, Oe.default)((0, u.default)((0, n.default)([[0], wt, Ur])));
      cr.forEach(function(Pr, pi) {
        var mn = cr[pi + 1] || Te.length, qi = Te.slice(Pr, mn);
        if (pi === 0 && R)
          return R.call(Se, qi, cr.length);
        var Xi = void 0;
        ~wt.indexOf(Pr) ? Xi = new O.default({ value: qi.slice(1), source: { start: { line: Se.currToken[2], column: Se.currToken[3] + Pr }, end: { line: Se.currToken[4], column: Se.currToken[3] + (mn - 1) } }, sourceIndex: Se.currToken[6] + cr[pi] }) : ~Ur.indexOf(Pr) ? Xi = new x.default({ value: qi.slice(1), source: { start: { line: Se.currToken[2], column: Se.currToken[3] + Pr }, end: { line: Se.currToken[4], column: Se.currToken[3] + (mn - 1) } }, sourceIndex: Se.currToken[6] + cr[pi] }) : Xi = new k.default({ value: qi, source: { start: { line: Se.currToken[2], column: Se.currToken[3] + Pr }, end: { line: Se.currToken[4], column: Se.currToken[3] + (mn - 1) } }, sourceIndex: Se.currToken[6] + cr[pi] }), Se.newNode(Xi, W);
      }), this.position++;
    }, V.prototype.word = function(W) {
      var R = this.nextToken;
      return R && R[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(W);
    }, V.prototype.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(!0);
      return this.root;
    }, V.prototype.parse = function(W) {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parentheses();
          break;
        case ")":
          W && this.missingParenthesis();
          break;
        case "[":
          this.attribute();
          break;
        case "]":
          this.missingSquareBracket();
          break;
        case "at-word":
        case "word":
          this.word();
          break;
        case ":":
          this.pseudo();
          break;
        case ";":
          this.missingBackslash();
          break;
        case ",":
          this.comma();
          break;
        case "*":
          this.universal();
          break;
        case "&":
          this.nesting();
          break;
        case "combinator":
          this.combinator();
          break;
        case "string":
          this.string();
          break;
      }
    }, V.prototype.parseNamespace = function(W) {
      if (this.lossy && typeof W == "string") {
        var R = W.trim();
        return R.length ? R : !0;
      }
      return W;
    }, V.prototype.parseSpace = function(W, R) {
      return this.lossy ? R || "" : W;
    }, V.prototype.parseValue = function(W) {
      return this.lossy && W && typeof W == "string" ? W.trim() : W;
    }, V.prototype.parseParenthesisToken = function(W) {
      return this.lossy ? W[0] === "space" ? this.parseSpace(W[1], " ") : this.parseValue(W[1]) : W[1];
    }, V.prototype.newNode = function(W, R) {
      return R && (W.namespace = this.parseNamespace(R)), this.spaces && (W.spaces.before = this.spaces, this.spaces = ""), this.current.append(W);
    }, r(V, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), V;
  }();
  t.default = ue, e.exports = t.default;
}), L5 = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function u(c, h) {
      for (var d = 0; d < h.length; d++) {
        var m = h[d];
        m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(c, m.key, m);
      }
    }
    return function(c, h, d) {
      return h && u(c.prototype, h), d && u(c, d), c;
    };
  }(), i = M5(), n = s(i);
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function a(u, c) {
    if (!(u instanceof c))
      throw new TypeError("Cannot call a class as a function");
  }
  var o = function() {
    function u(c) {
      return a(this, u), this.func = c || function() {
      }, this;
    }
    return u.prototype.process = function(c) {
      var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, d = new n.default({ css: c, error: function(m) {
        throw new Error(m);
      }, options: h });
      return this.res = d, this.func(d), this;
    }, r(u, [{ key: "result", get: function() {
      return String(this.res);
    } }]), u;
  }();
  t.default = o, e.exports = t.default;
}), Li = re((t, e) => {
  var r = function(i, n) {
    let s = new i.constructor();
    for (let a in i) {
      if (!i.hasOwnProperty(a))
        continue;
      let o = i[a], u = typeof o;
      a === "parent" && u === "object" ? n && (s[a] = n) : a === "source" ? s[a] = o : o instanceof Array ? s[a] = o.map((c) => r(c, s)) : a !== "before" && a !== "after" && a !== "between" && a !== "semicolon" && (u === "object" && o !== null && (o = r(o)), s[a] = o);
    }
    return s;
  };
  e.exports = class {
    constructor(i) {
      i = i || {}, this.raws = { before: "", after: "" };
      for (let n in i)
        this[n] = i[n];
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    toString() {
      return [this.raws.before, String(this.value), this.raws.after].join("");
    }
    clone(i) {
      i = i || {};
      let n = r(this);
      for (let s in i)
        n[s] = i[s];
      return n;
    }
    cloneBefore(i) {
      i = i || {};
      let n = this.clone(i);
      return this.parent.insertBefore(this, n), n;
    }
    cloneAfter(i) {
      i = i || {};
      let n = this.clone(i);
      return this.parent.insertAfter(this, n), n;
    }
    replaceWith() {
      let i = Array.prototype.slice.call(arguments);
      if (this.parent) {
        for (let n of i)
          this.parent.insertBefore(this, n);
        this.remove();
      }
      return this;
    }
    moveTo(i) {
      return this.cleanRaws(this.root() === i.root()), this.remove(), i.append(this), this;
    }
    moveBefore(i) {
      return this.cleanRaws(this.root() === i.root()), this.remove(), i.parent.insertBefore(i, this), this;
    }
    moveAfter(i) {
      return this.cleanRaws(this.root() === i.root()), this.remove(), i.parent.insertAfter(i, this), this;
    }
    next() {
      let i = this.parent.index(this);
      return this.parent.nodes[i + 1];
    }
    prev() {
      let i = this.parent.index(this);
      return this.parent.nodes[i - 1];
    }
    toJSON() {
      let i = {};
      for (let n in this) {
        if (!this.hasOwnProperty(n) || n === "parent")
          continue;
        let s = this[n];
        s instanceof Array ? i[n] = s.map((a) => typeof a == "object" && a.toJSON ? a.toJSON() : a) : typeof s == "object" && s.toJSON ? i[n] = s.toJSON() : i[n] = s;
      }
      return i;
    }
    root() {
      let i = this;
      for (; i.parent; )
        i = i.parent;
      return i;
    }
    cleanRaws(i) {
      delete this.raws.before, delete this.raws.after, i || delete this.raws.between;
    }
    positionInside(i) {
      let n = this.toString(), s = this.source.start.column, a = this.source.start.line;
      for (let o = 0; o < i; o++)
        n[o] === `
` ? (s = 1, a += 1) : s += 1;
      return { line: a, column: s };
    }
    positionBy(i) {
      let n = this.source.start;
      if (Object(i).index)
        n = this.positionInside(i.index);
      else if (Object(i).word) {
        let s = this.toString().indexOf(i.word);
        s !== -1 && (n = this.positionInside(s));
      }
      return n;
    }
  };
}), kr = re((t, e) => {
  var r = Li(), i = class extends r {
    constructor(n) {
      super(n), this.nodes || (this.nodes = []);
    }
    push(n) {
      return n.parent = this, this.nodes.push(n), this;
    }
    each(n) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let s = this.lastEach, a, o;
      if (this.indexes[s] = 0, !!this.nodes) {
        for (; this.indexes[s] < this.nodes.length && (a = this.indexes[s], o = n(this.nodes[a], a), o !== !1); )
          this.indexes[s] += 1;
        return delete this.indexes[s], o;
      }
    }
    walk(n) {
      return this.each((s, a) => {
        let o = n(s, a);
        return o !== !1 && s.walk && (o = s.walk(n)), o;
      });
    }
    walkType(n, s) {
      if (!n || !s)
        throw new Error("Parameters {type} and {callback} are required.");
      let a = typeof n == "function";
      return this.walk((o, u) => {
        if (a && o instanceof n || !a && o.type === n)
          return s.call(this, o, u);
      });
    }
    append(n) {
      return n.parent = this, this.nodes.push(n), this;
    }
    prepend(n) {
      return n.parent = this, this.nodes.unshift(n), this;
    }
    cleanRaws(n) {
      if (super.cleanRaws(n), this.nodes)
        for (let s of this.nodes)
          s.cleanRaws(n);
    }
    insertAfter(n, s) {
      let a = this.index(n), o;
      this.nodes.splice(a + 1, 0, s);
      for (let u in this.indexes)
        o = this.indexes[u], a <= o && (this.indexes[u] = o + this.nodes.length);
      return this;
    }
    insertBefore(n, s) {
      let a = this.index(n), o;
      this.nodes.splice(a, 0, s);
      for (let u in this.indexes)
        o = this.indexes[u], a <= o && (this.indexes[u] = o + this.nodes.length);
      return this;
    }
    removeChild(n) {
      n = this.index(n), this.nodes[n].parent = void 0, this.nodes.splice(n, 1);
      let s;
      for (let a in this.indexes)
        s = this.indexes[a], s >= n && (this.indexes[a] = s - 1);
      return this;
    }
    removeAll() {
      for (let n of this.nodes)
        n.parent = void 0;
      return this.nodes = [], this;
    }
    every(n) {
      return this.nodes.every(n);
    }
    some(n) {
      return this.nodes.some(n);
    }
    index(n) {
      return typeof n == "number" ? n : this.nodes.indexOf(n);
    }
    get first() {
      if (this.nodes)
        return this.nodes[0];
    }
    get last() {
      if (this.nodes)
        return this.nodes[this.nodes.length - 1];
    }
    toString() {
      let n = this.nodes.map(String).join("");
      return this.value && (n = this.value + n), this.raws.before && (n = this.raws.before + n), this.raws.after && (n += this.raws.after), n;
    }
  };
  i.registerWalker = (n) => {
    let s = "walk" + n.name;
    s.lastIndexOf("s") !== s.length - 1 && (s += "s"), !i.prototype[s] && (i.prototype[s] = function(a) {
      return this.walkType(n, a);
    });
  }, e.exports = i;
}), R5 = re((t, e) => {
  var r = kr();
  e.exports = class extends r {
    constructor(i) {
      super(i), this.type = "root";
    }
  };
}), j5 = re((t, e) => {
  var r = kr();
  e.exports = class extends r {
    constructor(i) {
      super(i), this.type = "value", this.unbalanced = 0;
    }
  };
}), Z5 = re((t, e) => {
  var r = kr(), i = class extends r {
    constructor(n) {
      super(n), this.type = "atword";
    }
    toString() {
      return this.quoted && this.raws.quote, [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
    }
  };
  r.registerWalker(i), e.exports = i;
}), W5 = re((t, e) => {
  var r = kr(), i = Li(), n = class extends i {
    constructor(s) {
      super(s), this.type = "colon";
    }
  };
  r.registerWalker(n), e.exports = n;
}), q5 = re((t, e) => {
  var r = kr(), i = Li(), n = class extends i {
    constructor(s) {
      super(s), this.type = "comma";
    }
  };
  r.registerWalker(n), e.exports = n;
}), X5 = re((t, e) => {
  var r = kr(), i = Li(), n = class extends i {
    constructor(s) {
      super(s), this.type = "comment", this.inline = Object(s).inline || !1;
    }
    toString() {
      return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
    }
  };
  r.registerWalker(n), e.exports = n;
}), V5 = re((t, e) => {
  var r = kr(), i = class extends r {
    constructor(n) {
      super(n), this.type = "func", this.unbalanced = -1;
    }
  };
  r.registerWalker(i), e.exports = i;
}), Y5 = re((t, e) => {
  var r = kr(), i = Li(), n = class extends i {
    constructor(s) {
      super(s), this.type = "number", this.unit = Object(s).unit || "";
    }
    toString() {
      return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
    }
  };
  r.registerWalker(n), e.exports = n;
}), U5 = re((t, e) => {
  var r = kr(), i = Li(), n = class extends i {
    constructor(s) {
      super(s), this.type = "operator";
    }
  };
  r.registerWalker(n), e.exports = n;
}), z5 = re((t, e) => {
  var r = kr(), i = Li(), n = class extends i {
    constructor(s) {
      super(s), this.type = "paren", this.parenType = "";
    }
  };
  r.registerWalker(n), e.exports = n;
}), G5 = re((t, e) => {
  var r = kr(), i = Li(), n = class extends i {
    constructor(s) {
      super(s), this.type = "string";
    }
    toString() {
      let s = this.quoted ? this.raws.quote : "";
      return [this.raws.before, s, this.value + "", s, this.raws.after].join("");
    }
  };
  r.registerWalker(n), e.exports = n;
}), H5 = re((t, e) => {
  var r = kr(), i = Li(), n = class extends i {
    constructor(s) {
      super(s), this.type = "word";
    }
  };
  r.registerWalker(n), e.exports = n;
}), J5 = re((t, e) => {
  var r = kr(), i = Li(), n = class extends i {
    constructor(s) {
      super(s), this.type = "unicode-range";
    }
  };
  r.registerWalker(n), e.exports = n;
}), K5 = re((t, e) => {
  var r = class extends Error {
    constructor(i) {
      super(i), this.name = this.constructor.name, this.message = i || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(i).stack;
    }
  };
  e.exports = r;
}), eN = re((t, e) => {
  var r = /[ \n\t\r\{\(\)'"\\;,/]/g, i = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, n = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, s = /^[a-z0-9]/i, a = /^[a-f0-9?\-]/i, o = K5();
  e.exports = function(u, c) {
    c = c || {};
    let h = [], d = u.valueOf(), m = d.length, y = -1, O = 1, b = 0, v = 0, S = null, x, w, k, C, E, P, I, B, Q, j, G;
    function J(L) {
      let q = `Unclosed ${L} at line: ${O}, column: ${b - y}, token: ${b}`;
      throw new o(q);
    }
    for (; b < m; ) {
      switch (x = d.charCodeAt(b), x === 10 && (y = b, O += 1), x) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12:
          w = b;
          do
            w += 1, x = d.charCodeAt(w), x === 10 && (y = w, O += 1);
          while (x === 32 || x === 10 || x === 9 || x === 13 || x === 12);
          h.push(["space", d.slice(b, w), O, b - y, O, w - y, b]), b = w - 1;
          break;
        case 58:
          w = b + 1, h.push(["colon", d.slice(b, w), O, b - y, O, w - y, b]), b = w - 1;
          break;
        case 44:
          w = b + 1, h.push(["comma", d.slice(b, w), O, b - y, O, w - y, b]), b = w - 1;
          break;
        case 123:
          h.push(["{", "{", O, b - y, O, w - y, b]);
          break;
        case 125:
          h.push(["}", "}", O, b - y, O, w - y, b]);
          break;
        case 40:
          v++, S = !S && v === 1 && h.length > 0 && h[h.length - 1][0] === "word" && h[h.length - 1][1] === "url", h.push(["(", "(", O, b - y, O, w - y, b]);
          break;
        case 41:
          v--, S = S && v > 0, h.push([")", ")", O, b - y, O, w - y, b]);
          break;
        case 39:
        case 34:
          k = x === 39 ? "'" : '"', w = b;
          do
            for (Q = !1, w = d.indexOf(k, w + 1), w === -1 && J("quote"), j = w; d.charCodeAt(j - 1) === 92; )
              j -= 1, Q = !Q;
          while (Q);
          h.push(["string", d.slice(b, w + 1), O, b - y, O, w - y, b]), b = w;
          break;
        case 64:
          r.lastIndex = b + 1, r.test(d), r.lastIndex === 0 ? w = d.length - 1 : w = r.lastIndex - 2, h.push(["atword", d.slice(b, w + 1), O, b - y, O, w - y, b]), b = w;
          break;
        case 92:
          w = b, x = d.charCodeAt(w + 1), h.push(["word", d.slice(b, w + 1), O, b - y, O, w - y, b]), b = w;
          break;
        case 43:
        case 45:
        case 42:
          if (w = b + 1, G = d.slice(b + 1, w + 1), d.slice(b - 1, b), x === 45 && G.charCodeAt(0) === 45) {
            w++, h.push(["word", d.slice(b, w), O, b - y, O, w - y, b]), b = w - 1;
            break;
          }
          h.push(["operator", d.slice(b, w), O, b - y, O, w - y, b]), b = w - 1;
          break;
        default:
          if (x === 47 && (d.charCodeAt(b + 1) === 42 || c.loose && !S && d.charCodeAt(b + 1) === 47)) {
            if (d.charCodeAt(b + 1) === 42)
              w = d.indexOf("*/", b + 2) + 1, w === 0 && J("comment");
            else {
              let L = d.indexOf(`
`, b + 2);
              w = L !== -1 ? L - 1 : m;
            }
            P = d.slice(b, w + 1), C = P.split(`
`), E = C.length - 1, E > 0 ? (I = O + E, B = w - C[E].length) : (I = O, B = y), h.push(["comment", P, O, b - y, I, w - B, b]), y = B, O = I, b = w;
          } else if (x === 35 && !s.test(d.slice(b + 1, b + 2)))
            w = b + 1, h.push(["#", d.slice(b, w), O, b - y, O, w - y, b]), b = w - 1;
          else if ((x === 117 || x === 85) && d.charCodeAt(b + 1) === 43) {
            w = b + 2;
            do
              w += 1, x = d.charCodeAt(w);
            while (w < m && a.test(d.slice(w, w + 1)));
            h.push(["unicoderange", d.slice(b, w), O, b - y, O, w - y, b]), b = w - 1;
          } else if (x === 47)
            w = b + 1, h.push(["operator", d.slice(b, w), O, b - y, O, w - y, b]), b = w - 1;
          else {
            let L = i;
            if (x >= 48 && x <= 57 && (L = n), L.lastIndex = b + 1, L.test(d), L.lastIndex === 0 ? w = d.length - 1 : w = L.lastIndex - 2, L === n || x === 46) {
              let q = d.charCodeAt(w), X = d.charCodeAt(w + 1), K = d.charCodeAt(w + 2);
              (q === 101 || q === 69) && (X === 45 || X === 43) && K >= 48 && K <= 57 && (n.lastIndex = w + 2, n.test(d), n.lastIndex === 0 ? w = d.length - 1 : w = n.lastIndex - 2);
            }
            h.push(["word", d.slice(b, w + 1), O, b - y, O, w - y, b]), b = w;
          }
          break;
      }
      b++;
    }
    return h;
  };
}), tN = re((t, e) => {
  var r = class extends Error {
    constructor(i) {
      super(i), this.name = this.constructor.name, this.message = i || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(i).stack;
    }
  };
  e.exports = r;
}), rN = re((t, e) => {
  var r = R5(), i = j5(), n = Z5(), s = W5(), a = q5(), o = X5(), u = V5(), c = Y5(), h = U5(), d = z5(), m = G5(), y = H5(), O = J5(), b = eN(), v = D2(), S = v2(), x = S2(), w = tN();
  function k(C) {
    return C.sort((E, P) => E - P);
  }
  e.exports = class {
    constructor(C, E) {
      let P = { loose: !1 };
      this.cache = [], this.input = C, this.options = Object.assign({}, P, E), this.position = 0, this.unbalanced = 0, this.root = new r();
      let I = new i();
      this.root.append(I), this.current = I, this.tokens = b(C, this.options);
    }
    parse() {
      return this.loop();
    }
    colon() {
      let C = this.currToken;
      this.newNode(new s({ value: C[1], source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6] })), this.position++;
    }
    comma() {
      let C = this.currToken;
      this.newNode(new a({ value: C[1], source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6] })), this.position++;
    }
    comment() {
      let C = !1, E = this.currToken[1].replace(/\/\*|\*\//g, ""), P;
      this.options.loose && E.startsWith("//") && (E = E.substring(2), C = !0), P = new o({ value: E, inline: C, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] }), this.newNode(P), this.position++;
    }
    error(C, E) {
      throw new w(C + ` at line: ${E[2]}, column ${E[3]}`);
    }
    loop() {
      for (; this.position < this.tokens.length; )
        this.parseTokens();
      return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
    }
    operator() {
      let C = this.currToken[1], E;
      if (C === "+" || C === "-") {
        if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? this.prevToken[0] !== "space" && this.prevToken[0] !== "(" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "word" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(" && this.error("Syntax Error", this.currToken) : (this.nextToken[0] === "space" || this.nextToken[0] === "operator" || this.prevToken[0] === "operator") && this.error("Syntax Error", this.currToken)), this.options.loose) {
          if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word")
            return this.word();
        } else if (this.nextToken[0] === "word")
          return this.word();
      }
      return E = new h({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), this.position++, this.newNode(E);
    }
    parseTokens() {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "colon":
          this.colon();
          break;
        case "comma":
          this.comma();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parenOpen();
          break;
        case ")":
          this.parenClose();
          break;
        case "atword":
        case "word":
          this.word();
          break;
        case "operator":
          this.operator();
          break;
        case "string":
          this.string();
          break;
        case "unicoderange":
          this.unicodeRange();
          break;
        default:
          this.word();
          break;
      }
    }
    parenOpen() {
      let C = 1, E = this.position + 1, P = this.currToken, I;
      for (; E < this.tokens.length && C; ) {
        let B = this.tokens[E];
        B[0] === "(" && C++, B[0] === ")" && C--, E++;
      }
      if (C && this.error("Expected closing parenthesis", P), I = this.current.last, I && I.type === "func" && I.unbalanced < 0 && (I.unbalanced = 0, this.current = I), this.current.unbalanced++, this.newNode(new d({ value: P[1], source: { start: { line: P[2], column: P[3] }, end: { line: P[4], column: P[5] } }, sourceIndex: P[6] })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
        let B = this.nextToken, Q = this.currToken[1], j = { line: this.currToken[2], column: this.currToken[3] };
        for (; B && B[0] !== ")" && this.current.unbalanced; )
          this.position++, Q += this.currToken[1], B = this.nextToken;
        this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new y({ value: Q, source: { start: j, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
      }
    }
    parenClose() {
      let C = this.currToken;
      this.newNode(new d({ value: C[1], source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6] })), this.position++, !(this.position >= this.tokens.length - 1 && !this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", C), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
    }
    space() {
      let C = this.currToken;
      this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += C[1], this.position++) : (this.spaces = C[1], this.position++);
    }
    unicodeRange() {
      let C = this.currToken;
      this.newNode(new O({ value: C[1], source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6] })), this.position++;
    }
    splitWord() {
      let C = this.nextToken, E = this.currToken[1], P = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/, I = /^(?!\#([a-z0-9]+))[\#\{\}]/gi, B, Q;
      if (!I.test(E))
        for (; C && C[0] === "word"; ) {
          this.position++;
          let j = this.currToken[1];
          E += j, C = this.nextToken;
        }
      B = S(E, "@"), Q = k(x(v([[0], B]))), Q.forEach((j, G) => {
        let J = Q[G + 1] || E.length, L = E.slice(j, J), q;
        if (~B.indexOf(j))
          q = new n({ value: L.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + j }, end: { line: this.currToken[4], column: this.currToken[3] + (J - 1) } }, sourceIndex: this.currToken[6] + Q[G] });
        else if (P.test(this.currToken[1])) {
          let X = L.replace(P, "");
          q = new c({ value: L.replace(X, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + j }, end: { line: this.currToken[4], column: this.currToken[3] + (J - 1) } }, sourceIndex: this.currToken[6] + Q[G], unit: X });
        } else
          q = new (C && C[0] === "(" ? u : y)({ value: L, source: { start: { line: this.currToken[2], column: this.currToken[3] + j }, end: { line: this.currToken[4], column: this.currToken[3] + (J - 1) } }, sourceIndex: this.currToken[6] + Q[G] }), q.type === "word" ? (q.isHex = /^#(.+)/.test(L), q.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(L)) : this.cache.push(this.current);
        this.newNode(q);
      }), this.position++;
    }
    string() {
      let C = this.currToken, E = this.currToken[1], P = /^(\"|\')/, I = P.test(E), B = "", Q;
      I && (B = E.match(P)[0], E = E.slice(1, E.length - 1)), Q = new m({ value: E, source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6], quoted: I }), Q.raws.quote = B, this.newNode(Q), this.position++;
    }
    word() {
      return this.splitWord();
    }
    newNode(C) {
      return this.spaces && (C.raws.before += this.spaces, this.spaces = ""), this.current.append(C);
    }
    get currToken() {
      return this.tokens[this.position];
    }
    get nextToken() {
      return this.tokens[this.position + 1];
    }
    get prevToken() {
      return this.tokens[this.position - 1];
    }
  };
}), w2 = {};
l2(w2, { languages: () => U_, options: () => H_, parsers: () => ev, printers: () => F7 });
var iN = (t, e, r, i) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, i) : r.global ? e.replace(r, i) : e.split(r).join(i);
}, Tt = iN, C2 = "string", A2 = "array", E2 = "cursor", gg = "indent", yg = "align", k2 = "trim", Og = "group", sl = "fill", Wh = "if-break", T2 = "indent-if-break", P2 = "line-suffix", F2 = "line-suffix-boundary", Ua = "line", $2 = "label", xg = "break-parent", B2 = /* @__PURE__ */ new Set([E2, gg, yg, k2, Og, sl, Wh, T2, P2, F2, Ua, $2, xg]);
function nN(t) {
  if (typeof t == "string")
    return C2;
  if (Array.isArray(t))
    return A2;
  if (!t)
    return;
  let { type: e } = t;
  if (B2.has(e))
    return e;
}
var I2 = nN, sN = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function aN(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (I2(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let i = sN([...B2].map((n) => `'${n}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${i}.`;
}
var oN = class extends Error {
  constructor(r) {
    super(aN(r));
    Gr(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, lN = oN, uN = () => {
}, cN = uN;
function mr(t) {
  return { type: gg, contents: t };
}
function N2(t, e) {
  return { type: yg, contents: e, n: t };
}
function Ir(t, e = {}) {
  return cN(e.expandedStates), { type: Og, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function hN(t) {
  return N2({ type: "root" }, t);
}
function Tc(t) {
  return N2(-1, t);
}
function Hd(t) {
  return { type: sl, parts: t };
}
function _2(t, e = "", r = {}) {
  return { type: Wh, breakContents: t, flatContents: e, groupId: r.groupId };
}
var bg = { type: xg }, pN = { type: Ua, hard: !0 }, Ut = { type: Ua }, Kr = { type: Ua, soft: !0 }, ct = [pN, bg];
function ds(t, e) {
  let r = [];
  for (let i = 0; i < e.length; i++)
    i !== 0 && r.push(t), r.push(e[i]);
  return r;
}
var dN = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, al = dN, fN = (t) => {
  if (Array.isArray(t))
    return t;
  if (t.type !== sl)
    throw new Error(`Expect doc to be 'array' or '${sl}'.`);
  return t.parts;
};
function mN(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return i(t);
  function i(s) {
    if (r.has(s))
      return r.get(s);
    let a = n(s);
    return r.set(s, a), a;
  }
  function n(s) {
    switch (I2(s)) {
      case A2:
        return e(s.map(i));
      case sl:
        return e({ ...s, parts: s.parts.map(i) });
      case Wh:
        return e({ ...s, breakContents: i(s.breakContents), flatContents: i(s.flatContents) });
      case Og: {
        let { expandedStates: a, contents: o } = s;
        return a ? (a = a.map(i), o = a[0]) : o = i(o), e({ ...s, contents: o, expandedStates: a });
      }
      case yg:
      case gg:
      case T2:
      case $2:
      case P2:
        return e({ ...s, contents: i(s.contents) });
      case C2:
      case E2:
      case k2:
      case F2:
      case Ua:
      case xg:
        return e(s);
      default:
        throw new lN(s);
    }
  }
}
function gN(t) {
  return t.type === Ua && !t.hard ? t.soft ? "" : " " : t.type === Wh ? t.flatContents : t;
}
function yN(t) {
  return mN(t, gN);
}
function ON(t) {
  return Array.isArray(t) && t.length > 0;
}
var qh = ON, vu = "'", pO = '"';
function xN(t, e) {
  let r = e === !0 || e === vu ? vu : pO, i = r === vu ? pO : vu, n = 0, s = 0;
  for (let a of t)
    a === r ? n++ : a === i && s++;
  return n > s ? i : r;
}
var bN = xN;
function DN(t, e, r) {
  let i = e === '"' ? "'" : '"', n = Tt(!1, t, /\\(.)|(["'])/gs, (s, a, o) => a === i ? a : o === e ? "\\" + o : o || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(a) ? a : "\\" + a));
  return e + n + e;
}
var vN = DN;
function SN(t, e) {
  let r = t.slice(1, -1), i = e.parser === "json" || e.parser === "jsonc" || e.parser === "json5" && e.quoteProps === "preserve" && !e.singleQuote ? '"' : e.__isInHtmlAttribute ? "'" : bN(r, e.singleQuote);
  return vN(r, i, !(e.parser === "css" || e.parser === "less" || e.parser === "scss" || e.__embeddedInHtml));
}
var Q2 = SN, wN = class extends Error {
  constructor(r, i, n = "type") {
    super(`Unexpected ${i} node ${n}: ${JSON.stringify(r[n])}.`);
    Gr(this, "name", "UnexpectedNodeError");
    this.node = r;
  }
}, CN = wN;
function AN(t) {
  return (t == null ? void 0 : t.type) === "front-matter";
}
var Pc = AN, EN = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma", "spaces"]);
function M2(t, e, r) {
  if (Pc(t) && t.lang === "yaml" && delete e.value, t.type === "css-comment" && r.type === "css-root" && r.nodes.length > 0 && ((r.nodes[0] === t || Pc(r.nodes[0]) && r.nodes[1] === t) && (delete e.text, /^\*\s*@(?:format|prettier)\s*$/.test(t.text)) || r.type === "css-root" && al(!1, r.nodes, -1) === t))
    return null;
  if (t.type === "value-root" && delete e.text, (t.type === "media-query" || t.type === "media-query-list" || t.type === "media-feature-expression") && delete e.value, t.type === "css-rule" && delete e.params, t.type === "selector-combinator" && (e.value = Tt(!1, e.value, /\s+/g, " ")), t.type === "media-feature" && (e.value = Tt(!1, e.value, " ", "")), (t.type === "value-word" && (t.isColor && t.isHex || ["initial", "inherit", "unset", "revert"].includes(e.value.toLowerCase())) || t.type === "media-feature" || t.type === "selector-root-invalid" || t.type === "selector-pseudo") && (e.value = e.value.toLowerCase()), t.type === "css-decl" && (e.prop = e.prop.toLowerCase()), (t.type === "css-atrule" || t.type === "css-import") && (e.name = e.name.toLowerCase()), t.type === "value-number" && (e.unit = e.unit.toLowerCase()), t.type === "value-unknown" && (e.value = Tt(!1, e.value, /;$/g, "")), (t.type === "media-feature" || t.type === "media-keyword" || t.type === "media-type" || t.type === "media-unknown" || t.type === "media-url" || t.type === "media-value" || t.type === "selector-attribute" || t.type === "selector-string" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "value-string") && e.value && (e.value = kN(e.value)), t.type === "selector-attribute" && (e.attribute = e.attribute.trim(), e.namespace && typeof e.namespace == "string" && (e.namespace = e.namespace.trim(), e.namespace.length === 0 && (e.namespace = !0)), e.value && (e.value = Tt(!1, e.value.trim(), /^["']|["']$/g, ""), delete e.quoted)), (t.type === "media-value" || t.type === "media-type" || t.type === "value-number" || t.type === "selector-root-invalid" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "selector-tag") && e.value && (e.value = Tt(!1, e.value, /([\d+.e-]+)([a-z]*)/gi, (i, n, s) => {
    let a = Number(n);
    return Number.isNaN(a) ? i : a + s.toLowerCase();
  })), t.type === "selector-tag") {
    let i = t.value.toLowerCase();
    ["from", "to"].includes(i) && (e.value = i);
  }
  if (t.type === "css-atrule" && t.name.toLowerCase() === "supports" && delete e.value, t.type === "selector-unknown" && delete e.value, t.type === "value-comma_group") {
    let i = t.groups.findIndex((n) => n.type === "value-number" && n.unit === "...");
    i !== -1 && (e.groups[i].unit = "", e.groups.splice(i + 1, 0, { type: "value-word", value: "...", isColor: !1, isHex: !1 }));
  }
  if (t.type === "value-comma_group" && t.groups.some((i) => i.type === "value-atword" && i.value.endsWith("[") || i.type === "value-word" && i.value.startsWith("]")))
    return { type: "value-atword", value: t.groups.map((i) => i.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
}
M2.ignoredProperties = EN;
function kN(t) {
  return Tt(!1, Tt(!1, t, "'", '"'), /\\([^\da-f])/gi, "$1");
}
var TN = M2;
async function PN(t, e) {
  if (t.lang === "yaml") {
    let r = t.value.trim(), i = r ? await e(r, { parser: "yaml" }) : "";
    return hN([t.startDelimiter, ct, i, i ? ct : "", t.endDelimiter]);
  }
}
var FN = PN;
function L2(t) {
  let { node: e } = t;
  if (e.type === "front-matter")
    return async (r) => {
      let i = await FN(e, r);
      return i ? [i, ct] : void 0;
    };
}
L2.getVisitorKeys = (t) => t.type === "css-root" ? ["frontMatter"] : [];
var $N = L2, yo = null;
function Xo(t) {
  if (yo !== null && typeof yo.property) {
    let e = yo;
    return yo = Xo.prototype = null, e;
  }
  return yo = Xo.prototype = t ?? /* @__PURE__ */ Object.create(null), new Xo();
}
var BN = 10;
for (let t = 0; t <= BN; t++)
  Xo();
function IN(t) {
  return Xo(t);
}
function NN(t, e = "type") {
  IN(t);
  function r(i) {
    let n = i[e], s = t[n];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: i });
    return s;
  }
  return r;
}
var _N = NN, QN = { "front-matter": [], "css-root": ["frontMatter", "nodes"], "css-comment": [], "css-rule": ["selector", "nodes"], "css-decl": ["value", "selector", "nodes"], "css-atrule": ["selector", "params", "value", "nodes"], "media-query-list": ["nodes"], "media-query": ["nodes"], "media-type": [], "media-feature-expression": ["nodes"], "media-feature": [], "media-colon": [], "media-value": [], "media-keyword": [], "media-url": [], "media-unknown": [], "selector-root": ["nodes"], "selector-selector": ["nodes"], "selector-comment": [], "selector-string": [], "selector-tag": [], "selector-id": [], "selector-class": [], "selector-attribute": [], "selector-combinator": ["nodes"], "selector-universal": [], "selector-pseudo": ["nodes"], "selector-nesting": [], "selector-unknown": [], "value-value": ["group"], "value-root": ["group"], "value-comment": [], "value-comma_group": ["groups"], "value-paren_group": ["open", "groups", "close"], "value-func": ["group"], "value-paren": [], "value-number": [], "value-operator": [], "value-word": [], "value-colon": [], "value-comma": [], "value-string": [], "value-atword": [], "value-unicode-range": [], "value-unknown": [] }, MN = QN, LN = _N(MN), RN = LN;
function jN(t, e) {
  let r = 0;
  for (let i = 0; i < t.line - 1; ++i)
    r = e.indexOf(`
`, r) + 1;
  return r + t.column;
}
var R2 = jN;
function Dg(t) {
  return (e, r, i) => {
    let n = !!(i != null && i.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, a = r;
    for (; a >= 0 && a < s; ) {
      let o = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(o))
          return a;
      } else if (!t.includes(o))
        return a;
      n ? a-- : a++;
    }
    return a === -1 || a === s ? a : !1;
  };
}
var j2 = Dg(" 	"), ZN = Dg(",; 	"), Z2 = Dg(/[^\n\r]/);
function W2(t, e) {
  var r, i, n;
  if (typeof ((i = (r = t.source) == null ? void 0 : r.start) == null ? void 0 : i.offset) == "number")
    return t.source.start.offset;
  if (typeof t.sourceIndex == "number")
    return t.sourceIndex;
  if ((n = t.source) != null && n.start)
    return R2(t.source.start, e);
  throw Object.assign(new Error("Can not locate node."), { node: t });
}
function vg(t, e) {
  var r, i;
  if (t.type === "css-comment" && t.inline)
    return Z2(e, t.source.startOffset);
  if (typeof ((i = (r = t.source) == null ? void 0 : r.end) == null ? void 0 : i.offset) == "number")
    return t.source.end.offset;
  if (t.source) {
    if (t.source.end)
      return R2(t.source.end, e);
    if (qh(t.nodes))
      return vg(al(!1, t.nodes, -1), e);
  }
  return null;
}
function q2(t, e) {
  t.source && (t.source.startOffset = W2(t, e), t.source.endOffset = vg(t, e));
  for (let r in t) {
    let i = t[r];
    r === "source" || !i || typeof i != "object" || (i.type === "value-root" || i.type === "value-unknown" ? X2(i, WN(t), i.text || i.value) : q2(i, e));
  }
}
function X2(t, e, r) {
  t.source && (t.source.startOffset = W2(t, r) + e, t.source.endOffset = vg(t, r) + e);
  for (let i in t) {
    let n = t[i];
    i === "source" || !n || typeof n != "object" || X2(n, e, r);
  }
}
function WN(t) {
  var e;
  let r = t.source.startOffset;
  return typeof t.prop == "string" && (r += t.prop.length), t.type === "css-atrule" && typeof t.name == "string" && (r += 1 + t.name.length + t.raws.afterName.match(/^\s*:?\s*/)[0].length), t.type !== "css-atrule" && typeof ((e = t.raws) == null ? void 0 : e.between) == "string" && (r += t.raws.between.length), r;
}
function qN(t) {
  let e = "initial", r = "initial", i, n = !1, s = [];
  for (let a = 0; a < t.length; a++) {
    let o = t[a];
    switch (e) {
      case "initial":
        if (o === "'") {
          e = "single-quotes";
          continue;
        }
        if (o === '"') {
          e = "double-quotes";
          continue;
        }
        if ((o === "u" || o === "U") && t.slice(a, a + 4).toLowerCase() === "url(") {
          e = "url", a += 3;
          continue;
        }
        if (o === "*" && t[a - 1] === "/") {
          e = "comment-block";
          continue;
        }
        if (o === "/" && t[a - 1] === "/") {
          e = "comment-inline", i = a - 1;
          continue;
        }
        continue;
      case "single-quotes":
        if (o === "'" && t[a - 1] !== "\\" && (e = r, r = "initial"), o === `
` || o === "\r")
          return t;
        continue;
      case "double-quotes":
        if (o === '"' && t[a - 1] !== "\\" && (e = r, r = "initial"), o === `
` || o === "\r")
          return t;
        continue;
      case "url":
        if (o === ")" && (e = "initial"), o === `
` || o === "\r")
          return t;
        if (o === "'") {
          e = "single-quotes", r = "url";
          continue;
        }
        if (o === '"') {
          e = "double-quotes", r = "url";
          continue;
        }
        continue;
      case "comment-block":
        o === "/" && t[a - 1] === "*" && (e = "initial");
        continue;
      case "comment-inline":
        (o === '"' || o === "'" || o === "*") && (n = !0), (o === `
` || o === "\r") && (n && s.push([i, a]), e = "initial", n = !1);
        continue;
    }
  }
  for (let [a, o] of s)
    t = t.slice(0, a) + Tt(!1, t.slice(a, o), /["'*]/g, " ") + t.slice(o);
  return t;
}
function br(t) {
  var e;
  return (e = t.source) == null ? void 0 : e.startOffset;
}
function Or(t) {
  var e;
  return (e = t.source) == null ? void 0 : e.endOffset;
}
var Fc = Ms(i5(), 1);
function XN(t) {
  if (!t.startsWith("#!"))
    return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var VN = XN;
function V2(t) {
  let e = VN(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, Fc.extract)(t), { pragmas: i, comments: n } = (0, Fc.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: i, comments: n };
}
function YN(t) {
  let { pragmas: e } = V2(t);
  return Object.prototype.hasOwnProperty.call(e, "prettier") || Object.prototype.hasOwnProperty.call(e, "format");
}
function UN(t) {
  let { shebang: e, text: r, pragmas: i, comments: n } = V2(t), s = (0, Fc.strip)(r), a = (0, Fc.print)({ pragmas: { format: "", ...i }, comments: n.trimStart() });
  return (e ? `${e}
` : "") + a + (s.startsWith(`
`) ? `
` : `

`) + s;
}
var zN = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
function GN(t) {
  let e = t.match(zN);
  if (!e)
    return { content: t };
  let { startDelimiter: r, language: i, value: n = "", endDelimiter: s } = e.groups, a = i.trim() || "yaml";
  if (r === "+++" && (a = "toml"), a !== "yaml" && r !== s)
    return { content: t };
  let [o] = e;
  return { frontMatter: { type: "front-matter", lang: a, value: n, startDelimiter: r, endDelimiter: s, raw: o.replace(/\n$/, "") }, content: Tt(!1, o, /[^\n]/g, " ") + t.slice(o.length) };
}
var Sg = GN;
function HN(t) {
  return YN(Sg(t).content);
}
function JN(t) {
  let { frontMatter: e, content: r } = Sg(t);
  return (e ? e.raw + `

` : "") + UN(r);
}
var KN = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
function e_(t) {
  var e, r;
  return (r = (e = t.findAncestor((i) => i.type === "css-decl")) == null ? void 0 : e.prop) == null ? void 0 : r.toLowerCase();
}
var t_ = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
function r_(t) {
  return t_.has(t.toLowerCase());
}
function i_(t, e) {
  var r;
  let i = t.findAncestor((n) => n.type === "css-atrule");
  return ((r = i == null ? void 0 : i.name) == null ? void 0 : r.toLowerCase().endsWith("keyframes")) && ["from", "to"].includes(e.toLowerCase());
}
function aa(t) {
  return t.includes("$") || t.includes("@") || t.includes("#") || t.startsWith("%") || t.startsWith("--") || t.startsWith(":--") || t.includes("(") && t.includes(")") ? t : t.toLowerCase();
}
function sc(t, e) {
  var r;
  let i = t.findAncestor((n) => n.type === "value-func");
  return ((r = i == null ? void 0 : i.value) == null ? void 0 : r.toLowerCase()) === e;
}
function n_(t) {
  var e;
  let r = t.findAncestor((n) => n.type === "css-rule"), i = (e = r == null ? void 0 : r.raws) == null ? void 0 : e.selector;
  return i && (i.startsWith(":import") || i.startsWith(":export"));
}
function ac(t, e) {
  let r = Array.isArray(e) ? e : [e], i = t.findAncestor((n) => n.type === "css-atrule");
  return i && r.includes(i.name.toLowerCase());
}
function s_(t) {
  var e;
  let { node: r } = t;
  return r.groups[0].value === "url" && r.groups.length === 2 && ((e = t.findAncestor((i) => i.type === "css-atrule")) == null ? void 0 : e.name) === "import";
}
function a_(t) {
  return t.type === "value-func" && t.value.toLowerCase() === "url";
}
function o_(t) {
  return t.type === "value-func" && t.value.toLowerCase() === "var";
}
function Lp(t, e) {
  var r;
  let i = (r = t.parent) == null ? void 0 : r.nodes;
  return i && i.indexOf(e) === i.length - 1;
}
function l_(t) {
  let { selector: e } = t;
  return e ? typeof e == "string" && /^@.+:.*$/.test(e) || e.value && /^@.+:.*$/.test(e.value) : !1;
}
function u_(t) {
  return t.type === "value-word" && ["from", "through", "end"].includes(t.value);
}
function c_(t) {
  return t.type === "value-word" && ["and", "or", "not"].includes(t.value);
}
function h_(t) {
  return t.type === "value-word" && t.value === "in";
}
function Jd(t) {
  return t.type === "value-operator" && t.value === "*";
}
function oc(t) {
  return t.type === "value-operator" && t.value === "/";
}
function wn(t) {
  return t.type === "value-operator" && t.value === "+";
}
function oa(t) {
  return t.type === "value-operator" && t.value === "-";
}
function p_(t) {
  return t.type === "value-operator" && t.value === "%";
}
function Rp(t) {
  return Jd(t) || oc(t) || wn(t) || oa(t) || p_(t);
}
function d_(t) {
  return t.type === "value-word" && ["==", "!="].includes(t.value);
}
function f_(t) {
  return t.type === "value-word" && ["<", ">", "<=", ">="].includes(t.value);
}
function Kd(t, e) {
  return e.parser === "scss" && t.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(t.name);
}
function dO(t) {
  var e;
  return ((e = t.raws) == null ? void 0 : e.params) && /^\(\s*\)$/.test(t.raws.params);
}
function jp(t) {
  return t.name.startsWith("prettier-placeholder");
}
function m_(t) {
  return t.prop.startsWith("@prettier-placeholder");
}
function g_(t, e) {
  return t.value === "$$" && t.type === "value-func" && (e == null ? void 0 : e.type) === "value-word" && !e.raws.before;
}
function y_(t) {
  var e, r;
  return ((e = t.value) == null ? void 0 : e.type) === "value-root" && ((r = t.value.group) == null ? void 0 : r.type) === "value-value" && t.prop.toLowerCase() === "composes";
}
function O_(t) {
  var e, r, i;
  return ((i = (r = (e = t.value) == null ? void 0 : e.group) == null ? void 0 : r.group) == null ? void 0 : i.type) === "value-paren_group" && t.value.group.group.open !== null && t.value.group.group.close !== null;
}
function ta(t) {
  var e;
  return ((e = t.raws) == null ? void 0 : e.before) === "";
}
function wg(t) {
  var e, r;
  return t.type === "value-comma_group" && ((r = (e = t.groups) == null ? void 0 : e[1]) == null ? void 0 : r.type) === "value-colon";
}
function Zp(t) {
  var e;
  return t.type === "value-paren_group" && ((e = t.groups) == null ? void 0 : e[0]) && wg(t.groups[0]);
}
function Y2(t, e) {
  var r;
  if (e.parser !== "scss")
    return !1;
  let { node: i } = t;
  if (i.groups.length === 0)
    return !1;
  let n = t.grandparent;
  if (!Zp(i) && !(n && Zp(n)))
    return !1;
  let s = t.findAncestor((a) => a.type === "css-decl");
  return !!((r = s == null ? void 0 : s.prop) != null && r.startsWith("$") || Zp(n) || n.type === "value-func");
}
function fO(t) {
  return t.type === "value-comment" && t.inline;
}
function Wp(t) {
  return t.type === "value-word" && t.value === "#";
}
function mO(t) {
  return t.type === "value-word" && t.value === "{";
}
function qp(t) {
  return t.type === "value-word" && t.value === "}";
}
function Su(t) {
  return ["value-word", "value-atword"].includes(t.type);
}
function ef(t) {
  return (t == null ? void 0 : t.type) === "value-colon";
}
function x_(t, e) {
  if (!wg(e))
    return !1;
  let { groups: r } = e, i = r.indexOf(t);
  return i === -1 ? !1 : ef(r[i + 1]);
}
function b_(t) {
  return t.value && ["not", "and", "or"].includes(t.value.toLowerCase());
}
function D_(t) {
  return t.type !== "value-func" ? !1 : KN.has(t.value.toLowerCase());
}
function Oo(t) {
  return /\/\//.test(t.split(/[\n\r]/).pop());
}
function wu(t) {
  return (t == null ? void 0 : t.type) === "value-atword" && t.value.startsWith("prettier-placeholder-");
}
function v_(t, e) {
  var r, i;
  if (((r = t.open) == null ? void 0 : r.value) !== "(" || ((i = t.close) == null ? void 0 : i.value) !== ")" || t.groups.some((n) => n.type !== "value-comma_group"))
    return !1;
  if (e.type === "value-comma_group") {
    let n = e.groups.indexOf(t) - 1, s = e.groups[n];
    if ((s == null ? void 0 : s.type) === "value-word" && s.value === "with")
      return !0;
  }
  return !1;
}
function Cu(t) {
  var e, r;
  return t.type === "value-paren_group" && ((e = t.open) == null ? void 0 : e.value) === "(" && ((r = t.close) == null ? void 0 : r.value) === ")";
}
function S_(t, e, r) {
  var i;
  let { node: n } = t, s = t.parent, a = t.grandparent, o = e_(t), u = o && s.type === "value-value" && (o === "grid" || o.startsWith("grid-template")), c = t.findAncestor((S) => S.type === "css-atrule"), h = c && Kd(c, e), d = n.groups.some((S) => fO(S)), m = t.map(r, "groups"), y = [], O = sc(t, "url"), b = !1, v = !1;
  for (let S = 0; S < n.groups.length; ++S) {
    y.push(m[S]);
    let x = n.groups[S - 1], w = n.groups[S], k = n.groups[S + 1], C = n.groups[S + 2];
    if (O) {
      (k && wn(k) || wn(w)) && y.push(" ");
      continue;
    }
    if (ac(t, "forward") && w.type === "value-word" && w.value && x !== void 0 && x.type === "value-word" && x.value === "as" && k.type === "value-operator" && k.value === "*" || !k || w.type === "value-word" && w.value.endsWith("-") && wu(k))
      continue;
    if (w.type === "value-string" && w.quoted) {
      let j = w.value.lastIndexOf("#{"), G = w.value.lastIndexOf("}");
      j !== -1 && G !== -1 ? b = j > G : j !== -1 ? b = !0 : G !== -1 && (b = !1);
    }
    if (b || ef(w) || ef(k) || w.type === "value-atword" && (w.value === "" || w.value.endsWith("[")) || k.type === "value-word" && k.value.startsWith("]") || w.value === "~" || w.type !== "value-string" && w.value && w.value.includes("\\") && k && k.type !== "value-comment" || x != null && x.value && x.value.indexOf("\\") === x.value.length - 1 && w.type === "value-operator" && w.value === "/" || w.value === "\\" || g_(w, k) || Wp(w) || mO(w) || qp(k) || mO(k) && ta(k) || qp(w) && ta(k) || w.value === "--" && Wp(k))
      continue;
    let E = Rp(w), P = Rp(k);
    if ((E && Wp(k) || P && qp(w)) && ta(k) || !x && oc(w) || sc(t, "calc") && (wn(w) || wn(k) || oa(w) || oa(k)) && ta(k))
      continue;
    let I = (wn(w) || oa(w)) && S === 0 && (k.type === "value-number" || k.isHex) && a && D_(a) && !ta(k), B = (C == null ? void 0 : C.type) === "value-func" || C && Su(C) || w.type === "value-func" || Su(w), Q = k.type === "value-func" || Su(k) || (x == null ? void 0 : x.type) === "value-func" || x && Su(x);
    if (e.parser === "scss" && E && w.value === "-" && k.type === "value-func" && Or(w) !== br(k)) {
      y.push(" ");
      continue;
    }
    if (!(!(Jd(k) || Jd(w)) && !sc(t, "calc") && !I && (oc(k) && !B || oc(w) && !Q || wn(k) && !B || wn(w) && !Q || oa(k) || oa(w)) && (ta(k) || E && (!x || x && Rp(x)))) && !((e.parser === "scss" || e.parser === "less") && E && w.value === "-" && Cu(k) && Or(w) === br(k.open) && k.open.value === "(")) {
      if (fO(w)) {
        if (s.type === "value-paren_group") {
          y.push(Tc(ct));
          continue;
        }
        y.push(ct);
        continue;
      }
      if (h && (d_(k) || f_(k) || c_(k) || h_(w) || u_(w))) {
        y.push(" ");
        continue;
      }
      if (c && c.name.toLowerCase() === "namespace") {
        y.push(" ");
        continue;
      }
      if (u) {
        w.source && k.source && w.source.start.line !== k.source.start.line ? (y.push(ct), v = !0) : y.push(" ");
        continue;
      }
      if (P) {
        y.push(" ");
        continue;
      }
      if ((k == null ? void 0 : k.value) !== "..." && !(wu(w) && wu(k) && Or(w) === br(k))) {
        if (wu(w) && Cu(k) && Or(w) === br(k.open)) {
          y.push(Kr);
          continue;
        }
        if (w.value === "with" && Cu(k)) {
          y.push(" ");
          continue;
        }
        (i = w.value) != null && i.endsWith("#") && k.value === "{" && Cu(k.group) || y.push(Ut);
      }
    }
  }
  return d && y.push(bg), v && y.unshift(ct), h ? Ir(mr(y)) : s_(t) ? Ir(Hd(y)) : Ir(mr(Hd(y)));
}
var w_ = S_;
function C_(t) {
  return t.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
}
var A_ = C_, gO = /* @__PURE__ */ new Map([["em", "em"], ["rem", "rem"], ["ex", "ex"], ["rex", "rex"], ["cap", "cap"], ["rcap", "rcap"], ["ch", "ch"], ["rch", "rch"], ["ic", "ic"], ["ric", "ric"], ["lh", "lh"], ["rlh", "rlh"], ["vw", "vw"], ["svw", "svw"], ["lvw", "lvw"], ["dvw", "dvw"], ["vh", "vh"], ["svh", "svh"], ["lvh", "lvh"], ["dvh", "dvh"], ["vi", "vi"], ["svi", "svi"], ["lvi", "lvi"], ["dvi", "dvi"], ["vb", "vb"], ["svb", "svb"], ["lvb", "lvb"], ["dvb", "dvb"], ["vmin", "vmin"], ["svmin", "svmin"], ["lvmin", "lvmin"], ["dvmin", "dvmin"], ["vmax", "vmax"], ["svmax", "svmax"], ["lvmax", "lvmax"], ["dvmax", "dvmax"], ["cm", "cm"], ["mm", "mm"], ["q", "Q"], ["in", "in"], ["pt", "pt"], ["pc", "pc"], ["px", "px"], ["deg", "deg"], ["grad", "grad"], ["rad", "rad"], ["turn", "turn"], ["s", "s"], ["ms", "ms"], ["hz", "Hz"], ["khz", "kHz"], ["dpi", "dpi"], ["dpcm", "dpcm"], ["dppx", "dppx"], ["x", "x"], ["cqw", "cqw"], ["cqh", "cqh"], ["cqi", "cqi"], ["cqb", "cqb"], ["cqmin", "cqmin"], ["cqmax", "cqmax"]]);
function E_(t) {
  let e = t.toLowerCase();
  return gO.has(e) ? gO.get(e) : t;
}
var U2 = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, k_ = /(?:\d*\.\d+|\d+\.?)(?:e[+-]?\d+)?/gi, T_ = /[a-z]+/gi, P_ = /[$@]?[_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/gi, F_ = new RegExp(U2.source + `|(${P_.source})?(${k_.source})(${T_.source})?`, "gi");
function mi(t, e) {
  return Tt(!1, t, U2, (r) => Q2(r, e));
}
function $_(t, e) {
  let r = e.singleQuote ? "'" : '"';
  return t.includes('"') || t.includes("'") ? t : r + t + r;
}
function ra(t) {
  return Tt(!1, t, F_, (e, r, i, n, s) => !i && n ? z2(n) + aa(s || "") : e);
}
function z2(t) {
  return A_(t).replace(/\.0(?=$|e)/, "");
}
function B_(t) {
  return t.trailingComma === "es5" || t.trailingComma === "all";
}
function I_(t, e, r) {
  let i = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let n = t.charAt(e);
  if (i) {
    if (t.charAt(e - 1) === "\r" && n === `
`)
      return e - 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e - 1;
  } else {
    if (n === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e + 1;
  }
  return e;
}
var G2 = I_;
function N_(t, e, r = {}) {
  let i = j2(t, r.backwards ? e - 1 : e, r), n = G2(t, i, r);
  return i !== n;
}
var H2 = N_;
function __(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var Q_ = __;
function M_(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? Z2(t, e) : e;
}
var L_ = M_;
function R_(t, e) {
  let r = null, i = e;
  for (; i !== r; )
    r = i, i = ZN(t, i), i = Q_(t, i), i = j2(t, i);
  return i = L_(t, i), i = G2(t, i), i !== !1 && H2(t, i);
}
var J2 = R_;
function j_({ node: t, parent: e }, r) {
  return !!(t.source && r.originalText.slice(br(t), br(e.close)).trimEnd().endsWith(","));
}
function Z_(t, e) {
  return o_(t.grandparent) && j_(t, e) ? "," : t.node.type !== "value-comment" && !(t.node.type === "value-comma_group" && t.node.groups.every((r) => r.type === "value-comment")) && B_(e) && t.callParent(() => Y2(t, e)) ? _2(",") : "";
}
function W_(t, e, r) {
  let { node: i, parent: n } = t, s = t.map(({ node: y }) => typeof y == "string" ? y : r(), "groups");
  if (n && a_(n) && (i.groups.length === 1 || i.groups.length > 0 && i.groups[0].type === "value-comma_group" && i.groups[0].groups.length > 0 && i.groups[0].groups[0].type === "value-word" && i.groups[0].groups[0].value.startsWith("data:")))
    return [i.open ? r("open") : "", ds(",", s), i.close ? r("close") : ""];
  if (!i.open) {
    let y = K2(t), O = ds([",", y ? ct : Ut], s);
    return mr(y ? [ct, O] : Ir(Hd(O)));
  }
  let a = t.map(({ node: y, isLast: O, index: b }) => {
    var v;
    let S = s[b];
    if (wg(y) && y.type === "value-comma_group" && y.groups && y.groups[0].type !== "value-paren_group" && ((v = y.groups[2]) == null ? void 0 : v.type) === "value-paren_group") {
      let w = fN(S.contents.contents);
      w[1] = Ir(w[1]), S = Ir(Tc(S));
    }
    let x = [S, O ? Z_(t, e) : ","];
    if (!O && y.type === "value-comma_group" && qh(y.groups)) {
      let w = al(!1, y.groups, -1);
      !w.source && w.close && (w = w.close), w.source && J2(e.originalText, Or(w)) && x.push(ct);
    }
    return x;
  }, "groups"), o = x_(i, n), u = v_(i, n), c = Y2(t, e), h = u || c && !o, d = u || o, m = Ir([i.open ? r("open") : "", mr([Kr, ds(Ut, a)]), Kr, i.close ? r("close") : ""], { shouldBreak: h });
  return d ? Tc(m) : m;
}
function K2(t) {
  return t.match((e) => e.type === "value-paren_group" && !e.open && e.groups.some((r) => r.type === "value-comma_group"), (e, r) => r === "group" && e.type === "value-value", (e, r) => r === "group" && e.type === "value-root", (e, r) => r === "value" && (e.type === "css-decl" && !e.prop.startsWith("--") || e.type === "css-atrule" && e.variable));
}
function q_(t, e, r) {
  let i = [];
  return t.each(() => {
    let { node: n, previous: s } = t;
    if ((s == null ? void 0 : s.type) === "css-comment" && s.text.trim() === "prettier-ignore" ? i.push(e.originalText.slice(br(n), Or(n))) : i.push(r()), t.isLast)
      return;
    let { next: a } = t;
    a.type === "css-comment" && !H2(e.originalText, br(a), { backwards: !0 }) && !Pc(n) || a.type === "css-atrule" && a.name === "else" && n.type !== "css-comment" ? i.push(" ") : (i.push(e.__isHTMLStyleAttribute ? Ut : ct), J2(e.originalText, Or(n)) && !Pc(n) && i.push(ct));
  }, "nodes"), i;
}
var xo = q_;
function X_(t, e, r) {
  var i, n, s, a, o, u;
  let { node: c } = t;
  switch (c.type) {
    case "front-matter":
      return [c.raw, ct];
    case "css-root": {
      let h = xo(t, e, r), d = c.raws.after.trim();
      return d.startsWith(";") && (d = d.slice(1).trim()), [c.frontMatter ? [r("frontMatter"), ct] : "", h, d ? ` ${d}` : "", c.nodes.length > 0 ? ct : ""];
    }
    case "css-comment": {
      let h = c.inline || c.raws.inline, d = e.originalText.slice(br(c), Or(c));
      return h ? d.trimEnd() : d;
    }
    case "css-rule":
      return [r("selector"), c.important ? " !important" : "", c.nodes ? [((i = c.selector) == null ? void 0 : i.type) === "selector-unknown" && Oo(c.selector.value) ? Ut : c.selector ? " " : "", "{", c.nodes.length > 0 ? mr([ct, xo(t, e, r)]) : "", ct, "}", l_(c) ? ";" : ""] : ";"];
    case "css-decl": {
      let h = t.parent, { between: d } = c.raws, m = d.trim(), y = m === ":", O = typeof c.value == "string" && /^ *$/.test(c.value), b = typeof c.value == "string" ? c.value : r("value");
      return b = y_(c) ? yN(b) : b, !y && Oo(m) && !((s = (n = c.value) == null ? void 0 : n.group) != null && s.group && t.call(() => K2(t), "value", "group", "group")) && (b = mr([ct, Tc(b)])), [Tt(!1, c.raws.before, /[\s;]/g, ""), h.type === "css-atrule" && h.variable || n_(t) ? c.prop : aa(c.prop), m.startsWith("//") ? " " : "", m, c.extend || O ? "" : " ", e.parser === "less" && c.extend && c.selector ? ["extend(", r("selector"), ")"] : "", b, c.raws.important ? c.raws.important.replace(/\s*!\s*important/i, " !important") : c.important ? " !important" : "", c.raws.scssDefault ? c.raws.scssDefault.replace(/\s*!default/i, " !default") : c.scssDefault ? " !default" : "", c.raws.scssGlobal ? c.raws.scssGlobal.replace(/\s*!global/i, " !global") : c.scssGlobal ? " !global" : "", c.nodes ? [" {", mr([Kr, xo(t, e, r)]), Kr, "}"] : m_(c) && !h.raws.semicolon && e.originalText[Or(c) - 1] !== ";" ? "" : e.__isHTMLStyleAttribute && Lp(t, c) ? _2(";") : ";"];
    }
    case "css-atrule": {
      let h = t.parent, d = jp(c) && !h.raws.semicolon && e.originalText[Or(c) - 1] !== ";";
      if (e.parser === "less") {
        if (c.mixin)
          return [r("selector"), c.important ? " !important" : "", d ? "" : ";"];
        if (c.function)
          return [c.name, typeof c.params == "string" ? c.params : r("params"), d ? "" : ";"];
        if (c.variable)
          return ["@", c.name, ": ", c.value ? r("value") : "", c.raws.between.trim() ? c.raws.between.trim() + " " : "", c.nodes ? ["{", mr([c.nodes.length > 0 ? Kr : "", xo(t, e, r)]), Kr, "}"] : "", d ? "" : ";"];
      }
      let m = c.name === "import" && ((a = c.params) == null ? void 0 : a.type) === "value-unknown" && c.params.value.endsWith(";");
      return ["@", dO(c) || c.name.endsWith(":") || jp(c) ? c.name : aa(c.name), c.params ? [dO(c) ? "" : jp(c) ? c.raws.afterName === "" ? "" : c.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(c.raws.afterName) ? [ct, ct] : /^\s*\n/.test(c.raws.afterName) ? ct : " " : " ", typeof c.params == "string" ? c.params : r("params")] : "", c.selector ? mr([" ", r("selector")]) : "", c.value ? Ir([" ", r("value"), Kd(c, e) ? O_(c) ? " " : Ut : ""]) : c.name === "else" ? " " : "", c.nodes ? [Kd(c, e) ? "" : c.selector && !c.selector.nodes && typeof c.selector.value == "string" && Oo(c.selector.value) || !c.selector && typeof c.params == "string" && Oo(c.params) ? Ut : " ", "{", mr([c.nodes.length > 0 ? Kr : "", xo(t, e, r)]), Kr, "}"] : d || m ? "" : ";"];
    }
    case "media-query-list": {
      let h = [];
      return t.each(({ node: d }) => {
        d.type === "media-query" && d.value === "" || h.push(r());
      }, "nodes"), Ir(mr(ds(Ut, h)));
    }
    case "media-query":
      return [ds(" ", t.map(r, "nodes")), Lp(t, c) ? "" : ","];
    case "media-type":
      return ra(mi(c.value, e));
    case "media-feature-expression":
      return c.nodes ? ["(", ...t.map(r, "nodes"), ")"] : c.value;
    case "media-feature":
      return aa(mi(Tt(!1, c.value, / +/g, " "), e));
    case "media-colon":
      return [c.value, " "];
    case "media-value":
      return ra(mi(c.value, e));
    case "media-keyword":
      return mi(c.value, e);
    case "media-url":
      return mi(Tt(!1, Tt(!1, c.value, /^url\(\s+/gi, "url("), /\s+\)$/g, ")"), e);
    case "media-unknown":
      return c.value;
    case "selector-root":
      return Ir([ac(t, "custom-selector") ? [t.findAncestor((h) => h.type === "css-atrule").customSelector, Ut] : "", ds([",", ac(t, ["extend", "custom-selector", "nest"]) ? Ut : ct], t.map(r, "nodes"))]);
    case "selector-selector":
      return Ir(mr(t.map(r, "nodes")));
    case "selector-comment":
      return c.value;
    case "selector-string":
      return mi(c.value, e);
    case "selector-tag":
      return [c.namespace ? [c.namespace === !0 ? "" : c.namespace.trim(), "|"] : "", ((o = t.previous) == null ? void 0 : o.type) === "selector-nesting" ? c.value : ra(i_(t, c.value) ? c.value.toLowerCase() : c.value)];
    case "selector-id":
      return ["#", c.value];
    case "selector-class":
      return [".", ra(mi(c.value, e))];
    case "selector-attribute":
      return ["[", c.namespace ? [c.namespace === !0 ? "" : c.namespace.trim(), "|"] : "", c.attribute.trim(), c.operator ?? "", c.value ? $_(mi(c.value.trim(), e), e) : "", c.insensitive ? " i" : "", "]"];
    case "selector-combinator": {
      if (c.value === "+" || c.value === ">" || c.value === "~" || c.value === ">>>") {
        let m = t.parent;
        return [m.type === "selector-selector" && m.nodes[0] === c ? "" : Ut, c.value, Lp(t, c) ? "" : " "];
      }
      let h = c.value.trim().startsWith("(") ? Ut : "", d = ra(mi(c.value.trim(), e)) || Ut;
      return [h, d];
    }
    case "selector-universal":
      return [c.namespace ? [c.namespace === !0 ? "" : c.namespace.trim(), "|"] : "", c.value];
    case "selector-pseudo":
      return [aa(c.value), qh(c.nodes) ? Ir(["(", mr([Kr, ds([",", Ut], t.map(r, "nodes"))]), Kr, ")"]) : ""];
    case "selector-nesting":
      return c.value;
    case "selector-unknown": {
      let h = t.findAncestor((y) => y.type === "css-rule");
      if (h != null && h.isSCSSNesterProperty)
        return ra(mi(aa(c.value), e));
      let d = t.parent;
      if ((u = d.raws) != null && u.selector) {
        let y = br(d), O = y + d.raws.selector.length;
        return e.originalText.slice(y, O).trim();
      }
      let m = t.grandparent;
      if (d.type === "value-paren_group" && (m == null ? void 0 : m.type) === "value-func" && m.value === "selector") {
        let y = Or(d.open) + 1, O = br(d.close), b = e.originalText.slice(y, O).trim();
        return Oo(b) ? [bg, b] : b;
      }
      return c.value;
    }
    case "value-value":
    case "value-root":
      return r("group");
    case "value-comment":
      return e.originalText.slice(br(c), Or(c));
    case "value-comma_group":
      return w_(t, e, r);
    case "value-paren_group":
      return W_(t, e, r);
    case "value-func":
      return [c.value, ac(t, "supports") && b_(c) ? " " : "", r("group")];
    case "value-paren":
      return c.value;
    case "value-number":
      return [z2(c.value), E_(c.unit)];
    case "value-operator":
      return c.value;
    case "value-word":
      return c.isColor && c.isHex || r_(c.value) ? c.value.toLowerCase() : c.value;
    case "value-colon": {
      let { previous: h } = t;
      return [c.value, typeof (h == null ? void 0 : h.value) == "string" && h.value.endsWith("\\") || sc(t, "url") ? "" : Ut];
    }
    case "value-string":
      return Q2(c.raws.quote + c.value + c.raws.quote, e);
    case "value-atword":
      return ["@", c.value];
    case "value-unicode-range":
      return c.value;
    case "value-unknown":
      return c.value;
    case "value-comma":
    default:
      throw new CN(c, "PostCSS");
  }
}
var V_ = { print: X_, embed: $N, insertPragma: JN, massageAstNode: TN, getVisitorKeys: RN }, Y_ = V_, U_ = [{ linguistLanguageId: 50, name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css", ".wxss"], parsers: ["css"], vscodeLanguageIds: ["css"] }, { linguistLanguageId: 262764437, name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", parsers: ["css"], vscodeLanguageIds: ["postcss"] }, { linguistLanguageId: 198, name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", parsers: ["less"], vscodeLanguageIds: ["less"] }, { linguistLanguageId: 329, name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], parsers: ["scss"], vscodeLanguageIds: ["scss"] }], z_ = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, G_ = { singleQuote: z_.singleQuote }, H_ = G_, ev = {};
l2(ev, { css: () => k7, less: () => T7, scss: () => P7 });
var J_ = Ms(Zh(), 1), K_ = Ms(f5(), 1), e7 = Ms(D5(), 1);
function t7(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var r7 = t7, i7 = Ms(S5(), 1);
function jl(t, e, r) {
  if (t && typeof t == "object") {
    delete t.parent;
    for (let i in t)
      jl(t[i], e, r), i === "type" && typeof t[i] == "string" && !t[i].startsWith(e) && (!r || !r.test(t[i])) && (t[i] = e + t[i]);
  }
  return t;
}
function tv(t) {
  if (t && typeof t == "object") {
    delete t.parent;
    for (let e in t)
      tv(t[e]);
    !Array.isArray(t) && t.value && !t.type && (t.type = "unknown");
  }
  return t;
}
var n7 = i7.default.default;
function s7(t) {
  let e;
  try {
    e = n7(t);
  } catch {
    return { type: "selector-unknown", value: t };
  }
  return jl(tv(e), "media-");
}
var a7 = s7, o7 = Ms(L5(), 1);
function l7(t) {
  if (/\/\/|\/\*/.test(t))
    return { type: "selector-unknown", value: t.trim() };
  let e;
  try {
    new o7.default((r) => {
      e = r;
    }).process(t);
  } catch {
    return { type: "selector-unknown", value: t };
  }
  return jl(e, "selector-");
}
var ls = l7, u7 = Ms(rN(), 1), c7 = (t) => {
  for (; t.parent; )
    t = t.parent;
  return t;
}, rv = c7;
function h7(t) {
  return rv(t).text.slice(t.group.open.sourceIndex + 1, t.group.close.sourceIndex).trim();
}
var p7 = h7;
function d7(t) {
  if (qh(t)) {
    for (let e = t.length - 1; e > 0; e--)
      if (t[e].type === "word" && t[e].value === "{" && t[e - 1].type === "word" && t[e - 1].value.endsWith("#"))
        return !0;
  }
  return !1;
}
var f7 = d7;
function m7(t) {
  return t.some((e) => e.type === "string" || e.type === "func" && !e.value.endsWith("\\"));
}
var g7 = m7;
function y7(t, e) {
  return !!(e.parser === "scss" && (t == null ? void 0 : t.type) === "word" && t.value.startsWith("$"));
}
var O7 = y7;
function x7(t, e) {
  var r;
  let { nodes: i } = t, n = { open: null, close: null, groups: [], type: "paren_group" }, s = [n], a = n, o = { groups: [], type: "comma_group" }, u = [o];
  for (let c = 0; c < i.length; ++c) {
    let h = i[c];
    if (e.parser === "scss" && h.type === "number" && h.unit === ".." && h.value.endsWith(".") && (h.value = h.value.slice(0, -1), h.unit = "..."), h.type === "func" && h.value === "selector" && (h.group.groups = [ls(rv(t).text.slice(h.group.open.sourceIndex + 1, h.group.close.sourceIndex))]), h.type === "func" && h.value === "url") {
      let d = ((r = h.group) == null ? void 0 : r.groups) ?? [], m = [];
      for (let y = 0; y < d.length; y++) {
        let O = d[y];
        O.type === "comma_group" ? m = [...m, ...O.groups] : m.push(O);
      }
      (f7(m) || !g7(m) && !O7(m[0], e)) && (h.group.groups = [p7(h)]);
    }
    if (h.type === "paren" && h.value === "(")
      n = { open: h, close: null, groups: [], type: "paren_group" }, s.push(n), o = { groups: [], type: "comma_group" }, u.push(o);
    else if (h.type === "paren" && h.value === ")") {
      if (o.groups.length > 0 && n.groups.push(o), n.close = h, u.length === 1)
        throw new Error("Unbalanced parenthesis");
      u.pop(), o = al(!1, u, -1), o.groups.push(n), s.pop(), n = al(!1, s, -1);
    } else
      h.type === "comma" ? (n.groups.push(o), o = { groups: [], type: "comma_group" }, u[u.length - 1] = o) : o.groups.push(h);
  }
  return o.groups.length > 0 && n.groups.push(o), a;
}
function tf(t) {
  return t.type === "paren_group" && !t.open && !t.close && t.groups.length === 1 || t.type === "comma_group" && t.groups.length === 1 ? tf(t.groups[0]) : t.type === "paren_group" || t.type === "comma_group" ? { ...t, groups: t.groups.map(tf) } : t;
}
function iv(t, e) {
  if (t && typeof t == "object")
    for (let r in t)
      r !== "parent" && (iv(t[r], e), r === "nodes" && (t.group = tf(x7(t, e)), delete t[r]));
  return t;
}
function b7(t, e) {
  if (e.parser === "less" && t.startsWith("~`"))
    return { type: "value-unknown", value: t };
  let r = null;
  try {
    r = new u7.default(t, { loose: !0 }).parse();
  } catch {
    return { type: "value-unknown", value: t };
  }
  r.text = t;
  let i = iv(r, e);
  return jl(i, "value-", /^selector-/);
}
var ns = b7, D7 = /* @__PURE__ */ new Set(["import", "use", "forward"]);
function v7(t) {
  return D7.has(t);
}
var S7 = v7;
function w7(t, e) {
  return e.parser !== "scss" || !t.selector ? !1 : t.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*\n/, "").trim().endsWith(":");
}
var C7 = w7, A7 = /(\s*)(!default).*$/, E7 = /(\s*)(!global).*$/;
function nv(t, e) {
  var r, i;
  if (t && typeof t == "object") {
    delete t.parent;
    for (let o in t)
      nv(t[o], e);
    if (!t.type)
      return t;
    if (t.raws ?? (t.raws = {}), t.type === "css-decl" && typeof t.prop == "string" && t.prop.startsWith("--") && typeof t.value == "string" && t.value.startsWith("{")) {
      let o;
      if (t.value.trimEnd().endsWith("}")) {
        let u = e.originalText.slice(0, t.source.start.offset), c = "a".repeat(t.prop.length) + e.originalText.slice(t.source.start.offset + t.prop.length, t.source.end.offset), h = Tt(!1, u, /[^\n]/g, " ") + c, d;
        e.parser === "scss" ? d = ov : e.parser === "less" ? d = av : d = sv;
        let m;
        try {
          m = d(h, { ...e });
        } catch {
        }
        ((r = m == null ? void 0 : m.nodes) == null ? void 0 : r.length) === 1 && m.nodes[0].type === "css-rule" && (o = m.nodes[0].nodes);
      }
      return o ? t.value = { type: "css-rule", nodes: o } : t.value = { type: "value-unknown", value: t.raws.value.raw }, t;
    }
    let n = "";
    typeof t.selector == "string" && (n = t.raws.selector ? t.raws.selector.scss ?? t.raws.selector.raw : t.selector, t.raws.between && t.raws.between.trim().length > 0 && (n += t.raws.between), t.raws.selector = n);
    let s = "";
    typeof t.value == "string" && (s = t.raws.value ? t.raws.value.scss ?? t.raws.value.raw : t.value, s = s.trim(), t.raws.value = s);
    let a = "";
    if (typeof t.params == "string" && (a = t.raws.params ? t.raws.params.scss ?? t.raws.params.raw : t.params, t.raws.afterName && t.raws.afterName.trim().length > 0 && (a = t.raws.afterName + a), t.raws.between && t.raws.between.trim().length > 0 && (a = a + t.raws.between), a = a.trim(), t.raws.params = a), n.trim().length > 0)
      return n.startsWith("@") && n.endsWith(":") ? t : t.mixin ? (t.selector = ns(n, e), t) : (C7(t, e) && (t.isSCSSNesterProperty = !0), t.selector = ls(n), t);
    if (s.length > 0) {
      let o = s.match(A7);
      o && (s = s.slice(0, o.index), t.scssDefault = !0, o[0].trim() !== "!default" && (t.raws.scssDefault = o[0]));
      let u = s.match(E7);
      if (u && (s = s.slice(0, u.index), t.scssGlobal = !0, u[0].trim() !== "!global" && (t.raws.scssGlobal = u[0])), s.startsWith("progid:"))
        return { type: "value-unknown", value: s };
      t.value = ns(s, e);
    }
    if (e.parser === "less" && t.type === "css-decl" && s.startsWith("extend(") && (t.extend || (t.extend = t.raws.between === ":"), t.extend && !t.selector && (delete t.value, t.selector = ls(s.slice(7, -1)))), t.type === "css-atrule") {
      if (e.parser === "less") {
        if (t.mixin) {
          let o = t.raws.identifier + t.name + t.raws.afterName + t.raws.params;
          return t.selector = ls(o), delete t.params, t;
        }
        if (t.function)
          return t;
      }
      if (e.parser === "css" && t.name === "custom-selector") {
        let o = t.params.match(/:--\S+\s+/)[0].trim();
        return t.customSelector = o, t.selector = ls(t.params.slice(o.length).trim()), delete t.params, t;
      }
      if (e.parser === "less") {
        if (t.name.includes(":") && !t.params) {
          t.variable = !0;
          let o = t.name.split(":");
          t.name = o[0], t.value = ns(o.slice(1).join(":"), e);
        }
        if (!["page", "nest", "keyframes"].includes(t.name) && ((i = t.params) == null ? void 0 : i[0]) === ":") {
          t.variable = !0;
          let o = t.params.slice(1);
          o && (t.value = ns(o, e)), t.raws.afterName += ":";
        }
        if (t.variable)
          return delete t.params, t.value || delete t.value, t;
      }
    }
    if (t.type === "css-atrule" && a.length > 0) {
      let { name: o } = t, u = t.name.toLowerCase();
      return o === "warn" || o === "error" ? (t.params = { type: "media-unknown", value: a }, t) : o === "extend" || o === "nest" ? (t.selector = ls(a), delete t.params, t) : o === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(a) ? t.params = ns(a, e) : (t.selector = ls(a), delete t.params), t) : S7(u) ? (t.import = !0, delete t.filename, t.params = ns(a, e), t) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(o) ? (a = a.replace(/(\$\S+?)(\s+)?\.{3}/, "$1...$2"), a = a.replace(/^(?!if)(\S+)(\s+)\(/, "$1($2"), t.value = ns(a, e), delete t.params, t) : ["media", "custom-media"].includes(u) ? a.includes("#{") ? { type: "media-unknown", value: a } : (t.params = a7(a), t) : (t.params = a, t);
    }
  }
  return t;
}
function Cg(t, e, r) {
  let i = Sg(e), { frontMatter: n } = i;
  e = i.content;
  let s;
  try {
    s = t(e, { map: !1 });
  } catch (a) {
    let { name: o, reason: u, line: c, column: h } = a;
    throw typeof c != "number" ? a : r7(`${o}: ${u}`, { loc: { start: { line: c, column: h } }, cause: a });
  }
  return r.originalText = e, s = nv(jl(s, "css-"), r), q2(s, e), n && (n.source = { startOffset: 0, endOffset: n.raw.length }, s.frontMatter = n), s;
}
function sv(t, e = {}) {
  return Cg(J_.default.default, t, e);
}
function av(t, e = {}) {
  return Cg((r) => K_.default.parse(qN(r)), t, e);
}
function ov(t, e = {}) {
  return Cg(e7.default, t, e);
}
var Ag = { astFormat: "postcss", hasPragma: HN, locStart: br, locEnd: Or }, k7 = { ...Ag, parse: sv }, T7 = { ...Ag, parse: av }, P7 = { ...Ag, parse: ov }, F7 = { postcss: Y_ }, $7 = w2, B7 = Object.create, Eg = Object.defineProperty, I7 = Object.getOwnPropertyDescriptor, N7 = Object.getOwnPropertyNames, _7 = Object.getPrototypeOf, Q7 = Object.prototype.hasOwnProperty, M7 = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Xh = (t, e) => {
  for (var r in e)
    Eg(t, r, { get: e[r], enumerable: !0 });
}, L7 = (t, e, r, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of N7(e))
      !Q7.call(t, n) && n !== r && Eg(t, n, { get: () => e[n], enumerable: !(i = I7(e, n)) || i.enumerable });
  return t;
}, R7 = (t, e, r) => (r = t != null ? B7(_7(t)) : {}, L7(e || !t || !t.__esModule ? Eg(r, "default", { value: t, enumerable: !0 }) : r, t)), lv = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, Dn = (t, e, r) => (lv(t, e, "read from private field"), r ? r.call(t) : e.get(t)), j7 = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, Z7 = (t, e, r, i) => (lv(t, e, "write to private field"), i ? i.call(t, r) : e.set(t, r), r), W7 = M7((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = h, t.parse = m, t.parseWithComments = y, t.print = O, t.strip = d;
  var e = /\*\/$/, r = /^\/\*\*?/, i = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, n = /(^|\s+)\/\/([^\r\n]*)/g, s = /^(\r?\n)+/, a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, o = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, u = /(\r?\n|^) *\* ?/g, c = [];
  function h(v) {
    let S = v.match(i);
    return S ? S[0].trimLeft() : "";
  }
  function d(v) {
    let S = v.match(i);
    return S && S[0] ? v.substring(S[0].length) : v;
  }
  function m(v) {
    return y(v).pragmas;
  }
  function y(v) {
    let S = `
`;
    v = v.replace(r, "").replace(e, "").replace(u, "$1");
    let x = "";
    for (; x !== v; )
      x = v, v = v.replace(a, `${S}$1 $2${S}`);
    v = v.replace(s, "").trimRight();
    let w = /* @__PURE__ */ Object.create(null), k = v.replace(o, "").replace(s, "").trimRight(), C;
    for (; C = o.exec(v); ) {
      let E = C[2].replace(n, "");
      typeof w[C[1]] == "string" || Array.isArray(w[C[1]]) ? w[C[1]] = c.concat(w[C[1]], E) : w[C[1]] = E;
    }
    return { comments: k, pragmas: w };
  }
  function O({ comments: v = "", pragmas: S = {} }) {
    let x = `
`, w = "/**", k = " *", C = " */", E = Object.keys(S), P = E.flatMap((B) => b(B, S[B])).map((B) => `${k} ${B}${x}`).join("");
    if (!v) {
      if (E.length === 0)
        return "";
      if (E.length === 1 && !Array.isArray(S[E[0]])) {
        let B = S[E[0]];
        return `${w} ${b(E[0], B)[0]}${C}`;
      }
    }
    let I = v.split(x).map((B) => `${k} ${B}`).join(x) + x;
    return w + x + (v ? I : "") + (v && E.length ? k + x : "") + P + C;
  }
  function b(v, S) {
    return c.concat(S).map((x) => `@${v} ${x}`.trim());
  }
}), uv = {};
Xh(uv, { languages: () => AL, options: () => wL, printers: () => CL });
var q7 = [{ linguistLanguageId: 183, name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib", ".wxs"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell", "zx"], parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"] }, { linguistLanguageId: 183, name: "Flow", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: [], extensions: [".js.flow"], filenames: [], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"] }, { linguistLanguageId: 183, name: "JSX", type: "programming", tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0, aliases: void 0, extensions: [".jsx"], filenames: void 0, interpreters: void 0, parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], group: "JavaScript" }, { linguistLanguageId: 378, name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] }, { linguistLanguageId: 94901924, name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] }], cv = {};
Xh(cv, { canAttachComment: () => H9, embed: () => M4, experimentalFeatures: () => mL, getCommentChildNodes: () => J9, getVisitorKeys: () => dv, handleComments: () => Mv, insertPragma: () => Z4, isBlockComment: () => Vr, isGap: () => K9, massageAstNode: () => HQ, print: () => fL, printComment: () => g9, willPrintOwnComments: () => Uv });
var X7 = (t, e, r, i) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, i) : r.global ? e.replace(r, i) : e.split(r).join(i);
}, Dr = X7, V7 = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, qe = V7, Y7 = /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/, U7 = (t) => Y7.test(t), z7 = U7;
function G7(t) {
  return t !== null && typeof t == "object";
}
var H7 = G7;
function* J7(t, e) {
  let { getVisitorKeys: r, filter: i = () => !0 } = e, n = (s) => H7(s) && i(s);
  for (let s of r(t)) {
    let a = t[s];
    if (Array.isArray(a))
      for (let o of a)
        n(o) && (yield o);
    else
      n(a) && (yield a);
  }
}
function* K7(t, e) {
  let r = [t];
  for (let i = 0; i < r.length; i++) {
    let n = r[i];
    for (let s of J7(n, e))
      yield s, r.push(s);
  }
}
function eQ(t, { getVisitorKeys: e, predicate: r }) {
  for (let i of K7(t, { getVisitorKeys: e }))
    if (r(i))
      return !0;
  return !1;
}
var tQ = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function rQ(t) {
  return t === 12288 || t >= 65281 && t <= 65376 || t >= 65504 && t <= 65510;
}
function iQ(t) {
  return t >= 4352 && t <= 4447 || t === 8986 || t === 8987 || t === 9001 || t === 9002 || t >= 9193 && t <= 9196 || t === 9200 || t === 9203 || t === 9725 || t === 9726 || t === 9748 || t === 9749 || t >= 9800 && t <= 9811 || t === 9855 || t === 9875 || t === 9889 || t === 9898 || t === 9899 || t === 9917 || t === 9918 || t === 9924 || t === 9925 || t === 9934 || t === 9940 || t === 9962 || t === 9970 || t === 9971 || t === 9973 || t === 9978 || t === 9981 || t === 9989 || t === 9994 || t === 9995 || t === 10024 || t === 10060 || t === 10062 || t >= 10067 && t <= 10069 || t === 10071 || t >= 10133 && t <= 10135 || t === 10160 || t === 10175 || t === 11035 || t === 11036 || t === 11088 || t === 11093 || t >= 11904 && t <= 11929 || t >= 11931 && t <= 12019 || t >= 12032 && t <= 12245 || t >= 12272 && t <= 12287 || t >= 12289 && t <= 12350 || t >= 12353 && t <= 12438 || t >= 12441 && t <= 12543 || t >= 12549 && t <= 12591 || t >= 12593 && t <= 12686 || t >= 12688 && t <= 12771 || t >= 12783 && t <= 12830 || t >= 12832 && t <= 12871 || t >= 12880 && t <= 19903 || t >= 19968 && t <= 42124 || t >= 42128 && t <= 42182 || t >= 43360 && t <= 43388 || t >= 44032 && t <= 55203 || t >= 63744 && t <= 64255 || t >= 65040 && t <= 65049 || t >= 65072 && t <= 65106 || t >= 65108 && t <= 65126 || t >= 65128 && t <= 65131 || t >= 94176 && t <= 94180 || t === 94192 || t === 94193 || t >= 94208 && t <= 100343 || t >= 100352 && t <= 101589 || t >= 101632 && t <= 101640 || t >= 110576 && t <= 110579 || t >= 110581 && t <= 110587 || t === 110589 || t === 110590 || t >= 110592 && t <= 110882 || t === 110898 || t >= 110928 && t <= 110930 || t === 110933 || t >= 110948 && t <= 110951 || t >= 110960 && t <= 111355 || t === 126980 || t === 127183 || t === 127374 || t >= 127377 && t <= 127386 || t >= 127488 && t <= 127490 || t >= 127504 && t <= 127547 || t >= 127552 && t <= 127560 || t === 127568 || t === 127569 || t >= 127584 && t <= 127589 || t >= 127744 && t <= 127776 || t >= 127789 && t <= 127797 || t >= 127799 && t <= 127868 || t >= 127870 && t <= 127891 || t >= 127904 && t <= 127946 || t >= 127951 && t <= 127955 || t >= 127968 && t <= 127984 || t === 127988 || t >= 127992 && t <= 128062 || t === 128064 || t >= 128066 && t <= 128252 || t >= 128255 && t <= 128317 || t >= 128331 && t <= 128334 || t >= 128336 && t <= 128359 || t === 128378 || t === 128405 || t === 128406 || t === 128420 || t >= 128507 && t <= 128591 || t >= 128640 && t <= 128709 || t === 128716 || t >= 128720 && t <= 128722 || t >= 128725 && t <= 128727 || t >= 128732 && t <= 128735 || t === 128747 || t === 128748 || t >= 128756 && t <= 128764 || t >= 128992 && t <= 129003 || t === 129008 || t >= 129292 && t <= 129338 || t >= 129340 && t <= 129349 || t >= 129351 && t <= 129535 || t >= 129648 && t <= 129660 || t >= 129664 && t <= 129672 || t >= 129680 && t <= 129725 || t >= 129727 && t <= 129733 || t >= 129742 && t <= 129755 || t >= 129760 && t <= 129768 || t >= 129776 && t <= 129784 || t >= 131072 && t <= 196605 || t >= 196608 && t <= 262141;
}
var nQ = (t) => !(rQ(t) || iQ(t)), sQ = /[^\x20-\x7F]/;
function aQ(t) {
  if (!t)
    return 0;
  if (!sQ.test(t))
    return t.length;
  t = t.replace(tQ(), "  ");
  let e = 0;
  for (let r of t) {
    let i = r.codePointAt(0);
    i <= 31 || i >= 127 && i <= 159 || i >= 768 && i <= 879 || (e += nQ(i) ? 1 : 2);
  }
  return e;
}
var Fa = aQ;
function kg(t) {
  return (e, r, i) => {
    let n = !!(i != null && i.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, a = r;
    for (; a >= 0 && a < s; ) {
      let o = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(o))
          return a;
      } else if (!t.includes(o))
        return a;
      n ? a-- : a++;
    }
    return a === -1 || a === s ? a : !1;
  };
}
var $a = kg(" 	"), oQ = kg(",; 	"), lQ = kg(/[^\n\r]/);
function uQ(t, e, r) {
  let i = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let n = t.charAt(e);
  if (i) {
    if (t.charAt(e - 1) === "\r" && n === `
`)
      return e - 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e - 1;
  } else {
    if (n === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e + 1;
  }
  return e;
}
var Ba = uQ;
function cQ(t, e, r = {}) {
  let i = $a(t, r.backwards ? e - 1 : e, r), n = Ba(t, i, r);
  return i !== n;
}
var Cr = cQ;
function hQ(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var Tg = hQ;
function pQ(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? lQ(t, e) : e;
}
var Pg = pQ;
function dQ(t, e) {
  let r = null, i = e;
  for (; i !== r; )
    r = i, i = oQ(t, i), i = Tg(t, i), i = $a(t, i);
  return i = Pg(t, i), i = Ba(t, i), i !== !1 && Cr(t, i);
}
var Fg = dQ;
function fQ(t) {
  return Array.isArray(t) && t.length > 0;
}
var Ze = fQ, Au = "'", yO = '"';
function mQ(t, e) {
  let r = e === !0 || e === Au ? Au : yO, i = r === Au ? yO : Au, n = 0, s = 0;
  for (let a of t)
    a === r ? n++ : a === i && s++;
  return n > s ? i : r;
}
var hv = mQ;
function gQ(t, e, r) {
  let i = e === '"' ? "'" : '"', n = Dr(!1, t, /\\(.)|(["'])/gs, (s, a, o) => a === i ? a : o === e ? "\\" + o : o || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(a) ? a : "\\" + a));
  return e + n + e;
}
var yQ = gQ;
function OQ(t, e) {
  let r = t.slice(1, -1), i = e.parser === "json" || e.parser === "jsonc" || e.parser === "json5" && e.quoteProps === "preserve" && !e.singleQuote ? '"' : e.__isInHtmlAttribute ? "'" : hv(r, e.singleQuote);
  return yQ(r, i, !(e.parser === "css" || e.parser === "less" || e.parser === "scss" || e.__embeddedInHtml));
}
var ol = OQ;
function ot(t) {
  var e, r, i;
  let n = ((e = t.range) == null ? void 0 : e[0]) ?? t.start, s = (i = ((r = t.declaration) == null ? void 0 : r.decorators) ?? t.decorators) == null ? void 0 : i[0];
  return s ? Math.min(ot(s), n) : n;
}
function We(t) {
  var e;
  return ((e = t.range) == null ? void 0 : e[1]) ?? t.end;
}
function Vh(t, e) {
  let r = ot(t);
  return Number.isInteger(r) && r === ot(e);
}
function xQ(t, e) {
  let r = We(t);
  return Number.isInteger(r) && r === We(e);
}
function bQ(t, e) {
  return Vh(t, e) && xQ(t, e);
}
var bo = null;
function Vo(t) {
  if (bo !== null && typeof bo.property) {
    let e = bo;
    return bo = Vo.prototype = null, e;
  }
  return bo = Vo.prototype = t ?? /* @__PURE__ */ Object.create(null), new Vo();
}
var DQ = 10;
for (let t = 0; t <= DQ; t++)
  Vo();
function vQ(t) {
  return Vo(t);
}
function SQ(t, e = "type") {
  vQ(t);
  function r(i) {
    let n = i[e], s = t[n];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: i });
    return s;
  }
  return r;
}
var pv = SQ, wQ = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value", "optional", "static", "method"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareEnum: ["id", "body"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], AsConstExpression: ["expression"], SatisfiesExpression: ["expression", "typeAnnotation"] }, CQ = pv(wQ), dv = CQ;
function AQ(t) {
  let e = new Set(t);
  return (r) => e.has(r == null ? void 0 : r.type);
}
var Ue = AQ, EQ = Ue(["Block", "CommentBlock", "MultiLine"]), Vr = EQ, kQ = Ue(["AnyTypeAnnotation", "ThisTypeAnnotation", "NumberTypeAnnotation", "VoidTypeAnnotation", "BooleanTypeAnnotation", "BigIntTypeAnnotation", "SymbolTypeAnnotation", "StringTypeAnnotation", "NeverTypeAnnotation", "UndefinedTypeAnnotation", "UnknownTypeAnnotation", "EmptyTypeAnnotation", "MixedTypeAnnotation"]), fv = kQ;
function TQ(t, e) {
  let r = e.split(".");
  for (let i = r.length - 1; i >= 0; i--) {
    let n = r[i];
    if (i === 0)
      return t.type === "Identifier" && t.name === n;
    if (t.type !== "MemberExpression" || t.optional || t.computed || t.property.type !== "Identifier" || t.property.name !== n)
      return !1;
    t = t.object;
  }
}
function PQ(t, e) {
  return e.some((r) => TQ(t, r));
}
var FQ = PQ;
function $Q({ type: t }) {
  return t.startsWith("TS") && t.endsWith("Keyword");
}
var mv = $Q;
function rf(t, e) {
  return e(t) || eQ(t, { getVisitorKeys: dv, predicate: e });
}
function $g(t) {
  return t.type === "AssignmentExpression" || t.type === "BinaryExpression" || t.type === "LogicalExpression" || t.type === "NGPipeExpression" || t.type === "ConditionalExpression" || Re(t) || at(t) || t.type === "SequenceExpression" || t.type === "TaggedTemplateExpression" || t.type === "BindExpression" || t.type === "UpdateExpression" && !t.prefix || Ci(t) || t.type === "TSNonNullExpression" || t.type === "ChainExpression";
}
function BQ(t) {
  return t.expressions ? t.expressions[0] : t.left ?? t.test ?? t.callee ?? t.object ?? t.tag ?? t.argument ?? t.expression;
}
function gv(t) {
  if (t.expressions)
    return ["expressions", 0];
  if (t.left)
    return ["left"];
  if (t.test)
    return ["test"];
  if (t.object)
    return ["object"];
  if (t.callee)
    return ["callee"];
  if (t.tag)
    return ["tag"];
  if (t.argument)
    return ["argument"];
  if (t.expression)
    return ["expression"];
  throw new Error("Unexpected node has no left side.");
}
var Yh = Ue(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose", "Hashbang", "InterpreterDirective"]), IQ = Ue(["ExportDefaultDeclaration", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "DeclareExportAllDeclaration"]), _t = Ue(["ArrayExpression", "TupleExpression"]), oi = Ue(["ObjectExpression", "RecordExpression"]);
function jn(t) {
  return t.type === "NumericLiteral" || t.type === "Literal" && typeof t.value == "number";
}
function yv(t) {
  return t.type === "UnaryExpression" && (t.operator === "+" || t.operator === "-") && jn(t.argument);
}
function lr(t) {
  return t.type === "StringLiteral" || t.type === "Literal" && typeof t.value == "string";
}
function Ov(t) {
  return t.type === "RegExpLiteral" || t.type === "Literal" && !!t.regex;
}
var Uh = Ue(["Literal", "BooleanLiteral", "BigIntLiteral", "DecimalLiteral", "DirectiveLiteral", "NullLiteral", "NumericLiteral", "RegExpLiteral", "StringLiteral"]), xv = Ue(["Identifier", "ThisExpression", "Super", "PrivateName", "PrivateIdentifier", "Import"]), Zn = Ue(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), ll = Ue(["FunctionExpression", "ArrowFunctionExpression"]);
function NQ(t) {
  return t.type === "FunctionExpression" || t.type === "ArrowFunctionExpression" && t.body.type === "BlockStatement";
}
function Xp(t) {
  return Re(t) && t.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(t.callee.name);
}
var vt = Ue(["JSXElement", "JSXFragment"]);
function zh(t) {
  return t.method && t.kind === "init" || t.kind === "get" || t.kind === "set";
}
function bv(t) {
  return (t.type === "ObjectTypeProperty" || t.type === "ObjectTypeInternalSlot") && !t.static && !t.method && t.kind !== "get" && t.kind !== "set" && t.value.type === "FunctionTypeAnnotation";
}
function _Q(t) {
  return (t.type === "TypeAnnotation" || t.type === "TSTypeAnnotation") && t.typeAnnotation.type === "FunctionTypeAnnotation" && !t.static && !Vh(t, t.typeAnnotation);
}
var Ji = Ue(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
function la(t) {
  return at(t) || t.type === "BindExpression" && !!t.object;
}
var QQ = Ue(["TSThisType", "NullLiteralTypeAnnotation", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType"]);
function Bg(t) {
  return mv(t) || fv(t) || QQ(t) || (t.type === "GenericTypeAnnotation" || t.type === "TSTypeReference") && !t.typeParameters;
}
function MQ(t) {
  let e = /^(?:before|after)(?:Each|All)$/;
  return t.callee.type === "Identifier" && t.arguments.length === 1 && e.test(t.callee.name);
}
var LQ = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
function RQ(t) {
  return FQ(t, LQ);
}
function Gh(t, e) {
  if (t.type !== "CallExpression")
    return !1;
  if (t.arguments.length === 1) {
    if (Xp(t) && e && Gh(e))
      return ll(t.arguments[0]);
    if (MQ(t))
      return Xp(t.arguments[0]);
  } else if ((t.arguments.length === 2 || t.arguments.length === 3) && (t.arguments[0].type === "TemplateLiteral" || lr(t.arguments[0])) && RQ(t.callee))
    return t.arguments[2] && !jn(t.arguments[2]) ? !1 : (t.arguments.length === 2 ? ll(t.arguments[1]) : NQ(t.arguments[1]) && Vt(t.arguments[1]).length <= 1) || Xp(t.arguments[1]);
  return !1;
}
var Dv = (t) => (e) => ((e == null ? void 0 : e.type) === "ChainExpression" && (e = e.expression), t(e)), Re = Dv(Ue(["CallExpression", "OptionalCallExpression"])), at = Dv(Ue(["MemberExpression", "OptionalMemberExpression"]));
function jQ(t) {
  let e = "expressions";
  t.type === "TSTemplateLiteralType" && (e = "types");
  let r = t[e];
  return r.length === 0 ? !1 : r.every((i) => {
    if (nf(i) || vv(i))
      return !0;
  });
}
function vv(t, { maxDepth: e = Number.POSITIVE_INFINITY } = {}) {
  if (se(t))
    return !1;
  if (t.type === "ChainExpression")
    return vv(t.expression, { maxDepth: e });
  if (!at(t))
    return !1;
  let r = t, i = 0;
  for (; at(r) && i++ <= e; )
    if (!nf(r.property) || (r = r.object, se(r)))
      return !1;
  return nf(r);
}
function nf(t) {
  return se(t) ? !1 : Uh(t) || xv(t);
}
function OO(t, e = 5) {
  return Sv(t, e) <= e;
}
function Sv(t, e) {
  let r = 0;
  for (let i in t) {
    let n = t[i];
    if (n && typeof n == "object" && typeof n.type == "string" && (r++, r += Sv(n, e - r)), r > e)
      return r;
  }
  return r;
}
var ZQ = 0.25;
function Ig(t, e) {
  let { printWidth: r } = e;
  if (se(t))
    return !1;
  let i = r * ZQ;
  if (t.type === "ThisExpression" || t.type === "Identifier" && t.name.length <= i || yv(t) && !se(t.argument))
    return !0;
  let n = t.type === "Literal" && "regex" in t && t.regex.pattern || t.type === "RegExpLiteral" && t.pattern;
  return n ? n.length <= i : lr(t) ? ol(Zr(t), e).length <= i : t.type === "TemplateLiteral" ? t.expressions.length === 0 && t.quasis[0].value.raw.length <= i && !t.quasis[0].value.raw.includes(`
`) : t.type === "UnaryExpression" ? Ig(t.argument, { printWidth: r }) : t.type === "CallExpression" && t.arguments.length === 0 && t.callee.type === "Identifier" ? t.callee.name.length <= i - 2 : Uh(t);
}
function Ss(t, e) {
  return vt(e) ? Hh(e) : se(e, de.Leading, (r) => Cr(t, We(r)));
}
function xO(t, e) {
  return e.parser !== "json" && e.parser !== "jsonc" && lr(t.key) && Zr(t.key).slice(1, -1) === t.key.value && (z7(t.key.value) && !(e.parser === "babel-ts" && t.type === "ClassProperty" || e.parser === "typescript" && t.type === "PropertyDefinition") || wv(t.key.value) && String(Number(t.key.value)) === t.key.value && (e.parser === "babel" || e.parser === "acorn" || e.parser === "espree" || e.parser === "meriyah" || e.parser === "__babel_estree"));
}
function wv(t) {
  return /^(?:\d+|\d+\.\d+)$/.test(t);
}
function bO(t) {
  return t.quasis.some((e) => e.value.raw.includes(`
`));
}
function Cv(t, e) {
  return (t.type === "TemplateLiteral" && bO(t) || t.type === "TaggedTemplateExpression" && bO(t.quasi)) && !Cr(e, ot(t), { backwards: !0 });
}
function Av(t) {
  if (!se(t))
    return !1;
  let e = qe(!1, xa(t, de.Dangling), -1);
  return e && !Vr(e);
}
function WQ(t) {
  if (t.length <= 1)
    return !1;
  let e = 0;
  for (let r of t)
    if (ll(r)) {
      if (e += 1, e > 1)
        return !0;
    } else if (Re(r)) {
      for (let i of Wr(r))
        if (ll(i))
          return !0;
    }
  return !1;
}
function Ev(t) {
  let { node: e, parent: r, key: i } = t;
  return i === "callee" && Re(e) && Re(r) && r.arguments.length > 0 && e.arguments.length > r.arguments.length;
}
var qQ = /* @__PURE__ */ new Set(["!", "-", "+", "~"]);
function ri(t, e = 2) {
  if (e <= 0)
    return !1;
  if (t.type === "ChainExpression" || t.type === "TSNonNullExpression")
    return ri(t.expression, e);
  let r = (i) => ri(i, e - 1);
  if (Ov(t))
    return Fa(t.pattern ?? t.regex.pattern) <= 5;
  if (Uh(t) || xv(t) || t.type === "ArgumentPlaceholder")
    return !0;
  if (t.type === "TemplateLiteral")
    return t.quasis.every((i) => !i.value.raw.includes(`
`)) && t.expressions.every(r);
  if (oi(t))
    return t.properties.every((i) => !i.computed && (i.shorthand || i.value && r(i.value)));
  if (_t(t))
    return t.elements.every((i) => i === null || r(i));
  if (Ia(t)) {
    if (t.type === "ImportExpression" || ri(t.callee, e)) {
      let i = Wr(t);
      return i.length <= e && i.every(r);
    }
    return !1;
  }
  return at(t) ? ri(t.object, e) && ri(t.property, e) : t.type === "UnaryExpression" && qQ.has(t.operator) || t.type === "UpdateExpression" ? ri(t.argument, e) : !1;
}
function Zr(t) {
  var e;
  return ((e = t.extra) == null ? void 0 : e.raw) ?? t.raw;
}
function XQ(t) {
  return t;
}
function Jn(t, e = "es5") {
  return t.trailingComma === "es5" && e === "es5" || t.trailingComma === "all" && (e === "all" || e === "es5");
}
function zt(t, e) {
  switch (t.type) {
    case "BinaryExpression":
    case "LogicalExpression":
    case "AssignmentExpression":
    case "NGPipeExpression":
      return zt(t.left, e);
    case "MemberExpression":
    case "OptionalMemberExpression":
      return zt(t.object, e);
    case "TaggedTemplateExpression":
      return t.tag.type === "FunctionExpression" ? !1 : zt(t.tag, e);
    case "CallExpression":
    case "OptionalCallExpression":
      return t.callee.type === "FunctionExpression" ? !1 : zt(t.callee, e);
    case "ConditionalExpression":
      return zt(t.test, e);
    case "UpdateExpression":
      return !t.prefix && zt(t.argument, e);
    case "BindExpression":
      return t.object && zt(t.object, e);
    case "SequenceExpression":
      return zt(t.expressions[0], e);
    case "ChainExpression":
    case "TSSatisfiesExpression":
    case "TSAsExpression":
    case "TSNonNullExpression":
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
      return zt(t.expression, e);
    default:
      return e(t);
  }
}
var DO = { "==": !0, "!=": !0, "===": !0, "!==": !0 }, Eu = { "*": !0, "/": !0, "%": !0 }, sf = { ">>": !0, ">>>": !0, "<<": !0 };
function Ng(t, e) {
  return !($c(e) !== $c(t) || t === "**" || DO[t] && DO[e] || e === "%" && Eu[t] || t === "%" && Eu[e] || e !== t && Eu[e] && Eu[t] || sf[t] && sf[e]);
}
var VQ = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((t, e) => t.map((r) => [r, e])));
function $c(t) {
  return VQ.get(t);
}
function YQ(t) {
  return !!sf[t] || t === "|" || t === "^" || t === "&";
}
function UQ(t) {
  var e;
  if (t.rest)
    return !0;
  let r = Vt(t);
  return ((e = qe(!1, r, -1)) == null ? void 0 : e.type) === "RestElement";
}
var Vp = /* @__PURE__ */ new WeakMap();
function Vt(t) {
  if (Vp.has(t))
    return Vp.get(t);
  let e = [];
  return t.this && e.push(t.this), Array.isArray(t.parameters) ? e.push(...t.parameters) : Array.isArray(t.params) && e.push(...t.params), t.rest && e.push(t.rest), Vp.set(t, e), e;
}
function zQ(t, e) {
  let { node: r } = t, i = 0, n = (s) => e(s, i++);
  r.this && t.call(n, "this"), Array.isArray(r.parameters) ? t.each(n, "parameters") : Array.isArray(r.params) && t.each(n, "params"), r.rest && t.call(n, "rest");
}
var Yp = /* @__PURE__ */ new WeakMap();
function Wr(t) {
  if (Yp.has(t))
    return Yp.get(t);
  if (t.type === "ChainExpression")
    return Wr(t.expression);
  let e = t.arguments;
  return t.type === "ImportExpression" && (e = [t.source], t.attributes && e.push(t.attributes), t.options && e.push(t.options)), Yp.set(t, e), e;
}
function _g(t, e) {
  let { node: r } = t;
  if (r.type === "ChainExpression")
    return t.call(() => _g(t, e), "expression");
  r.type === "ImportExpression" ? (t.call((i) => e(i, 0), "source"), r.attributes && t.call((i) => e(i, 1), "attributes"), r.options && t.call((i) => e(i, 1), "options")) : t.each(e, "arguments");
}
function vO(t, e) {
  let r = [];
  if (t.type === "ChainExpression" && r.push("expression"), t.type === "ImportExpression") {
    if (e === 0 || e === (t.attributes || t.options ? -2 : -1))
      return [...r, "source"];
    if (t.attributes && (e === 1 || e === -1))
      return [...r, "attributes"];
    if (t.options && (e === 1 || e === -1))
      return [...r, "options"];
    throw new RangeError("Invalid argument index");
  }
  if (e < 0 && (e = t.arguments.length + e), e < 0 || e >= t.arguments.length)
    throw new RangeError("Invalid argument index");
  return [...r, "arguments", e];
}
function Bc(t) {
  return t.value.trim() === "prettier-ignore" && !t.unignore;
}
function Hh(t) {
  return (t == null ? void 0 : t.prettierIgnore) || se(t, de.PrettierIgnore);
}
var de = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, kv = (t, e) => {
  if (typeof t == "function" && (e = t, t = 0), t || e)
    return (r, i, n) => !(t & de.Leading && !r.leading || t & de.Trailing && !r.trailing || t & de.Dangling && (r.leading || r.trailing) || t & de.Block && !Vr(r) || t & de.Line && !Yh(r) || t & de.First && i !== 0 || t & de.Last && i !== n.length - 1 || t & de.PrettierIgnore && !Bc(r) || e && !e(r));
};
function se(t, e, r) {
  if (!Ze(t == null ? void 0 : t.comments))
    return !1;
  let i = kv(e, r);
  return i ? t.comments.some(i) : !0;
}
function xa(t, e, r) {
  if (!Array.isArray(t == null ? void 0 : t.comments))
    return [];
  let i = kv(e, r);
  return i ? t.comments.filter(i) : t.comments;
}
var Kn = (t, { originalText: e }) => Fg(e, We(t));
function Ia(t) {
  return Re(t) || t.type === "NewExpression" || t.type === "ImportExpression";
}
function dn(t) {
  return t && (t.type === "ObjectProperty" || t.type === "Property" && !zh(t));
}
var Ci = Ue(["TSAsExpression", "TSSatisfiesExpression", "AsExpression", "AsConstExpression", "SatisfiesExpression"]), ws = Ue(["UnionTypeAnnotation", "TSUnionType"]), Tv = Ue(["IntersectionTypeAnnotation", "TSIntersectionType"]), GQ = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), ia = (t) => {
  for (let e of t.quasis)
    delete e.value;
};
function Pv(t, e, r) {
  var i, n;
  if (t.type === "Program" && delete e.sourceType, (t.type === "BigIntLiteral" || t.type === "BigIntLiteralTypeAnnotation") && e.value && (e.value = e.value.toLowerCase()), (t.type === "BigIntLiteral" || t.type === "Literal") && e.bigint && (e.bigint = e.bigint.toLowerCase()), t.type === "DecimalLiteral" && (e.value = Number(e.value)), t.type === "Literal" && e.decimal && (e.decimal = Number(e.decimal)), t.type === "EmptyStatement" || t.type === "JSXText" || t.type === "JSXExpressionContainer" && (t.expression.type === "Literal" || t.expression.type === "StringLiteral") && t.expression.value === " ")
    return null;
  if ((t.type === "Property" || t.type === "ObjectProperty" || t.type === "MethodDefinition" || t.type === "ClassProperty" || t.type === "ClassMethod" || t.type === "PropertyDefinition" || t.type === "TSDeclareMethod" || t.type === "TSPropertySignature" || t.type === "ObjectTypeProperty") && typeof t.key == "object" && t.key && (t.key.type === "Literal" || t.key.type === "NumericLiteral" || t.key.type === "StringLiteral" || t.key.type === "Identifier") && delete e.key, t.type === "JSXElement" && t.openingElement.name.name === "style" && t.openingElement.attributes.some((a) => a.type === "JSXAttribute" && a.name.name === "jsx"))
    for (let { type: a, expression: o } of e.children)
      a === "JSXExpressionContainer" && o.type === "TemplateLiteral" && ia(o);
  t.type === "JSXAttribute" && t.name.name === "css" && t.value.type === "JSXExpressionContainer" && t.value.expression.type === "TemplateLiteral" && ia(e.value.expression), t.type === "JSXAttribute" && ((i = t.value) == null ? void 0 : i.type) === "Literal" && /["']|&quot;|&apos;/.test(t.value.value) && (e.value.value = Dr(!1, e.value.value, /["']|&quot;|&apos;/g, '"'));
  let s = t.expression || t.callee;
  if (t.type === "Decorator" && s.type === "CallExpression" && s.callee.name === "Component" && s.arguments.length === 1) {
    let a = t.expression.arguments[0].properties;
    for (let [o, u] of e.expression.arguments[0].properties.entries())
      switch (a[o].key.name) {
        case "styles":
          _t(u.value) && ia(u.value.elements[0]);
          break;
        case "template":
          u.value.type === "TemplateLiteral" && ia(u.value);
          break;
      }
  }
  if (t.type === "TaggedTemplateExpression" && (t.tag.type === "MemberExpression" || t.tag.type === "Identifier" && (t.tag.name === "gql" || t.tag.name === "graphql" || t.tag.name === "css" || t.tag.name === "md" || t.tag.name === "markdown" || t.tag.name === "html") || t.tag.type === "CallExpression") && ia(e.quasi), t.type === "TemplateLiteral" && ((n = t.leadingComments) != null && n.some((a) => Vr(a) && ["GraphQL", "HTML"].some((o) => a.value === ` ${o} `)) || r.type === "CallExpression" && r.callee.name === "graphql" || !t.leadingComments) && ia(e), (t.type === "TSIntersectionType" || t.type === "TSUnionType") && t.types.length === 1)
    return e.types[0];
  t.type === "ChainExpression" && t.expression.type === "TSNonNullExpression" && ([e.type, e.expression.type] = [e.expression.type, e.type]);
}
Pv.ignoredProperties = GQ;
var HQ = Pv, za = "string", Cs = "array", Ga = "cursor", Rs = "indent", js = "align", Ha = "trim", qr = "group", Ni = "fill", Ti = "if-break", Zs = "indent-if-break", Ws = "line-suffix", qs = "line-suffix-boundary", Tr = "line", es = "label", ts = "break-parent", Fv = /* @__PURE__ */ new Set([Ga, Rs, js, Ha, qr, Ni, Ti, Zs, Ws, qs, Tr, es, ts]);
function JQ(t) {
  if (typeof t == "string")
    return za;
  if (Array.isArray(t))
    return Cs;
  if (!t)
    return;
  let { type: e } = t;
  if (Fv.has(e))
    return e;
}
var Ja = JQ, KQ = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function e9(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (Ja(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let i = KQ([...Fv].map((n) => `'${n}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${i}.`;
}
var t9 = class extends Error {
  constructor(e) {
    super(e9(e));
    Gr(this, "name", "InvalidDocError");
    this.doc = e;
  }
}, ul = t9, SO = {};
function r9(t, e, r, i) {
  let n = [t];
  for (; n.length > 0; ) {
    let s = n.pop();
    if (s === SO) {
      r(n.pop());
      continue;
    }
    r && n.push(s, SO);
    let a = Ja(s);
    if (!a)
      throw new ul(s);
    if ((e == null ? void 0 : e(s)) !== !1)
      switch (a) {
        case Cs:
        case Ni: {
          let o = a === Cs ? s : s.parts;
          for (let u = o.length, c = u - 1; c >= 0; --c)
            n.push(o[c]);
          break;
        }
        case Ti:
          n.push(s.flatContents, s.breakContents);
          break;
        case qr:
          if (i && s.expandedStates)
            for (let o = s.expandedStates.length, u = o - 1; u >= 0; --u)
              n.push(s.expandedStates[u]);
          else
            n.push(s.contents);
          break;
        case js:
        case Rs:
        case Zs:
        case es:
        case Ws:
          n.push(s.contents);
          break;
        case za:
        case Ga:
        case Ha:
        case qs:
        case Tr:
        case ts:
          break;
        default:
          throw new ul(s);
      }
  }
}
var $v = r9, i9 = () => {
}, n9 = i9;
function te(t) {
  return { type: Rs, contents: t };
}
function _i(t, e) {
  return { type: js, contents: e, n: t };
}
function Z(t, e = {}) {
  return n9(e.expandedStates), { type: qr, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function s9(t) {
  return _i(Number.NEGATIVE_INFINITY, t);
}
function Bv(t) {
  return _i(-1, t);
}
function fs(t, e) {
  return Z(t[0], { ...e, expandedStates: t });
}
function Qg(t) {
  return { type: Ni, parts: t };
}
function Ee(t, e = "", r = {}) {
  return { type: Ti, breakContents: t, flatContents: e, groupId: r.groupId };
}
function Jh(t, e) {
  return { type: Zs, contents: t, groupId: e.groupId, negate: e.negate };
}
function wO(t) {
  return { type: Ws, contents: t };
}
var Ki = { type: qs }, Qi = { type: ts }, Iv = { type: Tr, hard: !0 }, a9 = { type: Tr, hard: !0, literal: !0 }, he = { type: Tr }, H = { type: Tr, soft: !0 }, ee = [Iv, Qi], Nv = [a9, Qi], CO = { type: Ga };
function Ne(t, e) {
  let r = [];
  for (let i = 0; i < e.length; i++)
    i !== 0 && r.push(t), r.push(e[i]);
  return r;
}
function o9(t, e, r) {
  let i = t;
  if (e > 0) {
    for (let n = 0; n < Math.floor(e / r); ++n)
      i = te(i);
    i = _i(e % r, i), i = _i(Number.NEGATIVE_INFINITY, i);
  }
  return i;
}
function Zl(t, e) {
  return t ? { type: es, label: t, contents: e } : e;
}
var _v = (t) => {
  if (Array.isArray(t))
    return t;
  if (t.type !== Ni)
    throw new Error(`Expect doc to be 'array' or '${Ni}'.`);
  return t.parts;
};
function Ka(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return i(t);
  function i(s) {
    if (r.has(s))
      return r.get(s);
    let a = n(s);
    return r.set(s, a), a;
  }
  function n(s) {
    switch (Ja(s)) {
      case Cs:
        return e(s.map(i));
      case Ni:
        return e({ ...s, parts: s.parts.map(i) });
      case Ti:
        return e({ ...s, breakContents: i(s.breakContents), flatContents: i(s.flatContents) });
      case qr: {
        let { expandedStates: a, contents: o } = s;
        return a ? (a = a.map(i), o = a[0]) : o = i(o), e({ ...s, contents: o, expandedStates: a });
      }
      case js:
      case Rs:
      case Zs:
      case es:
      case Ws:
        return e({ ...s, contents: i(s.contents) });
      case za:
      case Ga:
      case Ha:
      case qs:
      case Tr:
      case ts:
        return e(s);
      default:
        throw new ul(s);
    }
  }
}
function Qv(t, e, r) {
  let i = r, n = !1;
  function s(a) {
    if (n)
      return !1;
    let o = e(a);
    o !== void 0 && (n = !0, i = o);
  }
  return $v(t, s), i;
}
function l9(t) {
  if (t.type === qr && t.break || t.type === Tr && t.hard || t.type === ts)
    return !0;
}
function Gt(t) {
  return Qv(t, l9, !1);
}
function AO(t) {
  if (t.length > 0) {
    let e = qe(!1, t, -1);
    !e.expandedStates && !e.break && (e.break = "propagated");
  }
  return null;
}
function u9(t) {
  let e = /* @__PURE__ */ new Set(), r = [];
  function i(s) {
    if (s.type === ts && AO(r), s.type === qr) {
      if (r.push(s), e.has(s))
        return !1;
      e.add(s);
    }
  }
  function n(s) {
    s.type === qr && r.pop().break && AO(r);
  }
  $v(t, i, n, !0);
}
function c9(t) {
  return t.type === Tr && !t.hard ? t.soft ? "" : " " : t.type === Ti ? t.flatContents : t;
}
function af(t) {
  return Ka(t, c9);
}
function h9(t) {
  switch (Ja(t)) {
    case Ni:
      if (t.parts.every((e) => e === ""))
        return "";
      break;
    case qr:
      if (!t.contents && !t.id && !t.break && !t.expandedStates)
        return "";
      if (t.contents.type === qr && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates)
        return t.contents;
      break;
    case js:
    case Rs:
    case Zs:
    case Ws:
      if (!t.contents)
        return "";
      break;
    case Ti:
      if (!t.flatContents && !t.breakContents)
        return "";
      break;
    case Cs: {
      let e = [];
      for (let r of t) {
        if (!r)
          continue;
        let [i, ...n] = Array.isArray(r) ? r : [r];
        typeof i == "string" && typeof qe(!1, e, -1) == "string" ? e[e.length - 1] += i : e.push(i), e.push(...n);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case za:
    case Ga:
    case Ha:
    case qs:
    case Tr:
    case es:
    case ts:
      break;
    default:
      throw new ul(t);
  }
  return t;
}
function Mg(t) {
  return Ka(t, (e) => h9(e));
}
function As(t, e = Nv) {
  return Ka(t, (r) => typeof r == "string" ? Ne(e, r.split(`
`)) : r);
}
function p9(t) {
  if (t.type === Tr)
    return !0;
}
function d9(t) {
  return Qv(t, p9, !1);
}
function of(t, e) {
  return t.type === es ? { ...t, contents: e(t.contents) } : e(t);
}
function f9(t) {
  let e = `*${t.value}*`.split(`
`);
  return e.length > 1 && e.every((r) => r.trimStart()[0] === "*");
}
var m9 = f9;
function g9(t, e) {
  let r = t.node;
  if (Yh(r))
    return e.originalText.slice(ot(r), We(r)).trimEnd();
  if (Vr(r))
    return m9(r) ? y9(r) : ["/*", As(r.value), "*/"];
  throw new Error("Not a comment: " + JSON.stringify(r));
}
function y9(t) {
  let e = t.value.split(`
`);
  return ["/*", Ne(ee, e.map((r, i) => i === 0 ? r.trimEnd() : " " + (i < e.length - 1 ? r.trim() : r.trimStart()))), "*/"];
}
var Mv = {};
Xh(Mv, { endOfLine: () => C9, ownLine: () => w9, remaining: () => A9 });
function O9(t) {
  let e = t.type || t.kind || "(unknown type)", r = String(t.name || t.id && (typeof t.id == "object" ? t.id.name : t.id) || t.key && (typeof t.key == "object" ? t.key.name : t.key) || t.value && (typeof t.value == "object" ? "" : String(t.value)) || t.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + ""), e + (r ? " " + r : "");
}
function Lg(t, e) {
  (t.comments ?? (t.comments = [])).push(e), e.printed = !1, e.nodeDescription = O9(t);
}
function Qt(t, e) {
  e.leading = !0, e.trailing = !1, Lg(t, e);
}
function Ar(t, e, r) {
  e.leading = !1, e.trailing = !1, r && (e.marker = r), Lg(t, e);
}
function dt(t, e) {
  e.leading = !1, e.trailing = !0, Lg(t, e);
}
function x9(t, e) {
  let r = null, i = e;
  for (; i !== r; )
    r = i, i = $a(t, i), i = Tg(t, i), i = Pg(t, i), i = Ba(t, i);
  return i;
}
var Wl = x9;
function b9(t, e) {
  let r = Wl(t, e);
  return r === !1 ? "" : t.charAt(r);
}
var en = b9;
function D9(t, e, r) {
  for (let i = e; i < r; ++i)
    if (t.charAt(i) === `
`)
      return !0;
  return !1;
}
var Wn = D9;
function v9(t) {
  return Vr(t) && t.value[0] === "*" && /@(?:type|satisfies)\b/.test(t.value);
}
var S9 = v9;
function w9(t) {
  return [Vv, Rv, Wv, k9, Rg, jg, Lv, jv, R9, M9, Wg, Xv, j9, Zv, qv, Zg, T9, z9].some((e) => e(t));
}
function C9(t) {
  return [E9, Wv, Rv, Xv, Rg, jg, Lv, jv, qv, Q9, L9, Wg, q9, Zg, Y9, U9].some((e) => e(t));
}
function A9(t) {
  return [Vv, Rg, jg, P9, _9, Zv, Wg, N9, I9, V9, Zg, X9].some((e) => e(t));
}
function Xs(t, e) {
  let r = (t.body || t.properties).find(({ type: i }) => i !== "EmptyStatement");
  r ? Qt(r, e) : Ar(t, e);
}
function lf(t, e) {
  t.type === "BlockStatement" ? Xs(t, e) : Qt(t, e);
}
function E9({ comment: t, followingNode: e }) {
  return e && S9(t) ? (Qt(e, t), !0) : !1;
}
function Rg({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i, text: n }) {
  if ((r == null ? void 0 : r.type) !== "IfStatement" || !i)
    return !1;
  if (en(n, We(t)) === ")")
    return dt(e, t), !0;
  if (e === r.consequent && i === r.alternate) {
    if (e.type === "BlockStatement")
      dt(e, t);
    else {
      let s = Yh(t) || t.loc.start.line === t.loc.end.line, a = t.loc.start.line === e.loc.start.line;
      s && a ? dt(e, t) : Ar(r, t);
    }
    return !0;
  }
  return i.type === "BlockStatement" ? (Xs(i, t), !0) : i.type === "IfStatement" ? (lf(i.consequent, t), !0) : r.consequent === i ? (Qt(i, t), !0) : !1;
}
function jg({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i, text: n }) {
  return (r == null ? void 0 : r.type) !== "WhileStatement" || !i ? !1 : en(n, We(t)) === ")" ? (dt(e, t), !0) : i.type === "BlockStatement" ? (Xs(i, t), !0) : r.body === i ? (Qt(i, t), !0) : !1;
}
function Lv({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i }) {
  return (r == null ? void 0 : r.type) !== "TryStatement" && (r == null ? void 0 : r.type) !== "CatchClause" || !i ? !1 : r.type === "CatchClause" && e ? (dt(e, t), !0) : i.type === "BlockStatement" ? (Xs(i, t), !0) : i.type === "TryStatement" ? (lf(i.finalizer, t), !0) : i.type === "CatchClause" ? (lf(i.body, t), !0) : !1;
}
function k9({ comment: t, enclosingNode: e, followingNode: r }) {
  return at(e) && (r == null ? void 0 : r.type) === "Identifier" ? (Qt(e, t), !0) : !1;
}
function T9({ comment: t, enclosingNode: e, followingNode: r, options: i }) {
  return !i.experimentalTernaries || !((e == null ? void 0 : e.type) === "ConditionalExpression" || (e == null ? void 0 : e.type) === "ConditionalTypeAnnotation" || (e == null ? void 0 : e.type) === "TSConditionalType") ? !1 : (r == null ? void 0 : r.type) === "ConditionalExpression" || (r == null ? void 0 : r.type) === "ConditionalTypeAnnotation" || (r == null ? void 0 : r.type) === "TSConditionalType" ? (Ar(e, t), !0) : !1;
}
function Rv({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i, text: n, options: s }) {
  let a = e && !Wn(n, We(e), ot(t));
  return (!e || !a) && ((r == null ? void 0 : r.type) === "ConditionalExpression" || (r == null ? void 0 : r.type) === "ConditionalTypeAnnotation" || (r == null ? void 0 : r.type) === "TSConditionalType") && i ? s.experimentalTernaries && r.alternate === i && !(Vr(t) && !Wn(s.originalText, ot(t), We(t))) ? (Ar(r, t), !0) : (Qt(i, t), !0) : !1;
}
function P9({ comment: t, precedingNode: e, enclosingNode: r }) {
  return dn(r) && r.shorthand && r.key === e && r.value.type === "AssignmentPattern" ? (dt(r.value.left, t), !0) : !1;
}
var F9 = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
function jv({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i }) {
  if (F9.has(r == null ? void 0 : r.type)) {
    if (Ze(r.decorators) && (i == null ? void 0 : i.type) !== "Decorator")
      return dt(qe(!1, r.decorators, -1), t), !0;
    if (r.body && i === r.body)
      return Xs(r.body, t), !0;
    if (i) {
      if (r.superClass && i === r.superClass && e && (e === r.id || e === r.typeParameters))
        return dt(e, t), !0;
      for (let n of ["implements", "extends", "mixins"])
        if (r[n] && i === r[n][0])
          return e && (e === r.id || e === r.typeParameters || e === r.superClass) ? dt(e, t) : Ar(r, t, n), !0;
    }
  }
  return !1;
}
var $9 = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
function Zv({ comment: t, precedingNode: e, enclosingNode: r, text: i }) {
  return r && e && en(i, We(t)) === "(" && (r.type === "Property" || r.type === "TSDeclareMethod" || r.type === "TSAbstractMethodDefinition") && e.type === "Identifier" && r.key === e && en(i, We(e)) !== ":" || (e == null ? void 0 : e.type) === "Decorator" && $9.has(r == null ? void 0 : r.type) ? (dt(e, t), !0) : !1;
}
var B9 = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
function I9({ comment: t, precedingNode: e, enclosingNode: r, text: i }) {
  return en(i, We(t)) !== "(" ? !1 : e && B9.has(r == null ? void 0 : r.type) ? (dt(e, t), !0) : !1;
}
function N9({ comment: t, enclosingNode: e, text: r }) {
  if ((e == null ? void 0 : e.type) !== "ArrowFunctionExpression")
    return !1;
  let i = Wl(r, We(t));
  return i !== !1 && r.slice(i, i + 2) === "=>" ? (Ar(e, t), !0) : !1;
}
function _9({ comment: t, enclosingNode: e, text: r }) {
  return en(r, We(t)) !== ")" ? !1 : e && (Yv(e) && Vt(e).length === 0 || Ia(e) && Wr(e).length === 0) ? (Ar(e, t), !0) : ((e == null ? void 0 : e.type) === "MethodDefinition" || (e == null ? void 0 : e.type) === "TSAbstractMethodDefinition") && Vt(e.value).length === 0 ? (Ar(e.value, t), !0) : !1;
}
function Wv({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i, text: n }) {
  return (e == null ? void 0 : e.type) === "FunctionTypeParam" && (r == null ? void 0 : r.type) === "FunctionTypeAnnotation" && (i == null ? void 0 : i.type) !== "FunctionTypeParam" || ((e == null ? void 0 : e.type) === "Identifier" || (e == null ? void 0 : e.type) === "AssignmentPattern" || (e == null ? void 0 : e.type) === "ObjectPattern" || (e == null ? void 0 : e.type) === "ArrayPattern" || (e == null ? void 0 : e.type) === "RestElement" || (e == null ? void 0 : e.type) === "TSParameterProperty") && Yv(r) && en(n, We(t)) === ")" ? (dt(e, t), !0) : !Vr(t) && ((r == null ? void 0 : r.type) === "FunctionDeclaration" || (r == null ? void 0 : r.type) === "FunctionExpression" || (r == null ? void 0 : r.type) === "ObjectMethod") && (i == null ? void 0 : i.type) === "BlockStatement" && r.body === i && Wl(n, We(t)) === ot(i) ? (Xs(i, t), !0) : !1;
}
function qv({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "LabeledStatement" ? (Qt(e, t), !0) : !1;
}
function Zg({ comment: t, enclosingNode: e }) {
  return ((e == null ? void 0 : e.type) === "ContinueStatement" || (e == null ? void 0 : e.type) === "BreakStatement") && !e.label ? (dt(e, t), !0) : !1;
}
function Q9({ comment: t, precedingNode: e, enclosingNode: r }) {
  return Re(r) && e && r.callee === e && r.arguments.length > 0 ? (Qt(r.arguments[0], t), !0) : !1;
}
function M9({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i }) {
  return ws(r) ? (Bc(t) && (i.prettierIgnore = !0, t.unignore = !0), e ? (dt(e, t), !0) : !1) : (ws(i) && Bc(t) && (i.types[0].prettierIgnore = !0, t.unignore = !0), !1);
}
function L9({ comment: t, enclosingNode: e }) {
  return dn(e) ? (Qt(e, t), !0) : !1;
}
function Wg({ comment: t, enclosingNode: e, followingNode: r, ast: i, isLastComment: n }) {
  var s;
  return ((s = i == null ? void 0 : i.body) == null ? void 0 : s.length) === 0 ? (n ? Ar(i, t) : Qt(i, t), !0) : (e == null ? void 0 : e.type) === "Program" && e.body.length === 0 && !Ze(e.directives) ? (n ? Ar(e, t) : Qt(e, t), !0) : (r == null ? void 0 : r.type) === "Program" && r.body.length === 0 && (e == null ? void 0 : e.type) === "ModuleExpression" ? (Ar(r, t), !0) : !1;
}
function R9({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "ForInStatement" || (e == null ? void 0 : e.type) === "ForOfStatement" ? (Qt(e, t), !0) : !1;
}
function Xv({ comment: t, precedingNode: e, enclosingNode: r, text: i }) {
  if ((r == null ? void 0 : r.type) === "ImportSpecifier" || (r == null ? void 0 : r.type) === "ExportSpecifier")
    return Qt(r, t), !0;
  let n = (e == null ? void 0 : e.type) === "ImportSpecifier" && (r == null ? void 0 : r.type) === "ImportDeclaration", s = (e == null ? void 0 : e.type) === "ExportSpecifier" && (r == null ? void 0 : r.type) === "ExportNamedDeclaration";
  return (n || s) && Cr(i, We(t)) ? (dt(e, t), !0) : !1;
}
function j9({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "AssignmentPattern" ? (Qt(e, t), !0) : !1;
}
var Z9 = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), W9 = /* @__PURE__ */ new Set(["ObjectExpression", "RecordExpression", "ArrayExpression", "TupleExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
function q9({ comment: t, enclosingNode: e, followingNode: r }) {
  return Z9.has(e == null ? void 0 : e.type) && r && (W9.has(r.type) || Vr(t)) ? (Qt(r, t), !0) : !1;
}
function X9({ comment: t, enclosingNode: e, followingNode: r, text: i }) {
  return !r && ((e == null ? void 0 : e.type) === "TSMethodSignature" || (e == null ? void 0 : e.type) === "TSDeclareFunction" || (e == null ? void 0 : e.type) === "TSAbstractMethodDefinition") && en(i, We(t)) === ";" ? (dt(e, t), !0) : !1;
}
function Vv({ comment: t, enclosingNode: e, followingNode: r }) {
  if (Bc(t) && (e == null ? void 0 : e.type) === "TSMappedType" && (r == null ? void 0 : r.type) === "TSTypeParameter" && r.constraint)
    return e.prettierIgnore = !0, t.unignore = !0, !0;
}
function V9({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i }) {
  return (r == null ? void 0 : r.type) !== "TSMappedType" ? !1 : (i == null ? void 0 : i.type) === "TSTypeParameter" && i.name ? (Qt(i.name, t), !0) : (e == null ? void 0 : e.type) === "TSTypeParameter" && e.constraint ? (dt(e.constraint, t), !0) : !1;
}
function Y9({ comment: t, enclosingNode: e, followingNode: r }) {
  return !e || e.type !== "SwitchCase" || e.test || !r || r !== e.consequent[0] ? !1 : (r.type === "BlockStatement" && Yh(t) ? Xs(r, t) : Ar(e, t), !0);
}
function U9({ comment: t, precedingNode: e, enclosingNode: r, followingNode: i }) {
  return ws(e) && ((r.type === "TSArrayType" || r.type === "ArrayTypeAnnotation") && !i || Tv(r)) ? (dt(qe(!1, e.types, -1), t), !0) : !1;
}
function z9({ comment: t, enclosingNode: e, precedingNode: r, followingNode: i }) {
  if (((e == null ? void 0 : e.type) === "ObjectPattern" || (e == null ? void 0 : e.type) === "ArrayPattern") && (i == null ? void 0 : i.type) === "TSTypeAnnotation")
    return r ? dt(r, t) : Ar(e, t), !0;
}
var Yv = Ue(["ArrowFunctionExpression", "FunctionExpression", "FunctionDeclaration", "ObjectMethod", "ClassMethod", "TSDeclareFunction", "TSCallSignatureDeclaration", "TSConstructSignatureDeclaration", "TSMethodSignature", "TSConstructorType", "TSFunctionType", "TSDeclareMethod"]), G9 = /* @__PURE__ */ new Set(["EmptyStatement", "TemplateElement", "Import", "TSEmptyBodyFunctionExpression", "ChainExpression"]);
function H9(t) {
  return !G9.has(t.type);
}
function J9(t, e) {
  var r;
  if ((e.parser === "typescript" || e.parser === "flow" || e.parser === "acorn" || e.parser === "espree" || e.parser === "meriyah" || e.parser === "__babel_estree") && t.type === "MethodDefinition" && ((r = t.value) == null ? void 0 : r.type) === "FunctionExpression" && Vt(t.value).length === 0 && !t.value.returnType && !Ze(t.value.typeParameters) && t.value.body)
    return [...t.decorators || [], t.key, t.value.body];
}
function Uv(t) {
  let { node: e, parent: r } = t;
  return (vt(e) || r && (r.type === "JSXSpreadAttribute" || r.type === "JSXSpreadChild" || ws(r) || (r.type === "ClassDeclaration" || r.type === "ClassExpression") && r.superClass === e)) && (!Hh(e) || ws(r));
}
function K9(t, { parser: e }) {
  if (e === "flow" || e === "babel-flow")
    return t = Dr(!1, t, /[\s(]/g, ""), t === "" || t === "/*" || t === "/*::";
}
function e4(t) {
  switch (t) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
var nr = Symbol("MODE_BREAK"), bi = Symbol("MODE_FLAT"), Yo = Symbol("cursor");
function zv() {
  return { value: "", length: 0, queue: [] };
}
function t4(t, e) {
  return uf(t, { type: "indent" }, e);
}
function r4(t, e, r) {
  return e === Number.NEGATIVE_INFINITY ? t.root || zv() : e < 0 ? uf(t, { type: "dedent" }, r) : e ? e.type === "root" ? { ...t, root: t } : uf(t, { type: typeof e == "string" ? "stringAlign" : "numberAlign", n: e }, r) : t;
}
function uf(t, e, r) {
  let i = e.type === "dedent" ? t.queue.slice(0, -1) : [...t.queue, e], n = "", s = 0, a = 0, o = 0;
  for (let O of i)
    switch (O.type) {
      case "indent":
        h(), r.useTabs ? u(1) : c(r.tabWidth);
        break;
      case "stringAlign":
        h(), n += O.n, s += O.n.length;
        break;
      case "numberAlign":
        a += 1, o += O.n;
        break;
      default:
        throw new Error(`Unexpected type '${O.type}'`);
    }
  return m(), { ...t, value: n, length: s, queue: i };
  function u(O) {
    n += "	".repeat(O), s += r.tabWidth * O;
  }
  function c(O) {
    n += " ".repeat(O), s += O;
  }
  function h() {
    r.useTabs ? d() : m();
  }
  function d() {
    a > 0 && u(a), y();
  }
  function m() {
    o > 0 && c(o), y();
  }
  function y() {
    a = 0, o = 0;
  }
}
function cf(t) {
  let e = 0, r = 0, i = t.length;
  e:
    for (; i--; ) {
      let n = t[i];
      if (n === Yo) {
        r++;
        continue;
      }
      for (let s = n.length - 1; s >= 0; s--) {
        let a = n[s];
        if (a === " " || a === "	")
          e++;
        else {
          t[i] = n.slice(0, s + 1);
          break e;
        }
      }
    }
  if (e > 0 || r > 0)
    for (t.length = i + 1; r-- > 0; )
      t.push(Yo);
  return e;
}
function ku(t, e, r, i, n, s) {
  if (r === Number.POSITIVE_INFINITY)
    return !0;
  let a = e.length, o = [t], u = [];
  for (; r >= 0; ) {
    if (o.length === 0) {
      if (a === 0)
        return !0;
      o.push(e[--a]);
      continue;
    }
    let { mode: c, doc: h } = o.pop();
    switch (Ja(h)) {
      case za:
        u.push(h), r -= Fa(h);
        break;
      case Cs:
      case Ni: {
        let d = _v(h);
        for (let m = d.length - 1; m >= 0; m--)
          o.push({ mode: c, doc: d[m] });
        break;
      }
      case Rs:
      case js:
      case Zs:
      case es:
        o.push({ mode: c, doc: h.contents });
        break;
      case Ha:
        r += cf(u);
        break;
      case qr: {
        if (s && h.break)
          return !1;
        let d = h.break ? nr : c, m = h.expandedStates && d === nr ? qe(!1, h.expandedStates, -1) : h.contents;
        o.push({ mode: d, doc: m });
        break;
      }
      case Ti: {
        let d = (h.groupId ? n[h.groupId] || bi : c) === nr ? h.breakContents : h.flatContents;
        d && o.push({ mode: c, doc: d });
        break;
      }
      case Tr:
        if (c === nr || h.hard)
          return !0;
        h.soft || (u.push(" "), r--);
        break;
      case Ws:
        i = !0;
        break;
      case qs:
        if (i)
          return !1;
        break;
    }
  }
  return !1;
}
function hf(t, e) {
  let r = {}, i = e.printWidth, n = e4(e.endOfLine), s = 0, a = [{ ind: zv(), mode: nr, doc: t }], o = [], u = !1, c = [], h = 0;
  for (u9(t); a.length > 0; ) {
    let { ind: m, mode: y, doc: O } = a.pop();
    switch (Ja(O)) {
      case za: {
        let b = n !== `
` ? Dr(!1, O, `
`, n) : O;
        o.push(b), a.length > 0 && (s += Fa(b));
        break;
      }
      case Cs:
        for (let b = O.length - 1; b >= 0; b--)
          a.push({ ind: m, mode: y, doc: O[b] });
        break;
      case Ga:
        if (h >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        o.push(Yo), h++;
        break;
      case Rs:
        a.push({ ind: t4(m, e), mode: y, doc: O.contents });
        break;
      case js:
        a.push({ ind: r4(m, O.n, e), mode: y, doc: O.contents });
        break;
      case Ha:
        s -= cf(o);
        break;
      case qr:
        switch (y) {
          case bi:
            if (!u) {
              a.push({ ind: m, mode: O.break ? nr : bi, doc: O.contents });
              break;
            }
          case nr: {
            u = !1;
            let b = { ind: m, mode: bi, doc: O.contents }, v = i - s, S = c.length > 0;
            if (!O.break && ku(b, a, v, S, r))
              a.push(b);
            else if (O.expandedStates) {
              let x = qe(!1, O.expandedStates, -1);
              if (O.break) {
                a.push({ ind: m, mode: nr, doc: x });
                break;
              } else
                for (let w = 1; w < O.expandedStates.length + 1; w++)
                  if (w >= O.expandedStates.length) {
                    a.push({ ind: m, mode: nr, doc: x });
                    break;
                  } else {
                    let k = O.expandedStates[w], C = { ind: m, mode: bi, doc: k };
                    if (ku(C, a, v, S, r)) {
                      a.push(C);
                      break;
                    }
                  }
            } else
              a.push({ ind: m, mode: nr, doc: O.contents });
            break;
          }
        }
        O.id && (r[O.id] = qe(!1, a, -1).mode);
        break;
      case Ni: {
        let b = i - s, { parts: v } = O;
        if (v.length === 0)
          break;
        let [S, x] = v, w = { ind: m, mode: bi, doc: S }, k = { ind: m, mode: nr, doc: S }, C = ku(w, [], b, c.length > 0, r, !0);
        if (v.length === 1) {
          C ? a.push(w) : a.push(k);
          break;
        }
        let E = { ind: m, mode: bi, doc: x }, P = { ind: m, mode: nr, doc: x };
        if (v.length === 2) {
          C ? a.push(E, w) : a.push(P, k);
          break;
        }
        v.splice(0, 2);
        let I = { ind: m, mode: y, doc: Qg(v) }, B = v[0];
        ku({ ind: m, mode: bi, doc: [S, x, B] }, [], b, c.length > 0, r, !0) ? a.push(I, E, w) : C ? a.push(I, P, w) : a.push(I, P, k);
        break;
      }
      case Ti:
      case Zs: {
        let b = O.groupId ? r[O.groupId] : y;
        if (b === nr) {
          let v = O.type === Ti ? O.breakContents : O.negate ? O.contents : te(O.contents);
          v && a.push({ ind: m, mode: y, doc: v });
        }
        if (b === bi) {
          let v = O.type === Ti ? O.flatContents : O.negate ? te(O.contents) : O.contents;
          v && a.push({ ind: m, mode: y, doc: v });
        }
        break;
      }
      case Ws:
        c.push({ ind: m, mode: y, doc: O.contents });
        break;
      case qs:
        c.length > 0 && a.push({ ind: m, mode: y, doc: Iv });
        break;
      case Tr:
        switch (y) {
          case bi:
            if (O.hard)
              u = !0;
            else {
              O.soft || (o.push(" "), s += 1);
              break;
            }
          case nr:
            if (c.length > 0) {
              a.push({ ind: m, mode: y, doc: O }, ...c.reverse()), c.length = 0;
              break;
            }
            O.literal ? m.root ? (o.push(n, m.root.value), s = m.root.length) : (o.push(n), s = 0) : (s -= cf(o), o.push(n + m.value), s = m.length);
            break;
        }
        break;
      case es:
        a.push({ ind: m, mode: y, doc: O.contents });
        break;
      case ts:
        break;
      default:
        throw new ul(O);
    }
    a.length === 0 && c.length > 0 && (a.push(...c.reverse()), c.length = 0);
  }
  let d = o.indexOf(Yo);
  if (d !== -1) {
    let m = o.indexOf(Yo, d + 1), y = o.slice(0, d).join(""), O = o.slice(d + 1, m).join(""), b = o.slice(m + 1).join("");
    return { formatted: y + O + b, cursorNodeStart: y.length, cursorNodeText: O };
  }
  return { formatted: o.join("") };
}
function i4(t, e, r = 0) {
  let i = 0;
  for (let n = r; n < t.length; ++n)
    t[n] === "	" ? i = i + e - i % e : i++;
  return i;
}
var n4 = i4;
function s4(t, e) {
  let r = t.lastIndexOf(`
`);
  return r === -1 ? 0 : n4(t.slice(r + 1).match(/^[\t ]*/)[0], e);
}
var a4 = s4;
function Gv(t, e, r) {
  let { node: i } = t;
  if (i.type === "TemplateLiteral" && c4(t)) {
    let c = l4(t, r, e);
    if (c)
      return c;
  }
  let n = "expressions";
  i.type === "TSTemplateLiteralType" && (n = "types");
  let s = [], a = t.map(e, n), o = jQ(i);
  o && (a = a.map((c) => hf(c, { ...r, printWidth: Number.POSITIVE_INFINITY }).formatted)), s.push(Ki, "`");
  let u = 0;
  return t.each(({ index: c, node: h }) => {
    if (s.push(e()), h.tail)
      return;
    let { tabWidth: d } = r, m = h.value.raw, y = m.includes(`
`) ? a4(m, d) : u;
    u = y;
    let O = a[c];
    if (!o) {
      let v = i[n][c], S = Wn(r.originalText, We(h), ot(i.quasis[c + 1]));
      if (!S) {
        let x = hf(O, { ...r, printWidth: Number.POSITIVE_INFINITY }).formatted;
        x.includes(`
`) ? S = !0 : O = x;
      }
      S && (se(v) || at(v) || v.type === "ConditionalExpression" || v.type === "SequenceExpression" || Ci(v) || Ji(v)) && (O = [te([H, O]), H]);
    }
    let b = y === 0 && m.endsWith(`
`) ? _i(Number.NEGATIVE_INFINITY, O) : o9(O, y, d);
    s.push(Z(["${", b, Ki, "}"]));
  }, "quasis"), s.push("`"), s;
}
function o4(t) {
  let e = t("quasi");
  return Zl(e.label && { tagged: !0, ...e.label }, [t("tag"), t("typeParameters"), Ki, e]);
}
function l4(t, e, r) {
  let { node: i } = t, n = i.quasis[0].value.raw.trim().split(/\s*\|\s*/);
  if (n.length > 1 || n.some((s) => s.length > 0)) {
    e.__inJestEach = !0;
    let s = t.map(r, "expressions");
    e.__inJestEach = !1;
    let a = [], o = s.map((m) => "${" + hf(m, { ...e, printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" }).formatted + "}"), u = [{ hasLineBreak: !1, cells: [] }];
    for (let m = 1; m < i.quasis.length; m++) {
      let y = qe(!1, u, -1), O = o[m - 1];
      y.cells.push(O), O.includes(`
`) && (y.hasLineBreak = !0), i.quasis[m].value.raw.includes(`
`) && u.push({ hasLineBreak: !1, cells: [] });
    }
    let c = Math.max(n.length, ...u.map((m) => m.cells.length)), h = Array.from({ length: c }).fill(0), d = [{ cells: n }, ...u.filter((m) => m.cells.length > 0)];
    for (let { cells: m } of d.filter((y) => !y.hasLineBreak))
      for (let [y, O] of m.entries())
        h[y] = Math.max(h[y], Fa(O));
    return a.push(Ki, "`", te([ee, Ne(ee, d.map((m) => Ne(" | ", m.cells.map((y, O) => m.hasLineBreak ? y : y + " ".repeat(h[O] - Fa(y))))))]), ee, "`"), a;
  }
}
function u4(t, e) {
  let { node: r } = t, i = e();
  return se(r) && (i = Z([te([H, i]), H])), ["${", i, Ki, "}"];
}
function qg(t, e) {
  return t.map((r) => u4(r, e), "expressions");
}
function Hv(t, e) {
  return Ka(t, (r) => typeof r == "string" ? e ? Dr(!1, r, /(\\*)`/g, "$1$1\\`") : Jv(r) : r);
}
function Jv(t) {
  return Dr(!1, t, /([\\`]|\${)/g, "\\$1");
}
function c4({ node: t, parent: e }) {
  let r = /^[fx]?(?:describe|it|test)$/;
  return e.type === "TaggedTemplateExpression" && e.quasi === t && e.tag.type === "MemberExpression" && e.tag.property.type === "Identifier" && e.tag.property.name === "each" && (e.tag.object.type === "Identifier" && r.test(e.tag.object.name) || e.tag.object.type === "MemberExpression" && e.tag.object.property.type === "Identifier" && (e.tag.object.property.name === "only" || e.tag.object.property.name === "skip") && e.tag.object.object.type === "Identifier" && r.test(e.tag.object.object.name));
}
var pf = [(t, e) => t.type === "ObjectExpression" && e === "properties", (t, e) => t.type === "CallExpression" && t.callee.type === "Identifier" && t.callee.name === "Component" && e === "arguments", (t, e) => t.type === "Decorator" && e === "expression"];
function h4(t) {
  let e = (i) => i.type === "TemplateLiteral", r = (i, n) => dn(i) && !i.computed && i.key.type === "Identifier" && i.key.name === "styles" && n === "value";
  return t.match(e, (i, n) => _t(i) && n === "elements", r, ...pf) || t.match(e, r, ...pf);
}
function p4(t) {
  return t.match((e) => e.type === "TemplateLiteral", (e, r) => dn(e) && !e.computed && e.key.type === "Identifier" && e.key.name === "template" && r === "value", ...pf);
}
function EO(t, e) {
  return se(t, de.Block | de.Leading, ({ value: r }) => r === ` ${e} `);
}
function Kv({ node: t, parent: e }, r) {
  return EO(t, r) || d4(e) && EO(e, r);
}
function d4(t) {
  return t.type === "AsConstExpression" || t.type === "TSAsExpression" && t.typeAnnotation.type === "TSTypeReference" && t.typeAnnotation.typeName.type === "Identifier" && t.typeAnnotation.typeName.name === "const";
}
async function f4(t, e, r) {
  let { node: i } = r, n = i.quasis.map((h) => h.value.raw), s = 0, a = n.reduce((h, d, m) => m === 0 ? d : h + "@prettier-placeholder-" + s++ + "-id" + d, ""), o = await t(a, { parser: "scss" }), u = qg(r, e), c = m4(o, u);
  if (!c)
    throw new Error("Couldn't insert all the expressions");
  return ["`", te([ee, c]), H, "`"];
}
function m4(t, e) {
  if (!Ze(e))
    return t;
  let r = 0, i = Ka(Mg(t), (n) => typeof n != "string" || !n.includes("@prettier-placeholder") ? n : n.split(/@prettier-placeholder-(\d+)-id/).map((s, a) => a % 2 === 0 ? As(s) : (r++, e[s])));
  return e.length === r ? i : null;
}
function g4({ node: t, parent: e, grandparent: r }) {
  return r && t.quasis && e.type === "JSXExpressionContainer" && r.type === "JSXElement" && r.openingElement.name.name === "style" && r.openingElement.attributes.some((i) => i.type === "JSXAttribute" && i.name.name === "jsx") || (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && e.tag.type === "Identifier" && e.tag.name === "css" || (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && e.tag.type === "MemberExpression" && e.tag.object.name === "css" && (e.tag.property.name === "global" || e.tag.property.name === "resolve");
}
function Tu(t) {
  return t.type === "Identifier" && t.name === "styled";
}
function kO(t) {
  return /^[A-Z]/.test(t.object.name) && t.property.name === "extend";
}
function y4({ parent: t }) {
  if (!t || t.type !== "TaggedTemplateExpression")
    return !1;
  let e = t.tag.type === "ParenthesizedExpression" ? t.tag.expression : t.tag;
  switch (e.type) {
    case "MemberExpression":
      return Tu(e.object) || kO(e);
    case "CallExpression":
      return Tu(e.callee) || e.callee.type === "MemberExpression" && (e.callee.object.type === "MemberExpression" && (Tu(e.callee.object.object) || kO(e.callee.object)) || e.callee.object.type === "CallExpression" && Tu(e.callee.object.callee));
    case "Identifier":
      return e.name === "css";
    default:
      return !1;
  }
}
function O4({ parent: t, grandparent: e }) {
  return (e == null ? void 0 : e.type) === "JSXAttribute" && t.type === "JSXExpressionContainer" && e.name.type === "JSXIdentifier" && e.name.name === "css";
}
function x4(t) {
  if (g4(t) || y4(t) || O4(t) || h4(t))
    return f4;
}
var b4 = x4;
async function D4(t, e, r) {
  let { node: i } = r, n = i.quasis.length, s = qg(r, e), a = [];
  for (let o = 0; o < n; o++) {
    let u = i.quasis[o], c = o === 0, h = o === n - 1, d = u.value.cooked, m = d.split(`
`), y = m.length, O = s[o], b = y > 2 && m[0].trim() === "" && m[1].trim() === "", v = y > 2 && m[y - 1].trim() === "" && m[y - 2].trim() === "", S = m.every((w) => /^\s*(?:#[^\n\r]*)?$/.test(w));
    if (!h && /#[^\n\r]*$/.test(m[y - 1]))
      return null;
    let x = null;
    S ? x = v4(m) : x = await t(d, { parser: "graphql" }), x ? (x = Hv(x, !1), !c && b && a.push(""), a.push(x), !h && v && a.push("")) : !c && !h && b && a.push(""), O && a.push(O);
  }
  return ["`", te([ee, Ne(ee, a)]), ee, "`"];
}
function v4(t) {
  let e = [], r = !1, i = t.map((n) => n.trim());
  for (let [n, s] of i.entries())
    s !== "" && (i[n - 1] === "" && r ? e.push([ee, s]) : e.push(s), r = !0);
  return e.length === 0 ? null : Ne(ee, e);
}
function S4({ node: t, parent: e }) {
  return Kv({ node: t, parent: e }, "GraphQL") || e && (e.type === "TaggedTemplateExpression" && (e.tag.type === "MemberExpression" && e.tag.object.name === "graphql" && e.tag.property.name === "experimental" || e.tag.type === "Identifier" && (e.tag.name === "gql" || e.tag.name === "graphql")) || e.type === "CallExpression" && e.callee.type === "Identifier" && e.callee.name === "graphql");
}
function w4(t) {
  if (S4(t))
    return D4;
}
var C4 = w4, Up = 0;
async function eS(t, e, r, i, n) {
  let { node: s } = i, a = Up;
  Up = Up + 1 >>> 0;
  let o = (S) => `PRETTIER_HTML_PLACEHOLDER_${S}_${a}_IN_JS`, u = s.quasis.map((S, x, w) => x === w.length - 1 ? S.value.cooked : S.value.cooked + o(x)).join(""), c = qg(i, r), h = new RegExp(o("(\\d+)"), "g"), d = 0, m = await e(u, { parser: t, __onHtmlRoot(S) {
    d = S.children.length;
  } }), y = Ka(m, (S) => {
    if (typeof S != "string")
      return S;
    let x = [], w = S.split(h);
    for (let k = 0; k < w.length; k++) {
      let C = w[k];
      if (k % 2 === 0) {
        C && (C = Jv(C), n.__embeddedInHtml && (C = Dr(!1, C, /<\/(?=script\b)/gi, "<\\/")), x.push(C));
        continue;
      }
      let E = Number(C);
      x.push(c[E]);
    }
    return x;
  }), O = /^\s/.test(u) ? " " : "", b = /\s$/.test(u) ? " " : "", v = n.htmlWhitespaceSensitivity === "ignore" ? ee : O && b ? he : null;
  return v ? Z(["`", te([v, Z(y)]), v, "`"]) : Zl({ hug: !1 }, Z(["`", O, d > 1 ? te(Z(y)) : Z(y), b, "`"]));
}
function A4(t) {
  return Kv(t, "HTML") || t.match((e) => e.type === "TemplateLiteral", (e, r) => e.type === "TaggedTemplateExpression" && e.tag.type === "Identifier" && e.tag.name === "html" && r === "quasi");
}
var E4 = eS.bind(void 0, "html"), k4 = eS.bind(void 0, "angular");
function T4(t) {
  if (A4(t))
    return E4;
  if (p4(t))
    return k4;
}
var P4 = T4;
async function F4(t, e, r) {
  let { node: i } = r, n = Dr(!1, i.quasis[0].value.raw, /((?:\\\\)*)\\`/g, (u, c) => "\\".repeat(c.length / 2) + "`"), s = $4(n), a = s !== "";
  a && (n = Dr(!1, n, new RegExp(`^${s}`, "gm"), ""));
  let o = Hv(await t(n, { parser: "markdown", __inJsTemplate: !0 }), !0);
  return ["`", a ? te([H, o]) : [Nv, s9(o)], H, "`"];
}
function $4(t) {
  let e = t.match(/^([^\S\n]*)\S/m);
  return e === null ? "" : e[1];
}
function B4(t) {
  if (I4(t))
    return F4;
}
function I4({ node: t, parent: e }) {
  return (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && t.quasis.length === 1 && e.tag.type === "Identifier" && (e.tag.name === "md" || e.tag.name === "markdown");
}
var N4 = B4;
function _4(t) {
  let { node: e } = t;
  if (e.type !== "TemplateLiteral" || Q4(e))
    return;
  let r;
  for (let i of [b4, C4, P4, N4])
    if (r = i(t), !!r)
      return e.quasis.length === 1 && e.quasis[0].value.raw.trim() === "" ? "``" : async (...n) => {
        let s = await r(...n);
        return s && Zl({ embed: !0, ...s.label }, s);
      };
}
function Q4({ quasis: t }) {
  return t.some(({ value: { cooked: e } }) => e === null);
}
var M4 = _4, Ic = R7(W7(), 1);
function L4(t) {
  if (!t.startsWith("#!"))
    return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var R4 = L4;
function j4(t) {
  let e = R4(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, Ic.extract)(t), { pragmas: i, comments: n } = (0, Ic.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: i, comments: n };
}
function Z4(t) {
  let { shebang: e, text: r, pragmas: i, comments: n } = j4(t), s = (0, Ic.strip)(r), a = (0, Ic.print)({ pragmas: { format: "", ...i }, comments: n.trimStart() });
  return (e ? `${e}
` : "") + a + (s.startsWith(`
`) ? `
` : `

`) + s;
}
function W4(t, e) {
  let { originalText: r, [Symbol.for("comments")]: i, locStart: n, locEnd: s, [Symbol.for("printedComments")]: a } = e, { node: o } = t, u = n(o), c = s(o);
  for (let h of i)
    n(h) >= u && s(h) <= c && a.add(h);
  return r.slice(u, c);
}
var q4 = W4;
function df(t, e) {
  var r, i, n, s, a, o, u;
  if (t.isRoot)
    return !1;
  let { node: c, key: h, parent: d } = t;
  if (e.__isInHtmlInterpolation && !e.bracketSpacing && U4(c) && $o(t))
    return !0;
  if (X4(c))
    return !1;
  if (c.type === "Identifier") {
    if ((r = c.extra) != null && r.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(c.name) || h === "left" && (c.name === "async" && !d.await || c.name === "let") && d.type === "ForOfStatement")
      return !0;
    if (c.name === "let") {
      let m = (i = t.findAncestor((y) => y.type === "ForOfStatement")) == null ? void 0 : i.left;
      if (m && zt(m, (y) => y === c))
        return !0;
    }
    if (h === "object" && c.name === "let" && d.type === "MemberExpression" && d.computed && !d.optional) {
      let m = t.findAncestor((O) => O.type === "ExpressionStatement" || O.type === "ForStatement" || O.type === "ForInStatement"), y = m ? m.type === "ExpressionStatement" ? m.expression : m.type === "ForStatement" ? m.init : m.left : void 0;
      if (y && zt(y, (O) => O === c))
        return !0;
    }
    if (h === "expression")
      switch (c.name) {
        case "await":
        case "interface":
        case "module":
        case "using":
        case "yield":
        case "let":
        case "type": {
          let m = t.findAncestor((y) => !Ci(y));
          if (m !== d && m.type === "ExpressionStatement")
            return !0;
        }
      }
    return !1;
  }
  if (c.type === "ObjectExpression" || c.type === "FunctionExpression" || c.type === "ClassExpression" || c.type === "DoExpression") {
    let m = (n = t.findAncestor((y) => y.type === "ExpressionStatement")) == null ? void 0 : n.expression;
    if (m && zt(m, (y) => y === c))
      return !0;
  }
  if (c.type === "ObjectExpression") {
    let m = (s = t.findAncestor((y) => y.type === "ArrowFunctionExpression")) == null ? void 0 : s.body;
    if (m && m.type !== "SequenceExpression" && m.type !== "AssignmentExpression" && zt(m, (y) => y === c))
      return !0;
  }
  switch (d.type) {
    case "ParenthesizedExpression":
      return !1;
    case "ClassDeclaration":
    case "ClassExpression":
      if (h === "superClass" && (c.type === "ArrowFunctionExpression" || c.type === "AssignmentExpression" || c.type === "AwaitExpression" || c.type === "BinaryExpression" || c.type === "ConditionalExpression" || c.type === "LogicalExpression" || c.type === "NewExpression" || c.type === "ObjectExpression" || c.type === "SequenceExpression" || c.type === "TaggedTemplateExpression" || c.type === "UnaryExpression" || c.type === "UpdateExpression" || c.type === "YieldExpression" || c.type === "TSNonNullExpression" || c.type === "ClassExpression" && Ze(c.decorators)))
        return !0;
      break;
    case "ExportDefaultDeclaration":
      return tS(t, e) || c.type === "SequenceExpression";
    case "Decorator":
      if (h === "expression") {
        if (at(c) && c.computed)
          return !0;
        let m = !1, y = !1, O = c;
        for (; O; )
          switch (O.type) {
            case "MemberExpression":
              y = !0, O = O.object;
              break;
            case "CallExpression":
              if (y || m)
                return e.parser !== "typescript";
              m = !0, O = O.callee;
              break;
            case "Identifier":
              return !1;
            case "TaggedTemplateExpression":
              return e.parser !== "typescript";
            default:
              return !0;
          }
        return !0;
      }
      break;
    case "TypeAnnotation":
      if (t.match(void 0, void 0, (m, y) => y === "returnType" && m.type === "ArrowFunctionExpression") && Y4(c))
        return !0;
      break;
    case "BinaryExpression":
      if (h === "left" && (d.operator === "in" || d.operator === "instanceof") && c.type === "UnaryExpression")
        return !0;
      break;
  }
  switch (c.type) {
    case "UpdateExpression":
      if (d.type === "UnaryExpression")
        return c.prefix && (c.operator === "++" && d.operator === "+" || c.operator === "--" && d.operator === "-");
    case "UnaryExpression":
      switch (d.type) {
        case "UnaryExpression":
          return c.operator === d.operator && (c.operator === "+" || c.operator === "-");
        case "BindExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return h === "object";
        case "TaggedTemplateExpression":
          return !0;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return h === "callee";
        case "BinaryExpression":
          return h === "left" && d.operator === "**";
        case "TSNonNullExpression":
          return !0;
        default:
          return !1;
      }
    case "BinaryExpression":
      if (d.type === "UpdateExpression" || c.operator === "in" && V4(t))
        return !0;
      if (c.operator === "|>" && (a = c.extra) != null && a.parenthesized) {
        let m = t.grandparent;
        if (m.type === "BinaryExpression" && m.operator === "|>")
          return !0;
      }
    case "TSTypeAssertion":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
    case "LogicalExpression":
      switch (d.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
          return !Ci(c);
        case "ConditionalExpression":
          return Ci(c);
        case "CallExpression":
        case "NewExpression":
        case "OptionalCallExpression":
          return h === "callee";
        case "ClassExpression":
        case "ClassDeclaration":
          return h === "superClass";
        case "TSTypeAssertion":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "JSXSpreadAttribute":
        case "SpreadElement":
        case "BindExpression":
        case "AwaitExpression":
        case "TSNonNullExpression":
        case "UpdateExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return h === "object";
        case "AssignmentExpression":
        case "AssignmentPattern":
          return h === "left" && (c.type === "TSTypeAssertion" || Ci(c));
        case "LogicalExpression":
          if (c.type === "LogicalExpression")
            return d.operator !== c.operator;
        case "BinaryExpression": {
          let { operator: m, type: y } = c;
          if (!m && y !== "TSTypeAssertion")
            return !0;
          let O = $c(m), b = d.operator, v = $c(b);
          return v > O || h === "right" && v === O || v === O && !Ng(b, m) ? !0 : v < O && m === "%" ? b === "+" || b === "-" : !!YQ(b);
        }
        default:
          return !1;
      }
    case "SequenceExpression":
      switch (d.type) {
        case "ReturnStatement":
          return !1;
        case "ForStatement":
          return !1;
        case "ExpressionStatement":
          return h !== "expression";
        case "ArrowFunctionExpression":
          return h !== "body";
        default:
          return !0;
      }
    case "YieldExpression":
      if (d.type === "AwaitExpression")
        return !0;
    case "AwaitExpression":
      switch (d.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "SpreadElement":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "BindExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return h === "object";
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return h === "callee";
        case "ConditionalExpression":
          return h === "test";
        case "BinaryExpression":
          return !(!c.argument && d.operator === "|>");
        default:
          return !1;
      }
    case "TSFunctionType":
      if (t.match((m) => m.type === "TSFunctionType", (m, y) => y === "typeAnnotation" && m.type === "TSTypeAnnotation", (m, y) => y === "returnType" && m.type === "ArrowFunctionExpression"))
        return !0;
    case "TSConditionalType":
    case "TSConstructorType":
      if (h === "extendsType" && d.type === "TSConditionalType") {
        if (c.type === "TSConditionalType")
          return !0;
        let { typeAnnotation: m } = c.returnType || c.typeAnnotation;
        if (m.type === "TSTypePredicate" && m.typeAnnotation && (m = m.typeAnnotation.typeAnnotation), m.type === "TSInferType" && m.typeParameter.constraint)
          return !0;
      }
      if (h === "checkType" && d.type === "TSConditionalType")
        return !0;
    case "TSUnionType":
    case "TSIntersectionType":
      if ((d.type === "TSUnionType" || d.type === "TSIntersectionType") && d.types.length > 1 && (!c.types || c.types.length > 1))
        return !0;
    case "TSInferType":
      if (c.type === "TSInferType" && d.type === "TSRestType")
        return !1;
    case "TSTypeOperator":
      return d.type === "TSArrayType" || d.type === "TSOptionalType" || d.type === "TSRestType" || h === "objectType" && d.type === "TSIndexedAccessType" || d.type === "TSTypeOperator" || d.type === "TSTypeAnnotation" && t.grandparent.type.startsWith("TSJSDoc");
    case "TSTypeQuery":
      return h === "objectType" && d.type === "TSIndexedAccessType" || h === "elementType" && d.type === "TSArrayType";
    case "TypeofTypeAnnotation":
      return h === "objectType" && (d.type === "IndexedAccessType" || d.type === "OptionalIndexedAccessType") || h === "elementType" && d.type === "ArrayTypeAnnotation";
    case "ArrayTypeAnnotation":
      return d.type === "NullableTypeAnnotation";
    case "IntersectionTypeAnnotation":
    case "UnionTypeAnnotation":
      return d.type === "ArrayTypeAnnotation" || d.type === "NullableTypeAnnotation" || d.type === "IntersectionTypeAnnotation" || d.type === "UnionTypeAnnotation" || h === "objectType" && (d.type === "IndexedAccessType" || d.type === "OptionalIndexedAccessType");
    case "InferTypeAnnotation":
    case "NullableTypeAnnotation":
      return d.type === "ArrayTypeAnnotation" || h === "objectType" && (d.type === "IndexedAccessType" || d.type === "OptionalIndexedAccessType");
    case "FunctionTypeAnnotation": {
      if (t.match(void 0, (y, O) => O === "typeAnnotation" && y.type === "TypeAnnotation", (y, O) => O === "returnType" && y.type === "ArrowFunctionExpression") || t.match(void 0, (y, O) => O === "typeAnnotation" && y.type === "TypePredicate", (y, O) => O === "typeAnnotation" && y.type === "TypeAnnotation", (y, O) => O === "returnType" && y.type === "ArrowFunctionExpression"))
        return !0;
      let m = d.type === "NullableTypeAnnotation" ? t.grandparent : d;
      return m.type === "UnionTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "ArrayTypeAnnotation" || h === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType") || h === "checkType" && d.type === "ConditionalTypeAnnotation" || h === "extendsType" && d.type === "ConditionalTypeAnnotation" && c.returnType.type === "InferTypeAnnotation" && c.returnType.typeParameter.bound || m.type === "NullableTypeAnnotation" || d.type === "FunctionTypeParam" && d.name === null && Vt(c).some((y) => {
        var O;
        return ((O = y.typeAnnotation) == null ? void 0 : O.type) === "NullableTypeAnnotation";
      });
    }
    case "ConditionalTypeAnnotation":
      if (h === "extendsType" && d.type === "ConditionalTypeAnnotation" && c.type === "ConditionalTypeAnnotation" || h === "checkType" && d.type === "ConditionalTypeAnnotation")
        return !0;
    case "OptionalIndexedAccessType":
      return h === "objectType" && d.type === "IndexedAccessType";
    case "StringLiteral":
    case "NumericLiteral":
    case "Literal":
      if (typeof c.value == "string" && d.type === "ExpressionStatement" && !d.directive) {
        let m = t.grandparent;
        return m.type === "Program" || m.type === "BlockStatement";
      }
      return h === "object" && d.type === "MemberExpression" && typeof c.value == "number";
    case "AssignmentExpression": {
      let m = t.grandparent;
      return h === "body" && d.type === "ArrowFunctionExpression" ? !0 : h === "key" && (d.type === "ClassProperty" || d.type === "PropertyDefinition") && d.computed || (h === "init" || h === "update") && d.type === "ForStatement" ? !1 : d.type === "ExpressionStatement" ? c.left.type === "ObjectPattern" : !(h === "key" && d.type === "TSPropertySignature" || d.type === "AssignmentExpression" || d.type === "SequenceExpression" && m.type === "ForStatement" && (m.init === d || m.update === d) || h === "value" && d.type === "Property" && m.type === "ObjectPattern" && m.properties.includes(d) || d.type === "NGChainedExpression");
    }
    case "ConditionalExpression":
      switch (d.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "BinaryExpression":
        case "LogicalExpression":
        case "NGPipeExpression":
        case "ExportDefaultDeclaration":
        case "AwaitExpression":
        case "JSXSpreadAttribute":
        case "TSTypeAssertion":
        case "TypeCastExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "TSNonNullExpression":
          return !0;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return h === "callee";
        case "ConditionalExpression":
          return e.experimentalTernaries ? !1 : h === "test";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return h === "object";
        default:
          return !1;
      }
    case "FunctionExpression":
      switch (d.type) {
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return h === "callee";
        case "TaggedTemplateExpression":
          return !0;
        default:
          return !1;
      }
    case "ArrowFunctionExpression":
      switch (d.type) {
        case "BinaryExpression":
          return d.operator !== "|>" || ((o = c.extra) == null ? void 0 : o.parenthesized);
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return h === "callee";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return h === "object";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "TSNonNullExpression":
        case "BindExpression":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "AwaitExpression":
        case "TSTypeAssertion":
          return !0;
        case "ConditionalExpression":
          return h === "test";
        default:
          return !1;
      }
    case "ClassExpression":
      switch (d.type) {
        case "NewExpression":
          return h === "callee";
        default:
          return !1;
      }
    case "OptionalMemberExpression":
    case "OptionalCallExpression":
    case "CallExpression":
    case "MemberExpression":
      if (z4(t))
        return !0;
    case "TaggedTemplateExpression":
    case "TSNonNullExpression":
      if (h === "callee" && (d.type === "BindExpression" || d.type === "NewExpression")) {
        let m = c;
        for (; m; )
          switch (m.type) {
            case "CallExpression":
            case "OptionalCallExpression":
              return !0;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "BindExpression":
              m = m.object;
              break;
            case "TaggedTemplateExpression":
              m = m.tag;
              break;
            case "TSNonNullExpression":
              m = m.expression;
              break;
            default:
              return !1;
          }
      }
      return !1;
    case "BindExpression":
      return h === "callee" && (d.type === "BindExpression" || d.type === "NewExpression") || h === "object" && at(d);
    case "NGPipeExpression":
      return !(d.type === "NGRoot" || d.type === "NGMicrosyntaxExpression" || d.type === "ObjectProperty" && !((u = c.extra) != null && u.parenthesized) || _t(d) || h === "arguments" && Re(d) || h === "right" && d.type === "NGPipeExpression" || h === "property" && d.type === "MemberExpression" || d.type === "AssignmentExpression");
    case "JSXFragment":
    case "JSXElement":
      return h === "callee" || h === "left" && d.type === "BinaryExpression" && d.operator === "<" || !_t(d) && d.type !== "ArrowFunctionExpression" && d.type !== "AssignmentExpression" && d.type !== "AssignmentPattern" && d.type !== "BinaryExpression" && d.type !== "NewExpression" && d.type !== "ConditionalExpression" && d.type !== "ExpressionStatement" && d.type !== "JsExpressionRoot" && d.type !== "JSXAttribute" && d.type !== "JSXElement" && d.type !== "JSXExpressionContainer" && d.type !== "JSXFragment" && d.type !== "LogicalExpression" && !Re(d) && !dn(d) && d.type !== "ReturnStatement" && d.type !== "ThrowStatement" && d.type !== "TypeCastExpression" && d.type !== "VariableDeclarator" && d.type !== "YieldExpression";
    case "TSInstantiationExpression":
      return h === "object" && at(d);
  }
  return !1;
}
var X4 = Ue(["BlockStatement", "BreakStatement", "ClassBody", "ClassDeclaration", "ClassMethod", "ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ContinueStatement", "DebuggerStatement", "DeclareClass", "DeclareExportAllDeclaration", "DeclareExportDeclaration", "DeclareFunction", "DeclareInterface", "DeclareModule", "DeclareModuleExports", "DeclareVariable", "DeclareEnum", "DoWhileStatement", "EnumDeclaration", "ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FunctionDeclaration", "IfStatement", "ImportDeclaration", "InterfaceDeclaration", "LabeledStatement", "MethodDefinition", "ReturnStatement", "SwitchStatement", "ThrowStatement", "TryStatement", "TSDeclareFunction", "TSEnumDeclaration", "TSImportEqualsDeclaration", "TSInterfaceDeclaration", "TSModuleDeclaration", "TSNamespaceExportDeclaration", "TypeAlias", "VariableDeclaration", "WhileStatement", "WithStatement"]);
function V4(t) {
  let e = 0, { node: r } = t;
  for (; r; ) {
    let i = t.getParentNode(e++);
    if ((i == null ? void 0 : i.type) === "ForStatement" && i.init === r)
      return !0;
    r = i;
  }
  return !1;
}
function Y4(t) {
  return rf(t, (e) => e.type === "ObjectTypeAnnotation" && rf(e, (r) => r.type === "FunctionTypeAnnotation"));
}
function U4(t) {
  return oi(t);
}
function $o(t) {
  let { parent: e, key: r } = t;
  switch (e.type) {
    case "NGPipeExpression":
      if (r === "arguments" && t.isLast)
        return t.callParent($o);
      break;
    case "ObjectProperty":
      if (r === "value")
        return t.callParent(() => t.key === "properties" && t.isLast);
      break;
    case "BinaryExpression":
    case "LogicalExpression":
      if (r === "right")
        return t.callParent($o);
      break;
    case "ConditionalExpression":
      if (r === "alternate")
        return t.callParent($o);
      break;
    case "UnaryExpression":
      if (e.prefix)
        return t.callParent($o);
      break;
  }
  return !1;
}
function tS(t, e) {
  let { node: r, parent: i } = t;
  return r.type === "FunctionExpression" || r.type === "ClassExpression" ? i.type === "ExportDefaultDeclaration" || !df(t, e) : !$g(r) || i.type !== "ExportDefaultDeclaration" && df(t, e) ? !1 : t.call(() => tS(t, e), ...gv(r));
}
function z4(t) {
  let { node: e, parent: r, grandparent: i, key: n } = t;
  return !!((e.type === "OptionalMemberExpression" || e.type === "OptionalCallExpression") && (n === "object" && r.type === "MemberExpression" || n === "callee" && (r.type === "CallExpression" || r.type === "NewExpression") || r.type === "TSNonNullExpression" && i.type === "MemberExpression" && i.object === r) || t.match(() => e.type === "CallExpression" || e.type === "MemberExpression", (s, a) => a === "expression" && s.type === "ChainExpression") && (t.match(void 0, void 0, (s, a) => a === "callee" && (s.type === "CallExpression" && !s.optional || s.type === "NewExpression") || a === "object" && s.type === "MemberExpression" && !s.optional) || t.match(void 0, void 0, (s, a) => a === "expression" && s.type === "TSNonNullExpression", (s, a) => a === "object" && s.type === "MemberExpression")) || t.match(() => e.type === "CallExpression" || e.type === "MemberExpression", (s, a) => a === "expression" && s.type === "TSNonNullExpression", (s, a) => a === "expression" && s.type === "ChainExpression", (s, a) => a === "object" && s.type === "MemberExpression"));
}
var Vs = df;
function G4(t, e) {
  let r = e - 1;
  r = $a(t, r, { backwards: !0 }), r = Ba(t, r, { backwards: !0 }), r = $a(t, r, { backwards: !0 });
  let i = Ba(t, r, { backwards: !0 });
  return r !== i;
}
var H4 = G4, J4 = () => !0;
function Xg(t, e) {
  let r = t.node;
  return r.printed = !0, e.printer.printComment(t, e);
}
function K4(t, e) {
  var r;
  let i = t.node, n = [Xg(t, e)], { printer: s, originalText: a, locStart: o, locEnd: u } = e;
  if ((r = s.isBlockComment) != null && r.call(s, i)) {
    let h = Cr(a, u(i)) ? Cr(a, o(i), { backwards: !0 }) ? ee : he : " ";
    n.push(h);
  } else
    n.push(ee);
  let c = Ba(a, $a(a, u(i)));
  return c !== !1 && Cr(a, c) && n.push(ee), n;
}
function e6(t, e, r) {
  var i;
  let n = t.node, s = Xg(t, e), { printer: a, originalText: o, locStart: u } = e, c = (i = a.isBlockComment) == null ? void 0 : i.call(a, n);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || Cr(o, u(n), { backwards: !0 })) {
    let h = H4(o, u(n));
    return { doc: wO([ee, h ? ee : "", s]), isBlock: c, hasLineSuffix: !0 };
  }
  return !c || r != null && r.hasLineSuffix ? { doc: [wO([" ", s]), Qi], isBlock: c, hasLineSuffix: !0 } : { doc: [" ", s], isBlock: c, hasLineSuffix: !1 };
}
function lt(t, e, r = {}) {
  let { node: i } = t;
  if (!Ze(i == null ? void 0 : i.comments))
    return "";
  let { indent: n = !1, marker: s, filter: a = J4 } = r, o = [];
  if (t.each(({ node: c }) => {
    c.leading || c.trailing || c.marker !== s || !a(c) || o.push(Xg(t, e));
  }, "comments"), o.length === 0)
    return "";
  let u = Ne(ee, o);
  return n ? te([ee, u]) : u;
}
function rS(t, e) {
  let r = t.node;
  if (!r)
    return {};
  let i = e[Symbol.for("printedComments")];
  if ((r.comments || []).filter((o) => !i.has(o)).length === 0)
    return { leading: "", trailing: "" };
  let n = [], s = [], a;
  return t.each(() => {
    let o = t.node;
    if (i != null && i.has(o))
      return;
    let { leading: u, trailing: c } = o;
    u ? n.push(K4(t, e)) : c && (a = e6(t, e, a), s.push(a.doc));
  }, "comments"), { leading: n, trailing: s };
}
function ai(t, e, r) {
  let { leading: i, trailing: n } = rS(t, r);
  return !i && !n ? e : of(e, (s) => [i, s, n]);
}
var t6 = class extends Error {
  constructor(r, i, n = "type") {
    super(`Unexpected ${i} node ${n}: ${JSON.stringify(r[n])}.`);
    Gr(this, "name", "UnexpectedNodeError");
    this.node = r;
  }
}, eo = t6;
function r6(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var Jr, i6 = class {
  constructor(e) {
    j7(this, Jr, void 0), Z7(this, Jr, new Set(e));
  }
  getLeadingWhitespaceCount(e) {
    let r = Dn(this, Jr), i = 0;
    for (let n = 0; n < e.length && r.has(e.charAt(n)); n++)
      i++;
    return i;
  }
  getTrailingWhitespaceCount(e) {
    let r = Dn(this, Jr), i = 0;
    for (let n = e.length - 1; n >= 0 && r.has(e.charAt(n)); n--)
      i++;
    return i;
  }
  getLeadingWhitespace(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(0, r);
  }
  getTrailingWhitespace(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(e.length - r);
  }
  hasLeadingWhitespace(e) {
    return Dn(this, Jr).has(e.charAt(0));
  }
  hasTrailingWhitespace(e) {
    return Dn(this, Jr).has(qe(!1, e, -1));
  }
  trimStart(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(r);
  }
  trimEnd(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(0, e.length - r);
  }
  trim(e) {
    return this.trimEnd(this.trimStart(e));
  }
  split(e, r = !1) {
    let i = `[${r6([...Dn(this, Jr)].join(""))}]+`, n = new RegExp(r ? `(${i})` : i);
    return e.split(n);
  }
  hasWhitespaceCharacter(e) {
    let r = Dn(this, Jr);
    return Array.prototype.some.call(e, (i) => r.has(i));
  }
  hasNonWhitespaceCharacter(e) {
    let r = Dn(this, Jr);
    return Array.prototype.some.call(e, (i) => !r.has(i));
  }
  isWhitespaceOnly(e) {
    let r = Dn(this, Jr);
    return Array.prototype.every.call(e, (i) => r.has(i));
  }
};
Jr = /* @__PURE__ */ new WeakMap();
var n6 = i6, lc = new n6(` 
\r	`), zp = (t) => t === "" || t === he || t === ee || t === H;
function s6(t, e, r) {
  var i, n, s;
  let { node: a } = t;
  if (a.type === "JSXElement" && b6(a))
    return [r("openingElement"), r("closingElement")];
  let o = a.type === "JSXElement" ? r("openingElement") : r("openingFragment"), u = a.type === "JSXElement" ? r("closingElement") : r("closingFragment");
  if (a.children.length === 1 && a.children[0].type === "JSXExpressionContainer" && (a.children[0].expression.type === "TemplateLiteral" || a.children[0].expression.type === "TaggedTemplateExpression"))
    return [o, ...t.map(r, "children"), u];
  a.children = a.children.map((E) => D6(E) ? { type: "JSXText", value: " ", raw: " " } : E);
  let c = a.children.some(vt), h = a.children.filter((E) => E.type === "JSXExpressionContainer").length > 1, d = a.type === "JSXElement" && a.openingElement.attributes.length > 1, m = Gt(o) || c || d || h, y = t.parent.rootMarker === "mdx", O = e.singleQuote ? "{' '}" : '{" "}', b = y ? " " : Ee([O, H], " "), v = ((n = (i = a.openingElement) == null ? void 0 : i.name) == null ? void 0 : n.name) === "fbt", S = a6(t, e, r, b, v), x = a.children.some((E) => cl(E));
  for (let E = S.length - 2; E >= 0; E--) {
    let P = S[E] === "" && S[E + 1] === "", I = S[E] === ee && S[E + 1] === "" && S[E + 2] === ee, B = (S[E] === H || S[E] === ee) && S[E + 1] === "" && S[E + 2] === b, Q = S[E] === b && S[E + 1] === "" && (S[E + 2] === H || S[E + 2] === ee), j = S[E] === b && S[E + 1] === "" && S[E + 2] === b, G = S[E] === H && S[E + 1] === "" && S[E + 2] === ee || S[E] === ee && S[E + 1] === "" && S[E + 2] === H;
    I && x || P || B || j || G ? S.splice(E, 2) : Q && S.splice(E + 1, 2);
  }
  for (; S.length > 0 && zp(qe(!1, S, -1)); )
    S.pop();
  for (; S.length > 1 && zp(S[0]) && zp(S[1]); )
    S.shift(), S.shift();
  let w = [];
  for (let [E, P] of S.entries()) {
    if (P === b) {
      if (E === 1 && S[E - 1] === "") {
        if (S.length === 2) {
          w.push(O);
          continue;
        }
        w.push([O, ee]);
        continue;
      } else if (E === S.length - 1) {
        w.push(O);
        continue;
      } else if (S[E - 1] === "" && S[E - 2] === ee) {
        w.push(O);
        continue;
      }
    }
    w.push(P), Gt(P) && (m = !0);
  }
  let k = x ? Qg(w) : Z(w, { shouldBreak: !0 });
  if (((s = e.cursorNode) == null ? void 0 : s.type) === "JSXText" && a.children.includes(e.cursorNode) && (k = [CO, k, CO]), y)
    return k;
  let C = Z([o, te([ee, k]), ee, u]);
  return m ? C : fs([Z([o, ...S, u]), C]);
}
function a6(t, e, r, i, n) {
  let s = [];
  return t.each(({ node: a, next: o }) => {
    if (a.type === "JSXText") {
      let u = Zr(a);
      if (cl(a)) {
        let c = lc.split(u, !0);
        c[0] === "" && (s.push(""), c.shift(), /\n/.test(c[0]) ? s.push(PO(n, c[1], a, o)) : s.push(i), c.shift());
        let h;
        if (qe(!1, c, -1) === "" && (c.pop(), h = c.pop()), c.length === 0)
          return;
        for (let [d, m] of c.entries())
          d % 2 === 1 ? s.push(he) : s.push(m);
        h !== void 0 ? /\n/.test(h) ? s.push(PO(n, qe(!1, s, -1), a, o)) : s.push(i) : s.push(TO(n, qe(!1, s, -1), a, o));
      } else
        /\n/.test(u) ? u.match(/\n/g).length > 1 && s.push("", ee) : s.push("", i);
    } else {
      let u = r();
      if (s.push(u), o && cl(o)) {
        let c = lc.trim(Zr(o)), [h] = lc.split(c);
        s.push(TO(n, h, a, o));
      } else
        s.push(ee);
    }
  }, "children"), s;
}
function TO(t, e, r, i) {
  return t ? "" : r.type === "JSXElement" && !r.closingElement || (i == null ? void 0 : i.type) === "JSXElement" && !i.closingElement ? e.length === 1 ? H : ee : H;
}
function PO(t, e, r, i) {
  return t ? ee : e.length === 1 ? r.type === "JSXElement" && !r.closingElement || (i == null ? void 0 : i.type) === "JSXElement" && !i.closingElement ? ee : H : ee;
}
var o6 = /* @__PURE__ */ new Set(["ArrayExpression", "TupleExpression", "JSXAttribute", "JSXElement", "JSXExpressionContainer", "JSXFragment", "ExpressionStatement", "CallExpression", "OptionalCallExpression", "ConditionalExpression", "JsExpressionRoot"]);
function l6(t, e, r) {
  let { parent: i } = t;
  if (o6.has(i.type))
    return e;
  let n = t.match(void 0, (a) => a.type === "ArrowFunctionExpression", Re, (a) => a.type === "JSXExpressionContainer"), s = Vs(t, r);
  return Z([s ? "" : Ee("("), te([H, e]), H, s ? "" : Ee(")")], { shouldBreak: n });
}
function u6(t, e, r) {
  let { node: i } = t, n = [];
  if (n.push(r("name")), i.value) {
    let s;
    if (lr(i.value)) {
      let a = Zr(i.value), o = Dr(!1, Dr(!1, a.slice(1, -1), "&apos;", "'"), "&quot;", '"'), u = hv(o, e.jsxSingleQuote);
      o = u === '"' ? Dr(!1, o, '"', "&quot;") : Dr(!1, o, "'", "&apos;"), s = t.call(() => ai(t, As(u + o + u), e), "value");
    } else
      s = r("value");
    n.push("=", s);
  }
  return n;
}
function c6(t, e, r) {
  let { node: i } = t, n = (s, a) => s.type === "JSXEmptyExpression" || !se(s) && (_t(s) || oi(s) || s.type === "ArrowFunctionExpression" || s.type === "AwaitExpression" && (n(s.argument, s) || s.argument.type === "JSXElement") || Re(s) || s.type === "ChainExpression" && Re(s.expression) || s.type === "FunctionExpression" || s.type === "TemplateLiteral" || s.type === "TaggedTemplateExpression" || s.type === "DoExpression" || vt(a) && (s.type === "ConditionalExpression" || Ji(s)));
  return n(i.expression, t.parent) ? Z(["{", r("expression"), Ki, "}"]) : Z(["{", te([H, r("expression")]), H, Ki, "}"]);
}
function h6(t, e, r) {
  var i, n;
  let { node: s } = t, a = se(s.name) || se(s.typeParameters) || se(s.typeArguments);
  if (s.selfClosing && s.attributes.length === 0 && !a)
    return ["<", r("name"), s.typeArguments ? r("typeArguments") : r("typeParameters"), " />"];
  if (((i = s.attributes) == null ? void 0 : i.length) === 1 && s.attributes[0].value && lr(s.attributes[0].value) && !s.attributes[0].value.value.includes(`
`) && !a && !se(s.attributes[0]))
    return Z(["<", r("name"), s.typeArguments ? r("typeArguments") : r("typeParameters"), " ", ...t.map(r, "attributes"), s.selfClosing ? " />" : ">"]);
  let o = (n = s.attributes) == null ? void 0 : n.some((c) => c.value && lr(c.value) && c.value.value.includes(`
`)), u = e.singleAttributePerLine && s.attributes.length > 1 ? ee : he;
  return Z(["<", r("name"), s.typeArguments ? r("typeArguments") : r("typeParameters"), te(t.map(() => [u, r()], "attributes")), ...p6(s, e, a)], { shouldBreak: o });
}
function p6(t, e, r) {
  return t.selfClosing ? [he, "/>"] : d6(t, e, r) ? [">"] : [H, ">"];
}
function d6(t, e, r) {
  let i = t.attributes.length > 0 && se(qe(!1, t.attributes, -1), de.Trailing);
  return t.attributes.length === 0 && !r || (e.bracketSameLine || e.jsxBracketSameLine) && (!r || t.attributes.length > 0) && !i;
}
function f6(t, e, r) {
  let { node: i } = t, n = [];
  n.push("</");
  let s = r("name");
  return se(i.name, de.Leading | de.Line) ? n.push(te([ee, s]), ee) : se(i.name, de.Leading | de.Block) ? n.push(" ", s) : n.push(s), n.push(">"), n;
}
function m6(t, e) {
  let { node: r } = t, i = se(r), n = se(r, de.Line), s = r.type === "JSXOpeningFragment";
  return [s ? "<" : "</", te([n ? ee : i && !s ? " " : "", lt(t, e)]), n ? ee : "", ">"];
}
function g6(t, e, r) {
  let i = ai(t, s6(t, e, r), e);
  return l6(t, i, e);
}
function y6(t, e) {
  let { node: r } = t, i = se(r, de.Line);
  return [lt(t, e, { indent: i }), i ? ee : ""];
}
function O6(t, e, r) {
  let { node: i } = t;
  return ["{", t.call(({ node: n }) => {
    let s = ["...", r()];
    return !se(n) || !Uv(t) ? s : [te([H, ai(t, s, e)]), H];
  }, i.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
}
function x6(t, e, r) {
  let { node: i } = t;
  if (i.type.startsWith("JSX"))
    switch (i.type) {
      case "JSXAttribute":
        return u6(t, e, r);
      case "JSXIdentifier":
        return i.name;
      case "JSXNamespacedName":
        return Ne(":", [r("namespace"), r("name")]);
      case "JSXMemberExpression":
        return Ne(".", [r("object"), r("property")]);
      case "JSXSpreadAttribute":
      case "JSXSpreadChild":
        return O6(t, e, r);
      case "JSXExpressionContainer":
        return c6(t, e, r);
      case "JSXFragment":
      case "JSXElement":
        return g6(t, e, r);
      case "JSXOpeningElement":
        return h6(t, e, r);
      case "JSXClosingElement":
        return f6(t, e, r);
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        return m6(t, e);
      case "JSXEmptyExpression":
        return y6(t, e);
      case "JSXText":
        throw new Error("JSXText should be handled by JSXElement");
      default:
        throw new eo(i, "JSX");
    }
}
function b6(t) {
  if (t.children.length === 0)
    return !0;
  if (t.children.length > 1)
    return !1;
  let e = t.children[0];
  return e.type === "JSXText" && !cl(e);
}
function cl(t) {
  return t.type === "JSXText" && (lc.hasNonWhitespaceCharacter(Zr(t)) || !/\n/.test(Zr(t)));
}
function D6(t) {
  return t.type === "JSXExpressionContainer" && lr(t.expression) && t.expression.value === " " && !se(t.expression);
}
function v6(t) {
  let { node: e, parent: r } = t;
  if (!vt(e) || !vt(r))
    return !1;
  let { index: i, siblings: n } = t, s;
  for (let a = i; a > 0; a--) {
    let o = n[a - 1];
    if (!(o.type === "JSXText" && !cl(o))) {
      s = o;
      break;
    }
  }
  return (s == null ? void 0 : s.type) === "JSXExpressionContainer" && s.expression.type === "JSXEmptyExpression" && Hh(s.expression);
}
function S6(t) {
  return Hh(t.node) || v6(t);
}
var iS = S6, w6 = 0;
function nS(t, e, r) {
  var i;
  let { node: n, parent: s, grandparent: a, key: o } = t, u = o !== "body" && (s.type === "IfStatement" || s.type === "WhileStatement" || s.type === "SwitchStatement" || s.type === "DoWhileStatement"), c = n.operator === "|>" && ((i = t.root.extra) == null ? void 0 : i.__isUsingHackPipeline), h = ff(t, r, e, !1, u);
  if (u)
    return h;
  if (c)
    return Z(h);
  if (Re(s) && s.callee === n || s.type === "UnaryExpression" || at(s) && !s.computed)
    return Z([te([H, ...h]), H]);
  let d = s.type === "ReturnStatement" || s.type === "ThrowStatement" || s.type === "JSXExpressionContainer" && a.type === "JSXAttribute" || n.operator !== "|" && s.type === "JsExpressionRoot" || n.type !== "NGPipeExpression" && (s.type === "NGRoot" && e.parser === "__ng_binding" || s.type === "NGMicrosyntaxExpression" && a.type === "NGMicrosyntax" && a.body.length === 1) || n === s.body && s.type === "ArrowFunctionExpression" || n !== s.body && s.type === "ForStatement" || s.type === "ConditionalExpression" && a.type !== "ReturnStatement" && a.type !== "ThrowStatement" && !Re(a) || s.type === "TemplateLiteral", m = s.type === "AssignmentExpression" || s.type === "VariableDeclarator" || s.type === "ClassProperty" || s.type === "PropertyDefinition" || s.type === "TSAbstractPropertyDefinition" || s.type === "ClassPrivateProperty" || dn(s), y = Ji(n.left) && Ng(n.operator, n.left.operator);
  if (d || hl(n) && !y || !hl(n) && m)
    return Z(h);
  if (h.length === 0)
    return "";
  let O = vt(n.right), b = h.findIndex((C) => typeof C != "string" && !Array.isArray(C) && C.type === qr), v = h.slice(0, b === -1 ? 1 : b + 1), S = h.slice(v.length, O ? -1 : void 0), x = Symbol("logicalChain-" + ++w6), w = Z([...v, te(S)], { id: x });
  if (!O)
    return w;
  let k = qe(!1, h, -1);
  return Z([w, Jh(k, { groupId: x })]);
}
function ff(t, e, r, i, n) {
  var s;
  let { node: a } = t;
  if (!Ji(a))
    return [Z(e())];
  let o = [];
  Ng(a.operator, a.left.operator) ? o = t.call((v) => ff(v, e, r, !0, n), "left") : o.push(Z(e("left")));
  let u = hl(a), c = (a.operator === "|>" || a.type === "NGPipeExpression" || C6(t, r)) && !Ss(r.originalText, a.right), h = a.type === "NGPipeExpression" ? "|" : a.operator, d = a.type === "NGPipeExpression" && a.arguments.length > 0 ? Z(te([H, ": ", Ne([he, ": "], t.map(() => _i(2, Z(e())), "arguments"))])) : "", m;
  if (u)
    m = [h, " ", e("right"), d];
  else {
    let v = h === "|>" && ((s = t.root.extra) != null && s.__isUsingHackPipeline) ? t.call((S) => ff(S, e, r, !0, n), "right") : e("right");
    m = [c ? he : "", h, c ? " " : he, v, d];
  }
  let { parent: y } = t, O = se(a.left, de.Trailing | de.Line), b = O || !(n && a.type === "LogicalExpression") && y.type !== a.type && a.left.type !== a.type && a.right.type !== a.type;
  if (o.push(c ? "" : " ", b ? Z(m, { shouldBreak: O }) : m), i && se(a)) {
    let v = Mg(ai(t, o, r));
    return Array.isArray(v) || v.type === Ni ? _v(v) : [v];
  }
  return o;
}
function hl(t) {
  return t.type !== "LogicalExpression" ? !1 : !!(oi(t.right) && t.right.properties.length > 0 || _t(t.right) && t.right.elements.length > 0 || vt(t.right));
}
var FO = (t) => t.type === "BinaryExpression" && t.operator === "|";
function C6(t, e) {
  return (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && FO(t.node) && !t.hasAncestor((r) => !FO(r) && r.type !== "JsExpressionRoot");
}
function A6(t, e, r) {
  let { node: i } = t;
  if (i.type.startsWith("NG"))
    switch (i.type) {
      case "NGRoot":
        return [r("node"), se(i.node) ? " //" + xa(i.node)[0].value.trimEnd() : ""];
      case "NGPipeExpression":
        return nS(t, e, r);
      case "NGChainedExpression":
        return Z(Ne([";", he], t.map(() => k6(t) ? r() : ["(", r(), ")"], "expressions")));
      case "NGEmptyExpression":
        return "";
      case "NGMicrosyntax":
        return t.map(() => [t.isFirst ? "" : $O(t) ? " " : [";", he], r()], "body");
      case "NGMicrosyntaxKey":
        return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(i.name) ? i.name : JSON.stringify(i.name);
      case "NGMicrosyntaxExpression":
        return [r("expression"), i.alias === null ? "" : [" as ", r("alias")]];
      case "NGMicrosyntaxKeyedExpression": {
        let { index: n, parent: s } = t, a = $O(t) || (n === 1 && (i.key.name === "then" || i.key.name === "else" || i.key.name === "as") || (n === 2 || n === 3) && (i.key.name === "else" && s.body[n - 1].type === "NGMicrosyntaxKeyedExpression" && s.body[n - 1].key.name === "then" || i.key.name === "track")) && s.body[0].type === "NGMicrosyntaxExpression";
        return [r("key"), a ? " " : ": ", r("expression")];
      }
      case "NGMicrosyntaxLet":
        return ["let ", r("key"), i.value === null ? "" : [" = ", r("value")]];
      case "NGMicrosyntaxAs":
        return [r("key"), " as ", r("alias")];
      default:
        throw new eo(i, "Angular");
    }
}
function $O({ node: t, index: e }) {
  return t.type === "NGMicrosyntaxKeyedExpression" && t.key.name === "of" && e === 1;
}
var E6 = Ue(["CallExpression", "OptionalCallExpression", "AssignmentExpression"]);
function k6({ node: t }) {
  return rf(t, E6);
}
function sS(t, e, r) {
  let { node: i } = t;
  return Z([Ne(he, t.map(r, "decorators")), aS(i, e) ? ee : he]);
}
function T6(t, e, r) {
  return oS(t.node) ? [Ne(ee, t.map(r, "declaration", "decorators")), ee] : "";
}
function P6(t, e, r) {
  let { node: i, parent: n } = t, { decorators: s } = i;
  if (!Ze(s) || oS(n) || iS(t))
    return "";
  let a = i.type === "ClassExpression" || i.type === "ClassDeclaration" || aS(i, e);
  return [t.key === "declaration" && IQ(n) ? ee : a ? Qi : "", Ne(he, t.map(r, "decorators")), he];
}
function aS(t, e) {
  return t.decorators.some((r) => Cr(e.originalText, We(r)));
}
function oS(t) {
  var e;
  if (t.type !== "ExportDefaultDeclaration" && t.type !== "ExportNamedDeclaration" && t.type !== "DeclareExportDeclaration")
    return !1;
  let r = (e = t.declaration) == null ? void 0 : e.decorators;
  return Ze(r) && Vh(t, r[0]);
}
var Nc = class extends Error {
  constructor() {
    super(...arguments);
    Gr(this, "name", "ArgExpansionBailout");
  }
};
function F6(t, e, r) {
  let { node: i } = t, n = Wr(i);
  if (n.length === 0)
    return ["(", lt(t, e), ")"];
  if (I6(n))
    return ["(", r(["arguments", 0]), ", ", r(["arguments", 1]), ")"];
  let s = !1, a = n.length - 1, o = [];
  _g(t, ({ node: d }, m) => {
    let y = r();
    m === a || (Kn(d, e) ? (s = !0, y = [y, ",", ee, ee]) : y = [y, ",", he]), o.push(y);
  });
  let u = !(i.type === "ImportExpression" || i.callee.type === "Import") && Jn(e, "all") ? "," : "";
  function c() {
    return Z(["(", te([he, ...o]), u, he, ")"], { shouldBreak: !0 });
  }
  if (s || t.parent.type !== "Decorator" && WQ(n))
    return c();
  if (B6(n)) {
    let d = o.slice(1);
    if (d.some(Gt))
      return c();
    let m;
    try {
      m = r(vO(i, 0), { expandFirstArg: !0 });
    } catch (y) {
      if (y instanceof Nc)
        return c();
      throw y;
    }
    return Gt(m) ? [Qi, fs([["(", Z(m, { shouldBreak: !0 }), ", ", ...d, ")"], c()])] : fs([["(", m, ", ", ...d, ")"], ["(", Z(m, { shouldBreak: !0 }), ", ", ...d, ")"], c()]);
  }
  if ($6(n, o, e)) {
    let d = o.slice(0, -1);
    if (d.some(Gt))
      return c();
    let m;
    try {
      m = r(vO(i, -1), { expandLastArg: !0 });
    } catch (y) {
      if (y instanceof Nc)
        return c();
      throw y;
    }
    return Gt(m) ? [Qi, fs([["(", ...d, Z(m, { shouldBreak: !0 }), ")"], c()])] : fs([["(", ...d, m, ")"], ["(", ...d, Z(m, { shouldBreak: !0 }), ")"], c()]);
  }
  let h = ["(", te([H, ...o]), Ee(u), H, ")"];
  return Ev(t) ? h : Z(h, { shouldBreak: o.some(Gt) || s });
}
function Uo(t, e = !1) {
  return oi(t) && (t.properties.length > 0 || se(t)) || _t(t) && (t.elements.length > 0 || se(t)) || t.type === "TSTypeAssertion" && Uo(t.expression) || Ci(t) && Uo(t.expression) || t.type === "FunctionExpression" || t.type === "ArrowFunctionExpression" && (!t.returnType || !t.returnType.typeAnnotation || t.returnType.typeAnnotation.type !== "TSTypeReference" || N6(t.body)) && (t.body.type === "BlockStatement" || t.body.type === "ArrowFunctionExpression" && Uo(t.body, !0) || oi(t.body) || _t(t.body) || !e && (Re(t.body) || t.body.type === "ConditionalExpression") || vt(t.body)) || t.type === "DoExpression" || t.type === "ModuleExpression";
}
function $6(t, e, r) {
  var i, n;
  let s = qe(!1, t, -1);
  if (t.length === 1) {
    let o = qe(!1, e, -1);
    if ((i = o.label) != null && i.embed && ((n = o.label) == null ? void 0 : n.hug) !== !1)
      return !0;
  }
  let a = qe(!1, t, -2);
  return !se(s, de.Leading) && !se(s, de.Trailing) && Uo(s) && (!a || a.type !== s.type) && (t.length !== 2 || a.type !== "ArrowFunctionExpression" || !_t(s)) && !(t.length > 1 && BS(s, r));
}
function B6(t) {
  if (t.length !== 2)
    return !1;
  let [e, r] = t;
  return e.type === "ModuleExpression" && _6(r) ? !0 : !se(e) && (e.type === "FunctionExpression" || e.type === "ArrowFunctionExpression" && e.body.type === "BlockStatement") && r.type !== "FunctionExpression" && r.type !== "ArrowFunctionExpression" && r.type !== "ConditionalExpression" && lS(r) && !Uo(r);
}
function lS(t) {
  var e;
  if (t.type === "ParenthesizedExpression")
    return lS(t.expression);
  if (Ci(t) || t.type === "TypeCastExpression") {
    let { typeAnnotation: r } = t;
    return r.type === "TypeAnnotation" && (r = r.typeAnnotation), r.type === "TSArrayType" && (r = r.elementType, r.type === "TSArrayType" && (r = r.elementType)), (r.type === "GenericTypeAnnotation" || r.type === "TSTypeReference") && ((e = r.typeParameters) == null ? void 0 : e.params.length) === 1 && (r = r.typeParameters.params[0]), Bg(r) && ri(t.expression, 1);
  }
  return Ia(t) && Wr(t).length > 1 ? !1 : Ji(t) ? ri(t.left, 1) && ri(t.right, 1) : Ov(t) || ri(t);
}
function I6(t) {
  return t.length === 2 && t[0].type === "ArrowFunctionExpression" && Vt(t[0]).length === 0 && t[0].body.type === "BlockStatement" && t[1].type === "ArrayExpression" && !t.some((e) => se(e));
}
function N6(t) {
  return t.type === "BlockStatement" && (t.body.some((e) => e.type !== "EmptyStatement") || se(t, de.Dangling));
}
function _6(t) {
  return t.type === "ObjectExpression" && t.properties.length === 1 && dn(t.properties[0]) && t.properties[0].key.type === "Identifier" && t.properties[0].key.name === "type" && lr(t.properties[0].value) && t.properties[0].value.value === "module";
}
var mf = F6, Q6 = (t) => ((t.type === "ChainExpression" || t.type === "TSNonNullExpression") && (t = t.expression), Re(t) && Wr(t).length > 0);
function M6(t, e, r) {
  var i;
  let n = r("object"), s = uS(t, e, r), { node: a } = t, o = t.findAncestor((h) => !(at(h) || h.type === "TSNonNullExpression")), u = t.findAncestor((h) => !(h.type === "ChainExpression" || h.type === "TSNonNullExpression")), c = o && (o.type === "NewExpression" || o.type === "BindExpression" || o.type === "AssignmentExpression" && o.left.type !== "Identifier") || a.computed || a.object.type === "Identifier" && a.property.type === "Identifier" && !at(u) || (u.type === "AssignmentExpression" || u.type === "VariableDeclarator") && (Q6(a.object) || ((i = n.label) == null ? void 0 : i.memberChain));
  return Zl(n.label, [n, c ? s : Z(te([H, s]))]);
}
function uS(t, e, r) {
  let i = r("property"), { node: n } = t, s = Ht(t);
  return n.computed ? !n.property || jn(n.property) ? [s, "[", i, "]"] : Z([s, "[", te([H, i]), H, "]"]) : [s, ".", i];
}
function cS(t, e, r) {
  if (t.node.type === "ChainExpression")
    return t.call(() => cS(t, e, r), "expression");
  let { parent: i } = t, n = !i || i.type === "ExpressionStatement", s = [];
  function a(L) {
    let { originalText: q } = e, X = Wl(q, We(L));
    return q.charAt(X) === ")" ? X !== !1 && Fg(q, X + 1) : Kn(L, e);
  }
  function o(L) {
    let { node: q } = L;
    if (q.type === "ChainExpression")
      return L.call(() => o(L), "expression");
    if (Re(q) && (la(q.callee) || Re(q.callee))) {
      let X = a(q);
      s.unshift({ node: q, hasTrailingEmptyLine: X, printed: [ai(L, [Ht(L), Es(L, e, r), mf(L, e, r)], e), X ? ee : ""] }), L.call((K) => o(K), "callee");
    } else
      la(q) ? (s.unshift({ node: q, needsParens: Vs(L, e), printed: ai(L, at(q) ? uS(L, e, r) : FS(L, e, r), e) }), L.call((X) => o(X), "object")) : q.type === "TSNonNullExpression" ? (s.unshift({ node: q, printed: ai(L, "!", e) }), L.call((X) => o(X), "expression")) : s.unshift({ node: q, printed: r() });
  }
  let { node: u } = t;
  s.unshift({ node: u, printed: [Ht(t), Es(t, e, r), mf(t, e, r)] }), u.callee && t.call((L) => o(L), "callee");
  let c = [], h = [s[0]], d = 1;
  for (; d < s.length && (s[d].node.type === "TSNonNullExpression" || Re(s[d].node) || at(s[d].node) && s[d].node.computed && jn(s[d].node.property)); ++d)
    h.push(s[d]);
  if (!Re(s[0].node))
    for (; d + 1 < s.length && la(s[d].node) && la(s[d + 1].node); ++d)
      h.push(s[d]);
  c.push(h), h = [];
  let m = !1;
  for (; d < s.length; ++d) {
    if (m && la(s[d].node)) {
      if (s[d].node.computed && jn(s[d].node.property)) {
        h.push(s[d]);
        continue;
      }
      c.push(h), h = [], m = !1;
    }
    (Re(s[d].node) || s[d].node.type === "ImportExpression") && (m = !0), h.push(s[d]), se(s[d].node, de.Trailing) && (c.push(h), h = [], m = !1);
  }
  h.length > 0 && c.push(h);
  function y(L) {
    return /^[A-Z]|^[$_]+$/.test(L);
  }
  function O(L) {
    return L.length <= e.tabWidth;
  }
  function b(L) {
    var q;
    let X = (q = L[1][0]) == null ? void 0 : q.node.computed;
    if (L[0].length === 1) {
      let Oe = L[0][0].node;
      return Oe.type === "ThisExpression" || Oe.type === "Identifier" && (y(Oe.name) || n && O(Oe.name) || X);
    }
    let K = qe(!1, L[0], -1).node;
    return at(K) && K.property.type === "Identifier" && (y(K.property.name) || X);
  }
  let v = c.length >= 2 && !se(c[1][0].node) && b(c);
  function S(L) {
    let q = L.map((X) => X.printed);
    return L.length > 0 && qe(!1, L, -1).needsParens ? ["(", ...q, ")"] : q;
  }
  function x(L) {
    return L.length === 0 ? "" : te([ee, Ne(ee, L.map(S))]);
  }
  let w = c.map(S), k = w, C = v ? 3 : 2, E = c.flat(), P = E.slice(1, -1).some((L) => se(L.node, de.Leading)) || E.slice(0, -1).some((L) => se(L.node, de.Trailing)) || c[C] && se(c[C][0].node, de.Leading);
  if (c.length <= C && !P && !c.some((L) => qe(!1, L, -1).hasTrailingEmptyLine))
    return Ev(t) ? k : Z(k);
  let I = qe(!1, c[v ? 1 : 0], -1).node, B = !Re(I) && a(I), Q = [S(c[0]), v ? c.slice(1, 2).map(S) : "", B ? ee : "", x(c.slice(v ? 2 : 1))], j = s.map(({ node: L }) => L).filter(Re);
  function G() {
    let L = qe(!1, qe(!1, c, -1), -1).node, q = qe(!1, w, -1);
    return Re(L) && Gt(q) && j.slice(0, -1).some((X) => X.arguments.some(ll));
  }
  let J;
  return P || j.length > 2 && j.some((L) => !L.arguments.every((q) => ri(q))) || w.slice(0, -1).some(Gt) || G() ? J = Z(Q) : J = [Gt(k) || B ? Qi : "", fs([k, Q])], Zl({ memberChain: !0 }, J);
}
var L6 = cS;
function hS(t, e, r) {
  var i;
  let { node: n, parent: s } = t, a = n.type === "NewExpression", o = n.type === "ImportExpression", u = Ht(t), c = Wr(n), h = c.length === 1 && Cv(c[0], e.originalText);
  if (h || c.length > 0 && !a && !o && (j6(n, s) || Gh(n, s))) {
    let m = [];
    if (_g(t, () => {
      m.push(r());
    }), !(h && (i = m[0].label) != null && i.embed))
      return [a ? "new " : "", r("callee"), u, Es(t, e, r), "(", Ne(", ", m), ")"];
  }
  if (!o && !a && la(n.callee) && !t.call((m) => Vs(m, e), "callee", ...n.callee.type === "ChainExpression" ? ["expression"] : []))
    return L6(t, e, r);
  let d = [a ? "new " : "", o ? R6(n) : r("callee"), u, Es(t, e, r), mf(t, e, r)];
  return o || Re(n.callee) ? Z(d) : d;
}
function R6(t) {
  return t.phase ? `import.${t.phase}` : "import";
}
function j6(t, e) {
  if (t.callee.type !== "Identifier")
    return !1;
  if (t.callee.name === "require") {
    let r = Wr(t);
    return r.length === 1 && lr(r[0]) || r.length > 1;
  }
  if (t.callee.name === "define") {
    let r = Wr(t);
    return e.type === "ExpressionStatement" && (r.length === 1 || r.length === 2 && r[0].type === "ArrayExpression" || r.length === 3 && lr(r[0]) && r[1].type === "ArrayExpression");
  }
  return !1;
}
function ql(t, e, r, i, n, s) {
  let a = q6(t, e, r, i, s), o = s ? r(s, { assignmentLayout: a }) : "";
  switch (a) {
    case "break-after-operator":
      return Z([Z(i), n, Z(te([he, o]))]);
    case "never-break-after-operator":
      return Z([Z(i), n, " ", o]);
    case "fluid": {
      let u = Symbol("assignment");
      return Z([Z(i), n, Z(te(he), { id: u }), Ki, Jh(o, { groupId: u })]);
    }
    case "break-lhs":
      return Z([i, n, " ", Z(o)]);
    case "chain":
      return [Z(i), n, he, o];
    case "chain-tail":
      return [Z(i), n, te([he, o])];
    case "chain-tail-arrow-chain":
      return [Z(i), n, o];
    case "only-left":
      return i;
  }
}
function Z6(t, e, r) {
  let { node: i } = t;
  return ql(t, e, r, r("left"), [" ", i.operator], "right");
}
function W6(t, e, r) {
  return ql(t, e, r, r("id"), " =", "init");
}
function q6(t, e, r, i, n) {
  let { node: s } = t, a = s[n];
  if (!a)
    return "only-left";
  let o = !uc(a);
  if (t.match(uc, pS, (h) => !o || h.type !== "ExpressionStatement" && h.type !== "VariableDeclaration"))
    return o ? a.type === "ArrowFunctionExpression" && a.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
  if (!o && uc(a.right) || Ss(e.originalText, a))
    return "break-after-operator";
  if (a.type === "CallExpression" && a.callee.name === "require" || e.parser === "json5" || e.parser === "jsonc" || e.parser === "json")
    return "never-break-after-operator";
  let u = d9(i);
  if (V6(s) || G6(s) || dS(s) && u)
    return "break-lhs";
  let c = J6(s, i, e);
  return t.call(() => X6(t, e, r, c), n) ? "break-after-operator" : Y6(s) ? "break-lhs" : !u && (c || a.type === "TemplateLiteral" || a.type === "TaggedTemplateExpression" || a.type === "BooleanLiteral" || jn(a) || a.type === "ClassExpression") ? "never-break-after-operator" : "fluid";
}
function X6(t, e, r, i) {
  let n = t.node;
  if (Ji(n) && !hl(n))
    return !0;
  switch (n.type) {
    case "StringLiteralTypeAnnotation":
    case "SequenceExpression":
      return !0;
    case "TSConditionalType":
    case "ConditionalTypeAnnotation":
      if (!e.experimentalTernaries && !tM(n))
        break;
      return !0;
    case "ConditionalExpression": {
      if (!e.experimentalTernaries) {
        let { test: c } = n;
        return Ji(c) && !hl(c);
      }
      let { consequent: o, alternate: u } = n;
      return o.type === "ConditionalExpression" || u.type === "ConditionalExpression";
    }
    case "ClassExpression":
      return Ze(n.decorators);
  }
  if (i)
    return !1;
  let s = n, a = [];
  for (; ; )
    if (s.type === "UnaryExpression" || s.type === "AwaitExpression" || s.type === "YieldExpression" && s.argument !== null)
      s = s.argument, a.push("argument");
    else if (s.type === "TSNonNullExpression")
      s = s.expression, a.push("expression");
    else
      break;
  return !!(lr(s) || t.call(() => fS(t, e, r), ...a));
}
function V6(t) {
  if (pS(t)) {
    let e = t.left || t.id;
    return e.type === "ObjectPattern" && e.properties.length > 2 && e.properties.some((r) => {
      var i;
      return dn(r) && (!r.shorthand || ((i = r.value) == null ? void 0 : i.type) === "AssignmentPattern");
    });
  }
  return !1;
}
function uc(t) {
  return t.type === "AssignmentExpression";
}
function pS(t) {
  return uc(t) || t.type === "VariableDeclarator";
}
function Y6(t) {
  let e = z6(t);
  if (Ze(e)) {
    let r = t.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
    if (e.length > 1 && e.some((i) => i[r] || i.default))
      return !0;
  }
  return !1;
}
var U6 = Ue(["TSTypeAliasDeclaration", "TypeAlias"]);
function z6(t) {
  var e;
  if (U6(t))
    return (e = t.typeParameters) == null ? void 0 : e.params;
}
function G6(t) {
  if (t.type !== "VariableDeclarator")
    return !1;
  let { typeAnnotation: e } = t.id;
  if (!e || !e.typeAnnotation)
    return !1;
  let r = BO(e.typeAnnotation);
  return Ze(r) && r.length > 1 && r.some((i) => Ze(BO(i)) || i.type === "TSConditionalType");
}
function dS(t) {
  var e;
  return t.type === "VariableDeclarator" && ((e = t.init) == null ? void 0 : e.type) === "ArrowFunctionExpression";
}
var H6 = Ue(["TSTypeReference", "GenericTypeAnnotation"]);
function BO(t) {
  var e;
  if (H6(t))
    return (e = t.typeParameters) == null ? void 0 : e.params;
}
function fS(t, e, r, i = !1) {
  var n;
  let { node: s } = t, a = () => fS(t, e, r, !0);
  if (s.type === "ChainExpression" || s.type === "TSNonNullExpression")
    return t.call(a, "expression");
  if (Re(s)) {
    if ((n = hS(t, e, r).label) != null && n.memberChain)
      return !1;
    let o = Wr(s);
    return !(o.length === 0 || o.length === 1 && Ig(o[0], e)) || K6(s, r) ? !1 : t.call(a, "callee");
  }
  return at(s) ? t.call(a, "object") : i && (s.type === "Identifier" || s.type === "ThisExpression");
}
function J6(t, e, r) {
  return dn(t) ? (e = Mg(e), typeof e == "string" && Fa(e) < r.tabWidth + 3) : !1;
}
function K6(t, e) {
  let r = eM(t);
  if (Ze(r)) {
    if (r.length > 1)
      return !0;
    if (r.length === 1) {
      let n = r[0];
      if (ws(n) || Tv(n) || n.type === "TSTypeLiteral" || n.type === "ObjectTypeAnnotation")
        return !0;
    }
    let i = t.typeParameters ? "typeParameters" : "typeArguments";
    if (Gt(e(i)))
      return !0;
  }
  return !1;
}
function eM(t) {
  var e;
  return (e = t.typeParameters ?? t.typeArguments) == null ? void 0 : e.params;
}
function tM(t) {
  function e(r) {
    switch (r.type) {
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "TSFunctionType":
      case "TSTypeReference":
        return !!r.typeParameters;
      default:
        return !1;
    }
  }
  return e(t.checkType) || e(t.extendsType);
}
function Xl(t, e, r, i, n) {
  let s = t.node, a = Vt(s), o = n ? Es(t, r, e) : "";
  if (a.length === 0)
    return [o, "(", lt(t, r, { filter: (y) => en(r.originalText, We(y)) === ")" }), ")"];
  let { parent: u } = t, c = Gh(u), h = mS(s), d = [];
  if (zQ(t, (y, O) => {
    let b = O === a.length - 1;
    b && s.rest && d.push("..."), d.push(e()), !b && (d.push(","), c || h ? d.push(" ") : Kn(a[O], r) ? d.push(ee, ee) : d.push(he));
  }), i && !iM(t)) {
    if (Gt(o) || Gt(d))
      throw new Nc();
    return Z([af(o), "(", af(d), ")"]);
  }
  let m = a.every((y) => !Ze(y.decorators));
  return h && m ? [o, "(", ...d, ")"] : c ? [o, "(", ...d, ")"] : (bv(u) || _Q(u) || u.type === "TypeAlias" || u.type === "UnionTypeAnnotation" || u.type === "IntersectionTypeAnnotation" || u.type === "FunctionTypeAnnotation" && u.returnType === s) && a.length === 1 && a[0].name === null && s.this !== a[0] && a[0].typeAnnotation && s.typeParameters === null && Bg(a[0].typeAnnotation) && !s.rest ? r.arrowParens === "always" ? ["(", ...d, ")"] : d : [o, "(", te([H, ...d]), Ee(!UQ(s) && Jn(r, "all") ? "," : ""), H, ")"];
}
function mS(t) {
  if (!t)
    return !1;
  let e = Vt(t);
  if (e.length !== 1)
    return !1;
  let [r] = e;
  return !se(r) && (r.type === "ObjectPattern" || r.type === "ArrayPattern" || r.type === "Identifier" && r.typeAnnotation && (r.typeAnnotation.type === "TypeAnnotation" || r.typeAnnotation.type === "TSTypeAnnotation") && Zn(r.typeAnnotation.typeAnnotation) || r.type === "FunctionTypeParam" && Zn(r.typeAnnotation) && r !== t.rest || r.type === "AssignmentPattern" && (r.left.type === "ObjectPattern" || r.left.type === "ArrayPattern") && (r.right.type === "Identifier" || oi(r.right) && r.right.properties.length === 0 || _t(r.right) && r.right.elements.length === 0));
}
function rM(t) {
  let e;
  return t.returnType ? (e = t.returnType, e.typeAnnotation && (e = e.typeAnnotation)) : t.typeAnnotation && (e = t.typeAnnotation), e;
}
function Kh(t, e) {
  var r;
  let i = rM(t);
  if (!i)
    return !1;
  let n = (r = t.typeParameters) == null ? void 0 : r.params;
  if (n) {
    if (n.length > 1)
      return !1;
    if (n.length === 1) {
      let s = n[0];
      if (s.constraint || s.default)
        return !1;
    }
  }
  return Vt(t).length === 1 && (Zn(i) || Gt(e));
}
function iM(t) {
  return t.match((e) => e.type === "ArrowFunctionExpression" && e.body.type === "BlockStatement", (e, r) => {
    if (e.type === "CallExpression" && r === "arguments" && e.arguments.length === 1 && e.callee.type === "CallExpression") {
      let i = e.callee.callee;
      return i.type === "Identifier" || i.type === "MemberExpression" && !i.computed && i.object.type === "Identifier" && i.property.type === "Identifier";
    }
    return !1;
  }, (e, r) => e.type === "VariableDeclarator" && r === "init" || e.type === "ExportDefaultDeclaration" && r === "declaration" || e.type === "TSExportAssignment" && r === "expression" || e.type === "AssignmentExpression" && r === "right" && e.left.type === "MemberExpression" && e.left.object.type === "Identifier" && e.left.object.name === "module" && e.left.property.type === "Identifier" && e.left.property.name === "exports", (e) => e.type !== "VariableDeclaration" || e.kind === "const" && e.declarations.length === 1);
}
function nM(t) {
  let e = Vt(t);
  return e.length > 1 && e.some((r) => r.type === "TSParameterProperty");
}
var sM = Ue(["VoidTypeAnnotation", "TSVoidKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword"]), aM = Ue(["ObjectTypeAnnotation", "TSTypeLiteral", "GenericTypeAnnotation", "TSTypeReference"]);
function oM(t) {
  let { types: e } = t;
  if (e.some((i) => se(i)))
    return !1;
  let r = e.find((i) => aM(i));
  return r ? e.every((i) => i === r || sM(i)) : !1;
}
function gS(t) {
  return Bg(t) || Zn(t) ? !0 : ws(t) ? oM(t) : !1;
}
function lM(t, e, r) {
  let i = e.semi ? ";" : "", { node: n } = t, s = [Xr(t), "opaque type ", r("id"), r("typeParameters")];
  return n.supertype && s.push(": ", r("supertype")), n.impltype && s.push(" = ", r("impltype")), s.push(i), s;
}
function yS(t, e, r) {
  let i = e.semi ? ";" : "", { node: n } = t, s = [Xr(t)];
  s.push("type ", r("id"), r("typeParameters"));
  let a = n.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
  return [ql(t, e, r, s, " =", a), i];
}
function OS(t, e, r) {
  let i = !1;
  return Z(t.map(({ isFirst: n, previous: s, node: a, index: o }) => {
    let u = r();
    if (n)
      return u;
    let c = Zn(a), h = Zn(s);
    return h && c ? [" & ", i ? te(u) : u] : !h && !c ? te([" &", he, u]) : (o > 1 && (i = !0), [" & ", o > 1 ? te(u) : u]);
  }, "types"));
}
function xS(t, e, r) {
  let { node: i } = t, { parent: n } = t, s = n.type !== "TypeParameterInstantiation" && (n.type !== "TSConditionalType" || !e.experimentalTernaries) && (n.type !== "ConditionalTypeAnnotation" || !e.experimentalTernaries) && n.type !== "TSTypeParameterInstantiation" && n.type !== "GenericTypeAnnotation" && n.type !== "TSTypeReference" && n.type !== "TSTypeAssertion" && n.type !== "TupleTypeAnnotation" && n.type !== "TSTupleType" && !(n.type === "FunctionTypeParam" && !n.name && t.grandparent.this !== n) && !((n.type === "TypeAlias" || n.type === "VariableDeclarator" || n.type === "TSTypeAliasDeclaration") && Ss(e.originalText, i)), a = gS(i), o = t.map((h) => {
    let d = r();
    return a || (d = _i(2, d)), ai(h, d, e);
  }, "types");
  if (a)
    return Ne(" | ", o);
  let u = s && !Ss(e.originalText, i), c = [Ee([u ? he : "", "| "]), Ne([he, "| "], o)];
  return Vs(t, e) ? Z([te(c), H]) : (n.type === "TupleTypeAnnotation" || n.type === "TSTupleType") && n[n.type === "TupleTypeAnnotation" && n.types ? "types" : "elementTypes"].length > 1 ? Z([te([Ee(["(", H]), c]), H, Ee(")")]) : Z(s ? te(c) : c);
}
function uM(t) {
  var e;
  let { node: r, parent: i } = t;
  return r.type === "FunctionTypeAnnotation" && (bv(i) || !((i.type === "ObjectTypeProperty" || i.type === "ObjectTypeInternalSlot") && !i.variance && !i.optional && Vh(i, r) || i.type === "ObjectTypeCallProperty" || ((e = t.getParentNode(2)) == null ? void 0 : e.type) === "DeclareFunction"));
}
function bS(t, e, r) {
  let { node: i } = t, n = [ep(t)];
  (i.type === "TSConstructorType" || i.type === "TSConstructSignatureDeclaration") && n.push("new ");
  let s = Xl(t, r, e, !1, !0), a = [];
  return i.type === "FunctionTypeAnnotation" ? a.push(uM(t) ? " => " : ": ", r("returnType")) : a.push(It(t, r, i.returnType ? "returnType" : "typeAnnotation")), Kh(i, a) && (s = Z(s)), n.push(s, a), Z(n);
}
function DS(t, e, r) {
  return [r("objectType"), Ht(t), "[", r("indexType"), "]"];
}
function vS(t, e, r) {
  return ["infer ", r("typeParameter")];
}
function IO(t, e, r) {
  let { node: i } = t;
  return [i.postfix ? "" : r, It(t, e), i.postfix ? r : ""];
}
function SS(t, e, r) {
  let { node: i } = t;
  return ["...", ...i.type === "TupleTypeSpreadElement" && i.label ? [r("label"), ": "] : [], r("typeAnnotation")];
}
function wS(t, e, r) {
  let { node: i } = t;
  return [i.variance ? r("variance") : "", r("label"), i.optional ? "?" : "", ": ", r("elementType")];
}
var cM = /* @__PURE__ */ new WeakSet();
function It(t, e, r = "typeAnnotation") {
  let { node: { [r]: i } } = t;
  if (!i)
    return "";
  let n = !1;
  if (i.type === "TSTypeAnnotation" || i.type === "TypeAnnotation") {
    let s = t.call(CS, r);
    (s === "=>" || s === ":" && se(i, de.Leading)) && (n = !0), cM.add(i);
  }
  return n ? [" ", e(r)] : e(r);
}
var CS = (t) => t.match((e) => e.type === "TSTypeAnnotation", (e, r) => (r === "returnType" || r === "typeAnnotation") && (e.type === "TSFunctionType" || e.type === "TSConstructorType")) ? "=>" : t.match((e) => e.type === "TSTypeAnnotation", (e, r) => r === "typeAnnotation" && (e.type === "TSJSDocNullableType" || e.type === "TSJSDocNonNullableType" || e.type === "TSTypePredicate")) || t.match((e) => e.type === "TypeAnnotation", (e, r) => r === "typeAnnotation" && e.type === "Identifier", (e, r) => r === "id" && e.type === "DeclareFunction") || t.match((e) => e.type === "TypeAnnotation", (e, r) => r === "bound" && e.type === "TypeParameter" && e.usesExtendsBound) ? "" : ":";
function AS(t, e, r) {
  let i = CS(t);
  return i ? [i, " ", r("typeAnnotation")] : r("typeAnnotation");
}
function ES(t) {
  return [t("elementType"), "[]"];
}
function kS({ node: t }, e) {
  let r = t.type === "TSTypeQuery" ? "exprName" : "argument", i = t.type === "TSTypeQuery" ? "typeParameters" : "typeArguments";
  return ["typeof ", e(r), e(i)];
}
function TS(t, e) {
  let { node: r } = t;
  return [r.asserts ? "asserts " : "", e("parameterName"), r.typeAnnotation ? [" is ", It(t, e)] : ""];
}
function Ht(t) {
  let { node: e } = t;
  return !e.optional || e.type === "Identifier" && e === t.parent.key ? "" : Re(e) || at(e) && e.computed || e.type === "OptionalIndexedAccessType" ? "?." : "?";
}
function PS(t) {
  return t.node.definite || t.match(void 0, (e, r) => r === "id" && e.type === "VariableDeclarator" && e.definite) ? "!" : "";
}
var hM = /* @__PURE__ */ new Set(["DeclareClass", "DeclareFunction", "DeclareVariable", "DeclareExportDeclaration", "DeclareExportAllDeclaration", "DeclareOpaqueType", "DeclareTypeAlias", "DeclareEnum", "DeclareInterface"]);
function Xr(t) {
  let { node: e } = t;
  return e.declare || hM.has(e.type) && t.parent.type !== "DeclareExportDeclaration" ? "declare " : "";
}
var pM = /* @__PURE__ */ new Set(["TSAbstractMethodDefinition", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
function ep({ node: t }) {
  return t.abstract || pM.has(t.type) ? "abstract " : "";
}
function Es(t, e, r) {
  let i = t.node;
  return i.typeArguments ? r("typeArguments") : i.typeParameters ? r("typeParameters") : "";
}
function FS(t, e, r) {
  return ["::", r("callee")];
}
function vn(t, e, r) {
  return t.type === "EmptyStatement" ? ";" : t.type === "BlockStatement" || r ? [" ", e] : te([he, e]);
}
function $S(t, e) {
  return ["...", e("argument"), It(t, e)];
}
function _c(t) {
  return t.accessibility ? t.accessibility + " " : "";
}
function dM(t, e, r, i) {
  let { node: n } = t;
  return se(n, de.Dangling) ? Z([r, lt(t, e, { indent: !0 }), H, i]) : [r, i];
}
function Vg(t, e, r) {
  let { node: i } = t, n = [], s = i.type === "TupleExpression" ? "#[" : "[", a = "]", o = i.type === "TupleTypeAnnotation" && i.types ? "types" : i.type === "TSTupleType" || i.type === "TupleTypeAnnotation" ? "elementTypes" : "elements", u = i[o];
  if (u.length === 0)
    n.push(dM(t, e, s, a));
  else {
    let c = qe(!1, u, -1), h = (c == null ? void 0 : c.type) !== "RestElement", d = c === null, m = Symbol("array"), y = !e.__inJestEach && u.length > 1 && u.every((v, S, x) => {
      let w = v == null ? void 0 : v.type;
      if (!_t(v) && !oi(v))
        return !1;
      let k = x[S + 1];
      if (k && w !== k.type)
        return !1;
      let C = _t(v) ? "elements" : "properties";
      return v[C] && v[C].length > 1;
    }), O = BS(i, e), b = h ? d ? "," : Jn(e) ? O ? Ee(",", "", { groupId: m }) : Ee(",") : "" : "";
    n.push(Z([s, te([H, O ? mM(t, e, r, b) : [fM(t, e, o, r), b], lt(t, e)]), H, a], { shouldBreak: y, id: m }));
  }
  return n.push(Ht(t), It(t, r)), n;
}
function BS(t, e) {
  return _t(t) && t.elements.length > 1 && t.elements.every((r) => r && (jn(r) || yv(r) && !se(r.argument)) && !se(r, de.Trailing | de.Line, (i) => !Cr(e.originalText, ot(i), { backwards: !0 })));
}
function IS({ node: t }, { originalText: e }) {
  let r = (n) => Tg(e, Pg(e, n)), i = (n) => e[n] === "," ? n : i(r(n + 1));
  return Fg(e, i(We(t)));
}
function fM(t, e, r, i) {
  let n = [];
  return t.each(({ node: s, isLast: a }) => {
    n.push(s ? Z(i()) : ""), a || n.push([",", he, s && IS(t, e) ? H : ""]);
  }, r), n;
}
function mM(t, e, r, i) {
  let n = [];
  return t.each(({ isLast: s, next: a }) => {
    n.push([r(), s ? i : ","]), s || n.push(IS(t, e) ? [ee, ee] : se(a, de.Leading | de.Line) ? ee : he);
  }, "elements"), Qg(n);
}
var NS = new Proxy(() => {
}, { get: () => NS }), _S = NS;
function gM(t) {
  return t.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
}
var Pn = gM, Pu = /* @__PURE__ */ new WeakMap();
function Vl(t, e, r) {
  let { node: i } = t;
  if (i.computed)
    return ["[", r("key"), "]"];
  let { parent: n } = t, { key: s } = i;
  if (e.quoteProps === "consistent" && !Pu.has(n)) {
    let a = (n.properties || n.body || n.members).some((o) => !o.computed && o.key && lr(o.key) && !xO(o, e));
    Pu.set(n, a);
  }
  if ((s.type === "Identifier" || jn(s) && wv(Pn(Zr(s))) && String(s.value) === Pn(Zr(s)) && !(e.parser === "typescript" || e.parser === "babel-ts")) && (e.parser === "json" || e.parser === "jsonc" || e.quoteProps === "consistent" && Pu.get(n))) {
    let a = ol(JSON.stringify(s.type === "Identifier" ? s.name : s.value.toString()), e);
    return t.call((o) => ai(o, a, e), "key");
  }
  return xO(i, e) && (e.quoteProps === "as-needed" || e.quoteProps === "consistent" && !Pu.get(n)) ? t.call((a) => ai(a, /^\d/.test(s.value) ? Pn(s.value) : s.value, e), "key") : r("key");
}
function NO(t, e, r) {
  let { node: i } = t;
  return i.shorthand ? r("value") : ql(t, e, r, Vl(t, e, r), ":", "value");
}
var yM = ({ node: t, key: e, parent: r }) => e === "value" && t.type === "FunctionExpression" && (r.type === "ObjectMethod" || r.type === "ClassMethod" || r.type === "ClassPrivateMethod" || r.type === "MethodDefinition" || r.type === "TSAbstractMethodDefinition" || r.type === "TSDeclareMethod" || r.type === "Property" && zh(r));
function QS(t, e, r, i) {
  if (yM(t))
    return Yg(t, r, e);
  let { node: n } = t, s = !1;
  if ((n.type === "FunctionDeclaration" || n.type === "FunctionExpression") && i != null && i.expandLastArg) {
    let { parent: h } = t;
    Re(h) && (Wr(h).length > 1 || Vt(n).every((d) => d.type === "Identifier" && !d.typeAnnotation)) && (s = !0);
  }
  let a = [Xr(t), n.async ? "async " : "", `function${n.generator ? "*" : ""} `, n.id ? e("id") : ""], o = Xl(t, e, r, s), u = Ug(t, e), c = Kh(n, u);
  return a.push(Es(t, r, e), Z([c ? Z(o) : o, u]), n.body ? " " : "", e("body")), r.semi && (n.declare || !n.body) && a.push(";"), a;
}
function gf(t, e, r) {
  let { node: i } = t, { kind: n } = i, s = i.value || i, a = [];
  return !n || n === "init" || n === "method" || n === "constructor" ? s.async && a.push("async ") : (_S.ok(n === "get" || n === "set"), a.push(n, " ")), s.generator && a.push("*"), a.push(Vl(t, e, r), i.optional || i.key.optional ? "?" : "", i === s ? Yg(t, e, r) : r("value")), a;
}
function Yg(t, e, r) {
  let { node: i } = t, n = Xl(t, r, e), s = Ug(t, r), a = nM(i), o = Kh(i, s), u = [Es(t, e, r), Z([a ? Z(n, { shouldBreak: !0 }) : o ? Z(n) : n, s])];
  return i.body ? u.push(" ", r("body")) : u.push(e.semi ? ";" : ""), u;
}
function OM(t) {
  let e = Vt(t);
  return e.length === 1 && !t.typeParameters && !se(t, de.Dangling) && e[0].type === "Identifier" && !e[0].typeAnnotation && !se(e[0]) && !e[0].optional && !t.predicate && !t.returnType;
}
function MS(t, e) {
  if (e.arrowParens === "always")
    return !1;
  if (e.arrowParens === "avoid") {
    let { node: r } = t;
    return OM(r);
  }
  return !1;
}
function Ug(t, e) {
  let { node: r } = t, i = [It(t, e, "returnType")];
  return r.predicate && i.push(e("predicate")), i;
}
function LS(t, e, r) {
  let { node: i } = t, n = e.semi ? ";" : "", s = [];
  if (i.argument) {
    let u = r("argument");
    DM(e, i.argument) ? u = ["(", te([ee, u]), ee, ")"] : (Ji(i.argument) || i.argument.type === "SequenceExpression" || e.experimentalTernaries && i.argument.type === "ConditionalExpression" && (i.argument.consequent.type === "ConditionalExpression" || i.argument.alternate.type === "ConditionalExpression")) && (u = Z([Ee("("), te([H, u]), H, Ee(")")])), s.push(" ", u);
  }
  let a = se(i, de.Dangling), o = n && a && se(i, de.Last | de.Line);
  return o && s.push(n), a && s.push(" ", lt(t, e)), o || s.push(n), s;
}
function xM(t, e, r) {
  return ["return", LS(t, e, r)];
}
function bM(t, e, r) {
  return ["throw", LS(t, e, r)];
}
function DM(t, e) {
  if (Ss(t.originalText, e) || se(e, de.Leading, (r) => Wn(t.originalText, ot(r), We(r))) && !vt(e))
    return !0;
  if ($g(e)) {
    let r = e, i;
    for (; i = BQ(r); )
      if (r = i, Ss(t.originalText, r))
        return !0;
  }
  return !1;
}
var Gp = /* @__PURE__ */ new WeakMap();
function RS(t) {
  return Gp.has(t) || Gp.set(t, t.type === "ConditionalExpression" && !zt(t, (e) => e.type === "ObjectExpression")), Gp.get(t);
}
var jS = (t) => t.type === "SequenceExpression";
function vM(t, e, r, i = {}) {
  let n = [], s, a = [], o = !1, u = !i.expandLastArg && t.node.body.type === "ArrowFunctionExpression", c;
  (function v() {
    let { node: S } = t, x = SM(t, e, r, i);
    if (n.length === 0)
      n.push(x);
    else {
      let { leading: w, trailing: k } = rS(t, e);
      n.push([w, x]), a.unshift(k);
    }
    u && (o || (o = S.returnType && Vt(S).length > 0 || S.typeParameters || Vt(S).some((w) => w.type !== "Identifier"))), !u || S.body.type !== "ArrowFunctionExpression" ? (s = r("body", i), c = S.body) : t.call(v, "body");
  })();
  let h = !Ss(e.originalText, c) && (jS(c) || wM(c, s, e) || !o && RS(c)), d = t.key === "callee" && Ia(t.parent), m = Symbol("arrow-chain"), y = CM(t, i, { signatureDocs: n, shouldBreak: o }), O, b = !1;
  return u && (d || i.assignmentLayout) && (b = !0, O = i.assignmentLayout === "chain-tail-arrow-chain" || d && !h), s = AM(t, e, i, { bodyDoc: s, bodyComments: a, functionBody: c, shouldPutBodyOnSameLine: h }), Z([Z(b ? te([H, y]) : y, { shouldBreak: O, id: m }), " =>", u ? Jh(s, { groupId: m }) : Z(s), u && d ? Ee(H, "", { groupId: m }) : ""]);
}
function SM(t, e, r, i) {
  let { node: n } = t, s = [];
  if (n.async && s.push("async "), MS(t, e))
    s.push(r(["params", 0]));
  else {
    let o = i.expandLastArg || i.expandFirstArg, u = Ug(t, r);
    if (o) {
      if (Gt(u))
        throw new Nc();
      u = Z(af(u));
    }
    s.push(Z([Xl(t, r, e, o, !0), u]));
  }
  let a = lt(t, e, { filter(o) {
    let u = Wl(e.originalText, We(o));
    return u !== !1 && e.originalText.slice(u, u + 2) === "=>";
  } });
  return a && s.push(" ", a), s;
}
function wM(t, e, r) {
  var i, n;
  return _t(t) || oi(t) || t.type === "ArrowFunctionExpression" || t.type === "DoExpression" || t.type === "BlockStatement" || vt(t) || ((i = e.label) == null ? void 0 : i.hug) !== !1 && (((n = e.label) == null ? void 0 : n.embed) || Cv(t, r.originalText));
}
function CM(t, e, { signatureDocs: r, shouldBreak: i }) {
  if (r.length === 1)
    return r[0];
  let { parent: n, key: s } = t;
  return s !== "callee" && Ia(n) || Ji(n) ? Z([r[0], " =>", te([he, Ne([" =>", he], r.slice(1))])], { shouldBreak: i }) : s === "callee" && Ia(n) || e.assignmentLayout ? Z(Ne([" =>", he], r), { shouldBreak: i }) : Z(te(Ne([" =>", he], r)), { shouldBreak: i });
}
function AM(t, e, r, { bodyDoc: i, bodyComments: n, functionBody: s, shouldPutBodyOnSameLine: a }) {
  let { node: o, parent: u } = t, c = r.expandLastArg && Jn(e, "all") ? Ee(",") : "", h = (r.expandLastArg || u.type === "JSXExpressionContainer") && !se(o) ? H : "";
  return a && RS(s) ? [" ", Z([Ee("", "("), te([H, i]), Ee("", ")"), c, h]), n] : (jS(s) && (i = Z(["(", te([H, i]), H, ")"])), a ? [" ", i, n] : [te([he, i, n]), c, h]);
}
var EM = (t, e, r) => {
  if (!(t && e == null)) {
    if (e.findLast)
      return e.findLast(r);
    for (let i = e.length - 1; i >= 0; i--) {
      let n = e[i];
      if (r(n, i, e))
        return n;
    }
  }
}, kM = EM;
function yf(t, e, r, i) {
  let { node: n } = t, s = [], a = kM(!1, n[i], (o) => o.type !== "EmptyStatement");
  return t.each(({ node: o }) => {
    o.type !== "EmptyStatement" && (s.push(r()), o !== a && (s.push(ee), Kn(o, e) && s.push(ee)));
  }, i), s;
}
function ZS(t, e, r) {
  let { node: i } = t, n = [];
  i.type === "StaticBlock" && n.push("static "), n.push("{");
  let s = WS(t, e, r);
  if (s)
    n.push(te([ee, s]), ee);
  else {
    let { parent: a } = t, o = t.grandparent;
    a.type === "ArrowFunctionExpression" || a.type === "FunctionExpression" || a.type === "FunctionDeclaration" || a.type === "ObjectMethod" || a.type === "ClassMethod" || a.type === "ClassPrivateMethod" || a.type === "ForStatement" || a.type === "WhileStatement" || a.type === "DoWhileStatement" || a.type === "DoExpression" || a.type === "CatchClause" && !o.finalizer || a.type === "TSModuleDeclaration" || a.type === "TSDeclareFunction" || i.type === "StaticBlock" || n.push(ee);
  }
  return n.push("}"), n;
}
function WS(t, e, r) {
  var i;
  let { node: n } = t, s = Ze(n.directives), a = n.body.some((c) => c.type !== "EmptyStatement"), o = se(n, de.Dangling);
  if (!s && !a && !o)
    return "";
  let u = [];
  return s && (u.push(yf(t, e, r, "directives")), (a || o) && (u.push(ee), Kn(qe(!1, n.directives, -1), e) && u.push(ee))), a && u.push(yf(t, e, r, "body")), o && u.push(lt(t, e)), n.type === "Program" && ((i = t.parent) == null ? void 0 : i.type) !== "ModuleExpression" && u.push(ee), u;
}
function TM(t) {
  let e = /* @__PURE__ */ new WeakMap();
  return function(r) {
    return e.has(r) || e.set(r, Symbol(t)), e.get(r);
  };
}
var qS = TM;
function PM(t) {
  switch (t) {
    case null:
      return "";
    case "PlusOptional":
      return "+?";
    case "MinusOptional":
      return "-?";
    case "Optional":
      return "?";
  }
}
function FM(t, e, r) {
  let { node: i } = t;
  return Z([i.variance ? r("variance") : "", "[", te([r("keyTparam"), " in ", r("sourceType")]), "]", PM(i.optional), ": ", r("propType")]);
}
function XS(t, e) {
  return t === "+" || t === "-" ? t + e : e;
}
function $M(t, e, r) {
  let { node: i } = t, n = Wn(e.originalText, ot(i), ot(i.typeParameter));
  return Z(["{", te([e.bracketSpacing ? he : H, Z([r("typeParameter"), i.optional ? XS(i.optional, "?") : "", i.typeAnnotation ? ": " : "", r("typeAnnotation")]), e.semi ? Ee(";") : ""]), lt(t, e), e.bracketSpacing ? he : H, "}"], { shouldBreak: n });
}
var zg = qS("typeParameters");
function BM(t, e, r) {
  let { node: i } = t;
  return Vt(i).length === 1 && i.type.startsWith("TS") && !i[r][0].constraint && t.parent.type === "ArrowFunctionExpression" && !(e.filepath && /\.ts$/.test(e.filepath));
}
function zo(t, e, r, i) {
  let { node: n } = t;
  if (!n[i])
    return "";
  if (!Array.isArray(n[i]))
    return r(i);
  let s = t.getNode(2), a = s && Gh(s), o = t.match((c) => !(c[i].length === 1 && Zn(c[i][0])), void 0, (c, h) => h === "typeAnnotation", (c) => c.type === "Identifier", dS);
  if (n[i].length === 0 || !o && (a || n[i].length === 1 && (n[i][0].type === "NullableTypeAnnotation" || gS(n[i][0]))))
    return ["<", Ne(", ", t.map(r, i)), IM(t, e), ">"];
  let u = n.type === "TSTypeParameterInstantiation" ? "" : BM(t, e, i) ? "," : Jn(e) ? Ee(",") : "";
  return Z(["<", te([H, Ne([",", he], t.map(r, i))]), u, H, ">"], { id: zg(n) });
}
function IM(t, e) {
  let { node: r } = t;
  if (!se(r, de.Dangling))
    return "";
  let i = !se(r, de.Line), n = lt(t, e, { indent: !i });
  return i ? n : [n, ee];
}
function VS(t, e, r) {
  let { node: i, parent: n } = t, s = [i.type === "TSTypeParameter" && i.const ? "const " : ""], a = i.type === "TSTypeParameter" ? r("name") : i.name;
  if (n.type === "TSMappedType")
    return n.readonly && s.push(XS(n.readonly, "readonly"), " "), s.push("[", a), i.constraint && s.push(" in ", r("constraint")), n.nameType && s.push(" as ", t.callParent(() => r("nameType"))), s.push("]"), s;
  if (i.variance && s.push(r("variance")), i.in && s.push("in "), i.out && s.push("out "), s.push(a), i.bound && (i.usesExtendsBound && s.push(" extends "), s.push(It(t, r, "bound"))), i.constraint) {
    let o = Symbol("constraint");
    s.push(" extends", Z(te(he), { id: o }), Ki, Jh(r("constraint"), { groupId: o }));
  }
  return i.default && s.push(" = ", r("default")), Z(s);
}
var YS = Ue(["ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
function US(t, e, r) {
  let { node: i } = t, n = [Xr(t), ep(t), "class"], s = se(i.id, de.Trailing) || se(i.typeParameters, de.Trailing) || se(i.superClass) || Ze(i.extends) || Ze(i.mixins) || Ze(i.implements), a = [], o = [];
  if (i.id && a.push(" ", r("id")), a.push(r("typeParameters")), i.superClass) {
    let u = [_M(t, e, r), r("superTypeParameters")], c = t.call((h) => ["extends ", ai(h, u, e)], "superClass");
    s ? o.push(he, Z(c)) : o.push(" ", c);
  } else
    o.push(Hp(t, e, r, "extends"));
  if (o.push(Hp(t, e, r, "mixins"), Hp(t, e, r, "implements")), s) {
    let u;
    HS(i) ? u = [...a, te(o)] : u = te([...a, o]), n.push(Z(u, { id: zS(i) }));
  } else
    n.push(...a, ...o);
  return n.push(" ", r("body")), n;
}
var zS = qS("heritageGroup");
function GS(t) {
  return Ee(ee, "", { groupId: zS(t) });
}
function NM(t) {
  return ["extends", "mixins", "implements"].reduce((e, r) => e + (Array.isArray(t[r]) ? t[r].length : 0), t.superClass ? 1 : 0) > 1;
}
function HS(t) {
  return t.typeParameters && !se(t.typeParameters, de.Trailing | de.Line) && !NM(t);
}
function Hp(t, e, r, i) {
  let { node: n } = t;
  if (!Ze(n[i]))
    return "";
  let s = lt(t, e, { marker: i });
  return [HS(n) ? Ee(" ", he, { groupId: zg(n.typeParameters) }) : he, s, s && ee, i, Z(te([he, Ne([",", he], t.map(r, i))]))];
}
function _M(t, e, r) {
  let i = r("superClass"), { parent: n } = t;
  return n.type === "AssignmentExpression" ? Z(Ee(["(", te([H, i]), H, ")"], i)) : i;
}
function JS(t, e, r) {
  let { node: i } = t, n = [];
  return Ze(i.decorators) && n.push(sS(t, e, r)), n.push(_c(i)), i.static && n.push("static "), n.push(ep(t)), i.override && n.push("override "), n.push(gf(t, e, r)), n;
}
function KS(t, e, r) {
  let { node: i } = t, n = [], s = e.semi ? ";" : "";
  Ze(i.decorators) && n.push(sS(t, e, r)), n.push(_c(i), Xr(t)), i.static && n.push("static "), n.push(ep(t)), i.override && n.push("override "), i.readonly && n.push("readonly "), i.variance && n.push(r("variance")), (i.type === "ClassAccessorProperty" || i.type === "AccessorProperty" || i.type === "TSAbstractAccessorProperty") && n.push("accessor "), n.push(Vl(t, e, r), Ht(t), PS(t), It(t, r));
  let a = i.type === "TSAbstractPropertyDefinition" || i.type === "TSAbstractAccessorProperty";
  return [ql(t, e, r, n, " =", a ? void 0 : "value"), s];
}
function QM(t, e, r) {
  let { node: i } = t, n = [];
  return t.each(({ node: s, next: a, isLast: o }) => {
    n.push(r()), !e.semi && YS(s) && MM(s, a) && n.push(";"), o || (n.push(ee), Kn(s, e) && n.push(ee));
  }, "body"), se(i, de.Dangling) && n.push(lt(t, e)), [Ze(i.body) ? GS(t.parent) : "", "{", n.length > 0 ? [te([ee, n]), ee] : "", "}"];
}
function MM(t, e) {
  var r;
  let { type: i, name: n } = t.key;
  if (!t.computed && i === "Identifier" && (n === "static" || n === "get" || n === "set") && !t.value && !t.typeAnnotation)
    return !0;
  if (!e || e.static || e.accessibility)
    return !1;
  if (!e.computed) {
    let s = (r = e.key) == null ? void 0 : r.name;
    if (s === "in" || s === "instanceof")
      return !0;
  }
  if (YS(e) && e.variance && !e.static && !e.declare)
    return !0;
  switch (e.type) {
    case "ClassProperty":
    case "PropertyDefinition":
    case "TSAbstractPropertyDefinition":
      return e.computed;
    case "MethodDefinition":
    case "TSAbstractMethodDefinition":
    case "ClassMethod":
    case "ClassPrivateMethod": {
      if ((e.value ? e.value.async : e.async) || e.kind === "get" || e.kind === "set")
        return !1;
      let s = e.value ? e.value.generator : e.generator;
      return !!(e.computed || s);
    }
    case "TSIndexSignature":
      return !0;
  }
  return !1;
}
function LM(t, e) {
  if (e.semi || tw(t, e) || iw(t, e))
    return !1;
  let { node: r, key: i, parent: n } = t;
  return !!(r.type === "ExpressionStatement" && (i === "body" && (n.type === "Program" || n.type === "BlockStatement" || n.type === "StaticBlock" || n.type === "TSModuleBlock") || i === "consequent" && n.type === "SwitchCase") && t.call(() => ew(t, e), "expression"));
}
function ew(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "ParenthesizedExpression":
    case "TypeCastExpression":
    case "ArrayExpression":
    case "ArrayPattern":
    case "TemplateLiteral":
    case "TemplateElement":
    case "RegExpLiteral":
      return !0;
    case "ArrowFunctionExpression":
      if (!MS(t, e))
        return !0;
      break;
    case "UnaryExpression": {
      let { prefix: i, operator: n } = r;
      if (i && (n === "+" || n === "-"))
        return !0;
      break;
    }
    case "BindExpression":
      if (!r.object)
        return !0;
      break;
    case "Literal":
      if (r.regex)
        return !0;
      break;
    default:
      if (vt(r))
        return !0;
  }
  return Vs(t, e) ? !0 : $g(r) ? t.call(() => ew(t, e), ...gv(r)) : !1;
}
function tw({ node: t, parent: e }, r) {
  return (r.parentParser === "markdown" || r.parentParser === "mdx") && t.type === "ExpressionStatement" && vt(t.expression) && e.type === "Program" && e.body.length === 1;
}
function rw(t) {
  switch (t.type) {
    case "MemberExpression":
      switch (t.property.type) {
        case "Identifier":
        case "NumericLiteral":
        case "StringLiteral":
          return rw(t.object);
      }
      return !1;
    case "Identifier":
      return !0;
    default:
      return !1;
  }
}
function iw({ node: t, parent: e }, r) {
  return (r.parser === "__vue_event_binding" || r.parser === "__vue_ts_event_binding") && t.type === "ExpressionStatement" && e.type === "Program" && e.body.length === 1;
}
function RM(t, e, r) {
  let i = [r("expression")];
  return iw(t, e) ? rw(t.node.expression) && i.push(";") : tw(t, e) || e.semi && i.push(";"), i;
}
function jM(t, e, r) {
  if (e.__isVueBindings || e.__isVueForBindingLeft) {
    let i = t.map(r, "program", "body", 0, "params");
    if (i.length === 1)
      return i[0];
    let n = Ne([",", he], i);
    return e.__isVueForBindingLeft ? ["(", te([H, Z(n)]), H, ")"] : n;
  }
  if (e.__isEmbeddedTypescriptGenericParameters) {
    let i = t.map(r, "program", "body", 0, "typeParameters", "params");
    return Ne([",", he], i);
  }
}
function ZM(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "RegExpLiteral":
      return _O(r);
    case "BigIntLiteral":
      return Of(r.extra.raw);
    case "NumericLiteral":
      return Pn(r.extra.raw);
    case "StringLiteral":
      return As(ol(r.extra.raw, e));
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return String(r.value);
    case "DecimalLiteral":
      return Pn(r.value) + "m";
    case "DirectiveLiteral":
      return QO(r.extra.raw, e);
    case "Literal": {
      if (r.regex)
        return _O(r.regex);
      if (r.bigint)
        return Of(r.raw);
      if (r.decimal)
        return Pn(r.decimal) + "m";
      let { value: i } = r;
      return typeof i == "number" ? Pn(r.raw) : typeof i == "string" ? WM(t) ? QO(r.raw, e) : As(ol(r.raw, e)) : String(i);
    }
  }
}
function WM(t) {
  if (t.key !== "expression")
    return;
  let { parent: e } = t;
  return e.type === "ExpressionStatement" && e.directive;
}
function Of(t) {
  return t.toLowerCase();
}
function _O({ pattern: t, flags: e }) {
  return e = [...e].sort().join(""), `/${t}/${e}`;
}
function QO(t, e) {
  let r = t.slice(1, -1);
  if (r.includes('"') || r.includes("'"))
    return t;
  let i = e.singleQuote ? "'" : '"';
  return i + r + i;
}
function qM(t, e, r) {
  let i = t.originalText.slice(e, r);
  for (let n of t[Symbol.for("comments")]) {
    let s = ot(n);
    if (s > r)
      break;
    let a = We(n);
    if (a < e)
      continue;
    let o = a - s;
    i = i.slice(0, s - e) + " ".repeat(o) + i.slice(a - e);
  }
  return i;
}
var Gg = qM;
function XM(t, e, r) {
  let { node: i } = t;
  return ["import", i.module ? " module" : "", i.phase ? ` ${i.phase}` : "", aw(i), lw(t, e, r), ow(t, e, r), cw(t, e, r), e.semi ? ";" : ""];
}
var nw = (t) => t.type === "ExportDefaultDeclaration" || t.type === "DeclareExportDeclaration" && t.default;
function sw(t, e, r) {
  let { node: i } = t, n = [T6(t, e, r), Xr(t), "export", nw(i) ? " default" : ""], { declaration: s, exported: a } = i;
  return se(i, de.Dangling) && (n.push(" ", lt(t, e)), Av(i) && n.push(ee)), s ? n.push(" ", r("declaration")) : (n.push(UM(i)), i.type === "ExportAllDeclaration" || i.type === "DeclareExportAllDeclaration" ? (n.push(" *"), a && n.push(" as ", r("exported"))) : n.push(lw(t, e, r)), n.push(ow(t, e, r), cw(t, e, r))), n.push(YM(i, e)), n;
}
var VM = Ue(["ClassDeclaration", "FunctionDeclaration", "TSInterfaceDeclaration", "DeclareClass", "DeclareFunction", "TSDeclareFunction", "EnumDeclaration"]);
function YM(t, e) {
  return e.semi && (!t.declaration || nw(t) && !VM(t.declaration)) ? ";" : "";
}
function Hg(t, e = !0) {
  return t && t !== "value" ? `${e ? " " : ""}${t}${e ? "" : " "}` : "";
}
function aw(t, e) {
  return Hg(t.importKind, e);
}
function UM(t) {
  return Hg(t.exportKind);
}
function ow(t, e, r) {
  let { node: i } = t;
  if (!i.source)
    return "";
  let n = [];
  return uw(i, e) && n.push(" from"), n.push(" ", r("source")), n;
}
function lw(t, e, r) {
  let { node: i } = t;
  if (!uw(i, e))
    return "";
  let n = [" "];
  if (Ze(i.specifiers)) {
    let s = [], a = [];
    t.each(() => {
      let o = t.node.type;
      if (o === "ExportNamespaceSpecifier" || o === "ExportDefaultSpecifier" || o === "ImportNamespaceSpecifier" || o === "ImportDefaultSpecifier")
        s.push(r());
      else if (o === "ExportSpecifier" || o === "ImportSpecifier")
        a.push(r());
      else
        throw new eo(i, "specifier");
    }, "specifiers"), n.push(Ne(", ", s)), a.length > 0 && (s.length > 0 && n.push(", "), a.length > 1 || s.length > 0 || i.specifiers.some((o) => se(o)) ? n.push(Z(["{", te([e.bracketSpacing ? he : H, Ne([",", he], a)]), Ee(Jn(e) ? "," : ""), e.bracketSpacing ? he : H, "}"])) : n.push(["{", e.bracketSpacing ? " " : "", ...a, e.bracketSpacing ? " " : "", "}"]));
  } else
    n.push("{}");
  return n;
}
function uw(t, e) {
  return t.type !== "ImportDeclaration" || Ze(t.specifiers) || t.importKind === "type" ? !0 : Gg(e, ot(t), ot(t.source)).trimEnd().endsWith("from");
}
function zM(t, e) {
  var r, i;
  if ((r = t.extra) != null && r.deprecatedAssertSyntax)
    return "assert";
  let n = Gg(e, We(t.source), (i = t.attributes) != null && i[0] ? ot(t.attributes[0]) : We(t)).trimStart();
  return n.startsWith("assert") ? "assert" : n.startsWith("with") || Ze(t.attributes) ? "with" : void 0;
}
function cw(t, e, r) {
  let { node: i } = t;
  if (!i.source)
    return "";
  let n = zM(i, e);
  if (!n)
    return "";
  let s = [` ${n} {`];
  return Ze(i.attributes) && (e.bracketSpacing && s.push(" "), s.push(Ne(", ", t.map(r, "attributes"))), e.bracketSpacing && s.push(" ")), s.push("}"), s;
}
function GM(t, e, r) {
  let { node: i } = t, { type: n } = i, s = n.startsWith("Import"), a = s ? "imported" : "local", o = s ? "local" : "exported", u = i[a], c = i[o], h = "", d = "";
  return n === "ExportNamespaceSpecifier" || n === "ImportNamespaceSpecifier" ? h = "*" : u && (h = r(a)), c && !HM(i) && (d = r(o)), [Hg(n === "ImportSpecifier" ? i.importKind : i.exportKind, !1), h, h && d ? " as " : "", d];
}
function HM(t) {
  if (t.type !== "ImportSpecifier" && t.type !== "ExportSpecifier")
    return !1;
  let { local: e, [t.type === "ImportSpecifier" ? "imported" : "exported"]: r } = t;
  if (e.type !== r.type || !bQ(e, r))
    return !1;
  if (lr(e))
    return e.value === r.value && Zr(e) === Zr(r);
  switch (e.type) {
    case "Identifier":
      return e.name === r.name;
    default:
      return !1;
  }
}
function tp(t, e, r) {
  var i;
  let n = e.semi ? ";" : "", { node: s } = t, a = s.type === "ObjectTypeAnnotation", o = s.type === "TSEnumDeclaration" || s.type === "EnumBooleanBody" || s.type === "EnumNumberBody" || s.type === "EnumStringBody" || s.type === "EnumSymbolBody", u = [s.type === "TSTypeLiteral" || o ? "members" : s.type === "TSInterfaceBody" ? "body" : "properties"];
  a && u.push("indexers", "callProperties", "internalSlots");
  let c = u.flatMap((E) => t.map(({ node: P }) => ({ node: P, printed: r(), loc: ot(P) }), E));
  u.length > 1 && c.sort((E, P) => E.loc - P.loc);
  let { parent: h, key: d } = t, m = a && d === "body" && (h.type === "InterfaceDeclaration" || h.type === "DeclareInterface" || h.type === "DeclareClass"), y = s.type === "TSInterfaceBody" || o || m || s.type === "ObjectPattern" && h.type !== "FunctionDeclaration" && h.type !== "FunctionExpression" && h.type !== "ArrowFunctionExpression" && h.type !== "ObjectMethod" && h.type !== "ClassMethod" && h.type !== "ClassPrivateMethod" && h.type !== "AssignmentPattern" && h.type !== "CatchClause" && s.properties.some((E) => E.value && (E.value.type === "ObjectPattern" || E.value.type === "ArrayPattern")) || s.type !== "ObjectPattern" && c.length > 0 && Wn(e.originalText, ot(s), c[0].loc), O = m ? ";" : s.type === "TSInterfaceBody" || s.type === "TSTypeLiteral" ? Ee(n, ";") : ",", b = s.type === "RecordExpression" ? "#{" : s.exact ? "{|" : "{", v = s.exact ? "|}" : "}", S = [], x = c.map((E) => {
    let P = [...S, Z(E.printed)];
    return S = [O, he], (E.node.type === "TSPropertySignature" || E.node.type === "TSMethodSignature" || E.node.type === "TSConstructSignatureDeclaration" || E.node.type === "TSCallSignatureDeclaration") && se(E.node, de.PrettierIgnore) && S.shift(), Kn(E.node, e) && S.push(ee), P;
  });
  if (s.inexact || s.hasUnknownMembers) {
    let E;
    if (se(s, de.Dangling)) {
      let P = se(s, de.Line);
      E = [lt(t, e), P || Cr(e.originalText, We(qe(!1, xa(s), -1))) ? ee : he, "..."];
    } else
      E = ["..."];
    x.push([...S, ...E]);
  }
  let w = (i = qe(!1, c, -1)) == null ? void 0 : i.node, k = !(s.inexact || s.hasUnknownMembers || w && (w.type === "RestElement" || (w.type === "TSPropertySignature" || w.type === "TSCallSignatureDeclaration" || w.type === "TSMethodSignature" || w.type === "TSConstructSignatureDeclaration") && se(w, de.PrettierIgnore))), C;
  if (x.length === 0) {
    if (!se(s, de.Dangling))
      return [b, v, It(t, r)];
    C = Z([b, lt(t, e, { indent: !0 }), H, v, Ht(t), It(t, r)]);
  } else
    C = [m && Ze(s.properties) ? GS(h) : "", b, te([e.bracketSpacing ? he : H, ...x]), Ee(k && (O !== "," || Jn(e)) ? O : ""), e.bracketSpacing ? he : H, v, Ht(t), It(t, r)];
  return t.match((E) => E.type === "ObjectPattern" && !Ze(E.decorators), Jp) || Zn(s) && (t.match(void 0, (E, P) => P === "typeAnnotation", (E, P) => P === "typeAnnotation", Jp) || t.match(void 0, (E, P) => E.type === "FunctionTypeParam" && P === "typeAnnotation", Jp)) || !y && t.match((E) => E.type === "ObjectPattern", (E) => E.type === "AssignmentExpression" || E.type === "VariableDeclarator") ? C : Z(C, { shouldBreak: y });
}
function Jp(t, e) {
  return (e === "params" || e === "parameters" || e === "this" || e === "rest") && mS(t);
}
function JM(t) {
  let e = [t];
  for (let r = 0; r < e.length; r++) {
    let i = e[r];
    for (let n of ["test", "consequent", "alternate"]) {
      let s = i[n];
      if (vt(s))
        return !0;
      s.type === "ConditionalExpression" && e.push(s);
    }
  }
  return !1;
}
function KM(t, e, r) {
  let { node: i } = t, n = i.type === "ConditionalExpression", s = n ? "alternate" : "falseType", { parent: a } = t, o = n ? r("test") : [r("checkType"), " ", "extends", " ", r("extendsType")];
  return a.type === i.type && a[s] === i ? _i(2, o) : o;
}
var eL = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
function tL(t) {
  let { node: e } = t;
  if (e.type !== "ConditionalExpression")
    return !1;
  let r, i = e;
  for (let n = 0; !r; n++) {
    let s = t.getParentNode(n);
    if (s.type === "ChainExpression" && s.expression === i || Re(s) && s.callee === i || at(s) && s.object === i || s.type === "TSNonNullExpression" && s.expression === i) {
      i = s;
      continue;
    }
    s.type === "NewExpression" && s.callee === i || Ci(s) && s.expression === i ? (r = t.getParentNode(n + 1), i = s) : r = s;
  }
  return i === e ? !1 : r[eL.get(r.type)] === i;
}
function rL(t, e, r) {
  let { node: i } = t, n = i.type === "ConditionalExpression", s = n ? "consequent" : "trueType", a = n ? "alternate" : "falseType", o = n ? ["test"] : ["checkType", "extendsType"], u = i[s], c = i[a], h = [], d = !1, { parent: m } = t, y = m.type === i.type && o.some((B) => m[B] === i), O = m.type === i.type && !y, b, v, S = 0;
  do
    v = b || i, b = t.getParentNode(S), S++;
  while (b && b.type === i.type && o.every((B) => b[B] !== v));
  let x = b || m, w = v;
  if (n && (vt(i[o[0]]) || vt(u) || vt(c) || JM(w))) {
    d = !0, O = !0;
    let B = (j) => [Ee("("), te([H, j]), H, Ee(")")], Q = (j) => j.type === "NullLiteral" || j.type === "Literal" && j.value === null || j.type === "Identifier" && j.name === "undefined";
    h.push(" ? ", Q(u) ? r(s) : B(r(s)), " : ", c.type === i.type || Q(c) ? r(a) : B(r(a)));
  } else {
    let B = (j) => e.useTabs ? te(r(j)) : _i(2, r(j)), Q = [he, "? ", u.type === i.type ? Ee("", "(") : "", B(s), u.type === i.type ? Ee("", ")") : "", he, ": ", B(a)];
    h.push(m.type !== i.type || m[a] === i || y ? Q : e.useTabs ? Bv(te(Q)) : _i(Math.max(0, e.tabWidth - 2), Q));
  }
  let k = [s, a, ...o].some((B) => se(i[B], (Q) => Vr(Q) && Wn(e.originalText, ot(Q), We(Q)))), C = (B) => m === x ? Z(B, { shouldBreak: k }) : k ? [B, Qi] : B, E = !d && (at(m) || m.type === "NGPipeExpression" && m.left === i) && !m.computed, P = tL(t), I = C([KM(t, e, r), O ? h : te(h), n && E && !P ? H : ""]);
  return y || P ? Z([te([H, I]), H]) : I;
}
function iL(t, e) {
  return (at(e) || e.type === "NGPipeExpression" && e.left === t) && !e.computed;
}
function nL(t, e, r, i) {
  return [...t.map((n) => xa(n)), xa(e), xa(r)].flat().some((n) => Vr(n) && Wn(i.originalText, ot(n), We(n)));
}
var sL = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
function aL(t) {
  let { node: e } = t;
  if (e.type !== "ConditionalExpression")
    return !1;
  let r, i = e;
  for (let n = 0; !r; n++) {
    let s = t.getParentNode(n);
    if (s.type === "ChainExpression" && s.expression === i || Re(s) && s.callee === i || at(s) && s.object === i || s.type === "TSNonNullExpression" && s.expression === i) {
      i = s;
      continue;
    }
    s.type === "NewExpression" && s.callee === i || Ci(s) && s.expression === i ? (r = t.getParentNode(n + 1), i = s) : r = s;
  }
  return i === e ? !1 : r[sL.get(r.type)] === i;
}
var Kp = (t) => [Ee("("), te([H, t]), H, Ee(")")];
function Jg(t, e, r, i) {
  if (!e.experimentalTernaries)
    return rL(t, e, r);
  let { node: n } = t, s = n.type === "ConditionalExpression", a = n.type === "TSConditionalType" || n.type === "ConditionalTypeAnnotation", o = s ? "consequent" : "trueType", u = s ? "alternate" : "falseType", c = s ? ["test"] : ["checkType", "extendsType"], h = n[o], d = n[u], m = c.map((Te) => n[Te]), { parent: y } = t, O = y.type === n.type, b = O && c.some((Te) => y[Te] === n), v = O && y[u] === n, S = h.type === n.type, x = d.type === n.type, w = x || v, k = e.tabWidth > 2 || e.useTabs, C, E, P = 0;
  do
    E = C || n, C = t.getParentNode(P), P++;
  while (C && C.type === n.type && c.every((Te) => C[Te] !== E));
  let I = C || y, B = i && i.assignmentLayout && i.assignmentLayout !== "break-after-operator" && (y.type === "AssignmentExpression" || y.type === "VariableDeclarator" || y.type === "ClassProperty" || y.type === "PropertyDefinition" || y.type === "ClassPrivateProperty" || y.type === "ObjectProperty" || y.type === "Property"), Q = (y.type === "ReturnStatement" || y.type === "ThrowStatement") && !(S || x), j = s && I.type === "JSXExpressionContainer" && t.grandparent.type !== "JSXAttribute", G = aL(t), J = iL(n, y), L = a && Vs(t, e), q = k ? e.useTabs ? "	" : " ".repeat(e.tabWidth - 1) : "", X = nL(m, h, d, e) || S || x, K = !w && !O && !a && (j ? h.type === "NullLiteral" || h.type === "Literal" && h.value === null : Ig(h, e) && OO(n.test, 3)), Oe = w || v || a && !O || O && s && OO(n.test, 1) || K, Ae = [];
  !S && se(h, de.Dangling) && t.call((Te) => {
    Ae.push(lt(Te, e), ee);
  }, "consequent");
  let ve = [];
  se(n.test, de.Dangling) && t.call((Te) => {
    ve.push(lt(Te, e));
  }, "test"), !x && se(d, de.Dangling) && t.call((Te) => {
    ve.push(lt(Te, e));
  }, "alternate"), se(n, de.Dangling) && ve.push(lt(t, e));
  let Le = Symbol("test"), ze = Symbol("consequent"), et = Symbol("test-and-consequent"), Fe = s ? [Kp(r("test")), n.test.type === "ConditionalExpression" ? Qi : ""] : [r("checkType"), " ", "extends", " ", n.extendsType.type === "TSConditionalType" || n.extendsType.type === "ConditionalTypeAnnotation" || n.extendsType.type === "TSMappedType" ? r("extendsType") : Z(Kp(r("extendsType")))], mt = Z([Fe, " ?"], { id: Le }), ue = r(o), V = te([S || j && (vt(h) || O || w) ? ee : he, Ae, ue]), W = Oe ? Z([mt, w ? V : Ee(V, Z(V, { id: ze }), { groupId: Le })], { id: et }) : [mt, V], R = r(u), Se = K ? Ee(R, Bv(Kp(R)), { groupId: et }) : R, De = [W, ve.length > 0 ? [te([ee, ve]), ee] : x ? ee : K ? Ee(he, " ", { groupId: et }) : he, ":", x ? " " : k ? Oe ? Ee(q, Ee(w || K ? " " : q, " "), { groupId: et }) : Ee(q, " ") : " ", x ? Se : Z([te(Se), j && !K ? H : ""]), J && !G ? H : "", X ? Qi : ""];
  return B && !X ? Z(te([H, Z(De)])) : B || Q ? Z(te(De)) : G || a && b ? Z([te([H, De]), L ? H : ""]) : y === I ? Z(De) : De;
}
function oL(t, e, r, i) {
  let { node: n } = t;
  if (Uh(n))
    return ZM(t, e);
  let s = e.semi ? ";" : "", a = [];
  switch (n.type) {
    case "JsExpressionRoot":
      return r("node");
    case "JsonRoot":
      return [r("node"), ee];
    case "File":
      return jM(t, e, r) ?? r("program");
    case "Program":
      return WS(t, e, r);
    case "EmptyStatement":
      return "";
    case "ExpressionStatement":
      return RM(t, e, r);
    case "ChainExpression":
      return r("expression");
    case "ParenthesizedExpression":
      return !se(n.expression) && (oi(n.expression) || _t(n.expression)) ? ["(", r("expression"), ")"] : Z(["(", te([H, r("expression")]), H, ")"]);
    case "AssignmentExpression":
      return Z6(t, e, r);
    case "VariableDeclarator":
      return W6(t, e, r);
    case "BinaryExpression":
    case "LogicalExpression":
      return nS(t, e, r);
    case "AssignmentPattern":
      return [r("left"), " = ", r("right")];
    case "OptionalMemberExpression":
    case "MemberExpression":
      return M6(t, e, r);
    case "MetaProperty":
      return [r("meta"), ".", r("property")];
    case "BindExpression":
      return n.object && a.push(r("object")), a.push(Z(te([H, FS(t, e, r)]))), a;
    case "Identifier":
      return [n.name, Ht(t), PS(t), It(t, r)];
    case "V8IntrinsicIdentifier":
      return ["%", n.name];
    case "SpreadElement":
    case "SpreadElementPattern":
    case "SpreadPropertyPattern":
    case "RestElement":
      return $S(t, r);
    case "FunctionDeclaration":
    case "FunctionExpression":
      return QS(t, r, e, i);
    case "ArrowFunctionExpression":
      return vM(t, e, r, i);
    case "YieldExpression":
      return a.push("yield"), n.delegate && a.push("*"), n.argument && a.push(" ", r("argument")), a;
    case "AwaitExpression":
      if (a.push("await"), n.argument) {
        a.push(" ", r("argument"));
        let { parent: o } = t;
        if (Re(o) && o.callee === n || at(o) && o.object === n) {
          a = [te([H, ...a]), H];
          let u = t.findAncestor((c) => c.type === "AwaitExpression" || c.type === "BlockStatement");
          if ((u == null ? void 0 : u.type) !== "AwaitExpression" || !zt(u.argument, (c) => c === n))
            return Z(a);
        }
      }
      return a;
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ExportAllDeclaration":
      return sw(t, e, r);
    case "ImportDeclaration":
      return XM(t, e, r);
    case "ImportSpecifier":
    case "ExportSpecifier":
    case "ImportNamespaceSpecifier":
    case "ExportNamespaceSpecifier":
    case "ImportDefaultSpecifier":
    case "ExportDefaultSpecifier":
      return GM(t, e, r);
    case "ImportAttribute":
      return [r("key"), ": ", r("value")];
    case "Import":
      return "import";
    case "BlockStatement":
    case "StaticBlock":
      return ZS(t, e, r);
    case "ClassBody":
      return QM(t, e, r);
    case "ThrowStatement":
      return bM(t, e, r);
    case "ReturnStatement":
      return xM(t, e, r);
    case "NewExpression":
    case "ImportExpression":
    case "OptionalCallExpression":
    case "CallExpression":
      return hS(t, e, r);
    case "ObjectExpression":
    case "ObjectPattern":
    case "RecordExpression":
      return tp(t, e, r);
    case "Property":
      return zh(n) ? gf(t, e, r) : NO(t, e, r);
    case "ObjectProperty":
      return NO(t, e, r);
    case "ObjectMethod":
      return gf(t, e, r);
    case "Decorator":
      return ["@", r("expression")];
    case "ArrayExpression":
    case "ArrayPattern":
    case "TupleExpression":
      return Vg(t, e, r);
    case "SequenceExpression": {
      let { parent: o } = t;
      if (o.type === "ExpressionStatement" || o.type === "ForStatement") {
        let u = [];
        return t.each(({ isFirst: c }) => {
          c ? u.push(r()) : u.push(",", te([he, r()]));
        }, "expressions"), Z(u);
      }
      return Z(Ne([",", he], t.map(r, "expressions")));
    }
    case "ThisExpression":
      return "this";
    case "Super":
      return "super";
    case "Directive":
      return [r("value"), s];
    case "UnaryExpression":
      return a.push(n.operator), /[a-z]$/.test(n.operator) && a.push(" "), se(n.argument) ? a.push(Z(["(", te([H, r("argument")]), H, ")"])) : a.push(r("argument")), a;
    case "UpdateExpression":
      return a.push(r("argument"), n.operator), n.prefix && a.reverse(), a;
    case "ConditionalExpression":
      return Jg(t, e, r, i);
    case "VariableDeclaration": {
      let o = t.map(r, "declarations"), u = t.parent, c = u.type === "ForStatement" || u.type === "ForInStatement" || u.type === "ForOfStatement", h = n.declarations.some((m) => m.init), d;
      return o.length === 1 && !se(n.declarations[0]) ? d = o[0] : o.length > 0 && (d = te(o[0])), a = [Xr(t), n.kind, d ? [" ", d] : "", te(o.slice(1).map((m) => [",", h && !c ? ee : he, m]))], c && u.body !== n || a.push(s), Z(a);
    }
    case "WithStatement":
      return Z(["with (", r("object"), ")", vn(n.body, r("body"))]);
    case "IfStatement": {
      let o = vn(n.consequent, r("consequent")), u = Z(["if (", Z([te([H, r("test")]), H]), ")", o]);
      if (a.push(u), n.alternate) {
        let c = se(n.consequent, de.Trailing | de.Line) || Av(n), h = n.consequent.type === "BlockStatement" && !c;
        a.push(h ? " " : ee), se(n, de.Dangling) && a.push(lt(t, e), c ? ee : " "), a.push("else", Z(vn(n.alternate, r("alternate"), n.alternate.type === "IfStatement")));
      }
      return a;
    }
    case "ForStatement": {
      let o = vn(n.body, r("body")), u = lt(t, e), c = u ? [u, H] : "";
      return !n.init && !n.test && !n.update ? [c, Z(["for (;;)", o])] : [c, Z(["for (", Z([te([H, r("init"), ";", he, r("test"), ";", he, r("update")]), H]), ")", o])];
    }
    case "WhileStatement":
      return Z(["while (", Z([te([H, r("test")]), H]), ")", vn(n.body, r("body"))]);
    case "ForInStatement":
      return Z(["for (", r("left"), " in ", r("right"), ")", vn(n.body, r("body"))]);
    case "ForOfStatement":
      return Z(["for", n.await ? " await" : "", " (", r("left"), " of ", r("right"), ")", vn(n.body, r("body"))]);
    case "DoWhileStatement": {
      let o = vn(n.body, r("body"));
      return a = [Z(["do", o])], n.body.type === "BlockStatement" ? a.push(" ") : a.push(ee), a.push("while (", Z([te([H, r("test")]), H]), ")", s), a;
    }
    case "DoExpression":
      return [n.async ? "async " : "", "do ", r("body")];
    case "BreakStatement":
    case "ContinueStatement":
      return a.push(n.type === "BreakStatement" ? "break" : "continue"), n.label && a.push(" ", r("label")), a.push(s), a;
    case "LabeledStatement":
      return n.body.type === "EmptyStatement" ? [r("label"), ":;"] : [r("label"), ": ", r("body")];
    case "TryStatement":
      return ["try ", r("block"), n.handler ? [" ", r("handler")] : "", n.finalizer ? [" finally ", r("finalizer")] : ""];
    case "CatchClause":
      if (n.param) {
        let o = se(n.param, (c) => !Vr(c) || c.leading && Cr(e.originalText, We(c)) || c.trailing && Cr(e.originalText, ot(c), { backwards: !0 })), u = r("param");
        return ["catch ", o ? ["(", te([H, u]), H, ") "] : ["(", u, ") "], r("body")];
      }
      return ["catch ", r("body")];
    case "SwitchStatement":
      return [Z(["switch (", te([H, r("discriminant")]), H, ")"]), " {", n.cases.length > 0 ? te([ee, Ne(ee, t.map(({ node: o, isLast: u }) => [r(), !u && Kn(o, e) ? ee : ""], "cases"))]) : "", ee, "}"];
    case "SwitchCase": {
      n.test ? a.push("case ", r("test"), ":") : a.push("default:"), se(n, de.Dangling) && a.push(" ", lt(t, e));
      let o = n.consequent.filter((u) => u.type !== "EmptyStatement");
      if (o.length > 0) {
        let u = yf(t, e, r, "consequent");
        a.push(o.length === 1 && o[0].type === "BlockStatement" ? [" ", u] : te([ee, u]));
      }
      return a;
    }
    case "DebuggerStatement":
      return ["debugger", s];
    case "ClassDeclaration":
    case "ClassExpression":
      return US(t, e, r);
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "MethodDefinition":
      return JS(t, e, r);
    case "ClassProperty":
    case "PropertyDefinition":
    case "ClassPrivateProperty":
    case "ClassAccessorProperty":
    case "AccessorProperty":
      return KS(t, e, r);
    case "TemplateElement":
      return As(n.value.raw);
    case "TemplateLiteral":
      return Gv(t, r, e);
    case "TaggedTemplateExpression":
      return o4(r);
    case "PrivateIdentifier":
      return ["#", n.name];
    case "PrivateName":
      return ["#", r("id")];
    case "TopicReference":
      return "%";
    case "ArgumentPlaceholder":
      return "?";
    case "ModuleExpression": {
      a.push("module {");
      let o = r("body");
      return o && a.push(te([ee, o]), ee), a.push("}"), a;
    }
    case "InterpreterDirective":
    default:
      throw new eo(n, "ESTree");
  }
}
function hw(t, e, r) {
  let { parent: i, node: n, key: s } = t, a = [r("expression")];
  switch (n.type) {
    case "AsConstExpression":
      a.push(" as const");
      break;
    case "AsExpression":
    case "TSAsExpression":
      a.push(" as ", r("typeAnnotation"));
      break;
    case "SatisfiesExpression":
    case "TSSatisfiesExpression":
      a.push(" satisfies ", r("typeAnnotation"));
      break;
  }
  return s === "callee" && Re(i) || s === "object" && at(i) ? Z([te([H, ...a]), H]) : a;
}
function pw(t, e, r) {
  return tp(t, r, e);
}
function dw(t, e) {
  let { node: r } = t, i = e("id");
  r.computed && (i = ["[", i, "]"]);
  let n = "";
  return r.initializer && (n = e("initializer")), r.init && (n = e("init")), n ? [i, " = ", n] : i;
}
function lL(t, e, r) {
  let { node: i } = t, n;
  if (i.type === "EnumSymbolBody" || i.explicitType)
    switch (i.type) {
      case "EnumBooleanBody":
        n = "boolean";
        break;
      case "EnumNumberBody":
        n = "number";
        break;
      case "EnumStringBody":
        n = "string";
        break;
      case "EnumSymbolBody":
        n = "symbol";
        break;
    }
  return [n ? `of ${n} ` : "", pw(t, e, r)];
}
function fw(t, e, r) {
  let { node: i } = t;
  return [Xr(t), i.const ? "const " : "", "enum ", e("id"), " ", i.type === "TSEnumDeclaration" ? pw(t, e, r) : e("body")];
}
function mw(t, e, r) {
  let { node: i } = t, n = [Xr(t), "interface"], s = [], a = [];
  i.type !== "InterfaceTypeAnnotation" && s.push(" ", r("id"), r("typeParameters"));
  let o = i.typeParameters && !se(i.typeParameters, de.Trailing | de.Line);
  return Ze(i.extends) && a.push(o ? Ee(" ", he, { groupId: zg(i.typeParameters) }) : he, "extends ", (i.extends.length === 1 ? XQ : te)(Ne([",", he], t.map(r, "extends")))), se(i.id, de.Trailing) || Ze(i.extends) ? o ? n.push(Z([...s, te(a)])) : n.push(Z(te([...s, ...a]))) : n.push(...s, ...a), n.push(" ", r("body")), Z(n);
}
function uL(t, e, r) {
  let { node: i } = t;
  if (fv(i))
    return i.type.slice(0, -14).toLowerCase();
  let n = e.semi ? ";" : "";
  switch (i.type) {
    case "DeclareClass":
      return US(t, e, r);
    case "DeclareFunction":
      return [Xr(t), "function ", r("id"), r("predicate"), n];
    case "DeclareModule":
      return ["declare module ", r("id"), " ", r("body")];
    case "DeclareModuleExports":
      return ["declare module.exports", It(t, r), n];
    case "DeclareVariable":
      return [Xr(t), i.kind ?? "var", " ", r("id"), n];
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
      return sw(t, e, r);
    case "DeclareOpaqueType":
    case "OpaqueType":
      return lM(t, e, r);
    case "DeclareTypeAlias":
    case "TypeAlias":
      return yS(t, e, r);
    case "IntersectionTypeAnnotation":
      return OS(t, e, r);
    case "UnionTypeAnnotation":
      return xS(t, e, r);
    case "ConditionalTypeAnnotation":
      return Jg(t, e, r);
    case "InferTypeAnnotation":
      return vS(t, e, r);
    case "FunctionTypeAnnotation":
      return bS(t, e, r);
    case "TupleTypeAnnotation":
      return Vg(t, e, r);
    case "TupleTypeLabeledElement":
      return wS(t, e, r);
    case "TupleTypeSpreadElement":
      return SS(t, e, r);
    case "GenericTypeAnnotation":
      return [r("id"), zo(t, e, r, "typeParameters")];
    case "IndexedAccessType":
    case "OptionalIndexedAccessType":
      return DS(t, e, r);
    case "TypeAnnotation":
      return AS(t, e, r);
    case "TypeParameter":
      return VS(t, e, r);
    case "TypeofTypeAnnotation":
      return kS(t, r);
    case "ExistsTypeAnnotation":
      return "*";
    case "ArrayTypeAnnotation":
      return ES(r);
    case "DeclareEnum":
    case "EnumDeclaration":
      return fw(t, r, e);
    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
      return lL(t, r, e);
    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumStringMember":
    case "EnumDefaultedMember":
      return dw(t, r);
    case "FunctionTypeParam": {
      let s = i.name ? r("name") : t.parent.this === i ? "this" : "";
      return [s, Ht(t), s ? ": " : "", r("typeAnnotation")];
    }
    case "DeclareInterface":
    case "InterfaceDeclaration":
    case "InterfaceTypeAnnotation":
      return mw(t, e, r);
    case "ClassImplements":
    case "InterfaceExtends":
      return [r("id"), r("typeParameters")];
    case "NullableTypeAnnotation":
      return ["?", r("typeAnnotation")];
    case "Variance": {
      let { kind: s } = i;
      return _S.ok(s === "plus" || s === "minus"), s === "plus" ? "+" : "-";
    }
    case "KeyofTypeAnnotation":
      return ["keyof ", r("argument")];
    case "ObjectTypeCallProperty":
      return [i.static ? "static " : "", r("value")];
    case "ObjectTypeMappedTypeProperty":
      return FM(t, e, r);
    case "ObjectTypeIndexer":
      return [i.static ? "static " : "", i.variance ? r("variance") : "", "[", r("id"), i.id ? ": " : "", r("key"), "]: ", r("value")];
    case "ObjectTypeProperty": {
      let s = "";
      return i.proto ? s = "proto " : i.static && (s = "static "), [s, i.kind !== "init" ? i.kind + " " : "", i.variance ? r("variance") : "", Vl(t, e, r), Ht(t), zh(i) ? "" : ": ", r("value")];
    }
    case "ObjectTypeAnnotation":
      return tp(t, e, r);
    case "ObjectTypeInternalSlot":
      return [i.static ? "static " : "", "[[", r("id"), "]]", Ht(t), i.method ? "" : ": ", r("value")];
    case "ObjectTypeSpreadProperty":
      return $S(t, r);
    case "QualifiedTypeofIdentifier":
    case "QualifiedTypeIdentifier":
      return [r("qualification"), ".", r("id")];
    case "NullLiteralTypeAnnotation":
      return "null";
    case "BooleanLiteralTypeAnnotation":
      return String(i.value);
    case "StringLiteralTypeAnnotation":
      return As(ol(Zr(i), e));
    case "NumberLiteralTypeAnnotation":
      return Pn(i.raw ?? i.extra.raw);
    case "BigIntLiteralTypeAnnotation":
      return Of(i.raw ?? i.extra.raw);
    case "TypeCastExpression":
      return ["(", r("expression"), It(t, r), ")"];
    case "TypePredicate":
      return TS(t, r);
    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation":
      return zo(t, e, r, "params");
    case "InferredPredicate":
    case "DeclaredPredicate":
      return [t.key === "predicate" && t.parent.type !== "DeclareFunction" && !t.parent.returnType ? ": " : " ", "%checks", ...i.type === "DeclaredPredicate" ? ["(", r("value"), ")"] : []];
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
      return hw(t, e, r);
  }
}
function cL(t, e, r) {
  var i;
  let { node: n } = t;
  if (!n.type.startsWith("TS"))
    return;
  if (mv(n))
    return n.type.slice(2, -7).toLowerCase();
  let s = e.semi ? ";" : "", a = [];
  switch (n.type) {
    case "TSThisType":
      return "this";
    case "TSTypeAssertion": {
      let o = !(_t(n.expression) || oi(n.expression)), u = Z(["<", te([H, r("typeAnnotation")]), H, ">"]), c = [Ee("("), te([H, r("expression")]), H, Ee(")")];
      return o ? fs([[u, r("expression")], [u, Z(c, { shouldBreak: !0 })], [u, r("expression")]]) : Z([u, r("expression")]);
    }
    case "TSDeclareFunction":
      return QS(t, r, e);
    case "TSExportAssignment":
      return ["export = ", r("expression"), s];
    case "TSModuleBlock":
      return ZS(t, e, r);
    case "TSInterfaceBody":
    case "TSTypeLiteral":
      return tp(t, e, r);
    case "TSTypeAliasDeclaration":
      return yS(t, e, r);
    case "TSQualifiedName":
      return [r("left"), ".", r("right")];
    case "TSAbstractMethodDefinition":
    case "TSDeclareMethod":
      return JS(t, e, r);
    case "TSAbstractAccessorProperty":
    case "TSAbstractPropertyDefinition":
      return KS(t, e, r);
    case "TSInterfaceHeritage":
    case "TSClassImplements":
    case "TSExpressionWithTypeArguments":
    case "TSInstantiationExpression":
      return [r("expression"), r("typeParameters")];
    case "TSTemplateLiteralType":
      return Gv(t, r, e);
    case "TSNamedTupleMember":
      return wS(t, e, r);
    case "TSRestType":
      return SS(t, e, r);
    case "TSOptionalType":
      return [r("typeAnnotation"), "?"];
    case "TSInterfaceDeclaration":
      return mw(t, e, r);
    case "TSTypeParameterDeclaration":
    case "TSTypeParameterInstantiation":
      return zo(t, e, r, "params");
    case "TSTypeParameter":
      return VS(t, e, r);
    case "TSAsExpression":
    case "TSSatisfiesExpression":
      return hw(t, e, r);
    case "TSArrayType":
      return ES(r);
    case "TSPropertySignature":
      return [n.readonly ? "readonly " : "", Vl(t, e, r), Ht(t), It(t, r)];
    case "TSParameterProperty":
      return [_c(n), n.static ? "static " : "", n.override ? "override " : "", n.readonly ? "readonly " : "", r("parameter")];
    case "TSTypeQuery":
      return kS(t, r);
    case "TSIndexSignature": {
      let o = n.parameters.length > 1 ? Ee(Jn(e) ? "," : "") : "", u = Z([te([H, Ne([", ", H], t.map(r, "parameters"))]), o, H]), c = t.parent.type === "ClassBody" && t.key === "body";
      return [c && n.static ? "static " : "", n.readonly ? "readonly " : "", "[", n.parameters ? u : "", "]", It(t, r), c ? s : ""];
    }
    case "TSTypePredicate":
      return TS(t, r);
    case "TSNonNullExpression":
      return [r("expression"), "!"];
    case "TSImportType":
      return [n.isTypeOf ? "typeof " : "", "import(", r("argument"), ")", n.qualifier ? [".", r("qualifier")] : "", zo(t, e, r, n.typeArguments ? "typeArguments" : "typeParameters")];
    case "TSLiteralType":
      return r("literal");
    case "TSIndexedAccessType":
      return DS(t, e, r);
    case "TSTypeOperator":
      return [n.operator, " ", r("typeAnnotation")];
    case "TSMappedType":
      return $M(t, e, r);
    case "TSMethodSignature": {
      let o = n.kind && n.kind !== "method" ? `${n.kind} ` : "";
      a.push(_c(n), o, n.computed ? "[" : "", r("key"), n.computed ? "]" : "", Ht(t));
      let u = Xl(t, r, e, !1, !0), c = n.returnType ? "returnType" : "typeAnnotation", h = n[c], d = h ? It(t, r, c) : "", m = Kh(n, d);
      return a.push(m ? Z(u) : u), h && a.push(Z(d)), Z(a);
    }
    case "TSNamespaceExportDeclaration":
      return ["export as namespace ", r("id"), e.semi ? ";" : ""];
    case "TSEnumDeclaration":
      return fw(t, r, e);
    case "TSEnumMember":
      return dw(t, r);
    case "TSImportEqualsDeclaration":
      return [n.isExport ? "export " : "", "import ", aw(n, !1), r("id"), " = ", r("moduleReference"), e.semi ? ";" : ""];
    case "TSExternalModuleReference":
      return ["require(", r("expression"), ")"];
    case "TSModuleDeclaration": {
      let { parent: o } = t, u = o.type === "TSModuleDeclaration", c = ((i = n.body) == null ? void 0 : i.type) === "TSModuleDeclaration";
      if (u)
        a.push(".");
      else if (a.push(Xr(t)), !(n.kind === "global" || n.global)) {
        let h = n.kind ?? (lr(n.id) || Gg(e, ot(n), ot(n.id)).trim().endsWith("module") ? "module" : "namespace");
        a.push(h, " ");
      }
      return a.push(r("id")), c ? a.push(r("body")) : n.body ? a.push(" ", Z(r("body"))) : a.push(s), a;
    }
    case "TSConditionalType":
      return Jg(t, e, r);
    case "TSInferType":
      return vS(t, e, r);
    case "TSIntersectionType":
      return OS(t, e, r);
    case "TSUnionType":
      return xS(t, e, r);
    case "TSFunctionType":
    case "TSCallSignatureDeclaration":
    case "TSConstructorType":
    case "TSConstructSignatureDeclaration":
      return bS(t, e, r);
    case "TSTupleType":
      return Vg(t, e, r);
    case "TSTypeReference":
      return [r("typeName"), zo(t, e, r, "typeParameters")];
    case "TSTypeAnnotation":
      return AS(t, e, r);
    case "TSEmptyBodyFunctionExpression":
      return Yg(t, e, r);
    case "TSJSDocAllType":
      return "*";
    case "TSJSDocUnknownType":
      return "?";
    case "TSJSDocNullableType":
      return IO(t, r, "?");
    case "TSJSDocNonNullableType":
      return IO(t, r, "!");
    case "TSParenthesizedType":
    default:
      throw new eo(n, "TypeScript");
  }
}
function hL(t, e, r, i) {
  if (iS(t))
    return q4(t, e);
  for (let n of [A6, x6, uL, cL, oL]) {
    let s = n(t, e, r, i);
    if (s !== void 0)
      return s;
  }
}
var pL = Ue(["ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "ClassPrivateProperty", "MethodDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod"]);
function dL(t, e, r, i) {
  var n;
  t.isRoot && ((n = e.__onHtmlBindingRoot) == null || n.call(e, t.node, e));
  let s = hL(t, e, r, i);
  if (!s)
    return "";
  let { node: a } = t;
  if (pL(a))
    return s;
  let o = Ze(a.decorators), u = P6(t, e, r), c = a.type === "ClassExpression";
  if (o && !c)
    return of(s, (m) => Z([u, m]));
  let h = Vs(t, e), d = LM(t, e);
  return !u && !h && !d ? s : of(s, (m) => [d ? ";" : "", h ? "(" : "", h && c && o ? [te([he, u, m]), he] : [u, m], h ? ")" : ""]);
}
var fL = dL, mL = { avoidAstMutation: !0 }, gL = [{ linguistLanguageId: 174, name: "JSON.stringify", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"], parsers: ["json-stringify"], vscodeLanguageIds: ["json"] }, { linguistLanguageId: 174, name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".all-contributorsrc", ".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "flake.lock", "mcmod.info", ".babelrc", ".jscsrc", ".jshintrc", ".jslintrc", ".swcrc"], parsers: ["json"], vscodeLanguageIds: ["json"] }, { linguistLanguageId: 423, name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".code-workspace", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [], parsers: ["jsonc"], vscodeLanguageIds: ["jsonc"] }, { linguistLanguageId: 175, name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", parsers: ["json5"], vscodeLanguageIds: ["json5"] }], gw = {};
Xh(gw, { getVisitorKeys: () => bL, massageAstNode: () => yw, print: () => DL });
var yL = { JsonRoot: ["node"], ArrayExpression: ["elements"], ObjectExpression: ["properties"], ObjectProperty: ["key", "value"], UnaryExpression: ["argument"], NullLiteral: [], BooleanLiteral: [], StringLiteral: [], NumericLiteral: [], Identifier: [], TemplateLiteral: ["quasis"], TemplateElement: [] }, OL = yL, xL = pv(OL), bL = xL;
function DL(t, e, r) {
  let { node: i } = t;
  switch (i.type) {
    case "JsonRoot":
      return [r("node"), ee];
    case "ArrayExpression": {
      if (i.elements.length === 0)
        return "[]";
      let n = t.map(() => t.node === null ? "null" : r(), "elements");
      return ["[", te([ee, Ne([",", ee], n)]), ee, "]"];
    }
    case "ObjectExpression":
      return i.properties.length === 0 ? "{}" : ["{", te([ee, Ne([",", ee], t.map(r, "properties"))]), ee, "}"];
    case "ObjectProperty":
      return [r("key"), ": ", r("value")];
    case "UnaryExpression":
      return [i.operator === "+" ? "" : i.operator, r("argument")];
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return i.value ? "true" : "false";
    case "StringLiteral":
      return JSON.stringify(i.value);
    case "NumericLiteral":
      return MO(t) ? JSON.stringify(String(i.value)) : JSON.stringify(i.value);
    case "Identifier":
      return MO(t) ? JSON.stringify(i.name) : i.name;
    case "TemplateLiteral":
      return r(["quasis", 0]);
    case "TemplateElement":
      return JSON.stringify(i.value.cooked);
    default:
      throw new eo(i, "JSON");
  }
}
function MO(t) {
  return t.key === "key" && t.parent.type === "ObjectProperty";
}
var vL = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
function yw(t, e) {
  let { type: r } = t;
  if (r === "ObjectProperty") {
    let { key: i } = t;
    i.type === "Identifier" ? e.key = { type: "StringLiteral", value: i.name } : i.type === "NumericLiteral" && (e.key = { type: "StringLiteral", value: String(i.value) });
    return;
  }
  if (r === "UnaryExpression" && t.operator === "+")
    return e.argument;
  if (r === "ArrayExpression") {
    for (let [i, n] of t.elements.entries())
      n === null && e.elements.splice(i, 0, { type: "NullLiteral" });
    return;
  }
  if (r === "TemplateLiteral")
    return { type: "StringLiteral", value: t.quasis[0].value.cooked };
}
yw.ignoredProperties = vL;
var Fu = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, ss = "JavaScript", SL = { arrowParens: { category: ss, type: "choice", default: "always", description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: Fu.bracketSameLine, bracketSpacing: Fu.bracketSpacing, jsxBracketSameLine: { category: ss, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { category: ss, type: "boolean", default: !0, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, experimentalTernaries: { category: ss, type: "boolean", default: !1, description: "Use curious ternaries, with the question mark after the condition.", oppositeDescription: "Default behavior of ternaries; keep question marks on the same line as the consequent." }, singleQuote: Fu.singleQuote, jsxSingleQuote: { category: ss, type: "boolean", default: !1, description: "Use single quotes in JSX." }, quoteProps: { category: ss, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { category: ss, type: "choice", default: "all", description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "all", description: "Trailing commas wherever possible (including function arguments)." }, { value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }] }, singleAttributePerLine: Fu.singleAttributePerLine }, wL = SL, CL = { estree: cv, "estree-json": gw }, AL = [...q7, ...gL], EL = uv, kL = Object.create, Kg = Object.defineProperty, TL = Object.getOwnPropertyDescriptor, PL = Object.getOwnPropertyNames, FL = Object.getPrototypeOf, $L = Object.prototype.hasOwnProperty, Ow = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), BL = (t, e) => {
  for (var r in e)
    Kg(t, r, { get: e[r], enumerable: !0 });
}, IL = (t, e, r, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of PL(e))
      !$L.call(t, n) && n !== r && Kg(t, n, { get: () => e[n], enumerable: !(i = TL(e, n)) || i.enumerable });
  return t;
}, ey = (t, e, r) => (r = t != null ? kL(FL(t)) : {}, IL(e || !t || !t.__esModule ? Kg(r, "default", { value: t, enumerable: !0 }) : r, t)), xw = Ow((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(p, l) {
    if (p == null)
      return {};
    var f = {}, g = Object.keys(p), D, A;
    for (A = 0; A < g.length; A++)
      D = g[A], !(l.indexOf(D) >= 0) && (f[D] = p[D]);
    return f;
  }
  var r = class {
    constructor(p, l, f) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = p, this.column = l, this.index = f;
    }
  }, i = class {
    constructor(p, l) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = p, this.end = l;
    }
  };
  function n(p, l) {
    let { line: f, column: g, index: D } = p;
    return new r(f, g + l, D + l);
  }
  var s = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", a = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: s }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: s } }, o = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, u = ({ type: p, prefix: l }) => p === "UpdateExpression" ? o.UpdateExpression[String(l)] : o[p], c = { AccessorIsGenerator: ({ kind: p }) => `A ${p}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: p }) => `Missing initializer in ${p} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: p }) => `\`${p}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", DynamicImportPhaseRequiresImportExpressions: ({ phase: p }) => `'import.${p}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: p, exportName: l }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${p}' as '${l}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: p }) => `'${p === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: p }) => `Unsyntactic ${p === "BreakStatement" ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: ({ importName: p }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${p}" as foo }\`?`, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: ({ maxArgumentCount: p }) => `\`import()\` requires exactly ${p === 1 ? "one argument" : "one or two arguments"}.`, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: p }) => `Expected number in radix ${p}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: p }) => `Escape sequence in keyword ${p}.`, InvalidIdentifier: ({ identifierName: p }) => `Invalid identifier ${p}.`, InvalidLhs: ({ ancestor: p }) => `Invalid left-hand side in ${u(p)}.`, InvalidLhsBinding: ({ ancestor: p }) => `Binding invalid left-hand side in ${u(p)}.`, InvalidLhsOptionalChaining: ({ ancestor: p }) => `Invalid optional chaining in the left-hand side of ${u(p)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: p }) => `Unexpected character '${p}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: p }) => `Private name #${p} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: p }) => `Label '${p}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: p }) => `This experimental syntax requires enabling the parser plugin: ${p.map((l) => JSON.stringify(l)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: p }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${p.map((l) => JSON.stringify(l)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: p }) => `Duplicate key "${p}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: p }) => `An export name cannot include a lone surrogate, found '\\u${p.toString(16)}'.`, ModuleExportUndefined: ({ localName: p }) => `Export '${p}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: p }) => `Private names are only allowed in property accesses (\`obj.#${p}\`) or in \`in\` expressions (\`#${p} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: p }) => `Duplicate private name #${p}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: p }) => `Unexpected keyword '${p}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: p }) => `Unexpected reserved word '${p}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: p, unexpected: l }) => `Unexpected token${l ? ` '${l}'.` : ""}${p ? `, expected "${p}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: p, onlyValidPropertyName: l }) => `The only valid meta property for ${p} is ${p}.${l}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: p }) => `Identifier '${p}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, h = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: p }) => `Assigning to '${p}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: p }) => `Binding '${p}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, d = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), m = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: p }) => `Invalid topic token ${p}. In order to use ${p} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${p}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: p }) => `Hack-style pipe body cannot be an unparenthesized ${u({ type: p })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }, y = ["toMessage"], O = ["message"];
  function b(p, l, f) {
    Object.defineProperty(p, l, { enumerable: !1, configurable: !0, value: f });
  }
  function v(p) {
    let { toMessage: l } = p, f = e(p, y);
    return function g(D, A) {
      let T = new SyntaxError();
      return Object.assign(T, f, { loc: D, pos: D.index }), "missingPlugin" in A && Object.assign(T, { missingPlugin: A.missingPlugin }), b(T, "clone", function(F = {}) {
        var N;
        let { line: $, column: Y, index: ie } = (N = F.loc) != null ? N : D;
        return g(new r($, Y, ie), Object.assign({}, A, F.details));
      }), b(T, "details", A), Object.defineProperty(T, "message", { configurable: !0, get() {
        let F = `${l(A)} (${D.line}:${D.column})`;
        return this.message = F, F;
      }, set(F) {
        Object.defineProperty(this, "message", { value: F, writable: !0 });
      } }), T;
    };
  }
  function S(p, l) {
    if (Array.isArray(p))
      return (g) => S(g, p[0]);
    let f = {};
    for (let g of Object.keys(p)) {
      let D = p[g], A = typeof D == "string" ? { message: () => D } : typeof D == "function" ? { message: D } : D, { message: T } = A, F = e(A, O), N = typeof T == "string" ? () => T : T;
      f[g] = v(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: g, toMessage: N }, l ? { syntaxPlugin: l } : {}, F));
    }
    return f;
  }
  var x = Object.assign({}, S(a), S(c), S(h), S`pipelineOperator`(m)), { defineProperty: w } = Object, k = (p, l) => w(p, l, { enumerable: !1, value: p[l] });
  function C(p) {
    return p.loc.start && k(p.loc.start, "index"), p.loc.end && k(p.loc.end, "index"), p;
  }
  var E = (p) => class extends p {
    parse() {
      let l = C(super.parse());
      return this.options.tokens && (l.tokens = l.tokens.map(C)), l;
    }
    parseRegExpLiteral({ pattern: l, flags: f }) {
      let g = null;
      try {
        g = new RegExp(l, f);
      } catch {
      }
      let D = this.estreeParseLiteral(g);
      return D.regex = { pattern: l, flags: f }, D;
    }
    parseBigIntLiteral(l) {
      let f;
      try {
        f = BigInt(l);
      } catch {
        f = null;
      }
      let g = this.estreeParseLiteral(f);
      return g.bigint = String(g.value || l), g;
    }
    parseDecimalLiteral(l) {
      let f = this.estreeParseLiteral(null);
      return f.decimal = String(f.value || l), f;
    }
    estreeParseLiteral(l) {
      return this.parseLiteral(l, "Literal");
    }
    parseStringLiteral(l) {
      return this.estreeParseLiteral(l);
    }
    parseNumericLiteral(l) {
      return this.estreeParseLiteral(l);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(l) {
      return this.estreeParseLiteral(l);
    }
    directiveToStmt(l) {
      let f = l.value;
      delete l.value, f.type = "Literal", f.raw = f.extra.raw, f.value = f.extra.expressionValue;
      let g = l;
      return g.type = "ExpressionStatement", g.expression = f, g.directive = f.extra.rawValue, delete f.extra, g;
    }
    initFunction(l, f) {
      super.initFunction(l, f), l.expression = !1;
    }
    checkDeclaration(l) {
      l != null && this.isObjectProperty(l) ? this.checkDeclaration(l.value) : super.checkDeclaration(l);
    }
    getObjectOrClassMethodParams(l) {
      return l.value.params;
    }
    isValidDirective(l) {
      var f;
      return l.type === "ExpressionStatement" && l.expression.type === "Literal" && typeof l.expression.value == "string" && !((f = l.expression.extra) != null && f.parenthesized);
    }
    parseBlockBody(l, f, g, D, A) {
      super.parseBlockBody(l, f, g, D, A);
      let T = l.directives.map((F) => this.directiveToStmt(F));
      l.body = T.concat(l.body), delete l.directives;
    }
    pushClassMethod(l, f, g, D, A, T) {
      this.parseMethod(f, g, D, A, T, "ClassMethod", !0), f.typeParameters && (f.value.typeParameters = f.typeParameters, delete f.typeParameters), l.body.push(f);
    }
    parsePrivateName() {
      let l = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(l) : l;
    }
    convertPrivateNameToPrivateIdentifier(l) {
      let f = super.getPrivateNameSV(l);
      return l = l, delete l.id, l.name = f, l.type = "PrivateIdentifier", l;
    }
    isPrivateName(l) {
      return this.getPluginOption("estree", "classFeatures") ? l.type === "PrivateIdentifier" : super.isPrivateName(l);
    }
    getPrivateNameSV(l) {
      return this.getPluginOption("estree", "classFeatures") ? l.name : super.getPrivateNameSV(l);
    }
    parseLiteral(l, f) {
      let g = super.parseLiteral(l, f);
      return g.raw = g.extra.raw, delete g.extra, g;
    }
    parseFunctionBody(l, f, g = !1) {
      super.parseFunctionBody(l, f, g), l.expression = l.body.type !== "BlockStatement";
    }
    parseMethod(l, f, g, D, A, T, F = !1) {
      let N = this.startNode();
      return N.kind = l.kind, N = super.parseMethod(N, f, g, D, A, T, F), N.type = "FunctionExpression", delete N.kind, l.value = N, T === "ClassPrivateMethod" && (l.computed = !1), this.finishNode(l, "MethodDefinition");
    }
    parseClassProperty(...l) {
      let f = super.parseClassProperty(...l);
      return this.getPluginOption("estree", "classFeatures") && (f.type = "PropertyDefinition"), f;
    }
    parseClassPrivateProperty(...l) {
      let f = super.parseClassPrivateProperty(...l);
      return this.getPluginOption("estree", "classFeatures") && (f.type = "PropertyDefinition", f.computed = !1), f;
    }
    parseObjectMethod(l, f, g, D, A) {
      let T = super.parseObjectMethod(l, f, g, D, A);
      return T && (T.type = "Property", T.kind === "method" && (T.kind = "init"), T.shorthand = !1), T;
    }
    parseObjectProperty(l, f, g, D) {
      let A = super.parseObjectProperty(l, f, g, D);
      return A && (A.kind = "init", A.type = "Property"), A;
    }
    isValidLVal(l, f, g) {
      return l === "Property" ? "value" : super.isValidLVal(l, f, g);
    }
    isAssignable(l, f) {
      return l != null && this.isObjectProperty(l) ? this.isAssignable(l.value, f) : super.isAssignable(l, f);
    }
    toAssignable(l, f = !1) {
      if (l != null && this.isObjectProperty(l)) {
        let { key: g, value: D } = l;
        this.isPrivateName(g) && this.classScope.usePrivateName(this.getPrivateNameSV(g), g.loc.start), this.toAssignable(D, f);
      } else
        super.toAssignable(l, f);
    }
    toAssignableObjectExpressionProp(l, f, g) {
      l.kind === "get" || l.kind === "set" ? this.raise(x.PatternHasAccessor, l.key) : l.method ? this.raise(x.PatternHasMethod, l.key) : super.toAssignableObjectExpressionProp(l, f, g);
    }
    finishCallExpression(l, f) {
      let g = super.finishCallExpression(l, f);
      if (g.callee.type === "Import") {
        if (g.type = "ImportExpression", g.source = g.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var D, A;
          g.options = (D = g.arguments[1]) != null ? D : null, g.attributes = (A = g.arguments[1]) != null ? A : null;
        }
        delete g.arguments, delete g.callee;
      }
      return g;
    }
    toReferencedArguments(l) {
      l.type !== "ImportExpression" && super.toReferencedArguments(l);
    }
    parseExport(l, f) {
      let g = this.state.lastTokStartLoc, D = super.parseExport(l, f);
      switch (D.type) {
        case "ExportAllDeclaration":
          D.exported = null;
          break;
        case "ExportNamedDeclaration":
          D.specifiers.length === 1 && D.specifiers[0].type === "ExportNamespaceSpecifier" && (D.type = "ExportAllDeclaration", D.exported = D.specifiers[0].exported, delete D.specifiers);
        case "ExportDefaultDeclaration":
          {
            var A;
            let { declaration: T } = D;
            (T == null ? void 0 : T.type) === "ClassDeclaration" && ((A = T.decorators) == null ? void 0 : A.length) > 0 && T.start === D.start && this.resetStartLocation(D, g);
          }
          break;
      }
      return D;
    }
    parseSubscript(l, f, g, D) {
      let A = super.parseSubscript(l, f, g, D);
      if (D.optionalChainMember) {
        if ((A.type === "OptionalMemberExpression" || A.type === "OptionalCallExpression") && (A.type = A.type.substring(8)), D.stop) {
          let T = this.startNodeAtNode(A);
          return T.expression = A, this.finishNode(T, "ChainExpression");
        }
      } else
        (A.type === "MemberExpression" || A.type === "CallExpression") && (A.optional = !1);
      return A;
    }
    isOptionalMemberExpression(l) {
      return l.type === "ChainExpression" ? l.expression.type === "MemberExpression" : super.isOptionalMemberExpression(l);
    }
    hasPropertyAsPrivateName(l) {
      return l.type === "ChainExpression" && (l = l.expression), super.hasPropertyAsPrivateName(l);
    }
    isObjectProperty(l) {
      return l.type === "Property" && l.kind === "init" && !l.method;
    }
    isObjectMethod(l) {
      return l.method || l.kind === "get" || l.kind === "set";
    }
    finishNodeAt(l, f, g) {
      return C(super.finishNodeAt(l, f, g));
    }
    resetStartLocation(l, f) {
      super.resetStartLocation(l, f), C(l);
    }
    resetEndLocation(l, f = this.state.lastTokEndLoc) {
      super.resetEndLocation(l, f), C(l);
    }
  }, P = class {
    constructor(p, l) {
      this.token = void 0, this.preserveSpace = void 0, this.token = p, this.preserveSpace = !!l;
    }
  }, I = { brace: new P("{"), j_oTag: new P("<tag"), j_cTag: new P("</tag"), j_expr: new P("<tag>...</tag>", !0) };
  I.template = new P("`", !0);
  var B = !0, Q = !0, j = !0, G = !0, J = !0, L = !0, q = class {
    constructor(p, l = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = p, this.keyword = l.keyword, this.beforeExpr = !!l.beforeExpr, this.startsExpr = !!l.startsExpr, this.rightAssociative = !!l.rightAssociative, this.isLoop = !!l.isLoop, this.isAssign = !!l.isAssign, this.prefix = !!l.prefix, this.postfix = !!l.postfix, this.binop = l.binop != null ? l.binop : null, this.updateContext = null;
    }
  }, X = /* @__PURE__ */ new Map();
  function K(p, l = {}) {
    l.keyword = p;
    let f = ue(p, l);
    return X.set(p, f), f;
  }
  function Oe(p, l) {
    return ue(p, { beforeExpr: B, binop: l });
  }
  var Ae = -1, ve = [], Le = [], ze = [], et = [], Fe = [], mt = [];
  function ue(p, l = {}) {
    var f, g, D, A;
    return ++Ae, Le.push(p), ze.push((f = l.binop) != null ? f : -1), et.push((g = l.beforeExpr) != null ? g : !1), Fe.push((D = l.startsExpr) != null ? D : !1), mt.push((A = l.prefix) != null ? A : !1), ve.push(new q(p, l)), Ae;
  }
  function V(p, l = {}) {
    var f, g, D, A;
    return ++Ae, X.set(p, Ae), Le.push(p), ze.push((f = l.binop) != null ? f : -1), et.push((g = l.beforeExpr) != null ? g : !1), Fe.push((D = l.startsExpr) != null ? D : !1), mt.push((A = l.prefix) != null ? A : !1), ve.push(new q("name", l)), Ae;
  }
  var W = { bracketL: ue("[", { beforeExpr: B, startsExpr: Q }), bracketHashL: ue("#[", { beforeExpr: B, startsExpr: Q }), bracketBarL: ue("[|", { beforeExpr: B, startsExpr: Q }), bracketR: ue("]"), bracketBarR: ue("|]"), braceL: ue("{", { beforeExpr: B, startsExpr: Q }), braceBarL: ue("{|", { beforeExpr: B, startsExpr: Q }), braceHashL: ue("#{", { beforeExpr: B, startsExpr: Q }), braceR: ue("}"), braceBarR: ue("|}"), parenL: ue("(", { beforeExpr: B, startsExpr: Q }), parenR: ue(")"), comma: ue(",", { beforeExpr: B }), semi: ue(";", { beforeExpr: B }), colon: ue(":", { beforeExpr: B }), doubleColon: ue("::", { beforeExpr: B }), dot: ue("."), question: ue("?", { beforeExpr: B }), questionDot: ue("?."), arrow: ue("=>", { beforeExpr: B }), template: ue("template"), ellipsis: ue("...", { beforeExpr: B }), backQuote: ue("`", { startsExpr: Q }), dollarBraceL: ue("${", { beforeExpr: B, startsExpr: Q }), templateTail: ue("...`", { startsExpr: Q }), templateNonTail: ue("...${", { beforeExpr: B, startsExpr: Q }), at: ue("@"), hash: ue("#", { startsExpr: Q }), interpreterDirective: ue("#!..."), eq: ue("=", { beforeExpr: B, isAssign: G }), assign: ue("_=", { beforeExpr: B, isAssign: G }), slashAssign: ue("_=", { beforeExpr: B, isAssign: G }), xorAssign: ue("_=", { beforeExpr: B, isAssign: G }), moduloAssign: ue("_=", { beforeExpr: B, isAssign: G }), incDec: ue("++/--", { prefix: J, postfix: L, startsExpr: Q }), bang: ue("!", { beforeExpr: B, prefix: J, startsExpr: Q }), tilde: ue("~", { beforeExpr: B, prefix: J, startsExpr: Q }), doubleCaret: ue("^^", { startsExpr: Q }), doubleAt: ue("@@", { startsExpr: Q }), pipeline: Oe("|>", 0), nullishCoalescing: Oe("??", 1), logicalOR: Oe("||", 1), logicalAND: Oe("&&", 2), bitwiseOR: Oe("|", 3), bitwiseXOR: Oe("^", 4), bitwiseAND: Oe("&", 5), equality: Oe("==/!=/===/!==", 6), lt: Oe("</>/<=/>=", 7), gt: Oe("</>/<=/>=", 7), relational: Oe("</>/<=/>=", 7), bitShift: Oe("<</>>/>>>", 8), bitShiftL: Oe("<</>>/>>>", 8), bitShiftR: Oe("<</>>/>>>", 8), plusMin: ue("+/-", { beforeExpr: B, binop: 9, prefix: J, startsExpr: Q }), modulo: ue("%", { binop: 10, startsExpr: Q }), star: ue("*", { binop: 10 }), slash: Oe("/", 10), exponent: ue("**", { beforeExpr: B, binop: 11, rightAssociative: !0 }), _in: K("in", { beforeExpr: B, binop: 7 }), _instanceof: K("instanceof", { beforeExpr: B, binop: 7 }), _break: K("break"), _case: K("case", { beforeExpr: B }), _catch: K("catch"), _continue: K("continue"), _debugger: K("debugger"), _default: K("default", { beforeExpr: B }), _else: K("else", { beforeExpr: B }), _finally: K("finally"), _function: K("function", { startsExpr: Q }), _if: K("if"), _return: K("return", { beforeExpr: B }), _switch: K("switch"), _throw: K("throw", { beforeExpr: B, prefix: J, startsExpr: Q }), _try: K("try"), _var: K("var"), _const: K("const"), _with: K("with"), _new: K("new", { beforeExpr: B, startsExpr: Q }), _this: K("this", { startsExpr: Q }), _super: K("super", { startsExpr: Q }), _class: K("class", { startsExpr: Q }), _extends: K("extends", { beforeExpr: B }), _export: K("export"), _import: K("import", { startsExpr: Q }), _null: K("null", { startsExpr: Q }), _true: K("true", { startsExpr: Q }), _false: K("false", { startsExpr: Q }), _typeof: K("typeof", { beforeExpr: B, prefix: J, startsExpr: Q }), _void: K("void", { beforeExpr: B, prefix: J, startsExpr: Q }), _delete: K("delete", { beforeExpr: B, prefix: J, startsExpr: Q }), _do: K("do", { isLoop: j, beforeExpr: B }), _for: K("for", { isLoop: j }), _while: K("while", { isLoop: j }), _as: V("as", { startsExpr: Q }), _assert: V("assert", { startsExpr: Q }), _async: V("async", { startsExpr: Q }), _await: V("await", { startsExpr: Q }), _defer: V("defer", { startsExpr: Q }), _from: V("from", { startsExpr: Q }), _get: V("get", { startsExpr: Q }), _let: V("let", { startsExpr: Q }), _meta: V("meta", { startsExpr: Q }), _of: V("of", { startsExpr: Q }), _sent: V("sent", { startsExpr: Q }), _set: V("set", { startsExpr: Q }), _source: V("source", { startsExpr: Q }), _static: V("static", { startsExpr: Q }), _using: V("using", { startsExpr: Q }), _yield: V("yield", { startsExpr: Q }), _asserts: V("asserts", { startsExpr: Q }), _checks: V("checks", { startsExpr: Q }), _exports: V("exports", { startsExpr: Q }), _global: V("global", { startsExpr: Q }), _implements: V("implements", { startsExpr: Q }), _intrinsic: V("intrinsic", { startsExpr: Q }), _infer: V("infer", { startsExpr: Q }), _is: V("is", { startsExpr: Q }), _mixins: V("mixins", { startsExpr: Q }), _proto: V("proto", { startsExpr: Q }), _require: V("require", { startsExpr: Q }), _satisfies: V("satisfies", { startsExpr: Q }), _keyof: V("keyof", { startsExpr: Q }), _readonly: V("readonly", { startsExpr: Q }), _unique: V("unique", { startsExpr: Q }), _abstract: V("abstract", { startsExpr: Q }), _declare: V("declare", { startsExpr: Q }), _enum: V("enum", { startsExpr: Q }), _module: V("module", { startsExpr: Q }), _namespace: V("namespace", { startsExpr: Q }), _interface: V("interface", { startsExpr: Q }), _type: V("type", { startsExpr: Q }), _opaque: V("opaque", { startsExpr: Q }), name: ue("name", { startsExpr: Q }), string: ue("string", { startsExpr: Q }), num: ue("num", { startsExpr: Q }), bigint: ue("bigint", { startsExpr: Q }), decimal: ue("decimal", { startsExpr: Q }), regexp: ue("regexp", { startsExpr: Q }), privateName: ue("#name", { startsExpr: Q }), eof: ue("eof"), jsxName: ue("jsxName"), jsxText: ue("jsxText", { beforeExpr: !0 }), jsxTagStart: ue("jsxTagStart", { startsExpr: !0 }), jsxTagEnd: ue("jsxTagEnd"), placeholder: ue("%%", { startsExpr: !0 }) };
  function R(p) {
    return p >= 93 && p <= 132;
  }
  function Se(p) {
    return p <= 92;
  }
  function De(p) {
    return p >= 58 && p <= 132;
  }
  function Te(p) {
    return p >= 58 && p <= 136;
  }
  function tr(p) {
    return et[p];
  }
  function Mt(p) {
    return Fe[p];
  }
  function wt(p) {
    return p >= 29 && p <= 33;
  }
  function Ur(p) {
    return p >= 129 && p <= 131;
  }
  function fn(p) {
    return p >= 90 && p <= 92;
  }
  function cr(p) {
    return p >= 58 && p <= 92;
  }
  function Pr(p) {
    return p >= 39 && p <= 59;
  }
  function pi(p) {
    return p === 34;
  }
  function mn(p) {
    return mt[p];
  }
  function qi(p) {
    return p >= 121 && p <= 123;
  }
  function Xi(p) {
    return p >= 124 && p <= 130;
  }
  function di(p) {
    return Le[p];
  }
  function Us(p) {
    return ze[p];
  }
  function au(p) {
    return p === 57;
  }
  function zs(p) {
    return p >= 24 && p <= 25;
  }
  function zr(p) {
    return ve[p];
  }
  ve[8].updateContext = (p) => {
    p.pop();
  }, ve[5].updateContext = ve[7].updateContext = ve[23].updateContext = (p) => {
    p.push(I.brace);
  }, ve[22].updateContext = (p) => {
    p[p.length - 1] === I.template ? p.pop() : p.push(I.template);
  }, ve[142].updateContext = (p) => {
    p.push(I.j_expr, I.j_oTag);
  };
  var ao = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", ou = "-----------------------------------------------------------------------------------------------------------------------------------------------------", M = new RegExp("[" + ao + "]"), ne = new RegExp("[" + ao + ou + "]");
  ao = ou = null;
  var pe = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], $e = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Ye(p, l) {
    let f = 65536;
    for (let g = 0, D = l.length; g < D; g += 2) {
      if (f += l[g], f > p)
        return !1;
      if (f += l[g + 1], f >= p)
        return !0;
    }
    return !1;
  }
  function _e(p) {
    return p < 65 ? p === 36 : p <= 90 ? !0 : p < 97 ? p === 95 : p <= 122 ? !0 : p <= 65535 ? p >= 170 && M.test(String.fromCharCode(p)) : Ye(p, pe);
  }
  function Be(p) {
    return p < 48 ? p === 36 : p < 58 ? !0 : p < 65 ? !1 : p <= 90 ? !0 : p < 97 ? p === 95 : p <= 122 ? !0 : p <= 65535 ? p >= 170 && ne.test(String.fromCharCode(p)) : Ye(p, pe) || Ye(p, $e);
  }
  var Pe = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, Lt = new Set(Pe.keyword), Fr = new Set(Pe.strict), fi = new Set(Pe.strictBind);
  function Vi(p, l) {
    return l && p === "await" || p === "enum";
  }
  function Gs(p, l) {
    return Vi(p, l) || Fr.has(p);
  }
  function Ly(p) {
    return fi.has(p);
  }
  function Ry(p, l) {
    return Gs(p, l) || Ly(p);
  }
  function xk(p) {
    return Lt.has(p);
  }
  function bk(p, l, f) {
    return p === 64 && l === 64 && _e(f);
  }
  var Dk = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function vk(p) {
    return Dk.has(p);
  }
  var gp = class {
    constructor(p) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = p;
    }
  }, yp = class {
    constructor(p, l) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = p, this.inModule = l;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let p = this.currentThisScopeFlags();
      return (p & 64) > 0 && (p & 2) === 0;
    }
    get inStaticBlock() {
      for (let p = this.scopeStack.length - 1; ; p--) {
        let { flags: l } = this.scopeStack[p];
        if (l & 128)
          return !0;
        if (l & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(p) {
      return new gp(p);
    }
    enter(p) {
      this.scopeStack.push(this.createScope(p));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(p) {
      return !!(p.flags & 130 || !this.parser.inModule && p.flags & 1);
    }
    declareName(p, l, f) {
      let g = this.currentScope();
      if (l & 8 || l & 16) {
        this.checkRedeclarationInScope(g, p, l, f);
        let D = g.names.get(p) || 0;
        l & 16 ? D = D | 4 : (g.firstLexicalName || (g.firstLexicalName = p), D = D | 2), g.names.set(p, D), l & 8 && this.maybeExportDefined(g, p);
      } else if (l & 4)
        for (let D = this.scopeStack.length - 1; D >= 0 && (g = this.scopeStack[D], this.checkRedeclarationInScope(g, p, l, f), g.names.set(p, (g.names.get(p) || 0) | 1), this.maybeExportDefined(g, p), !(g.flags & 387)); --D)
          ;
      this.parser.inModule && g.flags & 1 && this.undefinedExports.delete(p);
    }
    maybeExportDefined(p, l) {
      this.parser.inModule && p.flags & 1 && this.undefinedExports.delete(l);
    }
    checkRedeclarationInScope(p, l, f, g) {
      this.isRedeclaredInScope(p, l, f) && this.parser.raise(x.VarRedeclaration, g, { identifierName: l });
    }
    isRedeclaredInScope(p, l, f) {
      if (!(f & 1))
        return !1;
      if (f & 8)
        return p.names.has(l);
      let g = p.names.get(l);
      return f & 16 ? (g & 2) > 0 || !this.treatFunctionsAsVarInScope(p) && (g & 1) > 0 : (g & 2) > 0 && !(p.flags & 8 && p.firstLexicalName === l) || !this.treatFunctionsAsVarInScope(p) && (g & 4) > 0;
    }
    checkLocalExport(p) {
      let { name: l } = p;
      this.scopeStack[0].names.has(l) || this.undefinedExports.set(l, p.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let p = this.scopeStack.length - 1; ; p--) {
        let { flags: l } = this.scopeStack[p];
        if (l & 387)
          return l;
      }
    }
    currentThisScopeFlags() {
      for (let p = this.scopeStack.length - 1; ; p--) {
        let { flags: l } = this.scopeStack[p];
        if (l & 451 && !(l & 4))
          return l;
      }
    }
  }, Sk = class extends gp {
    constructor(...p) {
      super(...p), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, wk = class extends yp {
    createScope(p) {
      return new Sk(p);
    }
    declareName(p, l, f) {
      let g = this.currentScope();
      if (l & 2048) {
        this.checkRedeclarationInScope(g, p, l, f), this.maybeExportDefined(g, p), g.declareFunctions.add(p);
        return;
      }
      super.declareName(p, l, f);
    }
    isRedeclaredInScope(p, l, f) {
      if (super.isRedeclaredInScope(p, l, f))
        return !0;
      if (f & 2048 && !p.declareFunctions.has(l)) {
        let g = p.names.get(l);
        return (g & 4) > 0 || (g & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(p) {
      this.scopeStack[0].declareFunctions.has(p.name) || super.checkLocalExport(p);
    }
  }, Ck = class {
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(p) {
      if (typeof p == "string")
        return this.plugins.has(p);
      {
        let [l, f] = p;
        if (!this.hasPlugin(l))
          return !1;
        let g = this.plugins.get(l);
        for (let D of Object.keys(f))
          if ((g == null ? void 0 : g[D]) !== f[D])
            return !1;
        return !0;
      }
    }
    getPluginOption(p, l) {
      var f;
      return (f = this.plugins.get(p)) == null ? void 0 : f[l];
    }
  };
  function jy(p, l) {
    p.trailingComments === void 0 ? p.trailingComments = l : p.trailingComments.unshift(...l);
  }
  function Ak(p, l) {
    p.leadingComments === void 0 ? p.leadingComments = l : p.leadingComments.unshift(...l);
  }
  function oo(p, l) {
    p.innerComments === void 0 ? p.innerComments = l : p.innerComments.unshift(...l);
  }
  function lo(p, l, f) {
    let g = null, D = l.length;
    for (; g === null && D > 0; )
      g = l[--D];
    g === null || g.start > f.start ? oo(p, f.comments) : jy(g, f.comments);
  }
  var Ek = class extends Ck {
    addComment(p) {
      this.filename && (p.loc.filename = this.filename);
      let { commentsLen: l } = this.state;
      this.comments.length != l && (this.comments.length = l), this.comments.push(p), this.state.commentsLen++;
    }
    processComment(p) {
      let { commentStack: l } = this.state, f = l.length;
      if (f === 0)
        return;
      let g = f - 1, D = l[g];
      D.start === p.end && (D.leadingNode = p, g--);
      let { start: A } = p;
      for (; g >= 0; g--) {
        let T = l[g], F = T.end;
        if (F > A)
          T.containingNode = p, this.finalizeComment(T), l.splice(g, 1);
        else {
          F === A && (T.trailingNode = p);
          break;
        }
      }
    }
    finalizeComment(p) {
      let { comments: l } = p;
      if (p.leadingNode !== null || p.trailingNode !== null)
        p.leadingNode !== null && jy(p.leadingNode, l), p.trailingNode !== null && Ak(p.trailingNode, l);
      else {
        let { containingNode: f, start: g } = p;
        if (this.input.charCodeAt(g - 1) === 44)
          switch (f.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              lo(f, f.properties, p);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              lo(f, f.arguments, p);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              lo(f, f.params, p);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              lo(f, f.elements, p);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              lo(f, f.specifiers, p);
              break;
            default:
              oo(f, l);
          }
        else
          oo(f, l);
      }
    }
    finalizeRemainingComments() {
      let { commentStack: p } = this.state;
      for (let l = p.length - 1; l >= 0; l--)
        this.finalizeComment(p[l]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(p) {
      let { commentStack: l } = this.state, { length: f } = l;
      if (f === 0)
        return;
      let g = l[f - 1];
      g.leadingNode === p && (g.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(p) {
      let { commentStack: l } = this.state, { length: f } = l;
      f !== 0 && (l[f - 1].trailingNode === p ? l[f - 1].trailingNode = null : f >= 2 && l[f - 2].trailingNode === p && (l[f - 2].trailingNode = null));
    }
    takeSurroundingComments(p, l, f) {
      let { commentStack: g } = this.state, D = g.length;
      if (D === 0)
        return;
      let A = D - 1;
      for (; A >= 0; A--) {
        let T = g[A], F = T.end;
        if (T.start === f)
          T.leadingNode = p;
        else if (F === l)
          T.trailingNode = p;
        else if (F < l)
          break;
      }
    }
  }, Zy = /\r\n?|[\n\u2028\u2029]/, lu = new RegExp(Zy.source, "g");
  function uo(p) {
    switch (p) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  var Op = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, uu = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, Wy = new RegExp("(?=(" + uu.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function kk(p) {
    switch (p) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  var Tk = class bw {
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [I.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(l) {
      l ? this.flags |= 1 : this.flags &= -2;
    }
    init({ strictMode: l, sourceType: f, startLine: g, startColumn: D }) {
      this.strict = l === !1 ? !1 : l === !0 ? !0 : f === "module", this.curLine = g, this.lineStart = -D, this.startLoc = this.endLoc = new r(g, D, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(l) {
      l ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(l) {
      l ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(l) {
      l ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(l) {
      l ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(l) {
      l ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(l) {
      l ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(l) {
      l ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(l) {
      l ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(l) {
      l ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(l) {
      l ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(l) {
      l ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new r(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      let l = new bw();
      return l.flags = this.flags, l.curLine = this.curLine, l.lineStart = this.lineStart, l.startLoc = this.startLoc, l.endLoc = this.endLoc, l.errors = this.errors.slice(), l.potentialArrowAt = this.potentialArrowAt, l.noArrowAt = this.noArrowAt.slice(), l.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), l.topicContext = this.topicContext, l.labels = this.labels.slice(), l.commentsLen = this.commentsLen, l.commentStack = this.commentStack.slice(), l.pos = this.pos, l.type = this.type, l.value = this.value, l.start = this.start, l.end = this.end, l.lastTokEndLoc = this.lastTokEndLoc, l.lastTokStartLoc = this.lastTokStartLoc, l.context = this.context.slice(), l.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, l.strictErrors = this.strictErrors, l.tokensLength = this.tokensLength, l;
    }
  }, Pk = function(p) {
    return p >= 48 && p <= 57;
  }, qy = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, cu = { bin: (p) => p === 48 || p === 49, oct: (p) => p >= 48 && p <= 55, dec: (p) => p >= 48 && p <= 57, hex: (p) => p >= 48 && p <= 57 || p >= 65 && p <= 70 || p >= 97 && p <= 102 };
  function Xy(p, l, f, g, D, A) {
    let T = f, F = g, N = D, $ = "", Y = null, ie = f, { length: ce } = l;
    for (; ; ) {
      if (f >= ce) {
        A.unterminated(T, F, N), $ += l.slice(ie, f);
        break;
      }
      let le = l.charCodeAt(f);
      if (Fk(p, le, l, f)) {
        $ += l.slice(ie, f);
        break;
      }
      if (le === 92) {
        $ += l.slice(ie, f);
        let Ve = $k(l, f, g, D, p === "template", A);
        Ve.ch === null && !Y ? Y = { pos: f, lineStart: g, curLine: D } : $ += Ve.ch, { pos: f, lineStart: g, curLine: D } = Ve, ie = f;
      } else
        le === 8232 || le === 8233 ? (++f, ++D, g = f) : le === 10 || le === 13 ? p === "template" ? ($ += l.slice(ie, f) + `
`, ++f, le === 13 && l.charCodeAt(f) === 10 && ++f, ++D, ie = g = f) : A.unterminated(T, F, N) : ++f;
    }
    return { pos: f, str: $, firstInvalidLoc: Y, lineStart: g, curLine: D, containsInvalid: !!Y };
  }
  function Fk(p, l, f, g) {
    return p === "template" ? l === 96 || l === 36 && f.charCodeAt(g + 1) === 123 : l === (p === "double" ? 34 : 39);
  }
  function $k(p, l, f, g, D, A) {
    let T = !D;
    l++;
    let F = ($) => ({ pos: l, ch: $, lineStart: f, curLine: g }), N = p.charCodeAt(l++);
    switch (N) {
      case 110:
        return F(`
`);
      case 114:
        return F("\r");
      case 120: {
        let $;
        return { code: $, pos: l } = xp(p, l, f, g, 2, !1, T, A), F($ === null ? null : String.fromCharCode($));
      }
      case 117: {
        let $;
        return { code: $, pos: l } = Yy(p, l, f, g, T, A), F($ === null ? null : String.fromCodePoint($));
      }
      case 116:
        return F("	");
      case 98:
        return F("\b");
      case 118:
        return F("\v");
      case 102:
        return F("\f");
      case 13:
        p.charCodeAt(l) === 10 && ++l;
      case 10:
        f = l, ++g;
      case 8232:
      case 8233:
        return F("");
      case 56:
      case 57:
        if (D)
          return F(null);
        A.strictNumericEscape(l - 1, f, g);
      default:
        if (N >= 48 && N <= 55) {
          let $ = l - 1, Y = p.slice($, l + 2).match(/^[0-7]+/)[0], ie = parseInt(Y, 8);
          ie > 255 && (Y = Y.slice(0, -1), ie = parseInt(Y, 8)), l += Y.length - 1;
          let ce = p.charCodeAt(l);
          if (Y !== "0" || ce === 56 || ce === 57) {
            if (D)
              return F(null);
            A.strictNumericEscape($, f, g);
          }
          return F(String.fromCharCode(ie));
        }
        return F(String.fromCharCode(N));
    }
  }
  function xp(p, l, f, g, D, A, T, F) {
    let N = l, $;
    return { n: $, pos: l } = Vy(p, l, f, g, 16, D, A, !1, F, !T), $ === null && (T ? F.invalidEscapeSequence(N, f, g) : l = N - 1), { code: $, pos: l };
  }
  function Vy(p, l, f, g, D, A, T, F, N, $) {
    let Y = l, ie = D === 16 ? qy.hex : qy.decBinOct, ce = D === 16 ? cu.hex : D === 10 ? cu.dec : D === 8 ? cu.oct : cu.bin, le = !1, Ve = 0;
    for (let Xe = 0, Ot = A ?? 1 / 0; Xe < Ot; ++Xe) {
      let Rt = p.charCodeAt(l), hr;
      if (Rt === 95 && F !== "bail") {
        let wp = p.charCodeAt(l - 1), Cp = p.charCodeAt(l + 1);
        if (F) {
          if (Number.isNaN(Cp) || !ce(Cp) || ie.has(wp) || ie.has(Cp)) {
            if ($)
              return { n: null, pos: l };
            N.unexpectedNumericSeparator(l, f, g);
          }
        } else {
          if ($)
            return { n: null, pos: l };
          N.numericSeparatorInEscapeSequence(l, f, g);
        }
        ++l;
        continue;
      }
      if (Rt >= 97 ? hr = Rt - 97 + 10 : Rt >= 65 ? hr = Rt - 65 + 10 : Pk(Rt) ? hr = Rt - 48 : hr = 1 / 0, hr >= D) {
        if (hr <= 9 && $)
          return { n: null, pos: l };
        if (hr <= 9 && N.invalidDigit(l, f, g, D))
          hr = 0;
        else if (T)
          hr = 0, le = !0;
        else
          break;
      }
      ++l, Ve = Ve * D + hr;
    }
    return l === Y || A != null && l - Y !== A || le ? { n: null, pos: l } : { n: Ve, pos: l };
  }
  function Yy(p, l, f, g, D, A) {
    let T = p.charCodeAt(l), F;
    if (T === 123) {
      if (++l, { code: F, pos: l } = xp(p, l, f, g, p.indexOf("}", l) - l, !0, D, A), ++l, F !== null && F > 1114111)
        if (D)
          A.invalidCodePoint(l, f, g);
        else
          return { code: null, pos: l };
    } else
      ({ code: F, pos: l } = xp(p, l, f, g, 4, !1, D, A));
    return { code: F, pos: l };
  }
  function co(p, l, f) {
    return new r(f, p - l, p);
  }
  var Bk = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), gn = class {
    constructor(p) {
      this.type = p.type, this.value = p.value, this.start = p.start, this.end = p.end, this.loc = new i(p.startLoc, p.endLoc);
    }
  }, Ik = class extends Ek {
    constructor(p, l) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (f, g, D, A) => this.options.errorRecovery ? (this.raise(x.InvalidDigit, co(f, g, D), { radix: A }), !0) : !1, numericSeparatorInEscapeSequence: this.errorBuilder(x.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(x.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(x.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(x.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (f, g, D) => {
        this.recordStrictModeErrors(x.StrictNumericEscape, co(f, g, D));
      }, unterminated: (f, g, D) => {
        throw this.raise(x.UnterminatedString, co(f - 1, g, D));
      } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(x.StrictNumericEscape), unterminated: (f, g, D) => {
        throw this.raise(x.UnterminatedTemplate, co(f, g, D));
      } }), this.state = new Tk(), this.state.init(p), this.input = l, this.length = l.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(p) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(p), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new gn(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(p) {
      return this.match(p) ? (this.next(), !0) : !1;
    }
    match(p) {
      return this.state.type === p;
    }
    createLookaheadState(p) {
      return { pos: p.pos, value: null, type: p.type, start: p.start, end: p.end, context: [this.curContext()], inType: p.inType, startLoc: p.startLoc, lastTokEndLoc: p.lastTokEndLoc, curLine: p.curLine, lineStart: p.lineStart, curPosition: p.curPosition };
    }
    lookahead() {
      let p = this.state;
      this.state = this.createLookaheadState(p), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let l = this.state;
      return this.state = p, l;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(p) {
      return Op.lastIndex = p, Op.test(this.input) ? Op.lastIndex : p;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(p) {
      return uu.lastIndex = p, uu.test(this.input) ? uu.lastIndex : p;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(p) {
      let l = this.input.charCodeAt(p);
      if ((l & 64512) === 55296 && ++p < this.input.length) {
        let f = this.input.charCodeAt(p);
        (f & 64512) === 56320 && (l = 65536 + ((l & 1023) << 10) + (f & 1023));
      }
      return l;
    }
    setStrict(p) {
      this.state.strict = p, p && (this.state.strictErrors.forEach(([l, f]) => this.raise(l, f)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(p) {
      let l;
      this.isLookahead || (l = this.state.curPosition());
      let f = this.state.pos, g = this.input.indexOf(p, f + 2);
      if (g === -1)
        throw this.raise(x.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = g + p.length, lu.lastIndex = f + 2; lu.test(this.input) && lu.lastIndex <= g; )
        ++this.state.curLine, this.state.lineStart = lu.lastIndex;
      if (this.isLookahead)
        return;
      let D = { type: "CommentBlock", value: this.input.slice(f + 2, g), start: f, end: g + p.length, loc: new i(l, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(D), D;
    }
    skipLineComment(p) {
      let l = this.state.pos, f;
      this.isLookahead || (f = this.state.curPosition());
      let g = this.input.charCodeAt(this.state.pos += p);
      if (this.state.pos < this.length)
        for (; !uo(g) && ++this.state.pos < this.length; )
          g = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead)
        return;
      let D = this.state.pos, A = { type: "CommentLine", value: this.input.slice(l + p, D), start: l, end: D, loc: new i(f, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(A), A;
    }
    skipSpace() {
      let p = this.state.pos, l = [];
      e:
        for (; this.state.pos < this.length; ) {
          let f = this.input.charCodeAt(this.state.pos);
          switch (f) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  let g = this.skipBlockComment("*/");
                  g !== void 0 && (this.addComment(g), this.options.attachComment && l.push(g));
                  break;
                }
                case 47: {
                  let g = this.skipLineComment(2);
                  g !== void 0 && (this.addComment(g), this.options.attachComment && l.push(g));
                  break;
                }
                default:
                  break e;
              }
              break;
            default:
              if (kk(f))
                ++this.state.pos;
              else if (f === 45 && !this.inModule && this.options.annexB) {
                let g = this.state.pos;
                if (this.input.charCodeAt(g + 1) === 45 && this.input.charCodeAt(g + 2) === 62 && (p === 0 || this.state.lineStart > p)) {
                  let D = this.skipLineComment(3);
                  D !== void 0 && (this.addComment(D), this.options.attachComment && l.push(D));
                } else
                  break e;
              } else if (f === 60 && !this.inModule && this.options.annexB) {
                let g = this.state.pos;
                if (this.input.charCodeAt(g + 1) === 33 && this.input.charCodeAt(g + 2) === 45 && this.input.charCodeAt(g + 3) === 45) {
                  let D = this.skipLineComment(4);
                  D !== void 0 && (this.addComment(D), this.options.attachComment && l.push(D));
                } else
                  break e;
              } else
                break e;
          }
        }
      if (l.length > 0) {
        let f = this.state.pos, g = { start: p, end: f, comments: l, leadingNode: null, trailingNode: null, containingNode: null };
        this.state.commentStack.push(g);
      }
    }
    finishToken(p, l) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let f = this.state.type;
      this.state.type = p, this.state.value = l, this.isLookahead || this.updateContext(f);
    }
    replaceToken(p) {
      this.state.type = p, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let p = this.state.pos + 1, l = this.codePointAtPos(p);
      if (l >= 48 && l <= 57)
        throw this.raise(x.UnexpectedDigitAfterHash, this.state.curPosition());
      if (l === 123 || l === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(l === 123 ? x.RecordExpressionHashIncorrectStartSyntaxType : x.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        this.state.pos += 2, l === 123 ? this.finishToken(7) : this.finishToken(1);
      } else
        _e(l) ? (++this.state.pos, this.finishToken(138, this.readWord1(l))) : l === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let p = this.input.charCodeAt(this.state.pos + 1);
      if (p >= 48 && p <= 57) {
        this.readNumber(!0);
        return;
      }
      p === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return !1;
      let p = this.input.charCodeAt(this.state.pos + 1);
      if (p !== 33)
        return !1;
      let l = this.state.pos;
      for (this.state.pos += 1; !uo(p) && ++this.state.pos < this.length; )
        p = this.input.charCodeAt(this.state.pos);
      let f = this.input.slice(l + 2, this.state.pos);
      return this.finishToken(28, f), !0;
    }
    readToken_mult_modulo(p) {
      let l = p === 42 ? 55 : 54, f = 1, g = this.input.charCodeAt(this.state.pos + 1);
      p === 42 && g === 42 && (f++, g = this.input.charCodeAt(this.state.pos + 2), l = 57), g === 61 && !this.state.inType && (f++, l = p === 37 ? 33 : 30), this.finishOp(l, f);
    }
    readToken_pipe_amp(p) {
      let l = this.input.charCodeAt(this.state.pos + 1);
      if (l === p) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(p === 124 ? 41 : 42, 2);
        return;
      }
      if (p === 124) {
        if (l === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && l === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(x.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && l === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(x.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (l === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(p === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let p = this.input.charCodeAt(this.state.pos + 1);
      p === 61 && !this.state.inType ? this.finishOp(32, 2) : p === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(p) {
      let l = this.input.charCodeAt(this.state.pos + 1);
      if (l === p) {
        this.finishOp(34, 2);
        return;
      }
      l === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let { pos: p } = this.state, l = this.input.charCodeAt(p + 1);
      if (l === 60) {
        if (this.input.charCodeAt(p + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (l === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let { pos: p } = this.state, l = this.input.charCodeAt(p + 1);
      if (l === 62) {
        let f = this.input.charCodeAt(p + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(p + f) === 61) {
          this.finishOp(30, f + 1);
          return;
        }
        this.finishOp(52, f);
        return;
      }
      if (l === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(p) {
      let l = this.input.charCodeAt(this.state.pos + 1);
      if (l === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (p === 61 && l === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(p === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let p = this.input.charCodeAt(this.state.pos + 1), l = this.input.charCodeAt(this.state.pos + 2);
      p === 63 ? l === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : p === 46 && !(l >= 48 && l <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(p) {
      switch (p) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(x.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(x.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let l = this.input.charCodeAt(this.state.pos + 1);
          if (l === 120 || l === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (l === 111 || l === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (l === 98 || l === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(p);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(p);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(p);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(p);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(p);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (_e(p)) {
            this.readWord(p);
            return;
          }
      }
      throw this.raise(x.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(p) });
    }
    finishOp(p, l) {
      let f = this.input.slice(this.state.pos, this.state.pos + l);
      this.state.pos += l, this.finishToken(p, f);
    }
    readRegexp() {
      let p = this.state.startLoc, l = this.state.start + 1, f, g, { pos: D } = this.state;
      for (; ; ++D) {
        if (D >= this.length)
          throw this.raise(x.UnterminatedRegExp, n(p, 1));
        let N = this.input.charCodeAt(D);
        if (uo(N))
          throw this.raise(x.UnterminatedRegExp, n(p, 1));
        if (f)
          f = !1;
        else {
          if (N === 91)
            g = !0;
          else if (N === 93 && g)
            g = !1;
          else if (N === 47 && !g)
            break;
          f = N === 92;
        }
      }
      let A = this.input.slice(l, D);
      ++D;
      let T = "", F = () => n(p, D + 2 - l);
      for (; D < this.length; ) {
        let N = this.codePointAtPos(D), $ = String.fromCharCode(N);
        if (Bk.has(N))
          N === 118 ? T.includes("u") && this.raise(x.IncompatibleRegExpUVFlags, F()) : N === 117 && T.includes("v") && this.raise(x.IncompatibleRegExpUVFlags, F()), T.includes($) && this.raise(x.DuplicateRegExpFlags, F());
        else if (Be(N) || N === 92)
          this.raise(x.MalformedRegExpFlags, F());
        else
          break;
        ++D, T += $;
      }
      this.state.pos = D, this.finishToken(137, { pattern: A, flags: T });
    }
    readInt(p, l, f = !1, g = !0) {
      let { n: D, pos: A } = Vy(this.input, this.state.pos, this.state.lineStart, this.state.curLine, p, l, f, g, this.errorHandlers_readInt, !1);
      return this.state.pos = A, D;
    }
    readRadixNumber(p) {
      let l = this.state.curPosition(), f = !1;
      this.state.pos += 2;
      let g = this.readInt(p);
      g == null && this.raise(x.InvalidDigit, n(l, 2), { radix: p });
      let D = this.input.charCodeAt(this.state.pos);
      if (D === 110)
        ++this.state.pos, f = !0;
      else if (D === 109)
        throw this.raise(x.InvalidDecimal, l);
      if (_e(this.codePointAtPos(this.state.pos)))
        throw this.raise(x.NumberIdentifier, this.state.curPosition());
      if (f) {
        let A = this.input.slice(l.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, A);
        return;
      }
      this.finishToken(134, g);
    }
    readNumber(p) {
      let l = this.state.pos, f = this.state.curPosition(), g = !1, D = !1, A = !1, T = !1, F = !1;
      !p && this.readInt(10) === null && this.raise(x.InvalidNumber, this.state.curPosition());
      let N = this.state.pos - l >= 2 && this.input.charCodeAt(l) === 48;
      if (N) {
        let ce = this.input.slice(l, this.state.pos);
        if (this.recordStrictModeErrors(x.StrictOctalLiteral, f), !this.state.strict) {
          let le = ce.indexOf("_");
          le > 0 && this.raise(x.ZeroDigitNumericSeparator, n(f, le));
        }
        F = N && !/[89]/.test(ce);
      }
      let $ = this.input.charCodeAt(this.state.pos);
      if ($ === 46 && !F && (++this.state.pos, this.readInt(10), g = !0, $ = this.input.charCodeAt(this.state.pos)), ($ === 69 || $ === 101) && !F && ($ = this.input.charCodeAt(++this.state.pos), ($ === 43 || $ === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(x.InvalidOrMissingExponent, f), g = !0, T = !0, $ = this.input.charCodeAt(this.state.pos)), $ === 110 && ((g || N) && this.raise(x.InvalidBigIntLiteral, f), ++this.state.pos, D = !0), $ === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (T || N) && this.raise(x.InvalidDecimal, f), ++this.state.pos, A = !0), _e(this.codePointAtPos(this.state.pos)))
        throw this.raise(x.NumberIdentifier, this.state.curPosition());
      let Y = this.input.slice(l, this.state.pos).replace(/[_mn]/g, "");
      if (D) {
        this.finishToken(135, Y);
        return;
      }
      if (A) {
        this.finishToken(136, Y);
        return;
      }
      let ie = F ? parseInt(Y, 8) : parseFloat(Y);
      this.finishToken(134, ie);
    }
    readCodePoint(p) {
      let { code: l, pos: f } = Yy(this.input, this.state.pos, this.state.lineStart, this.state.curLine, p, this.errorHandlers_readCodePoint);
      return this.state.pos = f, l;
    }
    readString(p) {
      let { str: l, pos: f, curLine: g, lineStart: D } = Xy(p === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = f + 1, this.state.lineStart = D, this.state.curLine = g, this.finishToken(133, l);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let p = this.input[this.state.pos], { str: l, firstInvalidLoc: f, pos: g, curLine: D, lineStart: A } = Xy("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = g + 1, this.state.lineStart = A, this.state.curLine = D, f && (this.state.firstInvalidTemplateEscapePos = new r(f.curLine, f.pos - f.lineStart, f.pos)), this.input.codePointAt(g) === 96 ? this.finishToken(24, f ? null : p + l + "`") : (this.state.pos++, this.finishToken(25, f ? null : p + l + "${"));
    }
    recordStrictModeErrors(p, l) {
      let f = l.index;
      this.state.strict && !this.state.strictErrors.has(f) ? this.raise(p, l) : this.state.strictErrors.set(f, [p, l]);
    }
    readWord1(p) {
      this.state.containsEsc = !1;
      let l = "", f = this.state.pos, g = this.state.pos;
      for (p !== void 0 && (this.state.pos += p <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let D = this.codePointAtPos(this.state.pos);
        if (Be(D))
          this.state.pos += D <= 65535 ? 1 : 2;
        else if (D === 92) {
          this.state.containsEsc = !0, l += this.input.slice(g, this.state.pos);
          let A = this.state.curPosition(), T = this.state.pos === f ? _e : Be;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(x.MissingUnicodeEscape, this.state.curPosition()), g = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let F = this.readCodePoint(!0);
          F !== null && (T(F) || this.raise(x.EscapedCharNotAnIdentifier, A), l += String.fromCodePoint(F)), g = this.state.pos;
        } else
          break;
      }
      return l + this.input.slice(g, this.state.pos);
    }
    readWord(p) {
      let l = this.readWord1(p), f = X.get(l);
      f !== void 0 ? this.finishToken(f, di(f)) : this.finishToken(132, l);
    }
    checkKeywordEscapes() {
      let { type: p } = this.state;
      cr(p) && this.state.containsEsc && this.raise(x.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: di(p) });
    }
    raise(p, l, f = {}) {
      let g = l instanceof r ? l : l.loc.start, D = p(g, f);
      if (!this.options.errorRecovery)
        throw D;
      return this.isLookahead || this.state.errors.push(D), D;
    }
    raiseOverwrite(p, l, f = {}) {
      let g = l instanceof r ? l : l.loc.start, D = g.index, A = this.state.errors;
      for (let T = A.length - 1; T >= 0; T--) {
        let F = A[T];
        if (F.loc.index === D)
          return A[T] = p(g, f);
        if (F.loc.index < D)
          break;
      }
      return this.raise(p, l, f);
    }
    updateContext(p) {
    }
    unexpected(p, l) {
      throw this.raise(x.UnexpectedToken, p ?? this.state.startLoc, { expected: l ? di(l) : null });
    }
    expectPlugin(p, l) {
      if (this.hasPlugin(p))
        return !0;
      throw this.raise(x.MissingPlugin, l ?? this.state.startLoc, { missingPlugin: [p] });
    }
    expectOnePlugin(p) {
      if (!p.some((l) => this.hasPlugin(l)))
        throw this.raise(x.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: p });
    }
    errorBuilder(p) {
      return (l, f, g) => {
        this.raise(p, co(l, f, g));
      };
    }
  }, Nk = class {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, _k = class {
    constructor(p) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = p;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new Nk());
    }
    exit() {
      let p = this.stack.pop(), l = this.current();
      for (let [f, g] of Array.from(p.undefinedPrivateNames))
        l ? l.undefinedPrivateNames.has(f) || l.undefinedPrivateNames.set(f, g) : this.parser.raise(x.InvalidPrivateFieldResolution, g, { identifierName: f });
    }
    declarePrivateName(p, l, f) {
      let { privateNames: g, loneAccessors: D, undefinedPrivateNames: A } = this.current(), T = g.has(p);
      if (l & 3) {
        let F = T && D.get(p);
        if (F) {
          let N = F & 4, $ = l & 4, Y = F & 3, ie = l & 3;
          T = Y === ie || N !== $, T || D.delete(p);
        } else
          T || D.set(p, l);
      }
      T && this.parser.raise(x.PrivateNameRedeclaration, f, { identifierName: p }), g.add(p), A.delete(p);
    }
    usePrivateName(p, l) {
      let f;
      for (f of this.stack)
        if (f.privateNames.has(p))
          return;
      f ? f.undefinedPrivateNames.set(p, l) : this.parser.raise(x.InvalidPrivateFieldResolution, l, { identifierName: p });
    }
  }, hu = class {
    constructor(p = 0) {
      this.type = p;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, Uy = class extends hu {
    constructor(p) {
      super(p), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(p, l) {
      let f = l.index;
      this.declarationErrors.set(f, [p, l]);
    }
    clearDeclarationError(p) {
      this.declarationErrors.delete(p);
    }
    iterateErrors(p) {
      this.declarationErrors.forEach(p);
    }
  }, Qk = class {
    constructor(p) {
      this.parser = void 0, this.stack = [new hu()], this.parser = p;
    }
    enter(p) {
      this.stack.push(p);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(p, l) {
      let f = l.loc.start, { stack: g } = this, D = g.length - 1, A = g[D];
      for (; !A.isCertainlyParameterDeclaration(); ) {
        if (A.canBeArrowParameterDeclaration())
          A.recordDeclarationError(p, f);
        else
          return;
        A = g[--D];
      }
      this.parser.raise(p, f);
    }
    recordArrowParameterBindingError(p, l) {
      let { stack: f } = this, g = f[f.length - 1], D = l.loc.start;
      if (g.isCertainlyParameterDeclaration())
        this.parser.raise(p, D);
      else if (g.canBeArrowParameterDeclaration())
        g.recordDeclarationError(p, D);
      else
        return;
    }
    recordAsyncArrowParametersError(p) {
      let { stack: l } = this, f = l.length - 1, g = l[f];
      for (; g.canBeArrowParameterDeclaration(); )
        g.type === 2 && g.recordDeclarationError(x.AwaitBindingIdentifier, p), g = l[--f];
    }
    validateAsPattern() {
      let { stack: p } = this, l = p[p.length - 1];
      l.canBeArrowParameterDeclaration() && l.iterateErrors(([f, g]) => {
        this.parser.raise(f, g);
        let D = p.length - 2, A = p[D];
        for (; A.canBeArrowParameterDeclaration(); )
          A.clearDeclarationError(g.index), A = p[--D];
      });
    }
  };
  function Mk() {
    return new hu(3);
  }
  function Lk() {
    return new Uy(1);
  }
  function Rk() {
    return new Uy(2);
  }
  function zy() {
    return new hu();
  }
  var jk = class {
    constructor() {
      this.stacks = [];
    }
    enter(p) {
      this.stacks.push(p);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function pu(p, l) {
    return (p ? 2 : 0) | (l ? 1 : 0);
  }
  var Zk = class extends Ik {
    addExtra(p, l, f, g = !0) {
      if (!p)
        return;
      let D = p.extra = p.extra || {};
      g ? D[l] = f : Object.defineProperty(D, l, { enumerable: g, value: f });
    }
    isContextual(p) {
      return this.state.type === p && !this.state.containsEsc;
    }
    isUnparsedContextual(p, l) {
      let f = p + l.length;
      if (this.input.slice(p, f) === l) {
        let g = this.input.charCodeAt(f);
        return !(Be(g) || (g & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(p) {
      let l = this.nextTokenStart();
      return this.isUnparsedContextual(l, p);
    }
    eatContextual(p) {
      return this.isContextual(p) ? (this.next(), !0) : !1;
    }
    expectContextual(p, l) {
      if (!this.eatContextual(p)) {
        if (l != null)
          throw this.raise(l, this.state.startLoc);
        this.unexpected(null, p);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return Zy.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return Wy.lastIndex = this.state.end, Wy.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(p = !0) {
      (p ? this.isLineTerminator() : this.eat(13)) || this.raise(x.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(p, l) {
      this.eat(p) || this.unexpected(l, p);
    }
    tryParse(p, l = this.state.clone()) {
      let f = { node: null };
      try {
        let g = p((D = null) => {
          throw f.node = D, f;
        });
        if (this.state.errors.length > l.errors.length) {
          let D = this.state;
          return this.state = l, this.state.tokensLength = D.tokensLength, { node: g, error: D.errors[l.errors.length], thrown: !1, aborted: !1, failState: D };
        }
        return { node: g, error: null, thrown: !1, aborted: !1, failState: null };
      } catch (g) {
        let D = this.state;
        if (this.state = l, g instanceof SyntaxError)
          return { node: null, error: g, thrown: !0, aborted: !1, failState: D };
        if (g === f)
          return { node: f.node, error: null, thrown: !1, aborted: !0, failState: D };
        throw g;
      }
    }
    checkExpressionErrors(p, l) {
      if (!p)
        return !1;
      let { shorthandAssignLoc: f, doubleProtoLoc: g, privateKeyLoc: D, optionalParametersLoc: A } = p, T = !!f || !!g || !!A || !!D;
      if (!l)
        return T;
      f != null && this.raise(x.InvalidCoverInitializedName, f), g != null && this.raise(x.DuplicateProto, g), D != null && this.raise(x.UnexpectedPrivateField, D), A != null && this.unexpected(A);
    }
    isLiteralPropertyName() {
      return Te(this.state.type);
    }
    isPrivateName(p) {
      return p.type === "PrivateName";
    }
    getPrivateNameSV(p) {
      return p.id.name;
    }
    hasPropertyAsPrivateName(p) {
      return (p.type === "MemberExpression" || p.type === "OptionalMemberExpression") && this.isPrivateName(p.property);
    }
    isObjectProperty(p) {
      return p.type === "ObjectProperty";
    }
    isObjectMethod(p) {
      return p.type === "ObjectMethod";
    }
    initializeScopes(p = this.options.sourceType === "module") {
      let l = this.state.labels;
      this.state.labels = [];
      let f = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let g = this.inModule;
      this.inModule = p;
      let D = this.scope, A = this.getScopeHandler();
      this.scope = new A(this, p);
      let T = this.prodParam;
      this.prodParam = new jk();
      let F = this.classScope;
      this.classScope = new _k(this);
      let N = this.expressionScope;
      return this.expressionScope = new Qk(this), () => {
        this.state.labels = l, this.exportedIdentifiers = f, this.inModule = g, this.scope = D, this.prodParam = T, this.classScope = F, this.expressionScope = N;
      };
    }
    enterInitialScopes() {
      let p = 0;
      this.inModule && (p |= 2), this.scope.enter(1), this.prodParam.enter(p);
    }
    checkDestructuringPrivate(p) {
      let { privateKeyLoc: l } = p;
      l !== null && this.expectPlugin("destructuringPrivate", l);
    }
  }, du = class {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, fu = class {
    constructor(p, l, f) {
      this.type = "", this.start = l, this.end = 0, this.loc = new i(f), p != null && p.options.ranges && (this.range = [l, 0]), p != null && p.filename && (this.loc.filename = p.filename);
    }
  }, bp = fu.prototype;
  bp.__clone = function() {
    let p = new fu(void 0, this.start, this.loc.start), l = Object.keys(this);
    for (let f = 0, g = l.length; f < g; f++) {
      let D = l[f];
      D !== "leadingComments" && D !== "trailingComments" && D !== "innerComments" && (p[D] = this[D]);
    }
    return p;
  };
  function Wk(p) {
    return Yi(p);
  }
  function Yi(p) {
    let { type: l, start: f, end: g, loc: D, range: A, extra: T, name: F } = p, N = Object.create(bp);
    return N.type = l, N.start = f, N.end = g, N.loc = D, N.range = A, N.extra = T, N.name = F, l === "Placeholder" && (N.expectedNode = p.expectedNode), N;
  }
  function qk(p) {
    let { type: l, start: f, end: g, loc: D, range: A, extra: T } = p;
    if (l === "Placeholder")
      return Wk(p);
    let F = Object.create(bp);
    return F.type = l, F.start = f, F.end = g, F.loc = D, F.range = A, p.raw !== void 0 ? F.raw = p.raw : F.extra = T, F.value = p.value, F;
  }
  var Xk = class extends Zk {
    startNode() {
      let p = this.state.startLoc;
      return new fu(this, p.index, p);
    }
    startNodeAt(p) {
      return new fu(this, p.index, p);
    }
    startNodeAtNode(p) {
      return this.startNodeAt(p.loc.start);
    }
    finishNode(p, l) {
      return this.finishNodeAt(p, l, this.state.lastTokEndLoc);
    }
    finishNodeAt(p, l, f) {
      return p.type = l, p.end = f.index, p.loc.end = f, this.options.ranges && (p.range[1] = f.index), this.options.attachComment && this.processComment(p), p;
    }
    resetStartLocation(p, l) {
      p.start = l.index, p.loc.start = l, this.options.ranges && (p.range[0] = l.index);
    }
    resetEndLocation(p, l = this.state.lastTokEndLoc) {
      p.end = l.index, p.loc.end = l, this.options.ranges && (p.range[1] = l.index);
    }
    resetStartLocationFromNode(p, l) {
      this.resetStartLocation(p, l.loc.start);
    }
  }, Vk = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), be = S`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: p }) => `Cannot overwrite reserved type ${p}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: p, enumName: l }) => `Boolean enum members need to be initialized. Use either \`${p} = true,\` or \`${p} = false,\` in enum \`${l}\`.`, EnumDuplicateMemberName: ({ memberName: p, enumName: l }) => `Enum member names need to be unique, but the name \`${p}\` has already been used before in enum \`${l}\`.`, EnumInconsistentMemberValues: ({ enumName: p }) => `Enum \`${p}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: p, enumName: l }) => `Enum type \`${p}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${l}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: p }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${p}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: p, memberName: l, explicitType: f }) => `Enum \`${p}\` has type \`${f}\`, so the initializer of \`${l}\` needs to be a ${f} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: p, memberName: l }) => `Symbol enum members cannot be initialized. Use \`${l},\` in enum \`${p}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: p, memberName: l }) => `The enum member initializer for \`${l}\` needs to be a literal (either a boolean, number, or string) in enum \`${p}\`.`, EnumInvalidMemberName: ({ enumName: p, memberName: l, suggestion: f }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${l}\`, consider using \`${f}\`, in enum \`${p}\`.`, EnumNumberMemberNotInitialized: ({ enumName: p, memberName: l }) => `Number enum members need to be initialized, e.g. \`${l} = 1\` in enum \`${p}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: p }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${p}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: p }) => `Unexpected reserved type ${p}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: p, suggestion: l }) => `\`declare export ${p}\` is not supported. Use \`${l}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
  function Yk(p) {
    return p.type === "DeclareExportAllDeclaration" || p.type === "DeclareExportDeclaration" && (!p.declaration || p.declaration.type !== "TypeAlias" && p.declaration.type !== "InterfaceDeclaration");
  }
  function Gy(p) {
    return p.importKind === "type" || p.importKind === "typeof";
  }
  var Uk = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
  function zk(p, l) {
    let f = [], g = [];
    for (let D = 0; D < p.length; D++)
      (l(p[D], D, p) ? f : g).push(p[D]);
    return [f, g];
  }
  var Gk = /\*?\s*@((?:no)?flow)\b/, Hk = (p) => class extends p {
    constructor(...l) {
      super(...l), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return wk;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(l, f) {
      l !== 133 && l !== 13 && l !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(l, f);
    }
    addComment(l) {
      if (this.flowPragma === void 0) {
        let f = Gk.exec(l.value);
        if (f)
          if (f[1] === "flow")
            this.flowPragma = "flow";
          else if (f[1] === "noflow")
            this.flowPragma = "noflow";
          else
            throw new Error("Unexpected flow pragma");
      }
      super.addComment(l);
    }
    flowParseTypeInitialiser(l) {
      let f = this.state.inType;
      this.state.inType = !0, this.expect(l || 14);
      let g = this.flowParseType();
      return this.state.inType = f, g;
    }
    flowParsePredicate() {
      let l = this.startNode(), f = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > f.index + 1 && this.raise(be.UnexpectedSpaceBetweenModuloChecks, f), this.eat(10) ? (l.value = super.parseExpression(), this.expect(11), this.finishNode(l, "DeclaredPredicate")) : this.finishNode(l, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let l = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let f = null, g = null;
      return this.match(54) ? (this.state.inType = l, g = this.flowParsePredicate()) : (f = this.flowParseType(), this.state.inType = l, this.match(54) && (g = this.flowParsePredicate())), [f, g];
    }
    flowParseDeclareClass(l) {
      return this.next(), this.flowParseInterfaceish(l, !0), this.finishNode(l, "DeclareClass");
    }
    flowParseDeclareFunction(l) {
      this.next();
      let f = l.id = this.parseIdentifier(), g = this.startNode(), D = this.startNode();
      this.match(47) ? g.typeParameters = this.flowParseTypeParameterDeclaration() : g.typeParameters = null, this.expect(10);
      let A = this.flowParseFunctionTypeParams();
      return g.params = A.params, g.rest = A.rest, g.this = A._this, this.expect(11), [g.returnType, l.predicate] = this.flowParseTypeAndPredicateInitialiser(), D.typeAnnotation = this.finishNode(g, "FunctionTypeAnnotation"), f.typeAnnotation = this.finishNode(D, "TypeAnnotation"), this.resetEndLocation(f), this.semicolon(), this.scope.declareName(l.id.name, 2048, l.id.loc.start), this.finishNode(l, "DeclareFunction");
    }
    flowParseDeclare(l, f) {
      if (this.match(80))
        return this.flowParseDeclareClass(l);
      if (this.match(68))
        return this.flowParseDeclareFunction(l);
      if (this.match(74))
        return this.flowParseDeclareVariable(l);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(l) : (f && this.raise(be.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(l));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(l);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(l);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(l);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(l, f);
      this.unexpected();
    }
    flowParseDeclareVariable(l) {
      return this.next(), l.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(l.id.name, 5, l.id.loc.start), this.semicolon(), this.finishNode(l, "DeclareVariable");
    }
    flowParseDeclareModule(l) {
      this.scope.enter(0), this.match(133) ? l.id = super.parseExprAtom() : l.id = this.parseIdentifier();
      let f = l.body = this.startNode(), g = f.body = [];
      for (this.expect(5); !this.match(8); ) {
        let T = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(be.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(T)) : (this.expectContextual(125, be.UnsupportedStatementInDeclareModule), T = this.flowParseDeclare(T, !0)), g.push(T);
      }
      this.scope.exit(), this.expect(8), this.finishNode(f, "BlockStatement");
      let D = null, A = !1;
      return g.forEach((T) => {
        Yk(T) ? (D === "CommonJS" && this.raise(be.AmbiguousDeclareModuleKind, T), D = "ES") : T.type === "DeclareModuleExports" && (A && this.raise(be.DuplicateDeclareModuleExports, T), D === "ES" && this.raise(be.AmbiguousDeclareModuleKind, T), D = "CommonJS", A = !0);
      }), l.kind = D || "CommonJS", this.finishNode(l, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(l, f) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? l.declaration = this.flowParseDeclare(this.startNode()) : (l.declaration = this.flowParseType(), this.semicolon()), l.default = !0, this.finishNode(l, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !f) {
        let g = this.state.value;
        throw this.raise(be.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: g, suggestion: Uk[g] });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return l.declaration = this.flowParseDeclare(this.startNode()), l.default = !1, this.finishNode(l, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return l = this.parseExport(l, null), l.type === "ExportNamedDeclaration" && (l.type = "ExportDeclaration", l.default = !1, delete l.exportKind), l.type = "Declare" + l.type, l;
      this.unexpected();
    }
    flowParseDeclareModuleExports(l) {
      return this.next(), this.expectContextual(111), l.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(l, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(l) {
      this.next();
      let f = this.flowParseTypeAlias(l);
      return f.type = "DeclareTypeAlias", f;
    }
    flowParseDeclareOpaqueType(l) {
      this.next();
      let f = this.flowParseOpaqueType(l, !0);
      return f.type = "DeclareOpaqueType", f;
    }
    flowParseDeclareInterface(l) {
      return this.next(), this.flowParseInterfaceish(l, !1), this.finishNode(l, "DeclareInterface");
    }
    flowParseInterfaceish(l, f) {
      if (l.id = this.flowParseRestrictedIdentifier(!f, !0), this.scope.declareName(l.id.name, f ? 17 : 8201, l.id.loc.start), this.match(47) ? l.typeParameters = this.flowParseTypeParameterDeclaration() : l.typeParameters = null, l.extends = [], this.eat(81))
        do
          l.extends.push(this.flowParseInterfaceExtends());
        while (!f && this.eat(12));
      if (f) {
        if (l.implements = [], l.mixins = [], this.eatContextual(117))
          do
            l.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            l.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      l.body = this.flowParseObjectType({ allowStatic: f, allowExact: !1, allowSpread: !1, allowProto: f, allowInexact: !1 });
    }
    flowParseInterfaceExtends() {
      let l = this.startNode();
      return l.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? l.typeParameters = this.flowParseTypeParameterInstantiation() : l.typeParameters = null, this.finishNode(l, "InterfaceExtends");
    }
    flowParseInterface(l) {
      return this.flowParseInterfaceish(l, !1), this.finishNode(l, "InterfaceDeclaration");
    }
    checkNotUnderscore(l) {
      l === "_" && this.raise(be.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(l, f, g) {
      Vk.has(l) && this.raise(g ? be.AssignReservedType : be.UnexpectedReservedType, f, { reservedType: l });
    }
    flowParseRestrictedIdentifier(l, f) {
      return this.checkReservedType(this.state.value, this.state.startLoc, f), this.parseIdentifier(l);
    }
    flowParseTypeAlias(l) {
      return l.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(l.id.name, 8201, l.id.loc.start), this.match(47) ? l.typeParameters = this.flowParseTypeParameterDeclaration() : l.typeParameters = null, l.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(l, "TypeAlias");
    }
    flowParseOpaqueType(l, f) {
      return this.expectContextual(130), l.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(l.id.name, 8201, l.id.loc.start), this.match(47) ? l.typeParameters = this.flowParseTypeParameterDeclaration() : l.typeParameters = null, l.supertype = null, this.match(14) && (l.supertype = this.flowParseTypeInitialiser(14)), l.impltype = null, f || (l.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(l, "OpaqueType");
    }
    flowParseTypeParameter(l = !1) {
      let f = this.state.startLoc, g = this.startNode(), D = this.flowParseVariance(), A = this.flowParseTypeAnnotatableIdentifier();
      return g.name = A.name, g.variance = D, g.bound = A.typeAnnotation, this.match(29) ? (this.eat(29), g.default = this.flowParseType()) : l && this.raise(be.MissingTypeParamDefault, f), this.finishNode(g, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let l = this.state.inType, f = this.startNode();
      f.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let g = !1;
      do {
        let D = this.flowParseTypeParameter(g);
        f.params.push(D), D.default && (g = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = l, this.finishNode(f, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let l = this.startNode(), f = this.state.inType;
      l.params = [], this.state.inType = !0, this.expect(47);
      let g = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        l.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = g, this.expect(48), this.state.inType = f, this.finishNode(l, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let l = this.startNode(), f = this.state.inType;
      for (l.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        l.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = f, this.finishNode(l, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let l = this.startNode();
      if (this.expectContextual(129), l.extends = [], this.eat(81))
        do
          l.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return l.body = this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !1, allowProto: !1, allowInexact: !1 }), this.finishNode(l, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(l, f, g) {
      return l.static = f, this.lookahead().type === 14 ? (l.id = this.flowParseObjectPropertyKey(), l.key = this.flowParseTypeInitialiser()) : (l.id = null, l.key = this.flowParseType()), this.expect(3), l.value = this.flowParseTypeInitialiser(), l.variance = g, this.finishNode(l, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(l, f) {
      return l.static = f, l.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (l.method = !0, l.optional = !1, l.value = this.flowParseObjectTypeMethodish(this.startNodeAt(l.loc.start))) : (l.method = !1, this.eat(17) && (l.optional = !0), l.value = this.flowParseTypeInitialiser()), this.finishNode(l, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(l) {
      for (l.params = [], l.rest = null, l.typeParameters = null, l.this = null, this.match(47) && (l.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (l.this = this.flowParseFunctionTypeParam(!0), l.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        l.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (l.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), l.returnType = this.flowParseTypeInitialiser(), this.finishNode(l, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(l, f) {
      let g = this.startNode();
      return l.static = f, l.value = this.flowParseObjectTypeMethodish(g), this.finishNode(l, "ObjectTypeCallProperty");
    }
    flowParseObjectType({ allowStatic: l, allowExact: f, allowSpread: g, allowProto: D, allowInexact: A }) {
      let T = this.state.inType;
      this.state.inType = !0;
      let F = this.startNode();
      F.callProperties = [], F.properties = [], F.indexers = [], F.internalSlots = [];
      let N, $, Y = !1;
      for (f && this.match(6) ? (this.expect(6), N = 9, $ = !0) : (this.expect(5), N = 8, $ = !1), F.exact = $; !this.match(N); ) {
        let ce = !1, le = null, Ve = null, Xe = this.startNode();
        if (D && this.isContextual(118)) {
          let Rt = this.lookahead();
          Rt.type !== 14 && Rt.type !== 17 && (this.next(), le = this.state.startLoc, l = !1);
        }
        if (l && this.isContextual(106)) {
          let Rt = this.lookahead();
          Rt.type !== 14 && Rt.type !== 17 && (this.next(), ce = !0);
        }
        let Ot = this.flowParseVariance();
        if (this.eat(0))
          le != null && this.unexpected(le), this.eat(0) ? (Ot && this.unexpected(Ot.loc.start), F.internalSlots.push(this.flowParseObjectTypeInternalSlot(Xe, ce))) : F.indexers.push(this.flowParseObjectTypeIndexer(Xe, ce, Ot));
        else if (this.match(10) || this.match(47))
          le != null && this.unexpected(le), Ot && this.unexpected(Ot.loc.start), F.callProperties.push(this.flowParseObjectTypeCallProperty(Xe, ce));
        else {
          let Rt = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let wp = this.lookahead();
            Te(wp.type) && (Rt = this.state.value, this.next());
          }
          let hr = this.flowParseObjectTypeProperty(Xe, ce, le, Ot, Rt, g, A ?? !$);
          hr === null ? (Y = !0, Ve = this.state.lastTokStartLoc) : F.properties.push(hr);
        }
        this.flowObjectTypeSemicolon(), Ve && !this.match(8) && !this.match(9) && this.raise(be.UnexpectedExplicitInexactInObject, Ve);
      }
      this.expect(N), g && (F.inexact = Y);
      let ie = this.finishNode(F, "ObjectTypeAnnotation");
      return this.state.inType = T, ie;
    }
    flowParseObjectTypeProperty(l, f, g, D, A, T, F) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (T ? F || this.raise(be.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(be.InexactInsideNonObject, this.state.lastTokStartLoc), D && this.raise(be.InexactVariance, D), null) : (T || this.raise(be.UnexpectedSpreadType, this.state.lastTokStartLoc), g != null && this.unexpected(g), D && this.raise(be.SpreadVariance, D), l.argument = this.flowParseType(), this.finishNode(l, "ObjectTypeSpreadProperty"));
      {
        l.key = this.flowParseObjectPropertyKey(), l.static = f, l.proto = g != null, l.kind = A;
        let N = !1;
        return this.match(47) || this.match(10) ? (l.method = !0, g != null && this.unexpected(g), D && this.unexpected(D.loc.start), l.value = this.flowParseObjectTypeMethodish(this.startNodeAt(l.loc.start)), (A === "get" || A === "set") && this.flowCheckGetterSetterParams(l), !T && l.key.name === "constructor" && l.value.this && this.raise(be.ThisParamBannedInConstructor, l.value.this)) : (A !== "init" && this.unexpected(), l.method = !1, this.eat(17) && (N = !0), l.value = this.flowParseTypeInitialiser(), l.variance = D), l.optional = N, this.finishNode(l, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(l) {
      let f = l.kind === "get" ? 0 : 1, g = l.value.params.length + (l.value.rest ? 1 : 0);
      l.value.this && this.raise(l.kind === "get" ? be.GetterMayNotHaveThisParam : be.SetterMayNotHaveThisParam, l.value.this), g !== f && this.raise(l.kind === "get" ? x.BadGetterArity : x.BadSetterArity, l), l.kind === "set" && l.value.rest && this.raise(x.BadSetterRestParameter, l);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(l, f) {
      l != null || (l = this.state.startLoc);
      let g = f || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let D = this.startNodeAt(l);
        D.qualification = g, D.id = this.flowParseRestrictedIdentifier(!0), g = this.finishNode(D, "QualifiedTypeIdentifier");
      }
      return g;
    }
    flowParseGenericType(l, f) {
      let g = this.startNodeAt(l);
      return g.typeParameters = null, g.id = this.flowParseQualifiedTypeIdentifier(l, f), this.match(47) && (g.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(g, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let l = this.startNode();
      return this.expect(87), l.argument = this.flowParsePrimaryType(), this.finishNode(l, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let l = this.startNode();
      for (l.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (l.types.push(this.flowParseType()), !this.match(3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(l, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(l) {
      let f = null, g = !1, D = null, A = this.startNode(), T = this.lookahead(), F = this.state.type === 78;
      return T.type === 14 || T.type === 17 ? (F && !l && this.raise(be.ThisParamMustBeFirst, A), f = this.parseIdentifier(F), this.eat(17) && (g = !0, F && this.raise(be.ThisParamMayNotBeOptional, A)), D = this.flowParseTypeInitialiser()) : D = this.flowParseType(), A.name = f, A.optional = g, A.typeAnnotation = D, this.finishNode(A, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(l) {
      let f = this.startNodeAt(l.loc.start);
      return f.name = null, f.optional = !1, f.typeAnnotation = l, this.finishNode(f, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(l = []) {
      let f = null, g = null;
      for (this.match(78) && (g = this.flowParseFunctionTypeParam(!0), g.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        l.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (f = this.flowParseFunctionTypeParam(!1)), { params: l, rest: f, _this: g };
    }
    flowIdentToTypeAnnotation(l, f, g) {
      switch (g.name) {
        case "any":
          return this.finishNode(f, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(f, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(f, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(f, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(f, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(f, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(f, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(g.name), this.flowParseGenericType(l, g);
      }
    }
    flowParsePrimaryType() {
      let l = this.state.startLoc, f = this.startNode(), g, D, A = !1, T = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !0, allowProto: !1, allowInexact: !0 });
        case 6:
          return this.flowParseObjectType({ allowStatic: !1, allowExact: !0, allowSpread: !0, allowProto: !1, allowInexact: !1 });
        case 0:
          return this.state.noAnonFunctionType = !1, D = this.flowParseTupleType(), this.state.noAnonFunctionType = T, D;
        case 47:
          return f.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), g = this.flowParseFunctionTypeParams(), f.params = g.params, f.rest = g.rest, f.this = g._this, this.expect(11), this.expect(19), f.returnType = this.flowParseType(), this.finishNode(f, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (R(this.state.type) || this.match(78)) {
              let F = this.lookahead().type;
              A = F !== 17 && F !== 14;
            } else
              A = !0;
          if (A) {
            if (this.state.noAnonFunctionType = !1, D = this.flowParseType(), this.state.noAnonFunctionType = T, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), D;
            this.eat(12);
          }
          return D ? g = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(D)]) : g = this.flowParseFunctionTypeParams(), f.params = g.params, f.rest = g.rest, f.this = g._this, this.expect(11), this.expect(19), f.returnType = this.flowParseType(), f.typeParameters = null, this.finishNode(f, "FunctionTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return f.value = this.match(85), this.next(), this.finishNode(f, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", f);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", f);
            throw this.raise(be.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(f, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(f, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(f, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(f, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (cr(this.state.type)) {
            let F = di(this.state.type);
            return this.next(), super.createIdentifier(f, F);
          } else if (R(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(l, f, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let l = this.state.startLoc, f = this.flowParsePrimaryType(), g = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let D = this.startNodeAt(l), A = this.eat(18);
        g = g || A, this.expect(0), !A && this.match(3) ? (D.elementType = f, this.next(), f = this.finishNode(D, "ArrayTypeAnnotation")) : (D.objectType = f, D.indexType = this.flowParseType(), this.expect(3), g ? (D.optional = A, f = this.finishNode(D, "OptionalIndexedAccessType")) : f = this.finishNode(D, "IndexedAccessType"));
      }
      return f;
    }
    flowParsePrefixType() {
      let l = this.startNode();
      return this.eat(17) ? (l.typeAnnotation = this.flowParsePrefixType(), this.finishNode(l, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let l = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let f = this.startNodeAt(l.loc.start);
        return f.params = [this.reinterpretTypeAsFunctionTypeParam(l)], f.rest = null, f.this = null, f.returnType = this.flowParseType(), f.typeParameters = null, this.finishNode(f, "FunctionTypeAnnotation");
      }
      return l;
    }
    flowParseIntersectionType() {
      let l = this.startNode();
      this.eat(45);
      let f = this.flowParseAnonFunctionWithoutParens();
      for (l.types = [f]; this.eat(45); )
        l.types.push(this.flowParseAnonFunctionWithoutParens());
      return l.types.length === 1 ? f : this.finishNode(l, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let l = this.startNode();
      this.eat(43);
      let f = this.flowParseIntersectionType();
      for (l.types = [f]; this.eat(43); )
        l.types.push(this.flowParseIntersectionType());
      return l.types.length === 1 ? f : this.finishNode(l, "UnionTypeAnnotation");
    }
    flowParseType() {
      let l = this.state.inType;
      this.state.inType = !0;
      let f = this.flowParseUnionType();
      return this.state.inType = l, f;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let l = this.state.startLoc, f = this.parseIdentifier();
        return this.flowParseGenericType(l, f);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let l = this.startNode();
      return l.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(l, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(l) {
      let f = l ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (f.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(f)), f;
    }
    typeCastToParameter(l) {
      return l.expression.typeAnnotation = l.typeAnnotation, this.resetEndLocation(l.expression, l.typeAnnotation.loc.end), l.expression;
    }
    flowParseVariance() {
      let l = null;
      return this.match(53) ? (l = this.startNode(), this.state.value === "+" ? l.kind = "plus" : l.kind = "minus", this.next(), this.finishNode(l, "Variance")) : l;
    }
    parseFunctionBody(l, f, g = !1) {
      if (f) {
        this.forwardNoArrowParamsConversionAt(l, () => super.parseFunctionBody(l, !0, g));
        return;
      }
      super.parseFunctionBody(l, !1, g);
    }
    parseFunctionBodyAndFinish(l, f, g = !1) {
      if (this.match(14)) {
        let D = this.startNode();
        [D.typeAnnotation, l.predicate] = this.flowParseTypeAndPredicateInitialiser(), l.returnType = D.typeAnnotation ? this.finishNode(D, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(l, f, g);
    }
    parseStatementLike(l) {
      if (this.state.strict && this.isContextual(129)) {
        let g = this.lookahead();
        if (De(g.type)) {
          let D = this.startNode();
          return this.next(), this.flowParseInterface(D);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        let g = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(g);
      }
      let f = super.parseStatementLike(l);
      return this.flowPragma === void 0 && !this.isValidDirective(f) && (this.flowPragma = null), f;
    }
    parseExpressionStatement(l, f, g) {
      if (f.type === "Identifier") {
        if (f.name === "declare") {
          if (this.match(80) || R(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(l);
        } else if (R(this.state.type)) {
          if (f.name === "interface")
            return this.flowParseInterface(l);
          if (f.name === "type")
            return this.flowParseTypeAlias(l);
          if (f.name === "opaque")
            return this.flowParseOpaqueType(l, !1);
        }
      }
      return super.parseExpressionStatement(l, f, g);
    }
    shouldParseExportDeclaration() {
      let { type: l } = this.state;
      return Ur(l) || this.shouldParseEnums() && l === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let { type: l } = this.state;
      return Ur(l) || this.shouldParseEnums() && l === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        let l = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(l);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(l, f, g) {
      if (!this.match(17))
        return l;
      if (this.state.maybeInArrowParameters) {
        let ie = this.lookaheadCharCode();
        if (ie === 44 || ie === 61 || ie === 58 || ie === 41)
          return this.setOptionalParametersError(g), l;
      }
      this.expect(17);
      let D = this.state.clone(), A = this.state.noArrowAt, T = this.startNodeAt(f), { consequent: F, failed: N } = this.tryParseConditionalConsequent(), [$, Y] = this.getArrowLikeExpressions(F);
      if (N || Y.length > 0) {
        let ie = [...A];
        if (Y.length > 0) {
          this.state = D, this.state.noArrowAt = ie;
          for (let ce = 0; ce < Y.length; ce++)
            ie.push(Y[ce].start);
          ({ consequent: F, failed: N } = this.tryParseConditionalConsequent()), [$, Y] = this.getArrowLikeExpressions(F);
        }
        N && $.length > 1 && this.raise(be.AmbiguousConditionalArrow, D.startLoc), N && $.length === 1 && (this.state = D, ie.push($[0].start), this.state.noArrowAt = ie, { consequent: F, failed: N } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(F, !0), this.state.noArrowAt = A, this.expect(14), T.test = l, T.consequent = F, T.alternate = this.forwardNoArrowParamsConversionAt(T, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(T, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let l = this.parseMaybeAssignAllowIn(), f = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), { consequent: l, failed: f };
    }
    getArrowLikeExpressions(l, f) {
      let g = [l], D = [];
      for (; g.length !== 0; ) {
        let A = g.pop();
        A.type === "ArrowFunctionExpression" ? (A.typeParameters || !A.returnType ? this.finishArrowValidation(A) : D.push(A), g.push(A.body)) : A.type === "ConditionalExpression" && (g.push(A.consequent), g.push(A.alternate));
      }
      return f ? (D.forEach((A) => this.finishArrowValidation(A)), [D, []]) : zk(D, (A) => A.params.every((T) => this.isAssignable(T, !0)));
    }
    finishArrowValidation(l) {
      var f;
      this.toAssignableList(l.params, (f = l.extra) == null ? void 0 : f.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(l, !1, !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(l, f) {
      let g;
      return this.state.noArrowParamsConversionAt.indexOf(l.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), g = f(), this.state.noArrowParamsConversionAt.pop()) : g = f(), g;
    }
    parseParenItem(l, f) {
      if (l = super.parseParenItem(l, f), this.eat(17) && (l.optional = !0, this.resetEndLocation(l)), this.match(14)) {
        let g = this.startNodeAt(f);
        return g.expression = l, g.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(g, "TypeCastExpression");
      }
      return l;
    }
    assertModuleNodeAllowed(l) {
      l.type === "ImportDeclaration" && (l.importKind === "type" || l.importKind === "typeof") || l.type === "ExportNamedDeclaration" && l.exportKind === "type" || l.type === "ExportAllDeclaration" && l.exportKind === "type" || super.assertModuleNodeAllowed(l);
    }
    parseExportDeclaration(l) {
      if (this.isContextual(130)) {
        l.exportKind = "type";
        let f = this.startNode();
        return this.next(), this.match(5) ? (l.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(l), null) : this.flowParseTypeAlias(f);
      } else if (this.isContextual(131)) {
        l.exportKind = "type";
        let f = this.startNode();
        return this.next(), this.flowParseOpaqueType(f, !1);
      } else if (this.isContextual(129)) {
        l.exportKind = "type";
        let f = this.startNode();
        return this.next(), this.flowParseInterface(f);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        l.exportKind = "value";
        let f = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(f);
      } else
        return super.parseExportDeclaration(l);
    }
    eatExportStar(l) {
      return super.eatExportStar(l) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (l.exportKind = "type", this.next(), this.next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(l) {
      let { startLoc: f } = this.state, g = super.maybeParseExportNamespaceSpecifier(l);
      return g && l.exportKind === "type" && this.unexpected(f), g;
    }
    parseClassId(l, f, g) {
      super.parseClassId(l, f, g), this.match(47) && (l.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(l, f, g) {
      let { startLoc: D } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(l, f))
          return;
        f.declare = !0;
      }
      super.parseClassMember(l, f, g), f.declare && (f.type !== "ClassProperty" && f.type !== "ClassPrivateProperty" && f.type !== "PropertyDefinition" ? this.raise(be.DeclareClassElement, D) : f.value && this.raise(be.DeclareClassFieldInitializer, f.value));
    }
    isIterator(l) {
      return l === "iterator" || l === "asyncIterator";
    }
    readIterator() {
      let l = super.readWord1(), f = "@@" + l;
      (!this.isIterator(l) || !this.state.inType) && this.raise(x.InvalidIdentifier, this.state.curPosition(), { identifierName: f }), this.finishToken(132, f);
    }
    getTokenFromCode(l) {
      let f = this.input.charCodeAt(this.state.pos + 1);
      l === 123 && f === 124 ? this.finishOp(6, 2) : this.state.inType && (l === 62 || l === 60) ? this.finishOp(l === 62 ? 48 : 47, 1) : this.state.inType && l === 63 ? f === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : bk(l, f, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(l);
    }
    isAssignable(l, f) {
      return l.type === "TypeCastExpression" ? this.isAssignable(l.expression, f) : super.isAssignable(l, f);
    }
    toAssignable(l, f = !1) {
      !f && l.type === "AssignmentExpression" && l.left.type === "TypeCastExpression" && (l.left = this.typeCastToParameter(l.left)), super.toAssignable(l, f);
    }
    toAssignableList(l, f, g) {
      for (let D = 0; D < l.length; D++) {
        let A = l[D];
        (A == null ? void 0 : A.type) === "TypeCastExpression" && (l[D] = this.typeCastToParameter(A));
      }
      super.toAssignableList(l, f, g);
    }
    toReferencedList(l, f) {
      for (let D = 0; D < l.length; D++) {
        var g;
        let A = l[D];
        A && A.type === "TypeCastExpression" && !((g = A.extra) != null && g.parenthesized) && (l.length > 1 || !f) && this.raise(be.TypeCastInPattern, A.typeAnnotation);
      }
      return l;
    }
    parseArrayLike(l, f, g, D) {
      let A = super.parseArrayLike(l, f, g, D);
      return f && !this.state.maybeInArrowParameters && this.toReferencedList(A.elements), A;
    }
    isValidLVal(l, f, g) {
      return l === "TypeCastExpression" || super.isValidLVal(l, f, g);
    }
    parseClassProperty(l) {
      return this.match(14) && (l.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(l);
    }
    parseClassPrivateProperty(l) {
      return this.match(14) && (l.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(l);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(l) {
      return !this.match(14) && super.isNonstaticConstructor(l);
    }
    pushClassMethod(l, f, g, D, A, T) {
      if (f.variance && this.unexpected(f.variance.loc.start), delete f.variance, this.match(47) && (f.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(l, f, g, D, A, T), f.params && A) {
        let F = f.params;
        F.length > 0 && this.isThisParam(F[0]) && this.raise(be.ThisParamBannedInConstructor, f);
      } else if (f.type === "MethodDefinition" && A && f.value.params) {
        let F = f.value.params;
        F.length > 0 && this.isThisParam(F[0]) && this.raise(be.ThisParamBannedInConstructor, f);
      }
    }
    pushClassPrivateMethod(l, f, g, D) {
      f.variance && this.unexpected(f.variance.loc.start), delete f.variance, this.match(47) && (f.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(l, f, g, D);
    }
    parseClassSuper(l) {
      if (super.parseClassSuper(l), l.superClass && this.match(47) && (l.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
        this.next();
        let f = l.implements = [];
        do {
          let g = this.startNode();
          g.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? g.typeParameters = this.flowParseTypeParameterInstantiation() : g.typeParameters = null, f.push(this.finishNode(g, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(l) {
      super.checkGetterSetterParams(l);
      let f = this.getObjectOrClassMethodParams(l);
      if (f.length > 0) {
        let g = f[0];
        this.isThisParam(g) && l.kind === "get" ? this.raise(be.GetterMayNotHaveThisParam, g) : this.isThisParam(g) && this.raise(be.SetterMayNotHaveThisParam, g);
      }
    }
    parsePropertyNamePrefixOperator(l) {
      l.variance = this.flowParseVariance();
    }
    parseObjPropValue(l, f, g, D, A, T, F) {
      l.variance && this.unexpected(l.variance.loc.start), delete l.variance;
      let N;
      this.match(47) && !T && (N = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let $ = super.parseObjPropValue(l, f, g, D, A, T, F);
      return N && (($.value || $).typeParameters = N), $;
    }
    parseAssignableListItemTypes(l) {
      return this.eat(17) && (l.type !== "Identifier" && this.raise(be.PatternIsOptional, l), this.isThisParam(l) && this.raise(be.ThisParamMayNotBeOptional, l), l.optional = !0), this.match(14) ? l.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(l) && this.raise(be.ThisParamAnnotationRequired, l), this.match(29) && this.isThisParam(l) && this.raise(be.ThisParamNoDefault, l), this.resetEndLocation(l), l;
    }
    parseMaybeDefault(l, f) {
      let g = super.parseMaybeDefault(l, f);
      return g.type === "AssignmentPattern" && g.typeAnnotation && g.right.start < g.typeAnnotation.start && this.raise(be.TypeBeforeInitializer, g.typeAnnotation), g;
    }
    checkImportReflection(l) {
      super.checkImportReflection(l), l.module && l.importKind !== "value" && this.raise(be.ImportReflectionHasImportType, l.specifiers[0].loc.start);
    }
    parseImportSpecifierLocal(l, f, g) {
      f.local = Gy(l) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), l.specifiers.push(this.finishImportSpecifier(f, g));
    }
    isPotentialImportPhase(l) {
      if (super.isPotentialImportPhase(l))
        return !0;
      if (this.isContextual(130)) {
        if (!l)
          return !0;
        let f = this.lookaheadCharCode();
        return f === 123 || f === 42;
      }
      return !l && this.isContextual(87);
    }
    applyImportPhase(l, f, g, D) {
      if (super.applyImportPhase(l, f, g, D), f) {
        if (!g && this.match(65))
          return;
        l.exportKind = g === "type" ? g : "value";
      } else
        g === "type" && this.match(55) && this.unexpected(), l.importKind = g === "type" || g === "typeof" ? g : "value";
    }
    parseImportSpecifier(l, f, g, D, A) {
      let T = l.imported, F = null;
      T.type === "Identifier" && (T.name === "type" ? F = "type" : T.name === "typeof" && (F = "typeof"));
      let N = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let Y = this.parseIdentifier(!0);
        F !== null && !De(this.state.type) ? (l.imported = Y, l.importKind = F, l.local = Yi(Y)) : (l.imported = T, l.importKind = null, l.local = this.parseIdentifier());
      } else {
        if (F !== null && De(this.state.type))
          l.imported = this.parseIdentifier(!0), l.importKind = F;
        else {
          if (f)
            throw this.raise(x.ImportBindingIsString, l, { importName: T.value });
          l.imported = T, l.importKind = null;
        }
        this.eatContextual(93) ? l.local = this.parseIdentifier() : (N = !0, l.local = Yi(l.imported));
      }
      let $ = Gy(l);
      return g && $ && this.raise(be.ImportTypeShorthandOnlyInPureImport, l), (g || $) && this.checkReservedType(l.local.name, l.local.loc.start, !0), N && !g && !$ && this.checkReservedWord(l.local.name, l.loc.start, !0, !0), this.finishImportSpecifier(l, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(l, f) {
      let g = l.kind;
      g !== "get" && g !== "set" && this.match(47) && (l.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(l, f);
    }
    parseVarId(l, f) {
      super.parseVarId(l, f), this.match(14) && (l.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(l.id));
    }
    parseAsyncArrowFromCallExpression(l, f) {
      if (this.match(14)) {
        let g = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, l.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = g;
      }
      return super.parseAsyncArrowFromCallExpression(l, f);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(l, f) {
      var g;
      let D = null, A;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (D = this.state.clone(), A = this.tryParse(() => super.parseMaybeAssign(l, f), D), !A.error)
          return A.node;
        let { context: N } = this.state, $ = N[N.length - 1];
        ($ === I.j_oTag || $ === I.j_expr) && N.pop();
      }
      if ((g = A) != null && g.error || this.match(47)) {
        var T, F;
        D = D || this.state.clone();
        let N, $ = this.tryParse((ie) => {
          var ce;
          N = this.flowParseTypeParameterDeclaration();
          let le = this.forwardNoArrowParamsConversionAt(N, () => {
            let Xe = super.parseMaybeAssign(l, f);
            return this.resetStartLocationFromNode(Xe, N), Xe;
          });
          (ce = le.extra) != null && ce.parenthesized && ie();
          let Ve = this.maybeUnwrapTypeCastExpression(le);
          return Ve.type !== "ArrowFunctionExpression" && ie(), Ve.typeParameters = N, this.resetStartLocationFromNode(Ve, N), le;
        }, D), Y = null;
        if ($.node && this.maybeUnwrapTypeCastExpression($.node).type === "ArrowFunctionExpression") {
          if (!$.error && !$.aborted)
            return $.node.async && this.raise(be.UnexpectedTypeParameterBeforeAsyncArrowFunction, N), $.node;
          Y = $.node;
        }
        if ((T = A) != null && T.node)
          return this.state = A.failState, A.node;
        if (Y)
          return this.state = $.failState, Y;
        throw (F = A) != null && F.thrown ? A.error : $.thrown ? $.error : this.raise(be.UnexpectedTokenAfterTypeParameter, N);
      }
      return super.parseMaybeAssign(l, f);
    }
    parseArrow(l) {
      if (this.match(14)) {
        let f = this.tryParse(() => {
          let g = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let D = this.startNode();
          return [D.typeAnnotation, l.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = g, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), D;
        });
        if (f.thrown)
          return null;
        f.error && (this.state = f.failState), l.returnType = f.node.typeAnnotation ? this.finishNode(f.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(l);
    }
    shouldParseArrow(l) {
      return this.match(14) || super.shouldParseArrow(l);
    }
    setArrowFunctionParameters(l, f) {
      this.state.noArrowParamsConversionAt.indexOf(l.start) !== -1 ? l.params = f : super.setArrowFunctionParameters(l, f);
    }
    checkParams(l, f, g, D = !0) {
      if (!(g && this.state.noArrowParamsConversionAt.indexOf(l.start) !== -1)) {
        for (let A = 0; A < l.params.length; A++)
          this.isThisParam(l.params[A]) && A > 0 && this.raise(be.ThisParamMustBeFirst, l.params[A]);
        super.checkParams(l, f, g, D);
      }
    }
    parseParenAndDistinguishExpression(l) {
      return super.parseParenAndDistinguishExpression(l && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(l, f, g) {
      if (l.type === "Identifier" && l.name === "async" && this.state.noArrowAt.indexOf(f.index) !== -1) {
        this.next();
        let D = this.startNodeAt(f);
        D.callee = l, D.arguments = super.parseCallExpressionArguments(11, !1), l = this.finishNode(D, "CallExpression");
      } else if (l.type === "Identifier" && l.name === "async" && this.match(47)) {
        let D = this.state.clone(), A = this.tryParse((F) => this.parseAsyncArrowWithTypeParameters(f) || F(), D);
        if (!A.error && !A.aborted)
          return A.node;
        let T = this.tryParse(() => super.parseSubscripts(l, f, g), D);
        if (T.node && !T.error)
          return T.node;
        if (A.node)
          return this.state = A.failState, A.node;
        if (T.node)
          return this.state = T.failState, T.node;
        throw A.error || T.error;
      }
      return super.parseSubscripts(l, f, g);
    }
    parseSubscript(l, f, g, D) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (D.optionalChainMember = !0, g)
          return D.stop = !0, l;
        this.next();
        let A = this.startNodeAt(f);
        return A.callee = l, A.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), A.arguments = this.parseCallExpressionArguments(11, !1), A.optional = !0, this.finishCallExpression(A, !0);
      } else if (!g && this.shouldParseTypes() && this.match(47)) {
        let A = this.startNodeAt(f);
        A.callee = l;
        let T = this.tryParse(() => (A.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), A.arguments = super.parseCallExpressionArguments(11, !1), D.optionalChainMember && (A.optional = !1), this.finishCallExpression(A, D.optionalChainMember)));
        if (T.node)
          return T.error && (this.state = T.failState), T.node;
      }
      return super.parseSubscript(l, f, g, D);
    }
    parseNewCallee(l) {
      super.parseNewCallee(l);
      let f = null;
      this.shouldParseTypes() && this.match(47) && (f = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), l.typeArguments = f;
    }
    parseAsyncArrowWithTypeParameters(l) {
      let f = this.startNodeAt(l);
      if (this.parseFunctionParams(f, !1), !!this.parseArrow(f))
        return super.parseArrowExpression(f, void 0, !0);
    }
    readToken_mult_modulo(l) {
      let f = this.input.charCodeAt(this.state.pos + 1);
      if (l === 42 && f === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(l);
    }
    readToken_pipe_amp(l) {
      let f = this.input.charCodeAt(this.state.pos + 1);
      if (l === 124 && f === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(l);
    }
    parseTopLevel(l, f) {
      let g = super.parseTopLevel(l, f);
      return this.state.hasFlowComment && this.raise(be.UnterminatedFlowComment, this.state.curPosition()), g;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(be.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let l = this.skipFlowComment();
        l && (this.state.pos += l, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let { pos: l } = this.state, f = 2;
      for (; [32, 9].includes(this.input.charCodeAt(l + f)); )
        f++;
      let g = this.input.charCodeAt(f + l), D = this.input.charCodeAt(f + l + 1);
      return g === 58 && D === 58 ? f + 2 : this.input.slice(f + l, f + l + 12) === "flow-include" ? f + 12 : g === 58 && D !== 58 ? f : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(x.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(l, { enumName: f, memberName: g }) {
      this.raise(be.EnumBooleanMemberNotInitialized, l, { memberName: g, enumName: f });
    }
    flowEnumErrorInvalidMemberInitializer(l, f) {
      return this.raise(f.explicitType ? f.explicitType === "symbol" ? be.EnumInvalidMemberInitializerSymbolType : be.EnumInvalidMemberInitializerPrimaryType : be.EnumInvalidMemberInitializerUnknownType, l, f);
    }
    flowEnumErrorNumberMemberNotInitialized(l, f) {
      this.raise(be.EnumNumberMemberNotInitialized, l, f);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(l, f) {
      this.raise(be.EnumStringMemberInconsistentlyInitialized, l, f);
    }
    flowEnumMemberInit() {
      let l = this.state.startLoc, f = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 134: {
          let g = this.parseNumericLiteral(this.state.value);
          return f() ? { type: "number", loc: g.loc.start, value: g } : { type: "invalid", loc: l };
        }
        case 133: {
          let g = this.parseStringLiteral(this.state.value);
          return f() ? { type: "string", loc: g.loc.start, value: g } : { type: "invalid", loc: l };
        }
        case 85:
        case 86: {
          let g = this.parseBooleanLiteral(this.match(85));
          return f() ? { type: "boolean", loc: g.loc.start, value: g } : { type: "invalid", loc: l };
        }
        default:
          return { type: "invalid", loc: l };
      }
    }
    flowEnumMemberRaw() {
      let l = this.state.startLoc, f = this.parseIdentifier(!0), g = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: l };
      return { id: f, init: g };
    }
    flowEnumCheckExplicitTypeMismatch(l, f, g) {
      let { explicitType: D } = f;
      D !== null && D !== g && this.flowEnumErrorInvalidMemberInitializer(l, f);
    }
    flowEnumMembers({ enumName: l, explicitType: f }) {
      let g = /* @__PURE__ */ new Set(), D = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, A = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          A = !0;
          break;
        }
        let T = this.startNode(), { id: F, init: N } = this.flowEnumMemberRaw(), $ = F.name;
        if ($ === "")
          continue;
        /^[a-z]/.test($) && this.raise(be.EnumInvalidMemberName, F, { memberName: $, suggestion: $[0].toUpperCase() + $.slice(1), enumName: l }), g.has($) && this.raise(be.EnumDuplicateMemberName, F, { memberName: $, enumName: l }), g.add($);
        let Y = { enumName: l, explicitType: f, memberName: $ };
        switch (T.id = F, N.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(N.loc, Y, "boolean"), T.init = N.value, D.booleanMembers.push(this.finishNode(T, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(N.loc, Y, "number"), T.init = N.value, D.numberMembers.push(this.finishNode(T, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(N.loc, Y, "string"), T.init = N.value, D.stringMembers.push(this.finishNode(T, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(N.loc, Y);
          case "none":
            switch (f) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(N.loc, Y);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(N.loc, Y);
                break;
              default:
                D.defaultedMembers.push(this.finishNode(T, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return { members: D, hasUnknownMembers: A };
    }
    flowEnumStringMembers(l, f, { enumName: g }) {
      if (l.length === 0)
        return f;
      if (f.length === 0)
        return l;
      if (f.length > l.length) {
        for (let D of l)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(D, { enumName: g });
        return f;
      } else {
        for (let D of f)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(D, { enumName: g });
        return l;
      }
    }
    flowEnumParseExplicitType({ enumName: l }) {
      if (!this.eatContextual(102))
        return null;
      if (!R(this.state.type))
        throw this.raise(be.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: l });
      let { value: f } = this.state;
      return this.next(), f !== "boolean" && f !== "number" && f !== "string" && f !== "symbol" && this.raise(be.EnumInvalidExplicitType, this.state.startLoc, { enumName: l, invalidEnumType: f }), f;
    }
    flowEnumBody(l, f) {
      let g = f.name, D = f.loc.start, A = this.flowEnumParseExplicitType({ enumName: g });
      this.expect(5);
      let { members: T, hasUnknownMembers: F } = this.flowEnumMembers({ enumName: g, explicitType: A });
      switch (l.hasUnknownMembers = F, A) {
        case "boolean":
          return l.explicitType = !0, l.members = T.booleanMembers, this.expect(8), this.finishNode(l, "EnumBooleanBody");
        case "number":
          return l.explicitType = !0, l.members = T.numberMembers, this.expect(8), this.finishNode(l, "EnumNumberBody");
        case "string":
          return l.explicitType = !0, l.members = this.flowEnumStringMembers(T.stringMembers, T.defaultedMembers, { enumName: g }), this.expect(8), this.finishNode(l, "EnumStringBody");
        case "symbol":
          return l.members = T.defaultedMembers, this.expect(8), this.finishNode(l, "EnumSymbolBody");
        default: {
          let N = () => (l.members = [], this.expect(8), this.finishNode(l, "EnumStringBody"));
          l.explicitType = !1;
          let $ = T.booleanMembers.length, Y = T.numberMembers.length, ie = T.stringMembers.length, ce = T.defaultedMembers.length;
          if (!$ && !Y && !ie && !ce)
            return N();
          if (!$ && !Y)
            return l.members = this.flowEnumStringMembers(T.stringMembers, T.defaultedMembers, { enumName: g }), this.expect(8), this.finishNode(l, "EnumStringBody");
          if (!Y && !ie && $ >= ce) {
            for (let le of T.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(le.loc.start, { enumName: g, memberName: le.id.name });
            return l.members = T.booleanMembers, this.expect(8), this.finishNode(l, "EnumBooleanBody");
          } else if (!$ && !ie && Y >= ce) {
            for (let le of T.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(le.loc.start, { enumName: g, memberName: le.id.name });
            return l.members = T.numberMembers, this.expect(8), this.finishNode(l, "EnumNumberBody");
          } else
            return this.raise(be.EnumInconsistentMemberValues, D, { enumName: g }), N();
        }
      }
    }
    flowParseEnumDeclaration(l) {
      let f = this.parseIdentifier();
      return l.id = f, l.body = this.flowEnumBody(this.startNode(), f), this.finishNode(l, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let l = this.nextTokenStart();
      if (this.input.charCodeAt(l) === 60) {
        let f = this.input.charCodeAt(l + 1);
        return f !== 60 && f !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(l) {
      return l.type === "TypeCastExpression" ? l.expression : l;
    }
  }, is = S`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: p }) => `Expected corresponding JSX closing tag for <${p}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: p, HTMLEntity: l }) => `Unexpected token \`${p}\`. Did you mean \`${l}\` or \`{'${p}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
  function yn(p) {
    return p ? p.type === "JSXOpeningFragment" || p.type === "JSXClosingFragment" : !1;
  }
  function Hs(p) {
    if (p.type === "JSXIdentifier")
      return p.name;
    if (p.type === "JSXNamespacedName")
      return p.namespace.name + ":" + p.name.name;
    if (p.type === "JSXMemberExpression")
      return Hs(p.object) + "." + Hs(p.property);
    throw new Error("Node had unexpected type: " + p.type);
  }
  var Jk = (p) => class extends p {
    jsxReadToken() {
      let l = "", f = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(is.UnterminatedJsxContent, this.state.startLoc);
        let g = this.input.charCodeAt(this.state.pos);
        switch (g) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              g === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(g);
              return;
            }
            l += this.input.slice(f, this.state.pos), this.finishToken(141, l);
            return;
          case 38:
            l += this.input.slice(f, this.state.pos), l += this.jsxReadEntity(), f = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            uo(g) ? (l += this.input.slice(f, this.state.pos), l += this.jsxReadNewLine(!0), f = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(l) {
      let f = this.input.charCodeAt(this.state.pos), g;
      return ++this.state.pos, f === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, g = l ? `
` : `\r
`) : g = String.fromCharCode(f), ++this.state.curLine, this.state.lineStart = this.state.pos, g;
    }
    jsxReadString(l) {
      let f = "", g = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(x.UnterminatedString, this.state.startLoc);
        let D = this.input.charCodeAt(this.state.pos);
        if (D === l)
          break;
        D === 38 ? (f += this.input.slice(g, this.state.pos), f += this.jsxReadEntity(), g = this.state.pos) : uo(D) ? (f += this.input.slice(g, this.state.pos), f += this.jsxReadNewLine(!1), g = this.state.pos) : ++this.state.pos;
      }
      f += this.input.slice(g, this.state.pos++), this.finishToken(133, f);
    }
    jsxReadEntity() {
      let l = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let f = 10;
        this.codePointAtPos(this.state.pos) === 120 && (f = 16, ++this.state.pos);
        let g = this.readInt(f, void 0, !1, "bail");
        if (g !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(g);
      } else {
        let f = 0, g = !1;
        for (; f++ < 10 && this.state.pos < this.length && !(g = this.codePointAtPos(this.state.pos) == 59); )
          ++this.state.pos;
        if (g) {
          this.input.slice(l, this.state.pos);
          let D;
          ++this.state.pos;
        }
      }
      return this.state.pos = l, "&";
    }
    jsxReadWord() {
      let l, f = this.state.pos;
      do
        l = this.input.charCodeAt(++this.state.pos);
      while (Be(l) || l === 45);
      this.finishToken(140, this.input.slice(f, this.state.pos));
    }
    jsxParseIdentifier() {
      let l = this.startNode();
      return this.match(140) ? l.name = this.state.value : cr(this.state.type) ? l.name = di(this.state.type) : this.unexpected(), this.next(), this.finishNode(l, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let l = this.state.startLoc, f = this.jsxParseIdentifier();
      if (!this.eat(14))
        return f;
      let g = this.startNodeAt(l);
      return g.namespace = f, g.name = this.jsxParseIdentifier(), this.finishNode(g, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let l = this.state.startLoc, f = this.jsxParseNamespacedName();
      if (f.type === "JSXNamespacedName")
        return f;
      for (; this.eat(16); ) {
        let g = this.startNodeAt(l);
        g.object = f, g.property = this.jsxParseIdentifier(), f = this.finishNode(g, "JSXMemberExpression");
      }
      return f;
    }
    jsxParseAttributeValue() {
      let l;
      switch (this.state.type) {
        case 5:
          return l = this.startNode(), this.setContext(I.brace), this.next(), l = this.jsxParseExpressionContainer(l, I.j_oTag), l.expression.type === "JSXEmptyExpression" && this.raise(is.AttributeIsEmpty, l), l;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(is.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let l = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(l, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(l) {
      return this.next(), l.expression = this.parseExpression(), this.setContext(I.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(l, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(l, f) {
      if (this.match(8))
        l.expression = this.jsxParseEmptyExpression();
      else {
        let g = this.parseExpression();
        l.expression = g;
      }
      return this.setContext(f), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(l, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let l = this.startNode();
      return this.match(5) ? (this.setContext(I.brace), this.next(), this.expect(21), l.argument = this.parseMaybeAssignAllowIn(), this.setContext(I.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(l, "JSXSpreadAttribute")) : (l.name = this.jsxParseNamespacedName(), l.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(l, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(l) {
      let f = this.startNodeAt(l);
      return this.eat(143) ? this.finishNode(f, "JSXOpeningFragment") : (f.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(f));
    }
    jsxParseOpeningElementAfterName(l) {
      let f = [];
      for (; !this.match(56) && !this.match(143); )
        f.push(this.jsxParseAttribute());
      return l.attributes = f, l.selfClosing = this.eat(56), this.expect(143), this.finishNode(l, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(l) {
      let f = this.startNodeAt(l);
      return this.eat(143) ? this.finishNode(f, "JSXClosingFragment") : (f.name = this.jsxParseElementName(), this.expect(143), this.finishNode(f, "JSXClosingElement"));
    }
    jsxParseElementAt(l) {
      let f = this.startNodeAt(l), g = [], D = this.jsxParseOpeningElementAt(l), A = null;
      if (!D.selfClosing) {
        e:
          for (; ; )
            switch (this.state.type) {
              case 142:
                if (l = this.state.startLoc, this.next(), this.eat(56)) {
                  A = this.jsxParseClosingElementAt(l);
                  break e;
                }
                g.push(this.jsxParseElementAt(l));
                break;
              case 141:
                g.push(this.parseExprAtom());
                break;
              case 5: {
                let T = this.startNode();
                this.setContext(I.brace), this.next(), this.match(21) ? g.push(this.jsxParseSpreadChild(T)) : g.push(this.jsxParseExpressionContainer(T, I.j_expr));
                break;
              }
              default:
                this.unexpected();
            }
        yn(D) && !yn(A) && A !== null ? this.raise(is.MissingClosingTagFragment, A) : !yn(D) && yn(A) ? this.raise(is.MissingClosingTagElement, A, { openingTagName: Hs(D.name) }) : !yn(D) && !yn(A) && Hs(A.name) !== Hs(D.name) && this.raise(is.MissingClosingTagElement, A, { openingTagName: Hs(D.name) });
      }
      if (yn(D) ? (f.openingFragment = D, f.closingFragment = A) : (f.openingElement = D, f.closingElement = A), f.children = g, this.match(47))
        throw this.raise(is.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return yn(D) ? this.finishNode(f, "JSXFragment") : this.finishNode(f, "JSXElement");
    }
    jsxParseElement() {
      let l = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(l);
    }
    setContext(l) {
      let { context: f } = this.state;
      f[f.length - 1] = l;
    }
    parseExprAtom(l) {
      return this.match(141) ? this.parseLiteral(this.state.value, "JSXText") : this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(l);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(l) {
      let f = this.curContext();
      if (f === I.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (f === I.j_oTag || f === I.j_cTag) {
        if (_e(l)) {
          this.jsxReadWord();
          return;
        }
        if (l === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((l === 34 || l === 39) && f === I.j_oTag) {
          this.jsxReadString(l);
          return;
        }
      }
      if (l === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(l);
    }
    updateContext(l) {
      let { context: f, type: g } = this.state;
      if (g === 56 && l === 142)
        f.splice(-2, 2, I.j_cTag), this.state.canStartJSXElement = !1;
      else if (g === 142)
        f.push(I.j_oTag);
      else if (g === 143) {
        let D = f[f.length - 1];
        D === I.j_oTag && l === 56 || D === I.j_cTag ? (f.pop(), this.state.canStartJSXElement = f[f.length - 1] === I.j_expr) : (this.setContext(I.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = tr(g);
    }
  }, Kk = class extends gp {
    constructor(...p) {
      super(...p), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, eT = class extends yp {
    constructor(...p) {
      super(...p), this.importsStack = [];
    }
    createScope(p) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new Kk(p);
    }
    enter(p) {
      p == 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(p);
    }
    exit() {
      let p = super.exit();
      return p == 256 && this.importsStack.pop(), p;
    }
    hasImport(p, l) {
      let f = this.importsStack.length;
      if (this.importsStack[f - 1].has(p))
        return !0;
      if (!l && f > 1) {
        for (let g = 0; g < f - 1; g++)
          if (this.importsStack[g].has(p))
            return !0;
      }
      return !1;
    }
    declareName(p, l, f) {
      if (l & 4096) {
        this.hasImport(p, !0) && this.parser.raise(x.VarRedeclaration, f, { identifierName: p }), this.importsStack[this.importsStack.length - 1].add(p);
        return;
      }
      let g = this.currentScope(), D = g.tsNames.get(p) || 0;
      if (l & 1024) {
        this.maybeExportDefined(g, p), g.tsNames.set(p, D | 16);
        return;
      }
      super.declareName(p, l, f), l & 2 && (l & 1 || (this.checkRedeclarationInScope(g, p, l, f), this.maybeExportDefined(g, p)), D = D | 1), l & 256 && (D = D | 2), l & 512 && (D = D | 4), l & 128 && (D = D | 8), D && g.tsNames.set(p, D);
    }
    isRedeclaredInScope(p, l, f) {
      let g = p.tsNames.get(l);
      if ((g & 2) > 0) {
        if (f & 256) {
          let D = !!(f & 512), A = (g & 4) > 0;
          return D !== A;
        }
        return !0;
      }
      return f & 128 && (g & 8) > 0 ? p.names.get(l) & 2 ? !!(f & 1) : !1 : f & 2 && (g & 1) > 0 ? !0 : super.isRedeclaredInScope(p, l, f);
    }
    checkLocalExport(p) {
      let { name: l } = p;
      if (this.hasImport(l))
        return;
      let f = this.scopeStack.length;
      for (let g = f - 1; g >= 0; g--) {
        let D = this.scopeStack[g].tsNames.get(l);
        if ((D & 1) > 0 || (D & 16) > 0)
          return;
      }
      super.checkLocalExport(p);
    }
  }, tT = (p, l) => Object.hasOwnProperty.call(p, l) && p[l], Hy = (p) => p.type === "ParenthesizedExpression" ? Hy(p.expression) : p, rT = class extends Xk {
    toAssignable(p, l = !1) {
      var f, g;
      let D;
      switch ((p.type === "ParenthesizedExpression" || (f = p.extra) != null && f.parenthesized) && (D = Hy(p), l ? D.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(x.InvalidParenthesizedAssignment, p) : D.type !== "MemberExpression" && !this.isOptionalMemberExpression(D) && this.raise(x.InvalidParenthesizedAssignment, p) : this.raise(x.InvalidParenthesizedAssignment, p)), p.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          p.type = "ObjectPattern";
          for (let T = 0, F = p.properties.length, N = F - 1; T < F; T++) {
            var A;
            let $ = p.properties[T], Y = T === N;
            this.toAssignableObjectExpressionProp($, Y, l), Y && $.type === "RestElement" && (A = p.extra) != null && A.trailingCommaLoc && this.raise(x.RestTrailingComma, p.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let { key: T, value: F } = p;
          this.isPrivateName(T) && this.classScope.usePrivateName(this.getPrivateNameSV(T), T.loc.start), this.toAssignable(F, l);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          p.type = "ArrayPattern", this.toAssignableList(p.elements, (g = p.extra) == null ? void 0 : g.trailingCommaLoc, l);
          break;
        case "AssignmentExpression":
          p.operator !== "=" && this.raise(x.MissingEqInAssignment, p.left.loc.end), p.type = "AssignmentPattern", delete p.operator, this.toAssignable(p.left, l);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(D, l);
          break;
      }
    }
    toAssignableObjectExpressionProp(p, l, f) {
      if (p.type === "ObjectMethod")
        this.raise(p.kind === "get" || p.kind === "set" ? x.PatternHasAccessor : x.PatternHasMethod, p.key);
      else if (p.type === "SpreadElement") {
        p.type = "RestElement";
        let g = p.argument;
        this.checkToRestConversion(g, !1), this.toAssignable(g, f), l || this.raise(x.RestTrailingComma, p);
      } else
        this.toAssignable(p, f);
    }
    toAssignableList(p, l, f) {
      let g = p.length - 1;
      for (let D = 0; D <= g; D++) {
        let A = p[D];
        if (A) {
          if (A.type === "SpreadElement") {
            A.type = "RestElement";
            let T = A.argument;
            this.checkToRestConversion(T, !0), this.toAssignable(T, f);
          } else
            this.toAssignable(A, f);
          A.type === "RestElement" && (D < g ? this.raise(x.RestTrailingComma, A) : l && this.raise(x.RestTrailingComma, l));
        }
      }
    }
    isAssignable(p, l) {
      switch (p.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let f = p.properties.length - 1;
          return p.properties.every((g, D) => g.type !== "ObjectMethod" && (D === f || g.type !== "SpreadElement") && this.isAssignable(g));
        }
        case "ObjectProperty":
          return this.isAssignable(p.value);
        case "SpreadElement":
          return this.isAssignable(p.argument);
        case "ArrayExpression":
          return p.elements.every((f) => f === null || this.isAssignable(f));
        case "AssignmentExpression":
          return p.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(p.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !l;
        default:
          return !1;
      }
    }
    toReferencedList(p, l) {
      return p;
    }
    toReferencedListDeep(p, l) {
      this.toReferencedList(p, l);
      for (let f of p)
        (f == null ? void 0 : f.type) === "ArrayExpression" && this.toReferencedListDeep(f.elements);
    }
    parseSpread(p) {
      let l = this.startNode();
      return this.next(), l.argument = this.parseMaybeAssignAllowIn(p, void 0), this.finishNode(l, "SpreadElement");
    }
    parseRestBinding() {
      let p = this.startNode();
      return this.next(), p.argument = this.parseBindingAtom(), this.finishNode(p, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let p = this.startNode();
          return this.next(), p.elements = this.parseBindingList(3, 93, 1), this.finishNode(p, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(p, l, f) {
      let g = f & 1, D = [], A = !0;
      for (; !this.eat(p); )
        if (A ? A = !1 : this.expect(12), g && this.match(12))
          D.push(null);
        else {
          if (this.eat(p))
            break;
          if (this.match(21)) {
            if (D.push(this.parseAssignableListItemTypes(this.parseRestBinding(), f)), !this.checkCommaAfterRest(l)) {
              this.expect(p);
              break;
            }
          } else {
            let T = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(x.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
              T.push(this.parseDecorator());
            D.push(this.parseAssignableListItem(f, T));
          }
        }
      return D;
    }
    parseBindingRestProperty(p) {
      return this.next(), p.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(p, "RestElement");
    }
    parseBindingProperty() {
      let p = this.startNode(), { type: l, startLoc: f } = this.state;
      return l === 21 ? this.parseBindingRestProperty(p) : (l === 138 ? (this.expectPlugin("destructuringPrivate", f), this.classScope.usePrivateName(this.state.value, f), p.key = this.parsePrivateName()) : this.parsePropertyName(p), p.method = !1, this.parseObjPropValue(p, f, !1, !1, !0, !1));
    }
    parseAssignableListItem(p, l) {
      let f = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(f, p);
      let g = this.parseMaybeDefault(f.loc.start, f);
      return l.length && (f.decorators = l), g;
    }
    parseAssignableListItemTypes(p, l) {
      return p;
    }
    parseMaybeDefault(p, l) {
      var f;
      if (p != null || (p = this.state.startLoc), l = (f = l) != null ? f : this.parseBindingAtom(), !this.eat(29))
        return l;
      let g = this.startNodeAt(p);
      return g.left = l, g.right = this.parseMaybeAssignAllowIn(), this.finishNode(g, "AssignmentPattern");
    }
    isValidLVal(p, l, f) {
      return tT({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, p);
    }
    isOptionalMemberExpression(p) {
      return p.type === "OptionalMemberExpression";
    }
    checkLVal(p, { in: l, binding: f = 64, checkClashes: g = !1, strictModeChanged: D = !1, hasParenthesizedAncestor: A = !1 }) {
      var T;
      let F = p.type;
      if (this.isObjectMethod(p))
        return;
      let N = this.isOptionalMemberExpression(p);
      if (N || F === "MemberExpression") {
        N && (this.expectPlugin("optionalChainingAssign", p.loc.start), l.type !== "AssignmentExpression" && this.raise(x.InvalidLhsOptionalChaining, p, { ancestor: l })), f !== 64 && this.raise(x.InvalidPropertyBindingPattern, p);
        return;
      }
      if (F === "Identifier") {
        this.checkIdentifier(p, f, D);
        let { name: le } = p;
        g && (g.has(le) ? this.raise(x.ParamDupe, p) : g.add(le));
        return;
      }
      let $ = this.isValidLVal(F, !(A || (T = p.extra) != null && T.parenthesized) && l.type === "AssignmentExpression", f);
      if ($ === !0)
        return;
      if ($ === !1) {
        let le = f === 64 ? x.InvalidLhs : x.InvalidLhsBinding;
        this.raise(le, p, { ancestor: l });
        return;
      }
      let [Y, ie] = Array.isArray($) ? $ : [$, F === "ParenthesizedExpression"], ce = F === "ArrayPattern" || F === "ObjectPattern" ? { type: F } : l;
      for (let le of [].concat(p[Y]))
        le && this.checkLVal(le, { in: ce, binding: f, checkClashes: g, strictModeChanged: D, hasParenthesizedAncestor: ie });
    }
    checkIdentifier(p, l, f = !1) {
      this.state.strict && (f ? Ry(p.name, this.inModule) : Ly(p.name)) && (l === 64 ? this.raise(x.StrictEvalArguments, p, { referenceName: p.name }) : this.raise(x.StrictEvalArgumentsBinding, p, { bindingName: p.name })), l & 8192 && p.name === "let" && this.raise(x.LetInLexicalBinding, p), l & 64 || this.declareNameFromIdentifier(p, l);
    }
    declareNameFromIdentifier(p, l) {
      this.scope.declareName(p.name, l, p.loc.start);
    }
    checkToRestConversion(p, l) {
      switch (p.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(p.expression, l);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (l)
            break;
        default:
          this.raise(x.InvalidRestAssignmentPattern, p);
      }
    }
    checkCommaAfterRest(p) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === p ? x.RestTrailingComma : x.ElementAfterRest, this.state.startLoc), !0) : !1;
    }
  }, iT = (p, l) => Object.hasOwnProperty.call(p, l) && p[l];
  function nT(p) {
    if (p == null)
      throw new Error(`Unexpected ${p} value.`);
    return p;
  }
  function Jy(p) {
    if (!p)
      throw new Error("Assert fail");
  }
  var me = S`typescript`({ AbstractMethodHasImplementation: ({ methodName: p }) => `Method '${p}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: p }) => `Property '${p}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: p }) => `'declare' is not allowed in ${p}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: p }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier: p }) => `Duplicate modifier: '${p}'.`, EmptyHeritageClauseType: ({ token: p }) => `'${p}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: p }) => `'${p[0]}' modifier cannot be used with '${p[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: p }) => `Index signatures cannot have an accessibility modifier ('${p}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier: p }) => `'${p}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: p }) => `'${p}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: p }) => `'${p}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: p }) => `'${p[0]}' modifier must precede '${p[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: p }) => `Private elements cannot have an accessibility modifier ('${p}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: p }) => `Single type parameter ${p} should have a trailing comma. Example usage: <${p},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: p }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${p}.` });
  function sT(p) {
    switch (p) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  function Ky(p) {
    return p === "private" || p === "public" || p === "protected";
  }
  function aT(p) {
    return p === "in" || p === "out";
  }
  var oT = (p) => class extends p {
    constructor(...l) {
      super(...l), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: me.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: me.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: me.InvalidModifierOnTypeParameter });
    }
    getScopeHandler() {
      return eT;
    }
    tsIsIdentifier() {
      return R(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(l, f) {
      if (!R(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let g = this.state.value;
      if (l.indexOf(g) !== -1) {
        if (f && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return g;
      }
    }
    tsParseModifiers({ allowedModifiers: l, disallowedModifiers: f, stopOnStartOfClassStaticBlock: g, errorTemplate: D = me.InvalidModifierOnTypeMember }, A) {
      let T = (N, $, Y, ie) => {
        $ === Y && A[ie] && this.raise(me.InvalidModifiersOrder, N, { orderedModifiers: [Y, ie] });
      }, F = (N, $, Y, ie) => {
        (A[Y] && $ === ie || A[ie] && $ === Y) && this.raise(me.IncompatibleModifiers, N, { modifiers: [Y, ie] });
      };
      for (; ; ) {
        let { startLoc: N } = this.state, $ = this.tsParseModifier(l.concat(f ?? []), g);
        if (!$)
          break;
        Ky($) ? A.accessibility ? this.raise(me.DuplicateAccessibilityModifier, N, { modifier: $ }) : (T(N, $, $, "override"), T(N, $, $, "static"), T(N, $, $, "readonly"), A.accessibility = $) : aT($) ? (A[$] && this.raise(me.DuplicateModifier, N, { modifier: $ }), A[$] = !0, T(N, $, "in", "out")) : (Object.hasOwnProperty.call(A, $) ? this.raise(me.DuplicateModifier, N, { modifier: $ }) : (T(N, $, "static", "readonly"), T(N, $, "static", "override"), T(N, $, "override", "readonly"), T(N, $, "abstract", "override"), F(N, $, "declare", "override"), F(N, $, "static", "abstract")), A[$] = !0), f != null && f.includes($) && this.raise(D, N, { modifier: $ });
      }
    }
    tsIsListTerminator(l) {
      switch (l) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(l, f) {
      let g = [];
      for (; !this.tsIsListTerminator(l); )
        g.push(f());
      return g;
    }
    tsParseDelimitedList(l, f, g) {
      return nT(this.tsParseDelimitedListWorker(l, f, !0, g));
    }
    tsParseDelimitedListWorker(l, f, g, D) {
      let A = [], T = -1;
      for (; !this.tsIsListTerminator(l); ) {
        T = -1;
        let F = f();
        if (F == null)
          return;
        if (A.push(F), this.eat(12)) {
          T = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(l))
          break;
        g && this.expect(12);
        return;
      }
      return D && (D.value = T), A;
    }
    tsParseBracketedList(l, f, g, D, A) {
      D || (g ? this.expect(0) : this.expect(47));
      let T = this.tsParseDelimitedList(l, f, A);
      return g ? this.expect(3) : this.expect(48), T;
    }
    tsParseImportType() {
      let l = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(me.UnsupportedImportTypeArgument, this.state.startLoc), l.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (l.qualifier = this.tsParseEntityName()), this.match(47) && (l.typeParameters = this.tsParseTypeArguments()), this.finishNode(l, "TSImportType");
    }
    tsParseEntityName(l = !0) {
      let f = this.parseIdentifier(l);
      for (; this.eat(16); ) {
        let g = this.startNodeAtNode(f);
        g.left = f, g.right = this.parseIdentifier(l), f = this.finishNode(g, "TSQualifiedName");
      }
      return f;
    }
    tsParseTypeReference() {
      let l = this.startNode();
      return l.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (l.typeParameters = this.tsParseTypeArguments()), this.finishNode(l, "TSTypeReference");
    }
    tsParseThisTypePredicate(l) {
      this.next();
      let f = this.startNodeAtNode(l);
      return f.parameterName = l, f.typeAnnotation = this.tsParseTypeAnnotation(!1), f.asserts = !1, this.finishNode(f, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let l = this.startNode();
      return this.next(), this.finishNode(l, "TSThisType");
    }
    tsParseTypeQuery() {
      let l = this.startNode();
      return this.expect(87), this.match(83) ? l.exprName = this.tsParseImportType() : l.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (l.typeParameters = this.tsParseTypeArguments()), this.finishNode(l, "TSTypeQuery");
    }
    tsParseTypeParameter(l) {
      let f = this.startNode();
      return l(f), f.name = this.tsParseTypeParameterName(), f.constraint = this.tsEatThenParseType(81), f.default = this.tsEatThenParseType(29), this.finishNode(f, "TSTypeParameter");
    }
    tsTryParseTypeParameters(l) {
      if (this.match(47))
        return this.tsParseTypeParameters(l);
    }
    tsParseTypeParameters(l) {
      let f = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let g = { value: -1 };
      return f.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, l), !1, !0, g), f.params.length === 0 && this.raise(me.EmptyTypeParameters, f), g.value !== -1 && this.addExtra(f, "trailingComma", g.value), this.finishNode(f, "TSTypeParameterDeclaration");
    }
    tsFillSignature(l, f) {
      let g = l === 19, D = "parameters", A = "typeAnnotation";
      f.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), f[D] = this.tsParseBindingListForSignature(), g ? f[A] = this.tsParseTypeOrTypePredicateAnnotation(l) : this.match(l) && (f[A] = this.tsParseTypeOrTypePredicateAnnotation(l));
    }
    tsParseBindingListForSignature() {
      let l = super.parseBindingList(11, 41, 2);
      for (let f of l) {
        let { type: g } = f;
        (g === "AssignmentPattern" || g === "TSParameterProperty") && this.raise(me.UnsupportedSignatureParameterKind, f, { type: g });
      }
      return l;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(l, f) {
      return this.tsFillSignature(14, f), this.tsParseTypeMemberSemicolon(), this.finishNode(f, l);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), R(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(l) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let f = this.parseIdentifier();
      f.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(f), this.expect(3), l.parameters = [f];
      let g = this.tsTryParseTypeAnnotation();
      return g && (l.typeAnnotation = g), this.tsParseTypeMemberSemicolon(), this.finishNode(l, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(l, f) {
      this.eat(17) && (l.optional = !0);
      let g = l;
      if (this.match(10) || this.match(47)) {
        f && this.raise(me.ReadonlyForMethodSignature, l);
        let D = g;
        D.kind && this.match(47) && this.raise(me.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, D), this.tsParseTypeMemberSemicolon();
        let A = "parameters", T = "typeAnnotation";
        if (D.kind === "get")
          D[A].length > 0 && (this.raise(x.BadGetterArity, this.state.curPosition()), this.isThisParam(D[A][0]) && this.raise(me.AccesorCannotDeclareThisParameter, this.state.curPosition()));
        else if (D.kind === "set") {
          if (D[A].length !== 1)
            this.raise(x.BadSetterArity, this.state.curPosition());
          else {
            let F = D[A][0];
            this.isThisParam(F) && this.raise(me.AccesorCannotDeclareThisParameter, this.state.curPosition()), F.type === "Identifier" && F.optional && this.raise(me.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), F.type === "RestElement" && this.raise(me.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          D[T] && this.raise(me.SetAccesorCannotHaveReturnType, D[T]);
        } else
          D.kind = "method";
        return this.finishNode(D, "TSMethodSignature");
      } else {
        let D = g;
        f && (D.readonly = !0);
        let A = this.tsTryParseTypeAnnotation();
        return A && (D.typeAnnotation = A), this.tsParseTypeMemberSemicolon(), this.finishNode(D, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let l = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", l);
      if (this.match(77)) {
        let g = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", l) : (l.key = this.createIdentifier(g, "new"), this.tsParsePropertyOrMethodSignature(l, !1));
      }
      return this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, l), this.tsTryParseIndexSignature(l) || (super.parsePropertyName(l), !l.computed && l.key.type === "Identifier" && (l.key.name === "get" || l.key.name === "set") && this.tsTokenCanFollowModifier() && (l.kind = l.key.name, super.parsePropertyName(l)), this.tsParsePropertyOrMethodSignature(l, !!l.readonly));
    }
    tsParseTypeLiteral() {
      let l = this.startNode();
      return l.members = this.tsParseObjectTypeMembers(), this.finishNode(l, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let l = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), l;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let l = this.startNode();
      return l.name = this.tsParseTypeParameterName(), l.constraint = this.tsExpectThenParseType(58), this.finishNode(l, "TSTypeParameter");
    }
    tsParseMappedType() {
      let l = this.startNode();
      return this.expect(5), this.match(53) ? (l.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (l.readonly = !0), this.expect(0), l.typeParameter = this.tsParseMappedTypeParameter(), l.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (l.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (l.optional = !0), l.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(l, "TSMappedType");
    }
    tsParseTupleType() {
      let l = this.startNode();
      l.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let f = !1;
      return l.elementTypes.forEach((g) => {
        let { type: D } = g;
        f && D !== "TSRestType" && D !== "TSOptionalType" && !(D === "TSNamedTupleMember" && g.optional) && this.raise(me.OptionalTypeBeforeRequired, g), f || (f = D === "TSNamedTupleMember" && g.optional || D === "TSOptionalType");
      }), this.finishNode(l, "TSTupleType");
    }
    tsParseTupleElementType() {
      let { startLoc: l } = this.state, f = this.eat(21), g, D, A, T, F = De(this.state.type) ? this.lookaheadCharCode() : null;
      if (F === 58)
        g = !0, A = !1, D = this.parseIdentifier(!0), this.expect(14), T = this.tsParseType();
      else if (F === 63) {
        A = !0;
        let N = this.state.startLoc, $ = this.state.value, Y = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (g = !0, D = this.createIdentifier(this.startNodeAt(N), $), this.expect(17), this.expect(14), T = this.tsParseType()) : (g = !1, T = Y, this.expect(17));
      } else
        T = this.tsParseType(), A = this.eat(17), g = this.eat(14);
      if (g) {
        let N;
        D ? (N = this.startNodeAtNode(D), N.optional = A, N.label = D, N.elementType = T, this.eat(17) && (N.optional = !0, this.raise(me.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (N = this.startNodeAtNode(T), N.optional = A, this.raise(me.InvalidTupleMemberLabel, T), N.label = T, N.elementType = this.tsParseType()), T = this.finishNode(N, "TSNamedTupleMember");
      } else if (A) {
        let N = this.startNodeAtNode(T);
        N.typeAnnotation = T, T = this.finishNode(N, "TSOptionalType");
      }
      if (f) {
        let N = this.startNodeAt(l);
        N.typeAnnotation = T, T = this.finishNode(N, "TSRestType");
      }
      return T;
    }
    tsParseParenthesizedType() {
      let l = this.startNode();
      return this.expect(10), l.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(l, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(l, f) {
      let g = this.startNode();
      return l === "TSConstructorType" && (g.abstract = !!f, f && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, g)), this.finishNode(g, l);
    }
    tsParseLiteralTypeNode() {
      let l = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          l.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(l, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let l = this.startNode();
      return l.literal = super.parseTemplate(!1), this.finishNode(l, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let l = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(l) : l;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let l = this.startNode(), f = this.lookahead();
            return f.type !== 134 && f.type !== 135 && this.unexpected(), l.literal = this.parseMaybeUnary(), this.finishNode(l, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let { type: l } = this.state;
          if (R(l) || l === 88 || l === 84) {
            let f = l === 88 ? "TSVoidKeyword" : l === 84 ? "TSNullKeyword" : sT(this.state.value);
            if (f !== void 0 && this.lookaheadCharCode() !== 46) {
              let g = this.startNode();
              return this.next(), this.finishNode(g, f);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let l = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let f = this.startNodeAtNode(l);
          f.elementType = l, this.expect(3), l = this.finishNode(f, "TSArrayType");
        } else {
          let f = this.startNodeAtNode(l);
          f.objectType = l, f.indexType = this.tsParseType(), this.expect(3), l = this.finishNode(f, "TSIndexedAccessType");
        }
      return l;
    }
    tsParseTypeOperator() {
      let l = this.startNode(), f = this.state.value;
      return this.next(), l.operator = f, l.typeAnnotation = this.tsParseTypeOperatorOrHigher(), f === "readonly" && this.tsCheckTypeAnnotationForReadOnly(l), this.finishNode(l, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(l) {
      switch (l.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(me.UnexpectedReadonly, l);
      }
    }
    tsParseInferType() {
      let l = this.startNode();
      this.expectContextual(115);
      let f = this.startNode();
      return f.name = this.tsParseTypeParameterName(), f.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), l.typeParameter = this.finishNode(f, "TSTypeParameter"), this.finishNode(l, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let l = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return l;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return qi(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(l, f, g) {
      let D = this.startNode(), A = this.eat(g), T = [];
      do
        T.push(f());
      while (this.eat(g));
      return T.length === 1 && !A ? T[0] : (D.types = T, this.finishNode(D, l));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (R(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let { errors: l } = this.state, f = l.length;
        try {
          return this.parseObjectLike(8, !0), l.length === f;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let { errors: l } = this.state, f = l.length;
        try {
          return super.parseBindingList(3, 93, 1), l.length === f;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(l) {
      return this.tsInType(() => {
        let f = this.startNode();
        this.expect(l);
        let g = this.startNode(), D = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (D && this.match(78)) {
          let F = this.tsParseThisTypeOrThisTypePredicate();
          return F.type === "TSThisType" ? (g.parameterName = F, g.asserts = !0, g.typeAnnotation = null, F = this.finishNode(g, "TSTypePredicate")) : (this.resetStartLocationFromNode(F, g), F.asserts = !0), f.typeAnnotation = F, this.finishNode(f, "TSTypeAnnotation");
        }
        let A = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!A)
          return D ? (g.parameterName = this.parseIdentifier(), g.asserts = D, g.typeAnnotation = null, f.typeAnnotation = this.finishNode(g, "TSTypePredicate"), this.finishNode(f, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, f);
        let T = this.tsParseTypeAnnotation(!1);
        return g.parameterName = A, g.typeAnnotation = T, g.asserts = D, f.typeAnnotation = this.finishNode(g, "TSTypePredicate"), this.finishNode(f, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let l = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), l;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let l = this.state.containsEsc;
      return this.next(), !R(this.state.type) && !this.match(78) ? !1 : (l && this.raise(x.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), !0);
    }
    tsParseTypeAnnotation(l = !0, f = this.startNode()) {
      return this.tsInType(() => {
        l && this.expect(14), f.typeAnnotation = this.tsParseType();
      }), this.finishNode(f, "TSTypeAnnotation");
    }
    tsParseType() {
      Jy(this.state.inType);
      let l = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return l;
      let f = this.startNodeAtNode(l);
      return f.checkType = l, f.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), f.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), f.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(f, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(me.ReservedTypeAssertion, this.state.startLoc);
      let l = this.startNode();
      return l.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), l.expression = this.parseMaybeUnary(), this.finishNode(l, "TSTypeAssertion");
    }
    tsParseHeritageClause(l) {
      let f = this.state.startLoc, g = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let D = this.startNode();
        return D.expression = this.tsParseEntityName(), this.match(47) && (D.typeParameters = this.tsParseTypeArguments()), this.finishNode(D, "TSExpressionWithTypeArguments");
      });
      return g.length || this.raise(me.EmptyHeritageClauseType, f, { token: l }), g;
    }
    tsParseInterfaceDeclaration(l, f = {}) {
      if (this.hasFollowingLineBreak())
        return null;
      this.expectContextual(129), f.declare && (l.declare = !0), R(this.state.type) ? (l.id = this.parseIdentifier(), this.checkIdentifier(l.id, 130)) : (l.id = null, this.raise(me.MissingInterfaceName, this.state.startLoc)), l.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (l.extends = this.tsParseHeritageClause("extends"));
      let g = this.startNode();
      return g.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), l.body = this.finishNode(g, "TSInterfaceBody"), this.finishNode(l, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(l) {
      return l.id = this.parseIdentifier(), this.checkIdentifier(l.id, 2), l.typeAnnotation = this.tsInType(() => {
        if (l.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
          let f = this.startNode();
          return this.next(), this.finishNode(f, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(l, "TSTypeAliasDeclaration");
    }
    tsInNoContext(l) {
      let f = this.state.context;
      this.state.context = [f[0]];
      try {
        return l();
      } finally {
        this.state.context = f;
      }
    }
    tsInType(l) {
      let f = this.state.inType;
      this.state.inType = !0;
      try {
        return l();
      } finally {
        this.state.inType = f;
      }
    }
    tsInDisallowConditionalTypesContext(l) {
      let f = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return l();
      } finally {
        this.state.inDisallowConditionalTypesContext = f;
      }
    }
    tsInAllowConditionalTypesContext(l) {
      let f = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return l();
      } finally {
        this.state.inDisallowConditionalTypesContext = f;
      }
    }
    tsEatThenParseType(l) {
      if (this.match(l))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(l) {
      return this.tsInType(() => (this.expect(l), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let l = this.startNode();
      return l.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (l.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(l, "TSEnumMember");
    }
    tsParseEnumDeclaration(l, f = {}) {
      return f.const && (l.const = !0), f.declare && (l.declare = !0), this.expectContextual(126), l.id = this.parseIdentifier(), this.checkIdentifier(l.id, l.const ? 8971 : 8459), this.expect(5), l.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(l, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let l = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(l.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(l, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(l, f = !1) {
      if (l.id = this.parseIdentifier(), f || this.checkIdentifier(l.id, 1024), this.eat(16)) {
        let g = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(g, !0), l.body = g;
      } else
        this.scope.enter(256), this.prodParam.enter(0), l.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(l, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(l) {
      return this.isContextual(112) ? (l.global = !0, l.id = this.parseIdentifier()) : this.match(133) ? l.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), l.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(l, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(l, f, g) {
      l.isExport = g || !1, l.id = f || this.parseIdentifier(), this.checkIdentifier(l.id, 4096), this.expect(29);
      let D = this.tsParseModuleReference();
      return l.importKind === "type" && D.type !== "TSExternalModuleReference" && this.raise(me.ImportAliasHasImportType, D), l.moduleReference = D, this.semicolon(), this.finishNode(l, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      let l = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), l.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(l, "TSExternalModuleReference");
    }
    tsLookAhead(l) {
      let f = this.state.clone(), g = l();
      return this.state = f, g;
    }
    tsTryParseAndCatch(l) {
      let f = this.tryParse((g) => l() || g());
      if (!(f.aborted || !f.node))
        return f.error && (this.state = f.failState), f.node;
    }
    tsTryParse(l) {
      let f = this.state.clone(), g = l();
      if (g !== void 0 && g !== !1)
        return g;
      this.state = f;
    }
    tsTryParseDeclare(l) {
      if (this.isLineTerminator())
        return;
      let f = this.state.type, g;
      return this.isContextual(100) && (f = 74, g = "let"), this.tsInAmbientContext(() => {
        switch (f) {
          case 68:
            return l.declare = !0, super.parseFunctionStatement(l, !1, !1);
          case 80:
            return l.declare = !0, this.parseClass(l, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(l, { declare: !0 });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(l);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (l.declare = !0, this.parseVarStatement(l, g || this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(l, { const: !0, declare: !0 }));
          case 129: {
            let D = this.tsParseInterfaceDeclaration(l, { declare: !0 });
            if (D)
              return D;
          }
          default:
            if (R(f))
              return this.tsParseDeclaration(l, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(l, f, g) {
      switch (f.name) {
        case "declare": {
          let D = this.tsTryParseDeclare(l);
          return D && (D.declare = !0), D;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let D = l;
            return D.global = !0, D.id = f, D.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(D, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(l, f.name, !1, g);
      }
    }
    tsParseDeclaration(l, f, g, D) {
      switch (f) {
        case "abstract":
          if (this.tsCheckLineTerminator(g) && (this.match(80) || R(this.state.type)))
            return this.tsParseAbstractDeclaration(l, D);
          break;
        case "module":
          if (this.tsCheckLineTerminator(g)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(l);
            if (R(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(l);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(g) && R(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(l);
          break;
        case "type":
          if (this.tsCheckLineTerminator(g) && R(this.state.type))
            return this.tsParseTypeAliasDeclaration(l);
          break;
      }
    }
    tsCheckLineTerminator(l) {
      return l ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(l) {
      if (!this.match(47))
        return;
      let f = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let g = this.tsTryParseAndCatch(() => {
        let D = this.startNodeAt(l);
        return D.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(D), D.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), D;
      });
      if (this.state.maybeInArrowParameters = f, !!g)
        return super.parseArrowExpression(g, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let l = this.startNode();
      return l.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), l.params.length === 0 ? this.raise(me.EmptyTypeArguments, l) : !this.state.inType && this.curContext() === I.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(l, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return Xi(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(l, f) {
      let g = this.state.startLoc, D = {};
      this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, D);
      let A = D.accessibility, T = D.override, F = D.readonly;
      !(l & 4) && (A || F || T) && this.raise(me.UnexpectedParameterModifier, g);
      let N = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(N, l);
      let $ = this.parseMaybeDefault(N.loc.start, N);
      if (A || F || T) {
        let Y = this.startNodeAt(g);
        return f.length && (Y.decorators = f), A && (Y.accessibility = A), F && (Y.readonly = F), T && (Y.override = T), $.type !== "Identifier" && $.type !== "AssignmentPattern" && this.raise(me.UnsupportedParameterPropertyKind, Y), Y.parameter = $, this.finishNode(Y, "TSParameterProperty");
      }
      return f.length && (N.decorators = f), $;
    }
    isSimpleParameter(l) {
      return l.type === "TSParameterProperty" && super.isSimpleParameter(l.parameter) || super.isSimpleParameter(l);
    }
    tsDisallowOptionalPattern(l) {
      for (let f of l.params)
        f.type !== "Identifier" && f.optional && !this.state.isAmbientContext && this.raise(me.PatternIsOptional, f);
    }
    setArrowFunctionParameters(l, f, g) {
      super.setArrowFunctionParameters(l, f, g), this.tsDisallowOptionalPattern(l);
    }
    parseFunctionBodyAndFinish(l, f, g = !1) {
      this.match(14) && (l.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let D = f === "FunctionDeclaration" ? "TSDeclareFunction" : f === "ClassMethod" || f === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return D && !this.match(5) && this.isLineTerminator() ? this.finishNode(l, D) : D === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(me.DeclareFunctionHasImplementation, l), l.declare) ? super.parseFunctionBodyAndFinish(l, D, g) : (this.tsDisallowOptionalPattern(l), super.parseFunctionBodyAndFinish(l, f, g));
    }
    registerFunctionStatementId(l) {
      !l.body && l.id ? this.checkIdentifier(l.id, 1024) : super.registerFunctionStatementId(l);
    }
    tsCheckForInvalidTypeCasts(l) {
      l.forEach((f) => {
        (f == null ? void 0 : f.type) === "TSTypeCastExpression" && this.raise(me.UnexpectedTypeAnnotation, f.typeAnnotation);
      });
    }
    toReferencedList(l, f) {
      return this.tsCheckForInvalidTypeCasts(l), l;
    }
    parseArrayLike(l, f, g, D) {
      let A = super.parseArrayLike(l, f, g, D);
      return A.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(A.elements), A;
    }
    parseSubscript(l, f, g, D) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let T = this.startNodeAt(f);
        return T.expression = l, this.finishNode(T, "TSNonNullExpression");
      }
      let A = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (g)
          return D.stop = !0, l;
        D.optionalChainMember = A = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let T, F = this.tsTryParseAndCatch(() => {
          if (!g && this.atPossibleAsyncArrow(l)) {
            let ie = this.tsTryParseGenericAsyncArrowFunction(f);
            if (ie)
              return ie;
          }
          let N = this.tsParseTypeArgumentsInExpression();
          if (!N)
            return;
          if (A && !this.match(10)) {
            T = this.state.curPosition();
            return;
          }
          if (zs(this.state.type)) {
            let ie = super.parseTaggedTemplateExpression(l, f, D);
            return ie.typeParameters = N, ie;
          }
          if (!g && this.eat(10)) {
            let ie = this.startNodeAt(f);
            return ie.callee = l, ie.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(ie.arguments), ie.typeParameters = N, D.optionalChainMember && (ie.optional = A), this.finishCallExpression(ie, D.optionalChainMember);
          }
          let $ = this.state.type;
          if ($ === 48 || $ === 52 || $ !== 10 && Mt($) && !this.hasPrecedingLineBreak())
            return;
          let Y = this.startNodeAt(f);
          return Y.expression = l, Y.typeParameters = N, this.finishNode(Y, "TSInstantiationExpression");
        });
        if (T && this.unexpected(T, 10), F)
          return F.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(me.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), F;
      }
      return super.parseSubscript(l, f, g, D);
    }
    parseNewCallee(l) {
      var f;
      super.parseNewCallee(l);
      let { callee: g } = l;
      g.type === "TSInstantiationExpression" && !((f = g.extra) != null && f.parenthesized) && (l.typeParameters = g.typeParameters, l.callee = g.expression);
    }
    parseExprOp(l, f, g) {
      let D;
      if (Us(58) > g && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (D = this.isContextual(120)))) {
        let A = this.startNodeAt(f);
        return A.expression = l, A.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (D && this.raise(x.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(A, D ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(A, f, g);
      }
      return super.parseExprOp(l, f, g);
    }
    checkReservedWord(l, f, g, D) {
      this.state.isAmbientContext || super.checkReservedWord(l, f, g, D);
    }
    checkImportReflection(l) {
      super.checkImportReflection(l), l.module && l.importKind !== "value" && this.raise(me.ImportReflectionHasImportType, l.specifiers[0].loc.start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(l) {
      if (super.isPotentialImportPhase(l))
        return !0;
      if (this.isContextual(130)) {
        let f = this.lookaheadCharCode();
        return l ? f === 123 || f === 42 : f !== 61;
      }
      return !l && this.isContextual(87);
    }
    applyImportPhase(l, f, g, D) {
      super.applyImportPhase(l, f, g, D), f ? l.exportKind = g === "type" ? "type" : "value" : l.importKind = g === "type" || g === "typeof" ? g : "value";
    }
    parseImport(l) {
      if (this.match(133))
        return l.importKind = "value", super.parseImport(l);
      let f;
      if (R(this.state.type) && this.lookaheadCharCode() === 61)
        return l.importKind = "value", this.tsParseImportEqualsDeclaration(l);
      if (this.isContextual(130)) {
        let g = this.parseMaybeImportPhase(l, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(l, g);
        f = super.parseImportSpecifiersAndAfter(l, g);
      } else
        f = super.parseImport(l);
      return f.importKind === "type" && f.specifiers.length > 1 && f.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(me.TypeImportCannotSpecifyDefaultAndNamed, f), f;
    }
    parseExport(l, f) {
      if (this.match(83)) {
        this.next();
        let g = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? g = this.parseMaybeImportPhase(l, !1) : l.importKind = "value", this.tsParseImportEqualsDeclaration(l, g, !0);
      } else if (this.eat(29)) {
        let g = l;
        return g.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(g, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let g = l;
        return this.expectContextual(128), g.id = this.parseIdentifier(), this.semicolon(), this.finishNode(g, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(l, f);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let l = this.startNode();
        return this.next(), l.abstract = !0, this.parseClass(l, !0, !0);
      }
      if (this.match(129)) {
        let l = this.tsParseInterfaceDeclaration(this.startNode());
        if (l)
          return l;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(l, f, g = !1) {
      let { isAmbientContext: D } = this.state, A = super.parseVarStatement(l, f, g || D);
      if (!D)
        return A;
      for (let { id: T, init: F } of A.declarations)
        F && (f !== "const" || T.typeAnnotation ? this.raise(me.InitializerNotAllowedInAmbientContext, F) : uT(F, this.hasPlugin("estree")) || this.raise(me.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, F));
      return A;
    }
    parseStatementContent(l, f) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let g = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(g, { const: !0 });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let g = this.tsParseInterfaceDeclaration(this.startNode());
        if (g)
          return g;
      }
      return super.parseStatementContent(l, f);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(l, f) {
      return f.some((g) => Ky(g) ? l.accessibility === g : !!l[g]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(l, f, g) {
      let D = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({ allowedModifiers: D, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: !0, errorTemplate: me.InvalidModifierOnTypeParameterPositions }, f);
      let A = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(f, D) && this.raise(me.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(l, f)) : this.parseClassMemberWithIsStatic(l, f, g, !!f.static);
      };
      f.declare ? this.tsInAmbientContext(A) : A();
    }
    parseClassMemberWithIsStatic(l, f, g, D) {
      let A = this.tsTryParseIndexSignature(f);
      if (A) {
        l.body.push(A), f.abstract && this.raise(me.IndexSignatureHasAbstract, f), f.accessibility && this.raise(me.IndexSignatureHasAccessibility, f, { modifier: f.accessibility }), f.declare && this.raise(me.IndexSignatureHasDeclare, f), f.override && this.raise(me.IndexSignatureHasOverride, f);
        return;
      }
      !this.state.inAbstractClass && f.abstract && this.raise(me.NonAbstractClassHasAbstractMethod, f), f.override && (g.hadSuperClass || this.raise(me.OverrideNotInSubClass, f)), super.parseClassMemberWithIsStatic(l, f, g, D);
    }
    parsePostMemberNameModifiers(l) {
      this.eat(17) && (l.optional = !0), l.readonly && this.match(10) && this.raise(me.ClassMethodHasReadonly, l), l.declare && this.match(10) && this.raise(me.ClassMethodHasDeclare, l);
    }
    parseExpressionStatement(l, f, g) {
      return (f.type === "Identifier" ? this.tsParseExpressionStatement(l, f, g) : void 0) || super.parseExpressionStatement(l, f, g);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(l, f, g) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(l, f, g);
      let D = this.tryParse(() => super.parseConditional(l, f));
      return D.node ? (D.error && (this.state = D.failState), D.node) : (D.error && super.setOptionalParametersError(g, D.error), l);
    }
    parseParenItem(l, f) {
      if (l = super.parseParenItem(l, f), this.eat(17) && (l.optional = !0, this.resetEndLocation(l)), this.match(14)) {
        let g = this.startNodeAt(f);
        return g.expression = l, g.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(g, "TSTypeCastExpression");
      }
      return l;
    }
    parseExportDeclaration(l) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(l));
      let f = this.state.startLoc, g = this.eatContextual(125);
      if (g && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(me.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let D = R(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(l);
      return D ? ((D.type === "TSInterfaceDeclaration" || D.type === "TSTypeAliasDeclaration" || g) && (l.exportKind = "type"), g && (this.resetStartLocation(D, f), D.declare = !0), D) : null;
    }
    parseClassId(l, f, g, D) {
      if ((!f || g) && this.isContextual(113))
        return;
      super.parseClassId(l, f, g, l.declare ? 1024 : 8331);
      let A = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      A && (l.typeParameters = A);
    }
    parseClassPropertyAnnotation(l) {
      l.optional || (this.eat(35) ? l.definite = !0 : this.eat(17) && (l.optional = !0));
      let f = this.tsTryParseTypeAnnotation();
      f && (l.typeAnnotation = f);
    }
    parseClassProperty(l) {
      if (this.parseClassPropertyAnnotation(l), this.state.isAmbientContext && !(l.readonly && !l.typeAnnotation) && this.match(29) && this.raise(me.DeclareClassFieldHasInitializer, this.state.startLoc), l.abstract && this.match(29)) {
        let { key: f } = l;
        this.raise(me.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: f.type === "Identifier" && !l.computed ? f.name : `[${this.input.slice(f.start, f.end)}]` });
      }
      return super.parseClassProperty(l);
    }
    parseClassPrivateProperty(l) {
      return l.abstract && this.raise(me.PrivateElementHasAbstract, l), l.accessibility && this.raise(me.PrivateElementHasAccessibility, l, { modifier: l.accessibility }), this.parseClassPropertyAnnotation(l), super.parseClassPrivateProperty(l);
    }
    parseClassAccessorProperty(l) {
      return this.parseClassPropertyAnnotation(l), l.optional && this.raise(me.AccessorCannotBeOptional, l), super.parseClassAccessorProperty(l);
    }
    pushClassMethod(l, f, g, D, A, T) {
      let F = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      F && A && this.raise(me.ConstructorHasTypeParameters, F);
      let { declare: N = !1, kind: $ } = f;
      N && ($ === "get" || $ === "set") && this.raise(me.DeclareAccessor, f, { kind: $ }), F && (f.typeParameters = F), super.pushClassMethod(l, f, g, D, A, T);
    }
    pushClassPrivateMethod(l, f, g, D) {
      let A = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      A && (f.typeParameters = A), super.pushClassPrivateMethod(l, f, g, D);
    }
    declareClassPrivateMethodInScope(l, f) {
      l.type !== "TSDeclareMethod" && (l.type === "MethodDefinition" && !l.value.body || super.declareClassPrivateMethodInScope(l, f));
    }
    parseClassSuper(l) {
      super.parseClassSuper(l), l.superClass && (this.match(47) || this.match(51)) && (l.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (l.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(l, f, g, D, A, T, F) {
      let N = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return N && (l.typeParameters = N), super.parseObjPropValue(l, f, g, D, A, T, F);
    }
    parseFunctionParams(l, f) {
      let g = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      g && (l.typeParameters = g), super.parseFunctionParams(l, f);
    }
    parseVarId(l, f) {
      super.parseVarId(l, f), l.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (l.definite = !0);
      let g = this.tsTryParseTypeAnnotation();
      g && (l.id.typeAnnotation = g, this.resetEndLocation(l.id));
    }
    parseAsyncArrowFromCallExpression(l, f) {
      return this.match(14) && (l.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(l, f);
    }
    parseMaybeAssign(l, f) {
      var g, D, A, T, F;
      let N, $, Y;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (N = this.state.clone(), $ = this.tryParse(() => super.parseMaybeAssign(l, f), N), !$.error)
          return $.node;
        let { context: le } = this.state, Ve = le[le.length - 1];
        (Ve === I.j_oTag || Ve === I.j_expr) && le.pop();
      }
      if (!((g = $) != null && g.error) && !this.match(47))
        return super.parseMaybeAssign(l, f);
      (!N || N === this.state) && (N = this.state.clone());
      let ie, ce = this.tryParse((le) => {
        var Ve, Xe;
        ie = this.tsParseTypeParameters(this.tsParseConstModifier);
        let Ot = super.parseMaybeAssign(l, f);
        return (Ot.type !== "ArrowFunctionExpression" || (Ve = Ot.extra) != null && Ve.parenthesized) && le(), ((Xe = ie) == null ? void 0 : Xe.params.length) !== 0 && this.resetStartLocationFromNode(Ot, ie), Ot.typeParameters = ie, Ot;
      }, N);
      if (!ce.error && !ce.aborted)
        return ie && this.reportReservedArrowTypeParam(ie), ce.node;
      if (!$ && (Jy(!this.hasPlugin("jsx")), Y = this.tryParse(() => super.parseMaybeAssign(l, f), N), !Y.error))
        return Y.node;
      if ((D = $) != null && D.node)
        return this.state = $.failState, $.node;
      if (ce.node)
        return this.state = ce.failState, ie && this.reportReservedArrowTypeParam(ie), ce.node;
      if ((A = Y) != null && A.node)
        return this.state = Y.failState, Y.node;
      throw ((T = $) == null ? void 0 : T.error) || ce.error || ((F = Y) == null ? void 0 : F.error);
    }
    reportReservedArrowTypeParam(l) {
      var f;
      l.params.length === 1 && !l.params[0].constraint && !((f = l.extra) != null && f.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(me.ReservedArrowTypeParam, l);
    }
    parseMaybeUnary(l, f) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(l, f);
    }
    parseArrow(l) {
      if (this.match(14)) {
        let f = this.tryParse((g) => {
          let D = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && g(), D;
        });
        if (f.aborted)
          return;
        f.thrown || (f.error && (this.state = f.failState), l.returnType = f.node);
      }
      return super.parseArrow(l);
    }
    parseAssignableListItemTypes(l, f) {
      if (!(f & 2))
        return l;
      this.eat(17) && (l.optional = !0);
      let g = this.tsTryParseTypeAnnotation();
      return g && (l.typeAnnotation = g), this.resetEndLocation(l), l;
    }
    isAssignable(l, f) {
      switch (l.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(l.expression, f);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(l, f);
      }
    }
    toAssignable(l, f = !1) {
      switch (l.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(l, f);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          f ? this.expressionScope.recordArrowParameterBindingError(me.UnexpectedTypeCastInParameter, l) : this.raise(me.UnexpectedTypeCastInParameter, l), this.toAssignable(l.expression, f);
          break;
        case "AssignmentExpression":
          !f && l.left.type === "TSTypeCastExpression" && (l.left = this.typeCastToParameter(l.left));
        default:
          super.toAssignable(l, f);
      }
    }
    toAssignableParenthesizedExpression(l, f) {
      switch (l.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(l.expression, f);
          break;
        default:
          super.toAssignable(l, f);
      }
    }
    checkToRestConversion(l, f) {
      switch (l.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(l.expression, !1);
          break;
        default:
          super.checkToRestConversion(l, f);
      }
    }
    isValidLVal(l, f, g) {
      return iT({ TSTypeCastExpression: !0, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (g !== 64 || !f) && ["expression", !0], TSSatisfiesExpression: (g !== 64 || !f) && ["expression", !0], TSTypeAssertion: (g !== 64 || !f) && ["expression", !0] }, l) || super.isValidLVal(l, f, g);
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(l) {
      if (this.match(47) || this.match(51)) {
        let f = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let g = super.parseMaybeDecoratorArguments(l);
          return g.typeParameters = f, g;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(l);
    }
    checkCommaAfterRest(l) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === l ? (this.next(), !1) : super.checkCommaAfterRest(l);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(l, f) {
      let g = super.parseMaybeDefault(l, f);
      return g.type === "AssignmentPattern" && g.typeAnnotation && g.right.start < g.typeAnnotation.start && this.raise(me.TypeAnnotationAfterAssign, g.typeAnnotation), g;
    }
    getTokenFromCode(l) {
      if (this.state.inType) {
        if (l === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (l === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(l);
    }
    reScan_lt_gt() {
      let { type: l } = this.state;
      l === 47 ? (this.state.pos -= 1, this.readToken_lt()) : l === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let { type: l } = this.state;
      return l === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : l;
    }
    toAssignableList(l, f, g) {
      for (let D = 0; D < l.length; D++) {
        let A = l[D];
        (A == null ? void 0 : A.type) === "TSTypeCastExpression" && (l[D] = this.typeCastToParameter(A));
      }
      super.toAssignableList(l, f, g);
    }
    typeCastToParameter(l) {
      return l.expression.typeAnnotation = l.typeAnnotation, this.resetEndLocation(l.expression, l.typeAnnotation.loc.end), l.expression;
    }
    shouldParseArrow(l) {
      return this.match(14) ? l.every((f) => this.isAssignable(f, !0)) : super.shouldParseArrow(l);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(l) {
      if (this.match(47) || this.match(51)) {
        let f = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        f && (l.typeParameters = f);
      }
      return super.jsxParseOpeningElementAfterName(l);
    }
    getGetterSetterExpectedParamCount(l) {
      let f = super.getGetterSetterExpectedParamCount(l), g = this.getObjectOrClassMethodParams(l)[0];
      return g && this.isThisParam(g) ? f + 1 : f;
    }
    parseCatchClauseParam() {
      let l = super.parseCatchClauseParam(), f = this.tsTryParseTypeAnnotation();
      return f && (l.typeAnnotation = f, this.resetEndLocation(l)), l;
    }
    tsInAmbientContext(l) {
      let f = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return l();
      } finally {
        this.state.isAmbientContext = f;
      }
    }
    parseClass(l, f, g) {
      let D = this.state.inAbstractClass;
      this.state.inAbstractClass = !!l.abstract;
      try {
        return super.parseClass(l, f, g);
      } finally {
        this.state.inAbstractClass = D;
      }
    }
    tsParseAbstractDeclaration(l, f) {
      if (this.match(80))
        return l.abstract = !0, this.maybeTakeDecorators(f, this.parseClass(l, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return l.abstract = !0, this.raise(me.NonClassMethodPropertyHasAbstractModifer, l), this.tsParseInterfaceDeclaration(l);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(l, f, g, D, A, T, F) {
      let N = super.parseMethod(l, f, g, D, A, T, F);
      if (N.abstract && (this.hasPlugin("estree") ? N.value.body : N.body)) {
        let { key: $ } = N;
        this.raise(me.AbstractMethodHasImplementation, N, { methodName: $.type === "Identifier" && !N.computed ? $.name : `[${this.input.slice($.start, $.end)}]` });
      }
      return N;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(l, f, g, D) {
      return !f && D ? (this.parseTypeOnlyImportExportSpecifier(l, !1, g), this.finishNode(l, "ExportSpecifier")) : (l.exportKind = "value", super.parseExportSpecifier(l, f, g, D));
    }
    parseImportSpecifier(l, f, g, D, A) {
      return !f && D ? (this.parseTypeOnlyImportExportSpecifier(l, !0, g), this.finishNode(l, "ImportSpecifier")) : (l.importKind = "value", super.parseImportSpecifier(l, f, g, D, g ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(l, f, g) {
      let D = f ? "imported" : "local", A = f ? "local" : "exported", T = l[D], F, N = !1, $ = !0, Y = T.loc.start;
      if (this.isContextual(93)) {
        let ce = this.parseIdentifier();
        if (this.isContextual(93)) {
          let le = this.parseIdentifier();
          De(this.state.type) ? (N = !0, T = ce, F = f ? this.parseIdentifier() : this.parseModuleExportName(), $ = !1) : (F = le, $ = !1);
        } else
          De(this.state.type) ? ($ = !1, F = f ? this.parseIdentifier() : this.parseModuleExportName()) : (N = !0, T = ce);
      } else
        De(this.state.type) && (N = !0, f ? (T = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(T.name, T.loc.start, !0, !0)) : T = this.parseModuleExportName());
      N && g && this.raise(f ? me.TypeModifierIsUsedInTypeImports : me.TypeModifierIsUsedInTypeExports, Y), l[D] = T, l[A] = F;
      let ie = f ? "importKind" : "exportKind";
      l[ie] = N ? "type" : "value", $ && this.eatContextual(93) && (l[A] = f ? this.parseIdentifier() : this.parseModuleExportName()), l[A] || (l[A] = Yi(l[D])), f && this.checkIdentifier(l[A], N ? 4098 : 4096);
    }
  };
  function lT(p) {
    if (p.type !== "MemberExpression")
      return !1;
    let { computed: l, property: f } = p;
    return l && f.type !== "StringLiteral" && (f.type !== "TemplateLiteral" || f.expressions.length > 0) ? !1 : t0(p.object);
  }
  function uT(p, l) {
    var f;
    let { type: g } = p;
    if ((f = p.extra) != null && f.parenthesized)
      return !1;
    if (l) {
      if (g === "Literal") {
        let { value: D } = p;
        if (typeof D == "string" || typeof D == "boolean")
          return !0;
      }
    } else if (g === "StringLiteral" || g === "BooleanLiteral")
      return !0;
    return !!(e0(p, l) || cT(p, l) || g === "TemplateLiteral" && p.expressions.length === 0 || lT(p));
  }
  function e0(p, l) {
    return l ? p.type === "Literal" && (typeof p.value == "number" || "bigint" in p) : p.type === "NumericLiteral" || p.type === "BigIntLiteral";
  }
  function cT(p, l) {
    if (p.type === "UnaryExpression") {
      let { operator: f, argument: g } = p;
      if (f === "-" && e0(g, l))
        return !0;
    }
    return !1;
  }
  function t0(p) {
    return p.type === "Identifier" ? !0 : p.type !== "MemberExpression" || p.computed ? !1 : t0(p.object);
  }
  var r0 = S`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), hT = (p) => class extends p {
    parsePlaceholder(l) {
      if (this.match(144)) {
        let f = this.startNode();
        return this.next(), this.assertNoSpace(), f.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(f, l);
      }
    }
    finishPlaceholder(l, f) {
      let g = !!(l.expectedNode && l.type === "Placeholder");
      return l.expectedNode = f, g ? l : this.finishNode(l, "Placeholder");
    }
    getTokenFromCode(l) {
      l === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(l);
    }
    parseExprAtom(l) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(l);
    }
    parseIdentifier(l) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(l);
    }
    checkReservedWord(l, f, g, D) {
      l !== void 0 && super.checkReservedWord(l, f, g, D);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(l, f, g) {
      return l === "Placeholder" || super.isValidLVal(l, f, g);
    }
    toAssignable(l, f) {
      l && l.type === "Placeholder" && l.expectedNode === "Expression" ? l.expectedNode = "Pattern" : super.toAssignable(l, f);
    }
    chStartsBindingIdentifier(l, f) {
      return !!(super.chStartsBindingIdentifier(l, f) || this.lookahead().type === 144);
    }
    verifyBreakContinue(l, f) {
      l.label && l.label.type === "Placeholder" || super.verifyBreakContinue(l, f);
    }
    parseExpressionStatement(l, f) {
      var g;
      if (f.type !== "Placeholder" || (g = f.extra) != null && g.parenthesized)
        return super.parseExpressionStatement(l, f);
      if (this.match(14)) {
        let D = l;
        return D.label = this.finishPlaceholder(f, "Identifier"), this.next(), D.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(D, "LabeledStatement");
      }
      return this.semicolon(), l.name = f.name, this.finishPlaceholder(l, "Statement");
    }
    parseBlock(l, f, g) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(l, f, g);
    }
    parseFunctionId(l) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(l);
    }
    parseClass(l, f, g) {
      let D = f ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let A = this.state.strict, T = this.parsePlaceholder("Identifier");
      if (T)
        if (this.match(81) || this.match(144) || this.match(5))
          l.id = T;
        else {
          if (g || !f)
            return l.id = null, l.body = this.finishPlaceholder(T, "ClassBody"), this.finishNode(l, D);
          throw this.raise(r0.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(l, f, g);
      return super.parseClassSuper(l), l.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!l.superClass, A), this.finishNode(l, D);
    }
    parseExport(l, f) {
      let g = this.parsePlaceholder("Identifier");
      if (!g)
        return super.parseExport(l, f);
      if (!this.isContextual(98) && !this.match(12))
        return l.specifiers = [], l.source = null, l.declaration = this.finishPlaceholder(g, "Declaration"), this.finishNode(l, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      let D = this.startNode();
      return D.exported = g, l.specifiers = [this.finishNode(D, "ExportDefaultSpecifier")], super.parseExport(l, f);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let l = this.nextTokenStart();
        if (this.isUnparsedContextual(l, "from") && this.input.startsWith(di(144), this.nextTokenStartSince(l + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(l, f) {
      var g;
      return (g = l.specifiers) != null && g.length ? !0 : super.maybeParseExportDefaultSpecifier(l, f);
    }
    checkExport(l) {
      let { specifiers: f } = l;
      f != null && f.length && (l.specifiers = f.filter((g) => g.exported.type === "Placeholder")), super.checkExport(l), l.specifiers = f;
    }
    parseImport(l) {
      let f = this.parsePlaceholder("Identifier");
      if (!f)
        return super.parseImport(l);
      if (l.specifiers = [], !this.isContextual(98) && !this.match(12))
        return l.source = this.finishPlaceholder(f, "StringLiteral"), this.semicolon(), this.finishNode(l, "ImportDeclaration");
      let g = this.startNodeAtNode(f);
      return g.local = f, l.specifiers.push(this.finishNode(g, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(l) || this.parseNamedImportSpecifiers(l)), this.expectContextual(98), l.source = this.parseImportSource(), this.semicolon(), this.finishNode(l, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(r0.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, pT = (p) => class extends p {
    parseV8Intrinsic() {
      if (this.match(54)) {
        let l = this.state.startLoc, f = this.startNode();
        if (this.next(), R(this.state.type)) {
          let g = this.parseIdentifierName(), D = this.createIdentifier(f, g);
          if (D.type = "V8IntrinsicIdentifier", this.match(10))
            return D;
        }
        this.unexpected(l);
      }
    }
    parseExprAtom(l) {
      return this.parseV8Intrinsic() || super.parseExprAtom(l);
    }
  };
  function gt(p, l) {
    let [f, g] = typeof l == "string" ? [l, {}] : l, D = Object.keys(g), A = D.length === 0;
    return p.some((T) => {
      if (typeof T == "string")
        return A && T === f;
      {
        let [F, N] = T;
        if (F !== f)
          return !1;
        for (let $ of D)
          if (N[$] !== g[$])
            return !1;
        return !0;
      }
    });
  }
  function On(p, l, f) {
    let g = p.find((D) => Array.isArray(D) ? D[0] === l : D === l);
    return g && Array.isArray(g) && g.length > 1 ? g[1][f] : null;
  }
  var i0 = ["minimal", "fsharp", "hack", "smart"], n0 = ["^^", "@@", "^", "%", "#"], s0 = ["hash", "bar"];
  function dT(p) {
    if (gt(p, "decorators")) {
      if (gt(p, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let l = On(p, "decorators", "decoratorsBeforeExport");
      if (l != null && typeof l != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let f = On(p, "decorators", "allowCallParenthesized");
      if (f != null && typeof f != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (gt(p, "flow") && gt(p, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (gt(p, "placeholders") && gt(p, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (gt(p, "pipelineOperator")) {
      let l = On(p, "pipelineOperator", "proposal");
      if (!i0.includes(l)) {
        let g = i0.map((D) => `"${D}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${g}.`);
      }
      let f = gt(p, ["recordAndTuple", { syntaxType: "hash" }]);
      if (l === "hack") {
        if (gt(p, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (gt(p, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let g = On(p, "pipelineOperator", "topicToken");
        if (!n0.includes(g)) {
          let D = n0.map((A) => `"${A}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${D}.`);
        }
        if (g === "#" && f)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      } else if (l === "smart" && f)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (gt(p, "moduleAttributes")) {
      if (gt(p, "importAssertions") || gt(p, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (On(p, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (gt(p, "importAssertions") && gt(p, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (gt(p, "recordAndTuple") && On(p, "recordAndTuple", "syntaxType") != null && !s0.includes(On(p, "recordAndTuple", "syntaxType")))
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + s0.map((l) => `'${l}'`).join(", "));
    if (gt(p, "asyncDoExpressions") && !gt(p, "doExpressions")) {
      let l = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw l.missingPlugins = "doExpressions", l;
    }
    if (gt(p, "optionalChainingAssign") && On(p, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
  }
  var a0 = { estree: E, jsx: Jk, flow: Hk, typescript: oT, v8intrinsic: pT, placeholders: hT }, fT = Object.keys(a0), Dp = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: !1, allowReturnOutsideFunction: !1, allowNewTargetOutsideFunction: !1, allowImportExportEverywhere: !1, allowSuperOutsideMethod: !1, allowUndeclaredExports: !1, plugins: [], strictMode: null, ranges: !1, tokens: !1, createImportExpressions: !1, createParenthesizedExpressions: !1, errorRecovery: !1, attachComment: !0, annexB: !0 };
  function mT(p) {
    if (p == null)
      return Object.assign({}, Dp);
    if (p.annexB != null && p.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    let l = {};
    for (let g of Object.keys(Dp)) {
      var f;
      l[g] = (f = p[g]) != null ? f : Dp[g];
    }
    return l;
  }
  var gT = class extends rT {
    checkProto(p, l, f, g) {
      if (p.type === "SpreadElement" || this.isObjectMethod(p) || p.computed || p.shorthand)
        return;
      let D = p.key;
      if ((D.type === "Identifier" ? D.name : D.value) === "__proto__") {
        if (l) {
          this.raise(x.RecordNoProto, D);
          return;
        }
        f.used && (g ? g.doubleProtoLoc === null && (g.doubleProtoLoc = D.loc.start) : this.raise(x.DuplicateProto, D)), f.used = !0;
      }
    }
    shouldExitDescending(p, l) {
      return p.type === "ArrowFunctionExpression" && p.start === l;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let p = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), p.comments = this.comments, p.errors = this.state.errors, this.options.tokens && (p.tokens = this.tokens), p;
    }
    parseExpression(p, l) {
      return p ? this.disallowInAnd(() => this.parseExpressionBase(l)) : this.allowInAnd(() => this.parseExpressionBase(l));
    }
    parseExpressionBase(p) {
      let l = this.state.startLoc, f = this.parseMaybeAssign(p);
      if (this.match(12)) {
        let g = this.startNodeAt(l);
        for (g.expressions = [f]; this.eat(12); )
          g.expressions.push(this.parseMaybeAssign(p));
        return this.toReferencedList(g.expressions), this.finishNode(g, "SequenceExpression");
      }
      return f;
    }
    parseMaybeAssignDisallowIn(p, l) {
      return this.disallowInAnd(() => this.parseMaybeAssign(p, l));
    }
    parseMaybeAssignAllowIn(p, l) {
      return this.allowInAnd(() => this.parseMaybeAssign(p, l));
    }
    setOptionalParametersError(p, l) {
      var f;
      p.optionalParametersLoc = (f = l == null ? void 0 : l.loc) != null ? f : this.state.startLoc;
    }
    parseMaybeAssign(p, l) {
      let f = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let T = this.parseYield();
        return l && (T = l.call(this, T, f)), T;
      }
      let g;
      p ? g = !1 : (p = new du(), g = !0);
      let { type: D } = this.state;
      (D === 10 || R(D)) && (this.state.potentialArrowAt = this.state.start);
      let A = this.parseMaybeConditional(p);
      if (l && (A = l.call(this, A, f)), wt(this.state.type)) {
        let T = this.startNodeAt(f), F = this.state.value;
        if (T.operator = F, this.match(29)) {
          this.toAssignable(A, !0), T.left = A;
          let N = f.index;
          p.doubleProtoLoc != null && p.doubleProtoLoc.index >= N && (p.doubleProtoLoc = null), p.shorthandAssignLoc != null && p.shorthandAssignLoc.index >= N && (p.shorthandAssignLoc = null), p.privateKeyLoc != null && p.privateKeyLoc.index >= N && (this.checkDestructuringPrivate(p), p.privateKeyLoc = null);
        } else
          T.left = A;
        return this.next(), T.right = this.parseMaybeAssign(), this.checkLVal(A, { in: this.finishNode(T, "AssignmentExpression") }), T;
      } else
        g && this.checkExpressionErrors(p, !0);
      return A;
    }
    parseMaybeConditional(p) {
      let l = this.state.startLoc, f = this.state.potentialArrowAt, g = this.parseExprOps(p);
      return this.shouldExitDescending(g, f) ? g : this.parseConditional(g, l, p);
    }
    parseConditional(p, l, f) {
      if (this.eat(17)) {
        let g = this.startNodeAt(l);
        return g.test = p, g.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), g.alternate = this.parseMaybeAssign(), this.finishNode(g, "ConditionalExpression");
      }
      return p;
    }
    parseMaybeUnaryOrPrivate(p) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(p);
    }
    parseExprOps(p) {
      let l = this.state.startLoc, f = this.state.potentialArrowAt, g = this.parseMaybeUnaryOrPrivate(p);
      return this.shouldExitDescending(g, f) ? g : this.parseExprOp(g, l, -1);
    }
    parseExprOp(p, l, f) {
      if (this.isPrivateName(p)) {
        let D = this.getPrivateNameSV(p);
        (f >= Us(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(x.PrivateInExpectedIn, p, { identifierName: D }), this.classScope.usePrivateName(D, p.loc.start);
      }
      let g = this.state.type;
      if (Pr(g) && (this.prodParam.hasIn || !this.match(58))) {
        let D = Us(g);
        if (D > f) {
          if (g === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return p;
            this.checkPipelineAtInfixOperator(p, l);
          }
          let A = this.startNodeAt(l);
          A.left = p, A.operator = this.state.value;
          let T = g === 41 || g === 42, F = g === 40;
          if (F && (D = Us(42)), this.next(), g === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(x.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          A.right = this.parseExprOpRightExpr(g, D);
          let N = this.finishNode(A, T || F ? "LogicalExpression" : "BinaryExpression"), $ = this.state.type;
          if (F && ($ === 41 || $ === 42) || T && $ === 40)
            throw this.raise(x.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(N, l, f);
        }
      }
      return p;
    }
    parseExprOpRightExpr(p, l) {
      let f = this.state.startLoc;
      switch (p) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(x.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(p, l), f);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(l));
          }
        default:
          return this.parseExprOpBaseRightExpr(p, l);
      }
    }
    parseExprOpBaseRightExpr(p, l) {
      let f = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), f, au(p) ? l - 1 : l);
    }
    parseHackPipeBody() {
      var p;
      let { startLoc: l } = this.state, f = this.parseMaybeAssign();
      return d.has(f.type) && !((p = f.extra) != null && p.parenthesized) && this.raise(x.PipeUnparenthesizedBody, l, { type: f.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(x.PipeTopicUnused, l), f;
    }
    checkExponentialAfterUnary(p) {
      this.match(57) && this.raise(x.UnexpectedTokenUnaryExponentiation, p.argument);
    }
    parseMaybeUnary(p, l) {
      let f = this.state.startLoc, g = this.isContextual(96);
      if (g && this.isAwaitAllowed()) {
        this.next();
        let F = this.parseAwait(f);
        return l || this.checkExponentialAfterUnary(F), F;
      }
      let D = this.match(34), A = this.startNode();
      if (mn(this.state.type)) {
        A.operator = this.state.value, A.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let F = this.match(89);
        if (this.next(), A.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(p, !0), this.state.strict && F) {
          let N = A.argument;
          N.type === "Identifier" ? this.raise(x.StrictDelete, A) : this.hasPropertyAsPrivateName(N) && this.raise(x.DeletePrivateField, A);
        }
        if (!D)
          return l || this.checkExponentialAfterUnary(A), this.finishNode(A, "UnaryExpression");
      }
      let T = this.parseUpdate(A, D, p);
      if (g) {
        let { type: F } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Mt(F) : Mt(F) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(x.AwaitNotInAsyncContext, f), this.parseAwait(f);
      }
      return T;
    }
    parseUpdate(p, l, f) {
      if (l) {
        let A = p;
        return this.checkLVal(A.argument, { in: this.finishNode(A, "UpdateExpression") }), p;
      }
      let g = this.state.startLoc, D = this.parseExprSubscripts(f);
      if (this.checkExpressionErrors(f, !1))
        return D;
      for (; pi(this.state.type) && !this.canInsertSemicolon(); ) {
        let A = this.startNodeAt(g);
        A.operator = this.state.value, A.prefix = !1, A.argument = D, this.next(), this.checkLVal(D, { in: D = this.finishNode(A, "UpdateExpression") });
      }
      return D;
    }
    parseExprSubscripts(p) {
      let l = this.state.startLoc, f = this.state.potentialArrowAt, g = this.parseExprAtom(p);
      return this.shouldExitDescending(g, f) ? g : this.parseSubscripts(g, l);
    }
    parseSubscripts(p, l, f) {
      let g = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(p), stop: !1 };
      do
        p = this.parseSubscript(p, l, f, g), g.maybeAsyncArrow = !1;
      while (!g.stop);
      return p;
    }
    parseSubscript(p, l, f, g) {
      let { type: D } = this.state;
      if (!f && D === 15)
        return this.parseBind(p, l, f, g);
      if (zs(D))
        return this.parseTaggedTemplateExpression(p, l, g);
      let A = !1;
      if (D === 18) {
        if (f && (this.raise(x.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return g.stop = !0, p;
        g.optionalChainMember = A = !0, this.next();
      }
      if (!f && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(p, l, g, A);
      {
        let T = this.eat(0);
        return T || A || this.eat(16) ? this.parseMember(p, l, g, T, A) : (g.stop = !0, p);
      }
    }
    parseMember(p, l, f, g, D) {
      let A = this.startNodeAt(l);
      return A.object = p, A.computed = g, g ? (A.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (p.type === "Super" && this.raise(x.SuperPrivateField, l), this.classScope.usePrivateName(this.state.value, this.state.startLoc), A.property = this.parsePrivateName()) : A.property = this.parseIdentifier(!0), f.optionalChainMember ? (A.optional = D, this.finishNode(A, "OptionalMemberExpression")) : this.finishNode(A, "MemberExpression");
    }
    parseBind(p, l, f, g) {
      let D = this.startNodeAt(l);
      return D.object = p, this.next(), D.callee = this.parseNoCallExpr(), g.stop = !0, this.parseSubscripts(this.finishNode(D, "BindExpression"), l, f);
    }
    parseCoverCallAndAsyncArrowHead(p, l, f, g) {
      let D = this.state.maybeInArrowParameters, A = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let T = this.startNodeAt(l);
      T.callee = p;
      let { maybeAsyncArrow: F, optionalChainMember: N } = f;
      F && (this.expressionScope.enter(Rk()), A = new du()), N && (T.optional = g), g ? T.arguments = this.parseCallExpressionArguments(11) : T.arguments = this.parseCallExpressionArguments(11, p.type === "Import", p.type !== "Super", T, A);
      let $ = this.finishCallExpression(T, N);
      return F && this.shouldParseAsyncArrow() && !g ? (f.stop = !0, this.checkDestructuringPrivate(A), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), $ = this.parseAsyncArrowFromCallExpression(this.startNodeAt(l), $)) : (F && (this.checkExpressionErrors(A, !0), this.expressionScope.exit()), this.toReferencedArguments($)), this.state.maybeInArrowParameters = D, $;
    }
    toReferencedArguments(p, l) {
      this.toReferencedListDeep(p.arguments, l);
    }
    parseTaggedTemplateExpression(p, l, f) {
      let g = this.startNodeAt(l);
      return g.tag = p, g.quasi = this.parseTemplate(!0), f.optionalChainMember && this.raise(x.OptionalChainingNoTemplate, l), this.finishNode(g, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(p) {
      return p.type === "Identifier" && p.name === "async" && this.state.lastTokEndLoc.index === p.end && !this.canInsertSemicolon() && p.end - p.start === 5 && p.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(p, l) {
      if (p.callee.type === "Import")
        if (p.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), p.arguments.length === 0 || p.arguments.length > 2)
          this.raise(x.ImportCallArity, p, { maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
        else
          for (let f of p.arguments)
            f.type === "SpreadElement" && this.raise(x.ImportCallSpreadArgument, f);
      return this.finishNode(p, l ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(p, l, f, g, D) {
      let A = [], T = !0, F = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(p); ) {
        if (T)
          T = !1;
        else if (this.expect(12), this.match(p)) {
          l && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(x.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), g && this.addTrailingCommaExtraToNode(g), this.next();
          break;
        }
        A.push(this.parseExprListItem(!1, D, f));
      }
      return this.state.inFSharpPipelineDirectBody = F, A;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(p, l) {
      var f;
      return this.resetPreviousNodeTrailingComments(l), this.expect(19), this.parseArrowExpression(p, l.arguments, !0, (f = l.extra) == null ? void 0 : f.trailingCommaLoc), l.innerComments && oo(p, l.innerComments), l.callee.trailingComments && oo(p, l.callee.trailingComments), p;
    }
    parseNoCallExpr() {
      let p = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), p, !0);
    }
    parseExprAtom(p) {
      let l, f = null, { type: g } = this.state;
      switch (g) {
        case 79:
          return this.parseSuper();
        case 83:
          return l = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(l) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(l) : this.finishNode(l, "Import") : (this.raise(x.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(l, "Import"));
        case 78:
          return l = this.startNode(), this.next(), this.finishNode(l, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let D = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(D);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, p);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, p);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          f = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(f, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          l = this.startNode(), this.next(), l.object = null;
          let D = l.callee = this.parseNoCallExpr();
          if (D.type === "MemberExpression")
            return this.finishNode(l, "BindExpression");
          throw this.raise(x.UnsupportedBind, D);
        }
        case 138:
          return this.raise(x.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let D = this.getPluginOption("pipelineOperator", "proposal");
          if (D)
            return this.parseTopicReference(D);
          this.unexpected();
          break;
        }
        case 47: {
          let D = this.input.codePointAt(this.nextTokenStart());
          _e(D) || D === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (R(g)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let D = this.state.potentialArrowAt === this.state.start, A = this.state.containsEsc, T = this.parseIdentifier();
            if (!A && T.name === "async" && !this.canInsertSemicolon()) {
              let { type: F } = this.state;
              if (F === 68)
                return this.resetPreviousNodeTrailingComments(T), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(T));
              if (R(F))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(T)) : T;
              if (F === 90)
                return this.resetPreviousNodeTrailingComments(T), this.parseDo(this.startNodeAtNode(T), !0);
            }
            return D && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(T), [T], !1)) : T;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(p, l) {
      let f = this.getPluginOption("pipelineOperator", "proposal");
      if (f)
        return this.state.type = p, this.state.value = l, this.state.pos--, this.state.end--, this.state.endLoc = n(this.state.endLoc, -1), this.parseTopicReference(f);
      this.unexpected();
    }
    parseTopicReference(p) {
      let l = this.startNode(), f = this.state.startLoc, g = this.state.type;
      return this.next(), this.finishTopicReference(l, f, p, g);
    }
    finishTopicReference(p, l, f, g) {
      if (this.testTopicReferenceConfiguration(f, l, g)) {
        let D = f === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(f === "smart" ? x.PrimaryTopicNotAllowed : x.PipeTopicUnbound, l), this.registerTopicReference(), this.finishNode(p, D);
      } else
        throw this.raise(x.PipeTopicUnconfiguredToken, l, { token: di(g) });
    }
    testTopicReferenceConfiguration(p, l, f) {
      switch (p) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", { topicToken: di(f) }]);
        case "smart":
          return f === 27;
        default:
          throw this.raise(x.PipeTopicRequiresHackPipes, l);
      }
    }
    parseAsyncArrowUnaryFunction(p) {
      this.prodParam.enter(pu(!0, this.prodParam.hasYield));
      let l = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(x.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(p, l, !0);
    }
    parseDo(p, l) {
      this.expectPlugin("doExpressions"), l && this.expectPlugin("asyncDoExpressions"), p.async = l, this.next();
      let f = this.state.labels;
      return this.state.labels = [], l ? (this.prodParam.enter(2), p.body = this.parseBlock(), this.prodParam.exit()) : p.body = this.parseBlock(), this.state.labels = f, this.finishNode(p, "DoExpression");
    }
    parseSuper() {
      let p = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(x.SuperNotAllowed, p) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(x.UnexpectedSuper, p), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(x.UnsupportedSuper, p), this.finishNode(p, "Super");
    }
    parsePrivateName() {
      let p = this.startNode(), l = this.startNodeAt(n(this.state.startLoc, 1)), f = this.state.value;
      return this.next(), p.id = this.createIdentifier(l, f), this.finishNode(p, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let p = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let l = this.createIdentifier(this.startNodeAtNode(p), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(p, l, "sent");
      }
      return this.parseFunction(p);
    }
    parseMetaProperty(p, l, f) {
      p.meta = l;
      let g = this.state.containsEsc;
      return p.property = this.parseIdentifier(!0), (p.property.name !== f || g) && this.raise(x.UnsupportedMetaProperty, p.property, { target: l.name, onlyValidPropertyName: f }), this.finishNode(p, "MetaProperty");
    }
    parseImportMetaProperty(p) {
      let l = this.createIdentifier(this.startNodeAtNode(p), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(x.ImportMetaOutsideModule, l), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let f = this.isContextual(105);
        if (f || this.unexpected(), this.expectPlugin(f ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(x.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
        return this.next(), p.phase = f ? "source" : "defer", this.parseImportCall(p);
      }
      return this.parseMetaProperty(p, l, "meta");
    }
    parseLiteralAtNode(p, l, f) {
      return this.addExtra(f, "rawValue", p), this.addExtra(f, "raw", this.input.slice(f.start, this.state.end)), f.value = p, this.next(), this.finishNode(f, l);
    }
    parseLiteral(p, l) {
      let f = this.startNode();
      return this.parseLiteralAtNode(p, l, f);
    }
    parseStringLiteral(p) {
      return this.parseLiteral(p, "StringLiteral");
    }
    parseNumericLiteral(p) {
      return this.parseLiteral(p, "NumericLiteral");
    }
    parseBigIntLiteral(p) {
      return this.parseLiteral(p, "BigIntLiteral");
    }
    parseDecimalLiteral(p) {
      return this.parseLiteral(p, "DecimalLiteral");
    }
    parseRegExpLiteral(p) {
      let l = this.parseLiteral(p.value, "RegExpLiteral");
      return l.pattern = p.pattern, l.flags = p.flags, l;
    }
    parseBooleanLiteral(p) {
      let l = this.startNode();
      return l.value = p, this.next(), this.finishNode(l, "BooleanLiteral");
    }
    parseNullLiteral() {
      let p = this.startNode();
      return this.next(), this.finishNode(p, "NullLiteral");
    }
    parseParenAndDistinguishExpression(p) {
      let l = this.state.startLoc, f;
      this.next(), this.expressionScope.enter(Lk());
      let g = this.state.maybeInArrowParameters, D = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let A = this.state.startLoc, T = [], F = new du(), N = !0, $, Y;
      for (; !this.match(11); ) {
        if (N)
          N = !1;
        else if (this.expect(12, F.optionalParametersLoc === null ? null : F.optionalParametersLoc), this.match(11)) {
          Y = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let le = this.state.startLoc;
          if ($ = this.state.startLoc, T.push(this.parseParenItem(this.parseRestBinding(), le)), !this.checkCommaAfterRest(41))
            break;
        } else
          T.push(this.parseMaybeAssignAllowIn(F, this.parseParenItem));
      }
      let ie = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = g, this.state.inFSharpPipelineDirectBody = D;
      let ce = this.startNodeAt(l);
      return p && this.shouldParseArrow(T) && (ce = this.parseArrow(ce)) ? (this.checkDestructuringPrivate(F), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(ce, T, !1), ce) : (this.expressionScope.exit(), T.length || this.unexpected(this.state.lastTokStartLoc), Y && this.unexpected(Y), $ && this.unexpected($), this.checkExpressionErrors(F, !0), this.toReferencedListDeep(T, !0), T.length > 1 ? (f = this.startNodeAt(A), f.expressions = T, this.finishNode(f, "SequenceExpression"), this.resetEndLocation(f, ie)) : f = T[0], this.wrapParenthesis(l, f));
    }
    wrapParenthesis(p, l) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(l, "parenthesized", !0), this.addExtra(l, "parenStart", p.index), this.takeSurroundingComments(l, p.index, this.state.lastTokEndLoc.index), l;
      let f = this.startNodeAt(p);
      return f.expression = l, this.finishNode(f, "ParenthesizedExpression");
    }
    shouldParseArrow(p) {
      return !this.canInsertSemicolon();
    }
    parseArrow(p) {
      if (this.eat(19))
        return p;
    }
    parseParenItem(p, l) {
      return p;
    }
    parseNewOrNewTarget() {
      let p = this.startNode();
      if (this.next(), this.match(16)) {
        let l = this.createIdentifier(this.startNodeAtNode(p), "new");
        this.next();
        let f = this.parseMetaProperty(p, l, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(x.UnexpectedNewTarget, f), f;
      }
      return this.parseNew(p);
    }
    parseNew(p) {
      if (this.parseNewCallee(p), this.eat(10)) {
        let l = this.parseExprList(11);
        this.toReferencedList(l), p.arguments = l;
      } else
        p.arguments = [];
      return this.finishNode(p, "NewExpression");
    }
    parseNewCallee(p) {
      let l = this.match(83), f = this.parseNoCallExpr();
      p.callee = f, l && (f.type === "Import" || f.type === "ImportExpression") && this.raise(x.ImportCallNotNewExpression, f);
    }
    parseTemplateElement(p) {
      let { start: l, startLoc: f, end: g, value: D } = this.state, A = l + 1, T = this.startNodeAt(n(f, 1));
      D === null && (p || this.raise(x.InvalidEscapeSequenceTemplate, n(this.state.firstInvalidTemplateEscapePos, 1)));
      let F = this.match(24), N = F ? -1 : -2, $ = g + N;
      T.value = { raw: this.input.slice(A, $).replace(/\r\n?/g, `
`), cooked: D === null ? null : D.slice(1, N) }, T.tail = F, this.next();
      let Y = this.finishNode(T, "TemplateElement");
      return this.resetEndLocation(Y, n(this.state.lastTokEndLoc, N)), Y;
    }
    parseTemplate(p) {
      let l = this.startNode();
      l.expressions = [];
      let f = this.parseTemplateElement(p);
      for (l.quasis = [f]; !f.tail; )
        l.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), l.quasis.push(f = this.parseTemplateElement(p));
      return this.finishNode(l, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(p, l, f, g) {
      f && this.expectPlugin("recordAndTuple");
      let D = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let A = /* @__PURE__ */ Object.create(null), T = !0, F = this.startNode();
      for (F.properties = [], this.next(); !this.match(p); ) {
        if (T)
          T = !1;
        else if (this.expect(12), this.match(p)) {
          this.addTrailingCommaExtraToNode(F);
          break;
        }
        let $;
        l ? $ = this.parseBindingProperty() : ($ = this.parsePropertyDefinition(g), this.checkProto($, f, A, g)), f && !this.isObjectProperty($) && $.type !== "SpreadElement" && this.raise(x.InvalidRecordProperty, $), $.shorthand && this.addExtra($, "shorthand", !0), F.properties.push($);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = D;
      let N = "ObjectExpression";
      return l ? N = "ObjectPattern" : f && (N = "RecordExpression"), this.finishNode(F, N);
    }
    addTrailingCommaExtraToNode(p) {
      this.addExtra(p, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(p, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(p) {
      return !p.computed && p.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(p) {
      let l = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(x.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          l.push(this.parseDecorator());
      let f = this.startNode(), g = !1, D = !1, A;
      if (this.match(21))
        return l.length && this.unexpected(), this.parseSpread();
      l.length && (f.decorators = l, l = []), f.method = !1, p && (A = this.state.startLoc);
      let T = this.eat(55);
      this.parsePropertyNamePrefixOperator(f);
      let F = this.state.containsEsc, N = this.parsePropertyName(f, p);
      if (!T && !F && this.maybeAsyncOrAccessorProp(f)) {
        let $ = N.name;
        $ === "async" && !this.hasPrecedingLineBreak() && (g = !0, this.resetPreviousNodeTrailingComments(N), T = this.eat(55), this.parsePropertyName(f)), ($ === "get" || $ === "set") && (D = !0, this.resetPreviousNodeTrailingComments(N), f.kind = $, this.match(55) && (T = !0, this.raise(x.AccessorIsGenerator, this.state.curPosition(), { kind: $ }), this.next()), this.parsePropertyName(f));
      }
      return this.parseObjPropValue(f, A, T, g, !1, D, p);
    }
    getGetterSetterExpectedParamCount(p) {
      return p.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(p) {
      return p.params;
    }
    checkGetterSetterParams(p) {
      var l;
      let f = this.getGetterSetterExpectedParamCount(p), g = this.getObjectOrClassMethodParams(p);
      g.length !== f && this.raise(p.kind === "get" ? x.BadGetterArity : x.BadSetterArity, p), p.kind === "set" && ((l = g[g.length - 1]) == null ? void 0 : l.type) === "RestElement" && this.raise(x.BadSetterRestParameter, p);
    }
    parseObjectMethod(p, l, f, g, D) {
      if (D) {
        let A = this.parseMethod(p, l, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(A), A;
      }
      if (f || l || this.match(10))
        return g && this.unexpected(), p.kind = "method", p.method = !0, this.parseMethod(p, l, f, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(p, l, f, g) {
      if (p.shorthand = !1, this.eat(14))
        return p.value = f ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(g), this.finishNode(p, "ObjectProperty");
      if (!p.computed && p.key.type === "Identifier") {
        if (this.checkReservedWord(p.key.name, p.key.loc.start, !0, !1), f)
          p.value = this.parseMaybeDefault(l, Yi(p.key));
        else if (this.match(29)) {
          let D = this.state.startLoc;
          g != null ? g.shorthandAssignLoc === null && (g.shorthandAssignLoc = D) : this.raise(x.InvalidCoverInitializedName, D), p.value = this.parseMaybeDefault(l, Yi(p.key));
        } else
          p.value = Yi(p.key);
        return p.shorthand = !0, this.finishNode(p, "ObjectProperty");
      }
    }
    parseObjPropValue(p, l, f, g, D, A, T) {
      let F = this.parseObjectMethod(p, f, g, D, A) || this.parseObjectProperty(p, l, D, T);
      return F || this.unexpected(), F;
    }
    parsePropertyName(p, l) {
      if (this.eat(0))
        p.computed = !0, p.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let { type: f, value: g } = this.state, D;
        if (De(f))
          D = this.parseIdentifier(!0);
        else
          switch (f) {
            case 134:
              D = this.parseNumericLiteral(g);
              break;
            case 133:
              D = this.parseStringLiteral(g);
              break;
            case 135:
              D = this.parseBigIntLiteral(g);
              break;
            case 136:
              D = this.parseDecimalLiteral(g);
              break;
            case 138: {
              let A = this.state.startLoc;
              l != null ? l.privateKeyLoc === null && (l.privateKeyLoc = A) : this.raise(x.UnexpectedPrivateField, A), D = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        p.key = D, f !== 138 && (p.computed = !1);
      }
      return p.key;
    }
    initFunction(p, l) {
      p.id = null, p.generator = !1, p.async = l;
    }
    parseMethod(p, l, f, g, D, A, T = !1) {
      this.initFunction(p, f), p.generator = l, this.scope.enter(18 | (T ? 64 : 0) | (D ? 32 : 0)), this.prodParam.enter(pu(f, p.generator)), this.parseFunctionParams(p, g);
      let F = this.parseFunctionBodyAndFinish(p, A, !0);
      return this.prodParam.exit(), this.scope.exit(), F;
    }
    parseArrayLike(p, l, f, g) {
      f && this.expectPlugin("recordAndTuple");
      let D = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let A = this.startNode();
      return this.next(), A.elements = this.parseExprList(p, !f, g, A), this.state.inFSharpPipelineDirectBody = D, this.finishNode(A, f ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(p, l, f, g) {
      this.scope.enter(6);
      let D = pu(f, !1);
      !this.match(5) && this.prodParam.hasIn && (D |= 8), this.prodParam.enter(D), this.initFunction(p, f);
      let A = this.state.maybeInArrowParameters;
      return l && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(p, l, g)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(p, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = A, this.finishNode(p, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(p, l, f) {
      this.toAssignableList(l, f, !1), p.params = l;
    }
    parseFunctionBodyAndFinish(p, l, f = !1) {
      return this.parseFunctionBody(p, !1, f), this.finishNode(p, l);
    }
    parseFunctionBody(p, l, f = !1) {
      let g = l && !this.match(5);
      if (this.expressionScope.enter(zy()), g)
        p.body = this.parseMaybeAssign(), this.checkParams(p, !1, l, !1);
      else {
        let D = this.state.strict, A = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), p.body = this.parseBlock(!0, !1, (T) => {
          let F = !this.isSimpleParamList(p.params);
          T && F && this.raise(x.IllegalLanguageModeDirective, (p.kind === "method" || p.kind === "constructor") && p.key ? p.key.loc.end : p);
          let N = !D && this.state.strict;
          this.checkParams(p, !this.state.strict && !l && !f && !F, l, N), this.state.strict && p.id && this.checkIdentifier(p.id, 65, N);
        }), this.prodParam.exit(), this.state.labels = A;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(p) {
      return p.type === "Identifier";
    }
    isSimpleParamList(p) {
      for (let l = 0, f = p.length; l < f; l++)
        if (!this.isSimpleParameter(p[l]))
          return !1;
      return !0;
    }
    checkParams(p, l, f, g = !0) {
      let D = !l && /* @__PURE__ */ new Set(), A = { type: "FormalParameters" };
      for (let T of p.params)
        this.checkLVal(T, { in: A, binding: 5, checkClashes: D, strictModeChanged: g });
    }
    parseExprList(p, l, f, g) {
      let D = [], A = !0;
      for (; !this.eat(p); ) {
        if (A)
          A = !1;
        else if (this.expect(12), this.match(p)) {
          g && this.addTrailingCommaExtraToNode(g), this.next();
          break;
        }
        D.push(this.parseExprListItem(l, f));
      }
      return D;
    }
    parseExprListItem(p, l, f) {
      let g;
      if (this.match(12))
        p || this.raise(x.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), g = null;
      else if (this.match(21)) {
        let D = this.state.startLoc;
        g = this.parseParenItem(this.parseSpread(l), D);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), f || this.raise(x.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let D = this.startNode();
        this.next(), g = this.finishNode(D, "ArgumentPlaceholder");
      } else
        g = this.parseMaybeAssignAllowIn(l, this.parseParenItem);
      return g;
    }
    parseIdentifier(p) {
      let l = this.startNode(), f = this.parseIdentifierName(p);
      return this.createIdentifier(l, f);
    }
    createIdentifier(p, l) {
      return p.name = l, p.loc.identifierName = l, this.finishNode(p, "Identifier");
    }
    parseIdentifierName(p) {
      let l, { startLoc: f, type: g } = this.state;
      De(g) ? l = this.state.value : this.unexpected();
      let D = Se(g);
      return p ? D && this.replaceToken(132) : this.checkReservedWord(l, f, D, !1), this.next(), l;
    }
    checkReservedWord(p, l, f, g) {
      if (!(p.length > 10 || !vk(p))) {
        if (f && xk(p)) {
          this.raise(x.UnexpectedKeyword, l, { keyword: p });
          return;
        }
        if ((this.state.strict ? g ? Ry : Gs : Vi)(p, this.inModule)) {
          this.raise(x.UnexpectedReservedWord, l, { reservedWord: p });
          return;
        } else if (p === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(x.YieldBindingIdentifier, l);
            return;
          }
        } else if (p === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(x.AwaitBindingIdentifier, l);
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(x.AwaitBindingIdentifierInStaticBlock, l);
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError(l);
        } else if (p === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(x.ArgumentsInClass, l);
          return;
        }
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(p) {
      let l = this.startNodeAt(p);
      return this.expressionScope.recordParameterInitializerError(x.AwaitExpressionFormalParameter, l), this.eat(55) && this.raise(x.ObsoleteAwaitStar, l), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (l.argument = this.parseMaybeUnary(null, !0)), this.finishNode(l, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak())
        return !0;
      let { type: p } = this.state;
      return p === 53 || p === 10 || p === 0 || zs(p) || p === 102 && !this.state.containsEsc || p === 137 || p === 56 || this.hasPlugin("v8intrinsic") && p === 54;
    }
    parseYield() {
      let p = this.startNode();
      this.expressionScope.recordParameterInitializerError(x.YieldInParameter, p), this.next();
      let l = !1, f = null;
      if (!this.hasPrecedingLineBreak())
        switch (l = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!l)
              break;
          default:
            f = this.parseMaybeAssign();
        }
      return p.delegate = l, p.argument = f, this.finishNode(p, "YieldExpression");
    }
    parseImportCall(p) {
      return this.next(), p.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (p.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (p.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(p, "ImportExpression");
    }
    checkPipelineAtInfixOperator(p, l) {
      this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && p.type === "SequenceExpression" && this.raise(x.PipelineHeadSequenceExpression, l);
    }
    parseSmartPipelineBodyInStyle(p, l) {
      if (this.isSimpleReference(p)) {
        let f = this.startNodeAt(l);
        return f.callee = p, this.finishNode(f, "PipelineBareFunction");
      } else {
        let f = this.startNodeAt(l);
        return this.checkSmartPipeTopicBodyEarlyErrors(l), f.expression = p, this.finishNode(f, "PipelineTopicExpression");
      }
    }
    isSimpleReference(p) {
      switch (p.type) {
        case "MemberExpression":
          return !p.computed && this.isSimpleReference(p.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(p) {
      if (this.match(19))
        throw this.raise(x.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(x.PipelineTopicUnused, p);
    }
    withTopicBindingContext(p) {
      let l = this.state.topicContext;
      this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
      try {
        return p();
      } finally {
        this.state.topicContext = l;
      }
    }
    withSmartMixTopicForbiddingContext(p) {
      if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
        let l = this.state.topicContext;
        this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
        try {
          return p();
        } finally {
          this.state.topicContext = l;
        }
      } else
        return p();
    }
    withSoloAwaitPermittingContext(p) {
      let l = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return p();
      } finally {
        this.state.soloAwait = l;
      }
    }
    allowInAnd(p) {
      let l = this.prodParam.currentFlags();
      if (8 & ~l) {
        this.prodParam.enter(l | 8);
        try {
          return p();
        } finally {
          this.prodParam.exit();
        }
      }
      return p();
    }
    disallowInAnd(p) {
      let l = this.prodParam.currentFlags();
      if (8 & l) {
        this.prodParam.enter(l & -9);
        try {
          return p();
        } finally {
          this.prodParam.exit();
        }
      }
      return p();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(p) {
      let l = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let f = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let g = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), l, p);
      return this.state.inFSharpPipelineDirectBody = f, g;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let p = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let l = this.startNodeAt(this.state.endLoc);
      this.next();
      let f = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        p.body = this.parseProgram(l, 8, "module");
      } finally {
        f();
      }
      return this.finishNode(p, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(p) {
    }
  }, vp = { kind: 1 }, yT = { kind: 2 }, OT = /[\uD800-\uDFFF]/u, Sp = /in(?:stanceof)?/y;
  function xT(p, l) {
    for (let f = 0; f < p.length; f++) {
      let g = p[f], { type: D } = g;
      if (typeof D == "number") {
        {
          if (D === 138) {
            let { loc: A, start: T, value: F, end: N } = g, $ = T + 1, Y = n(A.start, 1);
            p.splice(f, 1, new gn({ type: zr(27), value: "#", start: T, end: $, startLoc: A.start, endLoc: Y }), new gn({ type: zr(132), value: F, start: $, end: N, startLoc: Y, endLoc: A.end })), f++;
            continue;
          }
          if (zs(D)) {
            let { loc: A, start: T, value: F, end: N } = g, $ = T + 1, Y = n(A.start, 1), ie;
            l.charCodeAt(T) === 96 ? ie = new gn({ type: zr(22), value: "`", start: T, end: $, startLoc: A.start, endLoc: Y }) : ie = new gn({ type: zr(8), value: "}", start: T, end: $, startLoc: A.start, endLoc: Y });
            let ce, le, Ve, Xe;
            D === 24 ? (le = N - 1, Ve = n(A.end, -1), ce = F === null ? null : F.slice(1, -1), Xe = new gn({ type: zr(22), value: "`", start: le, end: N, startLoc: Ve, endLoc: A.end })) : (le = N - 2, Ve = n(A.end, -2), ce = F === null ? null : F.slice(1, -2), Xe = new gn({ type: zr(23), value: "${", start: le, end: N, startLoc: Ve, endLoc: A.end })), p.splice(f, 1, ie, new gn({ type: zr(20), value: ce, start: $, end: le, startLoc: Y, endLoc: Ve }), Xe), f += 2;
            continue;
          }
        }
        g.type = zr(D);
      }
    }
    return p;
  }
  var bT = class extends gT {
    parseTopLevel(p, l) {
      return p.program = this.parseProgram(l), p.comments = this.comments, this.options.tokens && (p.tokens = xT(this.tokens, this.input)), this.finishNode(p, "File");
    }
    parseProgram(p, l = 139, f = this.options.sourceType) {
      if (p.sourceType = f, p.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(p, !0, !0, l), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [D, A] of Array.from(this.scope.undefinedExports))
          this.raise(x.ModuleExportUndefined, A, { localName: D });
      let g;
      return l === 139 ? g = this.finishNode(p, "Program") : g = this.finishNodeAt(p, "Program", n(this.state.startLoc, -1)), g;
    }
    stmtToDirective(p) {
      let l = p;
      l.type = "Directive", l.value = l.expression, delete l.expression;
      let f = l.value, g = f.value, D = this.input.slice(f.start, f.end), A = f.value = D.slice(1, -1);
      return this.addExtra(f, "raw", D), this.addExtra(f, "rawValue", A), this.addExtra(f, "expressionValue", g), f.type = "DirectiveLiteral", l;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let p = this.startNode();
      return p.value = this.state.value, this.next(), this.finishNode(p, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(p, l) {
      if (_e(p)) {
        if (Sp.lastIndex = l, Sp.test(this.input)) {
          let f = this.codePointAtPos(Sp.lastIndex);
          if (!Be(f) && f !== 92)
            return !1;
        }
        return !0;
      } else
        return p === 92;
    }
    chStartsBindingPattern(p) {
      return p === 91 || p === 123;
    }
    hasFollowingBindingAtom() {
      let p = this.nextTokenStart(), l = this.codePointAtPos(p);
      return this.chStartsBindingPattern(l) || this.chStartsBindingIdentifier(l, p);
    }
    hasInLineFollowingBindingIdentifier() {
      let p = this.nextTokenInLineStart(), l = this.codePointAtPos(p);
      return this.chStartsBindingIdentifier(l, p);
    }
    startsUsingForOf() {
      let { type: p, containsEsc: l } = this.lookahead();
      if (p === 102 && !l)
        return !1;
      if (R(p) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let p = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(p, "using")) {
        p = this.nextTokenInLineStartSince(p + 5);
        let l = this.codePointAtPos(p);
        if (this.chStartsBindingIdentifier(l, p))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(p = !1) {
      let l = 0;
      return this.options.annexB && !this.state.strict && (l |= 4, p && (l |= 8)), this.parseStatementLike(l);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(p) {
      let l = null;
      return this.match(26) && (l = this.parseDecorators(!0)), this.parseStatementContent(p, l);
    }
    parseStatementContent(p, l) {
      let f = this.state.type, g = this.startNode(), D = !!(p & 2), A = !!(p & 4), T = p & 1;
      switch (f) {
        case 60:
          return this.parseBreakContinueStatement(g, !0);
        case 63:
          return this.parseBreakContinueStatement(g, !1);
        case 64:
          return this.parseDebuggerStatement(g);
        case 90:
          return this.parseDoWhileStatement(g);
        case 91:
          return this.parseForStatement(g);
        case 68:
          if (this.lookaheadCharCode() === 46)
            break;
          return A || this.raise(this.state.strict ? x.StrictFunction : this.options.annexB ? x.SloppyFunctionAnnexB : x.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(g, !1, !D && A);
        case 80:
          return D || this.unexpected(), this.parseClass(this.maybeTakeDecorators(l, g), !0);
        case 69:
          return this.parseIfStatement(g);
        case 70:
          return this.parseReturnStatement(g);
        case 71:
          return this.parseSwitchStatement(g);
        case 72:
          return this.parseThrowStatement(g);
        case 73:
          return this.parseTryStatement(g);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.isAwaitAllowed() ? D || this.raise(x.UnexpectedLexicalDeclaration, g) : this.raise(x.AwaitUsingNotInAsyncContext, g), this.next(), this.parseVarStatement(g, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(x.UnexpectedUsingDeclaration, this.state.startLoc) : D || this.raise(x.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(g, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let $ = this.nextTokenStart(), Y = this.codePointAtPos($);
          if (Y !== 91 && (!D && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(Y, $) && Y !== 123))
            break;
        }
        case 75:
          D || this.raise(x.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let $ = this.state.value;
          return this.parseVarStatement(g, $);
        }
        case 92:
          return this.parseWhileStatement(g);
        case 76:
          return this.parseWithStatement(g);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(g);
        case 83: {
          let $ = this.lookaheadCharCode();
          if ($ === 40 || $ === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !T && this.raise(x.UnexpectedImportExport, this.state.startLoc), this.next();
          let $;
          return f === 83 ? ($ = this.parseImport(g), $.type === "ImportDeclaration" && (!$.importKind || $.importKind === "value") && (this.sawUnambiguousESM = !0)) : ($ = this.parseExport(g, l), ($.type === "ExportNamedDeclaration" && (!$.exportKind || $.exportKind === "value") || $.type === "ExportAllDeclaration" && (!$.exportKind || $.exportKind === "value") || $.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed($), $;
        }
        default:
          if (this.isAsyncFunction())
            return D || this.raise(x.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(g, !0, !D && A);
      }
      let F = this.state.value, N = this.parseExpression();
      return R(f) && N.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(g, F, N, p) : this.parseExpressionStatement(g, N, l);
    }
    assertModuleNodeAllowed(p) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(x.ImportOutsideModule, p);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
    }
    maybeTakeDecorators(p, l, f) {
      return p && (l.decorators && l.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(x.DecoratorsBeforeAfterExport, l.decorators[0]), l.decorators.unshift(...p)) : l.decorators = p, this.resetStartLocationFromNode(l, p[0]), f && this.resetStartLocationFromNode(f, l)), l;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(p) {
      let l = [];
      do
        l.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        p || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(x.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(x.UnexpectedLeadingDecorator, this.state.startLoc);
      return l;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let p = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let l = this.state.startLoc, f;
        if (this.match(10)) {
          let g = this.state.startLoc;
          this.next(), f = this.parseExpression(), this.expect(11), f = this.wrapParenthesis(g, f);
          let D = this.state.startLoc;
          p.expression = this.parseMaybeDecoratorArguments(f), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && p.expression !== f && this.raise(x.DecoratorArgumentsOutsideParentheses, D);
        } else {
          for (f = this.parseIdentifier(!1); this.eat(16); ) {
            let g = this.startNodeAt(l);
            g.object = f, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), g.property = this.parsePrivateName()) : g.property = this.parseIdentifier(!0), g.computed = !1, f = this.finishNode(g, "MemberExpression");
          }
          p.expression = this.parseMaybeDecoratorArguments(f);
        }
      } else
        p.expression = this.parseExprSubscripts();
      return this.finishNode(p, "Decorator");
    }
    parseMaybeDecoratorArguments(p) {
      if (this.eat(10)) {
        let l = this.startNodeAtNode(p);
        return l.callee = p, l.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(l.arguments), this.finishNode(l, "CallExpression");
      }
      return p;
    }
    parseBreakContinueStatement(p, l) {
      return this.next(), this.isLineTerminator() ? p.label = null : (p.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(p, l), this.finishNode(p, l ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(p, l) {
      let f;
      for (f = 0; f < this.state.labels.length; ++f) {
        let g = this.state.labels[f];
        if ((p.label == null || g.name === p.label.name) && (g.kind != null && (l || g.kind === 1) || p.label && l))
          break;
      }
      if (f === this.state.labels.length) {
        let g = l ? "BreakStatement" : "ContinueStatement";
        this.raise(x.IllegalBreakContinue, p, { type: g });
      }
    }
    parseDebuggerStatement(p) {
      return this.next(), this.semicolon(), this.finishNode(p, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let p = this.parseExpression();
      return this.expect(11), p;
    }
    parseDoWhileStatement(p) {
      return this.next(), this.state.labels.push(vp), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), p.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(p, "DoWhileStatement");
    }
    parseForStatement(p) {
      this.next(), this.state.labels.push(vp);
      let l = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (l = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
        return l !== null && this.unexpected(l), this.parseFor(p, null);
      let f = this.isContextual(100);
      {
        let F = this.isContextual(96) && this.startsAwaitUsing(), N = F || this.isContextual(107) && this.startsUsingForOf(), $ = f && this.hasFollowingBindingAtom() || N;
        if (this.match(74) || this.match(75) || $) {
          let Y = this.startNode(), ie;
          F ? (ie = "await using", this.isAwaitAllowed() || this.raise(x.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : ie = this.state.value, this.next(), this.parseVar(Y, !0, ie);
          let ce = this.finishNode(Y, "VariableDeclaration"), le = this.match(58);
          return le && N && this.raise(x.ForInUsing, ce), (le || this.isContextual(102)) && ce.declarations.length === 1 ? this.parseForIn(p, ce, l) : (l !== null && this.unexpected(l), this.parseFor(p, ce));
        }
      }
      let g = this.isContextual(95), D = new du(), A = this.parseExpression(!0, D), T = this.isContextual(102);
      if (T && (f && this.raise(x.ForOfLet, A), l === null && g && A.type === "Identifier" && this.raise(x.ForOfAsync, A)), T || this.match(58)) {
        this.checkDestructuringPrivate(D), this.toAssignable(A, !0);
        let F = T ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(A, { in: { type: F } }), this.parseForIn(p, A, l);
      } else
        this.checkExpressionErrors(D, !0);
      return l !== null && this.unexpected(l), this.parseFor(p, A);
    }
    parseFunctionStatement(p, l, f) {
      return this.next(), this.parseFunction(p, 1 | (f ? 2 : 0) | (l ? 8 : 0));
    }
    parseIfStatement(p) {
      return this.next(), p.test = this.parseHeaderExpression(), p.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), p.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(p, "IfStatement");
    }
    parseReturnStatement(p) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(x.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? p.argument = null : (p.argument = this.parseExpression(), this.semicolon()), this.finishNode(p, "ReturnStatement");
    }
    parseSwitchStatement(p) {
      this.next(), p.discriminant = this.parseHeaderExpression();
      let l = p.cases = [];
      this.expect(5), this.state.labels.push(yT), this.scope.enter(0);
      let f;
      for (let g; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let D = this.match(61);
          f && this.finishNode(f, "SwitchCase"), l.push(f = this.startNode()), f.consequent = [], this.next(), D ? f.test = this.parseExpression() : (g && this.raise(x.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), g = !0, f.test = null), this.expect(14);
        } else
          f ? f.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), f && this.finishNode(f, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(p, "SwitchStatement");
    }
    parseThrowStatement(p) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(x.NewlineAfterThrow, this.state.lastTokEndLoc), p.argument = this.parseExpression(), this.semicolon(), this.finishNode(p, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let p = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && p.type === "Identifier" ? 8 : 0), this.checkLVal(p, { in: { type: "CatchClause" }, binding: 9 }), p;
    }
    parseTryStatement(p) {
      if (this.next(), p.block = this.parseBlock(), p.handler = null, this.match(62)) {
        let l = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), l.param = this.parseCatchClauseParam(), this.expect(11)) : (l.param = null, this.scope.enter(0)), l.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), p.handler = this.finishNode(l, "CatchClause");
      }
      return p.finalizer = this.eat(67) ? this.parseBlock() : null, !p.handler && !p.finalizer && this.raise(x.NoCatchOrFinally, p), this.finishNode(p, "TryStatement");
    }
    parseVarStatement(p, l, f = !1) {
      return this.next(), this.parseVar(p, !1, l, f), this.semicolon(), this.finishNode(p, "VariableDeclaration");
    }
    parseWhileStatement(p) {
      return this.next(), p.test = this.parseHeaderExpression(), this.state.labels.push(vp), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(p, "WhileStatement");
    }
    parseWithStatement(p) {
      return this.state.strict && this.raise(x.StrictWith, this.state.startLoc), this.next(), p.object = this.parseHeaderExpression(), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(p, "WithStatement");
    }
    parseEmptyStatement(p) {
      return this.next(), this.finishNode(p, "EmptyStatement");
    }
    parseLabeledStatement(p, l, f, g) {
      for (let A of this.state.labels)
        A.name === l && this.raise(x.LabelRedeclaration, f, { labelName: l });
      let D = fn(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let A = this.state.labels.length - 1; A >= 0; A--) {
        let T = this.state.labels[A];
        if (T.statementStart === p.start)
          T.statementStart = this.state.start, T.kind = D;
        else
          break;
      }
      return this.state.labels.push({ name: l, kind: D, statementStart: this.state.start }), p.body = g & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), p.label = f, this.finishNode(p, "LabeledStatement");
    }
    parseExpressionStatement(p, l, f) {
      return p.expression = l, this.semicolon(), this.finishNode(p, "ExpressionStatement");
    }
    parseBlock(p = !1, l = !0, f) {
      let g = this.startNode();
      return p && this.state.strictErrors.clear(), this.expect(5), l && this.scope.enter(0), this.parseBlockBody(g, p, !1, 8, f), l && this.scope.exit(), this.finishNode(g, "BlockStatement");
    }
    isValidDirective(p) {
      return p.type === "ExpressionStatement" && p.expression.type === "StringLiteral" && !p.expression.extra.parenthesized;
    }
    parseBlockBody(p, l, f, g, D) {
      let A = p.body = [], T = p.directives = [];
      this.parseBlockOrModuleBlockBody(A, l ? T : void 0, f, g, D);
    }
    parseBlockOrModuleBlockBody(p, l, f, g, D) {
      let A = this.state.strict, T = !1, F = !1;
      for (; !this.match(g); ) {
        let N = f ? this.parseModuleItem() : this.parseStatementListItem();
        if (l && !F) {
          if (this.isValidDirective(N)) {
            let $ = this.stmtToDirective(N);
            l.push($), !T && $.value.value === "use strict" && (T = !0, this.setStrict(!0));
            continue;
          }
          F = !0, this.state.strictErrors.clear();
        }
        p.push(N);
      }
      D == null || D.call(this, T), A || this.setStrict(!1), this.next();
    }
    parseFor(p, l) {
      return p.init = l, this.semicolon(!1), p.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), p.update = this.match(11) ? null : this.parseExpression(), this.expect(11), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(p, "ForStatement");
    }
    parseForIn(p, l, f) {
      let g = this.match(58);
      return this.next(), g ? f !== null && this.unexpected(f) : p.await = f !== null, l.type === "VariableDeclaration" && l.declarations[0].init != null && (!g || !this.options.annexB || this.state.strict || l.kind !== "var" || l.declarations[0].id.type !== "Identifier") && this.raise(x.ForInOfLoopInitializer, l, { type: g ? "ForInStatement" : "ForOfStatement" }), l.type === "AssignmentPattern" && this.raise(x.InvalidLhs, l, { ancestor: { type: "ForStatement" } }), p.left = l, p.right = g ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), p.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(p, g ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(p, l, f, g = !1) {
      let D = p.declarations = [];
      for (p.kind = f; ; ) {
        let A = this.startNode();
        if (this.parseVarId(A, f), A.init = this.eat(29) ? l ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, A.init === null && !g && (A.id.type !== "Identifier" && !(l && (this.match(58) || this.isContextual(102))) ? this.raise(x.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" }) : f === "const" && !(this.match(58) || this.isContextual(102)) && this.raise(x.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "const" })), D.push(this.finishNode(A, "VariableDeclarator")), !this.eat(12))
          break;
      }
      return p;
    }
    parseVarId(p, l) {
      let f = this.parseBindingAtom();
      this.checkLVal(f, { in: { type: "VariableDeclarator" }, binding: l === "var" ? 5 : 8201 }), p.id = f;
    }
    parseAsyncFunctionExpression(p) {
      return this.parseFunction(p, 8);
    }
    parseFunction(p, l = 0) {
      let f = l & 2, g = !!(l & 1), D = g && !(l & 4), A = !!(l & 8);
      this.initFunction(p, A), this.match(55) && (f && this.raise(x.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), p.generator = !0), g && (p.id = this.parseFunctionId(D));
      let T = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(pu(A, p.generator)), g || (p.id = this.parseFunctionId()), this.parseFunctionParams(p, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(p, g ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), g && !f && this.registerFunctionStatementId(p), this.state.maybeInArrowParameters = T, p;
    }
    parseFunctionId(p) {
      return p || R(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(p, l) {
      this.expect(10), this.expressionScope.enter(Mk()), p.params = this.parseBindingList(11, 41, 2 | (l ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(p) {
      p.id && this.scope.declareName(p.id.name, !this.options.annexB || this.state.strict || p.generator || p.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, p.id.loc.start);
    }
    parseClass(p, l, f) {
      this.next();
      let g = this.state.strict;
      return this.state.strict = !0, this.parseClassId(p, l, f), this.parseClassSuper(p), p.body = this.parseClassBody(!!p.superClass, g), this.finishNode(p, l ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(p) {
      return !p.computed && !p.static && (p.key.name === "constructor" || p.key.value === "constructor");
    }
    parseClassBody(p, l) {
      this.classScope.enter();
      let f = { hadConstructor: !1, hadSuperClass: p }, g = [], D = this.startNode();
      if (D.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (g.length > 0)
              throw this.raise(x.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            g.push(this.parseDecorator());
            continue;
          }
          let A = this.startNode();
          g.length && (A.decorators = g, this.resetStartLocationFromNode(A, g[0]), g = []), this.parseClassMember(D, A, f), A.kind === "constructor" && A.decorators && A.decorators.length > 0 && this.raise(x.DecoratorConstructor, A);
        }
      }), this.state.strict = l, this.next(), g.length)
        throw this.raise(x.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(D, "ClassBody");
    }
    parseClassMemberFromModifier(p, l) {
      let f = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let g = l;
        return g.kind = "method", g.computed = !1, g.key = f, g.static = !1, this.pushClassMethod(p, g, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let g = l;
        return g.computed = !1, g.key = f, g.static = !1, p.body.push(this.parseClassProperty(g)), !0;
      }
      return this.resetPreviousNodeTrailingComments(f), !1;
    }
    parseClassMember(p, l, f) {
      let g = this.isContextual(106);
      if (g) {
        if (this.parseClassMemberFromModifier(p, l))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(p, l);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(p, l, f, g);
    }
    parseClassMemberWithIsStatic(p, l, f, g) {
      let D = l, A = l, T = l, F = l, N = l, $ = D, Y = D;
      if (l.static = g, this.parsePropertyNamePrefixOperator(l), this.eat(55)) {
        $.kind = "method";
        let Xe = this.match(138);
        if (this.parseClassElementName($), Xe) {
          this.pushClassPrivateMethod(p, A, !0, !1);
          return;
        }
        this.isNonstaticConstructor(D) && this.raise(x.ConstructorIsGenerator, D.key), this.pushClassMethod(p, D, !0, !1, !1, !1);
        return;
      }
      let ie = R(this.state.type) && !this.state.containsEsc, ce = this.match(138), le = this.parseClassElementName(l), Ve = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(Y), this.isClassMethod()) {
        if ($.kind = "method", ce) {
          this.pushClassPrivateMethod(p, A, !1, !1);
          return;
        }
        let Xe = this.isNonstaticConstructor(D), Ot = !1;
        Xe && (D.kind = "constructor", f.hadConstructor && !this.hasPlugin("typescript") && this.raise(x.DuplicateConstructor, le), Xe && this.hasPlugin("typescript") && l.override && this.raise(x.OverrideOnConstructor, le), f.hadConstructor = !0, Ot = f.hadSuperClass), this.pushClassMethod(p, D, !1, !1, Xe, Ot);
      } else if (this.isClassProperty())
        ce ? this.pushClassPrivateProperty(p, F) : this.pushClassProperty(p, T);
      else if (ie && le.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(le);
        let Xe = this.eat(55);
        Y.optional && this.unexpected(Ve), $.kind = "method";
        let Ot = this.match(138);
        this.parseClassElementName($), this.parsePostMemberNameModifiers(Y), Ot ? this.pushClassPrivateMethod(p, A, Xe, !0) : (this.isNonstaticConstructor(D) && this.raise(x.ConstructorIsAsync, D.key), this.pushClassMethod(p, D, Xe, !0, !1, !1));
      } else if (ie && (le.name === "get" || le.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(le), $.kind = le.name;
        let Xe = this.match(138);
        this.parseClassElementName(D), Xe ? this.pushClassPrivateMethod(p, A, !1, !1) : (this.isNonstaticConstructor(D) && this.raise(x.ConstructorIsAccessor, D.key), this.pushClassMethod(p, D, !1, !1, !1, !1)), this.checkGetterSetterParams(D);
      } else if (ie && le.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(le);
        let Xe = this.match(138);
        this.parseClassElementName(T), this.pushClassAccessorProperty(p, N, Xe);
      } else
        this.isLineTerminator() ? ce ? this.pushClassPrivateProperty(p, F) : this.pushClassProperty(p, T) : this.unexpected();
    }
    parseClassElementName(p) {
      let { type: l, value: f } = this.state;
      if ((l === 132 || l === 133) && p.static && f === "prototype" && this.raise(x.StaticPrototype, this.state.startLoc), l === 138) {
        f === "constructor" && this.raise(x.ConstructorClassPrivateField, this.state.startLoc);
        let g = this.parsePrivateName();
        return p.key = g, g;
      }
      return this.parsePropertyName(p);
    }
    parseClassStaticBlock(p, l) {
      var f;
      this.scope.enter(208);
      let g = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let D = l.body = [];
      this.parseBlockOrModuleBlockBody(D, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = g, p.body.push(this.finishNode(l, "StaticBlock")), (f = l.decorators) != null && f.length && this.raise(x.DecoratorStaticBlock, l);
    }
    pushClassProperty(p, l) {
      !l.computed && (l.key.name === "constructor" || l.key.value === "constructor") && this.raise(x.ConstructorClassField, l.key), p.body.push(this.parseClassProperty(l));
    }
    pushClassPrivateProperty(p, l) {
      let f = this.parseClassPrivateProperty(l);
      p.body.push(f), this.classScope.declarePrivateName(this.getPrivateNameSV(f.key), 0, f.key.loc.start);
    }
    pushClassAccessorProperty(p, l, f) {
      if (!f && !l.computed) {
        let D = l.key;
        (D.name === "constructor" || D.value === "constructor") && this.raise(x.ConstructorClassField, D);
      }
      let g = this.parseClassAccessorProperty(l);
      p.body.push(g), f && this.classScope.declarePrivateName(this.getPrivateNameSV(g.key), 0, g.key.loc.start);
    }
    pushClassMethod(p, l, f, g, D, A) {
      p.body.push(this.parseMethod(l, f, g, D, A, "ClassMethod", !0));
    }
    pushClassPrivateMethod(p, l, f, g) {
      let D = this.parseMethod(l, f, g, !1, !1, "ClassPrivateMethod", !0);
      p.body.push(D);
      let A = D.kind === "get" ? D.static ? 6 : 2 : D.kind === "set" ? D.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(D, A);
    }
    declareClassPrivateMethodInScope(p, l) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(p.key), l, p.key.loc.start);
    }
    parsePostMemberNameModifiers(p) {
    }
    parseClassPrivateProperty(p) {
      return this.parseInitializer(p), this.semicolon(), this.finishNode(p, "ClassPrivateProperty");
    }
    parseClassProperty(p) {
      return this.parseInitializer(p), this.semicolon(), this.finishNode(p, "ClassProperty");
    }
    parseClassAccessorProperty(p) {
      return this.parseInitializer(p), this.semicolon(), this.finishNode(p, "ClassAccessorProperty");
    }
    parseInitializer(p) {
      this.scope.enter(80), this.expressionScope.enter(zy()), this.prodParam.enter(0), p.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(p, l, f, g = 8331) {
      if (R(this.state.type))
        p.id = this.parseIdentifier(), l && this.declareNameFromIdentifier(p.id, g);
      else if (f || !l)
        p.id = null;
      else
        throw this.raise(x.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(p) {
      p.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(p, l) {
      let f = this.parseMaybeImportPhase(p, !0), g = this.maybeParseExportDefaultSpecifier(p, f), D = !g || this.eat(12), A = D && this.eatExportStar(p), T = A && this.maybeParseExportNamespaceSpecifier(p), F = D && (!T || this.eat(12)), N = g || A;
      if (A && !T) {
        if (g && this.unexpected(), l)
          throw this.raise(x.UnsupportedDecoratorExport, p);
        return this.parseExportFrom(p, !0), this.finishNode(p, "ExportAllDeclaration");
      }
      let $ = this.maybeParseExportNamedSpecifiers(p);
      g && D && !A && !$ && this.unexpected(null, 5), T && F && this.unexpected(null, 98);
      let Y;
      if (N || $) {
        if (Y = !1, l)
          throw this.raise(x.UnsupportedDecoratorExport, p);
        this.parseExportFrom(p, N);
      } else
        Y = this.maybeParseExportDeclaration(p);
      if (N || $ || Y) {
        var ie;
        let ce = p;
        if (this.checkExport(ce, !0, !1, !!ce.source), ((ie = ce.declaration) == null ? void 0 : ie.type) === "ClassDeclaration")
          this.maybeTakeDecorators(l, ce.declaration, ce);
        else if (l)
          throw this.raise(x.UnsupportedDecoratorExport, p);
        return this.finishNode(ce, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let ce = p, le = this.parseExportDefaultExpression();
        if (ce.declaration = le, le.type === "ClassDeclaration")
          this.maybeTakeDecorators(l, le, ce);
        else if (l)
          throw this.raise(x.UnsupportedDecoratorExport, p);
        return this.checkExport(ce, !0, !0), this.finishNode(ce, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(p) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(p, l) {
      if (l || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", l == null ? void 0 : l.loc.start);
        let f = l || this.parseIdentifier(!0), g = this.startNodeAtNode(f);
        return g.exported = f, p.specifiers = [this.finishNode(g, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(p) {
      if (this.isContextual(93)) {
        p.specifiers || (p.specifiers = []);
        let l = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), l.exported = this.parseModuleExportName(), p.specifiers.push(this.finishNode(l, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(p) {
      if (this.match(5)) {
        p.specifiers || (p.specifiers = []);
        let l = p.exportKind === "type";
        return p.specifiers.push(...this.parseExportSpecifiers(l)), p.source = null, p.declaration = null, this.hasPlugin("importAssertions") && (p.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(p) {
      return this.shouldParseExportDeclaration() ? (p.specifiers = [], p.source = null, this.hasPlugin("importAssertions") && (p.assertions = []), p.declaration = this.parseExportDeclaration(p), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95))
        return !1;
      let p = this.nextTokenInLineStart();
      return this.isUnparsedContextual(p, "function");
    }
    parseExportDefaultExpression() {
      let p = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(p, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(p, 13);
      if (this.match(80))
        return this.parseClass(p, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(x.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(x.UnsupportedDefaultExport, this.state.startLoc);
      let l = this.parseMaybeAssignAllowIn();
      return this.semicolon(), l;
    }
    parseExportDeclaration(p) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let { type: p } = this.state;
      if (R(p)) {
        if (p === 95 && !this.state.containsEsc || p === 100)
          return !1;
        if ((p === 130 || p === 129) && !this.state.containsEsc) {
          let { type: g } = this.lookahead();
          if (R(g) && g !== 98 || g === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let l = this.nextTokenStart(), f = this.isUnparsedContextual(l, "from");
      if (this.input.charCodeAt(l) === 44 || R(this.state.type) && f)
        return !0;
      if (this.match(65) && f) {
        let g = this.input.charCodeAt(this.nextTokenStartSince(l + 4));
        return g === 34 || g === 39;
      }
      return !1;
    }
    parseExportFrom(p, l) {
      this.eatContextual(98) ? (p.source = this.parseImportSource(), this.checkExport(p), this.maybeParseImportAttributes(p), this.checkJSONModuleImport(p)) : l && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let { type: p } = this.state;
      return p === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(x.DecoratorBeforeExport, this.state.startLoc), !0) : p === 74 || p === 75 || p === 68 || p === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(p, l, f, g) {
      if (l) {
        var D;
        if (f) {
          if (this.checkDuplicateExports(p, "default"), this.hasPlugin("exportDefaultFrom")) {
            var A;
            let T = p.declaration;
            T.type === "Identifier" && T.name === "from" && T.end - T.start === 4 && !((A = T.extra) != null && A.parenthesized) && this.raise(x.ExportDefaultFromAsIdentifier, T);
          }
        } else if ((D = p.specifiers) != null && D.length)
          for (let T of p.specifiers) {
            let { exported: F } = T, N = F.type === "Identifier" ? F.name : F.value;
            if (this.checkDuplicateExports(T, N), !g && T.local) {
              let { local: $ } = T;
              $.type !== "Identifier" ? this.raise(x.ExportBindingIsString, T, { localName: $.value, exportName: N }) : (this.checkReservedWord($.name, $.loc.start, !0, !1), this.scope.checkLocalExport($));
            }
          }
        else if (p.declaration) {
          if (p.declaration.type === "FunctionDeclaration" || p.declaration.type === "ClassDeclaration") {
            let T = p.declaration.id;
            if (!T)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(p, T.name);
          } else if (p.declaration.type === "VariableDeclaration")
            for (let T of p.declaration.declarations)
              this.checkDeclaration(T.id);
        }
      }
    }
    checkDeclaration(p) {
      if (p.type === "Identifier")
        this.checkDuplicateExports(p, p.name);
      else if (p.type === "ObjectPattern")
        for (let l of p.properties)
          this.checkDeclaration(l);
      else if (p.type === "ArrayPattern")
        for (let l of p.elements)
          l && this.checkDeclaration(l);
      else
        p.type === "ObjectProperty" ? this.checkDeclaration(p.value) : p.type === "RestElement" ? this.checkDeclaration(p.argument) : p.type === "AssignmentPattern" && this.checkDeclaration(p.left);
    }
    checkDuplicateExports(p, l) {
      this.exportedIdentifiers.has(l) && (l === "default" ? this.raise(x.DuplicateDefaultExport, p) : this.raise(x.DuplicateExport, p, { exportName: l })), this.exportedIdentifiers.add(l);
    }
    parseExportSpecifiers(p) {
      let l = [], f = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (f)
          f = !1;
        else if (this.expect(12), this.eat(8))
          break;
        let g = this.isContextual(130), D = this.match(133), A = this.startNode();
        A.local = this.parseModuleExportName(), l.push(this.parseExportSpecifier(A, D, p, g));
      }
      return l;
    }
    parseExportSpecifier(p, l, f, g) {
      return this.eatContextual(93) ? p.exported = this.parseModuleExportName() : l ? p.exported = qk(p.local) : p.exported || (p.exported = Yi(p.local)), this.finishNode(p, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        let p = this.parseStringLiteral(this.state.value), l = p.value.match(OT);
        return l && this.raise(x.ModuleExportNameHasLoneSurrogate, p, { surrogateCharCode: l[0].charCodeAt(0) }), p;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(p) {
      return p.assertions != null ? p.assertions.some(({ key: l, value: f }) => f.value === "json" && (l.type === "Identifier" ? l.name === "type" : l.value === "type")) : !1;
    }
    checkImportReflection(p) {
      let { specifiers: l } = p, f = l.length === 1 ? l[0].type : null;
      if (p.phase === "source")
        f !== "ImportDefaultSpecifier" && this.raise(x.SourcePhaseImportRequiresDefault, l[0].loc.start);
      else if (p.phase === "defer")
        f !== "ImportNamespaceSpecifier" && this.raise(x.DeferImportRequiresNamespace, l[0].loc.start);
      else if (p.module) {
        var g;
        f !== "ImportDefaultSpecifier" && this.raise(x.ImportReflectionNotBinding, l[0].loc.start), ((g = p.assertions) == null ? void 0 : g.length) > 0 && this.raise(x.ImportReflectionHasAssertion, l[0].loc.start);
      }
    }
    checkJSONModuleImport(p) {
      if (this.isJSONModuleImport(p) && p.type !== "ExportAllDeclaration") {
        let { specifiers: l } = p;
        if (l != null) {
          let f = l.find((g) => {
            let D;
            if (g.type === "ExportSpecifier" ? D = g.local : g.type === "ImportSpecifier" && (D = g.imported), D !== void 0)
              return D.type === "Identifier" ? D.name !== "default" : D.value !== "default";
          });
          f !== void 0 && this.raise(x.ImportJSONBindingNotDefault, f.loc.start);
        }
      }
    }
    isPotentialImportPhase(p) {
      return p ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(p, l, f, g) {
      l || (f === "module" ? (this.expectPlugin("importReflection", g), p.module = !0) : this.hasPlugin("importReflection") && (p.module = !1), f === "source" ? (this.expectPlugin("sourcePhaseImports", g), p.phase = "source") : f === "defer" ? (this.expectPlugin("deferredImportEvaluation", g), p.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (p.phase = null));
    }
    parseMaybeImportPhase(p, l) {
      if (!this.isPotentialImportPhase(l))
        return this.applyImportPhase(p, l, null), null;
      let f = this.parseIdentifier(!0), { type: g } = this.state;
      return (De(g) ? g !== 98 || this.lookaheadCharCode() === 102 : g !== 12) ? (this.resetPreviousIdentifierLeadingComments(f), this.applyImportPhase(p, l, f.name, f.loc.start), null) : (this.applyImportPhase(p, l, null), f);
    }
    isPrecedingIdImportPhase(p) {
      let { type: l } = this.state;
      return R(l) ? l !== 98 || this.lookaheadCharCode() === 102 : l !== 12;
    }
    parseImport(p) {
      return this.match(133) ? this.parseImportSourceAndAttributes(p) : this.parseImportSpecifiersAndAfter(p, this.parseMaybeImportPhase(p, !1));
    }
    parseImportSpecifiersAndAfter(p, l) {
      p.specifiers = [];
      let f = !this.maybeParseDefaultImportSpecifier(p, l) || this.eat(12), g = f && this.maybeParseStarImportSpecifier(p);
      return f && !g && this.parseNamedImportSpecifiers(p), this.expectContextual(98), this.parseImportSourceAndAttributes(p);
    }
    parseImportSourceAndAttributes(p) {
      return p.specifiers != null || (p.specifiers = []), p.source = this.parseImportSource(), this.maybeParseImportAttributes(p), this.checkImportReflection(p), this.checkJSONModuleImport(p), this.semicolon(), this.finishNode(p, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(p, l, f) {
      l.local = this.parseIdentifier(), p.specifiers.push(this.finishImportSpecifier(l, f));
    }
    finishImportSpecifier(p, l, f = 8201) {
      return this.checkLVal(p.local, { in: { type: l }, binding: f }), this.finishNode(p, l);
    }
    parseImportAttributes() {
      this.expect(5);
      let p = [], l = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let f = this.startNode(), g = this.state.value;
        if (l.has(g) && this.raise(x.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: g }), l.add(g), this.match(133) ? f.key = this.parseStringLiteral(g) : f.key = this.parseIdentifier(!0), this.expect(14), !this.match(133))
          throw this.raise(x.ModuleAttributeInvalidValue, this.state.startLoc);
        f.value = this.parseStringLiteral(this.state.value), p.push(this.finishNode(f, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), p;
    }
    parseModuleAttributes() {
      let p = [], l = /* @__PURE__ */ new Set();
      do {
        let f = this.startNode();
        if (f.key = this.parseIdentifier(!0), f.key.name !== "type" && this.raise(x.ModuleAttributeDifferentFromType, f.key), l.has(f.key.name) && this.raise(x.ModuleAttributesWithDuplicateKeys, f.key, { key: f.key.name }), l.add(f.key.name), this.expect(14), !this.match(133))
          throw this.raise(x.ModuleAttributeInvalidValue, this.state.startLoc);
        f.value = this.parseStringLiteral(this.state.value), p.push(this.finishNode(f, "ImportAttribute"));
      } while (this.eat(12));
      return p;
    }
    maybeParseImportAttributes(p) {
      let l, f = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? l = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), l = this.parseImportAttributes()), f = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(x.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(p, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), l = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        l = [];
      else if (this.hasPlugin("moduleAttributes"))
        l = [];
      else
        return;
      !f && this.hasPlugin("importAssertions") ? p.assertions = l : p.attributes = l;
    }
    maybeParseDefaultImportSpecifier(p, l) {
      if (l) {
        let f = this.startNodeAtNode(l);
        return f.local = l, p.specifiers.push(this.finishImportSpecifier(f, "ImportDefaultSpecifier")), !0;
      } else if (De(this.state.type))
        return this.parseImportSpecifierLocal(p, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(p) {
      if (this.match(55)) {
        let l = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(p, l, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(p) {
      let l = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (l)
          l = !1;
        else {
          if (this.eat(14))
            throw this.raise(x.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8))
            break;
        }
        let f = this.startNode(), g = this.match(133), D = this.isContextual(130);
        f.imported = this.parseModuleExportName();
        let A = this.parseImportSpecifier(f, g, p.importKind === "type" || p.importKind === "typeof", D, void 0);
        p.specifiers.push(A);
      }
    }
    parseImportSpecifier(p, l, f, g, D) {
      if (this.eatContextual(93))
        p.local = this.parseIdentifier();
      else {
        let { imported: A } = p;
        if (l)
          throw this.raise(x.ImportBindingIsString, p, { importName: A.value });
        this.checkReservedWord(A.name, p.loc.start, !0, !0), p.local || (p.local = Yi(A));
      }
      return this.finishImportSpecifier(p, "ImportSpecifier", D);
    }
    isThisParam(p) {
      return p.type === "Identifier" && p.name === "this";
    }
  }, o0 = class extends bT {
    constructor(p, l) {
      p = mT(p), super(p, l), this.options = p, this.initializeScopes(), this.plugins = DT(this.options.plugins), this.filename = p.sourceFilename;
    }
    getScopeHandler() {
      return yp;
    }
    parse() {
      this.enterInitialScopes();
      let p = this.startNode(), l = this.startNode();
      return this.nextToken(), p.errors = null, this.parseTopLevel(p, l), p.errors = this.state.errors, p.comments.length = this.state.commentsLen, p;
    }
  };
  function DT(p) {
    let l = /* @__PURE__ */ new Map();
    for (let f of p) {
      let [g, D] = Array.isArray(f) ? f : [f, {}];
      l.has(g) || l.set(g, D || {});
    }
    return l;
  }
  function vT(p, l) {
    var f;
    if (((f = l) == null ? void 0 : f.sourceType) === "unambiguous") {
      l = Object.assign({}, l);
      try {
        l.sourceType = "module";
        let g = ho(l, p), D = g.parse();
        if (g.sawUnambiguousESM)
          return D;
        if (g.ambiguousScriptDifferentAst)
          try {
            return l.sourceType = "script", ho(l, p).parse();
          } catch {
          }
        else
          D.program.sourceType = "script";
        return D;
      } catch (g) {
        try {
          return l.sourceType = "script", ho(l, p).parse();
        } catch {
        }
        throw g;
      }
    } else
      return ho(l, p).parse();
  }
  function ST(p, l) {
    let f = ho(l, p);
    return f.options.strictMode && (f.state.strict = !0), f.getExpression();
  }
  function wT(p) {
    let l = {};
    for (let f of Object.keys(p))
      l[f] = zr(p[f]);
    return l;
  }
  var CT = wT(W);
  function ho(p, l) {
    let f = o0;
    return p != null && p.plugins && (dT(p.plugins), f = AT(p.plugins)), new f(p, l);
  }
  var l0 = {};
  function AT(p) {
    let l = fT.filter((D) => gt(p, D)), f = l.join("/"), g = l0[f];
    if (!g) {
      g = o0;
      for (let D of l)
        g = a0[D](g);
      l0[f] = g;
    }
    return g;
  }
  t.parse = vT, t.parseExpression = ST, t.tokTypes = CT;
}), NL = Ow((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = h, t.parse = m, t.parseWithComments = y, t.print = O, t.strip = d;
  var e = /\*\/$/, r = /^\/\*\*?/, i = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, n = /(^|\s+)\/\/([^\r\n]*)/g, s = /^(\r?\n)+/, a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, o = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, u = /(\r?\n|^) *\* ?/g, c = [];
  function h(v) {
    let S = v.match(i);
    return S ? S[0].trimLeft() : "";
  }
  function d(v) {
    let S = v.match(i);
    return S && S[0] ? v.substring(S[0].length) : v;
  }
  function m(v) {
    return y(v).pragmas;
  }
  function y(v) {
    let S = `
`;
    v = v.replace(r, "").replace(e, "").replace(u, "$1");
    let x = "";
    for (; x !== v; )
      x = v, v = v.replace(a, `${S}$1 $2${S}`);
    v = v.replace(s, "").trimRight();
    let w = /* @__PURE__ */ Object.create(null), k = v.replace(o, "").replace(s, "").trimRight(), C;
    for (; C = o.exec(v); ) {
      let E = C[2].replace(n, "");
      typeof w[C[1]] == "string" || Array.isArray(w[C[1]]) ? w[C[1]] = c.concat(w[C[1]], E) : w[C[1]] = E;
    }
    return { comments: k, pragmas: w };
  }
  function O({ comments: v = "", pragmas: S = {} }) {
    let x = `
`, w = "/**", k = " *", C = " */", E = Object.keys(S), P = E.flatMap((B) => b(B, S[B])).map((B) => `${k} ${B}${x}`).join("");
    if (!v) {
      if (E.length === 0)
        return "";
      if (E.length === 1 && !Array.isArray(S[E[0]])) {
        let B = S[E[0]];
        return `${w} ${b(E[0], B)[0]}${C}`;
      }
    }
    let I = v.split(x).map((B) => `${k} ${B}`).join(x) + x;
    return w + x + (v ? I : "") + (v && E.length ? k + x : "") + P + C;
  }
  function b(v, S) {
    return c.concat(S).map((x) => `@${v} ${x}`.trim());
  }
}), Dw = {};
BL(Dw, { parsers: () => $R });
var LO = ey(xw(), 1);
function vw(t) {
  return (e, r, i) => {
    let n = !!(i != null && i.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, a = r;
    for (; a >= 0 && a < s; ) {
      let o = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(o))
          return a;
      } else if (!t.includes(o))
        return a;
      n ? a-- : a++;
    }
    return a === -1 || a === s ? a : !1;
  };
}
var _L = vw(" 	"), QL = vw(/[^\n\r]/);
function ML(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var LL = ML;
function RL(t, e, r) {
  let i = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let n = t.charAt(e);
  if (i) {
    if (t.charAt(e - 1) === "\r" && n === `
`)
      return e - 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e - 1;
  } else {
    if (n === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029")
      return e + 1;
  }
  return e;
}
var jL = RL;
function ZL(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? QL(t, e) : e;
}
var WL = ZL;
function qL(t, e) {
  let r = null, i = e;
  for (; i !== r; )
    r = i, i = _L(t, i), i = LL(t, i), i = WL(t, i), i = jL(t, i);
  return i;
}
var XL = qL;
function VL(t) {
  let e = [];
  for (let r of t)
    try {
      return r();
    } catch (i) {
      e.push(i);
    }
  throw Object.assign(new Error("All combinations failed"), { errors: e });
}
var YL = VL;
function UL(t) {
  if (!t.startsWith("#!"))
    return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var Sw = UL, zL = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, RO = zL;
function GL(t) {
  return Array.isArray(t) && t.length > 0;
}
var ty = GL;
function ei(t) {
  var e, r, i;
  let n = ((e = t.range) == null ? void 0 : e[0]) ?? t.start, s = (i = ((r = t.declaration) == null ? void 0 : r.decorators) ?? t.decorators) == null ? void 0 : i[0];
  return s ? Math.min(ei(s), n) : n;
}
function kn(t) {
  var e;
  return ((e = t.range) == null ? void 0 : e[1]) ?? t.end;
}
function HL(t) {
  let e = new Set(t);
  return (r) => e.has(r == null ? void 0 : r.type);
}
var JL = HL, KL = JL(["Block", "CommentBlock", "MultiLine"]), xf = KL;
function eR(t) {
  let e = `*${t.value}*`.split(`
`);
  return e.length > 1 && e.every((r) => r.trimStart()[0] === "*");
}
var jO = eR;
function tR(t) {
  return xf(t) && t.value[0] === "*" && /@(?:type|satisfies)\b/.test(t.value);
}
var rR = tR, Do = null;
function Go(t) {
  if (Do !== null && typeof Do.property) {
    let e = Do;
    return Do = Go.prototype = null, e;
  }
  return Do = Go.prototype = t ?? /* @__PURE__ */ Object.create(null), new Go();
}
var iR = 10;
for (let t = 0; t <= iR; t++)
  Go();
function nR(t) {
  return Go(t);
}
function sR(t, e = "type") {
  nR(t);
  function r(i) {
    let n = i[e], s = t[n];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: i });
    return s;
  }
  return r;
}
var aR = sR, oR = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value", "optional", "static", "method"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareEnum: ["id", "body"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], AsConstExpression: ["expression"], SatisfiesExpression: ["expression", "typeAnnotation"] }, lR = aR(oR), uR = lR;
function bf(t, e) {
  if (!(t !== null && typeof t == "object"))
    return t;
  if (Array.isArray(t)) {
    for (let i = 0; i < t.length; i++)
      t[i] = bf(t[i], e);
    return t;
  }
  let r = uR(t);
  for (let i = 0; i < r.length; i++)
    t[r[i]] = bf(t[r[i]], e);
  return e(t) || t;
}
var ed = bf;
function cR(t, e) {
  let { parser: r, text: i } = e;
  if (t.type === "File" && t.program.interpreter) {
    let { program: { interpreter: n }, comments: s } = t;
    delete t.program.interpreter, s.unshift(n);
  }
  if (r === "babel") {
    let n = /* @__PURE__ */ new Set();
    t = ed(t, (s) => {
      var a;
      (a = s.leadingComments) != null && a.some(rR) && n.add(ei(s));
    }), t = ed(t, (s) => {
      if (s.type === "ParenthesizedExpression") {
        let { expression: a } = s;
        if (a.type === "TypeCastExpression")
          return a.range = [...s.range], a;
        let o = ei(s);
        if (!n.has(o))
          return a.extra = { ...a.extra, parenthesized: !0 }, a;
      }
    });
  }
  if (t = ed(t, (n) => {
    var s;
    switch (n.type) {
      case "LogicalExpression":
        if (ww(n))
          return Df(n);
        break;
      case "VariableDeclaration": {
        let a = RO(!1, n.declarations, -1);
        a != null && a.init && i[kn(a)] !== ";" && (n.range = [ei(n), kn(a)]);
        break;
      }
      case "TSParenthesizedType":
        return n.typeAnnotation;
      case "TSTypeParameter":
        if (typeof n.name == "string") {
          let a = ei(n);
          n.name = { type: "Identifier", name: n.name, range: [a, a + n.name.length] };
        }
        break;
      case "TopicReference":
        t.extra = { ...t.extra, __isUsingHackPipeline: !0 };
        break;
      case "ExportAllDeclaration":
        if (r === "meriyah" && ((s = n.exported) == null ? void 0 : s.type) === "Identifier") {
          let { exported: a } = n, o = i.slice(ei(a), kn(a));
          (o.startsWith('"') || o.startsWith("'")) && (n.exported = { ...n.exported, type: "Literal", value: n.exported.name, raw: o });
        }
        break;
      case "TSUnionType":
      case "TSIntersectionType":
        if (n.types.length === 1)
          return n.types[0];
        break;
    }
  }), ty(t.comments)) {
    let n = RO(!1, t.comments, -1);
    for (let s = t.comments.length - 2; s >= 0; s--) {
      let a = t.comments[s];
      kn(a) === ei(n) && xf(a) && xf(n) && jO(a) && jO(n) && (t.comments.splice(s + 1, 1), a.value += "*//*" + n.value, a.range = [ei(a), kn(n)]), n = a;
    }
  }
  return t.type === "Program" && (t.range = [0, i.length]), t;
}
function ww(t) {
  return t.type === "LogicalExpression" && t.right.type === "LogicalExpression" && t.operator === t.right.operator;
}
function Df(t) {
  return ww(t) ? Df({ type: "LogicalExpression", operator: t.operator, left: Df({ type: "LogicalExpression", operator: t.operator, left: t.left, right: t.right.left, range: [ei(t.left), kn(t.right.left)] }), right: t.right.right, range: [ei(t), kn(t)] }) : t;
}
var hR = cR;
function pR(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var Cw = pR;
function dR(t) {
  let { message: e, loc: { line: r, column: i }, reasonCode: n } = t, s = t;
  (n === "MissingPlugin" || n === "MissingOneOfPlugins") && (e = "Unexpected token.", s = void 0);
  let a = ` (${r}:${i})`;
  return e.endsWith(a) && (e = e.slice(0, -a.length)), Cw(e, { loc: { start: { line: r, column: i + 1 } }, cause: s });
}
var Aw = dR, ZO = ey(NL(), 1);
function fR(t) {
  let e = Sw(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, ZO.extract)(t), { pragmas: i, comments: n } = (0, ZO.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: i, comments: n };
}
function mR(t) {
  let { pragmas: e } = fR(t);
  return Object.prototype.hasOwnProperty.call(e, "prettier") || Object.prototype.hasOwnProperty.call(e, "format");
}
function gR(t) {
  return t = typeof t == "function" ? { parse: t } : t, { astFormat: "estree", hasPragma: mR, locStart: ei, locEnd: kn, ...t };
}
var Bo = gR;
function yR(t) {
  let { filepath: e } = t;
  if (e) {
    if (e = e.toLowerCase(), e.endsWith(".cjs"))
      return "script";
    if (e.endsWith(".mjs"))
      return "module";
  }
}
var OR = yR;
function xR(t, e) {
  let { type: r = "JsExpressionRoot", rootMarker: i, text: n } = e, { tokens: s, comments: a } = t;
  return delete t.tokens, delete t.comments, { tokens: s, comments: a, type: r, node: t, range: [0, n.length], rootMarker: i };
}
var Ew = xR, to = (t) => Bo(CR(t)), bR = { sourceType: "module", allowImportExportEverywhere: !0, allowReturnOutsideFunction: !0, allowNewTargetOutsideFunction: !0, allowSuperOutsideMethod: !0, allowUndeclaredExports: !0, errorRecovery: !0, createParenthesizedExpressions: !0, createImportExpressions: !0, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", "decorators", "decimal", "moduleBlocks", "asyncDoExpressions", "regexpUnicodeSets", "destructuringPrivate", "decoratorAutoAccessors", "importReflection", "explicitResourceManagement", ["importAttributes", { deprecatedAssertSyntax: !0 }], "sourcePhaseImports", "deferredImportEvaluation", ["optionalChainingAssign", { version: "2023-07" }]], tokens: !0, ranges: !0 }, DR = ["recordAndTuple", { syntaxType: "hash" }], WO = "v8intrinsic", qO = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], Pi = (t, e = bR) => ({ ...e, plugins: [...e.plugins, ...t] }), vR = /@(?:no)?flow\b/;
function SR(t, e) {
  var r;
  if ((r = e.filepath) != null && r.endsWith(".js.flow"))
    return !0;
  let i = Sw(t);
  i && (t = t.slice(i.length));
  let n = XL(t, 0);
  return n !== !1 && (t = t.slice(0, n)), vR.test(t);
}
function wR(t, e, r) {
  let i = t(e, r), n = i.errors.find((s) => !AR.has(s.reasonCode));
  if (n)
    throw n;
  return i;
}
function CR({ isExpression: t = !1, optionsCombinations: e }) {
  return (r, i = {}) => {
    if ((i.parser === "babel" || i.parser === "__babel_estree") && SR(r, i))
      return i.parser = "babel-flow", Tw.parse(r, i);
    let n = e;
    (i.__babelSourceType ?? OR(i)) === "script" && (n = n.map((u) => ({ ...u, sourceType: "script" }))), /#[[{]/.test(r) && (n = n.map((u) => Pi([DR], u)));
    let s = /%[A-Z]/.test(r);
    r.includes("|>") ? n = (s ? [...qO, WO] : qO).flatMap((u) => n.map((c) => Pi([u], c))) : s && (n = n.map((u) => Pi([WO], u)));
    let a = t ? LO.parseExpression : LO.parse, o;
    try {
      o = YL(n.map((u) => () => wR(a, r, u)));
    } catch ({ errors: [u] }) {
      throw Aw(u);
    }
    return t && (o = Ew(o, { text: r, rootMarker: i.rootMarker })), hR(o, { parser: "babel", text: r });
  };
}
var AR = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "DuplicateAccessibilityModifier", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), kw = [Pi(["jsx"])], XO = to({ optionsCombinations: kw }), VO = to({ optionsCombinations: [Pi(["jsx", "typescript"]), Pi(["typescript"])] }), YO = to({ isExpression: !0, optionsCombinations: [Pi(["jsx"])] }), UO = to({ isExpression: !0, optionsCombinations: [Pi(["typescript"])] }), Tw = to({ optionsCombinations: [Pi(["jsx", ["flow", { all: !0, enums: !0 }], "flowComments"])] }), ER = to({ optionsCombinations: kw.map((t) => Pi(["estree"], t)) }), kR = { babel: XO, "babel-flow": Tw, "babel-ts": VO, __js_expression: YO, __ts_expression: UO, __vue_expression: YO, __vue_ts_expression: UO, __vue_event_binding: XO, __vue_ts_event_binding: VO, __babel_estree: ER }, TR = ey(xw(), 1);
function Pw(t = {}) {
  let { allowComments: e = !0 } = t;
  return function(r) {
    let i;
    try {
      i = (0, TR.parseExpression)(r, { tokens: !0, ranges: !0, attachComment: !1 });
    } catch (n) {
      throw Aw(n);
    }
    if (!e && ty(i.comments))
      throw Cn(i.comments[0], "Comment");
    return ua(i), Ew(i, { type: "JsonRoot", text: r });
  };
}
function Cn(t, e) {
  let [r, i] = [t.loc.start, t.loc.end].map(({ line: n, column: s }) => ({ line: n, column: s + 1 }));
  return Cw(`${e} is not allowed in JSON.`, { loc: { start: r, end: i } });
}
function ua(t) {
  switch (t.type) {
    case "ArrayExpression":
      for (let e of t.elements)
        e !== null && ua(e);
      return;
    case "ObjectExpression":
      for (let e of t.properties)
        ua(e);
      return;
    case "ObjectProperty":
      if (t.computed)
        throw Cn(t.key, "Computed key");
      if (t.shorthand)
        throw Cn(t.key, "Shorthand property");
      t.key.type !== "Identifier" && ua(t.key), ua(t.value);
      return;
    case "UnaryExpression": {
      let { operator: e, argument: r } = t;
      if (e !== "+" && e !== "-")
        throw Cn(t, `Operator '${t.operator}'`);
      if (r.type === "NumericLiteral" || r.type === "Identifier" && (r.name === "Infinity" || r.name === "NaN"))
        return;
      throw Cn(r, `Operator '${e}' before '${r.type}'`);
    }
    case "Identifier":
      if (t.name !== "Infinity" && t.name !== "NaN" && t.name !== "undefined")
        throw Cn(t, `Identifier '${t.name}'`);
      return;
    case "TemplateLiteral":
      if (ty(t.expressions))
        throw Cn(t.expressions[0], "'TemplateLiteral' with expression");
      for (let e of t.quasis)
        ua(e);
      return;
    case "NullLiteral":
    case "BooleanLiteral":
    case "NumericLiteral":
    case "StringLiteral":
    case "TemplateElement":
      return;
    default:
      throw Cn(t, `'${t.type}'`);
  }
}
var td = Pw(), PR = { json: Bo({ parse: td, hasPragma() {
  return !0;
} }), json5: Bo(td), jsonc: Bo(td), "json-stringify": Bo({ parse: Pw({ allowComments: !1 }), astFormat: "estree-json" }) }, FR = PR, $R = { ...kR, ...FR }, BR = Dw;
const IR = async (t, e) => {
  if (!bb(e))
    return t;
  const r = e === "js" ? "babel" : e;
  return await e3.format(t, {
    parser: r,
    plugins: [$7, GI, EL, BR],
    tabWidth: 2,
    htmlWhitespaceSensitivity: "ignore"
  });
}, Fw = (t, e = { mustBeOpen: !0 }) => Object.values(t).filter((r) => !e.mustBeOpen || r.open && e.mustBeOpen).sort((r, i) => r.name.localeCompare(i.name)), He = {
  REPLACE_PROJECT: "REPLACE_PROJECT",
  NEW_FILE: "NEW_FILE",
  RENAME_FILE: "RENAME_FILE",
  SAVE_FILE: "SAVE_FILE",
  OPEN_FILE: "OPEN_FILE",
  ACTIVATE_FILE: "ACTIVATE_FILE",
  MOVE_FILE: "MOVE_FILE",
  CLOSE_FILE: "CLOSE_FILE",
  DELETE_FILE: "DELETE_FILE",
  NEW_FOLDER: "NEW_FOLDER",
  TOGGLE_OPEN_FOLDER: "TOGGLE_OPEN_FOLDER",
  DELETE_FOLDER: "DELETE_FOLDER",
  RENAME_FOLDER: "RENAME_FOLDER"
}, NR = "Add your changes to ${fileName}", _R = (t) => String(Math.max(...t.map((e) => Number(e.id))) + 1), QR = (t) => String(Math.max(...t.map((e) => Number(e.id))) + 1), ry = (t, e) => e.reduce((r, i) => (i.parentId === t && r.push(i.id, ...ry(i.id, e)), r), []), MR = (t, e, r) => {
  const i = new Set(
    r ? [t, ...ry(t, r)] : [t]
  );
  return e.reduce((n, s) => (i.has(s.folderId) && n.push(s.id), n), []);
}, LR = (t) => Ob(() => {
  const e = {
    replaceProject: (r, i) => {
      t({
        type: He.REPLACE_PROJECT,
        payload: { project: r, shouldNotifyProjectUpdate: i }
      });
    },
    newFile: ({
      fileId: r,
      fileName: i,
      folderId: n = ys,
      contents: s = NR
    }) => {
      t({
        type: He.NEW_FILE,
        payload: {
          fileId: r,
          fileName: i,
          folderId: n,
          contents: s.replace(/\${fileName}/g, i)
        }
      }), e.setActiveFile(r);
    },
    renameFile: (r, i) => {
      t({
        type: He.RENAME_FILE,
        payload: { fileId: r, newName: i }
      });
    },
    saveFile: (r, i) => {
      t({
        type: He.SAVE_FILE,
        payload: { fileId: r, contents: i }
      });
    },
    openFile: (r) => {
      t({
        type: He.OPEN_FILE,
        payload: { fileId: r }
      });
    },
    closeFile: (r) => {
      t({
        type: He.CLOSE_FILE,
        payload: { fileId: r }
      });
    },
    deleteFile: (r) => {
      t({
        type: He.DELETE_FILE,
        payload: { fileId: r }
      });
    },
    setActiveFile: (r) => {
      t({
        type: He.ACTIVATE_FILE,
        payload: { fileId: r }
      });
    },
    moveFile: (r, i) => {
      t({
        type: He.MOVE_FILE,
        payload: { fileId: r, folderId: i }
      });
    },
    newFolder: ({
      folderId: r,
      folderName: i,
      parentId: n = ys
    }) => {
      t({
        type: He.NEW_FOLDER,
        payload: { folderId: r, folderName: i, parentId: n }
      });
    },
    renameFolder: (r, i) => {
      t({
        type: He.RENAME_FOLDER,
        payload: { folderId: r, newName: i }
      });
    },
    toggleOpenFolder: (r) => {
      t({
        type: He.TOGGLE_OPEN_FOLDER,
        payload: { folderId: r }
      });
    },
    deleteFolder: (r) => {
      t({
        type: He.DELETE_FOLDER,
        payload: { folderId: r }
      });
    }
  };
  return e;
}, [t]), RR = (t, e) => {
  var r;
  switch (e.type) {
    case He.REPLACE_PROJECT: {
      const {
        project: i,
        shouldNotifyProjectUpdate: n
      } = e.payload;
      return t !== i && (n.current = !1), i;
    }
    case He.NEW_FILE: {
      const { fileId: i, fileName: n, folderId: s, contents: a = "" } = e.payload, o = { ...t, files: { ...t.files } }, [u, c] = n.split(".");
      return o.files[i] = {
        id: i,
        name: n,
        language: c || "html",
        contents: a,
        folderId: s
      }, o;
    }
    case He.RENAME_FILE: {
      const { fileId: i, newName: n } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [i]: { ...t.files[i], name: n }
        }
      };
    }
    case He.SAVE_FILE: {
      const { fileId: i, contents: n } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [i]: { ...t.files[i], contents: n }
        }
      };
    }
    case He.OPEN_FILE:
    case He.ACTIVATE_FILE: {
      const { fileId: i } = e.payload, n = (r = Object.values(t.files).filter(
        (a) => a.active
      )) == null ? void 0 : r[0];
      if ((n == null ? void 0 : n.id) === i)
        return t;
      const s = {
        ...t,
        files: {
          ...t.files,
          [i]: { ...t.files[i], active: !0, open: !0 }
        }
      };
      return n && (s.files[n.id] = {
        ...s.files[n.id],
        active: !1
      }), s;
    }
    case He.CLOSE_FILE: {
      const { fileId: i } = e.payload, n = t.files[i], s = {
        ...t,
        files: {
          ...t.files,
          [i]: { ...t.files[i], open: !1, active: !1 }
        }
      };
      if (n.active) {
        const a = Fw(t.files, {
          mustBeOpen: !0
        }), o = a.findIndex((c) => c.id === n.id);
        let u;
        o > 0 ? u = a[o - 1].id : o < a.length - 1 && (u = a[o + 1].id), u && (s.files[u] = {
          ...s.files[u],
          active: !0
        });
      }
      return s;
    }
    case He.DELETE_FILE: {
      const { fileId: i } = e.payload, n = {
        ...t,
        files: {
          ...t.files
        }
      };
      return delete n.files[i], n;
    }
    case He.MOVE_FILE: {
      const { fileId: i, folderId: n } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [i]: { ...t.files[i], folderId: n }
        }
      };
    }
    case He.NEW_FOLDER: {
      const { folderId: i, folderName: n, parentId: s } = e.payload, a = { ...t, folders: { ...t.folders } };
      return a.folders[i] = {
        id: i,
        name: n,
        parentId: s
      }, a;
    }
    case He.TOGGLE_OPEN_FOLDER: {
      const { folderId: i } = e.payload;
      return {
        ...t,
        folders: {
          ...t.folders,
          [i]: {
            ...t.folders[i],
            open: !t.folders[i].open
          }
        }
      };
    }
    case He.DELETE_FOLDER: {
      const { folderId: i } = e.payload, n = {
        ...t,
        folders: {
          ...t.folders
        }
      }, s = new Set(
        ry(i, Object.values(t.folders))
      ), a = new Set(
        MR(
          i,
          Object.values(t.files),
          Object.values(t.folders)
        )
      );
      return delete n.folders[i], Object.values(n.folders).filter((o) => s.has(o.id)).forEach((o) => delete n.folders[o.id]), a.size && (n.files = { ...n.files }, Object.values(n.files).filter((o) => a.has(o.id)).forEach((o) => delete n.files[o.id])), n;
    }
    case He.RENAME_FOLDER: {
      const { folderId: i, newName: n } = e.payload;
      return {
        ...t,
        folders: {
          ...t.folders,
          [i]: { ...t.folders[i], name: n }
        }
      };
    }
    default:
      return t;
  }
}, jR = ({ setActivePane: t, activePane: e }) => {
  const {
    config: { leftNav: r }
  } = Er();
  return /* @__PURE__ */ z.jsx("div", { className: "nav-bar", children: r.map((i) => /* @__PURE__ */ z.jsx(
    "div",
    {
      onClick: () => t(i.component),
      style: {
        cursor: "pointer",
        backgroundColor: i.component === e ? "#666" : ""
      },
      children: /* @__PURE__ */ z.jsx("i", { className: `fa-regular fa-2xl ${i.icon}` })
    },
    i.icon
  )) });
}, ZR = () => {
  const {
    config: { sideBar: t }
  } = Er();
  return /* @__PURE__ */ z.jsx("div", { className: "left-side-bar", children: t.map((e) => /* @__PURE__ */ z.jsx(
    "div",
    {
      onClick: () => alert("not implemented"),
      style: { cursor: "pointer" },
      children: /* @__PURE__ */ z.jsx("i", { className: `fa-regular fa-2xl ${e}` })
    },
    e
  )) });
}, $w = ({
  parentId: t,
  folders: e,
  files: r,
  newFolderPrompt: i,
  newFilePrompt: n,
  moveFilePrompt: s,
  renameFilePrompt: a,
  renameFolderPrompt: o
}) => {
  const {
    openFile: u,
    deleteFile: c,
    toggleOpenFolder: h,
    deleteFolder: d
  } = Er();
  return /* @__PURE__ */ z.jsxs(z.Fragment, { children: [
    Object.values(e).filter((m) => m.parentId === t).sort((m, y) => m.name.localeCompare(y.name)).map((m) => {
      const y = /* @__PURE__ */ z.jsx(
        "i",
        {
          className: m.open ? "fa-solid fa-caret-down" : "fa-solid fa-caret-right"
        }
      );
      return /* @__PURE__ */ z.jsxs("li", { children: [
        /* @__PURE__ */ z.jsxs("span", { className: "label", children: [
          /* @__PURE__ */ z.jsxs("span", { className: "title", children: [
            /* @__PURE__ */ z.jsx(
              "span",
              {
                className: "caret-container",
                onClick: () => h(m.id),
                children: y
              }
            ),
            /* @__PURE__ */ z.jsx("span", { children: m.name })
          ] }),
          /* @__PURE__ */ z.jsxs("span", { className: "button-bar", children: [
            /* @__PURE__ */ z.jsx("span", { onClick: () => o(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-pencil" }) }),
            /* @__PURE__ */ z.jsx("span", { onClick: () => i(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-folder-plus" }) }),
            /* @__PURE__ */ z.jsx("span", { onClick: () => n(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-plus" }) }),
            /* @__PURE__ */ z.jsx("span", { onClick: () => d(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-trash" }) })
          ] })
        ] }),
        m.open && /* @__PURE__ */ z.jsx("ul", { children: /* @__PURE__ */ z.jsx(
          $w,
          {
            folders: e,
            newFolderPrompt: i,
            parentId: m.id,
            files: r,
            newFilePrompt: n,
            moveFilePrompt: s,
            renameFilePrompt: a,
            renameFolderPrompt: o
          }
        ) })
      ] }, m.id + m.open);
    }),
    Object.values(r).filter((m) => m.folderId === t).sort((m, y) => m.name.localeCompare(y.name)).map((m) => /* @__PURE__ */ z.jsx("li", { children: /* @__PURE__ */ z.jsxs("span", { className: "label", children: [
      /* @__PURE__ */ z.jsx("span", { onClick: () => u(m.id), children: m.name }),
      /* @__PURE__ */ z.jsxs("span", { className: "button-bar", children: [
        /* @__PURE__ */ z.jsx("span", { onClick: () => s(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-arrow-right" }) }),
        /* @__PURE__ */ z.jsx("span", { onClick: () => a(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-pencil" }) }),
        /* @__PURE__ */ z.jsx("span", { onClick: () => c(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-trash" }) })
      ] })
    ] }) }, m.id))
  ] });
}, WR = () => {
  const {
    project: t,
    newFile: e,
    renameFile: r,
    moveFile: i,
    renameFolder: n,
    newFolder: s
  } = Er(), a = (d = ys) => {
    const m = QR(Object.values(t.folders)), y = window.prompt("Please name your new folder");
    if (!y)
      return;
    if (Object.values(t.folders).some(
      (b) => b.name === y && b.parentId === d
    )) {
      alert("Folder already exists");
      return;
    }
    s({ parentId: d, folderName: y, folderId: m });
  }, o = (d = ys) => {
    var S;
    const m = (S = window.prompt("Please name your new file")) == null ? void 0 : S.replace(/[^\w.]+/g, "");
    if (!m)
      return;
    if (Object.values(t.files).some(
      (x) => x.name === m && x.folderId === d
    )) {
      alert("File already exists");
      return;
    }
    const [O, b] = m.split(".");
    if (!b) {
      window.alert("Files must have extensions");
      return;
    }
    const v = _R(Object.values(t.files));
    e({
      fileId: v,
      fileName: m,
      folderId: d
    });
  }, u = (d) => {
    const m = t.files[d], y = window.prompt("Please enter your destination folder") ?? "";
    try {
      const O = Db(y.split("/"), {
        folders: Object.values(t.folders),
        required: !0
      });
      if (Object.values(t.files).some(
        (v) => v.name === m.name && v.folderId === O
      )) {
        alert("File already exists");
        return;
      }
      i(d, O);
    } catch (O) {
      window.alert(vb(O));
    }
  }, c = (d) => {
    const m = t.files[d], y = window.prompt("Rename file", m.name);
    if (y === null || y === m.name)
      return;
    if (Object.values(t.files).some(
      (b) => b.name === y && b.folderId === m.folderId
    )) {
      alert("File already exists");
      return;
    }
    r(d, y);
  }, h = (d) => {
    const m = t.folders[d], y = window.prompt("Rename folder", m.name);
    if (y === null || y === m.name)
      return;
    if (Object.values(t.folders).some(
      (b) => b.name === y && b.parentId === m.parentId
    )) {
      alert("Folder already exists");
      return;
    }
    n(m.id, y);
  };
  return /* @__PURE__ */ z.jsxs("div", { children: [
    /* @__PURE__ */ z.jsxs("div", { className: "files-toolbar", children: [
      /* @__PURE__ */ z.jsx("button", { type: "button", onClick: () => a(), children: "New Folder" }),
      /* @__PURE__ */ z.jsx("button", { type: "button", onClick: () => o(), children: "New File" })
    ] }),
    /* @__PURE__ */ z.jsx("ul", { children: /* @__PURE__ */ z.jsx(
      $w,
      {
        parentId: ys,
        folders: t.folders,
        newFolderPrompt: a,
        files: t.files,
        newFilePrompt: o,
        moveFilePrompt: u,
        renameFilePrompt: c,
        renameFolderPrompt: h
      }
    ) })
  ] });
}, qR = () => {
  const {
    config: { instructions: t }
  } = Er();
  return /* @__PURE__ */ z.jsx("div", { className: "instructions", children: t });
}, XR = () => /* @__PURE__ */ z.jsx("div", { children: "Search is not yet implemented. Sorry." }), VR = {
  Instructions: qR,
  Files: WR,
  Search: XR
}, YR = () => {
  const { config: t } = Er(), [e, r] = In(
    t.activeLeftNav || t.leftNav[0].component
  ), i = VR[e];
  return /* @__PURE__ */ z.jsxs(
    "div",
    {
      className: "left-pane-outer",
      style: { gridTemplateColumns: t.showSideBar ? "1fr 9fr" : "1fr" },
      children: [
        t.showSideBar && /* @__PURE__ */ z.jsx(ZR, {}),
        /* @__PURE__ */ z.jsxs("div", { className: "left-pane-inner", children: [
          /* @__PURE__ */ z.jsx("div", { className: "left-nav", children: /* @__PURE__ */ z.jsx(jR, { setActivePane: r, activePane: e }) }),
          /* @__PURE__ */ z.jsx("div", { className: "left-main", children: /* @__PURE__ */ z.jsx(i, {}) })
        ] })
      ]
    }
  );
}, UR = () => {
  const { project: t, closeFile: e, setActiveFile: r } = Er(), i = Fw(t.files, { mustBeOpen: !0 });
  return /* @__PURE__ */ z.jsx("div", { className: "files-nav-bar", children: i.map((n) => /* @__PURE__ */ z.jsxs("div", { className: "file-tab", style: { cursor: "pointer" }, children: [
    /* @__PURE__ */ z.jsx(
      "span",
      {
        onClick: () => r(n.id),
        style: { fontWeight: n.active ? "bold" : "normal" },
        children: n.name
      }
    ),
    /* @__PURE__ */ z.jsx("span", { onClick: () => e(n.id), children: "X" })
  ] }, n.id)) });
};
function vf() {
  return vf = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
    }
    return t;
  }, vf.apply(this, arguments);
}
function zR(t, e) {
  if (t == null)
    return {};
  var r = {}, i = Object.keys(t), n, s;
  for (s = 0; s < i.length; s++)
    n = i[s], !(e.indexOf(n) >= 0) && (r[n] = t[n]);
  return r;
}
class je {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, r, i) {
    [e, r] = Na(this, e, r);
    let n = [];
    return this.decompose(
      0,
      e,
      n,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      n,
      3
      /* Open.To */
    ), this.decompose(
      r,
      this.length,
      n,
      1
      /* Open.From */
    ), Si.from(n, this.length - (r - e) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, r = this.length) {
    [e, r] = Na(this, e, r);
    let i = [];
    return this.decompose(e, r, i, 0), Si.from(i, r - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let r = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), n = new Ho(this), s = new Ho(e);
    for (let a = r, o = r; ; ) {
      if (n.next(a), s.next(a), a = 0, n.lineBreak != s.lineBreak || n.done != s.done || n.value != s.value)
        return !1;
      if (o += n.value.length, n.done || o >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Ho(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, r = this.length) {
    return new Bw(this, e, r);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, r) {
    let i;
    if (e == null)
      i = this.iter();
    else {
      r == null && (r = this.lines + 1);
      let n = this.line(e).from;
      i = this.iterRange(n, Math.max(n, r == this.lines + 1 ? this.length : r <= 1 ? 0 : this.line(r - 1).to));
    }
    return new Iw(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? je.empty : e.length <= 32 ? new pt(e) : Si.from(pt.split(e, []));
  }
}
class pt extends je {
  constructor(e, r = GR(e)) {
    super(), this.text = e, this.length = r;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, r, i, n) {
    for (let s = 0; ; s++) {
      let a = this.text[s], o = n + a.length;
      if ((r ? i : o) >= e)
        return new HR(n, o, i, a);
      n = o + 1, i++;
    }
  }
  decompose(e, r, i, n) {
    let s = e <= 0 && r >= this.length ? this : new pt(zO(this.text, e, r), Math.min(r, this.length) - Math.max(0, e));
    if (n & 1) {
      let a = i.pop(), o = cc(s.text, a.text.slice(), 0, s.length);
      if (o.length <= 32)
        i.push(new pt(o, a.length + s.length));
      else {
        let u = o.length >> 1;
        i.push(new pt(o.slice(0, u)), new pt(o.slice(u)));
      }
    } else
      i.push(s);
  }
  replace(e, r, i) {
    if (!(i instanceof pt))
      return super.replace(e, r, i);
    [e, r] = Na(this, e, r);
    let n = cc(this.text, cc(i.text, zO(this.text, 0, e)), r), s = this.length + i.length - (r - e);
    return n.length <= 32 ? new pt(n, s) : Si.from(pt.split(n, []), s);
  }
  sliceString(e, r = this.length, i = `
`) {
    [e, r] = Na(this, e, r);
    let n = "";
    for (let s = 0, a = 0; s <= r && a < this.text.length; a++) {
      let o = this.text[a], u = s + o.length;
      s > e && a && (n += i), e < u && r > s && (n += o.slice(Math.max(0, e - s), r - s)), s = u + 1;
    }
    return n;
  }
  flatten(e) {
    for (let r of this.text)
      e.push(r);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, r) {
    let i = [], n = -1;
    for (let s of e)
      i.push(s), n += s.length + 1, i.length == 32 && (r.push(new pt(i, n)), i = [], n = -1);
    return n > -1 && r.push(new pt(i, n)), r;
  }
}
class Si extends je {
  constructor(e, r) {
    super(), this.children = e, this.length = r, this.lines = 0;
    for (let i of e)
      this.lines += i.lines;
  }
  lineInner(e, r, i, n) {
    for (let s = 0; ; s++) {
      let a = this.children[s], o = n + a.length, u = i + a.lines - 1;
      if ((r ? u : o) >= e)
        return a.lineInner(e, r, i, n);
      n = o + 1, i = u + 1;
    }
  }
  decompose(e, r, i, n) {
    for (let s = 0, a = 0; a <= r && s < this.children.length; s++) {
      let o = this.children[s], u = a + o.length;
      if (e <= u && r >= a) {
        let c = n & ((a <= e ? 1 : 0) | (u >= r ? 2 : 0));
        a >= e && u <= r && !c ? i.push(o) : o.decompose(e - a, r - a, i, c);
      }
      a = u + 1;
    }
  }
  replace(e, r, i) {
    if ([e, r] = Na(this, e, r), i.lines < this.lines)
      for (let n = 0, s = 0; n < this.children.length; n++) {
        let a = this.children[n], o = s + a.length;
        if (e >= s && r <= o) {
          let u = a.replace(e - s, r - s, i), c = this.lines - a.lines + u.lines;
          if (u.lines < c >> 4 && u.lines > c >> 6) {
            let h = this.children.slice();
            return h[n] = u, new Si(h, this.length - (r - e) + i.length);
          }
          return super.replace(s, o, u);
        }
        s = o + 1;
      }
    return super.replace(e, r, i);
  }
  sliceString(e, r = this.length, i = `
`) {
    [e, r] = Na(this, e, r);
    let n = "";
    for (let s = 0, a = 0; s < this.children.length && a <= r; s++) {
      let o = this.children[s], u = a + o.length;
      a > e && s && (n += i), e < u && r > a && (n += o.sliceString(e - a, r - a, i)), a = u + 1;
    }
    return n;
  }
  flatten(e) {
    for (let r of this.children)
      r.flatten(e);
  }
  scanIdentical(e, r) {
    if (!(e instanceof Si))
      return 0;
    let i = 0, [n, s, a, o] = r > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; n += r, s += r) {
      if (n == a || s == o)
        return i;
      let u = this.children[n], c = e.children[s];
      if (u != c)
        return i + u.scanIdentical(c, r);
      i += u.length + 1;
    }
  }
  static from(e, r = e.reduce((i, n) => i + n.length + 1, -1)) {
    let i = 0;
    for (let y of e)
      i += y.lines;
    if (i < 32) {
      let y = [];
      for (let O of e)
        O.flatten(y);
      return new pt(y, r);
    }
    let n = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), s = n << 1, a = n >> 1, o = [], u = 0, c = -1, h = [];
    function d(y) {
      let O;
      if (y.lines > s && y instanceof Si)
        for (let b of y.children)
          d(b);
      else
        y.lines > a && (u > a || !u) ? (m(), o.push(y)) : y instanceof pt && u && (O = h[h.length - 1]) instanceof pt && y.lines + O.lines <= 32 ? (u += y.lines, c += y.length + 1, h[h.length - 1] = new pt(O.text.concat(y.text), O.length + 1 + y.length)) : (u + y.lines > n && m(), u += y.lines, c += y.length + 1, h.push(y));
    }
    function m() {
      u != 0 && (o.push(h.length == 1 ? h[0] : Si.from(h, c)), c = -1, u = h.length = 0);
    }
    for (let y of e)
      d(y);
    return m(), o.length == 1 ? o[0] : new Si(o, r);
  }
}
je.empty = /* @__PURE__ */ new pt([""], 0);
function GR(t) {
  let e = -1;
  for (let r of t)
    e += r.length + 1;
  return e;
}
function cc(t, e, r = 0, i = 1e9) {
  for (let n = 0, s = 0, a = !0; s < t.length && n <= i; s++) {
    let o = t[s], u = n + o.length;
    u >= r && (u > i && (o = o.slice(0, i - n)), n < r && (o = o.slice(r - n)), a ? (e[e.length - 1] += o, a = !1) : e.push(o)), n = u + 1;
  }
  return e;
}
function zO(t, e, r) {
  return cc(t, [""], e, r);
}
class Ho {
  constructor(e, r = 1) {
    this.dir = r, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [r > 0 ? 1 : (e instanceof pt ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, r) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, n = this.nodes[i], s = this.offsets[i], a = s >> 1, o = n instanceof pt ? n.text.length : n.children.length;
      if (a == (r > 0 ? o : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        r > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (r > 0 ? 0 : 1)) {
        if (this.offsets[i] += r, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (n instanceof pt) {
        let u = n.text[a + (r < 0 ? -1 : 0)];
        if (this.offsets[i] += r, u.length > Math.max(0, e))
          return this.value = e == 0 ? u : r > 0 ? u.slice(e) : u.slice(0, u.length - e), this;
        e -= u.length;
      } else {
        let u = n.children[a + (r < 0 ? -1 : 0)];
        e > u.length ? (e -= u.length, this.offsets[i] += r) : (r < 0 && this.offsets[i]--, this.nodes.push(u), this.offsets.push(r > 0 ? 1 : (u instanceof pt ? u.text.length : u.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class Bw {
  constructor(e, r, i) {
    this.value = "", this.done = !1, this.cursor = new Ho(e, r > i ? -1 : 1), this.pos = r > i ? e.length : 0, this.from = Math.min(r, i), this.to = Math.max(r, i);
  }
  nextInner(e, r) {
    if (r < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, r < 0 ? this.pos - this.to : this.from - this.pos);
    let i = r < 0 ? this.pos - this.from : this.to - this.pos;
    e > i && (e = i), i -= e;
    let { value: n } = this.cursor.next(e);
    return this.pos += (n.length + e) * r, this.value = n.length <= i ? n : r < 0 ? n.slice(n.length - i) : n.slice(0, i), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class Iw {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: r, lineBreak: i, value: n } = this.inner.next(e);
    return r && this.afterBreak ? (this.value = "", this.afterBreak = !1) : r ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = n, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (je.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Ho.prototype[Symbol.iterator] = Bw.prototype[Symbol.iterator] = Iw.prototype[Symbol.iterator] = function() {
  return this;
});
class HR {
  /**
  @internal
  */
  constructor(e, r, i, n) {
    this.from = e, this.to = r, this.number = i, this.text = n;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function Na(t, e, r) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, r))];
}
let ba = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
for (let t = 1; t < ba.length; t++)
  ba[t] += ba[t - 1];
function JR(t) {
  for (let e = 1; e < ba.length; e += 2)
    if (ba[e] > t)
      return ba[e - 1] <= t;
  return !1;
}
function GO(t) {
  return t >= 127462 && t <= 127487;
}
const HO = 8205;
function $t(t, e, r = !0, i = !0) {
  return (r ? Nw : KR)(t, e, i);
}
function Nw(t, e, r) {
  if (e == t.length)
    return e;
  e && _w(t.charCodeAt(e)) && Qw(t.charCodeAt(e - 1)) && e--;
  let i = Et(t, e);
  for (e += Nr(i); e < t.length; ) {
    let n = Et(t, e);
    if (i == HO || n == HO || r && JR(n))
      e += Nr(n), i = n;
    else if (GO(n)) {
      let s = 0, a = e - 2;
      for (; a >= 0 && GO(Et(t, a)); )
        s++, a -= 2;
      if (s % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function KR(t, e, r) {
  for (; e > 0; ) {
    let i = Nw(t, e - 2, r);
    if (i < e)
      return i;
    e--;
  }
  return 0;
}
function _w(t) {
  return t >= 56320 && t < 57344;
}
function Qw(t) {
  return t >= 55296 && t < 56320;
}
function Et(t, e) {
  let r = t.charCodeAt(e);
  if (!Qw(r) || e + 1 == t.length)
    return r;
  let i = t.charCodeAt(e + 1);
  return _w(i) ? (r - 55296 << 10) + (i - 56320) + 65536 : r;
}
function iy(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function Nr(t) {
  return t < 65536 ? 1 : 2;
}
const Sf = /\r\n?|\n/;
var Pt = /* @__PURE__ */ function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
}(Pt || (Pt = {}));
class Fi {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2)
      e += this.sections[r];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2) {
      let i = this.sections[r + 1];
      e += i < 0 ? this.sections[r] : i;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let r = 0, i = 0, n = 0; r < this.sections.length; ) {
      let s = this.sections[r++], a = this.sections[r++];
      a < 0 ? (e(i, n, s), n += s) : n += a, i += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, r = !1) {
    wf(this, e, r);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let r = 0; r < this.sections.length; ) {
      let i = this.sections[r++], n = this.sections[r++];
      n < 0 ? e.push(i, n) : e.push(n, i);
    }
    return new Fi(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : Mw(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, r = !1) {
    return e.empty ? this : Cf(this, e, r);
  }
  mapPos(e, r = -1, i = Pt.Simple) {
    let n = 0, s = 0;
    for (let a = 0; a < this.sections.length; ) {
      let o = this.sections[a++], u = this.sections[a++], c = n + o;
      if (u < 0) {
        if (c > e)
          return s + (e - n);
        s += o;
      } else {
        if (i != Pt.Simple && c >= e && (i == Pt.TrackDel && n < e && c > e || i == Pt.TrackBefore && n < e || i == Pt.TrackAfter && c > e))
          return null;
        if (c > e || c == e && r < 0 && !o)
          return e == n || r < 0 ? s : s + u;
        s += u;
      }
      n = c;
    }
    if (e > n)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${n}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, r = e) {
    for (let i = 0, n = 0; i < this.sections.length && n <= r; ) {
      let s = this.sections[i++], a = this.sections[i++], o = n + s;
      if (a >= 0 && n <= r && o >= e)
        return n < e && o > r ? "cover" : !0;
      n = o;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let r = 0; r < this.sections.length; ) {
      let i = this.sections[r++], n = this.sections[r++];
      e += (e ? " " : "") + i + (n >= 0 ? ":" + n : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((r) => typeof r != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Fi(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new Fi(e);
  }
}
class bt extends Fi {
  constructor(e, r) {
    super(e), this.inserted = r;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return wf(this, (r, i, n, s, a) => e = e.replace(n, n + (i - r), a), !1), e;
  }
  mapDesc(e, r = !1) {
    return Cf(this, e, r, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let r = this.sections.slice(), i = [];
    for (let n = 0, s = 0; n < r.length; n += 2) {
      let a = r[n], o = r[n + 1];
      if (o >= 0) {
        r[n] = o, r[n + 1] = a;
        let u = n >> 1;
        for (; i.length < u; )
          i.push(je.empty);
        i.push(a ? e.slice(s, s + a) : je.empty);
      }
      s += a;
    }
    return new bt(r, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : Mw(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, r = !1) {
    return e.empty ? this : Cf(this, e, r, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, r = !1) {
    wf(this, e, r);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Fi.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let r = [], i = [], n = [], s = new pl(this);
    e:
      for (let a = 0, o = 0; ; ) {
        let u = a == e.length ? 1e9 : e[a++];
        for (; o < u || o == u && s.len == 0; ) {
          if (s.done)
            break e;
          let h = Math.min(s.len, u - o);
          jt(n, h, -1);
          let d = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
          jt(r, h, d), d > 0 && Fn(i, r, s.text), s.forward(h), o += h;
        }
        let c = e[a++];
        for (; o < c; ) {
          if (s.done)
            break e;
          let h = Math.min(s.len, c - o);
          jt(r, h, -1), jt(n, h, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(h), o += h;
        }
      }
    return {
      changes: new bt(r, i),
      filtered: Fi.create(n)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let r = 0; r < this.sections.length; r += 2) {
      let i = this.sections[r], n = this.sections[r + 1];
      n < 0 ? e.push(i) : n == 0 ? e.push([i]) : e.push([i].concat(this.inserted[r >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, r, i) {
    let n = [], s = [], a = 0, o = null;
    function u(h = !1) {
      if (!h && !n.length)
        return;
      a < r && jt(n, r - a, -1);
      let d = new bt(n, s);
      o = o ? o.compose(d.map(o)) : d, n = [], s = [], a = 0;
    }
    function c(h) {
      if (Array.isArray(h))
        for (let d of h)
          c(d);
      else if (h instanceof bt) {
        if (h.length != r)
          throw new RangeError(`Mismatched change set length (got ${h.length}, expected ${r})`);
        u(), o = o ? o.compose(h.map(o)) : h;
      } else {
        let { from: d, to: m = d, insert: y } = h;
        if (d > m || d < 0 || m > r)
          throw new RangeError(`Invalid change range ${d} to ${m} (in doc of length ${r})`);
        let O = y ? typeof y == "string" ? je.of(y.split(i || Sf)) : y : je.empty, b = O.length;
        if (d == m && b == 0)
          return;
        d < a && u(), d > a && jt(n, d - a, -1), jt(n, m - d, b), Fn(s, n, O), a = m;
      }
    }
    return c(e), u(!o), o;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new bt(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let r = [], i = [];
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if (typeof s == "number")
        r.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((a, o) => o && typeof a != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          r.push(s[0], 0);
        else {
          for (; i.length < n; )
            i.push(je.empty);
          i[n] = je.of(s.slice(1)), r.push(s[0], i[n].length);
        }
      }
    }
    return new bt(r, i);
  }
  /**
  @internal
  */
  static createSet(e, r) {
    return new bt(e, r);
  }
}
function jt(t, e, r, i = !1) {
  if (e == 0 && r <= 0)
    return;
  let n = t.length - 2;
  n >= 0 && r <= 0 && r == t[n + 1] ? t[n] += e : e == 0 && t[n] == 0 ? t[n + 1] += r : i ? (t[n] += e, t[n + 1] += r) : t.push(e, r);
}
function Fn(t, e, r) {
  if (r.length == 0)
    return;
  let i = e.length - 2 >> 1;
  if (i < t.length)
    t[t.length - 1] = t[t.length - 1].append(r);
  else {
    for (; t.length < i; )
      t.push(je.empty);
    t.push(r);
  }
}
function wf(t, e, r) {
  let i = t.inserted;
  for (let n = 0, s = 0, a = 0; a < t.sections.length; ) {
    let o = t.sections[a++], u = t.sections[a++];
    if (u < 0)
      n += o, s += o;
    else {
      let c = n, h = s, d = je.empty;
      for (; c += o, h += u, u && i && (d = d.append(i[a - 2 >> 1])), !(r || a == t.sections.length || t.sections[a + 1] < 0); )
        o = t.sections[a++], u = t.sections[a++];
      e(n, c, s, h, d), n = c, s = h;
    }
  }
}
function Cf(t, e, r, i = !1) {
  let n = [], s = i ? [] : null, a = new pl(t), o = new pl(e);
  for (let u = -1; ; )
    if (a.ins == -1 && o.ins == -1) {
      let c = Math.min(a.len, o.len);
      jt(n, c, -1), a.forward(c), o.forward(c);
    } else if (o.ins >= 0 && (a.ins < 0 || u == a.i || a.off == 0 && (o.len < a.len || o.len == a.len && !r))) {
      let c = o.len;
      for (jt(n, o.ins, -1); c; ) {
        let h = Math.min(a.len, c);
        a.ins >= 0 && u < a.i && a.len <= h && (jt(n, 0, a.ins), s && Fn(s, n, a.text), u = a.i), a.forward(h), c -= h;
      }
      o.next();
    } else if (a.ins >= 0) {
      let c = 0, h = a.len;
      for (; h; )
        if (o.ins == -1) {
          let d = Math.min(h, o.len);
          c += d, h -= d, o.forward(d);
        } else if (o.ins == 0 && o.len < h)
          h -= o.len, o.next();
        else
          break;
      jt(n, c, u < a.i ? a.ins : 0), s && u < a.i && Fn(s, n, a.text), u = a.i, a.forward(a.len - h);
    } else {
      if (a.done && o.done)
        return s ? bt.createSet(n, s) : Fi.create(n);
      throw new Error("Mismatched change set lengths");
    }
}
function Mw(t, e, r = !1) {
  let i = [], n = r ? [] : null, s = new pl(t), a = new pl(e);
  for (let o = !1; ; ) {
    if (s.done && a.done)
      return n ? bt.createSet(i, n) : Fi.create(i);
    if (s.ins == 0)
      jt(i, s.len, 0, o), s.next();
    else if (a.len == 0 && !a.done)
      jt(i, 0, a.ins, o), n && Fn(n, i, a.text), a.next();
    else {
      if (s.done || a.done)
        throw new Error("Mismatched change set lengths");
      {
        let u = Math.min(s.len2, a.len), c = i.length;
        if (s.ins == -1) {
          let h = a.ins == -1 ? -1 : a.off ? 0 : a.ins;
          jt(i, u, h, o), n && h && Fn(n, i, a.text);
        } else
          a.ins == -1 ? (jt(i, s.off ? 0 : s.len, u, o), n && Fn(n, i, s.textBit(u))) : (jt(i, s.off ? 0 : s.len, a.off ? 0 : a.ins, o), n && !a.off && Fn(n, i, a.text));
        o = (s.ins > u || a.ins >= 0 && a.len > u) && (o || i.length > c), s.forward2(u), a.forward(u);
      }
    }
  }
}
class pl {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, r = this.i - 2 >> 1;
    return r >= e.length ? je.empty : e[r];
  }
  textBit(e) {
    let { inserted: r } = this.set, i = this.i - 2 >> 1;
    return i >= r.length && !e ? je.empty : r[i].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class ms {
  constructor(e, r, i) {
    this.from = e, this.to = r, this.flags = i;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, r = -1) {
    let i, n;
    return this.empty ? i = n = e.mapPos(this.from, r) : (i = e.mapPos(this.from, 1), n = e.mapPos(this.to, -1)), i == this.from && n == this.to ? this : new ms(i, n, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, r = e) {
    if (e <= this.anchor && r >= this.anchor)
      return U.range(e, r);
    let i = Math.abs(e - this.anchor) > Math.abs(r - this.anchor) ? e : r;
    return U.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(e, r = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!r || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return U.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, r, i) {
    return new ms(e, r, i);
  }
}
class U {
  constructor(e, r) {
    this.ranges = e, this.mainIndex = r;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, r = -1) {
    return e.empty ? this : U.create(this.ranges.map((i) => i.map(e, r)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, r = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(e.ranges[i], r))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new U([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, r = !0) {
    return U.create([e].concat(this.ranges), r ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, r = this.mainIndex) {
    let i = this.ranges.slice();
    return i[r] = e, U.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new U(e.ranges.map((r) => ms.fromJSON(r)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, r = e) {
    return new U([U.range(e, r)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, r = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, n = 0; n < e.length; n++) {
      let s = e[n];
      if (s.empty ? s.from <= i : s.from < i)
        return U.normalized(e.slice(), r);
      i = s.to;
    }
    return new U(e, r);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, r = 0, i, n) {
    return ms.create(e, e, (r == 0 ? 0 : r < 0 ? 8 : 16) | (i == null ? 7 : Math.min(6, i)) | (n ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, r, i, n) {
    let s = (i ?? 16777215) << 6 | (n == null ? 7 : Math.min(6, n));
    return r < e ? ms.create(r, e, 48 | s) : ms.create(e, r, (r > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, r = 0) {
    let i = e[r];
    e.sort((n, s) => n.from - s.from), r = e.indexOf(i);
    for (let n = 1; n < e.length; n++) {
      let s = e[n], a = e[n - 1];
      if (s.empty ? s.from <= a.to : s.from < a.to) {
        let o = a.from, u = Math.max(s.to, a.to);
        n <= r && r--, e.splice(--n, 2, s.anchor > s.head ? U.range(u, o) : U.range(o, u));
      }
    }
    return new U(e, r);
  }
}
function Lw(t, e) {
  for (let r of t.ranges)
    if (r.to > e)
      throw new RangeError("Selection points outside of document");
}
let ny = 0;
class fe {
  constructor(e, r, i, n, s) {
    this.combine = e, this.compareInput = r, this.compare = i, this.isStatic = n, this.id = ny++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new fe(e.combine || ((r) => r), e.compareInput || ((r, i) => r === i), e.compare || (e.combine ? (r, i) => r === i : sy), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new hc([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new hc(e, this, 1, r);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new hc(e, this, 2, r);
  }
  from(e, r) {
    return r || (r = (i) => i), this.compute([e], (i) => r(i.field(e)));
  }
}
function sy(t, e) {
  return t == e || t.length == e.length && t.every((r, i) => r === e[i]);
}
class hc {
  constructor(e, r, i, n) {
    this.dependencies = e, this.facet = r, this.type = i, this.value = n, this.id = ny++;
  }
  dynamicSlot(e) {
    var r;
    let i = this.value, n = this.facet.compareInput, s = this.id, a = e[s] >> 1, o = this.type == 2, u = !1, c = !1, h = [];
    for (let d of this.dependencies)
      d == "doc" ? u = !0 : d == "selection" ? c = !0 : ((r = e[d.id]) !== null && r !== void 0 ? r : 1) & 1 || h.push(e[d.id]);
    return {
      create(d) {
        return d.values[a] = i(d), 1;
      },
      update(d, m) {
        if (u && m.docChanged || c && (m.docChanged || m.selection) || Af(d, h)) {
          let y = i(d);
          if (o ? !JO(y, d.values[a], n) : !n(y, d.values[a]))
            return d.values[a] = y, 1;
        }
        return 0;
      },
      reconfigure: (d, m) => {
        let y, O = m.config.address[s];
        if (O != null) {
          let b = Mc(m, O);
          if (this.dependencies.every((v) => v instanceof fe ? m.facet(v) === d.facet(v) : v instanceof St ? m.field(v, !1) == d.field(v, !1) : !0) || (o ? JO(y = i(d), b, n) : n(y = i(d), b)))
            return d.values[a] = b, 0;
        } else
          y = i(d);
        return d.values[a] = y, 1;
      }
    };
  }
}
function JO(t, e, r) {
  if (t.length != e.length)
    return !1;
  for (let i = 0; i < t.length; i++)
    if (!r(t[i], e[i]))
      return !1;
  return !0;
}
function Af(t, e) {
  let r = !1;
  for (let i of e)
    Jo(t, i) & 1 && (r = !0);
  return r;
}
function ej(t, e, r) {
  let i = r.map((u) => t[u.id]), n = r.map((u) => u.type), s = i.filter((u) => !(u & 1)), a = t[e.id] >> 1;
  function o(u) {
    let c = [];
    for (let h = 0; h < i.length; h++) {
      let d = Mc(u, i[h]);
      if (n[h] == 2)
        for (let m of d)
          c.push(m);
      else
        c.push(d);
    }
    return e.combine(c);
  }
  return {
    create(u) {
      for (let c of i)
        Jo(u, c);
      return u.values[a] = o(u), 1;
    },
    update(u, c) {
      if (!Af(u, s))
        return 0;
      let h = o(u);
      return e.compare(h, u.values[a]) ? 0 : (u.values[a] = h, 1);
    },
    reconfigure(u, c) {
      let h = Af(u, i), d = c.config.facets[e.id], m = c.facet(e);
      if (d && !h && sy(r, d))
        return u.values[a] = m, 0;
      let y = o(u);
      return e.compare(y, m) ? (u.values[a] = m, 0) : (u.values[a] = y, 1);
    }
  };
}
const KO = /* @__PURE__ */ fe.define({ static: !0 });
class St {
  constructor(e, r, i, n, s) {
    this.id = e, this.createF = r, this.updateF = i, this.compareF = n, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let r = new St(ny++, e.create, e.update, e.compare || ((i, n) => i === n), e);
    return e.provide && (r.provides = e.provide(r)), r;
  }
  create(e) {
    let r = e.facet(KO).find((i) => i.field == this);
    return ((r == null ? void 0 : r.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let r = e[this.id] >> 1;
    return {
      create: (i) => (i.values[r] = this.create(i), 1),
      update: (i, n) => {
        let s = i.values[r], a = this.updateF(s, n);
        return this.compareF(s, a) ? 0 : (i.values[r] = a, 1);
      },
      reconfigure: (i, n) => n.config.address[this.id] != null ? (i.values[r] = n.field(this), 0) : (i.values[r] = this.create(i), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, KO.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const cs = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function vo(t) {
  return (e) => new Rw(e, t);
}
const Ys = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ vo(cs.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ vo(cs.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ vo(cs.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ vo(cs.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ vo(cs.lowest)
};
class Rw {
  constructor(e, r) {
    this.inner = e, this.prec = r;
  }
}
class rp {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new Ef(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return rp.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class Ef {
  constructor(e, r) {
    this.compartment = e, this.inner = r;
  }
}
class Qc {
  constructor(e, r, i, n, s, a) {
    for (this.base = e, this.compartments = r, this.dynamicSlots = i, this.address = n, this.staticValues = s, this.facets = a, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let r = this.address[e.id];
    return r == null ? e.default : this.staticValues[r >> 1];
  }
  static resolve(e, r, i) {
    let n = [], s = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ new Map();
    for (let m of tj(e, r, a))
      m instanceof St ? n.push(m) : (s[m.facet.id] || (s[m.facet.id] = [])).push(m);
    let o = /* @__PURE__ */ Object.create(null), u = [], c = [];
    for (let m of n)
      o[m.id] = c.length << 1, c.push((y) => m.slot(y));
    let h = i == null ? void 0 : i.config.facets;
    for (let m in s) {
      let y = s[m], O = y[0].facet, b = h && h[m] || [];
      if (y.every(
        (v) => v.type == 0
        /* Provider.Static */
      ))
        if (o[O.id] = u.length << 1 | 1, sy(b, y))
          u.push(i.facet(O));
        else {
          let v = O.combine(y.map((S) => S.value));
          u.push(i && O.compare(v, i.facet(O)) ? i.facet(O) : v);
        }
      else {
        for (let v of y)
          v.type == 0 ? (o[v.id] = u.length << 1 | 1, u.push(v.value)) : (o[v.id] = c.length << 1, c.push((S) => v.dynamicSlot(S)));
        o[O.id] = c.length << 1, c.push((v) => ej(v, O, y));
      }
    }
    let d = c.map((m) => m(o));
    return new Qc(e, a, d, o, u, s);
  }
}
function tj(t, e, r) {
  let i = [[], [], [], [], []], n = /* @__PURE__ */ new Map();
  function s(a, o) {
    let u = n.get(a);
    if (u != null) {
      if (u <= o)
        return;
      let c = i[u].indexOf(a);
      c > -1 && i[u].splice(c, 1), a instanceof Ef && r.delete(a.compartment);
    }
    if (n.set(a, o), Array.isArray(a))
      for (let c of a)
        s(c, o);
    else if (a instanceof Ef) {
      if (r.has(a.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(a.compartment) || a.inner;
      r.set(a.compartment, c), s(c, o);
    } else if (a instanceof Rw)
      s(a.inner, a.prec);
    else if (a instanceof St)
      i[o].push(a), a.provides && s(a.provides, o);
    else if (a instanceof hc)
      i[o].push(a), a.facet.extensions && s(a.facet.extensions, cs.default);
    else {
      let c = a.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${a}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(c, o);
    }
  }
  return s(t, cs.default), i.reduce((a, o) => a.concat(o));
}
function Jo(t, e) {
  if (e & 1)
    return 2;
  let r = e >> 1, i = t.status[r];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  t.status[r] = 4;
  let n = t.computeSlot(t, t.config.dynamicSlots[r]);
  return t.status[r] = 2 | n;
}
function Mc(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const jw = /* @__PURE__ */ fe.define(), kf = /* @__PURE__ */ fe.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), Zw = /* @__PURE__ */ fe.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), Ww = /* @__PURE__ */ fe.define(), qw = /* @__PURE__ */ fe.define(), Xw = /* @__PURE__ */ fe.define(), Vw = /* @__PURE__ */ fe.define({
  combine: (t) => t.length ? t[0] : !1
});
class Ri {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new rj();
  }
}
class rj {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Ri(this, e);
  }
}
class ij {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new we(this, e);
  }
}
class we {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let r = this.type.map(this.value, e);
    return r === void 0 ? void 0 : r == this.value ? this : new we(this.type, r);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new ij(e.map || ((r) => r));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, r) {
    if (!e.length)
      return e;
    let i = [];
    for (let n of e) {
      let s = n.map(r);
      s && i.push(s);
    }
    return i;
  }
}
we.reconfigure = /* @__PURE__ */ we.define();
we.appendConfig = /* @__PURE__ */ we.define();
class yt {
  constructor(e, r, i, n, s, a) {
    this.startState = e, this.changes = r, this.selection = i, this.effects = n, this.annotations = s, this.scrollIntoView = a, this._doc = null, this._state = null, i && Lw(i, r.newLength), s.some((o) => o.type == yt.time) || (this.annotations = s.concat(yt.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, r, i, n, s, a) {
    return new yt(e, r, i, n, s, a);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let r of this.annotations)
      if (r.type == e)
        return r.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let r = this.annotation(yt.userEvent);
    return !!(r && (r == e || r.length > e.length && r.slice(0, e.length) == e && r[e.length] == "."));
  }
}
yt.time = /* @__PURE__ */ Ri.define();
yt.userEvent = /* @__PURE__ */ Ri.define();
yt.addToHistory = /* @__PURE__ */ Ri.define();
yt.remote = /* @__PURE__ */ Ri.define();
function nj(t, e) {
  let r = [];
  for (let i = 0, n = 0; ; ) {
    let s, a;
    if (i < t.length && (n == e.length || e[n] >= t[i]))
      s = t[i++], a = t[i++];
    else if (n < e.length)
      s = e[n++], a = e[n++];
    else
      return r;
    !r.length || r[r.length - 1] < s ? r.push(s, a) : r[r.length - 1] < a && (r[r.length - 1] = a);
  }
}
function Yw(t, e, r) {
  var i;
  let n, s, a;
  return r ? (n = e.changes, s = bt.empty(e.changes.length), a = t.changes.compose(e.changes)) : (n = e.changes.map(t.changes), s = t.changes.mapDesc(e.changes, !0), a = t.changes.compose(n)), {
    changes: a,
    selection: e.selection ? e.selection.map(s) : (i = t.selection) === null || i === void 0 ? void 0 : i.map(n),
    effects: we.mapEffects(t.effects, n).concat(we.mapEffects(e.effects, s)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function Tf(t, e, r) {
  let i = e.selection, n = Da(e.annotations);
  return e.userEvent && (n = n.concat(yt.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof bt ? e.changes : bt.of(e.changes || [], r, t.facet(Zw)),
    selection: i && (i instanceof U ? i : U.single(i.anchor, i.head)),
    effects: Da(e.effects),
    annotations: n,
    scrollIntoView: !!e.scrollIntoView
  };
}
function Uw(t, e, r) {
  let i = Tf(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (r = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (r = !1);
    let a = !!e[s].sequential;
    i = Yw(i, Tf(t, e[s], a ? i.changes.newLength : t.doc.length), a);
  }
  let n = yt.create(t, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return aj(r ? sj(n) : n);
}
function sj(t) {
  let e = t.startState, r = !0;
  for (let n of e.facet(Ww)) {
    let s = n(t);
    if (s === !1) {
      r = !1;
      break;
    }
    Array.isArray(s) && (r = r === !0 ? s : nj(r, s));
  }
  if (r !== !0) {
    let n, s;
    if (r === !1)
      s = t.changes.invertedDesc, n = bt.empty(e.doc.length);
    else {
      let a = t.changes.filter(r);
      n = a.changes, s = a.filtered.mapDesc(a.changes).invertedDesc;
    }
    t = yt.create(e, n, t.selection && t.selection.map(s), we.mapEffects(t.effects, s), t.annotations, t.scrollIntoView);
  }
  let i = e.facet(qw);
  for (let n = i.length - 1; n >= 0; n--) {
    let s = i[n](t);
    s instanceof yt ? t = s : Array.isArray(s) && s.length == 1 && s[0] instanceof yt ? t = s[0] : t = Uw(e, Da(s), !1);
  }
  return t;
}
function aj(t) {
  let e = t.startState, r = e.facet(Xw), i = t;
  for (let n = r.length - 1; n >= 0; n--) {
    let s = r[n](t);
    s && Object.keys(s).length && (i = Yw(i, Tf(e, s, t.changes.newLength), !0));
  }
  return i == t ? t : yt.create(e, t.changes, t.selection, i.effects, i.annotations, i.scrollIntoView);
}
const oj = [];
function Da(t) {
  return t == null ? oj : Array.isArray(t) ? t : [t];
}
var st = /* @__PURE__ */ function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
}(st || (st = {}));
const lj = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Pf;
try {
  Pf = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function uj(t) {
  if (Pf)
    return Pf.test(t);
  for (let e = 0; e < t.length; e++) {
    let r = t[e];
    if (/\w/.test(r) || r > "" && (r.toUpperCase() != r.toLowerCase() || lj.test(r)))
      return !0;
  }
  return !1;
}
function cj(t) {
  return (e) => {
    if (!/\S/.test(e))
      return st.Space;
    if (uj(e))
      return st.Word;
    for (let r = 0; r < t.length; r++)
      if (e.indexOf(t[r]) > -1)
        return st.Word;
    return st.Other;
  };
}
class Ie {
  constructor(e, r, i, n, s, a) {
    this.config = e, this.doc = r, this.selection = i, this.values = n, this.status = e.statusTemplate.slice(), this.computeSlot = s, a && (a._state = this);
    for (let o = 0; o < this.config.dynamicSlots.length; o++)
      Jo(this, o << 1);
    this.computeSlot = null;
  }
  field(e, r = !0) {
    let i = this.config.address[e.id];
    if (i == null) {
      if (r)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Jo(this, i), Mc(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return Uw(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let r = this.config, { base: i, compartments: n } = r;
    for (let o of e.effects)
      o.is(rp.reconfigure) ? (r && (n = /* @__PURE__ */ new Map(), r.compartments.forEach((u, c) => n.set(c, u)), r = null), n.set(o.value.compartment, o.value.extension)) : o.is(we.reconfigure) ? (r = null, i = o.value) : o.is(we.appendConfig) && (r = null, i = Da(i).concat(o.value));
    let s;
    r ? s = e.startState.values.slice() : (r = Qc.resolve(i, n, this), s = new Ie(r, this.doc, this.selection, r.dynamicSlots.map(() => null), (u, c) => c.reconfigure(u, this), null).values);
    let a = e.startState.facet(kf) ? e.newSelection : e.newSelection.asSingle();
    new Ie(r, e.newDoc, a, s, (o, u) => u.update(o, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((r) => ({
      changes: { from: r.from, to: r.to, insert: e },
      range: U.cursor(r.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let r = this.selection, i = e(r.ranges[0]), n = this.changes(i.changes), s = [i.range], a = Da(i.effects);
    for (let o = 1; o < r.ranges.length; o++) {
      let u = e(r.ranges[o]), c = this.changes(u.changes), h = c.map(n);
      for (let m = 0; m < o; m++)
        s[m] = s[m].map(h);
      let d = n.mapDesc(c, !0);
      s.push(u.range.map(d)), n = n.compose(h), a = we.mapEffects(a, h).concat(we.mapEffects(Da(u.effects), d));
    }
    return {
      changes: n,
      selection: U.create(s, r.mainIndex),
      effects: a
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof bt ? e : bt.of(e, this.doc.length, this.facet(Ie.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return je.of(e.split(this.facet(Ie.lineSeparator) || Sf));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, r = this.doc.length) {
    return this.doc.sliceString(e, r, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let r = this.config.address[e.id];
    return r == null ? e.default : (Jo(this, r), Mc(this, r));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let r = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let i in e) {
        let n = e[i];
        n instanceof St && this.config.address[n.id] != null && (r[i] = n.spec.toJSON(this.field(e[i]), this));
      }
    return r;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, r = {}, i) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let n = [];
    if (i) {
      for (let s in i)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let a = i[s], o = e[s];
          n.push(a.init((u) => a.spec.fromJSON(o, u)));
        }
    }
    return Ie.create({
      doc: e.doc,
      selection: U.fromJSON(e.selection),
      extensions: r.extensions ? n.concat([r.extensions]) : n
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let r = Qc.resolve(e.extensions || [], /* @__PURE__ */ new Map()), i = e.doc instanceof je ? e.doc : je.of((e.doc || "").split(r.staticFacet(Ie.lineSeparator) || Sf)), n = e.selection ? e.selection instanceof U ? e.selection : U.single(e.selection.anchor, e.selection.head) : U.single(0);
    return Lw(n, i.length), r.staticFacet(kf) || (n = n.asSingle()), new Ie(r, i, n, r.dynamicSlots.map(() => null), (s, a) => a.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(Ie.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(Ie.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(Vw);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...r) {
    for (let i of this.facet(Ie.phrases))
      if (Object.prototype.hasOwnProperty.call(i, e)) {
        e = i[e];
        break;
      }
    return r.length && (e = e.replace(/\$(\$|\d*)/g, (i, n) => {
      if (n == "$")
        return "$";
      let s = +(n || 1);
      return !s || s > r.length ? i : r[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, r, i = -1) {
    let n = [];
    for (let s of this.facet(jw))
      for (let a of s(this, r, i))
        Object.prototype.hasOwnProperty.call(a, e) && n.push(a[e]);
    return n;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return cj(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: r, from: i, length: n } = this.doc.lineAt(e), s = this.charCategorizer(e), a = e - i, o = e - i;
    for (; a > 0; ) {
      let u = $t(r, a, !1);
      if (s(r.slice(u, a)) != st.Word)
        break;
      a = u;
    }
    for (; o < n; ) {
      let u = $t(r, o);
      if (s(r.slice(o, u)) != st.Word)
        break;
      o = u;
    }
    return a == o ? null : U.range(a + i, o + i);
  }
}
Ie.allowMultipleSelections = kf;
Ie.tabSize = /* @__PURE__ */ fe.define({
  combine: (t) => t.length ? t[0] : 4
});
Ie.lineSeparator = Zw;
Ie.readOnly = Vw;
Ie.phrases = /* @__PURE__ */ fe.define({
  compare(t, e) {
    let r = Object.keys(t), i = Object.keys(e);
    return r.length == i.length && r.every((n) => t[n] == e[n]);
  }
});
Ie.languageData = jw;
Ie.changeFilter = Ww;
Ie.transactionFilter = qw;
Ie.transactionExtender = Xw;
rp.reconfigure = /* @__PURE__ */ we.define();
function ji(t, e, r = {}) {
  let i = {};
  for (let n of t)
    for (let s of Object.keys(n)) {
      let a = n[s], o = i[s];
      if (o === void 0)
        i[s] = a;
      else if (!(o === a || a === void 0))
        if (Object.hasOwnProperty.call(r, s))
          i[s] = r[s](o, a);
        else
          throw new Error("Config merge conflict for field " + s);
    }
  for (let n in e)
    i[n] === void 0 && (i[n] = e[n]);
  return i;
}
class ks {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, r = e) {
    return Ff.create(e, r, this);
  }
}
ks.prototype.startSide = ks.prototype.endSide = 0;
ks.prototype.point = !1;
ks.prototype.mapMode = Pt.TrackDel;
let Ff = class zw {
  constructor(e, r, i) {
    this.from = e, this.to = r, this.value = i;
  }
  /**
  @internal
  */
  static create(e, r, i) {
    return new zw(e, r, i);
  }
};
function $f(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class ay {
  constructor(e, r, i, n) {
    this.from = e, this.to = r, this.value = i, this.maxPoint = n;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, r, i, n = 0) {
    let s = i ? this.to : this.from;
    for (let a = n, o = s.length; ; ) {
      if (a == o)
        return a;
      let u = a + o >> 1, c = s[u] - e || (i ? this.value[u].endSide : this.value[u].startSide) - r;
      if (u == a)
        return c >= 0 ? a : o;
      c >= 0 ? o = u : a = u + 1;
    }
  }
  between(e, r, i, n) {
    for (let s = this.findIndex(r, -1e9, !0), a = this.findIndex(i, 1e9, !1, s); s < a; s++)
      if (n(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, r) {
    let i = [], n = [], s = [], a = -1, o = -1;
    for (let u = 0; u < this.value.length; u++) {
      let c = this.value[u], h = this.from[u] + e, d = this.to[u] + e, m, y;
      if (h == d) {
        let O = r.mapPos(h, c.startSide, c.mapMode);
        if (O == null || (m = y = O, c.startSide != c.endSide && (y = r.mapPos(h, c.endSide), y < m)))
          continue;
      } else if (m = r.mapPos(h, c.startSide), y = r.mapPos(d, c.endSide), m > y || m == y && c.startSide > 0 && c.endSide <= 0)
        continue;
      (y - m || c.endSide - c.startSide) < 0 || (a < 0 && (a = m), c.point && (o = Math.max(o, y - m)), i.push(c), n.push(m - a), s.push(y - a));
    }
    return { mapped: i.length ? new ay(n, s, i, o) : null, pos: a };
  }
}
class Me {
  constructor(e, r, i, n) {
    this.chunkPos = e, this.chunk = r, this.nextLayer = i, this.maxPoint = n;
  }
  /**
  @internal
  */
  static create(e, r, i, n) {
    return new Me(e, r, i, n);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let r of this.chunk)
      e += r.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: r = [], sort: i = !1, filterFrom: n = 0, filterTo: s = this.length } = e, a = e.filter;
    if (r.length == 0 && !a)
      return this;
    if (i && (r = r.slice().sort($f)), this.isEmpty)
      return r.length ? Me.of(r) : this;
    let o = new Gw(this, null, -1).goto(0), u = 0, c = [], h = new qn();
    for (; o.value || u < r.length; )
      if (u < r.length && (o.from - r[u].from || o.startSide - r[u].value.startSide) >= 0) {
        let d = r[u++];
        h.addInner(d.from, d.to, d.value) || c.push(d);
      } else
        o.rangeIndex == 1 && o.chunkIndex < this.chunk.length && (u == r.length || this.chunkEnd(o.chunkIndex) < r[u].from) && (!a || n > this.chunkEnd(o.chunkIndex) || s < this.chunkPos[o.chunkIndex]) && h.addChunk(this.chunkPos[o.chunkIndex], this.chunk[o.chunkIndex]) ? o.nextChunk() : ((!a || n > o.to || s < o.from || a(o.from, o.to, o.value)) && (h.addInner(o.from, o.to, o.value) || c.push(Ff.create(o.from, o.to, o.value))), o.next());
    return h.finishInner(this.nextLayer.isEmpty && !c.length ? Me.empty : this.nextLayer.update({ add: c, filter: a, filterFrom: n, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let r = [], i = [], n = -1;
    for (let a = 0; a < this.chunk.length; a++) {
      let o = this.chunkPos[a], u = this.chunk[a], c = e.touchesRange(o, o + u.length);
      if (c === !1)
        n = Math.max(n, u.maxPoint), r.push(u), i.push(e.mapPos(o));
      else if (c === !0) {
        let { mapped: h, pos: d } = u.map(o, e);
        h && (n = Math.max(n, h.maxPoint), r.push(h), i.push(d));
      }
    }
    let s = this.nextLayer.map(e);
    return r.length == 0 ? s : new Me(i, r, s || Me.empty, n);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, r, i) {
    if (!this.isEmpty) {
      for (let n = 0; n < this.chunk.length; n++) {
        let s = this.chunkPos[n], a = this.chunk[n];
        if (r >= s && e <= s + a.length && a.between(s, e - s, r - s, i) === !1)
          return;
      }
      this.nextLayer.between(e, r, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return dl.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, r = 0) {
    return dl.from(e).goto(r);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, r, i, n, s = -1) {
    let a = e.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= s), o = r.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= s), u = e1(a, o, i), c = new So(a, u, s), h = new So(o, u, s);
    i.iterGaps((d, m, y) => t1(c, d, h, m, y, n)), i.empty && i.length == 0 && t1(c, 0, h, 0, 0, n);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, r, i = 0, n) {
    n == null && (n = 999999999);
    let s = e.filter((h) => !h.isEmpty && r.indexOf(h) < 0), a = r.filter((h) => !h.isEmpty && e.indexOf(h) < 0);
    if (s.length != a.length)
      return !1;
    if (!s.length)
      return !0;
    let o = e1(s, a), u = new So(s, o, 0).goto(i), c = new So(a, o, 0).goto(i);
    for (; ; ) {
      if (u.to != c.to || !Bf(u.active, c.active) || u.point && (!c.point || !u.point.eq(c.point)))
        return !1;
      if (u.to > n)
        return !0;
      u.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, r, i, n, s = -1) {
    let a = new So(e, null, s).goto(r), o = r, u = a.openStart;
    for (; ; ) {
      let c = Math.min(a.to, i);
      if (a.point) {
        let h = a.activeForPoint(a.to), d = a.pointFrom < r ? h.length + 1 : Math.min(h.length, u);
        n.point(o, c, a.point, h, d, a.pointRank), u = Math.min(a.openEnd(c), h.length);
      } else
        c > o && (n.span(o, c, a.active, u), u = a.openEnd(c));
      if (a.to > i)
        return u + (a.point && a.to > i ? 1 : 0);
      o = a.to, a.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, r = !1) {
    let i = new qn();
    for (let n of e instanceof Ff ? [e] : r ? hj(e) : e)
      i.add(n.from, n.to, n.value);
    return i.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return Me.empty;
    let r = e[e.length - 1];
    for (let i = e.length - 2; i >= 0; i--)
      for (let n = e[i]; n != Me.empty; n = n.nextLayer)
        r = new Me(n.chunkPos, n.chunk, r, Math.max(n.maxPoint, r.maxPoint));
    return r;
  }
}
Me.empty = /* @__PURE__ */ new Me([], [], null, -1);
function hj(t) {
  if (t.length > 1)
    for (let e = t[0], r = 1; r < t.length; r++) {
      let i = t[r];
      if ($f(e, i) > 0)
        return t.slice().sort($f);
      e = i;
    }
  return t;
}
Me.empty.nextLayer = Me.empty;
class qn {
  finishChunk(e) {
    this.chunks.push(new ay(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, r, i) {
    this.addInner(e, r, i) || (this.nextLayer || (this.nextLayer = new qn())).add(e, r, i);
  }
  /**
  @internal
  */
  addInner(e, r, i) {
    let n = e - this.lastTo || i.startSide - this.last.endSide;
    if (n <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return n < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(r - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = r, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, r - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, r) {
    if ((e - this.lastTo || r.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, r.maxPoint), this.chunks.push(r), this.chunkPos.push(e);
    let i = r.value.length - 1;
    return this.last = r.value[i], this.lastFrom = r.from[i] + e, this.lastTo = r.to[i] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Me.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let r = Me.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, r;
  }
}
function e1(t, e, r) {
  let i = /* @__PURE__ */ new Map();
  for (let s of t)
    for (let a = 0; a < s.chunk.length; a++)
      s.chunk[a].maxPoint <= 0 && i.set(s.chunk[a], s.chunkPos[a]);
  let n = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let a = 0; a < s.chunk.length; a++) {
      let o = i.get(s.chunk[a]);
      o != null && (r ? r.mapPos(o) : o) == s.chunkPos[a] && !(r != null && r.touchesRange(o, o + s.chunk[a].length)) && n.add(s.chunk[a]);
    }
  return n;
}
class Gw {
  constructor(e, r, i, n = 0) {
    this.layer = e, this.skip = r, this.minPoint = i, this.rank = n;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, r = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, r, !1), this;
  }
  gotoInner(e, r, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let n = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(n) || this.layer.chunkEnd(this.chunkIndex) < e || n.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let n = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], r, !0);
      (!i || this.rangeIndex < n) && this.setRangeIndex(n);
    }
    this.next();
  }
  forward(e, r) {
    (this.to - e || this.endSide - r) < 0 && this.gotoInner(e, r, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], r = this.layer.chunk[this.chunkIndex], i = e + r.from[this.rangeIndex];
        if (this.from = i, this.to = e + r.to[this.rangeIndex], this.value = r.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class dl {
  constructor(e) {
    this.heap = e;
  }
  static from(e, r = null, i = -1) {
    let n = [];
    for (let s = 0; s < e.length; s++)
      for (let a = e[s]; !a.isEmpty; a = a.nextLayer)
        a.maxPoint >= i && n.push(new Gw(a, r, i, s));
    return n.length == 1 ? n[0] : new dl(n);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, r = -1e9) {
    for (let i of this.heap)
      i.goto(e, r);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      rd(this.heap, i);
    return this.next(), this;
  }
  forward(e, r) {
    for (let i of this.heap)
      i.forward(e, r);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      rd(this.heap, i);
    (this.to - e || this.value.endSide - r) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), rd(this.heap, 0);
    }
  }
}
function rd(t, e) {
  for (let r = t[e]; ; ) {
    let i = (e << 1) + 1;
    if (i >= t.length)
      break;
    let n = t[i];
    if (i + 1 < t.length && n.compare(t[i + 1]) >= 0 && (n = t[i + 1], i++), r.compare(n) < 0)
      break;
    t[i] = r, t[e] = n, e = i;
  }
}
class So {
  constructor(e, r, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = dl.from(e, r, i);
  }
  goto(e, r = -1e9) {
    return this.cursor.goto(e, r), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = r, this.openStart = -1, this.next(), this;
  }
  forward(e, r) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - r) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, r);
  }
  removeActive(e) {
    $u(this.active, e), $u(this.activeTo, e), $u(this.activeRank, e), this.minActive = r1(this.active, this.activeTo);
  }
  addActive(e) {
    let r = 0, { value: i, to: n, rank: s } = this.cursor;
    for (; r < this.activeRank.length && (s - this.activeRank[r] || n - this.activeTo[r]) > 0; )
      r++;
    Bu(this.active, r, i), Bu(this.activeTo, r, n), Bu(this.activeRank, r, s), e && Bu(e, r, this.cursor.from), this.minActive = r1(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, r = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let n = this.minActive;
      if (n > -1 && (this.activeTo[n] - this.cursor.from || this.active[n].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[n] > e) {
          this.to = this.activeTo[n], this.endSide = this.active[n].endSide;
          break;
        }
        this.removeActive(n), i && $u(i, n);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(i), this.cursor.next();
          else if (r && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let n = i.length - 1; n >= 0 && i[n] < e; n--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let r = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && r.push(this.active[i]);
    return r.reverse();
  }
  openEnd(e) {
    let r = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)
      r++;
    return r;
  }
}
function t1(t, e, r, i, n, s) {
  t.goto(e), r.goto(i);
  let a = i + n, o = i, u = i - e;
  for (; ; ) {
    let c = t.to + u - r.to || t.endSide - r.endSide, h = c < 0 ? t.to + u : r.to, d = Math.min(h, a);
    if (t.point || r.point ? t.point && r.point && (t.point == r.point || t.point.eq(r.point)) && Bf(t.activeForPoint(t.to), r.activeForPoint(r.to)) || s.comparePoint(o, d, t.point, r.point) : d > o && !Bf(t.active, r.active) && s.compareRange(o, d, t.active, r.active), h > a)
      break;
    o = h, c <= 0 && t.next(), c >= 0 && r.next();
  }
}
function Bf(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (t[r] != e[r] && !t[r].eq(e[r]))
      return !1;
  return !0;
}
function $u(t, e) {
  for (let r = e, i = t.length - 1; r < i; r++)
    t[r] = t[r + 1];
  t.pop();
}
function Bu(t, e, r) {
  for (let i = t.length - 1; i >= e; i--)
    t[i + 1] = t[i];
  t[e] = r;
}
function r1(t, e) {
  let r = -1, i = 1e9;
  for (let n = 0; n < e.length; n++)
    (e[n] - i || t[n].endSide - t[r].endSide) < 0 && (r = n, i = e[n]);
  return r;
}
function ro(t, e, r = t.length) {
  let i = 0;
  for (let n = 0; n < r; )
    t.charCodeAt(n) == 9 ? (i += e - i % e, n++) : (i++, n = $t(t, n));
  return i;
}
function If(t, e, r, i) {
  for (let n = 0, s = 0; ; ) {
    if (s >= e)
      return n;
    if (n == t.length)
      break;
    s += t.charCodeAt(n) == 9 ? r - s % r : 1, n = $t(t, n);
  }
  return i === !0 ? -1 : t.length;
}
const Nf = "", i1 = typeof Symbol > "u" ? "__" + Nf : Symbol.for(Nf), _f = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), n1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Xn {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, r) {
    this.rules = [];
    let { finish: i } = r || {};
    function n(a) {
      return /^@/.test(a) ? [a] : a.split(/,\s*/);
    }
    function s(a, o, u, c) {
      let h = [], d = /^@(\w+)\b/.exec(a[0]), m = d && d[1] == "keyframes";
      if (d && o == null)
        return u.push(a[0] + ";");
      for (let y in o) {
        let O = o[y];
        if (/&/.test(y))
          s(
            y.split(/,\s*/).map((b) => a.map((v) => b.replace(/&/, v))).reduce((b, v) => b.concat(v)),
            O,
            u
          );
        else if (O && typeof O == "object") {
          if (!d)
            throw new RangeError("The value of a property (" + y + ") should be a primitive value.");
          s(n(y), O, h, m);
        } else
          O != null && h.push(y.replace(/_.*/, "").replace(/[A-Z]/g, (b) => "-" + b.toLowerCase()) + ": " + O + ";");
      }
      (h.length || m) && u.push((i && !d && !c ? a.map(i) : a).join(", ") + " {" + h.join(" ") + "}");
    }
    for (let a in e)
      s(n(a), e[a], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let e = n1[i1] || 1;
    return n1[i1] = e + 1, Nf + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, r, i) {
    let n = e[_f], s = i && i.nonce;
    n ? s && n.setNonce(s) : n = new pj(e, s), n.mount(Array.isArray(r) ? r : [r]);
  }
}
let s1 = /* @__PURE__ */ new Map();
class pj {
  constructor(e, r) {
    let i = e.ownerDocument || e, n = i.defaultView;
    if (!e.head && e.adoptedStyleSheets && n.CSSStyleSheet) {
      let s = s1.get(i);
      if (s)
        return e.adoptedStyleSheets = [s.sheet, ...e.adoptedStyleSheets], e[_f] = s;
      this.sheet = new n.CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets], s1.set(i, this);
    } else {
      this.styleTag = i.createElement("style"), r && this.styleTag.setAttribute("nonce", r);
      let s = e.head || e;
      s.insertBefore(this.styleTag, s.firstChild);
    }
    this.modules = [], e[_f] = this;
  }
  mount(e) {
    let r = this.sheet, i = 0, n = 0;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], o = this.modules.indexOf(a);
      if (o < n && o > -1 && (this.modules.splice(o, 1), n--, o = -1), o == -1) {
        if (this.modules.splice(n++, 0, a), r)
          for (let u = 0; u < a.rules.length; u++)
            r.insertRule(a.rules[u], i++);
      } else {
        for (; n < o; )
          i += this.modules[n++].rules.length;
        i += a.rules.length, n++;
      }
    }
    if (!r) {
      let s = "";
      for (let a = 0; a < this.modules.length; a++)
        s += this.modules[a].getRules() + `
`;
      this.styleTag.textContent = s;
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var Vn = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, fl = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, dj = typeof navigator < "u" && /Mac/.test(navigator.platform), fj = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var kt = 0; kt < 10; kt++)
  Vn[48 + kt] = Vn[96 + kt] = String(kt);
for (var kt = 1; kt <= 24; kt++)
  Vn[kt + 111] = "F" + kt;
for (var kt = 65; kt <= 90; kt++)
  Vn[kt] = String.fromCharCode(kt + 32), fl[kt] = String.fromCharCode(kt);
for (var id in Vn)
  fl.hasOwnProperty(id) || (fl[id] = Vn[id]);
function mj(t) {
  var e = dj && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || fj && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", r = !e && t.key || (t.shiftKey ? fl : Vn)[t.keyCode] || t.key || "Unidentified";
  return r == "Esc" && (r = "Escape"), r == "Del" && (r = "Delete"), r == "Left" && (r = "ArrowLeft"), r == "Up" && (r = "ArrowUp"), r == "Right" && (r = "ArrowRight"), r == "Down" && (r = "ArrowDown"), r;
}
function Lc(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function Qf(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function gj(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function pc(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return Qf(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function _a(t) {
  return t.nodeType == 3 ? Ts(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function Ko(t, e, r, i) {
  return r ? a1(t, e, r, i, -1) || a1(t, e, r, i, 1) : !1;
}
function ml(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function a1(t, e, r, i, n) {
  for (; ; ) {
    if (t == r && e == i)
      return !0;
    if (e == (n < 0 ? 0 : tn(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let s = t.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = ml(t) + (n < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (n < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = n < 0 ? tn(t) : 0;
    } else
      return !1;
  }
}
function tn(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function ip(t, e) {
  let r = e ? t.left : t.right;
  return { left: r, right: r, top: t.top, bottom: t.bottom };
}
function yj(t) {
  return {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function Hw(t, e) {
  let r = e.width / t.offsetWidth, i = e.height / t.offsetHeight;
  return (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.width - t.offsetWidth) < 1) && (r = 1), (i > 0.995 && i < 1.005 || !isFinite(i) || Math.abs(e.height - t.offsetHeight) < 1) && (i = 1), { scaleX: r, scaleY: i };
}
function Oj(t, e, r, i, n, s, a, o) {
  let u = t.ownerDocument, c = u.defaultView || window;
  for (let h = t, d = !1; h && !d; )
    if (h.nodeType == 1) {
      let m, y = h == u.body, O = 1, b = 1;
      if (y)
        m = yj(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(h).position) && (d = !0), h.scrollHeight <= h.clientHeight && h.scrollWidth <= h.clientWidth) {
          h = h.assignedSlot || h.parentNode;
          continue;
        }
        let x = h.getBoundingClientRect();
        ({ scaleX: O, scaleY: b } = Hw(h, x)), m = {
          left: x.left,
          right: x.left + h.clientWidth * O,
          top: x.top,
          bottom: x.top + h.clientHeight * b
        };
      }
      let v = 0, S = 0;
      if (n == "nearest")
        e.top < m.top ? (S = -(m.top - e.top + a), r > 0 && e.bottom > m.bottom + S && (S = e.bottom - m.bottom + S + a)) : e.bottom > m.bottom && (S = e.bottom - m.bottom + a, r < 0 && e.top - S < m.top && (S = -(m.top + S - e.top + a)));
      else {
        let x = e.bottom - e.top, w = m.bottom - m.top;
        S = (n == "center" && x <= w ? e.top + x / 2 - w / 2 : n == "start" || n == "center" && r < 0 ? e.top - a : e.bottom - w + a) - m.top;
      }
      if (i == "nearest" ? e.left < m.left ? (v = -(m.left - e.left + s), r > 0 && e.right > m.right + v && (v = e.right - m.right + v + s)) : e.right > m.right && (v = e.right - m.right + s, r < 0 && e.left < m.left + v && (v = -(m.left + v - e.left + s))) : v = (i == "center" ? e.left + (e.right - e.left) / 2 - (m.right - m.left) / 2 : i == "start" == o ? e.left - s : e.right - (m.right - m.left) + s) - m.left, v || S)
        if (y)
          c.scrollBy(v, S);
        else {
          let x = 0, w = 0;
          if (S) {
            let k = h.scrollTop;
            h.scrollTop += S / b, w = (h.scrollTop - k) * b;
          }
          if (v) {
            let k = h.scrollLeft;
            h.scrollLeft += v / O, x = (h.scrollLeft - k) * O;
          }
          e = {
            left: e.left - x,
            top: e.top - w,
            right: e.right - x,
            bottom: e.bottom - w
          }, x && Math.abs(x - v) < 1 && (i = "nearest"), w && Math.abs(w - S) < 1 && (n = "nearest");
        }
      if (y)
        break;
      h = h.assignedSlot || h.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
}
function xj(t) {
  let e = t.ownerDocument;
  for (let r = t.parentNode; r && r != e.body; )
    if (r.nodeType == 1) {
      if (r.scrollHeight > r.clientHeight || r.scrollWidth > r.clientWidth)
        return r;
      r = r.assignedSlot || r.parentNode;
    } else if (r.nodeType == 11)
      r = r.host;
    else
      break;
  return null;
}
class bj {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: r, focusNode: i } = e;
    this.set(r, Math.min(e.anchorOffset, r ? tn(r) : 0), i, Math.min(e.focusOffset, i ? tn(i) : 0));
  }
  set(e, r, i, n) {
    this.anchorNode = e, this.anchorOffset = r, this.focusNode = i, this.focusOffset = n;
  }
}
let na = null;
function Jw(t) {
  if (t.setActive)
    return t.setActive();
  if (na)
    return t.focus(na);
  let e = [];
  for (let r = t; r && (e.push(r, r.scrollTop, r.scrollLeft), r != r.ownerDocument); r = r.parentNode)
    ;
  if (t.focus(na == null ? {
    get preventScroll() {
      return na = { preventScroll: !0 }, !0;
    }
  } : void 0), !na) {
    na = !1;
    for (let r = 0; r < e.length; ) {
      let i = e[r++], n = e[r++], s = e[r++];
      i.scrollTop != n && (i.scrollTop = n), i.scrollLeft != s && (i.scrollLeft = s);
    }
  }
}
let o1;
function Ts(t, e, r = e) {
  let i = o1 || (o1 = document.createRange());
  return i.setEnd(t, r), i.setStart(t, e), i;
}
function va(t, e, r) {
  let i = { key: e, code: e, keyCode: r, which: r, cancelable: !0 }, n = new KeyboardEvent("keydown", i);
  n.synthetic = !0, t.dispatchEvent(n);
  let s = new KeyboardEvent("keyup", i);
  return s.synthetic = !0, t.dispatchEvent(s), n.defaultPrevented || s.defaultPrevented;
}
function Dj(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function Kw(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function vj(t, e) {
  let r = e.focusNode, i = e.focusOffset;
  if (!r || e.anchorNode != r || e.anchorOffset != i)
    return !1;
  for (i = Math.min(i, tn(r)); ; )
    if (i) {
      if (r.nodeType != 1)
        return !1;
      let n = r.childNodes[i - 1];
      n.contentEditable == "false" ? i-- : (r = n, i = tn(r));
    } else {
      if (r == t)
        return !0;
      i = ml(r), r = r.parentNode;
    }
}
function eC(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
class Wt {
  constructor(e, r, i = !0) {
    this.node = e, this.offset = r, this.precise = i;
  }
  static before(e, r) {
    return new Wt(e.parentNode, ml(e), r);
  }
  static after(e, r) {
    return new Wt(e.parentNode, ml(e) + 1, r);
  }
}
const oy = [];
class rt {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let r = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return r;
      r += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, r) {
    if (this.flags & 2) {
      let i = this.dom, n = null, s;
      for (let a of this.children) {
        if (a.flags & 7) {
          if (!a.dom && (s = n ? n.nextSibling : i.firstChild)) {
            let o = rt.get(s);
            (!o || !o.parent && o.canReuseDOM(a)) && a.reuseDOM(s);
          }
          a.sync(e, r), a.flags &= -8;
        }
        if (s = n ? n.nextSibling : i.firstChild, r && !r.written && r.node == i && s != a.dom && (r.written = !0), a.dom.parentNode == i)
          for (; s && s != a.dom; )
            s = l1(s);
        else
          i.insertBefore(a.dom, s);
        n = a.dom;
      }
      for (s = n ? n.nextSibling : i.firstChild, s && r && r.node == i && (r.written = !0); s; )
        s = l1(s);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(e, r), i.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, r) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[r];
    else {
      let n = tn(e) == 0 ? 0 : r == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        n == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? n = -1 : n = 1), e = s;
      }
      n < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !rt.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let n = 0, s = 0; ; n++) {
      let a = this.children[n];
      if (a.dom == i)
        return s;
      s += a.length + a.breakAfter;
    }
  }
  domBoundsAround(e, r, i = 0) {
    let n = -1, s = -1, a = -1, o = -1;
    for (let u = 0, c = i, h = i; u < this.children.length; u++) {
      let d = this.children[u], m = c + d.length;
      if (c < e && m > r)
        return d.domBoundsAround(e, r, c);
      if (m >= e && n == -1 && (n = u, s = c), c > r && d.dom.parentNode == this.dom) {
        a = u, o = h;
        break;
      }
      h = m, c = m + d.breakAfter;
    }
    return {
      from: s,
      to: o < 0 ? i + this.length : o,
      startDOM: (n ? this.children[n - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: a < this.children.length && a >= 0 ? this.children[a].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let r = this.parent; r; r = r.parent) {
      if (e && (r.flags |= 2), r.flags & 1)
        return;
      r.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let r = e.parent;
      if (!r)
        return e;
      e = r;
    }
  }
  replaceChildren(e, r, i = oy) {
    this.markDirty();
    for (let n = e; n < r; n++) {
      let s = this.children[n];
      s.parent == this && i.indexOf(s) < 0 && s.destroy();
    }
    this.children.splice(e, r - e, ...i);
    for (let n = 0; n < i.length; n++)
      i[n].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new tC(this.children, e, this.children.length);
  }
  childPos(e, r = 1) {
    return this.childCursor().findPos(e, r);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, r, i, n, s, a) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
rt.prototype.breakAfter = 0;
function l1(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class tC {
  constructor(e, r, i) {
    this.children = e, this.pos = r, this.i = i, this.off = 0;
  }
  findPos(e, r = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (r > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function rC(t, e, r, i, n, s, a, o, u) {
  let { children: c } = t, h = c.length ? c[e] : null, d = s.length ? s[s.length - 1] : null, m = d ? d.breakAfter : a;
  if (!(e == i && h && !a && !m && s.length < 2 && h.merge(r, n, s.length ? d : null, r == 0, o, u))) {
    if (i < c.length) {
      let y = c[i];
      y && (n < y.length || y.breakAfter && (d != null && d.breakAfter)) ? (e == i && (y = y.split(n), n = 0), !m && d && y.merge(0, n, d, !0, 0, u) ? s[s.length - 1] = y : ((n || y.children.length && !y.children[0].length) && y.merge(0, n, null, !1, 0, u), s.push(y))) : y != null && y.breakAfter && (d ? d.breakAfter = 1 : a = 1), i++;
    }
    for (h && (h.breakAfter = a, r > 0 && (!a && s.length && h.merge(r, h.length, s[0], !1, o, 0) ? h.breakAfter = s.shift().breakAfter : (r < h.length || h.children.length && h.children[h.children.length - 1].length == 0) && h.merge(r, h.length, null, !1, o, 0), e++)); e < i && s.length; )
      if (c[i - 1].become(s[s.length - 1]))
        i--, s.pop(), u = s.length ? 0 : o;
      else if (c[e].become(s[0]))
        e++, s.shift(), o = s.length ? 0 : u;
      else
        break;
    !s.length && e && i < c.length && !c[e - 1].breakAfter && c[i].merge(0, 0, c[e - 1], !1, o, u) && e--, (e < i || s.length) && t.replaceChildren(e, i, s);
  }
}
function iC(t, e, r, i, n, s) {
  let a = t.childCursor(), { i: o, off: u } = a.findPos(r, 1), { i: c, off: h } = a.findPos(e, -1), d = e - r;
  for (let m of i)
    d += m.length;
  t.length += d, rC(t, c, h, o, u, i, 0, n, s);
}
let xr = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Mf = typeof document < "u" ? document : { documentElement: { style: {} } };
const Lf = /* @__PURE__ */ /Edge\/(\d+)/.exec(xr.userAgent), nC = /* @__PURE__ */ /MSIE \d/.test(xr.userAgent), Rf = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(xr.userAgent), np = !!(nC || Rf || Lf), u1 = !np && /* @__PURE__ */ /gecko\/(\d+)/i.test(xr.userAgent), nd = !np && /* @__PURE__ */ /Chrome\/(\d+)/.exec(xr.userAgent), c1 = "webkitFontSmoothing" in Mf.documentElement.style, sC = !np && /* @__PURE__ */ /Apple Computer/.test(xr.vendor), h1 = sC && (/* @__PURE__ */ /Mobile\/\w+/.test(xr.userAgent) || xr.maxTouchPoints > 2);
var ge = {
  mac: h1 || /* @__PURE__ */ /Mac/.test(xr.platform),
  windows: /* @__PURE__ */ /Win/.test(xr.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(xr.platform),
  ie: np,
  ie_version: nC ? Mf.documentMode || 6 : Rf ? +Rf[1] : Lf ? +Lf[1] : 0,
  gecko: u1,
  gecko_version: u1 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(xr.userAgent) || [0, 0])[1] : 0,
  chrome: !!nd,
  chrome_version: nd ? +nd[1] : 0,
  ios: h1,
  android: /* @__PURE__ */ /Android\b/.test(xr.userAgent),
  webkit: c1,
  safari: sC,
  webkit_version: c1 ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: Mf.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const Sj = 256;
class rn extends rt {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, r) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (r && r.node == this.dom && (r.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, r, i) {
    return this.flags & 8 || i && (!(i instanceof rn) || this.length - (r - e) + i.length > Sj || i.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(r), this.markDirty(), !0);
  }
  split(e) {
    let r = new rn(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), r.flags |= this.flags & 8, r;
  }
  localPosFromDOM(e, r) {
    return e == this.dom ? r : r ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Wt(this.dom, e);
  }
  domBoundsAround(e, r, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, r) {
    return wj(this.dom, e, r);
  }
}
class nn extends rt {
  constructor(e, r = [], i = 0) {
    super(), this.mark = e, this.children = r, this.length = i;
    for (let n of r)
      n.setParent(this);
  }
  setAttrs(e) {
    if (Kw(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let r in this.mark.attrs)
        e.setAttribute(r, this.mark.attrs[r]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, r);
  }
  merge(e, r, i, n, s, a) {
    return i && (!(i instanceof nn && i.mark.eq(this.mark)) || e && s <= 0 || r < this.length && a <= 0) ? !1 : (iC(this, e, r, i ? i.children.slice() : [], s - 1, a - 1), this.markDirty(), !0);
  }
  split(e) {
    let r = [], i = 0, n = -1, s = 0;
    for (let o of this.children) {
      let u = i + o.length;
      u > e && r.push(i < e ? o.split(e - i) : o), n < 0 && i >= e && (n = s), i = u, s++;
    }
    let a = this.length - e;
    return this.length = e, n > -1 && (this.children.length = n, this.markDirty()), new nn(this.mark, r, a);
  }
  domAtPos(e) {
    return aC(this, e);
  }
  coordsAt(e, r) {
    return lC(this, e, r);
  }
}
function wj(t, e, r) {
  let i = t.nodeValue.length;
  e > i && (e = i);
  let n = e, s = e, a = 0;
  e == 0 && r < 0 || e == i && r >= 0 ? ge.chrome || ge.gecko || (e ? (n--, a = 1) : s < i && (s++, a = -1)) : r < 0 ? n-- : s < i && s++;
  let o = Ts(t, n, s).getClientRects();
  if (!o.length)
    return null;
  let u = o[(a ? a < 0 : r >= 0) ? 0 : o.length - 1];
  return ge.safari && !a && u.width == 0 && (u = Array.prototype.find.call(o, (c) => c.width) || u), a ? ip(u, a < 0) : u || null;
}
class $n extends rt {
  static create(e, r, i) {
    return new $n(e, r, i);
  }
  constructor(e, r, i) {
    super(), this.widget = e, this.length = r, this.side = i, this.prevWidget = null;
  }
  split(e) {
    let r = $n.create(this.widget, this.length - e, this.side);
    return this.length -= e, r;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, r, i, n, s, a) {
    return i && (!(i instanceof $n) || !this.widget.compare(i.widget) || e > 0 && s <= 0 || r < this.length && a <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - r), !0);
  }
  become(e) {
    return e instanceof $n && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return je.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: r } = e, i = r && r.state.doc, n = this.posAtStart;
    return i ? i.slice(n, n + this.length) : je.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Wt.before(this.dom) : Wt.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, r) {
    let i = this.widget.coordsAt(this.dom, e, r);
    if (i)
      return i;
    let n = this.dom.getClientRects(), s = null;
    if (!n.length)
      return null;
    let a = this.side ? this.side < 0 : e > 0;
    for (let o = a ? n.length - 1 : 0; s = n[o], !(e > 0 ? o == 0 : o == n.length - 1 || s.top < s.bottom); o += a ? -1 : 1)
      ;
    return ip(s, !a);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Qa extends rt {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Qa && e.side == this.side;
  }
  split() {
    return new Qa(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Wt.before(this.dom) : Wt.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return je.empty;
  }
  get isHidden() {
    return !0;
  }
}
rn.prototype.children = $n.prototype.children = Qa.prototype.children = oy;
function aC(t, e) {
  let r = t.dom, { children: i } = t, n = 0;
  for (let s = 0; n < i.length; n++) {
    let a = i[n], o = s + a.length;
    if (!(o == s && a.getSide() <= 0)) {
      if (e > s && e < o && a.dom.parentNode == r)
        return a.domAtPos(e - s);
      if (e <= s)
        break;
      s = o;
    }
  }
  for (let s = n; s > 0; s--) {
    let a = i[s - 1];
    if (a.dom.parentNode == r)
      return a.domAtPos(a.length);
  }
  for (let s = n; s < i.length; s++) {
    let a = i[s];
    if (a.dom.parentNode == r)
      return a.domAtPos(0);
  }
  return new Wt(r, 0);
}
function oC(t, e, r) {
  let i, { children: n } = t;
  r > 0 && e instanceof nn && n.length && (i = n[n.length - 1]) instanceof nn && i.mark.eq(e.mark) ? oC(i, e.children[0], r - 1) : (n.push(e), e.setParent(t)), t.length += e.length;
}
function lC(t, e, r) {
  let i = null, n = -1, s = null, a = -1;
  function o(c, h) {
    for (let d = 0, m = 0; d < c.children.length && m <= h; d++) {
      let y = c.children[d], O = m + y.length;
      O >= h && (y.children.length ? o(y, h - m) : (!s || s.isHidden && r > 0) && (O > h || m == O && y.getSide() > 0) ? (s = y, a = h - m) : (m < h || m == O && y.getSide() < 0 && !y.isHidden) && (i = y, n = h - m)), m = O;
    }
  }
  o(t, e);
  let u = (r < 0 ? i : s) || i || s;
  return u ? u.coordsAt(Math.max(0, u == i ? n : a), r) : Cj(t);
}
function Cj(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let r = _a(e);
  return r[r.length - 1] || null;
}
function jf(t, e) {
  for (let r in t)
    r == "class" && e.class ? e.class += " " + t.class : r == "style" && e.style ? e.style += ";" + t.style : e[r] = t[r];
  return e;
}
const p1 = /* @__PURE__ */ Object.create(null);
function ly(t, e, r) {
  if (t == e)
    return !0;
  t || (t = p1), e || (e = p1);
  let i = Object.keys(t), n = Object.keys(e);
  if (i.length - (r && i.indexOf(r) > -1 ? 1 : 0) != n.length - (r && n.indexOf(r) > -1 ? 1 : 0))
    return !1;
  for (let s of i)
    if (s != r && (n.indexOf(s) == -1 || t[s] !== e[s]))
      return !1;
  return !0;
}
function Zf(t, e, r) {
  let i = !1;
  if (e)
    for (let n in e)
      r && n in r || (i = !0, n == "style" ? t.style.cssText = "" : t.removeAttribute(n));
  if (r)
    for (let n in r)
      e && e[n] == r[n] || (i = !0, n == "style" ? t.style.cssText = r[n] : t.setAttribute(n, r[n]));
  return i;
}
function Aj(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r = 0; r < t.attributes.length; r++) {
    let i = t.attributes[r];
    e[i.name] = i.value;
  }
  return e;
}
class xt extends rt {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, r, i, n, s, a) {
    if (i) {
      if (!(i instanceof xt))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return n && this.setDeco(i ? i.attrs : null), iC(this, e, r, i ? i.children.slice() : [], s, a), !0;
  }
  split(e) {
    let r = new xt();
    if (r.breakAfter = this.breakAfter, this.length == 0)
      return r;
    let { i, off: n } = this.childPos(e);
    n && (r.append(this.children[i].split(n), 0), this.children[i].merge(n, this.children[i].length, null, !1, 0, 0), i++);
    for (let s = i; s < this.children.length; s++)
      r.append(this.children[s], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, r;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    ly(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, r) {
    oC(this, e, r);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let r = e.spec.attributes, i = e.spec.class;
    r && (this.attrs = jf(r, this.attrs || {})), i && (this.attrs = jf({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return aC(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    var i;
    this.dom ? this.flags & 4 && (Kw(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Zf(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, r);
    let n = this.dom.lastChild;
    for (; n && rt.get(n) instanceof nn; )
      n = n.lastChild;
    if (!n || !this.length || n.nodeName != "BR" && ((i = rt.get(n)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!ge.ios || !this.children.some((s) => s instanceof rn))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, r;
    for (let i of this.children) {
      if (!(i instanceof rn) || /[^ -~]/.test(i.text))
        return null;
      let n = _a(i.dom);
      if (n.length != 1)
        return null;
      e += n[0].width, r = n[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: r
    } : null;
  }
  coordsAt(e, r) {
    let i = lC(this, e, r);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: n } = this.parent.view.viewState, s = i.bottom - i.top;
      if (Math.abs(s - n.lineHeight) < 2 && n.textHeight < s) {
        let a = (s - n.textHeight) / 2;
        return { top: i.top + a, bottom: i.bottom - a, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(e) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(e, r) {
    for (let i = 0, n = 0; i < e.children.length; i++) {
      let s = e.children[i], a = n + s.length;
      if (a >= r) {
        if (s instanceof xt)
          return s;
        if (a > r)
          break;
      }
      n = a + s.breakAfter;
    }
    return null;
  }
}
class _n extends rt {
  constructor(e, r, i) {
    super(), this.widget = e, this.length = r, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, r, i, n, s, a) {
    return i && (!(i instanceof _n) || !this.widget.compare(i.widget) || e > 0 && s <= 0 || r < this.length && a <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - r), !0);
  }
  domAtPos(e) {
    return e == 0 ? Wt.before(this.dom) : Wt.after(this.dom, e == this.length);
  }
  split(e) {
    let r = this.length - e;
    this.length = e;
    let i = new _n(this.widget, r, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return oy;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : je.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof _n && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, r) {
    return this.widget.coordsAt(this.dom, e, r);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: r, endSide: i } = this.deco;
    return r == i ? !1 : e < 0 ? r < 0 : i > 0;
  }
}
class Zi {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, r) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, r, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Jt = /* @__PURE__ */ function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
}(Jt || (Jt = {}));
class xe extends ks {
  constructor(e, r, i, n) {
    super(), this.startSide = e, this.endSide = r, this.widget = i, this.spec = n;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Yl(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let r = Math.max(-1e4, Math.min(1e4, e.side || 0)), i = !!e.block;
    return r += i && !e.inlineOrder ? r > 0 ? 3e8 : -4e8 : r > 0 ? 1e8 : -1e8, new Yn(e, r, r, i, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let r = !!e.block, i, n;
    if (e.isBlockGap)
      i = -5e8, n = 4e8;
    else {
      let { start: s, end: a } = uC(e, r);
      i = (s ? r ? -3e8 : -1 : 5e8) - 1, n = (a ? r ? 2e8 : 1 : -6e8) + 1;
    }
    return new Yn(e, i, n, r, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Ul(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, r = !1) {
    return Me.of(e, r);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
xe.none = Me.empty;
class Yl extends xe {
  constructor(e) {
    let { start: r, end: i } = uC(e);
    super(r ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var r, i;
    return this == e || e instanceof Yl && this.tagName == e.tagName && (this.class || ((r = this.attrs) === null || r === void 0 ? void 0 : r.class)) == (e.class || ((i = e.attrs) === null || i === void 0 ? void 0 : i.class)) && ly(this.attrs, e.attrs, "class");
  }
  range(e, r = e) {
    if (e >= r)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, r);
  }
}
Yl.prototype.point = !1;
class Ul extends xe {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Ul && this.spec.class == e.spec.class && ly(this.spec.attributes, e.spec.attributes);
  }
  range(e, r = e) {
    if (r != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, r);
  }
}
Ul.prototype.mapMode = Pt.TrackBefore;
Ul.prototype.point = !0;
class Yn extends xe {
  constructor(e, r, i, n, s, a) {
    super(r, i, s, e), this.block = n, this.isReplace = a, this.mapMode = n ? r <= 0 ? Pt.TrackBefore : Pt.TrackAfter : Pt.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Jt.WidgetRange : this.startSide <= 0 ? Jt.WidgetBefore : Jt.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Yn && Ej(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, r = e) {
    if (this.isReplace && (e > r || e == r && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && r != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, r);
  }
}
Yn.prototype.point = !0;
function uC(t, e = !1) {
  let { inclusiveStart: r, inclusiveEnd: i } = t;
  return r == null && (r = t.inclusive), i == null && (i = t.inclusive), { start: r ?? e, end: i ?? e };
}
function Ej(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function Wf(t, e, r, i = 0) {
  let n = r.length - 1;
  n >= 0 && r[n] + i >= t ? r[n] = Math.max(r[n], e) : r.push(t, e);
}
class el {
  constructor(e, r, i, n) {
    this.doc = e, this.pos = r, this.end = i, this.disallowBlockEffectsFor = n, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = r;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof _n && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new xt()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Iu(new Qa(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof _n) && this.getLine();
  }
  buildText(e, r, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: a, done: o } = this.cursor.next(this.skip);
        if (this.skip = 0, o)
          throw new Error("Ran out of text content when drawing inline views");
        if (a) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let n = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(r.slice(r.length - i)), this.getLine().append(Iu(new rn(this.text.slice(this.textOff, this.textOff + n)), r), i), this.atCursorPos = !0, this.textOff += n, e -= n, i = 0;
    }
  }
  span(e, r, i, n) {
    this.buildText(r - e, i, n), this.pos = r, this.openStart < 0 && (this.openStart = n);
  }
  point(e, r, i, n, s, a) {
    if (this.disallowBlockEffectsFor[a] && i instanceof Yn) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (r > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let o = r - e;
    if (i instanceof Yn)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new _n(i.widget || new d1("div"), o, i));
      else {
        let u = $n.create(i.widget || new d1("span"), o, o ? 0 : i.startSide), c = this.atCursorPos && !u.isEditable && s <= n.length && (e < r || i.startSide > 0), h = !u.isEditable && (e < r || s > n.length || i.startSide <= 0), d = this.getLine();
        this.pendingBuffer == 2 && !c && !u.isEditable && (this.pendingBuffer = 0), this.flushBuffer(n), c && (d.append(Iu(new Qa(1), n), s), s = n.length + Math.max(0, s - n.length)), d.append(Iu(u, n), s), this.atCursorPos = h, this.pendingBuffer = h ? e < r || s > n.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = n.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    o && (this.textOff + o <= this.text.length ? this.textOff += o : (this.skip += o - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = r), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, r, i, n, s) {
    let a = new el(e, r, i, s);
    return a.openEnd = Me.spans(n, r, i, a), a.openStart < 0 && (a.openStart = a.openEnd), a.finish(a.openEnd), a;
  }
}
function Iu(t, e) {
  for (let r of e)
    t = new nn(r, [t], t.length);
  return t;
}
class d1 extends Zi {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
var it = /* @__PURE__ */ function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
}(it || (it = {}));
const Ps = it.LTR, uy = it.RTL;
function cC(t) {
  let e = [];
  for (let r = 0; r < t.length; r++)
    e.push(1 << +t[r]);
  return e;
}
const kj = /* @__PURE__ */ cC("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), Tj = /* @__PURE__ */ cC("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), qf = /* @__PURE__ */ Object.create(null), gi = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), r = /* @__PURE__ */ t.charCodeAt(1);
  qf[e] = r, qf[r] = -e;
}
function hC(t) {
  return t <= 247 ? kj[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? Tj[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const Pj = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Bn {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? uy : Ps;
  }
  /**
  @internal
  */
  constructor(e, r, i) {
    this.from = e, this.to = r, this.level = i;
  }
  /**
  @internal
  */
  side(e, r) {
    return this.dir == r == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, r) {
    return e == (this.dir == r);
  }
  /**
  @internal
  */
  static find(e, r, i, n) {
    let s = -1;
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      if (o.from <= r && o.to >= r) {
        if (o.level == i)
          return a;
        (s < 0 || (n != 0 ? n < 0 ? o.from < r : o.to > r : e[s].level > o.level)) && (s = a);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function pC(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++) {
    let i = t[r], n = e[r];
    if (i.from != n.from || i.to != n.to || i.direction != n.direction || !pC(i.inner, n.inner))
      return !1;
  }
  return !0;
}
const Ge = [];
function Fj(t, e, r, i, n) {
  for (let s = 0; s <= i.length; s++) {
    let a = s ? i[s - 1].to : e, o = s < i.length ? i[s].from : r, u = s ? 256 : n;
    for (let c = a, h = u, d = u; c < o; c++) {
      let m = hC(t.charCodeAt(c));
      m == 512 ? m = h : m == 8 && d == 4 && (m = 16), Ge[c] = m == 4 ? 2 : m, m & 7 && (d = m), h = m;
    }
    for (let c = a, h = u, d = u; c < o; c++) {
      let m = Ge[c];
      if (m == 128)
        c < o - 1 && h == Ge[c + 1] && h & 24 ? m = Ge[c] = h : Ge[c] = 256;
      else if (m == 64) {
        let y = c + 1;
        for (; y < o && Ge[y] == 64; )
          y++;
        let O = c && h == 8 || y < r && Ge[y] == 8 ? d == 1 ? 1 : 8 : 256;
        for (let b = c; b < y; b++)
          Ge[b] = O;
        c = y - 1;
      } else
        m == 8 && d == 1 && (Ge[c] = 1);
      h = m, m & 7 && (d = m);
    }
  }
}
function $j(t, e, r, i, n) {
  let s = n == 1 ? 2 : 1;
  for (let a = 0, o = 0, u = 0; a <= i.length; a++) {
    let c = a ? i[a - 1].to : e, h = a < i.length ? i[a].from : r;
    for (let d = c, m, y, O; d < h; d++)
      if (y = qf[m = t.charCodeAt(d)])
        if (y < 0) {
          for (let b = o - 3; b >= 0; b -= 3)
            if (gi[b + 1] == -y) {
              let v = gi[b + 2], S = v & 2 ? n : v & 4 ? v & 1 ? s : n : 0;
              S && (Ge[d] = Ge[gi[b]] = S), o = b;
              break;
            }
        } else {
          if (gi.length == 189)
            break;
          gi[o++] = d, gi[o++] = m, gi[o++] = u;
        }
      else if ((O = Ge[d]) == 2 || O == 1) {
        let b = O == n;
        u = b ? 0 : 1;
        for (let v = o - 3; v >= 0; v -= 3) {
          let S = gi[v + 2];
          if (S & 2)
            break;
          if (b)
            gi[v + 2] |= 2;
          else {
            if (S & 4)
              break;
            gi[v + 2] |= 4;
          }
        }
      }
  }
}
function Bj(t, e, r, i) {
  for (let n = 0, s = i; n <= r.length; n++) {
    let a = n ? r[n - 1].to : t, o = n < r.length ? r[n].from : e;
    for (let u = a; u < o; ) {
      let c = Ge[u];
      if (c == 256) {
        let h = u + 1;
        for (; ; )
          if (h == o) {
            if (n == r.length)
              break;
            h = r[n++].to, o = n < r.length ? r[n].from : e;
          } else if (Ge[h] == 256)
            h++;
          else
            break;
        let d = s == 1, m = (h < e ? Ge[h] : i) == 1, y = d == m ? d ? 1 : 2 : i;
        for (let O = h, b = n, v = b ? r[b - 1].to : t; O > u; )
          O == v && (O = r[--b].from, v = b ? r[b - 1].to : t), Ge[--O] = y;
        u = h;
      } else
        s = c, u++;
    }
  }
}
function Xf(t, e, r, i, n, s, a) {
  let o = i % 2 ? 2 : 1;
  if (i % 2 == n % 2)
    for (let u = e, c = 0; u < r; ) {
      let h = !0, d = !1;
      if (c == s.length || u < s[c].from) {
        let b = Ge[u];
        b != o && (h = !1, d = b == 16);
      }
      let m = !h && o == 1 ? [] : null, y = h ? i : i + 1, O = u;
      e:
        for (; ; )
          if (c < s.length && O == s[c].from) {
            if (d)
              break e;
            let b = s[c];
            if (!h)
              for (let v = b.to, S = c + 1; ; ) {
                if (v == r)
                  break e;
                if (S < s.length && s[S].from == v)
                  v = s[S++].to;
                else {
                  if (Ge[v] == o)
                    break e;
                  break;
                }
              }
            if (c++, m)
              m.push(b);
            else {
              b.from > u && a.push(new Bn(u, b.from, y));
              let v = b.direction == Ps != !(y % 2);
              Vf(t, v ? i + 1 : i, n, b.inner, b.from, b.to, a), u = b.to;
            }
            O = b.to;
          } else {
            if (O == r || (h ? Ge[O] != o : Ge[O] == o))
              break;
            O++;
          }
      m ? Xf(t, u, O, i + 1, n, m, a) : u < O && a.push(new Bn(u, O, y)), u = O;
    }
  else
    for (let u = r, c = s.length; u > e; ) {
      let h = !0, d = !1;
      if (!c || u > s[c - 1].to) {
        let b = Ge[u - 1];
        b != o && (h = !1, d = b == 16);
      }
      let m = !h && o == 1 ? [] : null, y = h ? i : i + 1, O = u;
      e:
        for (; ; )
          if (c && O == s[c - 1].to) {
            if (d)
              break e;
            let b = s[--c];
            if (!h)
              for (let v = b.from, S = c; ; ) {
                if (v == e)
                  break e;
                if (S && s[S - 1].to == v)
                  v = s[--S].from;
                else {
                  if (Ge[v - 1] == o)
                    break e;
                  break;
                }
              }
            if (m)
              m.push(b);
            else {
              b.to < u && a.push(new Bn(b.to, u, y));
              let v = b.direction == Ps != !(y % 2);
              Vf(t, v ? i + 1 : i, n, b.inner, b.from, b.to, a), u = b.from;
            }
            O = b.from;
          } else {
            if (O == e || (h ? Ge[O - 1] != o : Ge[O - 1] == o))
              break;
            O--;
          }
      m ? Xf(t, O, u, i + 1, n, m, a) : O < u && a.push(new Bn(O, u, y)), u = O;
    }
}
function Vf(t, e, r, i, n, s, a) {
  let o = e % 2 ? 2 : 1;
  Fj(t, n, s, i, o), $j(t, n, s, i, o), Bj(n, s, i, o), Xf(t, n, s, e, r, i, a);
}
function Ij(t, e, r) {
  if (!t)
    return [new Bn(0, 0, e == uy ? 1 : 0)];
  if (e == Ps && !r.length && !Pj.test(t))
    return dC(t.length);
  if (r.length)
    for (; t.length > Ge.length; )
      Ge[Ge.length] = 256;
  let i = [], n = e == Ps ? 0 : 1;
  return Vf(t, n, n, r, 0, t.length, i), i;
}
function dC(t) {
  return [new Bn(0, t, 0)];
}
let fC = "";
function Nj(t, e, r, i, n) {
  var s;
  let a = i.head - t.from, o = Bn.find(e, a, (s = i.bidiLevel) !== null && s !== void 0 ? s : -1, i.assoc), u = e[o], c = u.side(n, r);
  if (a == c) {
    let m = o += n ? 1 : -1;
    if (m < 0 || m >= e.length)
      return null;
    u = e[o = m], a = u.side(!n, r), c = u.side(n, r);
  }
  let h = $t(t.text, a, u.forward(n, r));
  (h < u.from || h > u.to) && (h = c), fC = t.text.slice(Math.min(a, h), Math.max(a, h));
  let d = o == (n ? e.length - 1 : 0) ? null : e[o + (n ? 1 : -1)];
  return d && h == c && d.level + (n ? 0 : 1) < u.level ? U.cursor(d.side(!n, r) + t.from, d.forward(n, r) ? 1 : -1, d.level) : U.cursor(h + t.from, u.forward(n, r) ? -1 : 1, u.level);
}
function _j(t, e, r) {
  for (let i = e; i < r; i++) {
    let n = hC(t.charCodeAt(i));
    if (n == 1)
      return Ps;
    if (n == 2 || n == 4)
      return uy;
  }
  return Ps;
}
const mC = /* @__PURE__ */ fe.define(), gC = /* @__PURE__ */ fe.define(), yC = /* @__PURE__ */ fe.define(), OC = /* @__PURE__ */ fe.define(), Yf = /* @__PURE__ */ fe.define(), xC = /* @__PURE__ */ fe.define(), bC = /* @__PURE__ */ fe.define(), DC = /* @__PURE__ */ fe.define({
  combine: (t) => t.some((e) => e)
}), vC = /* @__PURE__ */ fe.define({
  combine: (t) => t.some((e) => e)
});
class Sa {
  constructor(e, r = "nearest", i = "nearest", n = 5, s = 5, a = !1) {
    this.range = e, this.y = r, this.x = i, this.yMargin = n, this.xMargin = s, this.isSnapshot = a;
  }
  map(e) {
    return e.empty ? this : new Sa(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Sa(U.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Nu = /* @__PURE__ */ we.define({ map: (t, e) => t.map(e) });
function Mr(t, e, r) {
  let i = t.facet(OC);
  i.length ? i[0](e) : window.onerror ? window.onerror(String(e), r, void 0, void 0, e) : r ? console.error(r + ":", e) : console.error(e);
}
const sp = /* @__PURE__ */ fe.define({ combine: (t) => t.length ? t[0] : !0 });
let Qj = 0;
const Io = /* @__PURE__ */ fe.define();
class ft {
  constructor(e, r, i, n, s) {
    this.id = e, this.create = r, this.domEventHandlers = i, this.domEventObservers = n, this.extension = s(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, r) {
    const { eventHandlers: i, eventObservers: n, provide: s, decorations: a } = r || {};
    return new ft(Qj++, e, i, n, (o) => {
      let u = [Io.of(o)];
      return a && u.push(gl.of((c) => {
        let h = c.plugin(o);
        return h ? a(h) : xe.none;
      })), s && u.push(s(o)), u;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, r) {
    return ft.define((i) => new e(i), r);
  }
}
class sd {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let r = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(r);
          } catch (i) {
            if (Mr(r.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (r) {
        Mr(e.state, r, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var r;
    if (!((r = this.value) === null || r === void 0) && r.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        Mr(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const SC = /* @__PURE__ */ fe.define(), cy = /* @__PURE__ */ fe.define(), gl = /* @__PURE__ */ fe.define(), wC = /* @__PURE__ */ fe.define(), hy = /* @__PURE__ */ fe.define(), CC = /* @__PURE__ */ fe.define();
function f1(t, e) {
  let r = t.state.facet(CC);
  if (!r.length)
    return r;
  let i = r.map((s) => s instanceof Function ? s(t) : s), n = [];
  return Me.spans(i, e.from, e.to, {
    point() {
    },
    span(s, a, o, u) {
      let c = s - e.from, h = a - e.from, d = n;
      for (let m = o.length - 1; m >= 0; m--, u--) {
        let y = o[m].spec.bidiIsolate, O;
        if (y == null && (y = _j(e.text, c, h)), u > 0 && d.length && (O = d[d.length - 1]).to == c && O.direction == y)
          O.to = h, d = O.inner;
        else {
          let b = { from: c, to: h, direction: y, inner: [] };
          d.push(b), d = b.inner;
        }
      }
    }
  }), n;
}
const AC = /* @__PURE__ */ fe.define();
function EC(t) {
  let e = 0, r = 0, i = 0, n = 0;
  for (let s of t.state.facet(AC)) {
    let a = s(t);
    a && (a.left != null && (e = Math.max(e, a.left)), a.right != null && (r = Math.max(r, a.right)), a.top != null && (i = Math.max(i, a.top)), a.bottom != null && (n = Math.max(n, a.bottom)));
  }
  return { left: e, right: r, top: i, bottom: n };
}
const No = /* @__PURE__ */ fe.define();
class Lr {
  constructor(e, r, i, n) {
    this.fromA = e, this.toA = r, this.fromB = i, this.toB = n;
  }
  join(e) {
    return new Lr(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let r = e.length, i = this;
    for (; r > 0; r--) {
      let n = e[r - 1];
      if (!(n.fromA > i.toA)) {
        if (n.toA < i.fromA)
          break;
        i = i.join(n), e.splice(r - 1, 1);
      }
    }
    return e.splice(r, 0, i), e;
  }
  static extendWithRanges(e, r) {
    if (r.length == 0)
      return e;
    let i = [];
    for (let n = 0, s = 0, a = 0, o = 0; ; n++) {
      let u = n == e.length ? null : e[n], c = a - o, h = u ? u.fromB : 1e9;
      for (; s < r.length && r[s] < h; ) {
        let d = r[s], m = r[s + 1], y = Math.max(o, d), O = Math.min(h, m);
        if (y <= O && new Lr(y + c, O + c, y, O).addToSet(i), m > h)
          break;
        s += 2;
      }
      if (!u)
        return i;
      new Lr(u.fromA, u.toA, u.fromB, u.toB).addToSet(i), a = u.toA, o = u.toB;
    }
  }
}
class Rc {
  constructor(e, r, i) {
    this.view = e, this.state = r, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = bt.empty(this.startState.doc.length);
    for (let s of i)
      this.changes = this.changes.compose(s.changes);
    let n = [];
    this.changes.iterChangedRanges((s, a, o, u) => n.push(new Lr(s, a, o, u))), this.changedRanges = n;
  }
  /**
  @internal
  */
  static create(e, r, i) {
    return new Rc(e, r, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class m1 extends rt {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new xt()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Lr(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var r;
    let i = e.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: c, toA: h }) => h < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let n = -1;
    this.view.inputState.composing >= 0 && (!((r = this.domChanged) === null || r === void 0) && r.newSel ? n = this.domChanged.newSel.head : !qj(e.changes, this.hasComposition) && !e.selectionSet && (n = e.state.selection.main.head));
    let s = n > -1 ? Lj(this.view, e.changes, n) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: h } = this.hasComposition;
      i = new Lr(c, h, e.changes.mapPos(c, -1), e.changes.mapPos(h, 1)).addToSet(i.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (ge.ie || ge.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let a = this.decorations, o = this.updateDeco(), u = Zj(a, o, e.changes);
    return i = Lr.extendWithRanges(i, u), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, r, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, r, i);
    let { observer: n } = this.view;
    n.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let a = ge.chrome || ge.ios ? { node: n.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, a), this.flags &= -8, a && (a.written || n.selectionRange.focusNode != a.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (a) => a.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let a of this.children)
        a instanceof _n && a.widget instanceof g1 && s.push(a.dom);
    n.updateGaps(s);
  }
  updateChildren(e, r, i) {
    let n = i ? i.range.addToSet(e.slice()) : e, s = this.childCursor(r);
    for (let a = n.length - 1; ; a--) {
      let o = a >= 0 ? n[a] : null;
      if (!o)
        break;
      let { fromA: u, toA: c, fromB: h, toB: d } = o, m, y, O, b;
      if (i && i.range.fromB < d && i.range.toB > h) {
        let k = el.build(this.view.state.doc, h, i.range.fromB, this.decorations, this.dynamicDecorationMap), C = el.build(this.view.state.doc, i.range.toB, d, this.decorations, this.dynamicDecorationMap);
        y = k.breakAtStart, O = k.openStart, b = C.openEnd;
        let E = this.compositionView(i);
        C.breakAtStart ? E.breakAfter = 1 : C.content.length && E.merge(E.length, E.length, C.content[0], !1, C.openStart, 0) && (E.breakAfter = C.content[0].breakAfter, C.content.shift()), k.content.length && E.merge(0, 0, k.content[k.content.length - 1], !0, 0, k.openEnd) && k.content.pop(), m = k.content.concat(E).concat(C.content);
      } else
        ({ content: m, breakAtStart: y, openStart: O, openEnd: b } = el.build(this.view.state.doc, h, d, this.decorations, this.dynamicDecorationMap));
      let { i: v, off: S } = s.findPos(c, 1), { i: x, off: w } = s.findPos(u, -1);
      rC(this, x, w, v, S, m, y, O, b);
    }
    i && this.fixCompositionDOM(i);
  }
  compositionView(e) {
    let r = new rn(e.text.nodeValue);
    r.flags |= 8;
    for (let { deco: n } of e.marks)
      r = new nn(n, [r], r.length);
    let i = new xt();
    return i.append(r, 0), i;
  }
  fixCompositionDOM(e) {
    let r = (s, a) => {
      a.flags |= 8 | (a.children.some(
        (u) => u.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(a);
      let o = rt.get(s);
      o && o != a && (o.dom = null), a.setDOM(s);
    }, i = this.childPos(e.range.fromB, 1), n = this.children[i.i];
    r(e.line, n);
    for (let s = e.marks.length - 1; s >= -1; s--)
      i = n.childPos(i.off, 1), n = n.children[i.i], r(s >= 0 ? e.marks[s].node : e.text, n);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, r = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, n = i == this.dom, s = !n && pc(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(n || r || s))
      return;
    let a = this.forceSelection;
    this.forceSelection = !1;
    let o = this.view.state.selection.main, u = this.moveToLine(this.domAtPos(o.anchor)), c = o.empty ? u : this.moveToLine(this.domAtPos(o.head));
    if (ge.gecko && o.empty && !this.hasComposition && Mj(u)) {
      let d = document.createTextNode("");
      this.view.observer.ignore(() => u.node.insertBefore(d, u.node.childNodes[u.offset] || null)), u = c = new Wt(d, 0), a = !0;
    }
    let h = this.view.observer.selectionRange;
    (a || !h.focusNode || (!Ko(u.node, u.offset, h.anchorNode, h.anchorOffset) || !Ko(c.node, c.offset, h.focusNode, h.focusOffset)) && !this.suppressWidgetCursorChange(h, o)) && (this.view.observer.ignore(() => {
      ge.android && ge.chrome && this.dom.contains(h.focusNode) && Wj(h.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let d = Lc(this.view.root);
      if (d)
        if (o.empty) {
          if (ge.gecko) {
            let m = Rj(u.node, u.offset);
            if (m && m != 3) {
              let y = TC(u.node, u.offset, m == 1 ? 1 : -1);
              y && (u = new Wt(y.node, y.offset));
            }
          }
          d.collapse(u.node, u.offset), o.bidiLevel != null && d.caretBidiLevel !== void 0 && (d.caretBidiLevel = o.bidiLevel);
        } else if (d.extend) {
          d.collapse(u.node, u.offset);
          try {
            d.extend(c.node, c.offset);
          } catch {
          }
        } else {
          let m = document.createRange();
          o.anchor > o.head && ([u, c] = [c, u]), m.setEnd(c.node, c.offset), m.setStart(u.node, u.offset), d.removeAllRanges(), d.addRange(m);
        }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(u, c)), this.impreciseAnchor = u.precise ? null : new Wt(h.anchorNode, h.anchorOffset), this.impreciseHead = c.precise ? null : new Wt(h.focusNode, h.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, r) {
    return this.hasComposition && r.empty && Ko(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == r.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, r = e.state.selection.main, i = Lc(e.root), { anchorNode: n, anchorOffset: s } = e.observer.selectionRange;
    if (!i || !r.empty || !r.assoc || !i.modify)
      return;
    let a = xt.find(this, r.head);
    if (!a)
      return;
    let o = a.posAtStart;
    if (r.head == o || r.head == o + a.length)
      return;
    let u = this.coordsAt(r.head, -1), c = this.coordsAt(r.head, 1);
    if (!u || !c || u.bottom > c.top)
      return;
    let h = this.domAtPos(r.head + r.assoc);
    i.collapse(h.node, h.offset), i.modify("move", r.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let d = e.observer.selectionRange;
    e.docView.posFromDOM(d.anchorNode, d.anchorOffset) != r.from && i.collapse(n, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let r = this.dom, i;
    if (e.node != r)
      return e;
    for (let n = e.offset; !i && n < r.childNodes.length; n++) {
      let s = rt.get(r.childNodes[n]);
      s instanceof xt && (i = s.domAtPos(0));
    }
    for (let n = e.offset - 1; !i && n >= 0; n--) {
      let s = rt.get(r.childNodes[n]);
      s instanceof xt && (i = s.domAtPos(s.length));
    }
    return i ? new Wt(i.node, i.offset, !0) : e;
  }
  nearest(e) {
    for (let r = e; r; ) {
      let i = rt.get(r);
      if (i && i.rootView == this)
        return i;
      r = r.parentNode;
    }
    return null;
  }
  posFromDOM(e, r) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, r) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: r, off: i } = this.childCursor().findPos(e, -1);
    for (; r < this.children.length - 1; ) {
      let n = this.children[r];
      if (i < n.length || n instanceof xt)
        break;
      r++, i = 0;
    }
    return this.children[r].domAtPos(i);
  }
  coordsAt(e, r) {
    let i = null, n = 0;
    for (let s = this.length, a = this.children.length - 1; a >= 0; a--) {
      let o = this.children[a], u = s - o.breakAfter, c = u - o.length;
      if (u < e)
        break;
      c <= e && (c < e || o.covers(-1)) && (u > e || o.covers(1)) && (!i || o instanceof xt && !(i instanceof xt && r >= 0)) && (i = o, n = c), s = c;
    }
    return i ? i.coordsAt(e - n, r) : null;
  }
  coordsForChar(e) {
    let { i: r, off: i } = this.childPos(e, 1), n = this.children[r];
    if (!(n instanceof xt))
      return null;
    for (; n.children.length; ) {
      let { i: o, off: u } = n.childPos(i, 1);
      for (; ; o++) {
        if (o == n.children.length)
          return null;
        if ((n = n.children[o]).length)
          break;
      }
      i = u;
    }
    if (!(n instanceof rn))
      return null;
    let s = $t(n.text, i);
    if (s == i)
      return null;
    let a = Ts(n.dom, i, s).getClientRects();
    for (let o = 0; o < a.length; o++) {
      let u = a[o];
      if (o == a.length - 1 || u.top < u.bottom && u.left < u.right)
        return u;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let r = [], { from: i, to: n } = e, s = this.view.contentDOM.clientWidth, a = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, o = -1, u = this.view.textDirection == it.LTR;
    for (let c = 0, h = 0; h < this.children.length; h++) {
      let d = this.children[h], m = c + d.length;
      if (m > n)
        break;
      if (c >= i) {
        let y = d.dom.getBoundingClientRect();
        if (r.push(y.height), a) {
          let O = d.dom.lastChild, b = O ? _a(O) : [];
          if (b.length) {
            let v = b[b.length - 1], S = u ? v.right - y.left : y.right - v.left;
            S > o && (o = S, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = m);
          }
        }
      }
      c = m + d.breakAfter;
    }
    return r;
  }
  textDirectionAt(e) {
    let { i: r } = this.childPos(e, 1);
    return getComputedStyle(this.children[r].dom).direction == "rtl" ? it.RTL : it.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof xt) {
        let a = s.measureTextSize();
        if (a)
          return a;
      }
    let e = document.createElement("div"), r, i, n;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = _a(e.firstChild)[0];
      r = e.getBoundingClientRect().height, i = s ? s.width / 27 : 7, n = s ? s.height : r, e.remove();
    }), { lineHeight: r, charWidth: i, textHeight: n };
  }
  childCursor(e = this.length) {
    let r = this.children.length;
    return r && (e -= this.children[--r].length), new tC(this.children, e, r);
  }
  computeBlockGapDeco() {
    let e = [], r = this.view.viewState;
    for (let i = 0, n = 0; ; n++) {
      let s = n == r.viewports.length ? null : r.viewports[n], a = s ? s.from - 1 : this.length;
      if (a > i) {
        let o = (r.lineBlockAt(a).bottom - r.lineBlockAt(i).top) / this.view.scaleY;
        e.push(xe.replace({
          widget: new g1(o),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, a));
      }
      if (!s)
        break;
      i = s.to + 1;
    }
    return xe.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(gl).map((n, s) => (this.dynamicDecorationMap[s] = typeof n == "function") ? n(this.view) : n), r = !1, i = this.view.state.facet(wC).map((n, s) => {
      let a = typeof n == "function";
      return a && (r = !0), a ? n(this.view) : n;
    });
    i.length && (this.dynamicDecorationMap[e.length] = r, e.push(Me.join(i)));
    for (let n = e.length; n < e.length + 3; n++)
      this.dynamicDecorationMap[n] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    let { range: r } = e, i = this.coordsAt(r.head, r.empty ? r.assoc : r.head > r.anchor ? -1 : 1), n;
    if (!i)
      return;
    !r.empty && (n = this.coordsAt(r.anchor, r.anchor > r.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, n.left),
      top: Math.min(i.top, n.top),
      right: Math.max(i.right, n.right),
      bottom: Math.max(i.bottom, n.bottom)
    });
    let s = EC(this.view), a = {
      left: i.left - s.left,
      top: i.top - s.top,
      right: i.right + s.right,
      bottom: i.bottom + s.bottom
    }, { offsetWidth: o, offsetHeight: u } = this.view.scrollDOM;
    Oj(this.view.scrollDOM, a, r.head < r.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, o), -o), Math.max(Math.min(e.yMargin, u), -u), this.view.textDirection == it.LTR);
  }
}
function Mj(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
class g1 extends Zi {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
function kC(t, e) {
  let r = t.observer.selectionRange, i = r.focusNode && TC(r.focusNode, r.focusOffset, 0);
  if (!i)
    return null;
  let n = e - i.offset;
  return { from: n, to: n + i.node.nodeValue.length, node: i.node };
}
function Lj(t, e, r) {
  let i = kC(t, r);
  if (!i)
    return null;
  let { node: n, from: s, to: a } = i, o = n.nodeValue;
  if (/[\n\r]/.test(o) || t.state.doc.sliceString(i.from, i.to) != o)
    return null;
  let u = e.invertedDesc, c = new Lr(u.mapPos(s), u.mapPos(a), s, a), h = [];
  for (let d = n.parentNode; ; d = d.parentNode) {
    let m = rt.get(d);
    if (m instanceof nn)
      h.push({ node: d, deco: m.mark });
    else {
      if (m instanceof xt || d.nodeName == "DIV" && d.parentNode == t.contentDOM)
        return { range: c, text: n, marks: h, line: d };
      if (d != t.contentDOM)
        h.push({ node: d, deco: new Yl({
          inclusive: !0,
          attributes: Aj(d),
          tagName: d.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function TC(t, e, r) {
  if (r <= 0)
    for (let i = t, n = e; ; ) {
      if (i.nodeType == 3)
        return { node: i, offset: n };
      if (i.nodeType == 1 && n > 0)
        i = i.childNodes[n - 1], n = tn(i);
      else
        break;
    }
  if (r >= 0)
    for (let i = t, n = e; ; ) {
      if (i.nodeType == 3)
        return { node: i, offset: n };
      if (i.nodeType == 1 && n < i.childNodes.length && r >= 0)
        i = i.childNodes[n], n = 0;
      else
        break;
    }
  return null;
}
function Rj(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let jj = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, r) {
    Wf(e, r, this.changes);
  }
  comparePoint(e, r) {
    Wf(e, r, this.changes);
  }
};
function Zj(t, e, r) {
  let i = new jj();
  return Me.compare(t, e, r, i), i.changes;
}
function Wj(t, e) {
  for (let r = t; r && r != e; r = r.assignedSlot || r.parentNode)
    if (r.nodeType == 1 && r.contentEditable == "false")
      return !0;
  return !1;
}
function qj(t, e) {
  let r = !1;
  return e && t.iterChangedRanges((i, n) => {
    i < e.to && n > e.from && (r = !0);
  }), r;
}
function Xj(t, e, r = 1) {
  let i = t.charCategorizer(e), n = t.doc.lineAt(e), s = e - n.from;
  if (n.length == 0)
    return U.cursor(e);
  s == 0 ? r = 1 : s == n.length && (r = -1);
  let a = s, o = s;
  r < 0 ? a = $t(n.text, s, !1) : o = $t(n.text, s);
  let u = i(n.text.slice(a, o));
  for (; a > 0; ) {
    let c = $t(n.text, a, !1);
    if (i(n.text.slice(c, a)) != u)
      break;
    a = c;
  }
  for (; o < n.length; ) {
    let c = $t(n.text, o);
    if (i(n.text.slice(o, c)) != u)
      break;
    o = c;
  }
  return U.range(a + n.from, o + n.from);
}
function Vj(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function Yj(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function ad(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function y1(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function O1(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function Uf(t, e, r) {
  let i, n, s, a, o = !1, u, c, h, d;
  for (let O = t.firstChild; O; O = O.nextSibling) {
    let b = _a(O);
    for (let v = 0; v < b.length; v++) {
      let S = b[v];
      n && ad(n, S) && (S = y1(O1(S, n.bottom), n.top));
      let x = Vj(e, S), w = Yj(r, S);
      if (x == 0 && w == 0)
        return O.nodeType == 3 ? x1(O, e, r) : Uf(O, e, r);
      if (!i || a > w || a == w && s > x) {
        i = O, n = S, s = x, a = w;
        let k = w ? r < S.top ? -1 : 1 : x ? e < S.left ? -1 : 1 : 0;
        o = !k || (k > 0 ? v < b.length - 1 : v > 0);
      }
      x == 0 ? r > S.bottom && (!h || h.bottom < S.bottom) ? (u = O, h = S) : r < S.top && (!d || d.top > S.top) && (c = O, d = S) : h && ad(h, S) ? h = O1(h, S.bottom) : d && ad(d, S) && (d = y1(d, S.top));
    }
  }
  if (h && h.bottom >= r ? (i = u, n = h) : d && d.top <= r && (i = c, n = d), !i)
    return { node: t, offset: 0 };
  let m = Math.max(n.left, Math.min(n.right, e));
  if (i.nodeType == 3)
    return x1(i, m, r);
  if (o && i.contentEditable != "false")
    return Uf(i, m, r);
  let y = Array.prototype.indexOf.call(t.childNodes, i) + (e >= (n.left + n.right) / 2 ? 1 : 0);
  return { node: t, offset: y };
}
function x1(t, e, r) {
  let i = t.nodeValue.length, n = -1, s = 1e9, a = 0;
  for (let o = 0; o < i; o++) {
    let u = Ts(t, o, o + 1).getClientRects();
    for (let c = 0; c < u.length; c++) {
      let h = u[c];
      if (h.top == h.bottom)
        continue;
      a || (a = e - h.left);
      let d = (h.top > r ? h.top - r : r - h.bottom) - 1;
      if (h.left - 1 <= e && h.right + 1 >= e && d < s) {
        let m = e >= (h.left + h.right) / 2, y = m;
        if ((ge.chrome || ge.gecko) && Ts(t, o).getBoundingClientRect().left == h.right && (y = !m), d <= 0)
          return { node: t, offset: o + (y ? 1 : 0) };
        n = o + (y ? 1 : 0), s = d;
      }
    }
  }
  return { node: t, offset: n > -1 ? n : a > 0 ? t.nodeValue.length : 0 };
}
function PC(t, e, r, i = -1) {
  var n, s;
  let a = t.contentDOM.getBoundingClientRect(), o = a.top + t.viewState.paddingTop, u, { docHeight: c } = t.viewState, { x: h, y: d } = e, m = d - o;
  if (m < 0)
    return 0;
  if (m > c)
    return t.state.doc.length;
  for (let k = t.viewState.heightOracle.textHeight / 2, C = !1; u = t.elementAtHeight(m), u.type != Jt.Text; )
    for (; m = i > 0 ? u.bottom + k : u.top - k, !(m >= 0 && m <= c); ) {
      if (C)
        return r ? null : 0;
      C = !0, i = -i;
    }
  d = o + m;
  let y = u.from;
  if (y < t.viewport.from)
    return t.viewport.from == 0 ? 0 : r ? null : b1(t, a, u, h, d);
  if (y > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : r ? null : b1(t, a, u, h, d);
  let O = t.dom.ownerDocument, b = t.root.elementFromPoint ? t.root : O, v = b.elementFromPoint(h, d);
  v && !t.contentDOM.contains(v) && (v = null), v || (h = Math.max(a.left + 1, Math.min(a.right - 1, h)), v = b.elementFromPoint(h, d), v && !t.contentDOM.contains(v) && (v = null));
  let S, x = -1;
  if (v && ((n = t.docView.nearest(v)) === null || n === void 0 ? void 0 : n.isEditable) != !1) {
    if (O.caretPositionFromPoint) {
      let k = O.caretPositionFromPoint(h, d);
      k && ({ offsetNode: S, offset: x } = k);
    } else if (O.caretRangeFromPoint) {
      let k = O.caretRangeFromPoint(h, d);
      k && ({ startContainer: S, startOffset: x } = k, (!t.contentDOM.contains(S) || ge.safari && Uj(S, x, h) || ge.chrome && zj(S, x, h)) && (S = void 0));
    }
  }
  if (!S || !t.docView.dom.contains(S)) {
    let k = xt.find(t.docView, y);
    if (!k)
      return m > u.top + u.height / 2 ? u.to : u.from;
    ({ node: S, offset: x } = Uf(k.dom, h, d));
  }
  let w = t.docView.nearest(S);
  if (!w)
    return null;
  if (w.isWidget && ((s = w.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let k = w.dom.getBoundingClientRect();
    return e.y < k.top || e.y <= k.bottom && e.x <= (k.left + k.right) / 2 ? w.posAtStart : w.posAtEnd;
  } else
    return w.localPosFromDOM(S, x) + w.posAtStart;
}
function b1(t, e, r, i, n) {
  let s = Math.round((i - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && r.height > t.defaultLineHeight * 1.5) {
    let o = t.viewState.heightOracle.textHeight, u = Math.floor((n - r.top - (t.defaultLineHeight - o) * 0.5) / o);
    s += u * t.viewState.heightOracle.lineLength;
  }
  let a = t.state.sliceDoc(r.from, r.to);
  return r.from + If(a, s, t.state.tabSize);
}
function Uj(t, e, r) {
  let i;
  if (t.nodeType != 3 || e != (i = t.nodeValue.length))
    return !1;
  for (let n = t.nextSibling; n; n = n.nextSibling)
    if (n.nodeType != 1 || n.nodeName != "BR")
      return !1;
  return Ts(t, i - 1, i).getBoundingClientRect().left > r;
}
function zj(t, e, r) {
  if (e != 0)
    return !1;
  for (let n = t; ; ) {
    let s = n.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != n)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    n = s;
  }
  let i = t.nodeType == 1 ? t.getBoundingClientRect() : Ts(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return r - i.left > 5;
}
function zf(t, e) {
  let r = t.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    for (let i of r.type)
      if (i.to > e || i.to == e && (i.to == r.to || i.type == Jt.Text))
        return i;
  }
  return r;
}
function Gj(t, e, r, i) {
  let n = zf(t, e.head), s = !i || n.type != Jt.Text || !(t.lineWrapping || n.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > n.from ? e.head - 1 : e.head);
  if (s) {
    let a = t.dom.getBoundingClientRect(), o = t.textDirectionAt(n.from), u = t.posAtCoords({
      x: r == (o == it.LTR) ? a.right - 1 : a.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (u != null)
      return U.cursor(u, r ? -1 : 1);
  }
  return U.cursor(r ? n.to : n.from, r ? -1 : 1);
}
function D1(t, e, r, i) {
  let n = t.state.doc.lineAt(e.head), s = t.bidiSpans(n), a = t.textDirectionAt(n.from);
  for (let o = e, u = null; ; ) {
    let c = Nj(n, s, a, o, r), h = fC;
    if (!c) {
      if (n.number == (r ? t.state.doc.lines : 1))
        return o;
      h = `
`, n = t.state.doc.line(n.number + (r ? 1 : -1)), s = t.bidiSpans(n), c = t.visualLineSide(n, !r);
    }
    if (u) {
      if (!u(h))
        return o;
    } else {
      if (!i)
        return c;
      u = i(h);
    }
    o = c;
  }
}
function Hj(t, e, r) {
  let i = t.state.charCategorizer(e), n = i(r);
  return (s) => {
    let a = i(s);
    return n == st.Space && (n = a), n == a;
  };
}
function Jj(t, e, r, i) {
  let n = e.head, s = r ? 1 : -1;
  if (n == (r ? t.state.doc.length : 0))
    return U.cursor(n, e.assoc);
  let a = e.goalColumn, o, u = t.contentDOM.getBoundingClientRect(), c = t.coordsAtPos(n, e.assoc || -1), h = t.documentTop;
  if (c)
    a == null && (a = c.left - u.left), o = s < 0 ? c.top : c.bottom;
  else {
    let y = t.viewState.lineBlockAt(n);
    a == null && (a = Math.min(u.right - u.left, t.defaultCharacterWidth * (n - y.from))), o = (s < 0 ? y.top : y.bottom) + h;
  }
  let d = u.left + a, m = i ?? t.viewState.heightOracle.textHeight >> 1;
  for (let y = 0; ; y += 10) {
    let O = o + (m + y) * s, b = PC(t, { x: d, y: O }, !1, s);
    if (O < u.top || O > u.bottom || (s < 0 ? b < n : b > n)) {
      let v = t.docView.coordsForChar(b), S = !v || O < v.top ? -1 : 1;
      return U.cursor(b, S, void 0, a);
    }
  }
}
function dc(t, e, r) {
  for (; ; ) {
    let i = 0;
    for (let n of t)
      n.between(e - 1, e + 1, (s, a, o) => {
        if (e > s && e < a) {
          let u = i || r || (e - s < a - e ? -1 : 1);
          e = u < 0 ? s : a, i = u;
        }
      });
    if (!i)
      return e;
  }
}
function od(t, e, r) {
  let i = dc(t.state.facet(hy).map((n) => n(t)), r.from, e.head > r.from ? -1 : 1);
  return i == r.from ? r : U.cursor(i, i < r.from ? 1 : -1);
}
class Kj {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, ge.safari && e.contentDOM.addEventListener("input", () => null), ge.gecko && mZ(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !oZ(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, r) {
    let i = this.handlers[e];
    if (i) {
      for (let n of i.observers)
        n(this.view, r);
      for (let n of i.handlers) {
        if (r.defaultPrevented)
          break;
        if (n(this.view, r)) {
          r.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let r = eZ(e), i = this.handlers, n = this.view.contentDOM;
    for (let s in r)
      if (s != "scroll") {
        let a = !r[s].handlers.length, o = i[s];
        o && a != !o.handlers.length && (n.removeEventListener(s, this.handleEvent), o = null), o || n.addEventListener(s, this.handleEvent, { passive: a });
      }
    for (let s in i)
      s != "scroll" && !r[s] && n.removeEventListener(s, this.handleEvent);
    this.handlers = r;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (e.keyCode != 27 && $C.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), ge.android && ge.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let r;
    return ge.ios && !e.synthetic && !e.altKey && !e.metaKey && ((r = FC.find((i) => i.keyCode == e.keyCode)) && !e.ctrlKey || tZ.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = r || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let e = this.pendingIOSKey;
    return e ? (this.pendingIOSKey = void 0, va(this.view.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : ge.safari && !ge.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function v1(t, e) {
  return (r, i) => {
    try {
      return e.call(t, i, r);
    } catch (n) {
      Mr(r.state, n);
    }
  };
}
function eZ(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function r(i) {
    return e[i] || (e[i] = { observers: [], handlers: [] });
  }
  for (let i of t) {
    let n = i.spec;
    if (n && n.domEventHandlers)
      for (let s in n.domEventHandlers) {
        let a = n.domEventHandlers[s];
        a && r(s).handlers.push(v1(i.value, a));
      }
    if (n && n.domEventObservers)
      for (let s in n.domEventObservers) {
        let a = n.domEventObservers[s];
        a && r(s).observers.push(v1(i.value, a));
      }
  }
  for (let i in li)
    r(i).handlers.push(li[i]);
  for (let i in ui)
    r(i).observers.push(ui[i]);
  return e;
}
const FC = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], tZ = "dthko", $C = [16, 17, 18, 20, 91, 92, 224, 225], _u = 6;
function Qu(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function rZ(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class iZ {
  constructor(e, r, i, n) {
    this.view = e, this.startEvent = r, this.style = i, this.mustSelect = n, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = r, this.scrollParent = xj(e.contentDOM), this.atoms = e.state.facet(hy).map((a) => a(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = r.shiftKey, this.multiple = e.state.facet(Ie.allowMultipleSelections) && nZ(e, r), this.dragging = aZ(e, r) && _C(r) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var r;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && rZ(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let i = 0, n = 0, s = ((r = this.scrollParent) === null || r === void 0 ? void 0 : r.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, a = EC(this.view);
    e.clientX - a.left <= s.left + _u ? i = -Qu(s.left - e.clientX) : e.clientX + a.right >= s.right - _u && (i = Qu(e.clientX - s.right)), e.clientY - a.top <= s.top + _u ? n = -Qu(s.top - e.clientY) : e.clientY + a.bottom >= s.bottom - _u && (n = Qu(e.clientY - s.bottom)), this.setScrollSpeed(i, n);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, r) {
    this.scrollSpeed = { x: e, y: r }, e || r ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let r = null;
    for (let i = 0; i < e.ranges.length; i++) {
      let n = e.ranges[i], s = null;
      if (n.empty) {
        let a = dc(this.atoms, n.from, 0);
        a != n.from && (s = U.cursor(a, -1));
      } else {
        let a = dc(this.atoms, n.from, -1), o = dc(this.atoms, n.to, 1);
        (a != n.from || o != n.to) && (s = U.range(n.from == n.anchor ? a : o, n.from == n.head ? a : o));
      }
      s && (r || (r = e.ranges.slice()), r[i] = s);
    }
    return r ? U.create(r, e.mainIndex) : e;
  }
  select(e) {
    let { view: r } = this, i = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !i.eq(r.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function nZ(t, e) {
  let r = t.state.facet(mC);
  return r.length ? r[0](e) : ge.mac ? e.metaKey : e.ctrlKey;
}
function sZ(t, e) {
  let r = t.state.facet(gC);
  return r.length ? r[0](e) : ge.mac ? !e.altKey : !e.ctrlKey;
}
function aZ(t, e) {
  let { main: r } = t.state.selection;
  if (r.empty)
    return !1;
  let i = Lc(t.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let n = i.getRangeAt(0).getClientRects();
  for (let s = 0; s < n.length; s++) {
    let a = n[s];
    if (a.left <= e.clientX && a.right >= e.clientX && a.top <= e.clientY && a.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function oZ(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let r = e.target, i; r != t.contentDOM; r = r.parentNode)
    if (!r || r.nodeType == 11 || (i = rt.get(r)) && i.ignoreEvent(e))
      return !1;
  return !0;
}
const li = /* @__PURE__ */ Object.create(null), ui = /* @__PURE__ */ Object.create(null), BC = ge.ie && ge.ie_version < 15 || ge.ios && ge.webkit_version < 604;
function lZ(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let r = e.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(), setTimeout(() => {
    t.focus(), r.remove(), IC(t, r.value);
  }, 50);
}
function IC(t, e) {
  let { state: r } = t, i, n = 1, s = r.toText(e), a = s.lines == r.selection.ranges.length;
  if (Gf != null && r.selection.ranges.every((u) => u.empty) && Gf == s.toString()) {
    let u = -1;
    i = r.changeByRange((c) => {
      let h = r.doc.lineAt(c.from);
      if (h.from == u)
        return { range: c };
      u = h.from;
      let d = r.toText((a ? s.line(n++).text : e) + r.lineBreak);
      return {
        changes: { from: h.from, insert: d },
        range: U.cursor(c.from + d.length)
      };
    });
  } else
    a ? i = r.changeByRange((u) => {
      let c = s.line(n++);
      return {
        changes: { from: u.from, to: u.to, insert: c.text },
        range: U.cursor(u.from + c.length)
      };
    }) : i = r.replaceSelection(s);
  t.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
ui.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
li.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (t.inputState.lastEscPress = Date.now()), !1);
ui.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
ui.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
li.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let r = null;
  for (let i of t.state.facet(yC))
    if (r = i(t, e), r)
      break;
  if (!r && e.button == 0 && (r = hZ(t, e)), r) {
    let i = !t.hasFocus;
    t.inputState.startMouseSelection(new iZ(t, e, r, i)), i && t.observer.ignore(() => Jw(t.contentDOM));
    let n = t.inputState.mouseSelection;
    if (n)
      return n.start(e), n.dragging === !1;
  }
  return !1;
};
function S1(t, e, r, i) {
  if (i == 1)
    return U.cursor(e, r);
  if (i == 2)
    return Xj(t.state, e, r);
  {
    let n = xt.find(t.docView, e), s = t.state.doc.lineAt(n ? n.posAtEnd : e), a = n ? n.posAtStart : s.from, o = n ? n.posAtEnd : s.to;
    return o < t.state.doc.length && o == s.to && o++, U.range(a, o);
  }
}
let NC = (t, e) => t >= e.top && t <= e.bottom, w1 = (t, e, r) => NC(e, r) && t >= r.left && t <= r.right;
function uZ(t, e, r, i) {
  let n = xt.find(t.docView, e);
  if (!n)
    return 1;
  let s = e - n.posAtStart;
  if (s == 0)
    return 1;
  if (s == n.length)
    return -1;
  let a = n.coordsAt(s, -1);
  if (a && w1(r, i, a))
    return -1;
  let o = n.coordsAt(s, 1);
  return o && w1(r, i, o) ? 1 : a && NC(i, a) ? -1 : 1;
}
function C1(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: r, bias: uZ(t, r, e.clientX, e.clientY) };
}
const cZ = ge.ie && ge.ie_version <= 11;
let A1 = null, E1 = 0, k1 = 0;
function _C(t) {
  if (!cZ)
    return t.detail;
  let e = A1, r = k1;
  return A1 = t, k1 = Date.now(), E1 = !e || r > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (E1 + 1) % 3 : 1;
}
function hZ(t, e) {
  let r = C1(t, e), i = _C(e), n = t.state.selection;
  return {
    update(s) {
      s.docChanged && (r.pos = s.changes.mapPos(r.pos), n = n.map(s.changes));
    },
    get(s, a, o) {
      let u = C1(t, s), c, h = S1(t, u.pos, u.bias, i);
      if (r.pos != u.pos && !a) {
        let d = S1(t, r.pos, r.bias, i), m = Math.min(d.from, h.from), y = Math.max(d.to, h.to);
        h = m < h.from ? U.range(m, y) : U.range(y, m);
      }
      return a ? n.replaceRange(n.main.extend(h.from, h.to)) : o && i == 1 && n.ranges.length > 1 && (c = pZ(n, u.pos)) ? c : o ? n.addRange(h) : U.create([h]);
    }
  };
}
function pZ(t, e) {
  for (let r = 0; r < t.ranges.length; r++) {
    let { from: i, to: n } = t.ranges[r];
    if (i <= e && n >= e)
      return U.create(t.ranges.slice(0, r).concat(t.ranges.slice(r + 1)), t.mainIndex == r ? 0 : t.mainIndex - (t.mainIndex > r ? 1 : 0));
  }
  return null;
}
li.dragstart = (t, e) => {
  let { selection: { main: r } } = t.state;
  if (e.target.draggable) {
    let n = t.docView.nearest(e.target);
    if (n && n.isWidget) {
      let s = n.posAtStart, a = s + n.length;
      (s >= r.to || a <= r.from) && (r = U.range(s, a));
    }
  }
  let { inputState: i } = t;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = r, e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(r.from, r.to)), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
li.dragend = (t) => (t.inputState.draggedContent = null, !1);
function T1(t, e, r, i) {
  if (!r)
    return;
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = t.inputState, a = i && s && sZ(t, e) ? { from: s.from, to: s.to } : null, o = { from: n, insert: r }, u = t.state.changes(a ? [a, o] : o);
  t.focus(), t.dispatch({
    changes: u,
    selection: { anchor: u.mapPos(n, -1), head: u.mapPos(n, 1) },
    userEvent: a ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
li.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let r = e.dataTransfer.files;
  if (r && r.length) {
    let i = Array(r.length), n = 0, s = () => {
      ++n == r.length && T1(t, e, i.filter((a) => a != null).join(t.state.lineBreak), !1);
    };
    for (let a = 0; a < r.length; a++) {
      let o = new FileReader();
      o.onerror = s, o.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(o.result) || (i[a] = o.result), s();
      }, o.readAsText(r[a]);
    }
    return !0;
  } else {
    let i = e.dataTransfer.getData("Text");
    if (i)
      return T1(t, e, i, !0), !0;
  }
  return !1;
};
li.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let r = BC ? null : e.clipboardData;
  return r ? (IC(t, r.getData("text/plain") || r.getData("text/uri-text")), !0) : (lZ(t), !1);
};
function dZ(t, e) {
  let r = t.dom.parentNode;
  if (!r)
    return;
  let i = r.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), t.focus();
  }, 50);
}
function fZ(t) {
  let e = [], r = [], i = !1;
  for (let n of t.selection.ranges)
    n.empty || (e.push(t.sliceDoc(n.from, n.to)), r.push(n));
  if (!e.length) {
    let n = -1;
    for (let { from: s } of t.selection.ranges) {
      let a = t.doc.lineAt(s);
      a.number > n && (e.push(a.text), r.push({ from: a.from, to: Math.min(t.doc.length, a.to + 1) })), n = a.number;
    }
    i = !0;
  }
  return { text: e.join(t.lineBreak), ranges: r, linewise: i };
}
let Gf = null;
li.copy = li.cut = (t, e) => {
  let { text: r, ranges: i, linewise: n } = fZ(t.state);
  if (!r && !n)
    return !1;
  Gf = n ? r : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = BC ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", r), !0) : (dZ(t, r), !1);
};
const QC = /* @__PURE__ */ Ri.define();
function MC(t, e) {
  let r = [];
  for (let i of t.facet(bC)) {
    let n = i(t, e);
    n && r.push(n);
  }
  return r ? t.update({ effects: r, annotations: QC.of(!0) }) : null;
}
function LC(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let r = MC(t.state, e);
      r ? t.dispatch(r) : t.update([]);
    }
  }, 10);
}
ui.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), LC(t);
};
ui.blur = (t) => {
  t.observer.clearSelectionRange(), LC(t);
};
ui.compositionstart = ui.compositionupdate = (t) => {
  t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0);
};
ui.compositionend = (t) => {
  t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, ge.chrome && ge.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50);
};
ui.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
li.beforeinput = (t, e) => {
  var r;
  let i;
  if (ge.chrome && ge.android && (i = FC.find((n) => n.inputType == e.inputType)) && (t.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let n = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > n + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return !1;
};
const P1 = /* @__PURE__ */ new Set();
function mZ(t) {
  P1.has(t) || (P1.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const F1 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class gZ {
  constructor(e) {
    this.lineWrapping = e, this.doc = je.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, r) {
    let i = this.doc.lineAt(r).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((r - e - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return F1.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let r = !1;
    for (let i = 0; i < e.length; i++) {
      let n = e[i];
      n < 0 ? i++ : this.heightSamples[Math.floor(n * 10)] || (r = !0, this.heightSamples[Math.floor(n * 10)] = !0);
    }
    return r;
  }
  refresh(e, r, i, n, s, a) {
    let o = F1.indexOf(e) > -1, u = Math.round(r) != Math.round(this.lineHeight) || this.lineWrapping != o;
    if (this.lineWrapping = o, this.lineHeight = r, this.charWidth = i, this.textHeight = n, this.lineLength = s, u) {
      this.heightSamples = {};
      for (let c = 0; c < a.length; c++) {
        let h = a[c];
        h < 0 ? c++ : this.heightSamples[Math.floor(h * 10)] = !0;
      }
    }
    return u;
  }
}
class yZ {
  constructor(e, r) {
    this.from = e, this.heights = r, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class wi {
  /**
  @internal
  */
  constructor(e, r, i, n, s) {
    this.from = e, this.length = r, this.top = i, this.height = n, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Jt.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Yn ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let r = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new wi(this.from, this.length + e.length, this.top, this.height + e.height, r);
  }
}
var tt = /* @__PURE__ */ function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
}(tt || (tt = {}));
const fc = 1e-3;
class Kt {
  constructor(e, r, i = 2) {
    this.length = e, this.height = r, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, r) {
    this.height != r && (Math.abs(this.height - r) > fc && (e.heightChanged = !0), this.height = r);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, r, i) {
    return Kt.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, r) {
    r.push(this);
  }
  decomposeRight(e, r) {
    r.push(this);
  }
  applyChanges(e, r, i, n) {
    let s = this, a = i.doc;
    for (let o = n.length - 1; o >= 0; o--) {
      let { fromA: u, toA: c, fromB: h, toB: d } = n[o], m = s.lineAt(u, tt.ByPosNoHeight, i.setDoc(r), 0, 0), y = m.to >= c ? m : s.lineAt(c, tt.ByPosNoHeight, i, 0, 0);
      for (d += y.to - c, c = y.to; o > 0 && m.from <= n[o - 1].toA; )
        u = n[o - 1].fromA, h = n[o - 1].fromB, o--, u < m.from && (m = s.lineAt(u, tt.ByPosNoHeight, i, 0, 0));
      h += m.from - u, u = m.from;
      let O = py.build(i.setDoc(a), e, h, d);
      s = s.replace(u, c, O);
    }
    return s.updateHeight(i, 0);
  }
  static empty() {
    return new gr(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let r = 0, i = e.length, n = 0, s = 0;
    for (; ; )
      if (r == i)
        if (n > s * 2) {
          let o = e[r - 1];
          o.break ? e.splice(--r, 1, o.left, null, o.right) : e.splice(--r, 1, o.left, o.right), i += 1 + o.break, n -= o.size;
        } else if (s > n * 2) {
          let o = e[i];
          o.break ? e.splice(i, 1, o.left, null, o.right) : e.splice(i, 1, o.left, o.right), i += 2 + o.break, s -= o.size;
        } else
          break;
      else if (n < s) {
        let o = e[r++];
        o && (n += o.size);
      } else {
        let o = e[--i];
        o && (s += o.size);
      }
    let a = 0;
    return e[r - 1] == null ? (a = 1, r--) : e[r] == null && (a = 1, i++), new OZ(Kt.of(e.slice(0, r)), a, Kt.of(e.slice(i)));
  }
}
Kt.prototype.size = 1;
class RC extends Kt {
  constructor(e, r, i) {
    super(e, r), this.deco = i;
  }
  blockAt(e, r, i, n) {
    return new wi(n, this.length, i, this.height, this.deco || 0);
  }
  lineAt(e, r, i, n, s) {
    return this.blockAt(0, i, n, s);
  }
  forEachLine(e, r, i, n, s, a) {
    e <= s + this.length && r >= s && a(this.blockAt(0, i, n, s));
  }
  updateHeight(e, r = 0, i = !1, n) {
    return n && n.from <= r && n.more && this.setHeight(e, n.heights[n.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class gr extends RC {
  constructor(e, r) {
    super(e, r, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, r, i, n) {
    return new wi(n, this.length, i, this.height, this.breaks);
  }
  replace(e, r, i) {
    let n = i[0];
    return i.length == 1 && (n instanceof gr || n instanceof At && n.flags & 4) && Math.abs(this.length - n.length) < 10 ? (n instanceof At ? n = new gr(n.length, this.height) : n.height = this.height, this.outdated || (n.outdated = !1), n) : Kt.of(i);
  }
  updateHeight(e, r = 0, i = !1, n) {
    return n && n.from <= r && n.more ? this.setHeight(e, n.heights[n.index++]) : (i || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class At extends Kt {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, r) {
    let i = e.doc.lineAt(r).number, n = e.doc.lineAt(r + this.length).number, s = n - i + 1, a, o = 0;
    if (e.lineWrapping) {
      let u = Math.min(this.height, e.lineHeight * s);
      a = u / s, this.length > s + 1 && (o = (this.height - u) / (this.length - s - 1));
    } else
      a = this.height / s;
    return { firstLine: i, lastLine: n, perLine: a, perChar: o };
  }
  blockAt(e, r, i, n) {
    let { firstLine: s, lastLine: a, perLine: o, perChar: u } = this.heightMetrics(r, n);
    if (r.lineWrapping) {
      let c = n + Math.round(Math.max(0, Math.min(1, (e - i) / this.height)) * this.length), h = r.doc.lineAt(c), d = o + h.length * u, m = Math.max(i, e - d / 2);
      return new wi(h.from, h.length, m, d, 0);
    } else {
      let c = Math.max(0, Math.min(a - s, Math.floor((e - i) / o))), { from: h, length: d } = r.doc.line(s + c);
      return new wi(h, d, i + o * c, o, 0);
    }
  }
  lineAt(e, r, i, n, s) {
    if (r == tt.ByHeight)
      return this.blockAt(e, i, n, s);
    if (r == tt.ByPosNoHeight) {
      let { from: y, to: O } = i.doc.lineAt(e);
      return new wi(y, O - y, 0, 0, 0);
    }
    let { firstLine: a, perLine: o, perChar: u } = this.heightMetrics(i, s), c = i.doc.lineAt(e), h = o + c.length * u, d = c.number - a, m = n + o * d + u * (c.from - s - d);
    return new wi(c.from, c.length, Math.max(n, Math.min(m, n + this.height - h)), h, 0);
  }
  forEachLine(e, r, i, n, s, a) {
    e = Math.max(e, s), r = Math.min(r, s + this.length);
    let { firstLine: o, perLine: u, perChar: c } = this.heightMetrics(i, s);
    for (let h = e, d = n; h <= r; ) {
      let m = i.doc.lineAt(h);
      if (h == e) {
        let O = m.number - o;
        d += u * O + c * (e - s - O);
      }
      let y = u + c * m.length;
      a(new wi(m.from, m.length, d, y, 0)), d += y, h = m.to + 1;
    }
  }
  replace(e, r, i) {
    let n = this.length - r;
    if (n > 0) {
      let s = i[i.length - 1];
      s instanceof At ? i[i.length - 1] = new At(s.length + n) : i.push(null, new At(n - 1));
    }
    if (e > 0) {
      let s = i[0];
      s instanceof At ? i[0] = new At(e + s.length) : i.unshift(new At(e - 1), null);
    }
    return Kt.of(i);
  }
  decomposeLeft(e, r) {
    r.push(new At(e - 1), null);
  }
  decomposeRight(e, r) {
    r.push(null, new At(this.length - e - 1));
  }
  updateHeight(e, r = 0, i = !1, n) {
    let s = r + this.length;
    if (n && n.from <= r + this.length && n.more) {
      let a = [], o = Math.max(r, n.from), u = -1;
      for (n.from > r && a.push(new At(n.from - r - 1).updateHeight(e, r)); o <= s && n.more; ) {
        let h = e.doc.lineAt(o).length;
        a.length && a.push(null);
        let d = n.heights[n.index++];
        u == -1 ? u = d : Math.abs(d - u) >= fc && (u = -2);
        let m = new gr(h, d);
        m.outdated = !1, a.push(m), o += h + 1;
      }
      o <= s && a.push(null, new At(s - o).updateHeight(e, o));
      let c = Kt.of(a);
      return (u < 0 || Math.abs(c.height - this.height) >= fc || Math.abs(u - this.heightMetrics(e, r).perLine) >= fc) && (e.heightChanged = !0), c;
    } else
      (i || this.outdated) && (this.setHeight(e, e.heightForGap(r, r + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class OZ extends Kt {
  constructor(e, r, i) {
    super(e.length + r + i.length, e.height + i.height, r | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, r, i, n) {
    let s = i + this.left.height;
    return e < s ? this.left.blockAt(e, r, i, n) : this.right.blockAt(e, r, s, n + this.left.length + this.break);
  }
  lineAt(e, r, i, n, s) {
    let a = n + this.left.height, o = s + this.left.length + this.break, u = r == tt.ByHeight ? e < a : e < o, c = u ? this.left.lineAt(e, r, i, n, s) : this.right.lineAt(e, r, i, a, o);
    if (this.break || (u ? c.to < o : c.from > o))
      return c;
    let h = r == tt.ByPosNoHeight ? tt.ByPosNoHeight : tt.ByPos;
    return u ? c.join(this.right.lineAt(o, h, i, a, o)) : this.left.lineAt(o, h, i, n, s).join(c);
  }
  forEachLine(e, r, i, n, s, a) {
    let o = n + this.left.height, u = s + this.left.length + this.break;
    if (this.break)
      e < u && this.left.forEachLine(e, r, i, n, s, a), r >= u && this.right.forEachLine(e, r, i, o, u, a);
    else {
      let c = this.lineAt(u, tt.ByPos, i, n, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, i, n, s, a), c.to >= e && c.from <= r && a(c), r > c.to && this.right.forEachLine(c.to + 1, r, i, o, u, a);
    }
  }
  replace(e, r, i) {
    let n = this.left.length + this.break;
    if (r < n)
      return this.balanced(this.left.replace(e, r, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - n, r - n, i));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let a = s.length;
    for (let o of i)
      s.push(o);
    if (e > 0 && $1(s, a - 1), r < this.length) {
      let o = s.length;
      this.decomposeRight(r, s), $1(s, o);
    }
    return Kt.of(s);
  }
  decomposeLeft(e, r) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, r);
    r.push(this.left), this.break && (i++, e >= i && r.push(null)), e > i && this.right.decomposeLeft(e - i, r);
  }
  decomposeRight(e, r) {
    let i = this.left.length, n = i + this.break;
    if (e >= n)
      return this.right.decomposeRight(e - n, r);
    e < i && this.left.decomposeRight(e, r), this.break && e < n && r.push(null), r.push(this.right);
  }
  balanced(e, r) {
    return e.size > 2 * r.size || r.size > 2 * e.size ? Kt.of(this.break ? [e, null, r] : [e, r]) : (this.left = e, this.right = r, this.height = e.height + r.height, this.outdated = e.outdated || r.outdated, this.size = e.size + r.size, this.length = e.length + this.break + r.length, this);
  }
  updateHeight(e, r = 0, i = !1, n) {
    let { left: s, right: a } = this, o = r + s.length + this.break, u = null;
    return n && n.from <= r + s.length && n.more ? u = s = s.updateHeight(e, r, i, n) : s.updateHeight(e, r, i), n && n.from <= o + a.length && n.more ? u = a = a.updateHeight(e, o, i, n) : a.updateHeight(e, o, i), u ? this.balanced(s, a) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function $1(t, e) {
  let r, i;
  t[e] == null && (r = t[e - 1]) instanceof At && (i = t[e + 1]) instanceof At && t.splice(e - 1, 3, new At(r.length + 1 + i.length));
}
const xZ = 5;
class py {
  constructor(e, r) {
    this.pos = e, this.oracle = r, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, r) {
    if (this.lineStart > -1) {
      let i = Math.min(r, this.lineEnd), n = this.nodes[this.nodes.length - 1];
      n instanceof gr ? n.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new gr(i - this.pos, -1)), this.writtenTo = i, r > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = r;
  }
  point(e, r, i) {
    if (e < r || i.heightRelevant) {
      let n = i.widget ? i.widget.estimatedHeight : 0, s = i.widget ? i.widget.lineBreaks : 0;
      n < 0 && (n = this.oracle.lineHeight);
      let a = r - e;
      i.block ? this.addBlock(new RC(a, n, i)) : (a || s || n >= xZ) && this.addLineDeco(n, s, a);
    } else
      r > e && this.span(e, r);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: r } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = r, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new gr(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, r) {
    let i = new At(r - e);
    return this.oracle.doc.lineAt(e).to == r && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof gr)
      return e;
    let r = new gr(0, -1);
    return this.nodes.push(r), r;
  }
  addBlock(e) {
    this.enterLine();
    let r = e.deco;
    r && r.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, r && r.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, r, i) {
    let n = this.ensureLine();
    n.length += i, n.collapsed += i, n.widgetHeight = Math.max(n.widgetHeight, e), n.breaks += r, this.writtenTo = this.pos = this.pos + i;
  }
  finish(e) {
    let r = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(r instanceof gr) && !this.isCovered ? this.nodes.push(new gr(0, -1)) : (this.writtenTo < this.pos || r == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let n of this.nodes)
      n instanceof gr && n.updateHeight(this.oracle, i), i += n ? n.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, r, i, n) {
    let s = new py(i, e);
    return Me.spans(r, i, n, s, 0), s.finish(i);
  }
}
function bZ(t, e, r) {
  let i = new DZ();
  return Me.compare(t, e, r, i, 0), i.changes;
}
class DZ {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, r, i, n) {
    (e < r || i && i.heightRelevant || n && n.heightRelevant) && Wf(e, r, this.changes, 5);
  }
}
function vZ(t, e) {
  let r = t.getBoundingClientRect(), i = t.ownerDocument, n = i.defaultView || window, s = Math.max(0, r.left), a = Math.min(n.innerWidth, r.right), o = Math.max(0, r.top), u = Math.min(n.innerHeight, r.bottom);
  for (let c = t.parentNode; c && c != i.body; )
    if (c.nodeType == 1) {
      let h = c, d = window.getComputedStyle(h);
      if ((h.scrollHeight > h.clientHeight || h.scrollWidth > h.clientWidth) && d.overflow != "visible") {
        let m = h.getBoundingClientRect();
        s = Math.max(s, m.left), a = Math.min(a, m.right), o = Math.max(o, m.top), u = c == t.parentNode ? m.bottom : Math.min(u, m.bottom);
      }
      c = d.position == "absolute" || d.position == "fixed" ? h.offsetParent : h.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - r.left,
    right: Math.max(s, a) - r.left,
    top: o - (r.top + e),
    bottom: Math.max(o, u) - (r.top + e)
  };
}
function SZ(t, e) {
  let r = t.getBoundingClientRect();
  return {
    left: 0,
    right: r.right - r.left,
    top: e,
    bottom: r.bottom - (r.top + e)
  };
}
class ld {
  constructor(e, r, i) {
    this.from = e, this.to = r, this.size = i;
  }
  static same(e, r) {
    if (e.length != r.length)
      return !1;
    for (let i = 0; i < e.length; i++) {
      let n = e[i], s = r[i];
      if (n.from != s.from || n.to != s.to || n.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, r) {
    return xe.replace({
      widget: new wZ(this.size * (r ? e.scaleY : e.scaleX), r)
    }).range(this.from, this.to);
  }
}
class wZ extends Zi {
  constructor(e, r) {
    super(), this.size = e, this.vertical = r;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class B1 {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = I1, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = it.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let r = e.facet(cy).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new gZ(r), this.stateDeco = e.facet(gl).filter((i) => typeof i != "function"), this.heightMap = Kt.empty().applyChanges(this.stateDeco, je.empty, this.heightOracle.setDoc(e.doc), [new Lr(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = xe.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: r } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let n = i ? r.head : r.anchor;
      if (!e.some(({ from: s, to: a }) => n >= s && n <= a)) {
        let { from: s, to: a } = this.lineBlockAt(n);
        e.push(new Mu(s, a));
      }
    }
    this.viewports = e.sort((i, n) => i.from - n.from), this.scaler = this.heightMap.height <= 7e6 ? I1 : new EZ(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : _o(e, this.scaler));
    });
  }
  update(e, r = null) {
    this.state = e.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(gl).filter((h) => typeof h != "function");
    let n = e.changedRanges, s = Lr.extendWithRanges(n, bZ(i, this.stateDeco, e ? e.changes : bt.empty(this.state.doc.length))), a = this.heightMap.height, o = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != a && (e.flags |= 2), o ? (this.scrollAnchorPos = e.changes.mapPos(o.from, -1), this.scrollAnchorHeight = o.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let u = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (r && (r.range.head < u.from || r.range.head > u.to) || !this.viewportIsAppropriate(u)) && (u = this.getViewport(0, r));
    let c = !e.changes.empty || e.flags & 2 || u.from != this.viewport.from || u.to != this.viewport.to;
    this.viewport = u, this.updateForViewport(), c && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), r && (this.scrollTarget = r), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(vC) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let r = e.contentDOM, i = window.getComputedStyle(r), n = this.heightOracle, s = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? it.RTL : it.LTR;
    let a = this.heightOracle.mustRefreshForWrapping(s), o = r.getBoundingClientRect(), u = a || this.mustMeasureContent || this.contentDOMHeight != o.height;
    this.contentDOMHeight = o.height, this.mustMeasureContent = !1;
    let c = 0, h = 0;
    if (o.width && o.height) {
      let { scaleX: k, scaleY: C } = Hw(r, o);
      (this.scaleX != k || this.scaleY != C) && (this.scaleX = k, this.scaleY = C, c |= 8, a = u = !0);
    }
    let d = (parseInt(i.paddingTop) || 0) * this.scaleY, m = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d || this.paddingBottom != m) && (this.paddingTop = d, this.paddingBottom = m, c |= 10), this.editorWidth != e.scrollDOM.clientWidth && (n.lineWrapping && (u = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 8);
    let y = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != y && (this.scrollAnchorHeight = -1, this.scrollTop = y), this.scrolledToBottom = eC(e.scrollDOM);
    let O = (this.printing ? SZ : vZ)(r, this.paddingTop), b = O.top - this.pixelViewport.top, v = O.bottom - this.pixelViewport.bottom;
    this.pixelViewport = O;
    let S = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (S != this.inView && (this.inView = S, S && (u = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let x = o.width;
    if ((this.contentDOMWidth != x || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = o.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 8), u) {
      let k = e.docView.measureVisibleLineHeights(this.viewport);
      if (n.mustRefreshForHeights(k) && (a = !0), a || n.lineWrapping && Math.abs(x - this.contentDOMWidth) > n.charWidth) {
        let { lineHeight: C, charWidth: E, textHeight: P } = e.docView.measureTextSize();
        a = C > 0 && n.refresh(s, C, E, P, x / E, k), a && (e.docView.minWidth = 0, c |= 8);
      }
      b > 0 && v > 0 ? h = Math.max(b, v) : b < 0 && v < 0 && (h = Math.min(b, v)), n.heightChanged = !1;
      for (let C of this.viewports) {
        let E = C.from == this.viewport.from ? k : e.docView.measureVisibleLineHeights(C);
        this.heightMap = (a ? Kt.empty().applyChanges(this.stateDeco, je.empty, this.heightOracle, [new Lr(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(n, 0, a, new yZ(C.from, E));
      }
      n.heightChanged && (c |= 2);
    }
    let w = !this.viewportIsAppropriate(this.viewport, h) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return w && (this.viewport = this.getViewport(h, this.scrollTarget)), this.updateForViewport(), (c & 2 || w) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(a ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, r) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), n = this.heightMap, s = this.heightOracle, { visibleTop: a, visibleBottom: o } = this, u = new Mu(n.lineAt(a - i * 1e3, tt.ByHeight, s, 0, 0).from, n.lineAt(o + (1 - i) * 1e3, tt.ByHeight, s, 0, 0).to);
    if (r) {
      let { head: c } = r.range;
      if (c < u.from || c > u.to) {
        let h = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), d = n.lineAt(c, tt.ByPos, s, 0, 0), m;
        r.y == "center" ? m = (d.top + d.bottom) / 2 - h / 2 : r.y == "start" || r.y == "nearest" && c < u.from ? m = d.top : m = d.bottom - h, u = new Mu(n.lineAt(m - 1e3 / 2, tt.ByHeight, s, 0, 0).from, n.lineAt(m + h + 1e3 / 2, tt.ByHeight, s, 0, 0).to);
      }
    }
    return u;
  }
  mapViewport(e, r) {
    let i = r.mapPos(e.from, -1), n = r.mapPos(e.to, 1);
    return new Mu(this.heightMap.lineAt(i, tt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(n, tt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: r }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: n } = this.heightMap.lineAt(e, tt.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(r, tt.ByPos, this.heightOracle, 0, 0), { visibleTop: a, visibleBottom: o } = this;
    return (e == 0 || n <= a - Math.max(10, Math.min(
      -i,
      250
      /* VP.MaxCoverMargin */
    ))) && (r == this.state.doc.length || s >= o + Math.max(10, Math.min(
      i,
      250
      /* VP.MaxCoverMargin */
    ))) && n > a - 2 * 1e3 && s < o + 2 * 1e3;
  }
  mapLineGaps(e, r) {
    if (!e.length || r.empty)
      return e;
    let i = [];
    for (let n of e)
      r.touchesRange(n.from, n.to) || i.push(new ld(r.mapPos(n.from), r.mapPos(n.to), n.size));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, r) {
    let i = this.heightOracle.lineWrapping, n = i ? 1e4 : 2e3, s = n >> 1, a = n << 1;
    if (this.defaultTextDirection != it.LTR && !i)
      return [];
    let o = [], u = (c, h, d, m) => {
      if (h - c < s)
        return;
      let y = this.state.selection.main, O = [y.from];
      y.empty || O.push(y.to);
      for (let v of O)
        if (v > c && v < h) {
          u(c, v - 10, d, m), u(v + 10, h, d, m);
          return;
        }
      let b = AZ(e, (v) => v.from >= d.from && v.to <= d.to && Math.abs(v.from - c) < s && Math.abs(v.to - h) < s && !O.some((S) => v.from < S && v.to > S));
      if (!b) {
        if (h < d.to && r && i && r.visibleRanges.some((v) => v.from <= h && v.to >= h)) {
          let v = r.moveToLineBoundary(U.cursor(h), !1, !0).head;
          v > c && (h = v);
        }
        b = new ld(c, h, this.gapSize(d, c, h, m));
      }
      o.push(b);
    };
    for (let c of this.viewportLines) {
      if (c.length < a)
        continue;
      let h = CZ(c.from, c.to, this.stateDeco);
      if (h.total < a)
        continue;
      let d = this.scrollTarget ? this.scrollTarget.range.head : null, m, y;
      if (i) {
        let O = n / this.heightOracle.lineLength * this.heightOracle.lineHeight, b, v;
        if (d != null) {
          let S = Ru(h, d), x = ((this.visibleBottom - this.visibleTop) / 2 + O) / c.height;
          b = S - x, v = S + x;
        } else
          b = (this.visibleTop - c.top - O) / c.height, v = (this.visibleBottom - c.top + O) / c.height;
        m = Lu(h, b), y = Lu(h, v);
      } else {
        let O = h.total * this.heightOracle.charWidth, b = n * this.heightOracle.charWidth, v, S;
        if (d != null) {
          let x = Ru(h, d), w = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + b) / O;
          v = x - w, S = x + w;
        } else
          v = (this.pixelViewport.left - b) / O, S = (this.pixelViewport.right + b) / O;
        m = Lu(h, v), y = Lu(h, S);
      }
      m > c.from && u(c.from, m, c, h), y < c.to && u(y, c.to, c, h);
    }
    return o;
  }
  gapSize(e, r, i, n) {
    let s = Ru(n, i) - Ru(n, r);
    return this.heightOracle.lineWrapping ? e.height * s : n.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    ld.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = xe.set(e.map((r) => r.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let r = [];
    Me.spans(e, this.viewport.from, this.viewport.to, {
      span(n, s) {
        r.push({ from: n, to: s });
      },
      point() {
      }
    }, 20);
    let i = r.length != this.visibleRanges.length || this.visibleRanges.some((n, s) => n.from != r[s].from || n.to != r[s].to);
    return this.visibleRanges = r, i ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((r) => r.from <= e && r.to >= e) || _o(this.heightMap.lineAt(e, tt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return _o(this.heightMap.lineAt(this.scaler.fromDOM(e), tt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let r = this.lineBlockAtHeight(e + 8);
    return r.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? r : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return _o(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Mu {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
function CZ(t, e, r) {
  let i = [], n = t, s = 0;
  return Me.spans(r, t, e, {
    span() {
    },
    point(a, o) {
      a > n && (i.push({ from: n, to: a }), s += a - n), n = o;
    }
  }, 20), n < e && (i.push({ from: n, to: e }), s += e - n), { total: s, ranges: i };
}
function Lu({ total: t, ranges: e }, r) {
  if (r <= 0)
    return e[0].from;
  if (r >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(t * r);
  for (let n = 0; ; n++) {
    let { from: s, to: a } = e[n], o = a - s;
    if (i <= o)
      return s + i;
    i -= o;
  }
}
function Ru(t, e) {
  let r = 0;
  for (let { from: i, to: n } of t.ranges) {
    if (e <= n) {
      r += e - i;
      break;
    }
    r += n - i;
  }
  return r / t.total;
}
function AZ(t, e) {
  for (let r of t)
    if (e(r))
      return r;
}
const I1 = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1
};
class EZ {
  constructor(e, r, i) {
    let n = 0, s = 0, a = 0;
    this.viewports = i.map(({ from: o, to: u }) => {
      let c = r.lineAt(o, tt.ByPos, e, 0, 0).top, h = r.lineAt(u, tt.ByPos, e, 0, 0).bottom;
      return n += h - c, { from: o, to: u, top: c, bottom: h, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - n) / (r.height - n);
    for (let o of this.viewports)
      o.domTop = a + (o.top - s) * this.scale, a = o.domBottom = o.domTop + (o.bottom - o.top), s = o.bottom;
  }
  toDOM(e) {
    for (let r = 0, i = 0, n = 0; ; r++) {
      let s = r < this.viewports.length ? this.viewports[r] : null;
      if (!s || e < s.top)
        return n + (e - i) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      i = s.bottom, n = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let r = 0, i = 0, n = 0; ; r++) {
      let s = r < this.viewports.length ? this.viewports[r] : null;
      if (!s || e < s.domTop)
        return i + (e - n) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      i = s.bottom, n = s.domBottom;
    }
  }
}
function _o(t, e) {
  if (e.scale == 1)
    return t;
  let r = e.toDOM(t.top), i = e.toDOM(t.bottom);
  return new wi(t.from, t.length, r, i - r, Array.isArray(t._content) ? t._content.map((n) => _o(n, e)) : t._content);
}
const ju = /* @__PURE__ */ fe.define({ combine: (t) => t.join(" ") }), Hf = /* @__PURE__ */ fe.define({ combine: (t) => t.indexOf(!0) > -1 }), Jf = /* @__PURE__ */ Xn.newName(), jC = /* @__PURE__ */ Xn.newName(), ZC = /* @__PURE__ */ Xn.newName(), WC = { "&light": "." + jC, "&dark": "." + ZC };
function Kf(t, e, r) {
  return new Xn(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (n) => {
        if (n == "&")
          return t;
        if (!r || !r[n])
          throw new RangeError(`Unsupported selector: ${n}`);
        return r[n];
      }) : t + " " + i;
    }
  });
}
const kZ = /* @__PURE__ */ Kf("." + Jf, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, WC), Qo = "";
class TZ {
  constructor(e, r) {
    this.points = e, this.text = "", this.lineSeparator = r.facet(Ie.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Qo;
  }
  readRange(e, r) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let n = e; ; ) {
      this.findPointBefore(i, n);
      let s = this.text.length;
      this.readNode(n);
      let a = n.nextSibling;
      if (a == r)
        break;
      let o = rt.get(n), u = rt.get(a);
      (o && u ? o.breakAfter : (o ? o.breakAfter : N1(n)) || N1(a) && (n.nodeName != "BR" || n.cmIgnore) && this.text.length > s) && this.lineBreak(), n = a;
    }
    return this.findPointBefore(i, r), this;
  }
  readTextNode(e) {
    let r = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, r.length));
    for (let i = 0, n = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, a = 1, o;
      if (this.lineSeparator ? (s = r.indexOf(this.lineSeparator, i), a = this.lineSeparator.length) : (o = n.exec(r)) && (s = o.index, a = o[0].length), this.append(r.slice(i, s < 0 ? r.length : s)), s < 0)
        break;
      if (this.lineBreak(), a > 1)
        for (let u of this.points)
          u.node == e && u.pos > this.text.length && (u.pos -= a - 1);
      i = s + a;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let r = rt.get(e), i = r && r.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let n = i.iter(); !n.next().done; )
        n.lineBreak ? this.lineBreak() : this.append(n.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, r) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == r && (i.pos = this.text.length);
  }
  findPointInside(e, r) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + (PZ(e, i.node, i.offset) ? r : 0));
  }
}
function PZ(t, e, r) {
  for (; ; ) {
    if (!e || r < tn(e))
      return !1;
    if (e == t)
      return !0;
    r = ml(e) + 1, e = e.parentNode;
  }
}
function N1(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
class _1 {
  constructor(e, r) {
    this.node = e, this.offset = r, this.pos = -1;
  }
}
class FZ {
  constructor(e, r, i, n) {
    this.typeOver = n, this.bounds = null, this.text = "";
    let { impreciseHead: s, impreciseAnchor: a } = e.docView;
    if (e.state.readOnly && r > -1)
      this.newSel = null;
    else if (r > -1 && (this.bounds = e.docView.domBoundsAround(r, i, 0))) {
      let o = s || a ? [] : IZ(e), u = new TZ(o, e.state);
      u.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = u.text, this.newSel = NZ(o, this.bounds.from);
    } else {
      let o = e.observer.selectionRange, u = s && s.node == o.focusNode && s.offset == o.focusOffset || !Qf(e.contentDOM, o.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(o.focusNode, o.focusOffset), c = a && a.node == o.anchorNode && a.offset == o.anchorOffset || !Qf(e.contentDOM, o.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(o.anchorNode, o.anchorOffset), h = e.viewport;
      if ((ge.ios || ge.chrome) && e.state.selection.main.empty && u != c && (h.from > 0 || h.to < e.state.doc.length)) {
        let d = Math.min(u, c), m = Math.max(u, c), y = h.from - d, O = h.to - m;
        (y == 0 || y == 1 || d == 0) && (O == 0 || O == -1 || m == e.state.doc.length) && (u = 0, c = e.state.doc.length);
      }
      this.newSel = U.single(c, u);
    }
  }
}
function qC(t, e) {
  let r, { newSel: i } = e, n = t.state.selection.main, s = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: a, to: o } = e.bounds, u = n.from, c = null;
    (s === 8 || ge.android && e.text.length < o - a) && (u = n.to, c = "end");
    let h = BZ(t.state.doc.sliceString(a, o, Qo), e.text, u - a, c);
    h && (ge.chrome && s == 13 && h.toB == h.from + 2 && e.text.slice(h.from, h.toB) == Qo + Qo && h.toB--, r = {
      from: a + h.from,
      to: a + h.toA,
      insert: je.of(e.text.slice(h.from, h.toB).split(Qo))
    });
  } else
    i && (!t.hasFocus && t.state.facet(sp) || i.main.eq(n)) && (i = null);
  if (!r && !i)
    return !1;
  if (!r && e.typeOver && !n.empty && i && i.main.empty ? r = { from: n.from, to: n.to, insert: t.state.doc.slice(n.from, n.to) } : r && r.from >= n.from && r.to <= n.to && (r.from != n.from || r.to != n.to) && n.to - n.from - (r.to - r.from) <= 4 ? r = {
    from: n.from,
    to: n.to,
    insert: t.state.doc.slice(n.from, r.from).append(r.insert).append(t.state.doc.slice(r.to, n.to))
  } : (ge.mac || ge.android) && r && r.from == r.to && r.from == n.head - 1 && /^\. ?$/.test(r.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (i && r.insert.length == 2 && (i = U.single(i.main.anchor - 1, i.main.head - 1)), r = { from: n.from, to: n.to, insert: je.of([" "]) }) : ge.chrome && r && r.from == r.to && r.from == n.head && r.insert.toString() == `
 ` && t.lineWrapping && (i && (i = U.single(i.main.anchor - 1, i.main.head - 1)), r = { from: n.from, to: n.to, insert: je.of([" "]) }), r) {
    if (ge.ios && t.inputState.flushIOSKey() || ge.android && (r.from == n.from && r.to == n.to && r.insert.length == 1 && r.insert.lines == 2 && va(t.contentDOM, "Enter", 13) || (r.from == n.from - 1 && r.to == n.to && r.insert.length == 0 || s == 8 && r.insert.length < r.to - r.from && r.to > n.head) && va(t.contentDOM, "Backspace", 8) || r.from == n.from && r.to == n.to + 1 && r.insert.length == 0 && va(t.contentDOM, "Delete", 46)))
      return !0;
    let a = r.insert.toString();
    t.inputState.composing >= 0 && t.inputState.composing++;
    let o, u = () => o || (o = $Z(t, r, i));
    return t.state.facet(xC).some((c) => c(t, r.from, r.to, a, u)) || t.dispatch(u()), !0;
  } else if (i && !i.main.eq(n)) {
    let a = !1, o = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (a = !0), o = t.inputState.lastSelectionOrigin), t.dispatch({ selection: i, scrollIntoView: a, userEvent: o }), !0;
  } else
    return !1;
}
function $Z(t, e, r) {
  let i, n = t.state, s = n.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!r || r.main.empty && r.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let o = s.from < e.from ? n.sliceDoc(s.from, e.from) : "", u = s.to > e.to ? n.sliceDoc(e.to, s.to) : "";
    i = n.replaceSelection(t.state.toText(o + e.insert.sliceString(0, void 0, t.state.lineBreak) + u));
  } else {
    let o = n.changes(e), u = r && r.main.to <= o.newLength ? r.main : void 0;
    if (n.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let c = t.state.sliceDoc(e.from, e.to), h, d = r && kC(t, r.main.head);
      if (d) {
        let O = e.insert.length - (e.to - e.from);
        h = { from: d.from, to: d.to - O };
      } else
        h = t.state.doc.lineAt(s.head);
      let m = s.to - e.to, y = s.to - s.from;
      i = n.changeByRange((O) => {
        if (O.from == s.from && O.to == s.to)
          return { changes: o, range: u || O.map(o) };
        let b = O.to - m, v = b - c.length;
        if (O.to - O.from != y || t.state.sliceDoc(v, b) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        O.to >= h.from && O.from <= h.to)
          return { range: O };
        let S = n.changes({ from: v, to: b, insert: e.insert }), x = O.to - s.to;
        return {
          changes: S,
          range: u ? U.range(Math.max(0, u.anchor + x), Math.max(0, u.head + x)) : O.map(S)
        };
      });
    } else
      i = {
        changes: o,
        selection: u && n.selection.replaceRange(u)
      };
  }
  let a = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, a += ".compose", t.inputState.compositionFirstChange && (a += ".start", t.inputState.compositionFirstChange = !1)), n.update(i, { userEvent: a, scrollIntoView: !0 });
}
function BZ(t, e, r, i) {
  let n = Math.min(t.length, e.length), s = 0;
  for (; s < n && t.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == n && t.length == e.length)
    return null;
  let a = t.length, o = e.length;
  for (; a > 0 && o > 0 && t.charCodeAt(a - 1) == e.charCodeAt(o - 1); )
    a--, o--;
  if (i == "end") {
    let u = Math.max(0, s - Math.min(a, o));
    r -= a + u - s;
  }
  if (a < s && t.length < e.length) {
    let u = r <= s && r >= a ? s - r : 0;
    s -= u, o = s + (o - a), a = s;
  } else if (o < s) {
    let u = r <= s && r >= o ? s - r : 0;
    s -= u, a = s + (a - o), o = s;
  }
  return { from: s, toA: a, toB: o };
}
function IZ(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: r, anchorOffset: i, focusNode: n, focusOffset: s } = t.observer.selectionRange;
  return r && (e.push(new _1(r, i)), (n != r || s != i) && e.push(new _1(n, s))), e;
}
function NZ(t, e) {
  if (t.length == 0)
    return null;
  let r = t[0].pos, i = t.length == 2 ? t[1].pos : r;
  return r > -1 && i > -1 ? U.single(r + e, i + e) : null;
}
const _Z = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, ud = ge.ie && ge.ie_version <= 11;
class QZ {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new bj(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((r) => {
      for (let i of r)
        this.queue.push(i);
      (ge.ie && ge.ie_version <= 11 || ge.ios && e.composing) && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), ud && (this.onCharData = (r) => {
      this.queue.push({
        target: r.target,
        type: "characterData",
        oldValue: r.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var r;
      ((r = this.view.docView) === null || r === void 0 ? void 0 : r.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((r) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), r.length > 0 && r[r.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((r) => {
      r.length > 0 && r[r.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((r, i) => r != e[i]))) {
      this.gapIntersection.disconnect();
      for (let r of e)
        this.gapIntersection.observe(r);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let r = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, n = this.selectionRange;
    if (i.state.facet(sp) ? i.root.activeElement != this.dom : !pc(i.dom, n))
      return;
    let s = n.anchorNode && i.docView.nearest(n.anchorNode);
    if (s && s.ignoreEvent(e)) {
      r || (this.selectionChanged = !1);
      return;
    }
    (ge.ie && ge.ie_version <= 11 || ge.android && ge.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    n.focusNode && Ko(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, r = ge.safari && e.root.nodeType == 11 && gj(this.dom.ownerDocument) == this.dom && MZ(this.view) || Lc(e.root);
    if (!r || this.selectionRange.eq(r))
      return !1;
    let i = pc(this.dom, r);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && vj(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, r) {
    this.selectionRange.set(e.node, e.offset, r.node, r.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, r = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !r && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : r || (r = this.scrollTargets.slice(0, e)), r && r.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !r && (r = this.scrollTargets.slice(0, e)), r) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = r)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, _Z), ud && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), ud && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, r) {
    var i;
    if (!this.delayedAndroidKey) {
      let n = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && va(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(n);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: r,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let r = -1, i = -1, n = !1;
    for (let s of e) {
      let a = this.readMutation(s);
      a && (a.typeOver && (n = !0), r == -1 ? { from: r, to: i } = a : (r = Math.min(a.from, r), i = Math.max(a.to, i)));
    }
    return { from: r, to: i, typeOver: n };
  }
  readChange() {
    let { from: e, to: r, typeOver: i } = this.processRecords(), n = this.selectionChanged && pc(this.dom, this.selectionRange);
    if (e < 0 && !n)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new FZ(this.view, e, r, i);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let r = this.readChange();
    if (!r)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, n = qC(this.view, r);
    return this.view.state == i && this.view.update([]), n;
  }
  readMutation(e) {
    let r = this.view.docView.nearest(e.target);
    if (!r || r.ignoreMutation(e))
      return null;
    if (r.markDirty(e.type == "attributes"), e.type == "attributes" && (r.flags |= 4), e.type == "childList") {
      let i = Q1(r, e.previousSibling || e.target.previousSibling, -1), n = Q1(r, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? r.posAfter(i) : r.posAtStart,
        to: n ? r.posBefore(n) : r.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, r, i;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (r = this.gapIntersection) === null || r === void 0 || r.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let n of this.scrollTargets)
      n.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function Q1(t, e, r) {
  for (; e; ) {
    let i = rt.get(e);
    if (i && i.parent == t)
      return i;
    let n = e.parentNode;
    e = n != t.dom ? n : r > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function MZ(t) {
  let e = null;
  function r(u) {
    u.preventDefault(), u.stopImmediatePropagation(), e = u.getTargetRanges()[0];
  }
  if (t.contentDOM.addEventListener("beforeinput", r, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", r, !0), !e)
    return null;
  let i = e.startContainer, n = e.startOffset, s = e.endContainer, a = e.endOffset, o = t.docView.domAtPos(t.state.selection.main.anchor);
  return Ko(o.node, o.offset, s, a) && ([i, n, s, a] = [s, a, i, n]), { anchorNode: i, anchorOffset: n, focusNode: s, focusOffset: a };
}
class oe {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((i) => i.forEach((n) => r(n, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || Dj(e.parent) || document, this.viewState = new B1(e.state || Ie.create(e)), e.scrollTo && e.scrollTo.is(Nu) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Io).map((i) => new sd(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new QZ(this), this.inputState = new Kj(this), this.inputState.ensureHandlers(this.plugins), this.docView = new m1(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...e) {
    let r = e.length == 1 && e[0] instanceof yt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(r, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let r = !1, i = !1, n, s = this.state;
    for (let m of e) {
      if (m.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = m.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let a = this.hasFocus, o = 0, u = null;
    e.some((m) => m.annotation(QC)) ? (this.inputState.notifiedFocused = a, o = 1) : a != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = a, u = MC(s, a), u || (o = 1));
    let c = this.observer.delayedAndroidKey, h = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), h = this.observer.readChange(), (h && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (h = null)) : this.observer.clear(), s.facet(Ie.phrases) != this.state.facet(Ie.phrases))
      return this.setState(s);
    n = Rc.create(this, s, e), n.flags |= o;
    let d = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let m of e) {
        if (d && (d = d.map(m.changes)), m.scrollIntoView) {
          let { main: y } = m.state.selection;
          d = new Sa(y.empty ? y : U.cursor(y.head, y.head > y.anchor ? -1 : 1));
        }
        for (let y of m.effects)
          y.is(Nu) && (d = y.value.clip(this.state));
      }
      this.viewState.update(n, d), this.bidiCache = jc.update(this.bidiCache, n.changes), n.empty || (this.updatePlugins(n), this.inputState.update(n)), r = this.docView.update(n), this.state.facet(No) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(r, e.some((m) => m.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (n.startState.facet(ju) != n.state.facet(ju) && (this.viewState.mustMeasureContent = !0), (r || i || d || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !n.empty)
      for (let m of this.state.facet(Yf))
        try {
          m(n);
        } catch (y) {
          Mr(this.state, y, "update listener");
        }
    (u || h) && Promise.resolve().then(() => {
      u && this.state == u.startState && this.dispatch(u), h && !qC(this, h) && c.force && va(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let r = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new B1(e), this.plugins = e.facet(Io).map((i) => new sd(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView.destroy(), this.docView = new m1(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    r && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let r = e.startState.facet(Io), i = e.state.facet(Io);
    if (r != i) {
      let n = [];
      for (let s of i) {
        let a = r.indexOf(s);
        if (a < 0)
          n.push(new sd(s));
        else {
          let o = this.plugins[a];
          o.mustUpdate = e, n.push(o);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = n, this.pluginMap.clear();
    } else
      for (let n of this.plugins)
        n.mustUpdate = e;
    for (let n = 0; n < this.plugins.length; n++)
      this.plugins[n].update(this);
    r != i && this.inputState.ensureHandlers(this.plugins);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let r = null, i = this.scrollDOM, n = i.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: a } = this.viewState;
    Math.abs(n - this.viewState.scrollTop) > 1 && (a = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let o = 0; ; o++) {
        if (a < 0)
          if (eC(i))
            s = -1, a = this.viewState.heightMap.height;
          else {
            let y = this.viewState.scrollAnchorAt(n);
            s = y.from, a = y.top;
          }
        this.updateState = 1;
        let u = this.viewState.measure(this);
        if (!u && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (o > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        u & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let h = c.map((y) => {
          try {
            return y.read(this);
          } catch (O) {
            return Mr(this.state, O), M1;
          }
        }), d = Rc.create(this, this.state, []), m = !1;
        d.flags |= u, r ? r.flags |= u : r = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), m = this.docView.update(d));
        for (let y = 0; y < c.length; y++)
          if (h[y] != M1)
            try {
              let O = c[y];
              O.write && O.write(h[y], this);
            } catch (O) {
              Mr(this.state, O);
            }
        if (m && this.docView.updateSelection(!0), !d.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, a = -1;
              continue;
            } else {
              let O = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - a;
              if (O > 1 || O < -1) {
                n = n + O, i.scrollTop = n / this.scaleY, a = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (r && !r.empty)
      for (let o of this.state.facet(Yf))
        o(r);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Jf + " " + (this.state.facet(Hf) ? ZC : jC) + " " + this.state.facet(ju);
  }
  updateAttrs() {
    let e = L1(this, SC, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), r = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(sp) ? "true" : "false",
      class: "cm-content",
      style: `${ge.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (r["aria-readonly"] = "true"), L1(this, cy, r);
    let i = this.observer.ignore(() => {
      let n = Zf(this.contentDOM, this.contentAttrs, r), s = Zf(this.dom, this.editorAttrs, e);
      return n || s;
    });
    return this.editorAttrs = e, this.contentAttrs = r, i;
  }
  showAnnouncements(e) {
    let r = !0;
    for (let i of e)
      for (let n of i.effects)
        if (n.is(oe.announce)) {
          r && (this.announceDOM.textContent = ""), r = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = n.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(No);
    let e = this.state.facet(oe.cspNonce);
    Xn.mount(this.root, this.styleModules.concat(kZ).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let r = 0; r < this.measureRequests.length; r++)
          if (this.measureRequests[r].key === e.key) {
            this.measureRequests[r] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let r = this.pluginMap.get(e);
    return (r === void 0 || r && r.spec != e) && this.pluginMap.set(e, r = this.plugins.find((i) => i.spec == e) || null), r && r.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, r, i) {
    return od(this, e, D1(this, e, r, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, r) {
    return od(this, e, D1(this, e, r, (i) => Hj(this, e.head, i)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, r) {
    let i = this.bidiSpans(e), n = this.textDirectionAt(e.from), s = i[r ? i.length - 1 : 0];
    return U.cursor(s.side(r, n) + e.from, s.forward(!r, n) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, r, i = !0) {
    return Gj(this, e, r, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, r, i) {
    return od(this, e, Jj(this, e, r, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, r = 0) {
    return this.docView.posFromDOM(e, r);
  }
  posAtCoords(e, r = !0) {
    return this.readMeasured(), PC(this, e, r);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, r = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, r);
    if (!i || i.left == i.right)
      return i;
    let n = this.state.doc.lineAt(e), s = this.bidiSpans(n), a = s[Bn.find(s, e - n.from, -1, r)];
    return ip(i, a.dir == it.LTR == r > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(DC) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > LZ)
      return dC(e.length);
    let r = this.textDirectionAt(e.from), i;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == r && (s.fresh || pC(s.isolates, i = f1(this, e))))
        return s.order;
    i || (i = f1(this, e));
    let n = Ij(e.text, r, i);
    return this.bidiCache.push(new jc(e.from, e.to, r, i, !0, n)), n;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || ge.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      Jw(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, r = {}) {
    return Nu.of(new Sa(typeof e == "number" ? U.cursor(e) : e, r.y, r.x, r.yMargin, r.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: r } = this.scrollDOM, i = this.viewState.scrollAnchorAt(e);
    return Nu.of(new Sa(U.cursor(i.from), "start", "start", i.top - e, r, !0));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return ft.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return ft.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, r) {
    let i = Xn.newName(), n = [ju.of(i), No.of(Kf(`.${i}`, e))];
    return r && r.dark && n.push(Hf.of(!0)), n;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return Ys.lowest(No.of(Kf("." + Jf, e, WC)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var r;
    let i = e.querySelector(".cm-content"), n = i && rt.get(i) || rt.get(e);
    return ((r = n == null ? void 0 : n.rootView) === null || r === void 0 ? void 0 : r.view) || null;
  }
}
oe.styleModule = No;
oe.inputHandler = xC;
oe.focusChangeEffect = bC;
oe.perLineTextDirection = DC;
oe.exceptionSink = OC;
oe.updateListener = Yf;
oe.editable = sp;
oe.mouseSelectionStyle = yC;
oe.dragMovesSelection = gC;
oe.clickAddsSelectionRange = mC;
oe.decorations = gl;
oe.outerDecorations = wC;
oe.atomicRanges = hy;
oe.bidiIsolatedRanges = CC;
oe.scrollMargins = AC;
oe.darkTheme = Hf;
oe.cspNonce = /* @__PURE__ */ fe.define({ combine: (t) => t.length ? t[0] : "" });
oe.contentAttributes = cy;
oe.editorAttributes = SC;
oe.lineWrapping = /* @__PURE__ */ oe.contentAttributes.of({ class: "cm-lineWrapping" });
oe.announce = /* @__PURE__ */ we.define();
const LZ = 4096, M1 = {};
class jc {
  constructor(e, r, i, n, s, a) {
    this.from = e, this.to = r, this.dir = i, this.isolates = n, this.fresh = s, this.order = a;
  }
  static update(e, r) {
    if (r.empty && !e.some((s) => s.fresh))
      return e;
    let i = [], n = e.length ? e[e.length - 1].dir : it.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let a = e[s];
      a.dir == n && !r.touchesRange(a.from, a.to) && i.push(new jc(r.mapPos(a.from, 1), r.mapPos(a.to, -1), a.dir, a.isolates, !1, a.order));
    }
    return i;
  }
}
function L1(t, e, r) {
  for (let i = t.state.facet(e), n = i.length - 1; n >= 0; n--) {
    let s = i[n], a = typeof s == "function" ? s(t) : s;
    a && jf(a, r);
  }
  return r;
}
const RZ = ge.mac ? "mac" : ge.windows ? "win" : ge.linux ? "linux" : "key";
function jZ(t, e) {
  const r = t.split(/-(?!$)/);
  let i = r[r.length - 1];
  i == "Space" && (i = " ");
  let n, s, a, o;
  for (let u = 0; u < r.length - 1; ++u) {
    const c = r[u];
    if (/^(cmd|meta|m)$/i.test(c))
      o = !0;
    else if (/^a(lt)?$/i.test(c))
      n = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      a = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? o = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return n && (i = "Alt-" + i), s && (i = "Ctrl-" + i), o && (i = "Meta-" + i), a && (i = "Shift-" + i), i;
}
function Zu(t, e, r) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), r !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const ZZ = /* @__PURE__ */ Ys.default(/* @__PURE__ */ oe.domEventHandlers({
  keydown(t, e) {
    return VC(XC(e.state), t, e, "editor");
  }
})), zl = /* @__PURE__ */ fe.define({ enables: ZZ }), R1 = /* @__PURE__ */ new WeakMap();
function XC(t) {
  let e = t.facet(zl), r = R1.get(e);
  return r || R1.set(e, r = XZ(e.reduce((i, n) => i.concat(n), []))), r;
}
function WZ(t, e, r) {
  return VC(XC(t.state), e, t, r);
}
let Tn = null;
const qZ = 4e3;
function XZ(t, e = RZ) {
  let r = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), n = (a, o) => {
    let u = i[a];
    if (u == null)
      i[a] = o;
    else if (u != o)
      throw new Error("Key binding " + a + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (a, o, u, c, h) => {
    var d, m;
    let y = r[a] || (r[a] = /* @__PURE__ */ Object.create(null)), O = o.split(/ (?!$)/).map((S) => jZ(S, e));
    for (let S = 1; S < O.length; S++) {
      let x = O.slice(0, S).join(" ");
      n(x, !0), y[x] || (y[x] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(w) => {
          let k = Tn = { view: w, prefix: x, scope: a };
          return setTimeout(() => {
            Tn == k && (Tn = null);
          }, qZ), !0;
        }]
      });
    }
    let b = O.join(" ");
    n(b, !1);
    let v = y[b] || (y[b] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((m = (d = y._any) === null || d === void 0 ? void 0 : d.run) === null || m === void 0 ? void 0 : m.slice()) || []
    });
    u && v.run.push(u), c && (v.preventDefault = !0), h && (v.stopPropagation = !0);
  };
  for (let a of t) {
    let o = a.scope ? a.scope.split(" ") : ["editor"];
    if (a.any)
      for (let c of o) {
        let h = r[c] || (r[c] = /* @__PURE__ */ Object.create(null));
        h._any || (h._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let d in h)
          h[d].run.push(a.any);
      }
    let u = a[e] || a.key;
    if (u)
      for (let c of o)
        s(c, u, a.run, a.preventDefault, a.stopPropagation), a.shift && s(c, "Shift-" + u, a.shift, a.preventDefault, a.stopPropagation);
  }
  return r;
}
function VC(t, e, r, i) {
  let n = mj(e), s = Et(n, 0), a = Nr(s) == n.length && n != " ", o = "", u = !1, c = !1, h = !1;
  Tn && Tn.view == r && Tn.scope == i && (o = Tn.prefix + " ", $C.indexOf(e.keyCode) < 0 && (c = !0, Tn = null));
  let d = /* @__PURE__ */ new Set(), m = (v) => {
    if (v) {
      for (let S of v.run)
        if (!d.has(S) && (d.add(S), S(r, e)))
          return v.stopPropagation && (h = !0), !0;
      v.preventDefault && (v.stopPropagation && (h = !0), c = !0);
    }
    return !1;
  }, y = t[i], O, b;
  return y && (m(y[o + Zu(n, e, !a)]) ? u = !0 : a && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(ge.windows && e.ctrlKey && e.altKey) && (O = Vn[e.keyCode]) && O != n ? (m(y[o + Zu(O, e, !0)]) || e.shiftKey && (b = fl[e.keyCode]) != n && b != O && m(y[o + Zu(b, e, !1)])) && (u = !0) : a && e.shiftKey && m(y[o + Zu(n, e, !0)]) && (u = !0), !u && m(y._any) && (u = !0)), c && (u = !0), u && h && e.stopPropagation(), u;
}
class Gl {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, r, i, n, s) {
    this.className = e, this.left = r, this.top = i, this.width = n, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, r) {
    return r.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, r, i) {
    if (i.empty) {
      let n = e.coordsAtPos(i.head, i.assoc || 1);
      if (!n)
        return [];
      let s = YC(e);
      return [new Gl(r, n.left - s.left, n.top - s.top, null, n.bottom - n.top)];
    } else
      return VZ(e, r, i);
  }
}
function YC(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == it.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function j1(t, e, r) {
  let i = U.cursor(e);
  return {
    from: Math.max(r.from, t.moveToLineBoundary(i, !1, !0).from),
    to: Math.min(r.to, t.moveToLineBoundary(i, !0, !0).from),
    type: Jt.Text
  };
}
function VZ(t, e, r) {
  if (r.to <= t.viewport.from || r.from >= t.viewport.to)
    return [];
  let i = Math.max(r.from, t.viewport.from), n = Math.min(r.to, t.viewport.to), s = t.textDirection == it.LTR, a = t.contentDOM, o = a.getBoundingClientRect(), u = YC(t), c = a.querySelector(".cm-line"), h = c && window.getComputedStyle(c), d = o.left + (h ? parseInt(h.paddingLeft) + Math.min(0, parseInt(h.textIndent)) : 0), m = o.right - (h ? parseInt(h.paddingRight) : 0), y = zf(t, i), O = zf(t, n), b = y.type == Jt.Text ? y : null, v = O.type == Jt.Text ? O : null;
  if (b && (t.lineWrapping || y.widgetLineBreaks) && (b = j1(t, i, b)), v && (t.lineWrapping || O.widgetLineBreaks) && (v = j1(t, n, v)), b && v && b.from == v.from)
    return x(w(r.from, r.to, b));
  {
    let C = b ? w(r.from, null, b) : k(y, !1), E = v ? w(null, r.to, v) : k(O, !0), P = [];
    return (b || y).to < (v || O).from - (b && v ? 1 : 0) || y.widgetLineBreaks > 1 && C.bottom + t.defaultLineHeight / 2 < E.top ? P.push(S(d, C.bottom, m, E.top)) : C.bottom < E.top && t.elementAtHeight((C.bottom + E.top) / 2).type == Jt.Text && (C.bottom = E.top = (C.bottom + E.top) / 2), x(C).concat(P).concat(x(E));
  }
  function S(C, E, P, I) {
    return new Gl(
      e,
      C - u.left,
      E - u.top - 0.01,
      P - C,
      I - E + 0.01
      /* C.Epsilon */
    );
  }
  function x({ top: C, bottom: E, horizontal: P }) {
    let I = [];
    for (let B = 0; B < P.length; B += 2)
      I.push(S(P[B], C, P[B + 1], E));
    return I;
  }
  function w(C, E, P) {
    let I = 1e9, B = -1e9, Q = [];
    function j(L, q, X, K, Oe) {
      let Ae = t.coordsAtPos(L, L == P.to ? -2 : 2), ve = t.coordsAtPos(X, X == P.from ? 2 : -2);
      !Ae || !ve || (I = Math.min(Ae.top, ve.top, I), B = Math.max(Ae.bottom, ve.bottom, B), Oe == it.LTR ? Q.push(s && q ? d : Ae.left, s && K ? m : ve.right) : Q.push(!s && K ? d : ve.left, !s && q ? m : Ae.right));
    }
    let G = C ?? P.from, J = E ?? P.to;
    for (let L of t.visibleRanges)
      if (L.to > G && L.from < J)
        for (let q = Math.max(L.from, G), X = Math.min(L.to, J); ; ) {
          let K = t.state.doc.lineAt(q);
          for (let Oe of t.bidiSpans(K)) {
            let Ae = Oe.from + K.from, ve = Oe.to + K.from;
            if (Ae >= X)
              break;
            ve > q && j(Math.max(Ae, q), C == null && Ae <= G, Math.min(ve, X), E == null && ve >= J, Oe.dir);
          }
          if (q = K.to + 1, q >= X)
            break;
        }
    return Q.length == 0 && j(G, C == null, J, E == null, t.textDirection), { top: I, bottom: B, horizontal: Q };
  }
  function k(C, E) {
    let P = o.top + (E ? C.top : C.bottom);
    return { top: P, bottom: P, horizontal: [] };
  }
}
function YZ(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class UZ {
  constructor(e, r) {
    this.view = e, this.layer = r, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), r.above && this.dom.classList.add("cm-layer-above"), r.class && this.dom.classList.add(r.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), r.mount && r.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(mc) != e.state.facet(mc) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  setOrder(e) {
    let r = 0, i = e.facet(mc);
    for (; r < i.length && i[r] != this.layer; )
      r++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - r);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: r } = this.view;
    (e != this.scaleX || r != this.scaleY) && (this.scaleX = e, this.scaleY = r, this.dom.style.transform = `scale(${1 / e}, ${1 / r})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((r, i) => !YZ(r, this.drawn[i]))) {
      let r = this.dom.firstChild, i = 0;
      for (let n of e)
        n.update && r && n.constructor && this.drawn[i].constructor && n.update(r, this.drawn[i]) ? (r = r.nextSibling, i++) : this.dom.insertBefore(n.draw(), r);
      for (; r; ) {
        let n = r.nextSibling;
        r.remove(), r = n;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const mc = /* @__PURE__ */ fe.define();
function UC(t) {
  return [
    ft.define((e) => new UZ(e, t)),
    mc.of(t)
  ];
}
const zC = !ge.ios, yl = /* @__PURE__ */ fe.define({
  combine(t) {
    return ji(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, r) => Math.min(e, r),
      drawRangeCursor: (e, r) => e || r
    });
  }
});
function zZ(t = {}) {
  return [
    yl.of(t),
    GZ,
    HZ,
    JZ,
    vC.of(!0)
  ];
}
function GC(t) {
  return t.startState.facet(yl) != t.state.facet(yl);
}
const GZ = /* @__PURE__ */ UC({
  above: !0,
  markers(t) {
    let { state: e } = t, r = e.facet(yl), i = [];
    for (let n of e.selection.ranges) {
      let s = n == e.selection.main;
      if (n.empty ? !s || zC : r.drawRangeCursor) {
        let a = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", o = n.empty ? n : U.cursor(n.head, n.head > n.anchor ? -1 : 1);
        for (let u of Gl.forRange(t, a, o))
          i.push(u);
      }
    }
    return i;
  },
  update(t, e) {
    t.transactions.some((i) => i.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let r = GC(t);
    return r && Z1(t.state, e), t.docChanged || t.selectionSet || r;
  },
  mount(t, e) {
    Z1(e.state, t);
  },
  class: "cm-cursorLayer"
});
function Z1(t, e) {
  e.style.animationDuration = t.facet(yl).cursorBlinkRate + "ms";
}
const HZ = /* @__PURE__ */ UC({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : Gl.forRange(t, "cm-selectionBackground", e)).reduce((e, r) => e.concat(r));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || GC(t);
  },
  class: "cm-selectionLayer"
}), em = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
zC && (em[".cm-line"].caretColor = "transparent !important", em[".cm-content"] = { caretColor: "transparent !important" });
const JZ = /* @__PURE__ */ Ys.highest(/* @__PURE__ */ oe.theme(em)), HC = /* @__PURE__ */ we.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), Mo = /* @__PURE__ */ St.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((r, i) => i.is(HC) ? i.value : r, t);
  }
}), KZ = /* @__PURE__ */ ft.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let r = t.state.field(Mo);
    r == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(Mo) != r || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(Mo), r = e != null && t.coordsAtPos(e);
    if (!r)
      return null;
    let i = t.scrollDOM.getBoundingClientRect();
    return {
      left: r.left - i.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: r.top - i.top + t.scrollDOM.scrollTop * t.scaleY,
      height: r.bottom - r.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: r } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / r + "px", this.cursor.style.height = t.height / r + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(Mo) != t && this.view.dispatch({ effects: HC.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function eW() {
  return [Mo, KZ];
}
function W1(t, e, r, i, n) {
  e.lastIndex = 0;
  for (let s = t.iterRange(r, i), a = r, o; !s.next().done; a += s.value.length)
    if (!s.lineBreak)
      for (; o = e.exec(s.value); )
        n(a + o.index, o);
}
function tW(t, e) {
  let r = t.visibleRanges;
  if (r.length == 1 && r[0].from == t.viewport.from && r[0].to == t.viewport.to)
    return r;
  let i = [];
  for (let { from: n, to: s } of r)
    n = Math.max(t.state.doc.lineAt(n).from, n - e), s = Math.min(t.state.doc.lineAt(s).to, s + e), i.length && i[i.length - 1].to >= n ? i[i.length - 1].to = s : i.push({ from: n, to: s });
  return i;
}
class rW {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: r, decoration: i, decorate: n, boundary: s, maxLength: a = 1e3 } = e;
    if (!r.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = r, n)
      this.addMatch = (o, u, c, h) => n(h, c, c + o[0].length, o, u);
    else if (typeof i == "function")
      this.addMatch = (o, u, c, h) => {
        let d = i(o, u, c);
        d && h(c, c + o[0].length, d);
      };
    else if (i)
      this.addMatch = (o, u, c, h) => h(c, c + o[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = a;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let r = new qn(), i = r.add.bind(r);
    for (let { from: n, to: s } of tW(e, this.maxLength))
      W1(e.state.doc, this.regexp, n, s, (a, o) => this.addMatch(o, e, a, i));
    return r.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, r) {
    let i = 1e9, n = -1;
    return e.docChanged && e.changes.iterChanges((s, a, o, u) => {
      u > e.view.viewport.from && o < e.view.viewport.to && (i = Math.min(o, i), n = Math.max(u, n));
    }), e.viewportChanged || n - i > 1e3 ? this.createDeco(e.view) : n > -1 ? this.updateRange(e.view, r.map(e.changes), i, n) : r;
  }
  updateRange(e, r, i, n) {
    for (let s of e.visibleRanges) {
      let a = Math.max(s.from, i), o = Math.min(s.to, n);
      if (o > a) {
        let u = e.state.doc.lineAt(a), c = u.to < o ? e.state.doc.lineAt(o) : u, h = Math.max(s.from, u.from), d = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; a > u.from; a--)
            if (this.boundary.test(u.text[a - 1 - u.from])) {
              h = a;
              break;
            }
          for (; o < c.to; o++)
            if (this.boundary.test(c.text[o - c.from])) {
              d = o;
              break;
            }
        }
        let m = [], y, O = (b, v, S) => m.push(S.range(b, v));
        if (u == c)
          for (this.regexp.lastIndex = h - u.from; (y = this.regexp.exec(u.text)) && y.index < d - u.from; )
            this.addMatch(y, e, y.index + u.from, O);
        else
          W1(e.state.doc, this.regexp, h, d, (b, v) => this.addMatch(v, e, b, O));
        r = r.update({ filterFrom: h, filterTo: d, filter: (b, v) => b < h || v > d, add: m });
      }
    }
    return r;
  }
}
const tm = /x/.unicode != null ? "gu" : "g", iW = /* @__PURE__ */ new RegExp(`[\0-\b
--\u2028\u2029\uFEFF-]`, tm), nW = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let cd = null;
function sW() {
  var t;
  if (cd == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    cd = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return cd || !1;
}
const gc = /* @__PURE__ */ fe.define({
  combine(t) {
    let e = ji(t, {
      render: null,
      specialChars: iW,
      addSpecialChars: null
    });
    return (e.replaceTabs = !sW()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, tm)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, tm)), e;
  }
});
function aW(t = {}) {
  return [gc.of(t), oW()];
}
let q1 = null;
function oW() {
  return q1 || (q1 = ft.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = xe.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(gc)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new rW({
        regexp: t.specialChars,
        decoration: (e, r, i) => {
          let { doc: n } = r.state, s = Et(e[0], 0);
          if (s == 9) {
            let a = n.lineAt(i), o = r.state.tabSize, u = ro(a.text, o, i - a.from);
            return xe.replace({
              widget: new hW((o - u % o) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = xe.replace({ widget: new cW(t, s) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(gc);
      t.startState.facet(gc) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const lW = "";
function uW(t) {
  return t >= 32 ? lW : t == 10 ? "" : String.fromCharCode(9216 + t);
}
class cW extends Zi {
  constructor(e, r) {
    super(), this.options = e, this.code = r;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let r = uW(this.code), i = e.state.phrase("Control character") + " " + (nW[this.code] || "0x" + this.code.toString(16)), n = this.options.render && this.options.render(this.code, i, r);
    if (n)
      return n;
    let s = document.createElement("span");
    return s.textContent = r, s.title = i, s.setAttribute("aria-label", i), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class hW extends Zi {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function pW() {
  return fW;
}
const dW = /* @__PURE__ */ xe.line({ class: "cm-activeLine" }), fW = /* @__PURE__ */ ft.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, r = [];
    for (let i of t.state.selection.ranges) {
      let n = t.lineBlockAt(i.head);
      n.from > e && (r.push(dW.range(n.from)), e = n.from);
    }
    return xe.set(r);
  }
}, {
  decorations: (t) => t.decorations
});
class mW extends Zi {
  constructor(e) {
    super(), this.content = e;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content), typeof this.content == "string" ? e.setAttribute("aria-label", "placeholder " + this.content) : e.setAttribute("aria-hidden", "true"), e;
  }
  coordsAt(e) {
    let r = e.firstChild ? _a(e.firstChild) : [];
    if (!r.length)
      return null;
    let i = window.getComputedStyle(e.parentNode), n = ip(r[0], i.direction != "rtl"), s = parseInt(i.lineHeight);
    return n.bottom - n.top > s * 1.5 ? { left: n.left, right: n.right, top: n.top, bottom: n.top + s } : n;
  }
  ignoreEvent() {
    return !1;
  }
}
function gW(t) {
  return ft.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = t ? xe.set([xe.widget({ widget: new mW(t), side: 1 }).range(0)]) : xe.none;
    }
    get decorations() {
      return this.view.state.doc.length ? xe.none : this.placeholder;
    }
  }, { decorations: (e) => e.decorations });
}
const rm = 2e3;
function yW(t, e, r) {
  let i = Math.min(e.line, r.line), n = Math.max(e.line, r.line), s = [];
  if (e.off > rm || r.off > rm || e.col < 0 || r.col < 0) {
    let a = Math.min(e.off, r.off), o = Math.max(e.off, r.off);
    for (let u = i; u <= n; u++) {
      let c = t.doc.line(u);
      c.length <= o && s.push(U.range(c.from + a, c.to + o));
    }
  } else {
    let a = Math.min(e.col, r.col), o = Math.max(e.col, r.col);
    for (let u = i; u <= n; u++) {
      let c = t.doc.line(u), h = If(c.text, a, t.tabSize, !0);
      if (h < 0)
        s.push(U.cursor(c.to));
      else {
        let d = If(c.text, o, t.tabSize);
        s.push(U.range(c.from + h, c.from + d));
      }
    }
  }
  return s;
}
function OW(t, e) {
  let r = t.coordsAtPos(t.viewport.from);
  return r ? Math.round(Math.abs((r.left - e) / t.defaultCharacterWidth)) : -1;
}
function X1(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), i = t.state.doc.lineAt(r), n = r - i.from, s = n > rm ? -1 : n == i.length ? OW(t, e.clientX) : ro(i.text, t.state.tabSize, r - i.from);
  return { line: i.number, col: s, off: n };
}
function xW(t, e) {
  let r = X1(t, e), i = t.state.selection;
  return r ? {
    update(n) {
      if (n.docChanged) {
        let s = n.changes.mapPos(n.startState.doc.line(r.line).from), a = n.state.doc.lineAt(s);
        r = { line: a.number, col: r.col, off: Math.min(r.off, a.length) }, i = i.map(n.changes);
      }
    },
    get(n, s, a) {
      let o = X1(t, n);
      if (!o)
        return i;
      let u = yW(t.state, r, o);
      return u.length ? a ? U.create(u.concat(i.ranges)) : U.create(u) : i;
    }
  } : null;
}
function bW(t) {
  let e = (t == null ? void 0 : t.eventFilter) || ((r) => r.altKey && r.button == 0);
  return oe.mouseSelectionStyle.of((r, i) => e(i) ? xW(r, i) : null);
}
const DW = {
  Alt: [18, (t) => !!t.altKey],
  Control: [17, (t) => !!t.ctrlKey],
  Shift: [16, (t) => !!t.shiftKey],
  Meta: [91, (t) => !!t.metaKey]
}, vW = { style: "cursor: crosshair" };
function SW(t = {}) {
  let [e, r] = DW[t.key || "Alt"], i = ft.fromClass(class {
    constructor(n) {
      this.view = n, this.isDown = !1;
    }
    set(n) {
      this.isDown != n && (this.isDown = n, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(n) {
        this.set(n.keyCode == e || r(n));
      },
      keyup(n) {
        (n.keyCode == e || !r(n)) && this.set(!1);
      },
      mousemove(n) {
        this.set(r(n));
      }
    }
  });
  return [
    i,
    oe.contentAttributes.of((n) => {
      var s;
      return !((s = n.plugin(i)) === null || s === void 0) && s.isDown ? vW : null;
    })
  ];
}
const wo = "-10000px";
class JC {
  constructor(e, r, i, n) {
    this.facet = r, this.createTooltipView = i, this.removeTooltipView = n, this.input = e.state.facet(r), this.tooltips = this.input.filter((a) => a);
    let s = null;
    this.tooltipViews = this.tooltips.map((a) => s = i(a, s));
  }
  update(e, r) {
    var i;
    let n = e.state.facet(this.facet), s = n.filter((u) => u);
    if (n === this.input) {
      for (let u of this.tooltipViews)
        u.update && u.update(e);
      return !1;
    }
    let a = [], o = r ? [] : null;
    for (let u = 0; u < s.length; u++) {
      let c = s[u], h = -1;
      if (c) {
        for (let d = 0; d < this.tooltips.length; d++) {
          let m = this.tooltips[d];
          m && m.create == c.create && (h = d);
        }
        if (h < 0)
          a[u] = this.createTooltipView(c, u ? a[u - 1] : null), o && (o[u] = !!c.above);
        else {
          let d = a[u] = this.tooltipViews[h];
          o && (o[u] = r[h]), d.update && d.update(e);
        }
      }
    }
    for (let u of this.tooltipViews)
      a.indexOf(u) < 0 && (this.removeTooltipView(u), (i = u.destroy) === null || i === void 0 || i.call(u));
    return r && (o.forEach((u, c) => r[c] = u), r.length = o.length), this.input = n, this.tooltips = s, this.tooltipViews = a, !0;
  }
}
function wW(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const hd = /* @__PURE__ */ fe.define({
  combine: (t) => {
    var e, r, i;
    return {
      position: ge.ios ? "absolute" : ((e = t.find((n) => n.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((r = t.find((n) => n.parent)) === null || r === void 0 ? void 0 : r.parent) || null,
      tooltipSpace: ((i = t.find((n) => n.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || wW
    };
  }
}), V1 = /* @__PURE__ */ new WeakMap(), dy = /* @__PURE__ */ ft.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(hd);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new JC(t, fy, (r, i) => this.createTooltip(r, i), (r) => {
      this.resizeObserver && this.resizeObserver.unobserve(r.dom), r.dom.remove();
    }), this.above = this.manager.tooltips.map((r) => !!r.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((r) => {
      Date.now() > this.lastTransaction - 50 && r.length > 0 && r[r.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let r = e || t.geometryChanged, i = t.state.facet(hd);
    if (i.position != this.position && !this.madeAbsolute) {
      this.position = i.position;
      for (let n of this.manager.tooltipViews)
        n.dom.style.position = this.position;
      r = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let n of this.manager.tooltipViews)
        this.container.appendChild(n.dom);
      r = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    r && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let r = t.create(this.view), i = e ? e.dom : null;
    if (r.dom.classList.add("cm-tooltip"), t.arrow && !r.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let n = document.createElement("div");
      n.className = "cm-tooltip-arrow", r.dom.insertBefore(n, i);
    }
    return r.dom.style.position = this.position, r.dom.style.top = wo, r.dom.style.left = "0px", this.container.insertBefore(r.dom, i), r.mount && r.mount(this.view), this.resizeObserver && this.resizeObserver.observe(r.dom), r;
  }
  destroy() {
    var t, e, r;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let i of this.manager.tooltipViews)
      i.dom.remove(), (t = i.destroy) === null || t === void 0 || t.call(i);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (r = this.intersectionObserver) === null || r === void 0 || r.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = this.view.dom.getBoundingClientRect(), e = 1, r = 1, i = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: n } = this.manager.tooltipViews[0];
      if (ge.gecko)
        i = n.offsetParent != this.container.ownerDocument.body;
      else if (n.style.top == wo && n.style.left == "0px") {
        let s = n.getBoundingClientRect();
        i = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (i || this.position == "absolute")
      if (this.parent) {
        let n = this.parent.getBoundingClientRect();
        n.width && n.height && (e = n.width / this.parent.offsetWidth, r = n.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: r } = this.view.viewState);
    return {
      editor: t,
      parent: this.parent ? this.container.getBoundingClientRect() : t,
      pos: this.manager.tooltips.map((n, s) => {
        let a = this.manager.tooltipViews[s];
        return a.getCoords ? a.getCoords(n.pos) : this.view.coordsAtPos(n.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: n }) => n.getBoundingClientRect()),
      space: this.view.state.facet(hd).tooltipSpace(this.view),
      scaleX: e,
      scaleY: r,
      makeAbsolute: i
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let o of this.manager.tooltipViews)
        o.dom.style.position = "absolute";
    }
    let { editor: r, space: i, scaleX: n, scaleY: s } = t, a = [];
    for (let o = 0; o < this.manager.tooltips.length; o++) {
      let u = this.manager.tooltips[o], c = this.manager.tooltipViews[o], { dom: h } = c, d = t.pos[o], m = t.size[o];
      if (!d || d.bottom <= Math.max(r.top, i.top) || d.top >= Math.min(r.bottom, i.bottom) || d.right < Math.max(r.left, i.left) - 0.1 || d.left > Math.min(r.right, i.right) + 0.1) {
        h.style.top = wo;
        continue;
      }
      let y = u.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, O = y ? 7 : 0, b = m.right - m.left, v = (e = V1.get(c)) !== null && e !== void 0 ? e : m.bottom - m.top, S = c.offset || AW, x = this.view.textDirection == it.LTR, w = m.width > i.right - i.left ? x ? i.left : i.right - m.width : x ? Math.min(d.left - (y ? 14 : 0) + S.x, i.right - b) : Math.max(i.left, d.left - b + (y ? 14 : 0) - S.x), k = this.above[o];
      !u.strictSide && (k ? d.top - (m.bottom - m.top) - S.y < i.top : d.bottom + (m.bottom - m.top) + S.y > i.bottom) && k == i.bottom - d.bottom > d.top - i.top && (k = this.above[o] = !k);
      let C = (k ? d.top - i.top : i.bottom - d.bottom) - O;
      if (C < v && c.resize !== !1) {
        if (C < this.view.defaultLineHeight) {
          h.style.top = wo;
          continue;
        }
        V1.set(c, v), h.style.height = (v = C) / s + "px";
      } else
        h.style.height && (h.style.height = "");
      let E = k ? d.top - v - O - S.y : d.bottom + O + S.y, P = w + b;
      if (c.overlap !== !0)
        for (let I of a)
          I.left < P && I.right > w && I.top < E + v && I.bottom > E && (E = k ? I.top - v - 2 - O : I.bottom + O + 2);
      if (this.position == "absolute" ? (h.style.top = (E - t.parent.top) / s + "px", h.style.left = (w - t.parent.left) / n + "px") : (h.style.top = E / s + "px", h.style.left = w / n + "px"), y) {
        let I = d.left + (x ? S.x : -S.x) - (w + 14 - 7);
        y.style.left = I / n + "px";
      }
      c.overlap !== !0 && a.push({ left: w, top: E, right: P, bottom: E + v }), h.classList.toggle("cm-tooltip-above", k), h.classList.toggle("cm-tooltip-below", !k), c.positioned && c.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = wo;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), CW = /* @__PURE__ */ oe.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), AW = { x: 0, y: 0 }, fy = /* @__PURE__ */ fe.define({
  enables: [dy, CW]
}), Zc = /* @__PURE__ */ fe.define({
  combine: (t) => t.reduce((e, r) => e.concat(r), [])
});
class ap {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new ap(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new JC(e, Zc, (r, i) => this.createHostedView(r, i), (r) => r.dom.remove());
  }
  createHostedView(e, r) {
    let i = e.create(this.view);
    return i.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(i.dom, r ? r.dom.nextSibling : this.dom.firstChild), this.mounted && i.mount && i.mount(this.view), i;
  }
  mount(e) {
    for (let r of this.manager.tooltipViews)
      r.mount && r.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let r of this.manager.tooltipViews)
      r.positioned && r.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let r of this.manager.tooltipViews)
      (e = r.destroy) === null || e === void 0 || e.call(r);
  }
  passProp(e) {
    let r;
    for (let i of this.manager.tooltipViews) {
      let n = i[e];
      if (n !== void 0) {
        if (r === void 0)
          r = n;
        else if (r !== n)
          return;
      }
    }
    return r;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const EW = /* @__PURE__ */ fy.compute([Zc], (t) => {
  let e = t.facet(Zc);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((r) => r.pos)),
    end: Math.max(...e.map((r) => {
      var i;
      return (i = r.end) !== null && i !== void 0 ? i : r.pos;
    })),
    create: ap.create,
    above: e[0].above,
    arrow: e.some((r) => r.arrow)
  };
});
class kW {
  constructor(e, r, i, n, s) {
    this.view = e, this.source = r, this.field = i, this.setHover = n, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: r } = this, i = e.docView.nearest(r.target);
    if (!i)
      return;
    let n, s = 1;
    if (i instanceof $n)
      n = i.posAtStart;
    else {
      if (n = e.posAtCoords(r), n == null)
        return;
      let o = e.coordsAtPos(n);
      if (!o || r.y < o.top || r.y > o.bottom || r.x < o.left - e.defaultCharacterWidth || r.x > o.right + e.defaultCharacterWidth)
        return;
      let u = e.bidiSpans(e.state.doc.lineAt(n)).find((h) => h.from <= n && h.to >= n), c = u && u.dir == it.RTL ? -1 : 1;
      s = r.x < o.left ? -c : c;
    }
    let a = this.source(e, n, s);
    if (a != null && a.then) {
      let o = this.pending = { pos: n };
      a.then((u) => {
        this.pending == o && (this.pending = null, u && !(Array.isArray(u) && !u.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(u) ? u : [u]) }));
      }, (u) => Mr(e.state, u, "hover tooltip"));
    } else
      a && !(Array.isArray(a) && !a.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(a) ? a : [a]) });
  }
  get tooltip() {
    let e = this.view.plugin(dy), r = e ? e.manager.tooltips.findIndex((i) => i.create == ap.create) : -1;
    return r > -1 ? e.manager.tooltipViews[r] : null;
  }
  mousemove(e) {
    var r, i;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: n, tooltip: s } = this;
    if (n.length && s && !TW(s.dom, e) || this.pending) {
      let { pos: a } = n[0] || this.pending, o = (i = (r = n[0]) === null || r === void 0 ? void 0 : r.end) !== null && i !== void 0 ? i : a;
      (a == o ? this.view.posAtCoords(this.lastMove) != a : !PW(this.view, a, o, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: r } = this;
    if (r.length) {
      let { tooltip: i } = this;
      i && i.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(i.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let r = (i) => {
      e.removeEventListener("mouseleave", r), this.active.length && !this.view.dom.contains(i.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", r);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const Wu = 4;
function TW(t, e) {
  let r = t.getBoundingClientRect();
  return e.clientX >= r.left - Wu && e.clientX <= r.right + Wu && e.clientY >= r.top - Wu && e.clientY <= r.bottom + Wu;
}
function PW(t, e, r, i, n, s) {
  let a = t.scrollDOM.getBoundingClientRect(), o = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (a.left > i || a.right < i || a.top > n || Math.min(a.bottom, o) < n)
    return !1;
  let u = t.posAtCoords({ x: i, y: n }, !1);
  return u >= e && u <= r;
}
function FW(t, e = {}) {
  let r = we.define(), i = St.define({
    create() {
      return [];
    },
    update(n, s) {
      if (n.length && (e.hideOnChange && (s.docChanged || s.selection) ? n = [] : e.hideOn && (n = n.filter((a) => !e.hideOn(s, a))), s.docChanged))
        for (let a of n) {
          let o = s.changes.mapPos(a.pos, -1, Pt.TrackDel);
          if (o != null) {
            let u = Object.assign(/* @__PURE__ */ Object.create(null), a);
            u.pos = o, u.end != null && (u.end = s.changes.mapPos(u.end));
          }
        }
      for (let a of s.effects)
        a.is(r) && (n = a.value), a.is($W) && (n = []);
      return n;
    },
    provide: (n) => Zc.from(n)
  });
  return [
    i,
    ft.define((n) => new kW(
      n,
      t,
      i,
      r,
      e.hoverTime || 300
      /* Hover.Time */
    )),
    EW
  ];
}
function KC(t, e) {
  let r = t.plugin(dy);
  if (!r)
    return null;
  let i = r.manager.tooltips.indexOf(e);
  return i < 0 ? null : r.manager.tooltipViews[i];
}
const $W = /* @__PURE__ */ we.define(), Y1 = /* @__PURE__ */ fe.define({
  combine(t) {
    let e, r;
    for (let i of t)
      e = e || i.topContainer, r = r || i.bottomContainer;
    return { topContainer: e, bottomContainer: r };
  }
});
function Ol(t, e) {
  let r = t.plugin(eA), i = r ? r.specs.indexOf(e) : -1;
  return i > -1 ? r.panels[i] : null;
}
const eA = /* @__PURE__ */ ft.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(xl), this.specs = this.input.filter((r) => r), this.panels = this.specs.map((r) => r(t));
    let e = t.state.facet(Y1);
    this.top = new qu(t, !0, e.topContainer), this.bottom = new qu(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((r) => r.top)), this.bottom.sync(this.panels.filter((r) => !r.top));
    for (let r of this.panels)
      r.dom.classList.add("cm-panel"), r.mount && r.mount();
  }
  update(t) {
    let e = t.state.facet(Y1);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new qu(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new qu(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let r = t.state.facet(xl);
    if (r != this.input) {
      let i = r.filter((u) => u), n = [], s = [], a = [], o = [];
      for (let u of i) {
        let c = this.specs.indexOf(u), h;
        c < 0 ? (h = u(t.view), o.push(h)) : (h = this.panels[c], h.update && h.update(t)), n.push(h), (h.top ? s : a).push(h);
      }
      this.specs = i, this.panels = n, this.top.sync(s), this.bottom.sync(a);
      for (let u of o)
        u.dom.classList.add("cm-panel"), u.mount && u.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => oe.scrollMargins.of((e) => {
    let r = e.plugin(t);
    return r && { top: r.top.scrollMargin(), bottom: r.bottom.scrollMargin() };
  })
});
class qu {
  constructor(e, r, i) {
    this.view = e, this.top = r, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let r of this.panels)
      r.destroy && e.indexOf(r) < 0 && r.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let r = this.container || this.view.dom;
      r.insertBefore(this.dom, this.top ? r.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let r of this.panels)
      if (r.dom.parentNode == this.dom) {
        for (; e != r.dom; )
          e = U1(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(r.dom, e);
    for (; e; )
      e = U1(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function U1(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const xl = /* @__PURE__ */ fe.define({
  enables: eA
});
class sn extends ks {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
sn.prototype.elementClass = "";
sn.prototype.toDOM = void 0;
sn.prototype.mapMode = Pt.TrackBefore;
sn.prototype.startSide = sn.prototype.endSide = -1;
sn.prototype.point = !0;
const yc = /* @__PURE__ */ fe.define(), BW = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Me.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, tl = /* @__PURE__ */ fe.define();
function IW(t) {
  return [tA(), tl.of(Object.assign(Object.assign({}, BW), t))];
}
const im = /* @__PURE__ */ fe.define({
  combine: (t) => t.some((e) => e)
});
function tA(t) {
  let e = [
    NW
  ];
  return t && t.fixed === !1 && e.push(im.of(!0)), e;
}
const NW = /* @__PURE__ */ ft.fromClass(class {
  constructor(t) {
    this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(tl).map((e) => new G1(t, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !t.state.facet(im), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, r = t.view.viewport, i = Math.min(e.to, r.to) - Math.max(e.from, r.from);
      this.syncGutters(i < (r.to - r.from) * 0.8);
    }
    t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(im) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && this.dom.remove();
    let r = Me.iter(this.view.state.facet(yc), this.view.viewport.from), i = [], n = this.gutters.map((s) => new _W(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(s.type)) {
        let a = !0;
        for (let o of s.type)
          if (o.type == Jt.Text && a) {
            nm(r, i, o.from);
            for (let u of n)
              u.line(this.view, o, i);
            a = !1;
          } else if (o.widget)
            for (let u of n)
              u.widget(this.view, o);
      } else if (s.type == Jt.Text) {
        nm(r, i, s.from);
        for (let a of n)
          a.line(this.view, s, i);
      } else if (s.widget)
        for (let a of n)
          a.widget(this.view, s);
    for (let s of n)
      s.finish();
    t && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(t) {
    let e = t.startState.facet(tl), r = t.state.facet(tl), i = t.docChanged || t.heightChanged || t.viewportChanged || !Me.eq(t.startState.facet(yc), t.state.facet(yc), t.view.viewport.from, t.view.viewport.to);
    if (e == r)
      for (let n of this.gutters)
        n.update(t) && (i = !0);
    else {
      i = !0;
      let n = [];
      for (let s of r) {
        let a = e.indexOf(s);
        a < 0 ? n.push(new G1(this.view, s)) : (this.gutters[a].update(t), n.push(this.gutters[a]));
      }
      for (let s of this.gutters)
        s.dom.remove(), n.indexOf(s) < 0 && s.destroy();
      for (let s of n)
        this.dom.appendChild(s.dom);
      this.gutters = n;
    }
    return i;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove();
  }
}, {
  provide: (t) => oe.scrollMargins.of((e) => {
    let r = e.plugin(t);
    return !r || r.gutters.length == 0 || !r.fixed ? null : e.textDirection == it.LTR ? { left: r.dom.offsetWidth * e.scaleX } : { right: r.dom.offsetWidth * e.scaleX };
  })
});
function z1(t) {
  return Array.isArray(t) ? t : [t];
}
function nm(t, e, r) {
  for (; t.value && t.from <= r; )
    t.from == r && e.push(t.value), t.next();
}
class _W {
  constructor(e, r, i) {
    this.gutter = e, this.height = i, this.i = 0, this.cursor = Me.iter(e.markers, r.from);
  }
  addElement(e, r, i) {
    let { gutter: n } = this, s = (r.top - this.height) / e.scaleY, a = r.height / e.scaleY;
    if (this.i == n.elements.length) {
      let o = new rA(e, a, s, i);
      n.elements.push(o), n.dom.appendChild(o.dom);
    } else
      n.elements[this.i].update(e, a, s, i);
    this.height = r.bottom, this.i++;
  }
  line(e, r, i) {
    let n = [];
    nm(this.cursor, n, r.from), i.length && (n = n.concat(i));
    let s = this.gutter.config.lineMarker(e, r, n);
    s && n.unshift(s);
    let a = this.gutter;
    n.length == 0 && !a.config.renderEmptyElements || this.addElement(e, r, n);
  }
  widget(e, r) {
    let i = this.gutter.config.widgetMarker(e, r.widget, r);
    i && this.addElement(e, r, [i]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let r = e.elements.pop();
      e.dom.removeChild(r.dom), r.destroy();
    }
  }
}
class G1 {
  constructor(e, r) {
    this.view = e, this.config = r, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in r.domEventHandlers)
      this.dom.addEventListener(i, (n) => {
        let s = n.target, a;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let u = s.getBoundingClientRect();
          a = (u.top + u.bottom) / 2;
        } else
          a = n.clientY;
        let o = e.lineBlockAtHeight(a - e.documentTop);
        r.domEventHandlers[i](e, o, n) && n.preventDefault();
      });
    this.markers = z1(r.markers(e)), r.initialSpacer && (this.spacer = new rA(e, 0, 0, [r.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let r = this.markers;
    if (this.markers = z1(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let n = this.config.updateSpacer(this.spacer.markers[0], e);
      n != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [n]);
    }
    let i = e.view.viewport;
    return !Me.eq(this.markers, r, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class rA {
  constructor(e, r, i, n) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, r, i, n);
  }
  update(e, r, i, n) {
    this.height != r && (this.height = r, this.dom.style.height = r + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), QW(this.markers, n) || this.setMarkers(e, n);
  }
  setMarkers(e, r) {
    let i = "cm-gutterElement", n = this.dom.firstChild;
    for (let s = 0, a = 0; ; ) {
      let o = a, u = s < r.length ? r[s++] : null, c = !1;
      if (u) {
        let h = u.elementClass;
        h && (i += " " + h);
        for (let d = a; d < this.markers.length; d++)
          if (this.markers[d].compare(u)) {
            o = d, c = !0;
            break;
          }
      } else
        o = this.markers.length;
      for (; a < o; ) {
        let h = this.markers[a++];
        if (h.toDOM) {
          h.destroy(n);
          let d = n.nextSibling;
          n.remove(), n = d;
        }
      }
      if (!u)
        break;
      u.toDOM && (c ? n = n.nextSibling : this.dom.insertBefore(u.toDOM(e), n)), c && a++;
    }
    this.dom.className = i, this.markers = r;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function QW(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!t[r].compare(e[r]))
      return !1;
  return !0;
}
const MW = /* @__PURE__ */ fe.define(), ga = /* @__PURE__ */ fe.define({
  combine(t) {
    return ji(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, r) {
        let i = Object.assign({}, e);
        for (let n in r) {
          let s = i[n], a = r[n];
          i[n] = s ? (o, u, c) => s(o, u, c) || a(o, u, c) : a;
        }
        return i;
      }
    });
  }
});
class pd extends sn {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function dd(t, e) {
  return t.state.facet(ga).formatNumber(e, t.state);
}
const LW = /* @__PURE__ */ tl.compute([ga], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(MW);
  },
  lineMarker(e, r, i) {
    return i.some((n) => n.toDOM) ? null : new pd(dd(e, e.state.doc.lineAt(r.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(ga) != e.state.facet(ga),
  initialSpacer(e) {
    return new pd(dd(e, H1(e.state.doc.lines)));
  },
  updateSpacer(e, r) {
    let i = dd(r.view, H1(r.view.state.doc.lines));
    return i == e.number ? e : new pd(i);
  },
  domEventHandlers: t.facet(ga).domEventHandlers
}));
function RW(t = {}) {
  return [
    ga.of(t),
    tA(),
    LW
  ];
}
function H1(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const jW = /* @__PURE__ */ new class extends sn {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), ZW = /* @__PURE__ */ yc.compute(["selection"], (t) => {
  let e = [], r = -1;
  for (let i of t.selection.ranges) {
    let n = t.doc.lineAt(i.head).from;
    n > r && (r = n, e.push(jW.range(n)));
  }
  return Me.of(e);
});
function WW() {
  return ZW;
}
const iA = 1024;
let qW = 0;
class _r {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
class ke {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = qW++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = er.match(e)), (r) => {
      let i = e(r);
      return i === void 0 ? null : [this, i];
    };
  }
}
ke.closedBy = new ke({ deserialize: (t) => t.split(" ") });
ke.openedBy = new ke({ deserialize: (t) => t.split(" ") });
ke.group = new ke({ deserialize: (t) => t.split(" ") });
ke.isolate = new ke({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
ke.contextHash = new ke({ perNode: !0 });
ke.lookAhead = new ke({ perNode: !0 });
ke.mounted = new ke({ perNode: !0 });
class bl {
  constructor(e, r, i) {
    this.tree = e, this.overlay = r, this.parser = i;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[ke.mounted.id];
  }
}
const XW = /* @__PURE__ */ Object.create(null);
class er {
  /**
  @internal
  */
  constructor(e, r, i, n = 0) {
    this.name = e, this.props = r, this.id = i, this.flags = n;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let r = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : XW, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), n = new er(e.name || "", r, e.id, i);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(n)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          r[s[0].id] = s[1];
        }
    }
    return n;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let r = this.prop(ke.group);
      return r ? r.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in e)
      for (let n of i.split(" "))
        r[n] = e[i];
    return (i) => {
      for (let n = i.prop(ke.group), s = -1; s < (n ? n.length : 0); s++) {
        let a = r[s < 0 ? i.name : n[s]];
        if (a)
          return a;
      }
    };
  }
}
er.none = new er(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class my {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let r = 0; r < e.length; r++)
      if (e[r].id != r)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let r = [];
    for (let i of this.types) {
      let n = null;
      for (let s of e) {
        let a = s(i);
        a && (n || (n = Object.assign({}, i.props)), n[a[0].id] = a[1]);
      }
      r.push(n ? new er(i.name, n, i.id, i.flags) : i);
    }
    return new my(r);
  }
}
const Xu = /* @__PURE__ */ new WeakMap(), J1 = /* @__PURE__ */ new WeakMap();
var Ke;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Ke || (Ke = {}));
class ut {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, r, i, n, s) {
    if (this.type = e, this.children = r, this.positions = i, this.length = n, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [a, o] of s)
        this.props[typeof a == "number" ? a : a.id] = o;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = bl.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let r = "";
    for (let i of this.children) {
      let n = i.toString();
      n && (r && (r += ","), r += n);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (r.length ? "(" + r + ")" : "") : r;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new Wc(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, r = 0, i = 0) {
    let n = Xu.get(this) || this.topNode, s = new Wc(n);
    return s.moveTo(e, r), Xu.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Xt(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, r = 0) {
    let i = Dl(Xu.get(this) || this.topNode, e, r, !1);
    return Xu.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, r = 0) {
    let i = Dl(J1.get(this) || this.topNode, e, r, !0);
    return J1.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, r = 0) {
    return UW(this, e, r);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: r, leave: i, from: n = 0, to: s = this.length } = e, a = e.mode || 0, o = (a & Ke.IncludeAnonymous) > 0;
    for (let u = this.cursor(a | Ke.IncludeAnonymous); ; ) {
      let c = !1;
      if (u.from <= s && u.to >= n && (!o && u.type.isAnonymous || r(u) !== !1)) {
        if (u.firstChild())
          continue;
        c = !0;
      }
      for (; c && i && (o || !u.type.isAnonymous) && i(u), !u.nextSibling(); ) {
        if (!u.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let r in this.props)
        e.push([+r, this.props[r]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : Oy(er.none, this.children, this.positions, 0, this.children.length, 0, this.length, (r, i, n) => new ut(this.type, r, i, n, this.propValues), e.makeTree || ((r, i, n) => new ut(er.none, r, i, n)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return zW(e);
  }
}
ut.empty = new ut(er.none, [], [], 0);
class gy {
  constructor(e, r) {
    this.buffer = e, this.index = r;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new gy(this.buffer, this.index);
  }
}
class Un {
  /**
  Create a tree buffer.
  */
  constructor(e, r, i) {
    this.buffer = e, this.length = r, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return er.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let r = 0; r < this.buffer.length; )
      e.push(this.childString(r)), r = this.buffer[r + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let r = this.buffer[e], i = this.buffer[e + 3], n = this.set.types[r], s = n.name;
    if (/\W/.test(s) && !n.isError && (s = JSON.stringify(s)), e += 4, i == e)
      return s;
    let a = [];
    for (; e < i; )
      a.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + a.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, r, i, n, s) {
    let { buffer: a } = this, o = -1;
    for (let u = e; u != r && !(nA(s, n, a[u + 1], a[u + 2]) && (o = u, i > 0)); u = a[u + 3])
      ;
    return o;
  }
  /**
  @internal
  */
  slice(e, r, i) {
    let n = this.buffer, s = new Uint16Array(r - e), a = 0;
    for (let o = e, u = 0; o < r; ) {
      s[u++] = n[o++], s[u++] = n[o++] - i;
      let c = s[u++] = n[o++] - i;
      s[u++] = n[o++] - e, a = Math.max(a, c);
    }
    return new Un(s, a, this.set);
  }
}
function nA(t, e, r, i) {
  switch (t) {
    case -2:
      return r < e;
    case -1:
      return i >= e && r < e;
    case 0:
      return r < e && i > e;
    case 1:
      return r <= e && i > e;
    case 2:
      return i > e;
    case 4:
      return !0;
  }
}
function Dl(t, e, r, i) {
  for (var n; t.from == t.to || (r < 1 ? t.from >= e : t.from > e) || (r > -1 ? t.to <= e : t.to < e); ) {
    let a = !i && t instanceof Xt && t.index < 0 ? null : t.parent;
    if (!a)
      return t;
    t = a;
  }
  let s = i ? 0 : Ke.IgnoreOverlays;
  if (i)
    for (let a = t, o = a.parent; o; a = o, o = a.parent)
      a instanceof Xt && a.index < 0 && ((n = o.enter(e, r, s)) === null || n === void 0 ? void 0 : n.from) != a.from && (t = o);
  for (; ; ) {
    let a = t.enter(e, r, s);
    if (!a)
      return t;
    t = a;
  }
}
class sA {
  cursor(e = 0) {
    return new Wc(this, e);
  }
  getChild(e, r = null, i = null) {
    let n = K1(this, e, r, i);
    return n.length ? n[0] : null;
  }
  getChildren(e, r = null, i = null) {
    return K1(this, e, r, i);
  }
  resolve(e, r = 0) {
    return Dl(this, e, r, !1);
  }
  resolveInner(e, r = 0) {
    return Dl(this, e, r, !0);
  }
  matchContext(e) {
    return sm(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let r = this.childBefore(e), i = this;
    for (; r; ) {
      let n = r.lastChild;
      if (!n || n.to != r.to)
        break;
      n.type.isError && n.from == n.to ? (i = r, r = n.prevSibling) : r = n;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Xt extends sA {
  constructor(e, r, i, n) {
    super(), this._tree = e, this.from = r, this.index = i, this._parent = n;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, r, i, n, s = 0) {
    for (let a = this; ; ) {
      for (let { children: o, positions: u } = a._tree, c = r > 0 ? o.length : -1; e != c; e += r) {
        let h = o[e], d = u[e] + a.from;
        if (nA(n, i, d, d + h.length)) {
          if (h instanceof Un) {
            if (s & Ke.ExcludeBuffers)
              continue;
            let m = h.findChild(0, h.buffer.length, r, i - d, n);
            if (m > -1)
              return new Ai(new VW(a, h, e, d), null, m);
          } else if (s & Ke.IncludeAnonymous || !h.type.isAnonymous || yy(h)) {
            let m;
            if (!(s & Ke.IgnoreMounts) && (m = bl.get(h)) && !m.overlay)
              return new Xt(m.tree, d, e, a);
            let y = new Xt(h, d, e, a);
            return s & Ke.IncludeAnonymous || !y.type.isAnonymous ? y : y.nextChild(r < 0 ? h.children.length - 1 : 0, r, i, n);
          }
        }
      }
      if (s & Ke.IncludeAnonymous || !a.type.isAnonymous || (a.index >= 0 ? e = a.index + r : e = r < 0 ? -1 : a._parent._tree.children.length, a = a._parent, !a))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, i = 0) {
    let n;
    if (!(i & Ke.IgnoreOverlays) && (n = bl.get(this._tree)) && n.overlay) {
      let s = e - this.from;
      for (let { from: a, to: o } of n.overlay)
        if ((r > 0 ? a <= s : a < s) && (r < 0 ? o >= s : o > s))
          return new Xt(n.tree, n.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, r, i);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function K1(t, e, r, i) {
  let n = t.cursor(), s = [];
  if (!n.firstChild())
    return s;
  if (r != null) {
    for (let a = !1; !a; )
      if (a = n.type.is(r), !n.nextSibling())
        return s;
  }
  for (; ; ) {
    if (i != null && n.type.is(i))
      return s;
    if (n.type.is(e) && s.push(n.node), !n.nextSibling())
      return i == null ? s : [];
  }
}
function sm(t, e, r = e.length - 1) {
  for (let i = t.parent; r >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (e[r] && e[r] != i.name)
        return !1;
      r--;
    }
  }
  return !0;
}
class VW {
  constructor(e, r, i, n) {
    this.parent = e, this.buffer = r, this.index = i, this.start = n;
  }
}
class Ai extends sA {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, r, i) {
    super(), this.context = e, this._parent = r, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]];
  }
  child(e, r, i) {
    let { buffer: n } = this.context, s = n.findChild(this.index + 4, n.buffer[this.index + 3], e, r - this.context.start, i);
    return s < 0 ? null : new Ai(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, i = 0) {
    if (i & Ke.ExcludeBuffers)
      return null;
    let { buffer: n } = this.context, s = n.findChild(this.index + 4, n.buffer[this.index + 3], r > 0 ? 1 : -1, e - this.context.start, r);
    return s < 0 ? null : new Ai(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, r = e.buffer[this.index + 3];
    return r < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Ai(this.context, this._parent, r) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, r = this._parent ? this._parent.index + 4 : 0;
    return this.index == r ? this.externalSibling(-1) : new Ai(this.context, this._parent, e.findChild(
      r,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], r = [], { buffer: i } = this.context, n = this.index + 4, s = i.buffer[this.index + 3];
    if (s > n) {
      let a = i.buffer[this.index + 1];
      e.push(i.slice(n, s, a)), r.push(0);
    }
    return new ut(this.type, e, r, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function aA(t) {
  if (!t.length)
    return null;
  let e = 0, r = t[0];
  for (let s = 1; s < t.length; s++) {
    let a = t[s];
    (a.from > r.from || a.to < r.to) && (r = a, e = s);
  }
  let i = r instanceof Xt && r.index < 0 ? null : r.parent, n = t.slice();
  return i ? n[e] = i : n.splice(e, 1), new YW(n, r);
}
class YW {
  constructor(e, r) {
    this.heads = e, this.node = r;
  }
  get next() {
    return aA(this.heads);
  }
}
function UW(t, e, r) {
  let i = t.resolveInner(e, r), n = null;
  for (let s = i instanceof Xt ? i : i.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let a = s.parent;
      (n || (n = [i])).push(a.resolve(e, r)), s = a;
    } else {
      let a = bl.get(s.tree);
      if (a && a.overlay && a.overlay[0].from <= e && a.overlay[a.overlay.length - 1].to >= e) {
        let o = new Xt(a.tree, a.overlay[0].from + s.from, -1, s);
        (n || (n = [i])).push(Dl(o, e, r, !1));
      }
    }
  return n ? aA(n) : i;
}
class Wc {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, r = 0) {
    if (this.mode = r, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Xt)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let i = e._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, r) {
    this.index = e;
    let { start: i, buffer: n } = this.buffer;
    return this.type = r || n.set.types[n.buffer[e]], this.from = i + n.buffer[e + 1], this.to = i + n.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Xt ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, r, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, r, i, this.mode));
    let { buffer: n } = this.buffer, s = n.findChild(this.index + 4, n.buffer[this.index + 3], e, r - this.buffer.start, i);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, r, i = this.mode) {
    return this.buffer ? i & Ke.ExcludeBuffers ? !1 : this.enterChild(1, e, r) : this.yield(this._tree.enter(e, r, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Ke.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Ke.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: r } = this.buffer, i = this.stack.length - 1;
    if (e < 0) {
      let n = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != n)
        return this.yieldBuf(r.findChild(
          n,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let n = r.buffer[this.index + 3];
      if (n < (i < 0 ? r.buffer.length : r.buffer[this.stack[i] + 3]))
        return this.yieldBuf(n);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let r, i, { buffer: n } = this;
    if (n) {
      if (e > 0) {
        if (this.index < n.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (n.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: r, parent: i } = n);
    } else
      ({ index: r, _parent: i } = this._tree);
    for (; i; { index: r, _parent: i } = i)
      if (r > -1)
        for (let s = r + e, a = e < 0 ? -1 : i._tree.children.length; s != a; s += e) {
          let o = i._tree.children[s];
          if (this.mode & Ke.IncludeAnonymous || o instanceof Un || !o.type.isAnonymous || yy(o))
            return !1;
        }
    return !0;
  }
  move(e, r) {
    if (r && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, r = 0) {
    for (; (this.from == this.to || (r < 1 ? this.from >= e : this.from > e) || (r > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, r); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, r = null, i = 0;
    if (e && e.context == this.buffer)
      e:
        for (let n = this.index, s = this.stack.length; s >= 0; ) {
          for (let a = e; a; a = a._parent)
            if (a.index == n) {
              if (n == this.index)
                return a;
              r = a, i = s + 1;
              break e;
            }
          n = this.stack[--s];
        }
    for (let n = i; n < this.stack.length; n++)
      r = new Ai(this.buffer, r, this.stack[n]);
    return this.bufferNode = new Ai(this.buffer, r, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, r) {
    for (let i = 0; ; ) {
      let n = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (n = !0);
      }
      for (; n && r && r(this), n = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!i)
          return;
        this.parent(), i--, n = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return sm(this.node, e);
    let { buffer: r } = this.buffer, { types: i } = r.set;
    for (let n = e.length - 1, s = this.stack.length - 1; n >= 0; s--) {
      if (s < 0)
        return sm(this.node, e, n);
      let a = i[r.buffer[this.stack[s]]];
      if (!a.isAnonymous) {
        if (e[n] && e[n] != a.name)
          return !1;
        n--;
      }
    }
    return !0;
  }
}
function yy(t) {
  return t.children.some((e) => e instanceof Un || !e.type.isAnonymous || yy(e));
}
function zW(t) {
  var e;
  let { buffer: r, nodeSet: i, maxBufferLength: n = iA, reused: s = [], minRepeatType: a = i.types.length } = t, o = Array.isArray(r) ? new gy(r, r.length) : r, u = i.types, c = 0, h = 0;
  function d(C, E, P, I, B, Q) {
    let { id: j, start: G, end: J, size: L } = o, q = h;
    for (; L < 0; )
      if (o.next(), L == -1) {
        let ve = s[j];
        P.push(ve), I.push(G - C);
        return;
      } else if (L == -3) {
        c = j;
        return;
      } else if (L == -4) {
        h = j;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${L}`);
    let X = u[j], K, Oe, Ae = G - C;
    if (J - G <= n && (Oe = v(o.pos - E, B))) {
      let ve = new Uint16Array(Oe.size - Oe.skip), Le = o.pos - Oe.size, ze = ve.length;
      for (; o.pos > Le; )
        ze = S(Oe.start, ve, ze);
      K = new Un(ve, J - Oe.start, i), Ae = Oe.start - C;
    } else {
      let ve = o.pos - L;
      o.next();
      let Le = [], ze = [], et = j >= a ? j : -1, Fe = 0, mt = J;
      for (; o.pos > ve; )
        et >= 0 && o.id == et && o.size >= 0 ? (o.end <= mt - n && (O(Le, ze, G, Fe, o.end, mt, et, q), Fe = Le.length, mt = o.end), o.next()) : Q > 2500 ? m(G, ve, Le, ze) : d(G, ve, Le, ze, et, Q + 1);
      if (et >= 0 && Fe > 0 && Fe < Le.length && O(Le, ze, G, Fe, G, mt, et, q), Le.reverse(), ze.reverse(), et > -1 && Fe > 0) {
        let ue = y(X);
        K = Oy(X, Le, ze, 0, Le.length, 0, J - G, ue, ue);
      } else
        K = b(X, Le, ze, J - G, q - J);
    }
    P.push(K), I.push(Ae);
  }
  function m(C, E, P, I) {
    let B = [], Q = 0, j = -1;
    for (; o.pos > E; ) {
      let { id: G, start: J, end: L, size: q } = o;
      if (q > 4)
        o.next();
      else {
        if (j > -1 && J < j)
          break;
        j < 0 && (j = L - n), B.push(G, J, L), Q++, o.next();
      }
    }
    if (Q) {
      let G = new Uint16Array(Q * 4), J = B[B.length - 2];
      for (let L = B.length - 3, q = 0; L >= 0; L -= 3)
        G[q++] = B[L], G[q++] = B[L + 1] - J, G[q++] = B[L + 2] - J, G[q++] = q;
      P.push(new Un(G, B[2] - J, i)), I.push(J - C);
    }
  }
  function y(C) {
    return (E, P, I) => {
      let B = 0, Q = E.length - 1, j, G;
      if (Q >= 0 && (j = E[Q]) instanceof ut) {
        if (!Q && j.type == C && j.length == I)
          return j;
        (G = j.prop(ke.lookAhead)) && (B = P[Q] + j.length + G);
      }
      return b(C, E, P, I, B);
    };
  }
  function O(C, E, P, I, B, Q, j, G) {
    let J = [], L = [];
    for (; C.length > I; )
      J.push(C.pop()), L.push(E.pop() + P - B);
    C.push(b(i.types[j], J, L, Q - B, G - Q)), E.push(B - P);
  }
  function b(C, E, P, I, B = 0, Q) {
    if (c) {
      let j = [ke.contextHash, c];
      Q = Q ? [j].concat(Q) : [j];
    }
    if (B > 25) {
      let j = [ke.lookAhead, B];
      Q = Q ? [j].concat(Q) : [j];
    }
    return new ut(C, E, P, I, Q);
  }
  function v(C, E) {
    let P = o.fork(), I = 0, B = 0, Q = 0, j = P.end - n, G = { size: 0, start: 0, skip: 0 };
    e:
      for (let J = P.pos - C; P.pos > J; ) {
        let L = P.size;
        if (P.id == E && L >= 0) {
          G.size = I, G.start = B, G.skip = Q, Q += 4, I += 4, P.next();
          continue;
        }
        let q = P.pos - L;
        if (L < 0 || q < J || P.start < j)
          break;
        let X = P.id >= a ? 4 : 0, K = P.start;
        for (P.next(); P.pos > q; ) {
          if (P.size < 0)
            if (P.size == -3)
              X += 4;
            else
              break e;
          else
            P.id >= a && (X += 4);
          P.next();
        }
        B = K, I += L, Q += X;
      }
    return (E < 0 || I == C) && (G.size = I, G.start = B, G.skip = Q), G.size > 4 ? G : void 0;
  }
  function S(C, E, P) {
    let { id: I, start: B, end: Q, size: j } = o;
    if (o.next(), j >= 0 && I < a) {
      let G = P;
      if (j > 4) {
        let J = o.pos - (j - 4);
        for (; o.pos > J; )
          P = S(C, E, P);
      }
      E[--P] = G, E[--P] = Q - C, E[--P] = B - C, E[--P] = I;
    } else
      j == -3 ? c = I : j == -4 && (h = I);
    return P;
  }
  let x = [], w = [];
  for (; o.pos > 0; )
    d(t.start || 0, t.bufferStart || 0, x, w, -1, 0);
  let k = (e = t.length) !== null && e !== void 0 ? e : x.length ? w[0] + x[0].length : 0;
  return new ut(u[t.topID], x.reverse(), w.reverse(), k);
}
const ex = /* @__PURE__ */ new WeakMap();
function Oc(t, e) {
  if (!t.isAnonymous || e instanceof Un || e.type != t)
    return 1;
  let r = ex.get(e);
  if (r == null) {
    r = 1;
    for (let i of e.children) {
      if (i.type != t || !(i instanceof ut)) {
        r = 1;
        break;
      }
      r += Oc(t, i);
    }
    ex.set(e, r);
  }
  return r;
}
function Oy(t, e, r, i, n, s, a, o, u) {
  let c = 0;
  for (let O = i; O < n; O++)
    c += Oc(t, e[O]);
  let h = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), d = [], m = [];
  function y(O, b, v, S, x) {
    for (let w = v; w < S; ) {
      let k = w, C = b[w], E = Oc(t, O[w]);
      for (w++; w < S; w++) {
        let P = Oc(t, O[w]);
        if (E + P >= h)
          break;
        E += P;
      }
      if (w == k + 1) {
        if (E > h) {
          let P = O[k];
          y(P.children, P.positions, 0, P.children.length, b[k] + x);
          continue;
        }
        d.push(O[k]);
      } else {
        let P = b[w - 1] + O[w - 1].length - C;
        d.push(Oy(t, O, b, k, w, C, P, null, u));
      }
      m.push(C + x - s);
    }
  }
  return y(e, r, i, n, 0), (o || u)(d, m, a);
}
class oA {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, r, i) {
    let n = this.map.get(e);
    n || this.map.set(e, n = /* @__PURE__ */ new Map()), n.set(r, i);
  }
  getBuffer(e, r) {
    let i = this.map.get(e);
    return i && i.get(r);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, r) {
    e instanceof Ai ? this.setBuffer(e.context.buffer, e.index, r) : e instanceof Xt && this.map.set(e.tree, r);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof Ai ? this.getBuffer(e.context.buffer, e.index) : e instanceof Xt ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, r) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, r) : this.map.set(e.tree, r);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class Gi {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, r, i, n, s = !1, a = !1) {
    this.from = e, this.to = r, this.tree = i, this.offset = n, this.open = (s ? 1 : 0) | (a ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, r = [], i = !1) {
    let n = [new Gi(0, e.length, e, 0, !1, i)];
    for (let s of r)
      s.to > e.length && n.push(s);
    return n;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, r, i = 128) {
    if (!r.length)
      return e;
    let n = [], s = 1, a = e.length ? e[0] : null;
    for (let o = 0, u = 0, c = 0; ; o++) {
      let h = o < r.length ? r[o] : null, d = h ? h.fromA : 1e9;
      if (d - u >= i)
        for (; a && a.from < d; ) {
          let m = a;
          if (u >= m.from || d <= m.to || c) {
            let y = Math.max(m.from, u) - c, O = Math.min(m.to, d) - c;
            m = y >= O ? null : new Gi(y, O, m.tree, m.offset + c, o > 0, !!h);
          }
          if (m && n.push(m), a.to > d)
            break;
          a = s < e.length ? e[s++] : null;
        }
      if (!h)
        break;
      u = h.toA, c = h.toA - h.toB;
    }
    return n;
  }
}
class lA {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, r, i) {
    return typeof e == "string" && (e = new GW(e)), i = i ? i.length ? i.map((n) => new _r(n.from, n.to)) : [new _r(0, 0)] : [new _r(0, e.length)], this.createParse(e, r || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, r, i) {
    let n = this.startParse(e, r, i);
    for (; ; ) {
      let s = n.advance();
      if (s)
        return s;
    }
  }
}
class GW {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, r) {
    return this.string.slice(e, r);
  }
}
function HW(t) {
  return (e, r, i, n) => new KW(e, t, r, i, n);
}
class tx {
  constructor(e, r, i, n, s) {
    this.parser = e, this.parse = r, this.overlay = i, this.target = n, this.from = s;
  }
}
function rx(t) {
  if (!t.length || t.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(t));
}
class JW {
  constructor(e, r, i, n, s, a, o) {
    this.parser = e, this.predicate = r, this.mounts = i, this.index = n, this.start = s, this.target = a, this.prev = o, this.depth = 0, this.ranges = [];
  }
}
const am = new ke({ perNode: !0 });
class KW {
  constructor(e, r, i, n, s) {
    this.nest = r, this.input = i, this.fragments = n, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let n of this.inner)
          n.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new ut(i.type, i.children, i.positions, i.length, i.propValues.concat([[am, this.stoppedAt]]))), i;
    }
    let e = this.inner[this.innerDone], r = e.parse.advance();
    if (r) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      i[ke.mounted.id] = new bl(r, e.overlay, e.parser), e.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let r = this.innerDone; r < this.inner.length; r++)
      this.inner[r].from < e && (e = Math.min(e, this.inner[r].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let r = this.innerDone; r < this.inner.length; r++)
        this.inner[r].parse.stopAt(e);
  }
  startInner() {
    let e = new rq(this.fragments), r = null, i = null, n = new Wc(new Xt(this.baseTree, this.ranges[0].from, 0, null), Ke.IncludeAnonymous | Ke.IgnoreMounts);
    e:
      for (let s, a; ; ) {
        let o = !0, u;
        if (this.stoppedAt != null && n.from >= this.stoppedAt)
          o = !1;
        else if (e.hasNode(n)) {
          if (r) {
            let c = r.mounts.find((h) => h.frag.from <= n.from && h.frag.to >= n.to && h.mount.overlay);
            if (c)
              for (let h of c.mount.overlay) {
                let d = h.from + c.pos, m = h.to + c.pos;
                d >= n.from && m <= n.to && !r.ranges.some((y) => y.from < m && y.to > d) && r.ranges.push({ from: d, to: m });
              }
          }
          o = !1;
        } else if (i && (a = eq(i.ranges, n.from, n.to)))
          o = a != 2;
        else if (!n.type.isAnonymous && (s = this.nest(n, this.input)) && (n.from < n.to || !s.overlay)) {
          n.tree || tq(n);
          let c = e.findMounts(n.from, s.parser);
          if (typeof s.overlay == "function")
            r = new JW(s.parser, s.overlay, c, this.inner.length, n.from, n.tree, r);
          else {
            let h = sx(this.ranges, s.overlay || (n.from < n.to ? [new _r(n.from, n.to)] : []));
            h.length && rx(h), (h.length || !s.overlay) && this.inner.push(new tx(s.parser, h.length ? s.parser.startParse(this.input, ax(c, h), h) : s.parser.startParse(""), s.overlay ? s.overlay.map((d) => new _r(d.from - n.from, d.to - n.from)) : null, n.tree, h.length ? h[0].from : n.from)), s.overlay ? h.length && (i = { ranges: h, depth: 0, prev: i }) : o = !1;
          }
        } else
          r && (u = r.predicate(n)) && (u === !0 && (u = new _r(n.from, n.to)), u.from < u.to && r.ranges.push(u));
        if (o && n.firstChild())
          r && r.depth++, i && i.depth++;
        else
          for (; !n.nextSibling(); ) {
            if (!n.parent())
              break e;
            if (r && !--r.depth) {
              let c = sx(this.ranges, r.ranges);
              c.length && (rx(c), this.inner.splice(r.index, 0, new tx(r.parser, r.parser.startParse(this.input, ax(r.mounts, c), c), r.ranges.map((h) => new _r(h.from - r.start, h.to - r.start)), r.target, c[0].from))), r = r.prev;
            }
            i && !--i.depth && (i = i.prev);
          }
      }
  }
}
function eq(t, e, r) {
  for (let i of t) {
    if (i.from >= r)
      break;
    if (i.to > e)
      return i.from <= e && i.to >= r ? 2 : 1;
  }
  return 0;
}
function ix(t, e, r, i, n, s) {
  if (e < r) {
    let a = t.buffer[e + 1];
    i.push(t.slice(e, r, a)), n.push(a - s);
  }
}
function tq(t) {
  let { node: e } = t, r = [], i = e.context.buffer;
  do
    r.push(t.index), t.parent();
  while (!t.tree);
  let n = t.tree, s = n.children.indexOf(i), a = n.children[s], o = a.buffer, u = [s];
  function c(h, d, m, y, O, b) {
    let v = r[b], S = [], x = [];
    ix(a, h, v, S, x, y);
    let w = o[v + 1], k = o[v + 2];
    u.push(S.length);
    let C = b ? c(v + 4, o[v + 3], a.set.types[o[v]], w, k - w, b - 1) : e.toTree();
    return S.push(C), x.push(w - y), ix(a, o[v + 3], d, S, x, y), new ut(m, S, x, O);
  }
  n.children[s] = c(0, o.length, er.none, 0, a.length, r.length - 1);
  for (let h of u) {
    let d = t.tree.children[h], m = t.tree.positions[h];
    t.yield(new Xt(d, m + t.from, h, t._tree));
  }
}
class nx {
  constructor(e, r) {
    this.offset = r, this.done = !1, this.cursor = e.cursor(Ke.IncludeAnonymous | Ke.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: r } = this, i = e - this.offset;
    for (; !this.done && r.from < i; )
      r.to >= e && r.enter(i, 1, Ke.IgnoreOverlays | Ke.ExcludeBuffers) || r.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let r = this.cursor.tree; ; ) {
        if (r == e.tree)
          return !0;
        if (r.children.length && r.positions[0] == 0 && r.children[0] instanceof ut)
          r = r.children[0];
        else
          break;
      }
    return !1;
  }
}
let rq = class {
  constructor(e) {
    var r;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let i = this.curFrag = e[0];
      this.curTo = (r = i.tree.prop(am)) !== null && r !== void 0 ? r : i.to, this.inner = new nx(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let r = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = r.tree.prop(am)) !== null && e !== void 0 ? e : r.to, this.inner = new nx(r.tree, -r.offset);
    }
  }
  findMounts(e, r) {
    var i;
    let n = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let a = (i = s.tree) === null || i === void 0 ? void 0 : i.prop(ke.mounted);
        if (a && a.parser == r)
          for (let o = this.fragI; o < this.fragments.length; o++) {
            let u = this.fragments[o];
            if (u.from >= s.to)
              break;
            u.tree == this.curFrag.tree && n.push({
              frag: u,
              pos: s.from - u.offset,
              mount: a
            });
          }
      }
    }
    return n;
  }
};
function sx(t, e) {
  let r = null, i = e;
  for (let n = 1, s = 0; n < t.length; n++) {
    let a = t[n - 1].to, o = t[n].from;
    for (; s < i.length; s++) {
      let u = i[s];
      if (u.from >= o)
        break;
      u.to <= a || (r || (i = r = e.slice()), u.from < a ? (r[s] = new _r(u.from, a), u.to > o && r.splice(s + 1, 0, new _r(o, u.to))) : u.to > o ? r[s--] = new _r(o, u.to) : r.splice(s--, 1));
    }
  }
  return i;
}
function iq(t, e, r, i) {
  let n = 0, s = 0, a = !1, o = !1, u = -1e9, c = [];
  for (; ; ) {
    let h = n == t.length ? 1e9 : a ? t[n].to : t[n].from, d = s == e.length ? 1e9 : o ? e[s].to : e[s].from;
    if (a != o) {
      let m = Math.max(u, r), y = Math.min(h, d, i);
      m < y && c.push(new _r(m, y));
    }
    if (u = Math.min(h, d), u == 1e9)
      break;
    h == u && (a ? (a = !1, n++) : a = !0), d == u && (o ? (o = !1, s++) : o = !0);
  }
  return c;
}
function ax(t, e) {
  let r = [];
  for (let { pos: i, mount: n, frag: s } of t) {
    let a = i + (n.overlay ? n.overlay[0].from : 0), o = a + n.tree.length, u = Math.max(s.from, a), c = Math.min(s.to, o);
    if (n.overlay) {
      let h = n.overlay.map((m) => new _r(m.from + i, m.to + i)), d = iq(e, h, u, c);
      for (let m = 0, y = u; ; m++) {
        let O = m == d.length, b = O ? c : d[m].from;
        if (b > y && r.push(new Gi(y, b, n.tree, -a, s.from >= y || s.openStart, s.to <= b || s.openEnd)), O)
          break;
        y = d[m].to;
      }
    } else
      r.push(new Gi(u, c, n.tree, -a, s.from >= a || s.openStart, s.to <= o || s.openEnd));
  }
  return r;
}
let nq = 0;
class vi {
  /**
  @internal
  */
  constructor(e, r, i) {
    this.set = e, this.base = r, this.modified = i, this.id = nq++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let r = new vi([], null, []);
    if (r.set.push(r), e)
      for (let i of e.set)
        r.set.push(i);
    return r;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new qc();
    return (r) => r.modified.indexOf(e) > -1 ? r : qc.get(r.base || r, r.modified.concat(e).sort((i, n) => i.id - n.id));
  }
}
let sq = 0;
class qc {
  constructor() {
    this.instances = [], this.id = sq++;
  }
  static get(e, r) {
    if (!r.length)
      return e;
    let i = r[0].instances.find((o) => o.base == e && aq(r, o.modified));
    if (i)
      return i;
    let n = [], s = new vi(n, e, r);
    for (let o of r)
      o.instances.push(s);
    let a = oq(r);
    for (let o of e.set)
      if (!o.modified.length)
        for (let u of a)
          n.push(qc.get(o, u));
    return s;
  }
}
function aq(t, e) {
  return t.length == e.length && t.every((r, i) => r == e[i]);
}
function oq(t) {
  let e = [[]];
  for (let r = 0; r < t.length; r++)
    for (let i = 0, n = e.length; i < n; i++)
      e.push(e[i].concat(t[r]));
  return e.sort((r, i) => i.length - r.length);
}
function Hl(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let i = t[r];
    Array.isArray(i) || (i = [i]);
    for (let n of r.split(" "))
      if (n) {
        let s = [], a = 2, o = n;
        for (let d = 0; ; ) {
          if (o == "..." && d > 0 && d + 3 == n.length) {
            a = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(o);
          if (!m)
            throw new RangeError("Invalid path: " + n);
          if (s.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]), d += m[0].length, d == n.length)
            break;
          let y = n[d++];
          if (d == n.length && y == "!") {
            a = 0;
            break;
          }
          if (y != "/")
            throw new RangeError("Invalid path: " + n);
          o = n.slice(d);
        }
        let u = s.length - 1, c = s[u];
        if (!c)
          throw new RangeError("Invalid path: " + n);
        let h = new Xc(i, a, u > 0 ? s.slice(0, u) : null);
        e[c] = h.sort(e[c]);
      }
  }
  return uA.add(e);
}
const uA = new ke();
class Xc {
  constructor(e, r, i, n) {
    this.tags = e, this.mode = r, this.context = i, this.next = n;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Xc.empty = new Xc([], 2, null);
function cA(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let s of t)
    if (!Array.isArray(s.tag))
      r[s.tag.id] = s.class;
    else
      for (let a of s.tag)
        r[a.id] = s.class;
  let { scope: i, all: n = null } = e || {};
  return {
    style: (s) => {
      let a = n;
      for (let o of s)
        for (let u of o.set) {
          let c = r[u.id];
          if (c) {
            a = a ? a + " " + c : c;
            break;
          }
        }
      return a;
    },
    scope: i
  };
}
function lq(t, e) {
  let r = null;
  for (let i of t) {
    let n = i.style(e);
    n && (r = r ? r + " " + n : n);
  }
  return r;
}
function uq(t, e, r, i = 0, n = t.length) {
  let s = new cq(i, Array.isArray(e) ? e : [e], r);
  s.highlightRange(t.cursor(), i, n, "", s.highlighters), s.flush(n);
}
class cq {
  constructor(e, r, i) {
    this.at = e, this.highlighters = r, this.span = i, this.class = "";
  }
  startSpan(e, r) {
    r != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = r);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, r, i, n, s) {
    let { type: a, from: o, to: u } = e;
    if (o >= i || u <= r)
      return;
    a.isTop && (s = this.highlighters.filter((y) => !y.scope || y.scope(a)));
    let c = n, h = hq(e) || Xc.empty, d = lq(s, h.tags);
    if (d && (c && (c += " "), c += d, h.mode == 1 && (n += (n ? " " : "") + d)), this.startSpan(Math.max(r, o), c), h.opaque)
      return;
    let m = e.tree && e.tree.prop(ke.mounted);
    if (m && m.overlay) {
      let y = e.node.enter(m.overlay[0].from + o, 1), O = this.highlighters.filter((v) => !v.scope || v.scope(m.tree.type)), b = e.firstChild();
      for (let v = 0, S = o; ; v++) {
        let x = v < m.overlay.length ? m.overlay[v] : null, w = x ? x.from + o : u, k = Math.max(r, S), C = Math.min(i, w);
        if (k < C && b)
          for (; e.from < C && (this.highlightRange(e, k, C, n, s), this.startSpan(Math.min(C, e.to), c), !(e.to >= w || !e.nextSibling())); )
            ;
        if (!x || w > i)
          break;
        S = x.to + o, S > r && (this.highlightRange(y.cursor(), Math.max(r, x.from + o), Math.min(i, S), "", O), this.startSpan(Math.min(i, S), c));
      }
      b && e.parent();
    } else if (e.firstChild()) {
      m && (n = "");
      do
        if (!(e.to <= r)) {
          if (e.from >= i)
            break;
          this.highlightRange(e, r, i, n, s), this.startSpan(Math.min(i, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function hq(t) {
  let e = t.type.prop(uA);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const ae = vi.define, Vu = ae(), An = ae(), ox = ae(An), lx = ae(An), En = ae(), Yu = ae(En), fd = ae(En), Di = ae(), as = ae(Di), yi = ae(), Oi = ae(), om = ae(), Co = ae(om), Uu = ae(), _ = {
  /**
  A comment.
  */
  comment: Vu,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: ae(Vu),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: ae(Vu),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: ae(Vu),
  /**
  Any kind of identifier.
  */
  name: An,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: ae(An),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: ox,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: ae(ox),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: lx,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: ae(lx),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: ae(An),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: ae(An),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: ae(An),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: ae(An),
  /**
  A literal value.
  */
  literal: En,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Yu,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: ae(Yu),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: ae(Yu),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: ae(Yu),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: fd,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: ae(fd),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: ae(fd),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: ae(En),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: ae(En),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: ae(En),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: ae(En),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: ae(En),
  /**
  A language keyword.
  */
  keyword: yi,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: ae(yi),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: ae(yi),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: ae(yi),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: ae(yi),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: ae(yi),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: ae(yi),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: ae(yi),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: ae(yi),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: ae(yi),
  /**
  An operator.
  */
  operator: Oi,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: ae(Oi),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: ae(Oi),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: ae(Oi),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: ae(Oi),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: ae(Oi),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: ae(Oi),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: ae(Oi),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: ae(Oi),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: ae(Oi),
  /**
  Program or markup punctuation.
  */
  punctuation: om,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: ae(om),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Co,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: ae(Co),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: ae(Co),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: ae(Co),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: ae(Co),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Di,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: as,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: ae(as),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: ae(as),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: ae(as),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: ae(as),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: ae(as),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: ae(as),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: ae(Di),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: ae(Di),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: ae(Di),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: ae(Di),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: ae(Di),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: ae(Di),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: ae(Di),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: ae(Di),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: ae(),
  /**
  Deleted text.
  */
  deleted: ae(),
  /**
  Changed text.
  */
  changed: ae(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: ae(),
  /**
  Metadata or meta-instruction.
  */
  meta: Uu,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: ae(Uu),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: ae(Uu),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: ae(Uu),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: vi.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: vi.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: vi.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: vi.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: vi.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: vi.defineModifier()
};
cA([
  { tag: _.link, class: "tok-link" },
  { tag: _.heading, class: "tok-heading" },
  { tag: _.emphasis, class: "tok-emphasis" },
  { tag: _.strong, class: "tok-strong" },
  { tag: _.keyword, class: "tok-keyword" },
  { tag: _.atom, class: "tok-atom" },
  { tag: _.bool, class: "tok-bool" },
  { tag: _.url, class: "tok-url" },
  { tag: _.labelName, class: "tok-labelName" },
  { tag: _.inserted, class: "tok-inserted" },
  { tag: _.deleted, class: "tok-deleted" },
  { tag: _.literal, class: "tok-literal" },
  { tag: _.string, class: "tok-string" },
  { tag: _.number, class: "tok-number" },
  { tag: [_.regexp, _.escape, _.special(_.string)], class: "tok-string2" },
  { tag: _.variableName, class: "tok-variableName" },
  { tag: _.local(_.variableName), class: "tok-variableName tok-local" },
  { tag: _.definition(_.variableName), class: "tok-variableName tok-definition" },
  { tag: _.special(_.variableName), class: "tok-variableName2" },
  { tag: _.definition(_.propertyName), class: "tok-propertyName tok-definition" },
  { tag: _.typeName, class: "tok-typeName" },
  { tag: _.namespace, class: "tok-namespace" },
  { tag: _.className, class: "tok-className" },
  { tag: _.macroName, class: "tok-macroName" },
  { tag: _.propertyName, class: "tok-propertyName" },
  { tag: _.operator, class: "tok-operator" },
  { tag: _.comment, class: "tok-comment" },
  { tag: _.meta, class: "tok-meta" },
  { tag: _.invalid, class: "tok-invalid" },
  { tag: _.punctuation, class: "tok-punctuation" }
]);
var md;
const ya = /* @__PURE__ */ new ke();
function hA(t) {
  return fe.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
const xy = /* @__PURE__ */ new ke();
class si {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, r, i = [], n = "") {
    this.data = e, this.name = n, Ie.prototype.hasOwnProperty("tree") || Object.defineProperty(Ie.prototype, "tree", { get() {
      return ht(this);
    } }), this.parser = r, this.extension = [
      zn.of(this),
      Ie.languageData.of((s, a, o) => {
        let u = ux(s, a, o), c = u.type.prop(ya);
        if (!c)
          return [];
        let h = s.facet(c), d = u.type.prop(xy);
        if (d) {
          let m = u.resolve(a - u.from, o);
          for (let y of d)
            if (y.test(m, s)) {
              let O = s.facet(y.facet);
              return y.type == "replace" ? O : O.concat(h);
            }
        }
        return h;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, r, i = -1) {
    return ux(e, r, i).type.prop(ya) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let r = e.facet(zn);
    if ((r == null ? void 0 : r.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!r || !r.allowsNesting)
      return [];
    let i = [], n = (s, a) => {
      if (s.prop(ya) == this.data) {
        i.push({ from: a, to: a + s.length });
        return;
      }
      let o = s.prop(ke.mounted);
      if (o) {
        if (o.tree.prop(ya) == this.data) {
          if (o.overlay)
            for (let u of o.overlay)
              i.push({ from: u.from + a, to: u.to + a });
          else
            i.push({ from: a, to: a + s.length });
          return;
        } else if (o.overlay) {
          let u = i.length;
          if (n(o.tree, o.overlay[0].from + a), i.length > u)
            return;
        }
      }
      for (let u = 0; u < s.children.length; u++) {
        let c = s.children[u];
        c instanceof ut && n(c, s.positions[u] + a);
      }
    };
    return n(ht(e), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
si.setState = /* @__PURE__ */ we.define();
function ux(t, e, r) {
  let i = t.facet(zn), n = ht(t).topNode;
  if (!i || i.allowsNesting)
    for (let s = n; s; s = s.enter(e, r, Ke.ExcludeBuffers))
      s.type.isTop && (n = s);
  return n;
}
class Fs extends si {
  constructor(e, r, i) {
    super(e, r, [], i), this.parser = r;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let r = hA(e.languageData);
    return new Fs(r, e.parser.configure({
      props: [ya.add((i) => i.isTop ? r : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, r) {
    return new Fs(this.data, this.parser.configure(e), r || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function ht(t) {
  let e = t.field(si.state, !1);
  return e ? e.tree : ut.empty;
}
class pq {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, r) {
    let i = this.cursorPos - this.string.length;
    return e < i || r >= this.cursorPos ? this.doc.sliceString(e, r) : this.string.slice(e - i, r - i);
  }
}
let Ao = null;
class Vc {
  constructor(e, r, i = [], n, s, a, o, u) {
    this.parser = e, this.state = r, this.fragments = i, this.tree = n, this.treeLen = s, this.viewport = a, this.skipped = o, this.scheduleOn = u, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, r, i) {
    return new Vc(e, r, [], ut.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new pq(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, r) {
    return r != null && r >= this.state.doc.length && (r = void 0), this.tree != ut.empty && this.isDone(r ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof e == "number") {
        let n = Date.now() + e;
        e = () => Date.now() > n;
      }
      for (this.parse || (this.parse = this.startParse()), r != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > r) && r < this.state.doc.length && this.parse.stopAt(r); ; ) {
        let n = this.parse.advance();
        if (n)
          if (this.fragments = this.withoutTempSkipped(Gi.addTree(n, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = n, this.parse = null, this.treeLen < (r ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, r;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(r = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = r, this.fragments = this.withoutTempSkipped(Gi.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let r = Ao;
    Ao = this;
    try {
      return e();
    } finally {
      Ao = r;
    }
  }
  withoutTempSkipped(e) {
    for (let r; r = this.tempSkipped.pop(); )
      e = cx(e, r.from, r.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, r) {
    let { fragments: i, tree: n, treeLen: s, viewport: a, skipped: o } = this;
    if (this.takeTree(), !e.empty) {
      let u = [];
      if (e.iterChangedRanges((c, h, d, m) => u.push({ fromA: c, toA: h, fromB: d, toB: m })), i = Gi.applyChanges(i, u), n = ut.empty, s = 0, a = { from: e.mapPos(a.from, -1), to: e.mapPos(a.to, 1) }, this.skipped.length) {
        o = [];
        for (let c of this.skipped) {
          let h = e.mapPos(c.from, 1), d = e.mapPos(c.to, -1);
          h < d && o.push({ from: h, to: d });
        }
      }
    }
    return new Vc(this.parser, r, i, n, s, a, o, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let r = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: n, to: s } = this.skipped[i];
      n < e.to && s > e.from && (this.fragments = cx(this.fragments, n, s), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= r ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, r) {
    this.skipped.push({ from: e, to: r });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends lA {
      createParse(r, i, n) {
        let s = n[0].from, a = n[n.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let u = Ao;
            if (u) {
              for (let c of n)
                u.tempSkipped.push(c);
              e && (u.scheduleOn = u.scheduleOn ? Promise.all([u.scheduleOn, e]) : e);
            }
            return this.parsedPos = a, new ut(er.none, [], [], a - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let r = this.fragments;
    return this.treeLen >= e && r.length && r[0].from == 0 && r[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Ao;
  }
}
function cx(t, e, r) {
  return Gi.applyChanges(t, [{ fromA: e, toA: r, fromB: e, toB: r }]);
}
class Ma {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let r = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), r.viewport.to);
    return r.work(20, i) || r.takeTree(), new Ma(r);
  }
  static init(e) {
    let r = Math.min(3e3, e.doc.length), i = Vc.create(e.facet(zn).parser, e, { from: 0, to: r });
    return i.work(20, r) || i.takeTree(), new Ma(i);
  }
}
si.state = /* @__PURE__ */ St.define({
  create: Ma.init,
  update(t, e) {
    for (let r of e.effects)
      if (r.is(si.setState))
        return r.value;
    return e.startState.facet(zn) != e.state.facet(zn) ? Ma.init(e.state) : t.apply(e);
  }
});
let pA = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (pA = (t) => {
  let e = -1, r = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(r) : cancelIdleCallback(e);
});
const gd = typeof navigator < "u" && (!((md = navigator.scheduling) === null || md === void 0) && md.isInputPending) ? () => navigator.scheduling.isInputPending() : null, dq = /* @__PURE__ */ ft.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let r = this.view.state.field(si.state).context;
    (r.updateViewport(e.view.viewport) || this.view.viewport.to > r.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(r);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, r = e.field(si.state);
    (r.tree != r.context.tree || !r.context.isDone(e.doc.length)) && (this.working = pA(this.work));
  }
  work(e) {
    this.working = null;
    let r = Date.now();
    if (this.chunkEnd < r && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = r + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: n } } = this.view, s = i.field(si.state);
    if (s.tree == s.context.tree && s.context.isDone(
      n + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let a = Date.now() + Math.min(this.chunkBudget, 100, e && !gd ? Math.max(25, e.timeRemaining() - 5) : 1e9), o = s.context.treeLen < n && i.doc.length > n + 1e3, u = s.context.work(() => gd && gd() || Date.now() > a, n + (o ? 0 : 1e5));
    this.chunkBudget -= Date.now() - r, (u || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: si.setState.of(new Ma(s.context)) })), this.chunkBudget > 0 && !(u && !o) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((r) => Mr(this.view.state, r)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), zn = /* @__PURE__ */ fe.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    si.state,
    dq,
    oe.contentAttributes.compute([t], (e) => {
      let r = e.facet(t);
      return r && r.name ? { "data-language": r.name } : {};
    })
  ]
});
class op {
  /**
  Create a language support object.
  */
  constructor(e, r = []) {
    this.language = e, this.support = r, this.extension = [e, r];
  }
}
const fq = /* @__PURE__ */ fe.define(), Jl = /* @__PURE__ */ fe.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((r) => r != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function Yc(t) {
  let e = t.facet(Jl);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function vl(t, e) {
  let r = "", i = t.tabSize, n = t.facet(Jl)[0];
  if (n == "	") {
    for (; e >= i; )
      r += "	", e -= i;
    n = " ";
  }
  for (let s = 0; s < e; s++)
    r += n;
  return r;
}
function by(t, e) {
  t instanceof Ie && (t = new lp(t));
  for (let i of t.state.facet(fq)) {
    let n = i(t, e);
    if (n !== void 0)
      return n;
  }
  let r = ht(t.state);
  return r.length >= e ? mq(t, r, e) : null;
}
class lp {
  /**
  Create an indent context.
  */
  constructor(e, r = {}) {
    this.state = e, this.options = r, this.unit = Yc(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, r = 1) {
    let i = this.state.doc.lineAt(e), { simulateBreak: n, simulateDoubleBreak: s } = this.options;
    return n != null && n >= i.from && n <= i.to ? s && n == e ? { text: "", from: e } : (r < 0 ? n < e : n <= e) ? { text: i.text.slice(n - i.from), from: n } : { text: i.text.slice(0, n - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, r = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: i, from: n } = this.lineAt(e, r);
    return i.slice(e - n, Math.min(i.length, e + 100 - n));
  }
  /**
  Find the column for the given position.
  */
  column(e, r = 1) {
    let { text: i, from: n } = this.lineAt(e, r), s = this.countColumn(i, e - n), a = this.options.overrideIndentation ? this.options.overrideIndentation(n) : -1;
    return a > -1 && (s += a - this.countColumn(i, i.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, r = e.length) {
    return ro(e, this.state.tabSize, r);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, r = 1) {
    let { text: i, from: n } = this.lineAt(e, r), s = this.options.overrideIndentation;
    if (s) {
      let a = s(n);
      if (a > -1)
        return a;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Kl = /* @__PURE__ */ new ke();
function mq(t, e, r) {
  let i = e.resolveStack(r), n = i.node.enterUnfinishedNodesBefore(r);
  if (n != i.node) {
    let s = [];
    for (let a = n; a != i.node; a = a.parent)
      s.push(a);
    for (let a = s.length - 1; a >= 0; a--)
      i = { node: s[a], next: i };
  }
  return dA(i, t, r);
}
function dA(t, e, r) {
  for (let i = t; i; i = i.next) {
    let n = yq(i.node);
    if (n)
      return n(Dy.create(e, r, i));
  }
  return 0;
}
function gq(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function yq(t) {
  let e = t.type.prop(Kl);
  if (e)
    return e;
  let r = t.firstChild, i;
  if (r && (i = r.type.prop(ke.closedBy))) {
    let n = t.lastChild, s = n && i.indexOf(n.name) > -1;
    return (a) => fA(a, !0, 1, void 0, s && !gq(a) ? n.from : void 0);
  }
  return t.parent == null ? Oq : null;
}
function Oq() {
  return 0;
}
class Dy extends lp {
  constructor(e, r, i) {
    super(e.state, e.options), this.base = e, this.pos = r, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, r, i) {
    return new Dy(e, r, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let r = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let i = e.resolve(r.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (xq(i, e))
        break;
      r = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(r.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return dA(this.context.next, this.base, this.pos);
  }
}
function xq(t, e) {
  for (let r = e; r; r = r.parent)
    if (t == r)
      return !0;
  return !1;
}
function bq(t) {
  let e = t.node, r = e.childAfter(e.from), i = e.lastChild;
  if (!r)
    return null;
  let n = t.options.simulateBreak, s = t.state.doc.lineAt(r.from), a = n == null || n <= s.from ? s.to : Math.min(s.to, n);
  for (let o = r.to; ; ) {
    let u = e.childAfter(o);
    if (!u || u == i)
      return null;
    if (!u.type.isSkipped)
      return u.from < a ? r : null;
    o = u.to;
  }
}
function Dq({ closing: t, align: e = !0, units: r = 1 }) {
  return (i) => fA(i, e, r, t);
}
function fA(t, e, r, i, n) {
  let s = t.textAfter, a = s.match(/^\s*/)[0].length, o = i && s.slice(a, a + i.length) == i || n == t.pos + a, u = e ? bq(t) : null;
  return u ? o ? t.column(u.from) : t.column(u.to) : t.baseIndent + (o ? 0 : t.unit * r);
}
const vq = (t) => t.baseIndent;
function wa({ except: t, units: e = 1 } = {}) {
  return (r) => {
    let i = t && t.test(r.textAfter);
    return r.baseIndent + (i ? 0 : e * r.unit);
  };
}
const Sq = 200;
function wq() {
  return Ie.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let r = t.newDoc, { head: i } = t.newSelection.main, n = r.lineAt(i);
    if (i > n.from + Sq)
      return t;
    let s = r.sliceString(n.from, i);
    if (!e.some((c) => c.test(s)))
      return t;
    let { state: a } = t, o = -1, u = [];
    for (let { head: c } of a.selection.ranges) {
      let h = a.doc.lineAt(c);
      if (h.from == o)
        continue;
      o = h.from;
      let d = by(a, h.from);
      if (d == null)
        continue;
      let m = /^\s*/.exec(h.text)[0], y = vl(a, d);
      m != y && u.push({ from: h.from, to: h.from + m.length, insert: y });
    }
    return u.length ? [t, { changes: u, sequential: !0 }] : t;
  });
}
const Cq = /* @__PURE__ */ fe.define(), eu = /* @__PURE__ */ new ke();
function vy(t) {
  let e = t.firstChild, r = t.lastChild;
  return e && e.to < r.from ? { from: e.to, to: r.type.isError ? t.to : r.from } : null;
}
function Aq(t, e, r) {
  let i = ht(t);
  if (i.length < r)
    return null;
  let n = i.resolveStack(r, 1), s = null;
  for (let a = n; a; a = a.next) {
    let o = a.node;
    if (o.to <= r || o.from > r)
      continue;
    if (s && o.from < e)
      break;
    let u = o.type.prop(eu);
    if (u && (o.to < i.length - 50 || i.length == t.doc.length || !Eq(o))) {
      let c = u(o, t);
      c && c.from <= r && c.from >= e && c.to > r && (s = c);
    }
  }
  return s;
}
function Eq(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function Uc(t, e, r) {
  for (let i of t.facet(Cq)) {
    let n = i(t, e, r);
    if (n)
      return n;
  }
  return Aq(t, e, r);
}
function mA(t, e) {
  let r = e.mapPos(t.from, 1), i = e.mapPos(t.to, -1);
  return r >= i ? void 0 : { from: r, to: i };
}
const up = /* @__PURE__ */ we.define({ map: mA }), tu = /* @__PURE__ */ we.define({ map: mA });
function gA(t) {
  let e = [];
  for (let { head: r } of t.state.selection.ranges)
    e.some((i) => i.from <= r && i.to >= r) || e.push(t.lineBlockAt(r));
  return e;
}
const $s = /* @__PURE__ */ St.define({
  create() {
    return xe.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let r of e.effects)
      if (r.is(up) && !kq(t, r.value.from, r.value.to)) {
        let { preparePlaceholder: i } = e.state.facet(Sy), n = i ? xe.replace({ widget: new Nq(i(e.state, r.value)) }) : hx;
        t = t.update({ add: [n.range(r.value.from, r.value.to)] });
      } else
        r.is(tu) && (t = t.update({
          filter: (i, n) => r.value.from != i || r.value.to != n,
          filterFrom: r.value.from,
          filterTo: r.value.to
        }));
    if (e.selection) {
      let r = !1, { head: i } = e.selection.main;
      t.between(i, i, (n, s) => {
        n < i && s > i && (r = !0);
      }), r && (t = t.update({
        filterFrom: i,
        filterTo: i,
        filter: (n, s) => s <= i || n >= i
      }));
    }
    return t;
  },
  provide: (t) => oe.decorations.from(t),
  toJSON(t, e) {
    let r = [];
    return t.between(0, e.doc.length, (i, n) => {
      r.push(i, n);
    }), r;
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let r = 0; r < t.length; ) {
      let i = t[r++], n = t[r++];
      if (typeof i != "number" || typeof n != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(hx.range(i, n));
    }
    return xe.set(e, !0);
  }
});
function zc(t, e, r) {
  var i;
  let n = null;
  return (i = t.field($s, !1)) === null || i === void 0 || i.between(e, r, (s, a) => {
    (!n || n.from > s) && (n = { from: s, to: a });
  }), n;
}
function kq(t, e, r) {
  let i = !1;
  return t.between(e, e, (n, s) => {
    n == e && s == r && (i = !0);
  }), i;
}
function yA(t, e) {
  return t.field($s, !1) ? e : e.concat(we.appendConfig.of(xA()));
}
const Tq = (t) => {
  for (let e of gA(t)) {
    let r = Uc(t.state, e.from, e.to);
    if (r)
      return t.dispatch({ effects: yA(t.state, [up.of(r), OA(t, r)]) }), !0;
  }
  return !1;
}, Pq = (t) => {
  if (!t.state.field($s, !1))
    return !1;
  let e = [];
  for (let r of gA(t)) {
    let i = zc(t.state, r.from, r.to);
    i && e.push(tu.of(i), OA(t, i, !1));
  }
  return e.length && t.dispatch({ effects: e }), e.length > 0;
};
function OA(t, e, r = !0) {
  let i = t.state.doc.lineAt(e.from).number, n = t.state.doc.lineAt(e.to).number;
  return oe.announce.of(`${t.state.phrase(r ? "Folded lines" : "Unfolded lines")} ${i} ${t.state.phrase("to")} ${n}.`);
}
const Fq = (t) => {
  let { state: e } = t, r = [];
  for (let i = 0; i < e.doc.length; ) {
    let n = t.lineBlockAt(i), s = Uc(e, n.from, n.to);
    s && r.push(up.of(s)), i = (s ? t.lineBlockAt(s.to) : n).to + 1;
  }
  return r.length && t.dispatch({ effects: yA(t.state, r) }), !!r.length;
}, $q = (t) => {
  let e = t.state.field($s, !1);
  if (!e || !e.size)
    return !1;
  let r = [];
  return e.between(0, t.state.doc.length, (i, n) => {
    r.push(tu.of({ from: i, to: n }));
  }), t.dispatch({ effects: r }), !0;
}, Bq = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: Tq },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: Pq },
  { key: "Ctrl-Alt-[", run: Fq },
  { key: "Ctrl-Alt-]", run: $q }
], Iq = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
}, Sy = /* @__PURE__ */ fe.define({
  combine(t) {
    return ji(t, Iq);
  }
});
function xA(t) {
  let e = [$s, Mq];
  return t && e.push(Sy.of(t)), e;
}
function bA(t, e) {
  let { state: r } = t, i = r.facet(Sy), n = (a) => {
    let o = t.lineBlockAt(t.posAtDOM(a.target)), u = zc(t.state, o.from, o.to);
    u && t.dispatch({ effects: tu.of(u) }), a.preventDefault();
  };
  if (i.placeholderDOM)
    return i.placeholderDOM(t, n, e);
  let s = document.createElement("span");
  return s.textContent = i.placeholderText, s.setAttribute("aria-label", r.phrase("folded code")), s.title = r.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = n, s;
}
const hx = /* @__PURE__ */ xe.replace({ widget: /* @__PURE__ */ new class extends Zi {
  toDOM(t) {
    return bA(t, null);
  }
}() });
class Nq extends Zi {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return bA(e, this.value);
  }
}
const _q = {
  openText: "",
  closedText: "",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class yd extends sn {
  constructor(e, r) {
    super(), this.config = e, this.open = r;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let r = document.createElement("span");
    return r.textContent = this.open ? this.config.openText : this.config.closedText, r.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), r;
  }
}
function Qq(t = {}) {
  let e = Object.assign(Object.assign({}, _q), t), r = new yd(e, !0), i = new yd(e, !1), n = ft.fromClass(class {
    constructor(a) {
      this.from = a.viewport.from, this.markers = this.buildMarkers(a);
    }
    update(a) {
      (a.docChanged || a.viewportChanged || a.startState.facet(zn) != a.state.facet(zn) || a.startState.field($s, !1) != a.state.field($s, !1) || ht(a.startState) != ht(a.state) || e.foldingChanged(a)) && (this.markers = this.buildMarkers(a.view));
    }
    buildMarkers(a) {
      let o = new qn();
      for (let u of a.viewportLineBlocks) {
        let c = zc(a.state, u.from, u.to) ? i : Uc(a.state, u.from, u.to) ? r : null;
        c && o.add(u.from, u.from, c);
      }
      return o.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    n,
    IW({
      class: "cm-foldGutter",
      markers(a) {
        var o;
        return ((o = a.plugin(n)) === null || o === void 0 ? void 0 : o.markers) || Me.empty;
      },
      initialSpacer() {
        return new yd(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, s), { click: (a, o, u) => {
        if (s.click && s.click(a, o, u))
          return !0;
        let c = zc(a.state, o.from, o.to);
        if (c)
          return a.dispatch({ effects: tu.of(c) }), !0;
        let h = Uc(a.state, o.from, o.to);
        return h ? (a.dispatch({ effects: up.of(h) }), !0) : !1;
      } })
    }),
    xA()
  ];
}
const Mq = /* @__PURE__ */ oe.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class ru {
  constructor(e, r) {
    this.specs = e;
    let i;
    function n(o) {
      let u = Xn.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + u] = o, u;
    }
    const s = typeof r.all == "string" ? r.all : r.all ? n(r.all) : void 0, a = r.scope;
    this.scope = a instanceof si ? (o) => o.prop(ya) == a.data : a ? (o) => o == a : void 0, this.style = cA(e.map((o) => ({
      tag: o.tag,
      class: o.class || n(Object.assign({}, o, { tag: null }))
    })), {
      all: s
    }).style, this.module = i ? new Xn(i) : null, this.themeType = r.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, r) {
    return new ru(e, r || {});
  }
}
const lm = /* @__PURE__ */ fe.define(), DA = /* @__PURE__ */ fe.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function Od(t) {
  let e = t.facet(lm);
  return e.length ? e : t.facet(DA);
}
function vA(t, e) {
  let r = [Rq], i;
  return t instanceof ru && (t.module && r.push(oe.styleModule.of(t.module)), i = t.themeType), e != null && e.fallback ? r.push(DA.of(t)) : i ? r.push(lm.computeN([oe.darkTheme], (n) => n.facet(oe.darkTheme) == (i == "dark") ? [t] : [])) : r.push(lm.of(t)), r;
}
class Lq {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = ht(e.state), this.decorations = this.buildDeco(e, Od(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let r = ht(e.state), i = Od(e.state), n = i != Od(e.startState), { viewport: s } = e.view, a = e.changes.mapPos(this.decoratedTo, 1);
    r.length < s.to && !n && r.type == this.tree.type && a >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = a) : (r != this.tree || e.viewportChanged || n) && (this.tree = r, this.decorations = this.buildDeco(e.view, i), this.decoratedTo = s.to);
  }
  buildDeco(e, r) {
    if (!r || !this.tree.length)
      return xe.none;
    let i = new qn();
    for (let { from: n, to: s } of e.visibleRanges)
      uq(this.tree, r, (a, o, u) => {
        i.add(a, o, this.markCache[u] || (this.markCache[u] = xe.mark({ class: u })));
      }, n, s);
    return i.finish();
  }
}
const Rq = /* @__PURE__ */ Ys.high(/* @__PURE__ */ ft.fromClass(Lq, {
  decorations: (t) => t.decorations
})), jq = /* @__PURE__ */ ru.define([
  {
    tag: _.meta,
    color: "#404740"
  },
  {
    tag: _.link,
    textDecoration: "underline"
  },
  {
    tag: _.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: _.emphasis,
    fontStyle: "italic"
  },
  {
    tag: _.strong,
    fontWeight: "bold"
  },
  {
    tag: _.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: _.keyword,
    color: "#708"
  },
  {
    tag: [_.atom, _.bool, _.url, _.contentSeparator, _.labelName],
    color: "#219"
  },
  {
    tag: [_.literal, _.inserted],
    color: "#164"
  },
  {
    tag: [_.string, _.deleted],
    color: "#a11"
  },
  {
    tag: [_.regexp, _.escape, /* @__PURE__ */ _.special(_.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ _.definition(_.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ _.local(_.variableName),
    color: "#30a"
  },
  {
    tag: [_.typeName, _.namespace],
    color: "#085"
  },
  {
    tag: _.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ _.special(_.variableName), _.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ _.definition(_.propertyName),
    color: "#00c"
  },
  {
    tag: _.comment,
    color: "#940"
  },
  {
    tag: _.invalid,
    color: "#f00"
  }
]), Zq = /* @__PURE__ */ oe.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), SA = 1e4, wA = "()[]{}", CA = /* @__PURE__ */ fe.define({
  combine(t) {
    return ji(t, {
      afterCursor: !0,
      brackets: wA,
      maxScanDistance: SA,
      renderMatch: Xq
    });
  }
}), Wq = /* @__PURE__ */ xe.mark({ class: "cm-matchingBracket" }), qq = /* @__PURE__ */ xe.mark({ class: "cm-nonmatchingBracket" });
function Xq(t) {
  let e = [], r = t.matched ? Wq : qq;
  return e.push(r.range(t.start.from, t.start.to)), t.end && e.push(r.range(t.end.from, t.end.to)), e;
}
const Vq = /* @__PURE__ */ St.define({
  create() {
    return xe.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let r = [], i = e.state.facet(CA);
    for (let n of e.state.selection.ranges) {
      if (!n.empty)
        continue;
      let s = Ei(e.state, n.head, -1, i) || n.head > 0 && Ei(e.state, n.head - 1, 1, i) || i.afterCursor && (Ei(e.state, n.head, 1, i) || n.head < e.state.doc.length && Ei(e.state, n.head + 1, -1, i));
      s && (r = r.concat(i.renderMatch(s, e.state)));
    }
    return xe.set(r, !0);
  },
  provide: (t) => oe.decorations.from(t)
}), Yq = [
  Vq,
  Zq
];
function Uq(t = {}) {
  return [CA.of(t), Yq];
}
const AA = /* @__PURE__ */ new ke();
function um(t, e, r) {
  let i = t.prop(e < 0 ? ke.openedBy : ke.closedBy);
  if (i)
    return i;
  if (t.name.length == 1) {
    let n = r.indexOf(t.name);
    if (n > -1 && n % 2 == (e < 0 ? 1 : 0))
      return [r[n + e]];
  }
  return null;
}
function cm(t) {
  let e = t.type.prop(AA);
  return e ? e(t.node) : t;
}
function Ei(t, e, r, i = {}) {
  let n = i.maxScanDistance || SA, s = i.brackets || wA, a = ht(t), o = a.resolveInner(e, r);
  for (let u = o; u; u = u.parent) {
    let c = um(u.type, r, s);
    if (c && u.from < u.to) {
      let h = cm(u);
      if (h && (r > 0 ? e >= h.from && e < h.to : e > h.from && e <= h.to))
        return zq(t, e, r, u, h, c, s);
    }
  }
  return Gq(t, e, r, a, o.type, n, s);
}
function zq(t, e, r, i, n, s, a) {
  let o = i.parent, u = { from: n.from, to: n.to }, c = 0, h = o == null ? void 0 : o.cursor();
  if (h && (r < 0 ? h.childBefore(i.from) : h.childAfter(i.to)))
    do
      if (r < 0 ? h.to <= i.from : h.from >= i.to) {
        if (c == 0 && s.indexOf(h.type.name) > -1 && h.from < h.to) {
          let d = cm(h);
          return { start: u, end: d ? { from: d.from, to: d.to } : void 0, matched: !0 };
        } else if (um(h.type, r, a))
          c++;
        else if (um(h.type, -r, a)) {
          if (c == 0) {
            let d = cm(h);
            return {
              start: u,
              end: d && d.from < d.to ? { from: d.from, to: d.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (r < 0 ? h.prevSibling() : h.nextSibling());
  return { start: u, matched: !1 };
}
function Gq(t, e, r, i, n, s, a) {
  let o = r < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), u = a.indexOf(o);
  if (u < 0 || u % 2 == 0 != r > 0)
    return null;
  let c = { from: r < 0 ? e - 1 : e, to: r > 0 ? e + 1 : e }, h = t.doc.iterRange(e, r > 0 ? t.doc.length : 0), d = 0;
  for (let m = 0; !h.next().done && m <= s; ) {
    let y = h.value;
    r < 0 && (m += y.length);
    let O = e + m * r;
    for (let b = r > 0 ? 0 : y.length - 1, v = r > 0 ? y.length : -1; b != v; b += r) {
      let S = a.indexOf(y[b]);
      if (!(S < 0 || i.resolveInner(O + b, 1).type != n))
        if (S % 2 == 0 == r > 0)
          d++;
        else {
          if (d == 1)
            return { start: c, end: { from: O + b, to: O + b + 1 }, matched: S >> 1 == u >> 1 };
          d--;
        }
    }
    r > 0 && (m += y.length);
  }
  return h.done ? { start: c, matched: !1 } : null;
}
const Hq = /* @__PURE__ */ Object.create(null), px = [er.none], dx = [], fx = /* @__PURE__ */ Object.create(null), Jq = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  Jq[t] = /* @__PURE__ */ Kq(Hq, e);
function xd(t, e) {
  dx.indexOf(t) > -1 || (dx.push(t), console.warn(e));
}
function Kq(t, e) {
  let r = [];
  for (let o of e.split(" ")) {
    let u = [];
    for (let c of o.split(".")) {
      let h = t[c] || _[c];
      h ? typeof h == "function" ? u.length ? u = u.map(h) : xd(c, `Modifier ${c} used at start of tag`) : u.length ? xd(c, `Tag ${c} used as modifier`) : u = Array.isArray(h) ? h : [h] : xd(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of u)
      r.push(c);
  }
  if (!r.length)
    return 0;
  let i = e.replace(/ /g, "_"), n = i + " " + r.map((o) => o.id), s = fx[n];
  if (s)
    return s.id;
  let a = fx[n] = er.define({
    id: px.length,
    name: i,
    props: [Hl({ [i]: r })]
  });
  return px.push(a), a.id;
}
it.RTL, it.LTR;
const eX = (t) => {
  let { state: e } = t, r = e.doc.lineAt(e.selection.main.from), i = Cy(t.state, r.from);
  return i.line ? tX(t) : i.block ? iX(t) : !1;
};
function wy(t, e) {
  return ({ state: r, dispatch: i }) => {
    if (r.readOnly)
      return !1;
    let n = t(e, r);
    return n ? (i(r.update(n)), !0) : !1;
  };
}
const tX = /* @__PURE__ */ wy(
  aX,
  0
  /* CommentOption.Toggle */
), rX = /* @__PURE__ */ wy(
  EA,
  0
  /* CommentOption.Toggle */
), iX = /* @__PURE__ */ wy(
  (t, e) => EA(t, e, sX(e)),
  0
  /* CommentOption.Toggle */
);
function Cy(t, e) {
  let r = t.languageDataAt("commentTokens", e);
  return r.length ? r[0] : {};
}
const Eo = 50;
function nX(t, { open: e, close: r }, i, n) {
  let s = t.sliceDoc(i - Eo, i), a = t.sliceDoc(n, n + Eo), o = /\s*$/.exec(s)[0].length, u = /^\s*/.exec(a)[0].length, c = s.length - o;
  if (s.slice(c - e.length, c) == e && a.slice(u, u + r.length) == r)
    return {
      open: { pos: i - o, margin: o && 1 },
      close: { pos: n + u, margin: u && 1 }
    };
  let h, d;
  n - i <= 2 * Eo ? h = d = t.sliceDoc(i, n) : (h = t.sliceDoc(i, i + Eo), d = t.sliceDoc(n - Eo, n));
  let m = /^\s*/.exec(h)[0].length, y = /\s*$/.exec(d)[0].length, O = d.length - y - r.length;
  return h.slice(m, m + e.length) == e && d.slice(O, O + r.length) == r ? {
    open: {
      pos: i + m + e.length,
      margin: /\s/.test(h.charAt(m + e.length)) ? 1 : 0
    },
    close: {
      pos: n - y - r.length,
      margin: /\s/.test(d.charAt(O - 1)) ? 1 : 0
    }
  } : null;
}
function sX(t) {
  let e = [];
  for (let r of t.selection.ranges) {
    let i = t.doc.lineAt(r.from), n = r.to <= i.to ? i : t.doc.lineAt(r.to), s = e.length - 1;
    s >= 0 && e[s].to > i.from ? e[s].to = n.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: n.to });
  }
  return e;
}
function EA(t, e, r = e.selection.ranges) {
  let i = r.map((s) => Cy(e, s.from).block);
  if (!i.every((s) => s))
    return null;
  let n = r.map((s, a) => nX(e, i[a], s.from, s.to));
  if (t != 2 && !n.every((s) => s))
    return { changes: e.changes(r.map((s, a) => n[a] ? [] : [{ from: s.from, insert: i[a].open + " " }, { from: s.to, insert: " " + i[a].close }])) };
  if (t != 1 && n.some((s) => s)) {
    let s = [];
    for (let a = 0, o; a < n.length; a++)
      if (o = n[a]) {
        let u = i[a], { open: c, close: h } = o;
        s.push({ from: c.pos - u.open.length, to: c.pos + c.margin }, { from: h.pos - h.margin, to: h.pos + u.close.length });
      }
    return { changes: s };
  }
  return null;
}
function aX(t, e, r = e.selection.ranges) {
  let i = [], n = -1;
  for (let { from: s, to: a } of r) {
    let o = i.length, u = 1e9, c = Cy(e, s).line;
    if (c) {
      for (let h = s; h <= a; ) {
        let d = e.doc.lineAt(h);
        if (d.from > n && (s == a || a > d.from)) {
          n = d.from;
          let m = /^\s*/.exec(d.text)[0].length, y = m == d.length, O = d.text.slice(m, m + c.length) == c ? m : -1;
          m < d.text.length && m < u && (u = m), i.push({ line: d, comment: O, token: c, indent: m, empty: y, single: !1 });
        }
        h = d.to + 1;
      }
      if (u < 1e9)
        for (let h = o; h < i.length; h++)
          i[h].indent < i[h].line.text.length && (i[h].indent = u);
      i.length == o + 1 && (i[o].single = !0);
    }
  }
  if (t != 2 && i.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: o, token: u, indent: c, empty: h, single: d } of i)
      (d || !h) && s.push({ from: o.from + c, insert: u + " " });
    let a = e.changes(s);
    return { changes: a, selection: e.selection.map(a, 1) };
  } else if (t != 1 && i.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: a, comment: o, token: u } of i)
      if (o >= 0) {
        let c = a.from + o, h = c + u.length;
        a.text[h - a.from] == " " && h++, s.push({ from: c, to: h });
      }
    return { changes: s };
  }
  return null;
}
const hm = /* @__PURE__ */ Ri.define(), oX = /* @__PURE__ */ Ri.define(), lX = /* @__PURE__ */ fe.define(), kA = /* @__PURE__ */ fe.define({
  combine(t) {
    return ji(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, r) => r
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, r) => (i, n) => e(i, n) || r(i, n)
    });
  }
}), TA = /* @__PURE__ */ St.define({
  create() {
    return ki.empty;
  },
  update(t, e) {
    let r = e.state.facet(kA), i = e.annotation(hm);
    if (i) {
      let u = ar.fromTransaction(e, i.selection), c = i.side, h = c == 0 ? t.undone : t.done;
      return u ? h = Gc(h, h.length, r.minDepth, u) : h = $A(h, e.startState.selection), new ki(c == 0 ? i.rest : h, c == 0 ? h : i.rest);
    }
    let n = e.annotation(oX);
    if ((n == "full" || n == "before") && (t = t.isolate()), e.annotation(yt.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let s = ar.fromTransaction(e), a = e.annotation(yt.time), o = e.annotation(yt.userEvent);
    return s ? t = t.addChanges(s, a, o, r, e) : e.selection && (t = t.addSelection(e.startState.selection, a, o, r.newGroupDelay)), (n == "full" || n == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new ki(t.done.map(ar.fromJSON), t.undone.map(ar.fromJSON));
  }
});
function uX(t = {}) {
  return [
    TA,
    kA.of(t),
    oe.domEventHandlers({
      beforeinput(e, r) {
        let i = e.inputType == "historyUndo" ? PA : e.inputType == "historyRedo" ? pm : null;
        return i ? (e.preventDefault(), i(r)) : !1;
      }
    })
  ];
}
function cp(t, e) {
  return function({ state: r, dispatch: i }) {
    if (!e && r.readOnly)
      return !1;
    let n = r.field(TA, !1);
    if (!n)
      return !1;
    let s = n.pop(t, r, e);
    return s ? (i(s), !0) : !1;
  };
}
const PA = /* @__PURE__ */ cp(0, !1), pm = /* @__PURE__ */ cp(1, !1), cX = /* @__PURE__ */ cp(0, !0), hX = /* @__PURE__ */ cp(1, !0);
class ar {
  constructor(e, r, i, n, s) {
    this.changes = e, this.effects = r, this.mapped = i, this.startSelection = n, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new ar(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, r, i;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (r = this.mapped) === null || r === void 0 ? void 0 : r.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((n) => n.toJSON())
    };
  }
  static fromJSON(e) {
    return new ar(e.changes && bt.fromJSON(e.changes), [], e.mapped && Fi.fromJSON(e.mapped), e.startSelection && U.fromJSON(e.startSelection), e.selectionsAfter.map(U.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, r) {
    let i = Qr;
    for (let n of e.startState.facet(lX)) {
      let s = n(e);
      s.length && (i = i.concat(s));
    }
    return !i.length && e.changes.empty ? null : new ar(e.changes.invert(e.startState.doc), i, void 0, r || e.startState.selection, Qr);
  }
  static selection(e) {
    return new ar(void 0, Qr, void 0, void 0, e);
  }
}
function Gc(t, e, r, i) {
  let n = e + 1 > r + 20 ? e - r - 1 : 0, s = t.slice(n, e);
  return s.push(i), s;
}
function pX(t, e) {
  let r = [], i = !1;
  return t.iterChangedRanges((n, s) => r.push(n, s)), e.iterChangedRanges((n, s, a, o) => {
    for (let u = 0; u < r.length; ) {
      let c = r[u++], h = r[u++];
      o >= c && a <= h && (i = !0);
    }
  }), i;
}
function dX(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((r, i) => r.empty != e.ranges[i].empty).length === 0;
}
function FA(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const Qr = [], fX = 200;
function $A(t, e) {
  if (t.length) {
    let r = t[t.length - 1], i = r.selectionsAfter.slice(Math.max(0, r.selectionsAfter.length - fX));
    return i.length && i[i.length - 1].eq(e) ? t : (i.push(e), Gc(t, t.length - 1, 1e9, r.setSelAfter(i)));
  } else
    return [ar.selection([e])];
}
function mX(t) {
  let e = t[t.length - 1], r = t.slice();
  return r[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), r;
}
function bd(t, e) {
  if (!t.length)
    return t;
  let r = t.length, i = Qr;
  for (; r; ) {
    let n = gX(t[r - 1], e, i);
    if (n.changes && !n.changes.empty || n.effects.length) {
      let s = t.slice(0, r);
      return s[r - 1] = n, s;
    } else
      e = n.mapped, r--, i = n.selectionsAfter;
  }
  return i.length ? [ar.selection(i)] : Qr;
}
function gX(t, e, r) {
  let i = FA(t.selectionsAfter.length ? t.selectionsAfter.map((o) => o.map(e)) : Qr, r);
  if (!t.changes)
    return ar.selection(i);
  let n = t.changes.map(e), s = e.mapDesc(t.changes, !0), a = t.mapped ? t.mapped.composeDesc(s) : s;
  return new ar(n, we.mapEffects(t.effects, e), a, t.startSelection.map(s), i);
}
const yX = /^(input\.type|delete)($|\.)/;
class ki {
  constructor(e, r, i = 0, n = void 0) {
    this.done = e, this.undone = r, this.prevTime = i, this.prevUserEvent = n;
  }
  isolate() {
    return this.prevTime ? new ki(this.done, this.undone) : this;
  }
  addChanges(e, r, i, n, s) {
    let a = this.done, o = a[a.length - 1];
    return o && o.changes && !o.changes.empty && e.changes && (!i || yX.test(i)) && (!o.selectionsAfter.length && r - this.prevTime < n.newGroupDelay && n.joinToEvent(s, pX(o.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? a = Gc(a, a.length - 1, n.minDepth, new ar(e.changes.compose(o.changes), FA(e.effects, o.effects), o.mapped, o.startSelection, Qr)) : a = Gc(a, a.length, n.minDepth, e), new ki(a, Qr, r, i);
  }
  addSelection(e, r, i, n) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Qr;
    return s.length > 0 && r - this.prevTime < n && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && dX(s[s.length - 1], e) ? this : new ki($A(this.done, e), this.undone, r, i);
  }
  addMapping(e) {
    return new ki(bd(this.done, e), bd(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, r, i) {
    let n = e == 0 ? this.done : this.undone;
    if (n.length == 0)
      return null;
    let s = n[n.length - 1], a = s.selectionsAfter[0] || r.selection;
    if (i && s.selectionsAfter.length)
      return r.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: hm.of({ side: e, rest: mX(n), selection: a }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let o = n.length == 1 ? Qr : n.slice(0, n.length - 1);
      return s.mapped && (o = bd(o, s.mapped)), r.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: hm.of({ side: e, rest: o, selection: a }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
ki.empty = /* @__PURE__ */ new ki(Qr, Qr);
const OX = [
  { key: "Mod-z", run: PA, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: pm, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: pm, preventDefault: !0 },
  { key: "Mod-u", run: cX, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: hX, preventDefault: !0 }
];
function io(t, e) {
  return U.create(t.ranges.map(e), t.mainIndex);
}
function Wi(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function ci({ state: t, dispatch: e }, r) {
  let i = io(t.selection, r);
  return i.eq(t.selection, !0) ? !1 : (e(Wi(t, i)), !0);
}
function hp(t, e) {
  return U.cursor(e ? t.to : t.from);
}
function BA(t, e) {
  return ci(t, (r) => r.empty ? t.moveByChar(r, e) : hp(r, e));
}
function Yt(t) {
  return t.textDirectionAt(t.state.selection.main.head) == it.LTR;
}
const IA = (t) => BA(t, !Yt(t)), NA = (t) => BA(t, Yt(t));
function _A(t, e) {
  return ci(t, (r) => r.empty ? t.moveByGroup(r, e) : hp(r, e));
}
const xX = (t) => _A(t, !Yt(t)), bX = (t) => _A(t, Yt(t));
function DX(t, e, r) {
  if (e.type.prop(r))
    return !0;
  let i = e.to - e.from;
  return i && (i > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function pp(t, e, r) {
  let i = ht(t).resolveInner(e.head), n = r ? ke.closedBy : ke.openedBy;
  for (let u = e.head; ; ) {
    let c = r ? i.childAfter(u) : i.childBefore(u);
    if (!c)
      break;
    DX(t, c, n) ? i = c : u = r ? c.to : c.from;
  }
  let s = i.type.prop(n), a, o;
  return s && (a = r ? Ei(t, i.from, 1) : Ei(t, i.to, -1)) && a.matched ? o = r ? a.end.to : a.end.from : o = r ? i.to : i.from, U.cursor(o, r ? -1 : 1);
}
const vX = (t) => ci(t, (e) => pp(t.state, e, !Yt(t))), SX = (t) => ci(t, (e) => pp(t.state, e, Yt(t)));
function QA(t, e) {
  return ci(t, (r) => {
    if (!r.empty)
      return hp(r, e);
    let i = t.moveVertically(r, e);
    return i.head != r.head ? i : t.moveToLineBoundary(r, e);
  });
}
const MA = (t) => QA(t, !1), LA = (t) => QA(t, !0);
function RA(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, r = 0, i = 0, n;
  if (e) {
    for (let s of t.state.facet(oe.scrollMargins)) {
      let a = s(t);
      a != null && a.top && (r = Math.max(a == null ? void 0 : a.top, r)), a != null && a.bottom && (i = Math.max(a == null ? void 0 : a.bottom, i));
    }
    n = t.scrollDOM.clientHeight - r - i;
  } else
    n = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: r,
    marginBottom: i,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, n - 5)
  };
}
function jA(t, e) {
  let r = RA(t), { state: i } = t, n = io(i.selection, (a) => a.empty ? t.moveVertically(a, e, r.height) : hp(a, e));
  if (n.eq(i.selection))
    return !1;
  let s;
  if (r.selfScroll) {
    let a = t.coordsAtPos(i.selection.main.head), o = t.scrollDOM.getBoundingClientRect(), u = o.top + r.marginTop, c = o.bottom - r.marginBottom;
    a && a.top > u && a.bottom < c && (s = oe.scrollIntoView(n.main.head, { y: "start", yMargin: a.top - u }));
  }
  return t.dispatch(Wi(i, n), { effects: s }), !0;
}
const mx = (t) => jA(t, !1), dm = (t) => jA(t, !0);
function rs(t, e, r) {
  let i = t.lineBlockAt(e.head), n = t.moveToLineBoundary(e, r);
  if (n.head == e.head && n.head != (r ? i.to : i.from) && (n = t.moveToLineBoundary(e, r, !1)), !r && n.head == i.from && i.length) {
    let s = /^\s*/.exec(t.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    s && e.head != i.from + s && (n = U.cursor(i.from + s));
  }
  return n;
}
const wX = (t) => ci(t, (e) => rs(t, e, !0)), CX = (t) => ci(t, (e) => rs(t, e, !1)), AX = (t) => ci(t, (e) => rs(t, e, !Yt(t))), EX = (t) => ci(t, (e) => rs(t, e, Yt(t))), kX = (t) => ci(t, (e) => U.cursor(t.lineBlockAt(e.head).from, 1)), TX = (t) => ci(t, (e) => U.cursor(t.lineBlockAt(e.head).to, -1));
function PX(t, e, r) {
  let i = !1, n = io(t.selection, (s) => {
    let a = Ei(t, s.head, -1) || Ei(t, s.head, 1) || s.head > 0 && Ei(t, s.head - 1, 1) || s.head < t.doc.length && Ei(t, s.head + 1, -1);
    if (!a || !a.end)
      return s;
    i = !0;
    let o = a.start.from == s.head ? a.end.to : a.end.from;
    return r ? U.range(s.anchor, o) : U.cursor(o);
  });
  return i ? (e(Wi(t, n)), !0) : !1;
}
const FX = ({ state: t, dispatch: e }) => PX(t, e, !1);
function Yr(t, e) {
  let r = io(t.state.selection, (i) => {
    let n = e(i);
    return U.range(i.anchor, n.head, n.goalColumn, n.bidiLevel || void 0);
  });
  return r.eq(t.state.selection) ? !1 : (t.dispatch(Wi(t.state, r)), !0);
}
function ZA(t, e) {
  return Yr(t, (r) => t.moveByChar(r, e));
}
const WA = (t) => ZA(t, !Yt(t)), qA = (t) => ZA(t, Yt(t));
function XA(t, e) {
  return Yr(t, (r) => t.moveByGroup(r, e));
}
const $X = (t) => XA(t, !Yt(t)), BX = (t) => XA(t, Yt(t)), IX = (t) => Yr(t, (e) => pp(t.state, e, !Yt(t))), NX = (t) => Yr(t, (e) => pp(t.state, e, Yt(t)));
function VA(t, e) {
  return Yr(t, (r) => t.moveVertically(r, e));
}
const YA = (t) => VA(t, !1), UA = (t) => VA(t, !0);
function zA(t, e) {
  return Yr(t, (r) => t.moveVertically(r, e, RA(t).height));
}
const gx = (t) => zA(t, !1), yx = (t) => zA(t, !0), _X = (t) => Yr(t, (e) => rs(t, e, !0)), QX = (t) => Yr(t, (e) => rs(t, e, !1)), MX = (t) => Yr(t, (e) => rs(t, e, !Yt(t))), LX = (t) => Yr(t, (e) => rs(t, e, Yt(t))), RX = (t) => Yr(t, (e) => U.cursor(t.lineBlockAt(e.head).from)), jX = (t) => Yr(t, (e) => U.cursor(t.lineBlockAt(e.head).to)), Ox = ({ state: t, dispatch: e }) => (e(Wi(t, { anchor: 0 })), !0), xx = ({ state: t, dispatch: e }) => (e(Wi(t, { anchor: t.doc.length })), !0), bx = ({ state: t, dispatch: e }) => (e(Wi(t, { anchor: t.selection.main.anchor, head: 0 })), !0), Dx = ({ state: t, dispatch: e }) => (e(Wi(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), ZX = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), WX = ({ state: t, dispatch: e }) => {
  let r = dp(t).map(({ from: i, to: n }) => U.range(i, Math.min(n + 1, t.doc.length)));
  return e(t.update({ selection: U.create(r), userEvent: "select" })), !0;
}, qX = ({ state: t, dispatch: e }) => {
  let r = io(t.selection, (i) => {
    var n;
    let s = ht(t).resolveStack(i.from, 1);
    for (let a = s; a; a = a.next) {
      let { node: o } = a;
      if ((o.from < i.from && o.to >= i.to || o.to > i.to && o.from <= i.from) && (!((n = o.parent) === null || n === void 0) && n.parent))
        return U.range(o.to, o.from);
    }
    return i;
  });
  return e(Wi(t, r)), !0;
}, XX = ({ state: t, dispatch: e }) => {
  let r = t.selection, i = null;
  return r.ranges.length > 1 ? i = U.create([r.main]) : r.main.empty || (i = U.create([U.cursor(r.main.head)])), i ? (e(Wi(t, i)), !0) : !1;
};
function iu(t, e) {
  if (t.state.readOnly)
    return !1;
  let r = "delete.selection", { state: i } = t, n = i.changeByRange((s) => {
    let { from: a, to: o } = s;
    if (a == o) {
      let u = e(s);
      u < a ? (r = "delete.backward", u = zu(t, u, !1)) : u > a && (r = "delete.forward", u = zu(t, u, !0)), a = Math.min(a, u), o = Math.max(o, u);
    } else
      a = zu(t, a, !1), o = zu(t, o, !0);
    return a == o ? { range: s } : { changes: { from: a, to: o }, range: U.cursor(a, a < s.head ? -1 : 1) };
  });
  return n.changes.empty ? !1 : (t.dispatch(i.update(n, {
    scrollIntoView: !0,
    userEvent: r,
    effects: r == "delete.selection" ? oe.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function zu(t, e, r) {
  if (t instanceof oe)
    for (let i of t.state.facet(oe.atomicRanges).map((n) => n(t)))
      i.between(e, e, (n, s) => {
        n < e && s > e && (e = r ? s : n);
      });
  return e;
}
const GA = (t, e) => iu(t, (r) => {
  let i = r.from, { state: n } = t, s = n.doc.lineAt(i), a, o;
  if (!e && i > s.from && i < s.from + 200 && !/[^ \t]/.test(a = s.text.slice(0, i - s.from))) {
    if (a[a.length - 1] == "	")
      return i - 1;
    let u = ro(a, n.tabSize), c = u % Yc(n) || Yc(n);
    for (let h = 0; h < c && a[a.length - 1 - h] == " "; h++)
      i--;
    o = i;
  } else
    o = $t(s.text, i - s.from, e, e) + s.from, o == i && s.number != (e ? n.doc.lines : 1) ? o += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(o - s.from, i - s.from)) && (o = $t(s.text, o - s.from, !1, !1) + s.from);
  return o;
}), fm = (t) => GA(t, !1), HA = (t) => GA(t, !0), JA = (t, e) => iu(t, (r) => {
  let i = r.head, { state: n } = t, s = n.doc.lineAt(i), a = n.charCategorizer(i);
  for (let o = null; ; ) {
    if (i == (e ? s.to : s.from)) {
      i == r.head && s.number != (e ? n.doc.lines : 1) && (i += e ? 1 : -1);
      break;
    }
    let u = $t(s.text, i - s.from, e) + s.from, c = s.text.slice(Math.min(i, u) - s.from, Math.max(i, u) - s.from), h = a(c);
    if (o != null && h != o)
      break;
    (c != " " || i != r.head) && (o = h), i = u;
  }
  return i;
}), KA = (t) => JA(t, !1), VX = (t) => JA(t, !0), YX = (t) => iu(t, (e) => {
  let r = t.lineBlockAt(e.head).to;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), UX = (t) => iu(t, (e) => {
  let r = t.moveToLineBoundary(e, !1).head;
  return e.head > r ? r : Math.max(0, e.head - 1);
}), zX = (t) => iu(t, (e) => {
  let r = t.moveToLineBoundary(e, !0).head;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), GX = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: je.of(["", ""]) },
    range: U.cursor(i.from)
  }));
  return e(t.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
}, HX = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == t.doc.length)
      return { range: i };
    let n = i.from, s = t.doc.lineAt(n), a = n == s.from ? n - 1 : $t(s.text, n - s.from, !1) + s.from, o = n == s.to ? n + 1 : $t(s.text, n - s.from, !0) + s.from;
    return {
      changes: { from: a, to: o, insert: t.doc.slice(n, o).append(t.doc.slice(a, n)) },
      range: U.cursor(o)
    };
  });
  return r.changes.empty ? !1 : (e(t.update(r, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function dp(t) {
  let e = [], r = -1;
  for (let i of t.selection.ranges) {
    let n = t.doc.lineAt(i.from), s = t.doc.lineAt(i.to);
    if (!i.empty && i.to == s.from && (s = t.doc.lineAt(i.to - 1)), r >= n.number) {
      let a = e[e.length - 1];
      a.to = s.to, a.ranges.push(i);
    } else
      e.push({ from: n.from, to: s.to, ranges: [i] });
    r = s.number + 1;
  }
  return e;
}
function eE(t, e, r) {
  if (t.readOnly)
    return !1;
  let i = [], n = [];
  for (let s of dp(t)) {
    if (r ? s.to == t.doc.length : s.from == 0)
      continue;
    let a = t.doc.lineAt(r ? s.to + 1 : s.from - 1), o = a.length + 1;
    if (r) {
      i.push({ from: s.to, to: a.to }, { from: s.from, insert: a.text + t.lineBreak });
      for (let u of s.ranges)
        n.push(U.range(Math.min(t.doc.length, u.anchor + o), Math.min(t.doc.length, u.head + o)));
    } else {
      i.push({ from: a.from, to: s.from }, { from: s.to, insert: t.lineBreak + a.text });
      for (let u of s.ranges)
        n.push(U.range(u.anchor - o, u.head - o));
    }
  }
  return i.length ? (e(t.update({
    changes: i,
    scrollIntoView: !0,
    selection: U.create(n, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const JX = ({ state: t, dispatch: e }) => eE(t, e, !1), KX = ({ state: t, dispatch: e }) => eE(t, e, !0);
function tE(t, e, r) {
  if (t.readOnly)
    return !1;
  let i = [];
  for (let n of dp(t))
    r ? i.push({ from: n.from, insert: t.doc.slice(n.from, n.to) + t.lineBreak }) : i.push({ from: n.to, insert: t.lineBreak + t.doc.slice(n.from, n.to) });
  return e(t.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const eV = ({ state: t, dispatch: e }) => tE(t, e, !1), tV = ({ state: t, dispatch: e }) => tE(t, e, !0), rV = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, r = e.changes(dp(e).map(({ from: n, to: s }) => (n > 0 ? n-- : s < e.doc.length && s++, { from: n, to: s }))), i = io(e.selection, (n) => t.moveVertically(n, !0)).map(r);
  return t.dispatch({ changes: r, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function iV(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let r = ht(t).resolveInner(e), i = r.childBefore(e), n = r.childAfter(e), s;
  return i && n && i.to <= e && n.from >= e && (s = i.type.prop(ke.closedBy)) && s.indexOf(n.name) > -1 && t.doc.lineAt(i.to).from == t.doc.lineAt(n.from).from && !/\S/.test(t.sliceDoc(i.to, n.from)) ? { from: i.to, to: n.from } : null;
}
const nV = /* @__PURE__ */ rE(!1), sV = /* @__PURE__ */ rE(!0);
function rE(t) {
  return ({ state: e, dispatch: r }) => {
    if (e.readOnly)
      return !1;
    let i = e.changeByRange((n) => {
      let { from: s, to: a } = n, o = e.doc.lineAt(s), u = !t && s == a && iV(e, s);
      t && (s = a = (a <= o.to ? o : e.doc.lineAt(a)).to);
      let c = new lp(e, { simulateBreak: s, simulateDoubleBreak: !!u }), h = by(c, s);
      for (h == null && (h = ro(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); a < o.to && /\s/.test(o.text[a - o.from]); )
        a++;
      u ? { from: s, to: a } = u : s > o.from && s < o.from + 100 && !/\S/.test(o.text.slice(0, s)) && (s = o.from);
      let d = ["", vl(e, h)];
      return u && d.push(vl(e, c.lineIndent(o.from, -1))), {
        changes: { from: s, to: a, insert: je.of(d) },
        range: U.cursor(s + 1 + d[1].length)
      };
    });
    return r(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Ay(t, e) {
  let r = -1;
  return t.changeByRange((i) => {
    let n = [];
    for (let a = i.from; a <= i.to; ) {
      let o = t.doc.lineAt(a);
      o.number > r && (i.empty || i.to > o.from) && (e(o, n, i), r = o.number), a = o.to + 1;
    }
    let s = t.changes(n);
    return {
      changes: n,
      range: U.range(s.mapPos(i.anchor, 1), s.mapPos(i.head, 1))
    };
  });
}
const aV = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = /* @__PURE__ */ Object.create(null), i = new lp(t, { overrideIndentation: (s) => {
    let a = r[s];
    return a ?? -1;
  } }), n = Ay(t, (s, a, o) => {
    let u = by(i, s.from);
    if (u == null)
      return;
    /\S/.test(s.text) || (u = 0);
    let c = /^\s*/.exec(s.text)[0], h = vl(t, u);
    (c != h || o.from < s.from + c.length) && (r[s.from] = u, a.push({ from: s.from, to: s.from + c.length, insert: h }));
  });
  return n.changes.empty || e(t.update(n, { userEvent: "indent" })), !0;
}, iE = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Ay(t, (r, i) => {
  i.push({ from: r.from, insert: t.facet(Jl) });
}), { userEvent: "input.indent" })), !0), nE = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Ay(t, (r, i) => {
  let n = /^\s*/.exec(r.text)[0];
  if (!n)
    return;
  let s = ro(n, t.tabSize), a = 0, o = vl(t, Math.max(0, s - Yc(t)));
  for (; a < n.length && a < o.length && n.charCodeAt(a) == o.charCodeAt(a); )
    a++;
  i.push({ from: r.from + a, to: r.from + n.length, insert: o.slice(a) });
}), { userEvent: "delete.dedent" })), !0), oV = [
  { key: "Ctrl-b", run: IA, shift: WA, preventDefault: !0 },
  { key: "Ctrl-f", run: NA, shift: qA },
  { key: "Ctrl-p", run: MA, shift: YA },
  { key: "Ctrl-n", run: LA, shift: UA },
  { key: "Ctrl-a", run: kX, shift: RX },
  { key: "Ctrl-e", run: TX, shift: jX },
  { key: "Ctrl-d", run: HA },
  { key: "Ctrl-h", run: fm },
  { key: "Ctrl-k", run: YX },
  { key: "Ctrl-Alt-h", run: KA },
  { key: "Ctrl-o", run: GX },
  { key: "Ctrl-t", run: HX },
  { key: "Ctrl-v", run: dm }
], lV = /* @__PURE__ */ [
  { key: "ArrowLeft", run: IA, shift: WA, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: xX, shift: $X, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: AX, shift: MX, preventDefault: !0 },
  { key: "ArrowRight", run: NA, shift: qA, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: bX, shift: BX, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: EX, shift: LX, preventDefault: !0 },
  { key: "ArrowUp", run: MA, shift: YA, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Ox, shift: bx },
  { mac: "Ctrl-ArrowUp", run: mx, shift: gx },
  { key: "ArrowDown", run: LA, shift: UA, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: xx, shift: Dx },
  { mac: "Ctrl-ArrowDown", run: dm, shift: yx },
  { key: "PageUp", run: mx, shift: gx },
  { key: "PageDown", run: dm, shift: yx },
  { key: "Home", run: CX, shift: QX, preventDefault: !0 },
  { key: "Mod-Home", run: Ox, shift: bx },
  { key: "End", run: wX, shift: _X, preventDefault: !0 },
  { key: "Mod-End", run: xx, shift: Dx },
  { key: "Enter", run: nV },
  { key: "Mod-a", run: ZX },
  { key: "Backspace", run: fm, shift: fm },
  { key: "Delete", run: HA },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: KA },
  { key: "Mod-Delete", mac: "Alt-Delete", run: VX },
  { mac: "Mod-Backspace", run: UX },
  { mac: "Mod-Delete", run: zX }
].concat(/* @__PURE__ */ oV.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), uV = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: vX, shift: IX },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: SX, shift: NX },
  { key: "Alt-ArrowUp", run: JX },
  { key: "Shift-Alt-ArrowUp", run: eV },
  { key: "Alt-ArrowDown", run: KX },
  { key: "Shift-Alt-ArrowDown", run: tV },
  { key: "Escape", run: XX },
  { key: "Mod-Enter", run: sV },
  { key: "Alt-l", mac: "Ctrl-l", run: WX },
  { key: "Mod-i", run: qX, preventDefault: !0 },
  { key: "Mod-[", run: nE },
  { key: "Mod-]", run: iE },
  { key: "Mod-Alt-\\", run: aV },
  { key: "Shift-Mod-k", run: rV },
  { key: "Shift-Mod-\\", run: FX },
  { key: "Mod-/", run: eX },
  { key: "Alt-A", run: rX }
].concat(lV), cV = { key: "Tab", run: iE, shift: nE };
function Je() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, r = arguments[1];
  if (r && typeof r == "object" && r.nodeType == null && !Array.isArray(r)) {
    for (var i in r)
      if (Object.prototype.hasOwnProperty.call(r, i)) {
        var n = r[i];
        typeof n == "string" ? t.setAttribute(i, n) : n != null && (t[i] = n);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    sE(t, arguments[e]);
  return t;
}
function sE(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      t.appendChild(e);
    else if (Array.isArray(e))
      for (var r = 0; r < e.length; r++)
        sE(t, e[r]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const vx = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class La {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, r, i = 0, n = e.length, s, a) {
    this.test = a, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, n), this.bufferStart = i, this.normalize = s ? (o) => s(vx(o)) : vx, this.query = this.normalize(r);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Et(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let r = iy(e), i = this.bufferStart + this.bufferPos;
      this.bufferPos += Nr(e);
      let n = this.normalize(r);
      for (let s = 0, a = i; ; s++) {
        let o = n.charCodeAt(s), u = this.match(o, a, this.bufferPos + this.bufferStart);
        if (s == n.length - 1) {
          if (u)
            return this.value = u, this;
          break;
        }
        a == i && s < r.length && r.charCodeAt(s) == o && a++;
      }
    }
  }
  match(e, r, i) {
    let n = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let a = this.matches[s], o = !1;
      this.query.charCodeAt(a) == e && (a == this.query.length - 1 ? n = { from: this.matches[s + 1], to: i } : (this.matches[s]++, o = !0)), o || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? n = { from: r, to: i } : this.matches.push(1, r)), n && this.test && !this.test(n.from, n.to, this.buffer, this.bufferStart) && (n = null), n;
  }
}
typeof Symbol < "u" && (La.prototype[Symbol.iterator] = function() {
  return this;
});
const aE = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Ey = "gm" + (/x/.unicode == null ? "" : "u");
class oE {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, r, i, n = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = aE, /\\[sWDnr]|\n|\r|\[\^/.test(r))
      return new lE(e, r, i, n, s);
    this.re = new RegExp(r, Ey + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = e.iter();
    let a = e.lineAt(n);
    this.curLineStart = a.from, this.matchPos = Hc(e, n), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let r = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (r) {
        let i = this.curLineStart + r.index, n = i + r[0].length;
        if (this.matchPos = Hc(this.text, n + (i == n ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < n || i > this.value.to) && (!this.test || this.test(i, n, r)))
          return this.value = { from: i, to: n, match: r }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Dd = /* @__PURE__ */ new WeakMap();
class Ca {
  constructor(e, r) {
    this.from = e, this.text = r;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, r, i) {
    let n = Dd.get(e);
    if (!n || n.from >= i || n.to <= r) {
      let o = new Ca(r, e.sliceString(r, i));
      return Dd.set(e, o), o;
    }
    if (n.from == r && n.to == i)
      return n;
    let { text: s, from: a } = n;
    return a > r && (s = e.sliceString(r, a) + s, a = r), n.to < i && (s += e.sliceString(n.to, i)), Dd.set(e, new Ca(a, s)), new Ca(r, s.slice(r - a, i - a));
  }
}
class lE {
  constructor(e, r, i, n, s) {
    this.text = e, this.to = s, this.done = !1, this.value = aE, this.matchPos = Hc(e, n), this.re = new RegExp(r, Ey + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = Ca.get(e, n, this.chunkEnd(
      n + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, r = this.re.exec(this.flat.text);
      if (r && !r[0] && r.index == e && (this.re.lastIndex = e + 1, r = this.re.exec(this.flat.text)), r) {
        let i = this.flat.from + r.index, n = i + r[0].length;
        if ((this.flat.to >= this.to || r.index + r[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, n, r)))
          return this.value = { from: i, to: n, match: r }, this.matchPos = Hc(this.text, n + (i == n ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Ca.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (oE.prototype[Symbol.iterator] = lE.prototype[Symbol.iterator] = function() {
  return this;
});
function hV(t) {
  try {
    return new RegExp(t, Ey), !0;
  } catch {
    return !1;
  }
}
function Hc(t, e) {
  if (e >= t.length)
    return e;
  let r = t.lineAt(e), i;
  for (; e < r.to && (i = r.text.charCodeAt(e - r.from)) >= 56320 && i < 57344; )
    e++;
  return e;
}
function mm(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), r = Je("input", { class: "cm-textfield", name: "line", value: e }), i = Je("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), t.dispatch({ effects: Jc.of(!1) }), t.focus()) : s.keyCode == 13 && (s.preventDefault(), n());
    },
    onsubmit: (s) => {
      s.preventDefault(), n();
    }
  }, Je("label", t.state.phrase("Go to line"), ": ", r), " ", Je("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")));
  function n() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(r.value);
    if (!s)
      return;
    let { state: a } = t, o = a.doc.lineAt(a.selection.main.head), [, u, c, h, d] = s, m = h ? +h.slice(1) : 0, y = c ? +c : o.number;
    if (c && d) {
      let v = y / 100;
      u && (v = v * (u == "-" ? -1 : 1) + o.number / a.doc.lines), y = Math.round(a.doc.lines * v);
    } else
      c && u && (y = y * (u == "-" ? -1 : 1) + o.number);
    let O = a.doc.line(Math.max(1, Math.min(a.doc.lines, y))), b = U.cursor(O.from + Math.max(0, Math.min(m, O.length)));
    t.dispatch({
      effects: [Jc.of(!1), oe.scrollIntoView(b.from, { y: "center" })],
      selection: b
    }), t.focus();
  }
  return { dom: i };
}
const Jc = /* @__PURE__ */ we.define(), Sx = /* @__PURE__ */ St.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(Jc) && (t = r.value);
    return t;
  },
  provide: (t) => xl.from(t, (e) => e ? mm : null)
}), pV = (t) => {
  let e = Ol(t, mm);
  if (!e) {
    let r = [Jc.of(!0)];
    t.state.field(Sx, !1) == null && r.push(we.appendConfig.of([Sx, dV])), t.dispatch({ effects: r }), e = Ol(t, mm);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, dV = /* @__PURE__ */ oe.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), fV = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, uE = /* @__PURE__ */ fe.define({
  combine(t) {
    return ji(t, fV, {
      highlightWordAroundCursor: (e, r) => e || r,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function mV(t) {
  let e = [bV, xV];
  return t && e.push(uE.of(t)), e;
}
const gV = /* @__PURE__ */ xe.mark({ class: "cm-selectionMatch" }), yV = /* @__PURE__ */ xe.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function wx(t, e, r, i) {
  return (r == 0 || t(e.sliceDoc(r - 1, r)) != st.Word) && (i == e.doc.length || t(e.sliceDoc(i, i + 1)) != st.Word);
}
function OV(t, e, r, i) {
  return t(e.sliceDoc(r, r + 1)) == st.Word && t(e.sliceDoc(i - 1, i)) == st.Word;
}
const xV = /* @__PURE__ */ ft.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(uE), { state: r } = t, i = r.selection;
    if (i.ranges.length > 1)
      return xe.none;
    let n = i.main, s, a = null;
    if (n.empty) {
      if (!e.highlightWordAroundCursor)
        return xe.none;
      let u = r.wordAt(n.head);
      if (!u)
        return xe.none;
      a = r.charCategorizer(n.head), s = r.sliceDoc(u.from, u.to);
    } else {
      let u = n.to - n.from;
      if (u < e.minSelectionLength || u > 200)
        return xe.none;
      if (e.wholeWords) {
        if (s = r.sliceDoc(n.from, n.to), a = r.charCategorizer(n.head), !(wx(a, r, n.from, n.to) && OV(a, r, n.from, n.to)))
          return xe.none;
      } else if (s = r.sliceDoc(n.from, n.to), !s)
        return xe.none;
    }
    let o = [];
    for (let u of t.visibleRanges) {
      let c = new La(r.doc, s, u.from, u.to);
      for (; !c.next().done; ) {
        let { from: h, to: d } = c.value;
        if ((!a || wx(a, r, h, d)) && (n.empty && h <= n.from && d >= n.to ? o.push(yV.range(h, d)) : (h >= n.to || d <= n.from) && o.push(gV.range(h, d)), o.length > e.maxMatches))
          return xe.none;
      }
    }
    return xe.set(o);
  }
}, {
  decorations: (t) => t.decorations
}), bV = /* @__PURE__ */ oe.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), DV = ({ state: t, dispatch: e }) => {
  let { selection: r } = t, i = U.create(r.ranges.map((n) => t.wordAt(n.head) || U.cursor(n.head)), r.mainIndex);
  return i.eq(r) ? !1 : (e(t.update({ selection: i })), !0);
};
function vV(t, e) {
  let { main: r, ranges: i } = t.selection, n = t.wordAt(r.head), s = n && n.from == r.from && n.to == r.to;
  for (let a = !1, o = new La(t.doc, e, i[i.length - 1].to); ; )
    if (o.next(), o.done) {
      if (a)
        return null;
      o = new La(t.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), a = !0;
    } else {
      if (a && i.some((u) => u.from == o.value.from))
        continue;
      if (s) {
        let u = t.wordAt(o.value.from);
        if (!u || u.from != o.value.from || u.to != o.value.to)
          continue;
      }
      return o.value;
    }
}
const SV = ({ state: t, dispatch: e }) => {
  let { ranges: r } = t.selection;
  if (r.some((s) => s.from === s.to))
    return DV({ state: t, dispatch: e });
  let i = t.sliceDoc(r[0].from, r[0].to);
  if (t.selection.ranges.some((s) => t.sliceDoc(s.from, s.to) != i))
    return !1;
  let n = vV(t, i);
  return n ? (e(t.update({
    selection: t.selection.addRange(U.range(n.from, n.to), !1),
    effects: oe.scrollIntoView(n.to)
  })), !0) : !1;
}, no = /* @__PURE__ */ fe.define({
  combine(t) {
    return ji(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new NV(e),
      scrollToMatch: (e) => oe.scrollIntoView(e)
    });
  }
});
class cE {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || hV(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (r, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new EV(this) : new CV(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, r = 0, i) {
    let n = e.doc ? e : Ie.create({ doc: e });
    return i == null && (i = n.doc.length), this.regexp ? ha(this, n, r, i) : ca(this, n, r, i);
  }
}
class hE {
  constructor(e) {
    this.spec = e;
  }
}
function ca(t, e, r, i) {
  return new La(e.doc, t.unquoted, r, i, t.caseSensitive ? void 0 : (n) => n.toLowerCase(), t.wholeWord ? wV(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function wV(t, e) {
  return (r, i, n, s) => ((s > r || s + n.length < i) && (s = Math.max(0, r - 2), n = t.sliceString(s, Math.min(t.length, i + 2))), (e(Kc(n, r - s)) != st.Word || e(eh(n, r - s)) != st.Word) && (e(eh(n, i - s)) != st.Word || e(Kc(n, i - s)) != st.Word));
}
class CV extends hE {
  constructor(e) {
    super(e);
  }
  nextMatch(e, r, i) {
    let n = ca(this.spec, e, i, e.doc.length).nextOverlapping();
    return n.done && (n = ca(this.spec, e, 0, r).nextOverlapping()), n.done ? null : n.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, r, i) {
    for (let n = i; ; ) {
      let s = Math.max(r, n - 1e4 - this.spec.unquoted.length), a = ca(this.spec, e, s, n), o = null;
      for (; !a.nextOverlapping().done; )
        o = a.value;
      if (o)
        return o;
      if (s == r)
        return null;
      n -= 1e4;
    }
  }
  prevMatch(e, r, i) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, r) {
    let i = ca(this.spec, e, 0, e.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= r)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(e, r, i, n) {
    let s = ca(this.spec, e, Math.max(0, r - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      n(s.value.from, s.value.to);
  }
}
function ha(t, e, r, i) {
  return new oE(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? AV(e.charCategorizer(e.selection.main.head)) : void 0
  }, r, i);
}
function Kc(t, e) {
  return t.slice($t(t, e, !1), e);
}
function eh(t, e) {
  return t.slice(e, $t(t, e));
}
function AV(t) {
  return (e, r, i) => !i[0].length || (t(Kc(i.input, i.index)) != st.Word || t(eh(i.input, i.index)) != st.Word) && (t(eh(i.input, i.index + i[0].length)) != st.Word || t(Kc(i.input, i.index + i[0].length)) != st.Word);
}
class EV extends hE {
  nextMatch(e, r, i) {
    let n = ha(this.spec, e, i, e.doc.length).next();
    return n.done && (n = ha(this.spec, e, 0, r).next()), n.done ? null : n.value;
  }
  prevMatchInRange(e, r, i) {
    for (let n = 1; ; n++) {
      let s = Math.max(
        r,
        i - n * 1e4
        /* FindPrev.ChunkSize */
      ), a = ha(this.spec, e, s, i), o = null;
      for (; !a.next().done; )
        o = a.value;
      if (o && (s == r || o.from > s + 10))
        return o;
      if (s == r)
        return null;
    }
  }
  prevMatch(e, r, i) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (r, i) => i == "$" ? "$" : i == "&" ? e.match[0] : i != "0" && +i < e.match.length ? e.match[i] : r);
  }
  matchAll(e, r) {
    let i = ha(this.spec, e, 0, e.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= r)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(e, r, i, n) {
    let s = ha(this.spec, e, Math.max(
      0,
      r - 250
      /* RegExp.HighlightMargin */
    ), Math.min(i + 250, e.doc.length));
    for (; !s.next().done; )
      n(s.value.from, s.value.to);
  }
}
const Sl = /* @__PURE__ */ we.define(), ky = /* @__PURE__ */ we.define(), Qn = /* @__PURE__ */ St.define({
  create(t) {
    return new vd(gm(t).create(), null);
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(Sl) ? t = new vd(r.value.create(), t.panel) : r.is(ky) && (t = new vd(t.query, r.value ? Ty : null));
    return t;
  },
  provide: (t) => xl.from(t, (e) => e.panel)
});
class vd {
  constructor(e, r) {
    this.query = e, this.panel = r;
  }
}
const kV = /* @__PURE__ */ xe.mark({ class: "cm-searchMatch" }), TV = /* @__PURE__ */ xe.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), PV = /* @__PURE__ */ ft.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(Qn));
  }
  update(t) {
    let e = t.state.field(Qn);
    (e != t.startState.field(Qn) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return xe.none;
    let { view: r } = this, i = new qn();
    for (let n = 0, s = r.visibleRanges, a = s.length; n < a; n++) {
      let { from: o, to: u } = s[n];
      for (; n < a - 1 && u > s[n + 1].from - 2 * 250; )
        u = s[++n].to;
      t.highlight(r.state, o, u, (c, h) => {
        let d = r.state.selection.ranges.some((m) => m.from == c && m.to == h);
        i.add(c, h, d ? TV : kV);
      });
    }
    return i.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function nu(t) {
  return (e) => {
    let r = e.state.field(Qn, !1);
    return r && r.query.spec.valid ? t(e, r) : fE(e);
  };
}
const th = /* @__PURE__ */ nu((t, { query: e }) => {
  let { to: r } = t.state.selection.main, i = e.nextMatch(t.state, r, r);
  if (!i)
    return !1;
  let n = U.single(i.from, i.to), s = t.state.facet(no);
  return t.dispatch({
    selection: n,
    effects: [Py(t, i), s.scrollToMatch(n.main, t)],
    userEvent: "select.search"
  }), dE(t), !0;
}), rh = /* @__PURE__ */ nu((t, { query: e }) => {
  let { state: r } = t, { from: i } = r.selection.main, n = e.prevMatch(r, i, i);
  if (!n)
    return !1;
  let s = U.single(n.from, n.to), a = t.state.facet(no);
  return t.dispatch({
    selection: s,
    effects: [Py(t, n), a.scrollToMatch(s.main, t)],
    userEvent: "select.search"
  }), dE(t), !0;
}), FV = /* @__PURE__ */ nu((t, { query: e }) => {
  let r = e.matchAll(t.state, 1e3);
  return !r || !r.length ? !1 : (t.dispatch({
    selection: U.create(r.map((i) => U.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), $V = ({ state: t, dispatch: e }) => {
  let r = t.selection;
  if (r.ranges.length > 1 || r.main.empty)
    return !1;
  let { from: i, to: n } = r.main, s = [], a = 0;
  for (let o = new La(t.doc, t.sliceDoc(i, n)); !o.next().done; ) {
    if (s.length > 1e3)
      return !1;
    o.value.from == i && (a = s.length), s.push(U.range(o.value.from, o.value.to));
  }
  return e(t.update({
    selection: U.create(s, a),
    userEvent: "select.search.matches"
  })), !0;
}, Cx = /* @__PURE__ */ nu((t, { query: e }) => {
  let { state: r } = t, { from: i, to: n } = r.selection.main;
  if (r.readOnly)
    return !1;
  let s = e.nextMatch(r, i, i);
  if (!s)
    return !1;
  let a = [], o, u, c = [];
  if (s.from == i && s.to == n && (u = r.toText(e.getReplacement(s)), a.push({ from: s.from, to: s.to, insert: u }), s = e.nextMatch(r, s.from, s.to), c.push(oe.announce.of(r.phrase("replaced match on line $", r.doc.lineAt(i).number) + "."))), s) {
    let h = a.length == 0 || a[0].from >= s.to ? 0 : s.to - s.from - u.length;
    o = U.single(s.from - h, s.to - h), c.push(Py(t, s)), c.push(r.facet(no).scrollToMatch(o.main, t));
  }
  return t.dispatch({
    changes: a,
    selection: o,
    effects: c,
    userEvent: "input.replace"
  }), !0;
}), BV = /* @__PURE__ */ nu((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let r = e.matchAll(t.state, 1e9).map((n) => {
    let { from: s, to: a } = n;
    return { from: s, to: a, insert: e.getReplacement(n) };
  });
  if (!r.length)
    return !1;
  let i = t.state.phrase("replaced $ matches", r.length) + ".";
  return t.dispatch({
    changes: r,
    effects: oe.announce.of(i),
    userEvent: "input.replace.all"
  }), !0;
});
function Ty(t) {
  return t.state.facet(no).createPanel(t);
}
function gm(t, e) {
  var r, i, n, s, a;
  let o = t.selection.main, u = o.empty || o.to > o.from + 100 ? "" : t.sliceDoc(o.from, o.to);
  if (e && !u)
    return e;
  let c = t.facet(no);
  return new cE({
    search: ((r = e == null ? void 0 : e.literal) !== null && r !== void 0 ? r : c.literal) ? u : u.replace(/\n/g, "\\n"),
    caseSensitive: (i = e == null ? void 0 : e.caseSensitive) !== null && i !== void 0 ? i : c.caseSensitive,
    literal: (n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : c.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : c.regexp,
    wholeWord: (a = e == null ? void 0 : e.wholeWord) !== null && a !== void 0 ? a : c.wholeWord
  });
}
function pE(t) {
  let e = Ol(t, Ty);
  return e && e.dom.querySelector("[main-field]");
}
function dE(t) {
  let e = pE(t);
  e && e == t.root.activeElement && e.select();
}
const fE = (t) => {
  let e = t.state.field(Qn, !1);
  if (e && e.panel) {
    let r = pE(t);
    if (r && r != t.root.activeElement) {
      let i = gm(t.state, e.query.spec);
      i.valid && t.dispatch({ effects: Sl.of(i) }), r.focus(), r.select();
    }
  } else
    t.dispatch({ effects: [
      ky.of(!0),
      e ? Sl.of(gm(t.state, e.query.spec)) : we.appendConfig.of(QV)
    ] });
  return !0;
}, mE = (t) => {
  let e = t.state.field(Qn, !1);
  if (!e || !e.panel)
    return !1;
  let r = Ol(t, Ty);
  return r && r.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: ky.of(!1) }), !0;
}, IV = [
  { key: "Mod-f", run: fE, scope: "editor search-panel" },
  { key: "F3", run: th, shift: rh, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: th, shift: rh, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: mE, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: $V },
  { key: "Mod-Alt-g", run: pV },
  { key: "Mod-d", run: SV, preventDefault: !0 }
];
class NV {
  constructor(e) {
    this.view = e;
    let r = this.query = e.state.field(Qn).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Je("input", {
      value: r.search,
      placeholder: pr(e, "Find"),
      "aria-label": pr(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Je("input", {
      value: r.replace,
      placeholder: pr(e, "Replace"),
      "aria-label": pr(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Je("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: r.caseSensitive,
      onchange: this.commit
    }), this.reField = Je("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: r.regexp,
      onchange: this.commit
    }), this.wordField = Je("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: r.wholeWord,
      onchange: this.commit
    });
    function i(n, s, a) {
      return Je("button", { class: "cm-button", name: n, onclick: s, type: "button" }, a);
    }
    this.dom = Je("div", { onkeydown: (n) => this.keydown(n), class: "cm-search" }, [
      this.searchField,
      i("next", () => th(e), [pr(e, "next")]),
      i("prev", () => rh(e), [pr(e, "previous")]),
      i("select", () => FV(e), [pr(e, "all")]),
      Je("label", null, [this.caseField, pr(e, "match case")]),
      Je("label", null, [this.reField, pr(e, "regexp")]),
      Je("label", null, [this.wordField, pr(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Je("br"),
        this.replaceField,
        i("replace", () => Cx(e), [pr(e, "replace")]),
        i("replaceAll", () => BV(e), [pr(e, "replace all")])
      ],
      Je("button", {
        name: "close",
        onclick: () => mE(e),
        "aria-label": pr(e, "close"),
        type: "button"
      }, [""])
    ]);
  }
  commit() {
    let e = new cE({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: Sl.of(e) }));
  }
  keydown(e) {
    WZ(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? rh : th)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Cx(this.view));
  }
  update(e) {
    for (let r of e.transactions)
      for (let i of r.effects)
        i.is(Sl) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(no).top;
  }
}
function pr(t, e) {
  return t.state.phrase(e);
}
const Gu = 30, Hu = /[\s\.,:;?!]/;
function Py(t, { from: e, to: r }) {
  let i = t.state.doc.lineAt(e), n = t.state.doc.lineAt(r).to, s = Math.max(i.from, e - Gu), a = Math.min(n, r + Gu), o = t.state.sliceDoc(s, a);
  if (s != i.from) {
    for (let u = 0; u < Gu; u++)
      if (!Hu.test(o[u + 1]) && Hu.test(o[u])) {
        o = o.slice(u);
        break;
      }
  }
  if (a != n) {
    for (let u = o.length - 1; u > o.length - Gu; u--)
      if (!Hu.test(o[u - 1]) && Hu.test(o[u])) {
        o = o.slice(0, u);
        break;
      }
  }
  return oe.announce.of(`${t.state.phrase("current match")}. ${o} ${t.state.phrase("on line")} ${i.number}.`);
}
const _V = /* @__PURE__ */ oe.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), QV = [
  Qn,
  /* @__PURE__ */ Ys.low(PV),
  _V
];
class gE {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(e, r, i) {
    this.state = e, this.pos = r, this.explicit = i, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let r = ht(this.state).resolveInner(this.pos, -1);
    for (; r && e.indexOf(r.name) < 0; )
      r = r.parent;
    return r ? {
      from: r.from,
      to: this.pos,
      text: this.state.sliceDoc(r.from, this.pos),
      type: r.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let r = this.state.doc.lineAt(this.pos), i = Math.max(r.from, this.pos - 250), n = r.text.slice(i - r.from, this.pos - r.from), s = n.search(OE(e, !1));
    return s < 0 ? null : { from: i + s, to: this.pos, text: n.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, r) {
    e == "abort" && this.abortListeners && this.abortListeners.push(r);
  }
}
function Ax(t) {
  let e = Object.keys(t).join(""), r = /\w/.test(e);
  return r && (e = e.replace(/\w/g, "")), `[${r ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function MV(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  for (let { label: n } of t) {
    e[n[0]] = !0;
    for (let s = 1; s < n.length; s++)
      r[n[s]] = !0;
  }
  let i = Ax(e) + Ax(r) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function yE(t) {
  let e = t.map((n) => typeof n == "string" ? { label: n } : n), [r, i] = e.every((n) => /^\w+$/.test(n.label)) ? [/\w*$/, /\w+$/] : MV(e);
  return (n) => {
    let s = n.matchBefore(i);
    return s || n.explicit ? { from: s ? s.from : n.pos, options: e, validFor: r } : null;
  };
}
function LV(t, e) {
  return (r) => {
    for (let i = ht(r.state).resolveInner(r.pos, -1); i; i = i.parent) {
      if (t.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return e(r);
  };
}
class Ex {
  constructor(e, r, i, n) {
    this.completion = e, this.source = r, this.match = i, this.score = n;
  }
}
function Mn(t) {
  return t.selection.main.from;
}
function OE(t, e) {
  var r;
  let { source: i } = t, n = e && i[0] != "^", s = i[i.length - 1] != "$";
  return !n && !s ? t : new RegExp(`${n ? "^" : ""}(?:${i})${s ? "$" : ""}`, (r = t.flags) !== null && r !== void 0 ? r : t.ignoreCase ? "i" : "");
}
const xE = /* @__PURE__ */ Ri.define();
function RV(t, e, r, i) {
  let { main: n } = t.selection, s = r - n.from, a = i - n.from;
  return Object.assign(Object.assign({}, t.changeByRange((o) => o != n && r != i && t.sliceDoc(o.from + s, o.from + a) != t.sliceDoc(r, i) ? { range: o } : {
    changes: { from: o.from + s, to: i == n.from ? o.to : o.from + a, insert: e },
    range: U.cursor(o.from + s + e.length)
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const kx = /* @__PURE__ */ new WeakMap();
function jV(t) {
  if (!Array.isArray(t))
    return t;
  let e = kx.get(t);
  return e || kx.set(t, e = yE(t)), e;
}
const ih = /* @__PURE__ */ we.define(), wl = /* @__PURE__ */ we.define();
class ZV {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let r = 0; r < e.length; ) {
      let i = Et(e, r), n = Nr(i);
      this.chars.push(i);
      let s = e.slice(r, r + n), a = s.toUpperCase();
      this.folded.push(Et(a == s ? s.toLowerCase() : a, 0)), r += n;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, r) {
    return this.score = e, this.matched = r, !0;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return !1;
    let { chars: r, folded: i, any: n, precise: s, byWord: a } = this;
    if (r.length == 1) {
      let x = Et(e, 0), w = Nr(x), k = w == e.length ? 0 : -100;
      if (x != r[0])
        if (x == i[0])
          k += -200;
        else
          return !1;
      return this.ret(k, [0, w]);
    }
    let o = e.indexOf(this.pattern);
    if (o == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let u = r.length, c = 0;
    if (o < 0) {
      for (let x = 0, w = Math.min(e.length, 200); x < w && c < u; ) {
        let k = Et(e, x);
        (k == r[c] || k == i[c]) && (n[c++] = x), x += Nr(k);
      }
      if (c < u)
        return !1;
    }
    let h = 0, d = 0, m = !1, y = 0, O = -1, b = -1, v = /[a-z]/.test(e), S = !0;
    for (let x = 0, w = Math.min(e.length, 200), k = 0; x < w && d < u; ) {
      let C = Et(e, x);
      o < 0 && (h < u && C == r[h] && (s[h++] = x), y < u && (C == r[y] || C == i[y] ? (y == 0 && (O = x), b = x + 1, y++) : y = 0));
      let E, P = C < 255 ? C >= 48 && C <= 57 || C >= 97 && C <= 122 ? 2 : C >= 65 && C <= 90 ? 1 : 0 : (E = iy(C)) != E.toLowerCase() ? 1 : E != E.toUpperCase() ? 2 : 0;
      (!x || P == 1 && v || k == 0 && P != 0) && (r[d] == C || i[d] == C && (m = !0) ? a[d++] = x : a.length && (S = !1)), k = P, x += Nr(C);
    }
    return d == u && a[0] == 0 && S ? this.result(-100 + (m ? -200 : 0), a, e) : y == u && O == 0 ? this.ret(-200 - e.length + (b == e.length ? 0 : -100), [0, b]) : o > -1 ? this.ret(-700 - e.length, [o, o + this.pattern.length]) : y == u ? this.ret(-900 - e.length, [O, b]) : d == u ? this.result(-100 + (m ? -200 : 0) + -700 + (S ? 0 : -1100), a, e) : r.length == 2 ? !1 : this.result((n[0] ? -700 : 0) + -200 + -1100, n, e);
  }
  result(e, r, i) {
    let n = [], s = 0;
    for (let a of r) {
      let o = a + (this.astral ? Nr(Et(i, a)) : 1);
      s && n[s - 1] == a ? n[s - 1] = o : (n[s++] = a, n[s++] = o);
    }
    return this.ret(e - i.length, n);
  }
}
const Ft = /* @__PURE__ */ fe.define({
  combine(t) {
    return ji(t, {
      activateOnTyping: !0,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: WV,
      compareCompletions: (e, r) => e.label.localeCompare(r.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, r) => e && r,
      closeOnBlur: (e, r) => e && r,
      icons: (e, r) => e && r,
      tooltipClass: (e, r) => (i) => Tx(e(i), r(i)),
      optionClass: (e, r) => (i) => Tx(e(i), r(i)),
      addToOptions: (e, r) => e.concat(r)
    });
  }
});
function Tx(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function WV(t, e, r, i, n, s) {
  let a = t.textDirection == it.RTL, o = a, u = !1, c = "top", h, d, m = e.left - n.left, y = n.right - e.right, O = i.right - i.left, b = i.bottom - i.top;
  if (o && m < Math.min(O, y) ? o = !1 : !o && y < Math.min(O, m) && (o = !0), O <= (o ? m : y))
    h = Math.max(n.top, Math.min(r.top, n.bottom - b)) - e.top, d = Math.min(400, o ? m : y);
  else {
    u = !0, d = Math.min(
      400,
      (a ? e.right : n.right - e.left) - 30
      /* Info.Margin */
    );
    let x = n.bottom - e.bottom;
    x >= b || x > e.top ? h = r.bottom - e.top : (c = "bottom", h = e.bottom - r.top);
  }
  let v = (e.bottom - e.top) / s.offsetHeight, S = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${c}: ${h / v}px; max-width: ${d / S}px`,
    class: "cm-completionInfo-" + (u ? a ? "left-narrow" : "right-narrow" : o ? "left" : "right")
  };
}
function qV(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(r) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), r.type && i.classList.add(...r.type.split(/\s+/g).map((n) => "cm-completionIcon-" + n)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), e.push({
    render(r, i, n, s) {
      let a = document.createElement("span");
      a.className = "cm-completionLabel";
      let o = r.displayLabel || r.label, u = 0;
      for (let c = 0; c < s.length; ) {
        let h = s[c++], d = s[c++];
        h > u && a.appendChild(document.createTextNode(o.slice(u, h)));
        let m = a.appendChild(document.createElement("span"));
        m.appendChild(document.createTextNode(o.slice(h, d))), m.className = "cm-completionMatchedText", u = d;
      }
      return u < o.length && a.appendChild(document.createTextNode(o.slice(u))), a;
    },
    position: 50
  }, {
    render(r) {
      if (!r.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = r.detail, i;
    },
    position: 80
  }), e.sort((r, i) => r.position - i.position).map((r) => r.render);
}
function Sd(t, e, r) {
  if (t <= r)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let n = Math.floor(e / r);
    return { from: n * r, to: (n + 1) * r };
  }
  let i = Math.floor((t - e) / r);
  return { from: t - (i + 1) * r, to: t - i * r };
}
class XV {
  constructor(e, r, i) {
    this.view = e, this.stateField = r, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (u) => this.placeInfo(u),
      key: this
    }, this.space = null, this.currentClass = "";
    let n = e.state.field(r), { options: s, selected: a } = n.open, o = e.state.facet(Ft);
    this.optionContent = qV(o), this.optionClass = o.optionClass, this.tooltipClass = o.tooltipClass, this.range = Sd(s.length, a, o.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (u) => {
      let { options: c } = e.state.field(r).open;
      for (let h = u.target, d; h && h != this.dom; h = h.parentNode)
        if (h.nodeName == "LI" && (d = /-(\d+)$/.exec(h.id)) && +d[1] < c.length) {
          this.applyCompletion(e, c[+d[1]]), u.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (u) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(Ft).closeOnBlur && u.relatedTarget != e.contentDOM && e.dispatch({ effects: wl.of(null) });
    }), this.showOptions(s, n.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, r) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, r, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var r;
    let i = e.state.field(this.stateField), n = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), i != n) {
      let { options: s, selected: a, disabled: o } = i.open;
      (!n.open || n.open.options != s) && (this.range = Sd(s.length, a, e.state.facet(Ft).maxRenderedOptions), this.showOptions(s, i.id)), this.updateSel(), o != ((r = n.open) === null || r === void 0 ? void 0 : r.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!o);
    }
  }
  updateTooltipClass(e) {
    let r = this.tooltipClass(e);
    if (r != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of r.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = r;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), r = e.open;
    if ((r.selected > -1 && r.selected < this.range.from || r.selected >= this.range.to) && (this.range = Sd(r.options.length, r.selected, this.view.state.facet(Ft).maxRenderedOptions), this.showOptions(r.options, e.id)), this.updateSelectedOption(r.selected)) {
      this.destroyInfo();
      let { completion: i } = r.options[r.selected], { info: n } = i;
      if (!n)
        return;
      let s = typeof n == "string" ? document.createTextNode(n) : n(i);
      if (!s)
        return;
      "then" in s ? s.then((a) => {
        a && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(a, i);
      }).catch((a) => Mr(this.view.state, a, "completion info")) : this.addInfoPane(s, i);
    }
  }
  addInfoPane(e, r) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      i.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: n, destroy: s } = e;
      i.appendChild(n), this.infoDestroy = s || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let r = null;
    for (let i = this.list.firstChild, n = this.range.from; i; i = i.nextSibling, n++)
      i.nodeName != "LI" || !i.id ? n-- : n == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), r = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return r && YV(this.list, r), r;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let r = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), n = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let a = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: a.innerWidth, bottom: a.innerHeight };
    }
    return n.top > Math.min(s.bottom, r.bottom) - 10 || n.bottom < Math.max(s.top, r.top) + 10 ? null : this.view.state.facet(Ft).positionInfo(this.view, r, n, i, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, r, i) {
    const n = document.createElement("ul");
    n.id = r, n.setAttribute("role", "listbox"), n.setAttribute("aria-expanded", "true"), n.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let s = null;
    for (let a = i.from; a < i.to; a++) {
      let { completion: o, match: u } = e[a], { section: c } = o;
      if (c) {
        let m = typeof c == "string" ? c : c.name;
        if (m != s && (a > i.from || i.from == 0))
          if (s = m, typeof c != "string" && c.header)
            n.appendChild(c.header(c));
          else {
            let y = n.appendChild(document.createElement("completion-section"));
            y.textContent = m;
          }
      }
      const h = n.appendChild(document.createElement("li"));
      h.id = r + "-" + a, h.setAttribute("role", "option");
      let d = this.optionClass(o);
      d && (h.className = d);
      for (let m of this.optionContent) {
        let y = m(o, this.view.state, this.view, u);
        y && h.appendChild(y);
      }
    }
    return i.from && n.classList.add("cm-completionListIncompleteTop"), i.to < e.length && n.classList.add("cm-completionListIncompleteBottom"), n;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function VV(t, e) {
  return (r) => new XV(r, t, e);
}
function YV(t, e) {
  let r = t.getBoundingClientRect(), i = e.getBoundingClientRect(), n = r.height / t.offsetHeight;
  i.top < r.top ? t.scrollTop -= (r.top - i.top) / n : i.bottom > r.bottom && (t.scrollTop += (i.bottom - r.bottom) / n);
}
function Px(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function UV(t, e) {
  let r = [], i = null, n = (u) => {
    r.push(u);
    let { section: c } = u.completion;
    if (c) {
      i || (i = []);
      let h = typeof c == "string" ? c : c.name;
      i.some((d) => d.name == h) || i.push(typeof c == "string" ? { name: h } : c);
    }
  };
  for (let u of t)
    if (u.hasResult()) {
      let c = u.result.getMatch;
      if (u.result.filter === !1)
        for (let h of u.result.options)
          n(new Ex(h, u.source, c ? c(h) : [], 1e9 - r.length));
      else {
        let h = new ZV(e.sliceDoc(u.from, u.to));
        for (let d of u.result.options)
          if (h.match(d.label)) {
            let m = d.displayLabel ? c ? c(d, h.matched) : [] : h.matched;
            n(new Ex(d, u.source, m, h.score + (d.boost || 0)));
          }
      }
    }
  if (i) {
    let u = /* @__PURE__ */ Object.create(null), c = 0, h = (d, m) => {
      var y, O;
      return ((y = d.rank) !== null && y !== void 0 ? y : 1e9) - ((O = m.rank) !== null && O !== void 0 ? O : 1e9) || (d.name < m.name ? -1 : 1);
    };
    for (let d of i.sort(h))
      c -= 1e5, u[d.name] = c;
    for (let d of r) {
      let { section: m } = d.completion;
      m && (d.score += u[typeof m == "string" ? m : m.name]);
    }
  }
  let s = [], a = null, o = e.facet(Ft).compareCompletions;
  for (let u of r.sort((c, h) => h.score - c.score || o(c.completion, h.completion))) {
    let c = u.completion;
    !a || a.label != c.label || a.detail != c.detail || a.type != null && c.type != null && a.type != c.type || a.apply != c.apply || a.boost != c.boost ? s.push(u) : Px(u.completion) > Px(a) && (s[s.length - 1] = u), a = u.completion;
  }
  return s;
}
class Oa {
  constructor(e, r, i, n, s, a) {
    this.options = e, this.attrs = r, this.tooltip = i, this.timestamp = n, this.selected = s, this.disabled = a;
  }
  setSelected(e, r) {
    return e == this.selected || e >= this.options.length ? this : new Oa(this.options, Fx(r, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, r, i, n, s) {
    let a = UV(e, r);
    if (!a.length)
      return n && e.some(
        (u) => u.state == 1
        /* State.Pending */
      ) ? new Oa(n.options, n.attrs, n.tooltip, n.timestamp, n.selected, !0) : null;
    let o = r.facet(Ft).selectOnOpen ? 0 : -1;
    if (n && n.selected != o && n.selected != -1) {
      let u = n.options[n.selected].completion;
      for (let c = 0; c < a.length; c++)
        if (a[c].completion == u) {
          o = c;
          break;
        }
    }
    return new Oa(a, Fx(i, o), {
      pos: e.reduce((u, c) => c.hasResult() ? Math.min(u, c.from) : u, 1e8),
      create: KV,
      above: s.aboveCursor
    }, n ? n.timestamp : Date.now(), o, !1);
  }
  map(e) {
    return new Oa(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class nh {
  constructor(e, r, i) {
    this.active = e, this.id = r, this.open = i;
  }
  static start() {
    return new nh(HV, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: r } = e, i = r.facet(Ft), s = (i.override || r.languageDataAt("autocomplete", Mn(r)).map(jV)).map((o) => (this.active.find((c) => c.source == o) || new sr(
      o,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, i));
    s.length == this.active.length && s.every((o, u) => o == this.active[u]) && (s = this.active);
    let a = this.open;
    a && e.docChanged && (a = a.map(e.changes)), e.selection || s.some((o) => o.hasResult() && e.changes.touchesRange(o.from, o.to)) || !zV(s, this.active) ? a = Oa.build(s, r, this.id, a, i) : a && a.disabled && !s.some(
      (o) => o.state == 1
      /* State.Pending */
    ) && (a = null), !a && s.every(
      (o) => o.state != 1
      /* State.Pending */
    ) && s.some((o) => o.hasResult()) && (s = s.map((o) => o.hasResult() ? new sr(
      o.source,
      0
      /* State.Inactive */
    ) : o));
    for (let o of e.effects)
      o.is(DE) && (a = a && a.setSelected(o.value, this.id));
    return s == this.active && a == this.open ? this : new nh(s, this.id, a);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : GV;
  }
}
function zV(t, e) {
  if (t == e)
    return !0;
  for (let r = 0, i = 0; ; ) {
    for (; r < t.length && !t[r].hasResult; )
      r++;
    for (; i < e.length && !e[i].hasResult; )
      i++;
    let n = r == t.length, s = i == e.length;
    if (n || s)
      return n == s;
    if (t[r++].result != e[i++].result)
      return !1;
  }
}
const GV = {
  "aria-autocomplete": "list"
};
function Fx(t, e) {
  let r = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (r["aria-activedescendant"] = t + "-" + e), r;
}
const HV = [];
function ym(t) {
  return t.isUserEvent("input.type") ? "input" : t.isUserEvent("delete.backward") ? "delete" : null;
}
class sr {
  constructor(e, r, i = -1) {
    this.source = e, this.state = r, this.explicitPos = i;
  }
  hasResult() {
    return !1;
  }
  update(e, r) {
    let i = ym(e), n = this;
    i ? n = n.handleUserEvent(e, i, r) : e.docChanged ? n = n.handleChange(e) : e.selection && n.state != 0 && (n = new sr(
      n.source,
      0
      /* State.Inactive */
    ));
    for (let s of e.effects)
      if (s.is(ih))
        n = new sr(n.source, 1, s.value ? Mn(e.state) : -1);
      else if (s.is(wl))
        n = new sr(
          n.source,
          0
          /* State.Inactive */
        );
      else if (s.is(bE))
        for (let a of s.value)
          a.source == n.source && (n = a);
    return n;
  }
  handleUserEvent(e, r, i) {
    return r == "delete" || !i.activateOnTyping ? this.map(e.changes) : new sr(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(Mn(e.startState)) ? new sr(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new sr(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class Aa extends sr {
  constructor(e, r, i, n, s) {
    super(e, 2, r), this.result = i, this.from = n, this.to = s;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, r, i) {
    var n;
    let s = e.changes.mapPos(this.from), a = e.changes.mapPos(this.to, 1), o = Mn(e.state);
    if ((this.explicitPos < 0 ? o <= s : o < this.from) || o > a || r == "delete" && Mn(e.startState) == this.from)
      return new sr(
        this.source,
        r == "input" && i.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let u = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), c;
    return JV(this.result.validFor, e.state, s, a) ? new Aa(this.source, u, this.result, s, a) : this.result.update && (c = this.result.update(this.result, s, a, new gE(e.state, o, u >= 0))) ? new Aa(this.source, u, c, c.from, (n = c.to) !== null && n !== void 0 ? n : Mn(e.state)) : new sr(this.source, 1, u);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new sr(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new Aa(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function JV(t, e, r, i) {
  if (!t)
    return !1;
  let n = e.sliceDoc(r, i);
  return typeof t == "function" ? t(n, r, i, e) : OE(t, !0).test(n);
}
const bE = /* @__PURE__ */ we.define({
  map(t, e) {
    return t.map((r) => r.map(e));
  }
}), DE = /* @__PURE__ */ we.define(), yr = /* @__PURE__ */ St.define({
  create() {
    return nh.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    fy.from(t, (e) => e.tooltip),
    oe.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function vE(t, e) {
  const r = e.completion.apply || e.completion.label;
  let i = t.state.field(yr).active.find((n) => n.source == e.source);
  return i instanceof Aa ? (typeof r == "string" ? t.dispatch(Object.assign(Object.assign({}, RV(t.state, r, i.from, i.to)), { annotations: xE.of(e.completion) })) : r(t, e.completion, i.from, i.to), !0) : !1;
}
const KV = /* @__PURE__ */ VV(yr, vE);
function Ju(t, e = "option") {
  return (r) => {
    let i = r.state.field(yr, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < r.state.facet(Ft).interactionDelay)
      return !1;
    let n = 1, s;
    e == "page" && (s = KC(r, i.open.tooltip)) && (n = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: a } = i.open.options, o = i.open.selected > -1 ? i.open.selected + n * (t ? 1 : -1) : t ? 0 : a - 1;
    return o < 0 ? o = e == "page" ? 0 : a - 1 : o >= a && (o = e == "page" ? a - 1 : 0), r.dispatch({ effects: DE.of(o) }), !0;
  };
}
const eY = (t) => {
  let e = t.state.field(yr, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(Ft).interactionDelay ? !1 : vE(t, e.open.options[e.open.selected]);
}, tY = (t) => t.state.field(yr, !1) ? (t.dispatch({ effects: ih.of(!0) }), !0) : !1, rY = (t) => {
  let e = t.state.field(yr, !1);
  return !e || !e.active.some(
    (r) => r.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: wl.of(null) }), !0);
};
class iY {
  constructor(e, r) {
    this.active = e, this.context = r, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const nY = 50, sY = 1e3, aY = /* @__PURE__ */ ft.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(yr).active)
      e.state == 1 && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(yr);
    if (!t.selectionSet && !t.docChanged && t.startState.field(yr) == e)
      return;
    let r = t.transactions.some((n) => (n.selection || n.docChanged) && !ym(n));
    for (let n = 0; n < this.running.length; n++) {
      let s = this.running[n];
      if (r || s.updates.length + t.transactions.length > nY && Date.now() - s.time > sY) {
        for (let a of s.context.abortListeners)
          try {
            a();
          } catch (o) {
            Mr(this.view.state, o);
          }
        s.context.abortListeners = null, this.running.splice(n--, 1);
      } else
        s.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((n) => n.effects.some((s) => s.is(ih))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : t.state.facet(Ft).activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((n) => n.state == 1 && !this.running.some((s) => s.active.source == n.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let n of t.transactions)
        ym(n) == "input" ? this.composing = 2 : this.composing == 2 && n.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(yr);
    for (let r of e.active)
      r.state == 1 && !this.running.some((i) => i.active.source == r.source) && this.startQuery(r);
  }
  startQuery(t) {
    let { state: e } = this.view, r = Mn(e), i = new gE(e, r, t.explicitPos == r), n = new iY(t, i);
    this.running.push(n), Promise.resolve(t.source(i)).then((s) => {
      n.context.aborted || (n.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: wl.of(null) }), Mr(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ft).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], r = this.view.state.facet(Ft);
    for (let i = 0; i < this.running.length; i++) {
      let n = this.running[i];
      if (n.done === void 0)
        continue;
      if (this.running.splice(i--, 1), n.done) {
        let a = new Aa(n.active.source, n.active.explicitPos, n.done, n.done.from, (t = n.done.to) !== null && t !== void 0 ? t : Mn(n.updates.length ? n.updates[0].startState : this.view.state));
        for (let o of n.updates)
          a = a.update(o, r);
        if (a.hasResult()) {
          e.push(a);
          continue;
        }
      }
      let s = this.view.state.field(yr).active.find((a) => a.source == n.active.source);
      if (s && s.state == 1)
        if (n.done == null) {
          let a = new sr(
            n.active.source,
            0
            /* State.Inactive */
          );
          for (let o of n.updates)
            a = a.update(o, r);
          a.state != 1 && e.push(a);
        } else
          this.startQuery(s);
    }
    e.length && this.view.dispatch({ effects: bE.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(yr, !1);
      if (e && e.tooltip && this.view.state.facet(Ft).closeOnBlur) {
        let r = e.open && KC(this.view, e.open.tooltip);
        (!r || !r.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: wl.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: ih.of(!1) }), 20), this.composing = 0;
    }
  }
}), SE = /* @__PURE__ */ oe.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class oY {
  constructor(e, r, i, n) {
    this.field = e, this.line = r, this.from = i, this.to = n;
  }
}
class Fy {
  constructor(e, r, i) {
    this.field = e, this.from = r, this.to = i;
  }
  map(e) {
    let r = e.mapPos(this.from, -1, Pt.TrackDel), i = e.mapPos(this.to, 1, Pt.TrackDel);
    return r == null || i == null ? null : new Fy(this.field, r, i);
  }
}
class $y {
  constructor(e, r) {
    this.lines = e, this.fieldPositions = r;
  }
  instantiate(e, r) {
    let i = [], n = [r], s = e.doc.lineAt(r), a = /^\s*/.exec(s.text)[0];
    for (let u of this.lines) {
      if (i.length) {
        let c = a, h = /^\t*/.exec(u)[0].length;
        for (let d = 0; d < h; d++)
          c += e.facet(Jl);
        n.push(r + c.length - h), u = c + u.slice(h);
      }
      i.push(u), r += u.length + 1;
    }
    let o = this.fieldPositions.map((u) => new Fy(u.field, n[u.line] + u.from, n[u.line] + u.to));
    return { text: i, ranges: o };
  }
  static parse(e) {
    let r = [], i = [], n = [], s;
    for (let a of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(a); ) {
        let o = s[1] ? +s[1] : null, u = s[2] || s[3] || "", c = -1;
        for (let h = 0; h < r.length; h++)
          (o != null ? r[h].seq == o : u && r[h].name == u) && (c = h);
        if (c < 0) {
          let h = 0;
          for (; h < r.length && (o == null || r[h].seq != null && r[h].seq < o); )
            h++;
          r.splice(h, 0, { seq: o, name: u }), c = h;
          for (let d of n)
            d.field >= c && d.field++;
        }
        n.push(new oY(c, i.length, s.index, s.index + u.length)), a = a.slice(0, s.index) + u + a.slice(s.index + s[0].length);
      }
      for (let o; o = /\\([{}])/.exec(a); ) {
        a = a.slice(0, o.index) + o[1] + a.slice(o.index + o[0].length);
        for (let u of n)
          u.line == i.length && u.from > o.index && (u.from--, u.to--);
      }
      i.push(a);
    }
    return new $y(i, n);
  }
}
let lY = /* @__PURE__ */ xe.widget({ widget: /* @__PURE__ */ new class extends Zi {
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-snippetFieldPosition", t;
  }
  ignoreEvent() {
    return !1;
  }
}() }), uY = /* @__PURE__ */ xe.mark({ class: "cm-snippetField" });
class so {
  constructor(e, r) {
    this.ranges = e, this.active = r, this.deco = xe.set(e.map((i) => (i.from == i.to ? lY : uY).range(i.from, i.to)));
  }
  map(e) {
    let r = [];
    for (let i of this.ranges) {
      let n = i.map(e);
      if (!n)
        return null;
      r.push(n);
    }
    return new so(r, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((r) => this.ranges.some((i) => i.field == this.active && i.from <= r.from && i.to >= r.to));
  }
}
const su = /* @__PURE__ */ we.define({
  map(t, e) {
    return t && t.map(e);
  }
}), cY = /* @__PURE__ */ we.define(), Cl = /* @__PURE__ */ St.define({
  create() {
    return null;
  },
  update(t, e) {
    for (let r of e.effects) {
      if (r.is(su))
        return r.value;
      if (r.is(cY) && t)
        return new so(t.ranges, r.value);
    }
    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
  },
  provide: (t) => oe.decorations.from(t, (e) => e ? e.deco : xe.none)
});
function By(t, e) {
  return U.create(t.filter((r) => r.field == e).map((r) => U.range(r.from, r.to)));
}
function hY(t) {
  let e = $y.parse(t);
  return (r, i, n, s) => {
    let { text: a, ranges: o } = e.instantiate(r.state, n), u = {
      changes: { from: n, to: s, insert: je.of(a) },
      scrollIntoView: !0,
      annotations: i ? [xE.of(i), yt.userEvent.of("input.complete")] : void 0
    };
    if (o.length && (u.selection = By(o, 0)), o.some((c) => c.field > 0)) {
      let c = new so(o, 0), h = u.effects = [su.of(c)];
      r.state.field(Cl, !1) === void 0 && h.push(we.appendConfig.of([Cl, gY, yY, SE]));
    }
    r.dispatch(r.state.update(u));
  };
}
function wE(t) {
  return ({ state: e, dispatch: r }) => {
    let i = e.field(Cl, !1);
    if (!i || t < 0 && i.active == 0)
      return !1;
    let n = i.active + t, s = t > 0 && !i.ranges.some((a) => a.field == n + t);
    return r(e.update({
      selection: By(i.ranges, n),
      effects: su.of(s ? null : new so(i.ranges, n)),
      scrollIntoView: !0
    })), !0;
  };
}
const pY = ({ state: t, dispatch: e }) => t.field(Cl, !1) ? (e(t.update({ effects: su.of(null) })), !0) : !1, dY = /* @__PURE__ */ wE(1), fY = /* @__PURE__ */ wE(-1), mY = [
  { key: "Tab", run: dY, shift: fY },
  { key: "Escape", run: pY }
], $x = /* @__PURE__ */ fe.define({
  combine(t) {
    return t.length ? t[0] : mY;
  }
}), gY = /* @__PURE__ */ Ys.highest(/* @__PURE__ */ zl.compute([$x], (t) => t.facet($x)));
function rr(t, e) {
  return Object.assign(Object.assign({}, e), { apply: hY(t) });
}
const yY = /* @__PURE__ */ oe.domEventHandlers({
  mousedown(t, e) {
    let r = e.state.field(Cl, !1), i;
    if (!r || (i = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)
      return !1;
    let n = r.ranges.find((s) => s.from <= i && s.to >= i);
    return !n || n.field == r.active ? !1 : (e.dispatch({
      selection: By(r.ranges, n.field),
      effects: su.of(r.ranges.some((s) => s.field > n.field) ? new so(r.ranges, n.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), Al = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, gs = /* @__PURE__ */ we.define({
  map(t, e) {
    let r = e.mapPos(t, -1, Pt.TrackAfter);
    return r ?? void 0;
  }
}), Iy = /* @__PURE__ */ new class extends ks {
}();
Iy.startSide = 1;
Iy.endSide = -1;
const CE = /* @__PURE__ */ St.define({
  create() {
    return Me.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let r = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (i) => i >= r.from && i <= r.to });
    }
    for (let r of e.effects)
      r.is(gs) && (t = t.update({ add: [Iy.range(r.value, r.value + 1)] }));
    return t;
  }
});
function OY() {
  return [bY, CE];
}
const wd = "()[]{}<>";
function AE(t) {
  for (let e = 0; e < wd.length; e += 2)
    if (wd.charCodeAt(e) == t)
      return wd.charAt(e + 1);
  return iy(t < 128 ? t : t + 1);
}
function EE(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || Al;
}
const xY = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), bY = /* @__PURE__ */ oe.inputHandler.of((t, e, r, i) => {
  if ((xY ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let n = t.state.selection.main;
  if (i.length > 2 || i.length == 2 && Nr(Et(i, 0)) == 1 || e != n.from || r != n.to)
    return !1;
  let s = SY(t.state, i);
  return s ? (t.dispatch(s), !0) : !1;
}), DY = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let i = EE(t, t.selection.main.head).brackets || Al.brackets, n = null, s = t.changeByRange((a) => {
    if (a.empty) {
      let o = wY(t.doc, a.head);
      for (let u of i)
        if (u == o && fp(t.doc, a.head) == AE(Et(u, 0)))
          return {
            changes: { from: a.head - u.length, to: a.head + u.length },
            range: U.cursor(a.head - u.length)
          };
    }
    return { range: n = a };
  });
  return n || e(t.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !n;
}, vY = [
  { key: "Backspace", run: DY }
];
function SY(t, e) {
  let r = EE(t, t.selection.main.head), i = r.brackets || Al.brackets;
  for (let n of i) {
    let s = AE(Et(n, 0));
    if (e == n)
      return s == n ? EY(t, n, i.indexOf(n + n + n) > -1, r) : CY(t, n, s, r.before || Al.before);
    if (e == s && kE(t, t.selection.main.from))
      return AY(t, n, s);
  }
  return null;
}
function kE(t, e) {
  let r = !1;
  return t.field(CE).between(0, t.doc.length, (i) => {
    i == e && (r = !0);
  }), r;
}
function fp(t, e) {
  let r = t.sliceString(e, e + 2);
  return r.slice(0, Nr(Et(r, 0)));
}
function wY(t, e) {
  let r = t.sliceString(e - 2, e);
  return Nr(Et(r, 0)) == r.length ? r : r.slice(1);
}
function CY(t, e, r, i) {
  let n = null, s = t.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: r, from: a.to }],
        effects: gs.of(a.to + e.length),
        range: U.range(a.anchor + e.length, a.head + e.length)
      };
    let o = fp(t.doc, a.head);
    return !o || /\s/.test(o) || i.indexOf(o) > -1 ? {
      changes: { insert: e + r, from: a.head },
      effects: gs.of(a.head + e.length),
      range: U.cursor(a.head + e.length)
    } : { range: n = a };
  });
  return n ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function AY(t, e, r) {
  let i = null, n = t.changeByRange((s) => s.empty && fp(t.doc, s.head) == r ? {
    changes: { from: s.head, to: s.head + r.length, insert: r },
    range: U.cursor(s.head + r.length)
  } : i = { range: s });
  return i ? null : t.update(n, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function EY(t, e, r, i) {
  let n = i.stringPrefixes || Al.stringPrefixes, s = null, a = t.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: e, from: o.to }],
        effects: gs.of(o.to + e.length),
        range: U.range(o.anchor + e.length, o.head + e.length)
      };
    let u = o.head, c = fp(t.doc, u), h;
    if (c == e) {
      if (Bx(t, u))
        return {
          changes: { insert: e + e, from: u },
          effects: gs.of(u + e.length),
          range: U.cursor(u + e.length)
        };
      if (kE(t, u)) {
        let m = r && t.sliceDoc(u, u + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: u, to: u + m.length, insert: m },
          range: U.cursor(u + m.length)
        };
      }
    } else {
      if (r && t.sliceDoc(u - 2 * e.length, u) == e + e && (h = Ix(t, u - 2 * e.length, n)) > -1 && Bx(t, h))
        return {
          changes: { insert: e + e + e + e, from: u },
          effects: gs.of(u + e.length),
          range: U.cursor(u + e.length)
        };
      if (t.charCategorizer(u)(c) != st.Word && Ix(t, u, n) > -1 && !kY(t, u, e, n))
        return {
          changes: { insert: e + e, from: u },
          effects: gs.of(u + e.length),
          range: U.cursor(u + e.length)
        };
    }
    return { range: s = o };
  });
  return s ? null : t.update(a, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Bx(t, e) {
  let r = ht(t).resolveInner(e + 1);
  return r.parent && r.from == e;
}
function kY(t, e, r, i) {
  let n = ht(t).resolveInner(e, -1), s = i.reduce((a, o) => Math.max(a, o.length), 0);
  for (let a = 0; a < 5; a++) {
    let o = t.sliceDoc(n.from, Math.min(n.to, n.from + r.length + s)), u = o.indexOf(r);
    if (!u || u > -1 && i.indexOf(o.slice(0, u)) > -1) {
      let h = n.firstChild;
      for (; h && h.from == n.from && h.to - h.from > r.length + u; ) {
        if (t.sliceDoc(h.to - r.length, h.to) == r)
          return !1;
        h = h.firstChild;
      }
      return !0;
    }
    let c = n.to == e && n.parent;
    if (!c)
      break;
    n = c;
  }
  return !1;
}
function Ix(t, e, r) {
  let i = t.charCategorizer(e);
  if (i(t.sliceDoc(e - 1, e)) != st.Word)
    return e;
  for (let n of r) {
    let s = e - n.length;
    if (t.sliceDoc(s, e) == n && i(t.sliceDoc(s - 1, s)) != st.Word)
      return s;
  }
  return -1;
}
function TY(t = {}) {
  return [
    yr,
    Ft.of(t),
    aY,
    PY,
    SE
  ];
}
const TE = [
  { key: "Ctrl-Space", run: tY },
  { key: "Escape", run: rY },
  { key: "ArrowDown", run: /* @__PURE__ */ Ju(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Ju(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Ju(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Ju(!1, "page") },
  { key: "Enter", run: eY }
], PY = /* @__PURE__ */ Ys.highest(/* @__PURE__ */ zl.computeN([Ft], (t) => t.facet(Ft).defaultKeymap ? [TE] : []));
class FY {
  constructor(e, r, i) {
    this.from = e, this.to = r, this.diagnostic = i;
  }
}
class hs {
  constructor(e, r, i) {
    this.diagnostics = e, this.panel = r, this.selected = i;
  }
  static init(e, r, i) {
    let n = e, s = i.facet($E).markerFilter;
    s && (n = s(n, i));
    let a = xe.set(n.map((o) => o.from == o.to || o.from == o.to - 1 && i.doc.lineAt(o.from).to == o.from ? xe.widget({
      widget: new RY(o),
      diagnostic: o
    }).range(o.from) : xe.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + o.severity + (o.markClass ? " " + o.markClass : "") },
      diagnostic: o,
      inclusive: !0
    }).range(o.from, o.to)), !0);
    return new hs(a, r, Ra(a));
  }
}
function Ra(t, e = null, r = 0) {
  let i = null;
  return t.between(r, 1e9, (n, s, { spec: a }) => {
    if (!(e && a.diagnostic != e))
      return i = new FY(n, s, a.diagnostic), !1;
  }), i;
}
function $Y(t, e) {
  let r = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((i) => i.is(PE)) || t.changes.touchesRange(r.from, r.to));
}
function BY(t, e) {
  return t.field(vr, !1) ? e : e.concat(we.appendConfig.of(WY));
}
const PE = /* @__PURE__ */ we.define(), Ny = /* @__PURE__ */ we.define(), FE = /* @__PURE__ */ we.define(), vr = /* @__PURE__ */ St.define({
  create() {
    return new hs(xe.none, null, null);
  },
  update(t, e) {
    if (e.docChanged) {
      let r = t.diagnostics.map(e.changes), i = null;
      if (t.selected) {
        let n = e.changes.mapPos(t.selected.from, 1);
        i = Ra(r, t.selected.diagnostic, n) || Ra(r, null, n);
      }
      t = new hs(r, t.panel, i);
    }
    for (let r of e.effects)
      r.is(PE) ? t = hs.init(r.value, t.panel, e.state) : r.is(Ny) ? t = new hs(t.diagnostics, r.value ? mp.open : null, t.selected) : r.is(FE) && (t = new hs(t.diagnostics, t.panel, r.value));
    return t;
  },
  provide: (t) => [
    xl.from(t, (e) => e.panel),
    oe.decorations.from(t, (e) => e.diagnostics)
  ]
}), IY = /* @__PURE__ */ xe.mark({ class: "cm-lintRange cm-lintRange-active", inclusive: !0 });
function NY(t, e, r) {
  let { diagnostics: i } = t.state.field(vr), n = [], s = 2e8, a = 0;
  i.between(e - (r < 0 ? 1 : 0), e + (r > 0 ? 1 : 0), (u, c, { spec: h }) => {
    e >= u && e <= c && (u == c || (e > u || r > 0) && (e < c || r < 0)) && (n.push(h.diagnostic), s = Math.min(u, s), a = Math.max(c, a));
  });
  let o = t.state.facet($E).tooltipFilter;
  return o && (n = o(n, t.state)), n.length ? {
    pos: s,
    end: a,
    above: t.state.doc.lineAt(s).to < a,
    create() {
      return { dom: _Y(t, n) };
    }
  } : null;
}
function _Y(t, e) {
  return Je("ul", { class: "cm-tooltip-lint" }, e.map((r) => IE(t, r, !1)));
}
const QY = (t) => {
  let e = t.state.field(vr, !1);
  (!e || !e.panel) && t.dispatch({ effects: BY(t.state, [Ny.of(!0)]) });
  let r = Ol(t, mp.open);
  return r && r.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, Nx = (t) => {
  let e = t.state.field(vr, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: Ny.of(!1) }), !0);
}, MY = (t) => {
  let e = t.state.field(vr, !1);
  if (!e)
    return !1;
  let r = t.state.selection.main, i = e.diagnostics.iter(r.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == r.from && i.to == r.to) ? !1 : (t.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, LY = [
  { key: "Mod-Shift-m", run: QY, preventDefault: !0 },
  { key: "F8", run: MY }
], $E = /* @__PURE__ */ fe.define({
  combine(t) {
    return Object.assign({ sources: t.map((e) => e.source).filter((e) => e != null) }, ji(t.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (e, r) => e ? r ? (i) => e(i) || r(i) : e : r
    }));
  }
});
function BE(t) {
  let e = [];
  if (t)
    e:
      for (let { name: r } of t) {
        for (let i = 0; i < r.length; i++) {
          let n = r[i];
          if (/[a-zA-Z]/.test(n) && !e.some((s) => s.toLowerCase() == n.toLowerCase())) {
            e.push(n);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function IE(t, e, r) {
  var i;
  let n = r ? BE(e.actions) : [];
  return Je("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Je("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((s, a) => {
    let o = !1, u = (m) => {
      if (m.preventDefault(), o)
        return;
      o = !0;
      let y = Ra(t.state.field(vr).diagnostics, e);
      y && s.apply(t, y.from, y.to);
    }, { name: c } = s, h = n[a] ? c.indexOf(n[a]) : -1, d = h < 0 ? c : [
      c.slice(0, h),
      Je("u", c.slice(h, h + 1)),
      c.slice(h + 1)
    ];
    return Je("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: u,
      onmousedown: u,
      "aria-label": ` Action: ${c}${h < 0 ? "" : ` (access key "${n[a]})"`}.`
    }, d);
  }), e.source && Je("div", { class: "cm-diagnosticSource" }, e.source));
}
class RY extends Zi {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return Je("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class _x {
  constructor(e, r) {
    this.diagnostic = r, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = IE(e, r, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class mp {
  constructor(e) {
    this.view = e, this.items = [];
    let r = (n) => {
      if (n.keyCode == 27)
        Nx(this.view), this.view.focus();
      else if (n.keyCode == 38 || n.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (n.keyCode == 40 || n.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (n.keyCode == 36)
        this.moveSelection(0);
      else if (n.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (n.keyCode == 13)
        this.view.focus();
      else if (n.keyCode >= 65 && n.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], a = BE(s.actions);
        for (let o = 0; o < a.length; o++)
          if (a[o].toUpperCase().charCodeAt(0) == n.keyCode) {
            let u = Ra(this.view.state.field(vr).diagnostics, s);
            u && s.actions[o].apply(e, u.from, u.to);
          }
      } else
        return;
      n.preventDefault();
    }, i = (n) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(n.target) && this.moveSelection(s);
    };
    this.list = Je("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: r,
      onclick: i
    }), this.dom = Je("div", { class: "cm-panel-lint" }, this.list, Je("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => Nx(this.view)
    }, "")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(vr).selected;
    if (!e)
      return -1;
    for (let r = 0; r < this.items.length; r++)
      if (this.items[r].diagnostic == e.diagnostic)
        return r;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: r } = this.view.state.field(vr), i = 0, n = !1, s = null;
    for (e.between(0, this.view.state.doc.length, (a, o, { spec: u }) => {
      let c = -1, h;
      for (let d = i; d < this.items.length; d++)
        if (this.items[d].diagnostic == u.diagnostic) {
          c = d;
          break;
        }
      c < 0 ? (h = new _x(this.view, u.diagnostic), this.items.splice(i, 0, h), n = !0) : (h = this.items[c], c > i && (this.items.splice(i, c - i), n = !0)), r && h.diagnostic == r.diagnostic ? h.dom.hasAttribute("aria-selected") || (h.dom.setAttribute("aria-selected", "true"), s = h) : h.dom.hasAttribute("aria-selected") && h.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      n = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new _x(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), n = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: a, panel: o }) => {
        let u = o.height / this.list.offsetHeight;
        a.top < o.top ? this.list.scrollTop -= (o.top - a.top) / u : a.bottom > o.bottom && (this.list.scrollTop += (a.bottom - o.bottom) / u);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), n && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function r() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          r();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      r();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let r = this.view.state.field(vr), i = Ra(r.diagnostics, this.items[e].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: FE.of(i)
    });
  }
  static open(e) {
    return new mp(e);
  }
}
function jY(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function Ku(t) {
  return jY(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const ZY = /* @__PURE__ */ oe.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Ku("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Ku("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Ku("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Ku("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), WY = [
  vr,
  /* @__PURE__ */ oe.decorations.compute([vr], (t) => {
    let { selected: e, panel: r } = t.field(vr);
    return !e || !r || e.from == e.to ? xe.none : xe.set([
      IY.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ FW(NY, { hideOn: $Y }),
  ZY
];
var Qx = function(e) {
  e === void 0 && (e = {});
  var {
    crosshairCursor: r = !1
  } = e, i = [];
  e.closeBracketsKeymap !== !1 && (i = i.concat(vY)), e.defaultKeymap !== !1 && (i = i.concat(uV)), e.searchKeymap !== !1 && (i = i.concat(IV)), e.historyKeymap !== !1 && (i = i.concat(OX)), e.foldKeymap !== !1 && (i = i.concat(Bq)), e.completionKeymap !== !1 && (i = i.concat(TE)), e.lintKeymap !== !1 && (i = i.concat(LY));
  var n = [];
  return e.lineNumbers !== !1 && n.push(RW()), e.highlightActiveLineGutter !== !1 && n.push(WW()), e.highlightSpecialChars !== !1 && n.push(aW()), e.history !== !1 && n.push(uX()), e.foldGutter !== !1 && n.push(Qq()), e.drawSelection !== !1 && n.push(zZ()), e.dropCursor !== !1 && n.push(eW()), e.allowMultipleSelections !== !1 && n.push(Ie.allowMultipleSelections.of(!0)), e.indentOnInput !== !1 && n.push(wq()), e.syntaxHighlighting !== !1 && n.push(vA(jq, {
    fallback: !0
  })), e.bracketMatching !== !1 && n.push(Uq()), e.closeBrackets !== !1 && n.push(OY()), e.autocompletion !== !1 && n.push(TY()), e.rectangularSelection !== !1 && n.push(bW()), r !== !1 && n.push(SW()), e.highlightActiveLine !== !1 && n.push(pW()), e.highlightSelectionMatches !== !1 && n.push(mV()), e.tabSize && typeof e.tabSize == "number" && n.push(Jl.of(" ".repeat(e.tabSize))), n.concat([zl.of(i.flat())]).filter(Boolean);
};
const qY = "#e5c07b", Mx = "#e06c75", XY = "#56b6c2", VY = "#ffffff", xc = "#abb2bf", Om = "#7d8799", YY = "#61afef", UY = "#98c379", Lx = "#d19a66", zY = "#c678dd", GY = "#21252b", Rx = "#2c313a", jx = "#282c34", Cd = "#353a42", HY = "#3E4451", Zx = "#528bff", JY = /* @__PURE__ */ oe.theme({
  "&": {
    color: xc,
    backgroundColor: jx
  },
  ".cm-content": {
    caretColor: Zx
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: Zx },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: HY },
  ".cm-panels": { backgroundColor: GY, color: xc },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: jx,
    color: Om,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: Rx
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: Cd
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: Cd,
    borderBottomColor: Cd
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: Rx,
      color: xc
    }
  }
}, { dark: !0 }), KY = /* @__PURE__ */ ru.define([
  {
    tag: _.keyword,
    color: zY
  },
  {
    tag: [_.name, _.deleted, _.character, _.propertyName, _.macroName],
    color: Mx
  },
  {
    tag: [/* @__PURE__ */ _.function(_.variableName), _.labelName],
    color: YY
  },
  {
    tag: [_.color, /* @__PURE__ */ _.constant(_.name), /* @__PURE__ */ _.standard(_.name)],
    color: Lx
  },
  {
    tag: [/* @__PURE__ */ _.definition(_.name), _.separator],
    color: xc
  },
  {
    tag: [_.typeName, _.className, _.number, _.changed, _.annotation, _.modifier, _.self, _.namespace],
    color: qY
  },
  {
    tag: [_.operator, _.operatorKeyword, _.url, _.escape, _.regexp, _.link, /* @__PURE__ */ _.special(_.string)],
    color: XY
  },
  {
    tag: [_.meta, _.comment],
    color: Om
  },
  {
    tag: _.strong,
    fontWeight: "bold"
  },
  {
    tag: _.emphasis,
    fontStyle: "italic"
  },
  {
    tag: _.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: _.link,
    color: Om,
    textDecoration: "underline"
  },
  {
    tag: _.heading,
    fontWeight: "bold",
    color: Mx
  },
  {
    tag: [_.atom, _.bool, /* @__PURE__ */ _.special(_.variableName)],
    color: Lx
  },
  {
    tag: [_.processingInstruction, _.string, _.inserted],
    color: UY
  },
  {
    tag: _.invalid,
    color: VY
  }
]), eU = [JY, /* @__PURE__ */ vA(KY)];
var tU = oe.theme({
  "&": {
    backgroundColor: "#fff"
  }
}, {
  dark: !1
}), rU = function(e) {
  e === void 0 && (e = {});
  var {
    indentWithTab: r = !0,
    editable: i = !0,
    readOnly: n = !1,
    theme: s = "light",
    placeholder: a = "",
    basicSetup: o = !0
  } = e, u = [];
  switch (r && u.unshift(zl.of([cV])), o && (typeof o == "boolean" ? u.unshift(Qx()) : u.unshift(Qx(o))), a && u.unshift(gW(a)), s) {
    case "light":
      u.push(tU);
      break;
    case "dark":
      u.push(eU);
      break;
    case "none":
      break;
    default:
      u.push(s);
      break;
  }
  return i === !1 && u.push(oe.editable.of(!1)), n && u.push(Ie.readOnly.of(!0)), [...u];
}, iU = (t) => ({
  line: t.state.doc.lineAt(t.state.selection.main.from),
  lineCount: t.state.doc.lines,
  lineBreak: t.state.lineBreak,
  length: t.state.doc.length,
  readOnly: t.state.readOnly,
  tabSize: t.state.tabSize,
  selection: t.state.selection,
  selectionAsSingle: t.state.selection.asSingle().main,
  ranges: t.state.selection.ranges,
  selectionCode: t.state.sliceDoc(t.state.selection.main.from, t.state.selection.main.to),
  selections: t.state.selection.ranges.map((e) => t.state.sliceDoc(e.from, e.to)),
  selectedText: t.state.selection.ranges.some((e) => !e.empty)
}), Wx = Ri.define(), nU = [];
function sU(t) {
  var {
    value: e,
    selection: r,
    onChange: i,
    onStatistics: n,
    onCreateEditor: s,
    onUpdate: a,
    extensions: o = nU,
    autoFocus: u,
    theme: c = "light",
    height: h = null,
    minHeight: d = null,
    maxHeight: m = null,
    width: y = null,
    minWidth: O = null,
    maxWidth: b = null,
    placeholder: v = "",
    editable: S = !0,
    readOnly: x = !1,
    indentWithTab: w = !0,
    basicSetup: k = !0,
    root: C,
    initialState: E
  } = t, [P, I] = In(), [B, Q] = In(), [j, G] = In(), J = oe.theme({
    "&": {
      height: h,
      minHeight: d,
      maxHeight: m,
      width: y,
      minWidth: O,
      maxWidth: b
    },
    "& .cm-scroller": {
      height: "100% !important"
    }
  }), L = oe.updateListener.of((K) => {
    if (K.docChanged && typeof i == "function" && // Fix echoing of the remote changes:
    // If transaction is market as remote we don't have to call `onChange` handler again
    !K.transactions.some((ve) => ve.annotation(Wx))) {
      var Oe = K.state.doc, Ae = Oe.toString();
      i(Ae, K);
    }
    n && n(iU(K));
  }), q = rU({
    theme: c,
    editable: S,
    readOnly: x,
    placeholder: v,
    indentWithTab: w,
    basicSetup: k
  }), X = [L, J, ...q];
  return a && typeof a == "function" && X.push(oe.updateListener.of(a)), X = X.concat(o), ti(() => {
    if (P && !j) {
      var K = {
        doc: e,
        selection: r,
        extensions: X
      }, Oe = E ? Ie.fromJSON(E.json, K, E.fields) : Ie.create(K);
      if (G(Oe), !B) {
        var Ae = new oe({
          state: Oe,
          parent: P,
          root: C
        });
        Q(Ae), s && s(Ae, Oe);
      }
    }
    return () => {
      B && (G(void 0), Q(void 0));
    };
  }, [P, j]), ti(() => I(t.container), [t.container]), ti(() => () => {
    B && (B.destroy(), Q(void 0));
  }, [B]), ti(() => {
    u && B && B.focus();
  }, [u, B]), ti(() => {
    B && B.dispatch({
      effects: we.reconfigure.of(X)
    });
  }, [c, o, h, d, m, y, O, b, v, S, x, w, k, i, a]), ti(() => {
    if (e !== void 0) {
      var K = B ? B.state.doc.toString() : "";
      B && e !== K && B.dispatch({
        changes: {
          from: 0,
          to: K.length,
          insert: e || ""
        },
        annotations: [Wx.of(!0)]
      });
    }
  }, [e, B]), {
    state: j,
    setState: G,
    view: B,
    setView: Q,
    container: P,
    setContainer: I
  };
}
var aU = ["className", "value", "selection", "extensions", "onChange", "onStatistics", "onCreateEditor", "onUpdate", "autoFocus", "theme", "height", "minHeight", "maxHeight", "width", "minWidth", "maxWidth", "basicSetup", "placeholder", "indentWithTab", "editable", "readOnly", "root", "initialState"], NE = /* @__PURE__ */ FT((t, e) => {
  var {
    className: r,
    value: i = "",
    selection: n,
    extensions: s = [],
    onChange: a,
    onStatistics: o,
    onCreateEditor: u,
    onUpdate: c,
    autoFocus: h,
    theme: d = "light",
    height: m,
    minHeight: y,
    maxHeight: O,
    width: b,
    minWidth: v,
    maxWidth: S,
    basicSetup: x,
    placeholder: w,
    indentWithTab: k,
    editable: C,
    readOnly: E,
    root: P,
    initialState: I
  } = t, B = zR(t, aU), Q = Sm(null), {
    state: j,
    view: G,
    container: J
  } = sU({
    container: Q.current,
    root: P,
    value: i,
    autoFocus: h,
    theme: d,
    height: m,
    minHeight: y,
    maxHeight: O,
    width: b,
    minWidth: v,
    maxWidth: S,
    basicSetup: x,
    placeholder: w,
    indentWithTab: k,
    editable: C,
    readOnly: E,
    selection: n,
    onChange: a,
    onStatistics: o,
    onCreateEditor: u,
    onUpdate: c,
    extensions: s,
    initialState: I
  });
  if ($T(e, () => ({
    editor: Q.current,
    state: j,
    view: G
  }), [Q, J, j, G]), typeof i != "string")
    throw new Error("value must be typeof string but got " + typeof i);
  var L = typeof d == "string" ? "cm-theme-" + d : "cm-theme";
  return /* @__PURE__ */ z.jsx("div", vf({
    ref: Q,
    className: "" + L + (r ? " " + r : "")
  }, B));
});
NE.displayName = "CodeMirror";
class sh {
  /**
  @internal
  */
  constructor(e, r, i, n, s, a, o, u, c, h = 0, d) {
    this.p = e, this.stack = r, this.state = i, this.reducePos = n, this.pos = s, this.score = a, this.buffer = o, this.bufferBase = u, this.curContext = c, this.lookAhead = h, this.parent = d;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, r) => r % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, r, i = 0) {
    let n = e.parser.context;
    return new sh(e, [], r, i, i, 0, [], 0, n ? new qx(n, n.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, r) {
    this.stack.push(this.state, r, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var r;
    let i = e >> 19, n = e & 65535, { parser: s } = this.p, a = s.dynamicPrecedence(n);
    if (a && (this.score += a), i == 0) {
      this.pushState(s.getGoto(this.state, n, !0), this.reducePos), n < s.minRepeatTerm && this.storeNode(n, this.reducePos, this.reducePos, 4, !0), this.reduceContext(n, this.reducePos);
      return;
    }
    let o = this.stack.length - (i - 1) * 3 - (e & 262144 ? 6 : 0), u = o ? this.stack[o - 2] : this.p.ranges[0].from, c = this.reducePos - u;
    c >= 2e3 && !(!((r = this.p.parser.nodeSet.types[n]) === null || r === void 0) && r.isAnonymous) && (u == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = c) : this.p.lastBigReductionSize < c && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = u, this.p.lastBigReductionSize = c));
    let h = o ? this.stack[o - 1] : 0, d = this.bufferBase + this.buffer.length - h;
    if (n < s.minRepeatTerm || e & 131072) {
      let m = s.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(n, u, m, d + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[o];
    else {
      let m = this.stack[o - 3];
      this.state = s.getGoto(m, n, !0);
    }
    for (; this.stack.length > o; )
      this.stack.pop();
    this.reduceContext(n, u);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, r, i, n = 4, s = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let a = this, o = this.buffer.length;
      if (o == 0 && a.parent && (o = a.bufferBase - a.parent.bufferBase, a = a.parent), o > 0 && a.buffer[o - 4] == 0 && a.buffer[o - 1] > -1) {
        if (r == i)
          return;
        if (a.buffer[o - 2] >= r) {
          a.buffer[o - 2] = i;
          return;
        }
      }
    }
    if (!s || this.pos == i)
      this.buffer.push(e, r, i, n);
    else {
      let a = this.buffer.length;
      if (a > 0 && this.buffer[a - 4] != 0)
        for (; a > 0 && this.buffer[a - 2] > i; )
          this.buffer[a] = this.buffer[a - 4], this.buffer[a + 1] = this.buffer[a - 3], this.buffer[a + 2] = this.buffer[a - 2], this.buffer[a + 3] = this.buffer[a - 1], a -= 4, n > 4 && (n -= 4);
      this.buffer[a] = e, this.buffer[a + 1] = r, this.buffer[a + 2] = i, this.buffer[a + 3] = n;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, r, i, n) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = n, this.shiftContext(r, i), r <= this.p.parser.maxNode && this.buffer.push(r, i, n, 4);
    else {
      let s = e, { parser: a } = this.p;
      (n > this.pos || r <= a.maxNode) && (this.pos = n, a.stateFlag(
        s,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = n)), this.pushState(s, i), this.shiftContext(r, i), r <= a.maxNode && this.buffer.push(r, i, n, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, r, i, n) {
    e & 65536 ? this.reduce(e) : this.shift(e, r, i, n);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, r) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++);
    let n = this.pos;
    this.reducePos = this.pos = n + e.length, this.pushState(r, n), this.buffer.push(
      i,
      n,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, r = e.buffer.length;
    for (; r > 0 && e.buffer[r - 2] > e.reducePos; )
      r -= 4;
    let i = e.buffer.slice(r), n = e.bufferBase + r;
    for (; e && n == e.bufferBase; )
      e = e.parent;
    return new sh(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, n, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, r) {
    let i = e <= this.p.parser.maxNode;
    i && this.storeNode(e, this.pos, r, 4), this.storeNode(0, this.pos, r, i ? 8 : 4), this.pos = this.reducePos = r, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let r = new oU(this); ; ) {
      let i = this.p.parser.stateSlot(
        r.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(r.state, e);
      if (i == 0)
        return !1;
      if (!(i & 65536))
        return !0;
      r.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let r = this.p.parser.nextStates(this.state);
    if (r.length > 8 || this.stack.length >= 120) {
      let n = [];
      for (let s = 0, a; s < r.length; s += 2)
        (a = r[s + 1]) != this.state && this.p.parser.hasAction(a, e) && n.push(r[s], a);
      if (this.stack.length < 120)
        for (let s = 0; n.length < 8 && s < r.length; s += 2) {
          let a = r[s + 1];
          n.some((o, u) => u & 1 && o == a) || n.push(r[s], a);
        }
      r = n;
    }
    let i = [];
    for (let n = 0; n < r.length && i.length < 4; n += 2) {
      let s = r[n + 1];
      if (s == this.state)
        continue;
      let a = this.split();
      a.pushState(s, this.pos), a.storeNode(0, a.pos, a.pos, 4, !0), a.shiftContext(r[n], this.pos), a.reducePos = this.pos, a.score -= 200, i.push(a);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, r = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(r & 65536))
      return !1;
    if (!e.validAction(this.state, r)) {
      let i = r >> 19, n = r & 65535, s = this.stack.length - i * 3;
      if (s < 0 || e.getGoto(this.stack[s], n, !1) < 0) {
        let a = this.findForcedReduction();
        if (a == null)
          return !1;
        r = a;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(r), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, r = [], i = (n, s) => {
      if (!r.includes(n))
        return r.push(n), e.allActions(n, (a) => {
          if (!(a & 393216))
            if (a & 65536) {
              let o = (a >> 19) - s;
              if (o > 1) {
                let u = a & 65535, c = this.stack.length - o * 3;
                if (c >= 0 && e.getGoto(this.stack[c], u, !1) >= 0)
                  return o << 19 | 65536 | u;
              }
            } else {
              let o = i(a, s + 1);
              if (o != null)
                return o;
            }
        });
    };
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let r = 0; r < this.stack.length; r += 3)
      if (this.stack[r] != e.stack[r])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, r) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  reduceContext(e, r) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let r = new qx(this.curContext.tracker, e);
      r.hash != this.curContext.hash && this.emitContext(), this.curContext = r;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class qx {
  constructor(e, r) {
    this.tracker = e, this.context = r, this.hash = e.strict ? e.hash(r) : 0;
  }
}
class oU {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let r = e & 65535, i = e >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let n = this.start.p.parser.getGoto(this.stack[this.base - 3], r, !0);
    this.state = n;
  }
}
class ah {
  constructor(e, r, i) {
    this.stack = e, this.pos = r, this.index = i, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, r = e.bufferBase + e.buffer.length) {
    return new ah(e, r, r - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new ah(this.stack, this.pos, this.index);
  }
}
function Lo(t, e = Uint16Array) {
  if (typeof t != "string")
    return t;
  let r = null;
  for (let i = 0, n = 0; i < t.length; ) {
    let s = 0;
    for (; ; ) {
      let a = t.charCodeAt(i++), o = !1;
      if (a == 126) {
        s = 65535;
        break;
      }
      a >= 92 && a--, a >= 34 && a--;
      let u = a - 32;
      if (u >= 46 && (u -= 46, o = !0), s += u, o)
        break;
      s *= 46;
    }
    r ? r[n++] = s : r = new e(s);
  }
  return r;
}
class bc {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const Xx = new bc();
class lU {
  /**
  @internal
  */
  constructor(e, r) {
    this.input = e, this.ranges = r, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = Xx, this.rangeIndex = 0, this.pos = this.chunkPos = r[0].from, this.range = r[0], this.end = r[r.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, r) {
    let i = this.range, n = this.rangeIndex, s = this.pos + e;
    for (; s < i.from; ) {
      if (!n)
        return null;
      let a = this.ranges[--n];
      s -= i.from - a.to, i = a;
    }
    for (; r < 0 ? s > i.to : s >= i.to; ) {
      if (n == this.ranges.length - 1)
        return null;
      let a = this.ranges[++n];
      s += a.from - i.to, i = a;
    }
    return s;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let r of this.ranges)
      if (r.to > e)
        return Math.max(e, r.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingwhen looking forwardor even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let r = this.chunkOff + e, i, n;
    if (r >= 0 && r < this.chunk.length)
      i = this.pos + e, n = this.chunk.charCodeAt(r);
    else {
      let s = this.resolveOffset(e, 1);
      if (s == null)
        return -1;
      if (i = s, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        n = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let a = this.rangeIndex, o = this.range;
        for (; o.to <= i; )
          o = this.ranges[++a];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > o.to && (this.chunk2 = this.chunk2.slice(0, o.to - i)), n = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), n;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, r = 0) {
    let i = r ? this.resolveOffset(r, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, r) {
    this.token.value = e, this.token.end = r;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: r } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = r, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), r = this.pos + e.length;
      this.chunk = r > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, r) {
    if (r ? (this.token = r, r.start = e, r.lookAhead = e + 1, r.value = r.extended = -1) : this.token = Xx, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, r) {
    if (e >= this.chunkPos && r <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, r - this.chunkPos);
    if (e >= this.chunk2Pos && r <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, r - this.chunk2Pos);
    if (e >= this.range.from && r <= this.range.to)
      return this.input.read(e, r);
    let i = "";
    for (let n of this.ranges) {
      if (n.from >= r)
        break;
      n.to > e && (i += this.input.read(Math.max(n.from, e), Math.min(n.to, r)));
    }
    return i;
  }
}
class Ea {
  constructor(e, r) {
    this.data = e, this.id = r;
  }
  token(e, r) {
    let { parser: i } = r.p;
    _E(this.data, e, r, this.id, i.data, i.tokenPrecTable);
  }
}
Ea.prototype.contextual = Ea.prototype.fallback = Ea.prototype.extend = !1;
class oh {
  constructor(e, r, i) {
    this.precTable = r, this.elseToken = i, this.data = typeof e == "string" ? Lo(e) : e;
  }
  token(e, r) {
    let i = e.pos, n = 0;
    for (; ; ) {
      let s = e.next < 0, a = e.resolveOffset(1, 1);
      if (_E(this.data, e, r, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (s || n++, a == null)
        break;
      e.reset(a, e.token);
    }
    n && (e.reset(i, e.token), e.acceptToken(this.elseToken, n));
  }
}
oh.prototype.contextual = Ea.prototype.fallback = Ea.prototype.extend = !1;
class hi {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, r = {}) {
    this.token = e, this.contextual = !!r.contextual, this.fallback = !!r.fallback, this.extend = !!r.extend;
  }
}
function _E(t, e, r, i, n, s) {
  let a = 0, o = 1 << i, { dialect: u } = r.p.parser;
  e:
    for (; o & t[a]; ) {
      let c = t[a + 1];
      for (let y = a + 3; y < c; y += 2)
        if ((t[y + 1] & o) > 0) {
          let O = t[y];
          if (u.allows(O) && (e.token.value == -1 || e.token.value == O || uU(O, e.token.value, n, s))) {
            e.acceptToken(O);
            break;
          }
        }
      let h = e.next, d = 0, m = t[a + 2];
      if (e.next < 0 && m > d && t[c + m * 3 - 3] == 65535) {
        a = t[c + m * 3 - 1];
        continue e;
      }
      for (; d < m; ) {
        let y = d + m >> 1, O = c + y + (y << 1), b = t[O], v = t[O + 1] || 65536;
        if (h < b)
          m = y;
        else if (h >= v)
          d = y + 1;
        else {
          a = t[O + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function Vx(t, e, r) {
  for (let i = e, n; (n = t[i]) != 65535; i++)
    if (n == r)
      return i - e;
  return -1;
}
function uU(t, e, r, i) {
  let n = Vx(r, i, e);
  return n < 0 || Vx(r, i, t) < n;
}
const dr = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let Ad = null;
function Yx(t, e, r) {
  let i = t.cursor(Ke.IncludeAnonymous);
  for (i.moveTo(e); ; )
    if (!(r < 0 ? i.childBefore(e) : i.childAfter(e)))
      for (; ; ) {
        if ((r < 0 ? i.to < e : i.from > e) && !i.type.isError)
          return r < 0 ? Math.max(0, Math.min(
            i.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(t.length, Math.max(
            i.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (r < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return r < 0 ? 0 : t.length;
      }
}
class cU {
  constructor(e, r) {
    this.fragments = e, this.nodeSet = r, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? Yx(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? Yx(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let r = this.trees.length - 1;
      if (r < 0)
        return this.nextFragment(), null;
      let i = this.trees[r], n = this.index[r];
      if (n == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = i.children[n], a = this.start[r] + i.positions[n];
      if (a > e)
        return this.nextStart = a, null;
      if (s instanceof ut) {
        if (a == e) {
          if (a < this.safeFrom)
            return null;
          let o = a + s.length;
          if (o <= this.safeTo) {
            let u = s.prop(ke.lookAhead);
            if (!u || o + u < this.fragment.to)
              return s;
          }
        }
        this.index[r]++, a + s.length >= Math.max(this.safeFrom, e) && (this.trees.push(s), this.start.push(a), this.index.push(0));
      } else
        this.index[r]++, this.nextStart = a + s.length;
    }
  }
}
class hU {
  constructor(e, r) {
    this.stream = r, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((i) => new bc());
  }
  getActions(e) {
    let r = 0, i = null, { parser: n } = e.p, { tokenizers: s } = n, a = n.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), o = e.curContext ? e.curContext.hash : 0, u = 0;
    for (let c = 0; c < s.length; c++) {
      if (!(1 << c & a))
        continue;
      let h = s[c], d = this.tokens[c];
      if (!(i && !h.fallback) && ((h.contextual || d.start != e.pos || d.mask != a || d.context != o) && (this.updateCachedToken(d, h, e), d.mask = a, d.context = o), d.lookAhead > d.end + 25 && (u = Math.max(d.lookAhead, u)), d.value != 0)) {
        let m = r;
        if (d.extended > -1 && (r = this.addActions(e, d.extended, d.end, r)), r = this.addActions(e, d.value, d.end, r), !h.extend && (i = d, r > m))
          break;
      }
    }
    for (; this.actions.length > r; )
      this.actions.pop();
    return u && e.setLookAhead(u), !i && e.pos == this.stream.end && (i = new bc(), i.value = e.p.parser.eofTerm, i.start = i.end = e.pos, r = this.addActions(e, i.value, i.end, r)), this.mainToken = i, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let r = new bc(), { pos: i, p: n } = e;
    return r.start = i, r.end = Math.min(i + 1, n.stream.end), r.value = i == n.stream.end ? n.parser.eofTerm : 0, r;
  }
  updateCachedToken(e, r, i) {
    let n = this.stream.clipPos(i.pos);
    if (r.token(this.stream.reset(n, e), i), e.value > -1) {
      let { parser: s } = i.p;
      for (let a = 0; a < s.specialized.length; a++)
        if (s.specialized[a] == e.value) {
          let o = s.specializers[a](this.stream.read(e.start, e.end), i);
          if (o >= 0 && i.p.parser.dialect.allows(o >> 1)) {
            o & 1 ? e.extended = o >> 1 : e.value = o >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(n + 1);
  }
  putAction(e, r, i, n) {
    for (let s = 0; s < n; s += 3)
      if (this.actions[s] == e)
        return n;
    return this.actions[n++] = e, this.actions[n++] = r, this.actions[n++] = i, n;
  }
  addActions(e, r, i, n) {
    let { state: s } = e, { parser: a } = e.p, { data: o } = a;
    for (let u = 0; u < 2; u++)
      for (let c = a.stateSlot(
        s,
        u ? 2 : 1
        /* ParseState.Actions */
      ); ; c += 3) {
        if (o[c] == 65535)
          if (o[c + 1] == 1)
            c = zi(o, c + 2);
          else {
            n == 0 && o[c + 1] == 2 && (n = this.putAction(zi(o, c + 2), r, i, n));
            break;
          }
        o[c] == r && (n = this.putAction(zi(o, c + 1), r, i, n));
      }
    return n;
  }
}
class pU {
  constructor(e, r, i, n) {
    this.parser = e, this.input = r, this.ranges = n, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new lU(r, n), this.tokens = new hU(e, this.stream), this.topTerm = e.top[1];
    let { from: s } = n[0];
    this.stacks = [sh.start(this, e.top[0], s)], this.fragments = i.length && this.stream.end - s > e.bufferLength * 4 ? new cU(i, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, r = this.minStackPos, i = this.stacks = [], n, s;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [a] = e;
      for (; a.forceReduce() && a.stack.length && a.stack[a.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      for (; ; ) {
        if (this.tokens.mainToken = null, o.pos > r)
          i.push(o);
        else {
          if (this.advanceStack(o, i, e))
            continue;
          {
            n || (n = [], s = []), n.push(o);
            let u = this.tokens.getMainToken(o);
            s.push(u.value, u.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let a = n && fU(n);
      if (a)
        return dr && console.log("Finish with " + this.stackID(a)), this.stackToTree(a);
      if (this.parser.strict)
        throw dr && n && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + r);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && n) {
      let a = this.stoppedAt != null && n[0].pos > this.stoppedAt ? n[0] : this.runRecovery(n, s, i);
      if (a)
        return dr && console.log("Force-finish " + this.stackID(a)), this.stackToTree(a.forceAll());
    }
    if (this.recovering) {
      let a = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > a)
        for (i.sort((o, u) => u.score - o.score); i.length > a; )
          i.pop();
      i.some((o) => o.reducePos > r) && this.recovering--;
    } else if (i.length > 1) {
      e:
        for (let a = 0; a < i.length - 1; a++) {
          let o = i[a];
          for (let u = a + 1; u < i.length; u++) {
            let c = i[u];
            if (o.sameState(c) || o.buffer.length > 500 && c.buffer.length > 500)
              if ((o.score - c.score || o.buffer.length - c.buffer.length) > 0)
                i.splice(u--, 1);
              else {
                i.splice(a--, 1);
                continue e;
              }
          }
        }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let a = 1; a < i.length; a++)
      i[a].pos < this.minStackPos && (this.minStackPos = i[a].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, r, i) {
    let n = e.pos, { parser: s } = this, a = dr ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && n > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict, h = c ? e.curContext.hash : 0;
      for (let d = this.fragments.nodeAt(n); d; ) {
        let m = this.parser.nodeSet.types[d.type.id] == d.type ? s.getGoto(e.state, d.type.id) : -1;
        if (m > -1 && d.length && (!c || (d.prop(ke.contextHash) || 0) == h))
          return e.useNode(d, m), dr && console.log(a + this.stackID(e) + ` (via reuse of ${s.getName(d.type.id)})`), !0;
        if (!(d instanceof ut) || d.children.length == 0 || d.positions[0] > 0)
          break;
        let y = d.children[0];
        if (y instanceof ut && d.positions[0] == 0)
          d = y;
        else
          break;
      }
    }
    let o = s.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (o > 0)
      return e.reduce(o), dr && console.log(a + this.stackID(e) + ` (via always-reduce ${s.getName(
        o & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let u = this.tokens.getActions(e);
    for (let c = 0; c < u.length; ) {
      let h = u[c++], d = u[c++], m = u[c++], y = c == u.length || !i, O = y ? e : e.split(), b = this.tokens.mainToken;
      if (O.apply(h, d, b ? b.start : O.pos, m), dr && console.log(a + this.stackID(O) + ` (via ${h & 65536 ? `reduce of ${s.getName(
        h & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${s.getName(d)} @ ${n}${O == e ? "" : ", split"})`), y)
        return !0;
      O.pos > n ? r.push(O) : i.push(O);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, r) {
    let i = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > i)
        return Ux(e, r), !0;
    }
  }
  runRecovery(e, r, i) {
    let n = null, s = !1;
    for (let a = 0; a < e.length; a++) {
      let o = e[a], u = r[a << 1], c = r[(a << 1) + 1], h = dr ? this.stackID(o) + " -> " : "";
      if (o.deadEnd && (s || (s = !0, o.restart(), dr && console.log(h + this.stackID(o) + " (restarted)"), this.advanceFully(o, i))))
        continue;
      let d = o.split(), m = h;
      for (let y = 0; d.forceReduce() && y < 10 && (dr && console.log(m + this.stackID(d) + " (via force-reduce)"), !this.advanceFully(d, i)); y++)
        dr && (m = this.stackID(d) + " -> ");
      for (let y of o.recoverByInsert(u))
        dr && console.log(h + this.stackID(y) + " (via recover-insert)"), this.advanceFully(y, i);
      this.stream.end > o.pos ? (c == o.pos && (c++, u = 0), o.recoverByDelete(u, c), dr && console.log(h + this.stackID(o) + ` (via recover-delete ${this.parser.getName(u)})`), Ux(o, i)) : (!n || n.score < o.score) && (n = o);
    }
    return n;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), ut.build({
      buffer: ah.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let r = (Ad || (Ad = /* @__PURE__ */ new WeakMap())).get(e);
    return r || Ad.set(e, r = String.fromCodePoint(this.nextStackID++)), r + e;
  }
}
function Ux(t, e) {
  for (let r = 0; r < e.length; r++) {
    let i = e[r];
    if (i.pos == t.pos && i.sameState(t)) {
      e[r].score < t.score && (e[r] = t);
      return;
    }
  }
  e.push(t);
}
class dU {
  constructor(e, r, i) {
    this.source = e, this.flags = r, this.disabled = i;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const Ed = (t) => t;
class QE {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || Ed, this.reduce = e.reduce || Ed, this.reuse = e.reuse || Ed, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class Bs extends lA {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let r = e.nodeNames.split(" ");
    this.minRepeatTerm = r.length;
    for (let o = 0; o < e.repeatNodeCount; o++)
      r.push("");
    let i = Object.keys(e.topRules).map((o) => e.topRules[o][1]), n = [];
    for (let o = 0; o < r.length; o++)
      n.push([]);
    function s(o, u, c) {
      n[o].push([u, u.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let o of e.nodeProps) {
        let u = o[0];
        typeof u == "string" && (u = ke[u]);
        for (let c = 1; c < o.length; ) {
          let h = o[c++];
          if (h >= 0)
            s(h, u, o[c++]);
          else {
            let d = o[c + -h];
            for (let m = -h; m > 0; m--)
              s(o[c++], u, d);
            c++;
          }
        }
      }
    this.nodeSet = new my(r.map((o, u) => er.define({
      name: u >= this.minRepeatTerm ? void 0 : o,
      id: u,
      props: n[u],
      top: i.indexOf(u) > -1,
      error: u == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(u) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = iA;
    let a = Lo(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let o = 0; o < this.specializerSpecs.length; o++)
      this.specialized[o] = this.specializerSpecs[o].term;
    this.specializers = this.specializerSpecs.map(zx), this.states = Lo(e.states, Uint32Array), this.data = Lo(e.stateData), this.goto = Lo(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((o) => typeof o == "number" ? new Ea(a, o) : o), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, r, i) {
    let n = new pU(this, e, r, i);
    for (let s of this.wrappers)
      n = s(n, e, r, i);
    return n;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, r, i = !1) {
    let n = this.goto;
    if (r >= n[0])
      return -1;
    for (let s = n[r + 1]; ; ) {
      let a = n[s++], o = a & 1, u = n[s++];
      if (o && i)
        return u;
      for (let c = s + (a >> 1); s < c; s++)
        if (n[s] == e)
          return u;
      if (o)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, r) {
    let i = this.data;
    for (let n = 0; n < 2; n++)
      for (let s = this.stateSlot(
        e,
        n ? 2 : 1
        /* ParseState.Actions */
      ), a; ; s += 3) {
        if ((a = i[s]) == 65535)
          if (i[s + 1] == 1)
            a = i[s = zi(i, s + 2)];
          else {
            if (i[s + 1] == 2)
              return zi(i, s + 2);
            break;
          }
        if (a == r || a == 0)
          return zi(i, s + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, r) {
    return this.states[e * 6 + r];
  }
  /**
  @internal
  */
  stateFlag(e, r) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & r) > 0;
  }
  /**
  @internal
  */
  validAction(e, r) {
    return !!this.allActions(e, (i) => i == r ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, r) {
    let i = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), n = i ? r(i) : void 0;
    for (let s = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); n == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1)
          s = zi(this.data, s + 2);
        else
          break;
      n = r(zi(this.data, s + 1));
    }
    return n;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let r = [];
    for (let i = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = zi(this.data, i + 2);
        else
          break;
      if (!(this.data[i + 2] & 1)) {
        let n = this.data[i + 1];
        r.some((s, a) => a & 1 && s == n) || r.push(this.data[i], n);
      }
    }
    return r;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let r = Object.assign(Object.create(Bs.prototype), this);
    if (e.props && (r.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let i = this.topRules[e.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      r.top = i;
    }
    return e.tokenizers && (r.tokenizers = this.tokenizers.map((i) => {
      let n = e.tokenizers.find((s) => s.from == i);
      return n ? n.to : i;
    })), e.specializers && (r.specializers = this.specializers.slice(), r.specializerSpecs = this.specializerSpecs.map((i, n) => {
      let s = e.specializers.find((o) => o.from == i.external);
      if (!s)
        return i;
      let a = Object.assign(Object.assign({}, i), { external: s.to });
      return r.specializers[n] = zx(a), a;
    })), e.contextTracker && (r.context = e.contextTracker), e.dialect && (r.dialect = this.parseDialect(e.dialect)), e.strict != null && (r.strict = e.strict), e.wrap && (r.wrappers = r.wrappers.concat(e.wrap)), e.bufferLength != null && (r.bufferLength = e.bufferLength), r;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let r = this.dynamicPrecedences;
    return r == null ? 0 : r[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let r = Object.keys(this.dialects), i = r.map(() => !1);
    if (e)
      for (let s of e.split(" ")) {
        let a = r.indexOf(s);
        a >= 0 && (i[a] = !0);
      }
    let n = null;
    for (let s = 0; s < r.length; s++)
      if (!i[s])
        for (let a = this.dialects[r[s]], o; (o = this.data[a++]) != 65535; )
          (n || (n = new Uint8Array(this.maxTerm + 1)))[o] = 1;
    return new dU(e, i, n);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new Bs(e);
  }
}
function zi(t, e) {
  return t[e] | t[e + 1] << 16;
}
function fU(t) {
  let e = null;
  for (let r of t) {
    let i = r.p.stoppedAt;
    (r.pos == r.p.stream.end || i != null && r.pos > i) && r.p.parser.stateFlag(
      r.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < r.score) && (e = r);
  }
  return e;
}
function zx(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (r, i) => t.external(r, i) << 1 | e;
  }
  return t.get;
}
const mU = 54, gU = 1, yU = 55, OU = 2, xU = 56, bU = 3, Gx = 4, DU = 5, lh = 6, ME = 7, LE = 8, RE = 9, jE = 10, vU = 11, SU = 12, wU = 13, kd = 57, CU = 14, Hx = 58, ZE = 20, AU = 22, WE = 23, EU = 24, xm = 26, qE = 27, kU = 28, TU = 31, PU = 34, FU = 36, $U = 37, BU = 0, IU = 1, NU = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, _U = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, Jx = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function QU(t) {
  return t == 45 || t == 46 || t == 58 || t >= 65 && t <= 90 || t == 95 || t >= 97 && t <= 122 || t >= 161;
}
function XE(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
let Kx = null, eb = null, tb = 0;
function bm(t, e) {
  let r = t.pos + e;
  if (tb == r && eb == t)
    return Kx;
  let i = t.peek(e);
  for (; XE(i); )
    i = t.peek(++e);
  let n = "";
  for (; QU(i); )
    n += String.fromCharCode(i), i = t.peek(++e);
  return eb = t, tb = r, Kx = n ? n.toLowerCase() : i == MU || i == LU ? void 0 : null;
}
const VE = 60, uh = 62, _y = 47, MU = 63, LU = 33, RU = 45;
function rb(t, e) {
  this.name = t, this.parent = e, this.hash = e ? e.hash : 0;
  for (let r = 0; r < t.length; r++)
    this.hash += (this.hash << 4) + t.charCodeAt(r) + (t.charCodeAt(r) << 8);
}
const jU = [lh, jE, ME, LE, RE], ZU = new QE({
  start: null,
  shift(t, e, r, i) {
    return jU.indexOf(e) > -1 ? new rb(bm(i, 1) || "", t) : t;
  },
  reduce(t, e) {
    return e == ZE && t ? t.parent : t;
  },
  reuse(t, e, r, i) {
    let n = e.type.id;
    return n == lh || n == FU ? new rb(bm(i, 1) || "", t) : t;
  },
  hash(t) {
    return t ? t.hash : 0;
  },
  strict: !1
}), WU = new hi((t, e) => {
  if (t.next != VE) {
    t.next < 0 && e.context && t.acceptToken(kd);
    return;
  }
  t.advance();
  let r = t.next == _y;
  r && t.advance();
  let i = bm(t, 0);
  if (i === void 0)
    return;
  if (!i)
    return t.acceptToken(r ? CU : lh);
  let n = e.context ? e.context.name : null;
  if (r) {
    if (i == n)
      return t.acceptToken(vU);
    if (n && _U[n])
      return t.acceptToken(kd, -2);
    if (e.dialectEnabled(BU))
      return t.acceptToken(SU);
    for (let s = e.context; s; s = s.parent)
      if (s.name == i)
        return;
    t.acceptToken(wU);
  } else {
    if (i == "script")
      return t.acceptToken(ME);
    if (i == "style")
      return t.acceptToken(LE);
    if (i == "textarea")
      return t.acceptToken(RE);
    if (NU.hasOwnProperty(i))
      return t.acceptToken(jE);
    n && Jx[n] && Jx[n][i] ? t.acceptToken(kd, -1) : t.acceptToken(lh);
  }
}, { contextual: !0 }), qU = new hi((t) => {
  for (let e = 0, r = 0; ; r++) {
    if (t.next < 0) {
      r && t.acceptToken(Hx);
      break;
    }
    if (t.next == RU)
      e++;
    else if (t.next == uh && e >= 2) {
      r >= 3 && t.acceptToken(Hx, -2);
      break;
    } else
      e = 0;
    t.advance();
  }
});
function XU(t) {
  for (; t; t = t.parent)
    if (t.name == "svg" || t.name == "math")
      return !0;
  return !1;
}
const VU = new hi((t, e) => {
  if (t.next == _y && t.peek(1) == uh) {
    let r = e.dialectEnabled(IU) || XU(e.context);
    t.acceptToken(r ? DU : Gx, 2);
  } else
    t.next == uh && t.acceptToken(Gx, 1);
});
function Qy(t, e, r) {
  let i = 2 + t.length;
  return new hi((n) => {
    for (let s = 0, a = 0, o = 0; ; o++) {
      if (n.next < 0) {
        o && n.acceptToken(e);
        break;
      }
      if (s == 0 && n.next == VE || s == 1 && n.next == _y || s >= 2 && s < i && n.next == t.charCodeAt(s - 2))
        s++, a++;
      else if ((s == 2 || s == i) && XE(n.next))
        a++;
      else if (s == i && n.next == uh) {
        o > a ? n.acceptToken(e, -a) : n.acceptToken(r, -(a - 2));
        break;
      } else if ((n.next == 10 || n.next == 13) && o) {
        n.acceptToken(e, 1);
        break;
      } else
        s = a = 0;
      n.advance();
    }
  });
}
const YU = Qy("script", mU, gU), UU = Qy("style", yU, OU), zU = Qy("textarea", xU, bU), GU = Hl({
  "Text RawText": _.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": _.angleBracket,
  TagName: _.tagName,
  "MismatchedCloseTag/TagName": [_.tagName, _.invalid],
  AttributeName: _.attributeName,
  "AttributeValue UnquotedAttributeValue": _.attributeValue,
  Is: _.definitionOperator,
  "EntityReference CharacterReference": _.character,
  Comment: _.blockComment,
  ProcessingInst: _.processingInstruction,
  DoctypeDecl: _.documentMeta
}), HU = Bs.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%WQ&rO,59fO%`Q&rO,59iO%hQ&rO,59lO%sQ&rO,59nOOOa'#D^'#D^O%{OaO'#CxO&WOaO,59[OOOb'#D_'#D_O&`ObO'#C{O&kObO,59[OOOd'#D`'#D`O&sOdO'#DOO'OOdO,59[OOO`'#Da'#DaO'WO!rO,59[O'_Q#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'dO$fO,59oOOO`,59o,59oO'lQ#|O,59qO'qQ#|O,59rOOO`-E7W-E7WO'vQ&rO'#CsOOQW'#DZ'#DZO(UQ&rO1G.wOOOa1G.w1G.wO(^Q&rO1G/QOOOb1G/Q1G/QO(fQ&rO1G/TOOOd1G/T1G/TO(nQ&rO1G/WOOO`1G/W1G/WOOO`1G/Y1G/YO(yQ&rO1G/YOOOa-E7[-E7[O)RQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)WQ#tO'#C|OOOd-E7^-E7^O)]Q#tO'#DPOOO`-E7_-E7_O)bQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O)gQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rOOO`7+$t7+$tO)rQ#|O,59eO)wQ#|O,59hO)|Q#|O,59kOOO`1G/X1G/XO*RO7[O'#CvO*dOMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O*uO7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+WOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: "+s~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OhyO~OS!OOhyO~OS!QOhyO~OS!SOT!TOhyO~OS!TOhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXhgXTgX~OS!fOhyO~OS!gOhyO~OS!hOhyO~OS!iOT!jOhyO~OS!jOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: " StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: ZU,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [GU],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [YU, UU, zU, VU, WU, qU, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 485 },
  tokenPrec: 487
});
function YE(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let i of t.getChildren(WE)) {
    let n = i.getChild(EU), s = i.getChild(xm) || i.getChild(qE);
    n && (r[e.read(n.from, n.to)] = s ? s.type.id == xm ? e.read(s.from + 1, s.to - 1) : e.read(s.from, s.to) : "");
  }
  return r;
}
function ib(t, e) {
  let r = t.getChild(AU);
  return r ? e.read(r.from, r.to) : " ";
}
function Td(t, e, r) {
  let i;
  for (let n of r)
    if (!n.attrs || n.attrs(i || (i = YE(t.node.parent.firstChild, e))))
      return { parser: n.parser };
  return null;
}
function UE(t = [], e = []) {
  let r = [], i = [], n = [], s = [];
  for (let o of t)
    (o.tag == "script" ? r : o.tag == "style" ? i : o.tag == "textarea" ? n : s).push(o);
  let a = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let o of e)
    (a[o.name] || (a[o.name] = [])).push(o);
  return HW((o, u) => {
    let c = o.type.id;
    if (c == kU)
      return Td(o, u, r);
    if (c == TU)
      return Td(o, u, i);
    if (c == PU)
      return Td(o, u, n);
    if (c == ZE && s.length) {
      let h = o.node, d = h.firstChild, m = d && ib(d, u), y;
      if (m) {
        for (let O of s)
          if (O.tag == m && (!O.attrs || O.attrs(y || (y = YE(h, u))))) {
            let b = h.lastChild, v = b.type.id == $U ? b.from : h.to;
            if (v > d.to)
              return { parser: O.parser, overlay: [{ from: d.to, to: v }] };
          }
      }
    }
    if (a && c == WE) {
      let h = o.node, d;
      if (d = h.firstChild) {
        let m = a[u.read(d.from, d.to)];
        if (m)
          for (let y of m) {
            if (y.tagName && y.tagName != ib(h.parent, u))
              continue;
            let O = h.lastChild;
            if (O.type.id == xm) {
              let b = O.from + 1, v = O.lastChild, S = O.to - (v && v.isError ? 0 : 1);
              if (S > b)
                return { parser: y.parser, overlay: [{ from: b, to: S }] };
            } else if (O.type.id == qE)
              return { parser: y.parser, overlay: [{ from: O.from, to: O.to }] };
          }
      }
    }
    return null;
  });
}
const JU = 99, nb = 1, KU = 100, ez = 101, sb = 2, zE = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], tz = 58, rz = 40, GE = 95, iz = 91, Dc = 45, nz = 46, sz = 35, az = 37, oz = 38, lz = 92, uz = 10;
function El(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 161;
}
function cz(t) {
  return t >= 48 && t <= 57;
}
const hz = new hi((t, e) => {
  for (let r = !1, i = 0, n = 0; ; n++) {
    let { next: s } = t;
    if (El(s) || s == Dc || s == GE || r && cz(s))
      !r && (s != Dc || n > 0) && (r = !0), i === n && s == Dc && i++, t.advance();
    else if (s == lz && t.peek(1) != uz)
      t.advance(), t.next > -1 && t.advance(), r = !0;
    else {
      r && t.acceptToken(s == rz ? KU : i == 2 && e.canShift(sb) ? sb : ez);
      break;
    }
  }
}), pz = new hi((t) => {
  if (zE.includes(t.peek(-1))) {
    let { next: e } = t;
    (El(e) || e == GE || e == sz || e == nz || e == iz || e == tz && El(t.peek(1)) || e == Dc || e == oz) && t.acceptToken(JU);
  }
}), dz = new hi((t) => {
  if (!zE.includes(t.peek(-1))) {
    let { next: e } = t;
    if (e == az && (t.advance(), t.acceptToken(nb)), El(e)) {
      do
        t.advance();
      while (El(t.next));
      t.acceptToken(nb);
    }
  }
}), fz = Hl({
  "AtKeyword import charset namespace keyframes media supports": _.definitionKeyword,
  "from to selector": _.keyword,
  NamespaceName: _.namespace,
  KeyframeName: _.labelName,
  KeyframeRangeName: _.operatorKeyword,
  TagName: _.tagName,
  ClassName: _.className,
  PseudoClassName: _.constant(_.className),
  IdName: _.labelName,
  "FeatureName PropertyName": _.propertyName,
  AttributeName: _.attributeName,
  NumberLiteral: _.number,
  KeywordQuery: _.keyword,
  UnaryQueryOp: _.operatorKeyword,
  "CallTag ValueName": _.atom,
  VariableName: _.variableName,
  Callee: _.operatorKeyword,
  Unit: _.unit,
  "UniversalSelector NestingSelector": _.definitionOperator,
  MatchOp: _.compareOperator,
  "ChildOp SiblingOp, LogicOp": _.logicOperator,
  BinOp: _.arithmeticOperator,
  Important: _.modifier,
  Comment: _.blockComment,
  ColorLiteral: _.color,
  "ParenthesizedContent StringLiteral": _.string,
  ":": _.punctuation,
  "PseudoOp #": _.derefOperator,
  "; ,": _.separator,
  "( )": _.paren,
  "[ ]": _.squareBracket,
  "{ }": _.brace
}), mz = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 138 }, gz = { __proto__: null, "@import": 118, "@media": 142, "@charset": 146, "@namespace": 150, "@keyframes": 156, "@supports": 168 }, yz = { __proto__: null, not: 132, only: 132 }, Oz = Bs.deserialize({
  version: 14,
  states: ":^QYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO${QdO,59}O-kQ[O'#E^O-xQWO,5;_O-xQWO,5;_POOO'#EV'#EVP.TO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.zQXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/XQ`O1G/^O/rQXO1G/aO0YQXO1G/cO0pQXO1G/dO1WQWO,59|O1]Q[O'#DSO1dQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1kQpO,59]OOQS,59_,59_O${QdO,59aO1sQWO1G/mOOQS,59c,59cO1xQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2QQ[O,59jOOQS,59j,59jO2YQWO'#DjO2eQWO,5:VO2jQWO,5:]O&`Q[O,5:XO&`Q[O'#E_O2rQWO,5;`O2}QWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3`QWO1G0OO3eQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO3pQtO1G/iOOQO,5:x,5:xO4WQ[O,5:xOOQO-E8[-E8[O4eQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO4pQXO'#ErO4wQWO,59nO4|QtO'#EXO5tQdO'#EoO6OQWO,59ZO6TQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XO6]QWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6bQWO,5:yOOQO-E8]-E8]O6pQXO1G/xOOQS7+%j7+%jO6wQYO'#CsOOQO'#EQ'#EQO7SQ`O'#EPOOQO'#EP'#EPO7_QWO'#E`O7gQdO,5:jOOQS,5:j,5:jO7rQtO'#E]O${QdO'#E]O8sQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9WQpO<<HdO9`QWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9hQWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO9pQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3hQdO'#EaO7_QWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO9wQtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO:xQdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
  stateData: ";[~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#wO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.`Op#yO|#zO~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/aOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/aOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/aO!S#{O~Oa#fP~P(aOa#cP~P${Oa$SOj#XO~O!Y$UO~Oh$VOo$VO~Op$XO#X#]O~O]!`Xa!^X!b!^X~O]$YO~Oa$ZO!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$`O~O!S$gO#X$bO#e$aO~Oj#XOt$iO!X$kO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$oO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$qOa#cX~P${Oa$sO~Oj#XOp$tO~Oa$uO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$wO~P.`OP#WOtgX!TgX~O#e$aOt!sX!T!sX~Ot$yO!TwO~O!S$}O#X$bO#e$aO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$iO!X%QO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%RO~OtoOa#fa~Ot$qOa#ca~Oa%UO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
  goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#skYOPdhotuvw!n#R#h#skSOPdhotuvw!n#R#h#sQmTR!tnQ{VR!xqQ!x}Q#Z!XR#x!zq![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SU$d#m$f$yR$x$cq!XZ]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#x!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ${$eR%X$zSgPwQ!phQ#r!nR$l#sZfPhw!n#sa!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$e#m$fR%V$yV$c#m$f$yQ!rjR#v!rQdOShPwU!ldh#sR#s!nQ$P#SU$p$P$v%SQ$v$YR%S$qQ#_!ZR$W#_Q$r$PR%T$rQpUS!vp$nR$n#|Q$j#qR%P$jQ!ogS#t!o#uR#u!pQ#f!_R$^#fQ$f#mR$|$fQ$z$eR%W$z_cOPdhw!n#s^UOPdhw!n#sQ!uoQ!}tQ#OuQ#PvQ#|#RR$_#hR$Q#SQ!VZQ!d]Q#V!TQ#q!m[$O#S$P$Y$q$v%SQ$R#UQ$T#XS$h#q$jQ$m#zR%O$iR#}#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$[#dR$]#e",
  nodeNames: " Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 117,
  nodeProps: [
    ["isolate", -2, 3, 24, ""],
    ["openedBy", 17, "(", 32, "[", 50, "{"],
    ["closedBy", 18, ")", 33, "]", 51, "}"]
  ],
  propSources: [fz],
  skippedNodes: [0, 3, 87],
  repeatNodeCount: 11,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [pz, dz, hz, 1, 2, 3, 4, new oh("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~", 28, 105)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 86] },
  specialized: [{ term: 100, get: (t) => mz[t] || -1 }, { term: 58, get: (t) => gz[t] || -1 }, { term: 101, get: (t) => yz[t] || -1 }],
  tokenPrec: 1200
});
let Pd = null;
function Fd() {
  if (!Pd && typeof document == "object" && document.body) {
    let { style: t } = document.body, e = [], r = /* @__PURE__ */ new Set();
    for (let i in t)
      i != "cssText" && i != "cssFloat" && typeof t[i] == "string" && (/[A-Z]/.test(i) && (i = i.replace(/[A-Z]/g, (n) => "-" + n.toLowerCase())), r.has(i) || (e.push(i), r.add(i)));
    Pd = e.sort().map((i) => ({ type: "property", label: i }));
  }
  return Pd || [];
}
const ab = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((t) => ({ type: "class", label: t })), ob = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((t) => ({ type: "keyword", label: t })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((t) => ({ type: "constant", label: t }))), xz = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((t) => ({ type: "type", label: t })), Sn = /^(\w[\w-]*|-\w[\w-]*|)$/, bz = /^-(-[\w-]*)?$/;
function Dz(t, e) {
  var r;
  if ((t.name == "(" || t.type.isError) && (t = t.parent || t), t.name != "ArgList")
    return !1;
  let i = (r = t.parent) === null || r === void 0 ? void 0 : r.firstChild;
  return (i == null ? void 0 : i.name) != "Callee" ? !1 : e.sliceString(i.from, i.to) == "var";
}
const lb = /* @__PURE__ */ new oA(), vz = ["Declaration"];
function Sz(t) {
  for (let e = t; ; ) {
    if (e.type.isTop)
      return e;
    if (!(e = e.parent))
      return t;
  }
}
function HE(t, e, r) {
  if (e.to - e.from > 4096) {
    let i = lb.get(e);
    if (i)
      return i;
    let n = [], s = /* @__PURE__ */ new Set(), a = e.cursor(Ke.IncludeAnonymous);
    if (a.firstChild())
      do
        for (let o of HE(t, a.node, r))
          s.has(o.label) || (s.add(o.label), n.push(o));
      while (a.nextSibling());
    return lb.set(e, n), n;
  } else {
    let i = [], n = /* @__PURE__ */ new Set();
    return e.cursor().iterate((s) => {
      var a;
      if (r(s) && s.matchContext(vz) && ((a = s.node.nextSibling) === null || a === void 0 ? void 0 : a.name) == ":") {
        let o = t.sliceString(s.from, s.to);
        n.has(o) || (n.add(o), i.push({ label: o, type: "variable" }));
      }
    }), i;
  }
}
const wz = (t) => (e) => {
  let { state: r, pos: i } = e, n = ht(r).resolveInner(i, -1), s = n.type.isError && n.from == n.to - 1 && r.doc.sliceString(n.from, n.to) == "-";
  if (n.name == "PropertyName" || (s || n.name == "TagName") && /^(Block|Styles)$/.test(n.resolve(n.to).name))
    return { from: n.from, options: Fd(), validFor: Sn };
  if (n.name == "ValueName")
    return { from: n.from, options: ob, validFor: Sn };
  if (n.name == "PseudoClassName")
    return { from: n.from, options: ab, validFor: Sn };
  if (t(n) || (e.explicit || s) && Dz(n, r.doc))
    return {
      from: t(n) || s ? n.from : i,
      options: HE(r.doc, Sz(n), t),
      validFor: bz
    };
  if (n.name == "TagName") {
    for (let { parent: u } = n; u; u = u.parent)
      if (u.name == "Block")
        return { from: n.from, options: Fd(), validFor: Sn };
    return { from: n.from, options: xz, validFor: Sn };
  }
  if (!e.explicit)
    return null;
  let a = n.resolve(i), o = a.childBefore(i);
  return o && o.name == ":" && a.name == "PseudoClassSelector" ? { from: i, options: ab, validFor: Sn } : o && o.name == ":" && a.name == "Declaration" || a.name == "ArgList" ? { from: i, options: ob, validFor: Sn } : a.name == "Block" || a.name == "Styles" ? { from: i, options: Fd(), validFor: Sn } : null;
}, Cz = /* @__PURE__ */ wz((t) => t.name == "VariableName"), ch = /* @__PURE__ */ Fs.define({
  name: "css",
  parser: /* @__PURE__ */ Oz.configure({
    props: [
      /* @__PURE__ */ Kl.add({
        Declaration: /* @__PURE__ */ wa()
      }),
      /* @__PURE__ */ eu.add({
        "Block KeyframeList": vy
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function JE() {
  return new op(ch, ch.data.of({ autocomplete: Cz }));
}
const Az = 309, ub = 1, Ez = 2, kz = 3, Tz = 310, Pz = 312, Fz = 313, $z = 4, Bz = 5, Iz = 0, Dm = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], KE = 125, Nz = 59, vm = 47, _z = 42, Qz = 43, Mz = 45, Lz = 60, Rz = 44, jz = new QE({
  start: !1,
  shift(t, e) {
    return e == $z || e == Bz || e == Pz ? t : e == Fz;
  },
  strict: !1
}), Zz = new hi((t, e) => {
  let { next: r } = t;
  (r == KE || r == -1 || e.context) && t.acceptToken(Tz);
}, { contextual: !0, fallback: !0 }), Wz = new hi((t, e) => {
  let { next: r } = t, i;
  Dm.indexOf(r) > -1 || r == vm && ((i = t.peek(1)) == vm || i == _z) || r != KE && r != Nz && r != -1 && !e.context && t.acceptToken(Az);
}, { contextual: !0 }), qz = new hi((t, e) => {
  let { next: r } = t;
  if ((r == Qz || r == Mz) && (t.advance(), r == t.next)) {
    t.advance();
    let i = !e.context && e.canShift(ub);
    t.acceptToken(i ? ub : Ez);
  }
}, { contextual: !0 });
function $d(t, e) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t == 95 || t >= 192 || !e && t >= 48 && t <= 57;
}
const Xz = new hi((t, e) => {
  if (t.next != Lz || !e.dialectEnabled(Iz) || (t.advance(), t.next == vm))
    return;
  let r = 0;
  for (; Dm.indexOf(t.next) > -1; )
    t.advance(), r++;
  if ($d(t.next, !0)) {
    for (t.advance(), r++; $d(t.next, !1); )
      t.advance(), r++;
    for (; Dm.indexOf(t.next) > -1; )
      t.advance(), r++;
    if (t.next == Rz)
      return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!$d(t.next, !0))
          return;
        break;
      }
      if (t.next != "extends".charCodeAt(i))
        break;
      t.advance(), r++;
    }
  }
  t.acceptToken(kz, -r);
}), Vz = Hl({
  "get set async static": _.modifier,
  "for while do if else switch try catch finally return throw break continue default case": _.controlKeyword,
  "in of await yield void typeof delete instanceof": _.operatorKeyword,
  "let var const using function class extends": _.definitionKeyword,
  "import export from": _.moduleKeyword,
  "with debugger as new": _.keyword,
  TemplateString: _.special(_.string),
  super: _.atom,
  BooleanLiteral: _.bool,
  this: _.self,
  null: _.null,
  Star: _.modifier,
  VariableName: _.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": _.function(_.variableName),
  VariableDefinition: _.definition(_.variableName),
  Label: _.labelName,
  PropertyName: _.propertyName,
  PrivatePropertyName: _.special(_.propertyName),
  "CallExpression/MemberExpression/PropertyName": _.function(_.propertyName),
  "FunctionDeclaration/VariableDefinition": _.function(_.definition(_.variableName)),
  "ClassDeclaration/VariableDefinition": _.definition(_.className),
  PropertyDefinition: _.definition(_.propertyName),
  PrivatePropertyDefinition: _.definition(_.special(_.propertyName)),
  UpdateOp: _.updateOperator,
  "LineComment Hashbang": _.lineComment,
  BlockComment: _.blockComment,
  Number: _.number,
  String: _.string,
  Escape: _.escape,
  ArithOp: _.arithmeticOperator,
  LogicOp: _.logicOperator,
  BitOp: _.bitwiseOperator,
  CompareOp: _.compareOperator,
  RegExp: _.regexp,
  Equals: _.definitionOperator,
  Arrow: _.function(_.punctuation),
  ": Spread": _.punctuation,
  "( )": _.paren,
  "[ ]": _.squareBracket,
  "{ }": _.brace,
  "InterpolationStart InterpolationEnd": _.special(_.brace),
  ".": _.derefOperator,
  ", ;": _.separator,
  "@": _.meta,
  TypeName: _.typeName,
  TypeDefinition: _.definition(_.typeName),
  "type enum interface implements namespace module declare": _.definitionKeyword,
  "abstract global Privacy readonly override": _.modifier,
  "is keyof unique infer": _.operatorKeyword,
  JSXAttributeValue: _.attributeValue,
  JSXText: _.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": _.angleBracket,
  "JSXIdentifier JSXNameSpacedName": _.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": _.attributeName,
  "JSXBuiltin/JSXIdentifier": _.standard(_.tagName)
}), Yz = { __proto__: null, export: 18, as: 23, from: 31, default: 34, async: 39, function: 40, extends: 52, this: 56, true: 64, false: 64, null: 76, void: 80, typeof: 84, super: 102, new: 136, delete: 152, yield: 161, await: 165, class: 170, public: 227, private: 227, protected: 227, readonly: 229, instanceof: 248, satisfies: 251, in: 252, const: 254, import: 286, keyof: 339, unique: 343, infer: 349, is: 385, abstract: 405, implements: 407, type: 409, let: 412, var: 414, using: 417, interface: 423, enum: 427, namespace: 433, module: 435, declare: 439, global: 443, for: 462, of: 471, while: 474, with: 478, do: 482, if: 486, else: 488, switch: 492, case: 498, try: 504, catch: 508, finally: 512, return: 516, throw: 520, break: 524, continue: 528, debugger: 532 }, Uz = { __proto__: null, async: 123, get: 125, set: 127, declare: 187, public: 189, private: 189, protected: 189, static: 191, abstract: 193, override: 195, readonly: 201, accessor: 203, new: 389 }, zz = { __proto__: null, "<": 143 }, Gz = Bs.deserialize({
  version: 14,
  states: "$<UO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ08SO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO?MpO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DyO0fQ^O'#EROOQ07b'#EZ'#EZO1PQWO'#EWOOQO'#El'#ElOOQO'#Ie'#IeO1XQWO'#GmO1dQWO'#EkO1iQWO'#EkO3kQ08SO'#JiO6[Q08SO'#JjO6xQWO'#FZO6}Q&jO'#FqOOQ07b'#Fc'#FcO7YO,YO'#FcO7hQ7[O'#FxO9UQWO'#FwOOQ07b'#Jj'#JjOOQ07`'#Ji'#JiO9ZQWO'#GqOOQU'#KU'#KUO9fQWO'#IRO9kQ07hO'#ISOOQU'#JW'#JWOOQU'#IW'#IWQ`Q^OOO`Q^OOO%[Q^O'#DqO9sQ^O'#D}O9zQ^O'#EPO9aQWO'#GmO:RQ7[O'#CnO:aQWO'#EjO:lQWO'#EuO:qQ7[O'#FbO;`QWO'#GmOOQO'#KV'#KVO;eQWO'#KVO;sQWO'#GuO;sQWO'#GvO;sQWO'#GxO9aQWO'#G{O<jQWO'#HOO>RQWO'#CdO>cQWO'#H[O>kQWO'#HbO>kQWO'#HdO`Q^O'#HfO>kQWO'#HhO>kQWO'#HkO>pQWO'#HqO>uQ07iO'#HwO%[Q^O'#HyO?QQ07iO'#H{O?]Q07iO'#H}O9kQ07hO'#IPO?hQ08SO'#ChO@jQ`O'#DiQOQWOOO%[Q^O'#EPOAQQWO'#ESO:RQ7[O'#EjOA]QWO'#EjOAhQpO'#FbOOQU'#Cf'#CfOOQ07`'#Dn'#DnOOQ07`'#Jm'#JmO%[Q^O'#JmOOQO'#Jq'#JqOOQO'#Ib'#IbOBhQ`O'#EcOOQ07`'#Eb'#EbOCdQ07pO'#EcOCnQ`O'#EVOOQO'#Jp'#JpODSQ`O'#JqOEaQ`O'#EVOCnQ`O'#EcPEnO!0LbO'#CaPOOO)CDu)CDuOOOO'#IX'#IXOEyO!bO,59TOOQ07b,59T,59TOOOO'#IY'#IYOFXO#tO,59TO%[Q^O'#D`OOOO'#I['#I[OFgO?MpO,59xOOQ07b,59x,59xOFuQ^O'#I]OGYQWO'#JkOI[QrO'#JkO+}Q^O'#JkOIcQWO,5:OOIyQWO'#ElOJWQWO'#JyOJcQWO'#JxOJcQWO'#JxOJkQWO,5;YOJpQWO'#JwOOQ07f,5:Z,5:ZOJwQ^O,5:ZOLxQ08SO,5:eOMiQWO,5:mONSQ07hO'#JvONZQWO'#JuO9ZQWO'#JuONoQWO'#JuONwQWO,5;XON|QWO'#JuO!#UQrO'#JjOOQ07b'#Ch'#ChO%[Q^O'#ERO!#tQpO,5:rOOQO'#Jr'#JrOOQO-E<c-E<cO9aQWO,5=XO!$[QWO,5=XO!$aQ^O,5;VO!&dQ7[O'#EgO!'}QWO,5;VO!)mQ7[O'#DsO!)tQ^O'#DxO!*OQ`O,5;`O!*WQ`O,5;`O%[Q^O,5;`OOQU'#FR'#FROOQU'#FT'#FTO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aOOQU'#FX'#FXO!*fQ^O,5;rOOQ07b,5;w,5;wOOQ07b,5;x,5;xO!,iQWO,5;xOOQ07b,5;y,5;yO%[Q^O'#IiO!,qQ07hO,5<eO!&dQ7[O,5;aO!-`Q7[O,5;aO%[Q^O,5;uO!-gQ&jO'#FgO!.dQ&jO'#J}O!.OQ&jO'#J}O!.kQ&jO'#J}OOQO'#J}'#J}O!/PQ&jO,5<POOOS,5<],5<]O!/bQ^O'#FsOOOS'#Ih'#IhO7YO,YO,5;}O!/iQ&jO'#FuOOQ07b,5;},5;}O!0YQMhO'#CuOOQ07b'#Cy'#CyO!0mQWO'#CyO!0rO?MpO'#C}O!1`Q7[O,5<bO!1gQWO,5<dO!3SQ!LQO'#GSO!3aQWO'#GTO!3fQWO'#GTO!3kQ!LQO'#GXO!4jQ`O'#G]OOQO'#Gh'#GhO!(SQ7[O'#GgOOQO'#Gj'#GjO!(SQ7[O'#GiO!5]QMhO'#JdOOQ07b'#Jd'#JdO!5gQWO'#JcO!5uQWO'#JbO!5}QWO'#CtOOQ07b'#Cw'#CwOOQ07b'#DR'#DROOQ07b'#DT'#DTO1SQWO'#DVO!(SQ7[O'#FzO!(SQ7[O'#F|O!6VQWO'#GOO!6[QWO'#GPO!3fQWO'#GVO!(SQ7[O'#G[O!6aQWO'#EmO!7OQWO,5<cOOQ07`'#Cq'#CqO!7WQWO'#EnO!8QQ`O'#EoOOQ07`'#Jw'#JwO!8XQ07hO'#KWO9kQ07hO,5=]O`Q^O,5>mOOQU'#J`'#J`OOQU,5>n,5>nOOQU-E<U-E<UO!:ZQ08SO,5:]O!<wQ08SO,5:iO%[Q^O,5:iO!?bQ08SO,5:kOOQO,5@q,5@qO!@RQ7[O,5=XO!@aQ07hO'#JaO9UQWO'#JaO!@rQ07hO,59YO!@}Q`O,59YO!AVQ7[O,59YO:RQ7[O,59YO!AbQWO,5;VO!AjQWO'#HZO!BOQWO'#KZO%[Q^O,5;zO!7{Q`O,5;|O!BWQWO,5=tO!B]QWO,5=tO!BbQWO,5=tO9kQ07hO,5=tO;sQWO,5=dOOQO'#Cu'#CuO!BpQ`O,5=aO!BxQ7[O,5=bO!CTQWO,5=dO!CYQpO,5=gO!CbQWO'#KVO>pQWO'#HQO9aQWO'#HSO!CgQWO'#HSO:RQ7[O'#HUO!ClQWO'#HUOOQU,5=j,5=jO!CqQWO'#HVO!DSQWO'#CnO!DXQWO,59OO!DcQWO,59OO!FhQ^O,59OOOQU,59O,59OO!FxQ07hO,59OO%[Q^O,59OO!ITQ^O'#H^OOQU'#H_'#H_OOQU'#H`'#H`O`Q^O,5=vO!IkQWO,5=vO`Q^O,5=|O`Q^O,5>OO!IpQWO,5>QO`Q^O,5>SO!IuQWO,5>VO!IzQ^O,5>]OOQU,5>c,5>cO%[Q^O,5>cO9kQ07hO,5>eOOQU,5>g,5>gO!NUQWO,5>gOOQU,5>i,5>iO!NUQWO,5>iOOQU,5>k,5>kO!NZQ`O'#D[O%[Q^O'#JmO!NxQ`O'#JmO# gQ`O'#DjO# xQ`O'#DjO#$ZQ^O'#DjO#$bQWO'#JlO#$jQWO,5:TO#$oQWO'#EpO#$}QWO'#JzO#%VQWO,5;ZO#%[Q`O'#DjO#%iQ`O'#EUOOQ07b,5:n,5:nO%[Q^O,5:nO#%pQWO,5:nO>pQWO,5;UO!@}Q`O,5;UO!AVQ7[O,5;UO:RQ7[O,5;UO#%xQWO,5@XO#%}Q$ISO,5:rOOQO-E<`-E<`O#'TQ07pO,5:}OCnQ`O,5:qO#'_Q`O,5:qOCnQ`O,5:}O!@rQ07hO,5:qOOQ07`'#Ef'#EfOOQO,5:},5:}O%[Q^O,5:}O#'lQ07hO,5:}O#'wQ07hO,5:}O!@}Q`O,5:qOOQO,5;T,5;TO#(VQ07hO,5:}POOO'#IV'#IVP#(kO!0LbO,58{POOO,58{,58{OOOO-E<V-E<VOOQ07b1G.o1G.oOOOO-E<W-E<WO#(vQpO,59zOOOO-E<Y-E<YOOQ07b1G/d1G/dO#({QrO,5>wO+}Q^O,5>wOOQO,5>},5>}O#)VQ^O'#I]OOQO-E<Z-E<ZO#)dQWO,5@VO#)lQrO,5@VO#)sQWO,5@dOOQ07b1G/j1G/jO%[Q^O,5@eO#){QWO'#IcOOQO-E<a-E<aO#)sQWO,5@dOOQ07`1G0t1G0tOOQ07f1G/u1G/uOOQ07f1G0X1G0XO%[Q^O,5@bO#*aQ07hO,5@bO#*rQ07hO,5@bO#*yQWO,5@aO9ZQWO,5@aO#+RQWO,5@aO#+aQWO'#IfO#*yQWO,5@aOOQ07`1G0s1G0sO!*OQ`O,5:tO!*ZQ`O,5:tOOQO,5:v,5:vO#,RQWO,5:vO#,ZQ7[O1G2sO9aQWO1G2sOOQ07b1G0q1G0qO#,iQ08SO1G0qO#-nQ08QO,5;ROOQ07b'#GR'#GRO#.[Q08SO'#JdO!$aQ^O1G0qO#0dQ7[O'#JnO#0nQWO,5:_O#0sQrO'#JoO%[Q^O'#JoO#0}QWO,5:dOOQ07b'#D['#D[OOQ07b1G0z1G0zO%[Q^O1G0zOOQ07b1G1d1G1dO#1SQWO1G0zO#3kQ08SO1G0{O#3rQ08SO1G0{O#6]Q08SO1G0{O#6dQ08SO1G0{O#8nQ08SO1G0{O#9UQ08SO1G0{O#<OQ08SO1G0{O#<VQ08SO1G0{O#>jQ08SO1G0{O#>wQ08SO1G0{O#@uQ08SO1G0{O#CuQ(CYO'#ChO#EsQ(CYO1G1^O#EzQ(CYO'#JjO!,lQWO1G1dO#F[Q08SO,5?TOOQ07`-E<g-E<gO#GOQ08SO1G0{OOQ07b1G0{1G0{O#IZQ08SO1G1aO#I}Q&jO,5<TO#JVQ&jO,5<UO#J_Q&jO'#FlO#JvQWO'#FkOOQO'#KO'#KOOOQO'#Ig'#IgO#J{Q&jO1G1kOOQ07b1G1k1G1kOOOS1G1v1G1vO#K^Q(CYO'#JiO#KhQWO,5<_O!*fQ^O,5<_OOOS-E<f-E<fOOQ07b1G1i1G1iO#KmQ`O'#J}OOQ07b,5<a,5<aO#KuQ`O,5<aOOQ07b,59e,59eO!&dQ7[O'#DPOOOO'#IZ'#IZO#KzO?MpO,59iOOQ07b,59i,59iO%[Q^O1G1|O!6[QWO'#IkO#LVQ7[O,5<uOOQ07b,5<r,5<rO!(SQ7[O'#InO#LuQ7[O,5=RO!(SQ7[O'#IpO#MhQ7[O,5=TO!&dQ7[O,5=VOOQO1G2O1G2OO#MrQpO'#CqO#NVQpO,5<nO#N^QWO'#KRO9aQWO'#KRO#NlQWO,5<pO!(SQ7[O,5<oO#NqQWO'#GUO#N|QWO,5<oO$ RQpO'#GRO$ `QpO'#KSO$ jQWO'#KSO!&dQ7[O'#KSO$ oQWO,5<sO$ tQ`O'#G^O!4eQ`O'#G^O$!VQWO'#G`O$![QWO'#GbO!3fQWO'#GeO$!aQ07hO'#ImO$!lQ`O,5<wOOQ07f,5<w,5<wO$!sQ`O'#G^O$#RQ`O'#G_O$#ZQ`O'#G_O$#`Q7[O,5=RO$#pQ7[O,5=TOOQ07b,5=W,5=WO!(SQ7[O,5?}O!(SQ7[O,5?}O$$QQWO'#IrO$$]QWO,5?|O$$eQWO,59`O$%UQ7[O,59qOOQ07b,59q,59qO$%wQ7[O,5<fO$&jQ7[O,5<hO@bQWO,5<jOOQ07b,5<k,5<kO$&tQWO,5<qO$&yQ7[O,5<vO$'ZQWO'#JuO!$aQ^O1G1}O$'`QWO1G1}O9ZQWO'#JxO9ZQWO'#EpO%[Q^O'#EpO9ZQWO'#ItO$'eQ07hO,5@rOOQU1G2w1G2wOOQU1G4X1G4XOOQ07b1G/w1G/wO!,iQWO1G/wO$)jQ08SO1G0TOOQU1G2s1G2sO!&dQ7[O1G2sO%[Q^O1G2sO#,^QWO1G2sO$+nQ7[O'#EgOOQ07`,5?{,5?{O$+xQ07hO,5?{OOQU1G.t1G.tO!@rQ07hO1G.tO!@}Q`O1G.tO!AVQ7[O1G.tO$,ZQWO1G0qO$,`QWO'#ChO$,kQWO'#K[O$,sQWO,5=uO$,xQWO'#K[O$,}QWO'#K[O$-]QWO'#IzO$-kQWO,5@uO$-sQrO1G1fOOQ07b1G1h1G1hO9aQWO1G3`O@bQWO1G3`O$-zQWO1G3`O$.PQWO1G3`OOQU1G3`1G3`O!CTQWO1G3OO!&dQ7[O1G2{O$.UQWO1G2{OOQU1G2|1G2|O!&dQ7[O1G2|O$.ZQWO1G2|O$.cQ`O'#GzOOQU1G3O1G3OO!4eQ`O'#IvO!CYQpO1G3ROOQU1G3R1G3ROOQU,5=l,5=lO$.kQ7[O,5=nO9aQWO,5=nO$![QWO,5=pO9UQWO,5=pO!@}Q`O,5=pO!AVQ7[O,5=pO:RQ7[O,5=pO$.yQWO'#KYO$/UQWO,5=qOOQU1G.j1G.jO$/ZQ07hO1G.jO@bQWO1G.jO$/fQWO1G.jO9kQ07hO1G.jO$1kQrO,5@wO$1{QWO,5@wO9ZQWO,5@wO$2WQ^O,5=xO$2_QWO,5=xOOQU1G3b1G3bO`Q^O1G3bOOQU1G3h1G3hOOQU1G3j1G3jO>kQWO1G3lO$2dQ^O1G3nO$6hQ^O'#HmOOQU1G3q1G3qO$6uQWO'#HsO>pQWO'#HuOOQU1G3w1G3wO$6}Q^O1G3wO9kQ07hO1G3}OOQU1G4P1G4POOQ07`'#GY'#GYO9kQ07hO1G4RO9kQ07hO1G4TO$;UQWO,5@XO!*fQ^O,5;[O9ZQWO,5;[O>pQWO,5:UO!*fQ^O,5:UO!@}Q`O,5:UO$;ZQ(CYO,5:UOOQO,5;[,5;[O$;eQ`O'#I^O$;{QWO,5@WOOQ07b1G/o1G/oO$<TQ`O'#IdO$<_QWO,5@fOOQ07`1G0u1G0uO# xQ`O,5:UOOQO'#Ia'#IaO$<gQ`O,5:pOOQ07f,5:p,5:pO#%sQWO1G0YOOQ07b1G0Y1G0YO%[Q^O1G0YOOQ07b1G0p1G0pO>pQWO1G0pO!@}Q`O1G0pO!AVQ7[O1G0pOOQ07`1G5s1G5sO!@rQ07hO1G0]OOQO1G0i1G0iO%[Q^O1G0iO$<nQ07hO1G0iO$<yQ07hO1G0iO!@}Q`O1G0]OCnQ`O1G0]O$=XQ07hO1G0iOOQO1G0]1G0]O$=mQ08SO1G0iPOOO-E<T-E<TPOOO1G.g1G.gOOOO1G/f1G/fO$=wQpO,5<eO$>PQrO1G4cOOQO1G4i1G4iO%[Q^O,5>wO$>ZQWO1G5qO$>cQWO1G6OO$>kQrO1G6PO9ZQWO,5>}O$>uQ08SO1G5|O%[Q^O1G5|O$?VQ07hO1G5|O$?hQWO1G5{O$?hQWO1G5{O9ZQWO1G5{O$?pQWO,5?QO9ZQWO,5?QOOQO,5?Q,5?QO$@UQWO,5?QO$'ZQWO,5?QOOQO-E<d-E<dOOQO1G0`1G0`OOQO1G0b1G0bO!,lQWO1G0bOOQU7+(_7+(_O!&dQ7[O7+(_O%[Q^O7+(_O$@dQWO7+(_O$@oQ7[O7+(_O$@}Q08SO,5=RO$CYQ08SO,5=TO$EeQ08SO,5=RO$GvQ08SO,5=TO$JXQ08SO,59qO$LaQ08SO,5<fO$NlQ08SO,5<hO%!wQ08SO,5<vOOQ07b7+&]7+&]O%%YQ08SO7+&]O%%|Q7[O'#I_O%&WQWO,5@YOOQ07b1G/y1G/yO%&`Q^O'#I`O%&mQWO,5@ZO%&uQrO,5@ZOOQ07b1G0O1G0OO%'PQWO7+&fOOQ07b7+&f7+&fO%'UQ(CYO,5:eO%[Q^O7+&xO%'`Q(CYO,5:]O%'mQ(CYO,5:iO%'wQ(CYO,5:kOOQ07b7+'O7+'OOOQO1G1o1G1oOOQO1G1p1G1pO%(RQtO,5<WO!*fQ^O,5<VOOQO-E<e-E<eOOQ07b7+'V7+'VOOOS7+'b7+'bOOOS1G1y1G1yO%(^QWO1G1yOOQ07b1G1{1G1{O%(cQpO,59kOOOO-E<X-E<XOOQ07b1G/T1G/TO%(jQ08SO7+'hOOQ07b,5?V,5?VO%)^QpO,5?VOOQ07b1G2a1G2aP!&dQ7[O'#IkPOQ07b-E<i-E<iO%)|Q7[O,5?YOOQ07b-E<l-E<lO%*oQ7[O,5?[OOQ07b-E<n-E<nO%*yQpO1G2qOOQ07b1G2Y1G2YO%+QQWO'#IjO%+`QWO,5@mO%+`QWO,5@mO%+hQWO,5@mO%+sQWO,5@mOOQO1G2[1G2[O%,RQ7[O1G2ZO!(SQ7[O1G2ZO%,cQ!LQO'#IlO%,sQWO,5@nO!&dQ7[O,5@nO%,{QpO,5@nOOQ07b1G2_1G2_OOQ07`,5<x,5<xOOQ07`,5<y,5<yO$'ZQWO,5<yOC_QWO,5<yO!@}Q`O,5<xOOQO'#Ga'#GaO%-VQWO,5<zOOQ07`,5<|,5<|O$'ZQWO,5=POOQO,5?X,5?XOOQO-E<k-E<kOOQ07f1G2c1G2cO!4eQ`O,5<xO%-_QWO,5<yO$!VQWO,5<zO!4eQ`O,5<yO!(SQ7[O'#InO%.RQ7[O1G2mO!(SQ7[O'#IpO%.tQ7[O1G2oO%/OQ7[O1G5iO%/YQ7[O1G5iOOQO,5?^,5?^OOQO-E<p-E<pOOQO1G.z1G.zO!7{Q`O,59sO%[Q^O,59sO%/gQWO1G2UO!(SQ7[O1G2]O%/lQ08SO7+'iOOQ07b7+'i7+'iO!$aQ^O7+'iO%0`QWO,5;[OOQ07`,5?`,5?`OOQ07`-E<r-E<rOOQ07b7+%c7+%cO%0eQpO'#KTO#%sQWO7+(_O%0oQrO7+(_O$@gQWO7+(_O%0vQ08QO'#ChO%1ZQ08QO,5<}O%1{QWO,5<}OOQ07`1G5g1G5gOOQU7+$`7+$`O!@rQ07hO7+$`O!@}Q`O7+$`O!$aQ^O7+&]O%2QQWO'#IyO%2iQWO,5@vOOQO1G3a1G3aO9aQWO,5@vO%2iQWO,5@vO%2qQWO,5@vOOQO,5?f,5?fOOQO-E<x-E<xOOQ07b7+'Q7+'QO%2vQWO7+(zO9kQ07hO7+(zO9aQWO7+(zO@bQWO7+(zOOQU7+(j7+(jO%2{Q08QO7+(gO!&dQ7[O7+(gO%3VQpO7+(hOOQU7+(h7+(hO!&dQ7[O7+(hO%3^QWO'#KXO%3iQWO,5=fOOQO,5?b,5?bOOQO-E<t-E<tOOQU7+(m7+(mO%4xQ`O'#HTOOQU1G3Y1G3YO!&dQ7[O1G3YO%[Q^O1G3YO%5PQWO1G3YO%5[Q7[O1G3YO9kQ07hO1G3[O$![QWO1G3[O9UQWO1G3[O!@}Q`O1G3[O!AVQ7[O1G3[O%5jQWO'#IxO%6OQWO,5@tO%6WQ`O,5@tOOQ07`1G3]1G3]OOQU7+$U7+$UO@bQWO7+$UO9kQ07hO7+$UO%6cQWO7+$UO%[Q^O1G6cO%[Q^O1G6dO%6hQ07hO1G6cO%6rQ^O1G3dO%6yQWO1G3dO%7OQ^O1G3dOOQU7+(|7+(|O9kQ07hO7+)WO`Q^O7+)YOOQU'#K_'#K_OOQU'#I{'#I{O%7VQ^O,5>XOOQU,5>X,5>XO%[Q^O'#HnO%7dQWO'#HpOOQU,5>_,5>_O9ZQWO,5>_OOQU,5>a,5>aOOQU7+)c7+)cOOQU7+)i7+)iOOQU7+)m7+)mOOQU7+)o7+)oO%7iQ`O1G5sO%7}Q(CYO1G0vO%8XQWO1G0vOOQO1G/p1G/pO%8dQ(CYO1G/pO>pQWO1G/pO!*fQ^O'#DjOOQO,5>x,5>xOOQO-E<[-E<[OOQO,5?O,5?OOOQO-E<b-E<bO!@}Q`O1G/pOOQO-E<_-E<_OOQ07f1G0[1G0[OOQ07b7+%t7+%tO#%sQWO7+%tOOQ07b7+&[7+&[O>pQWO7+&[O!@}Q`O7+&[OOQO7+%w7+%wO$=mQ08SO7+&TOOQO7+&T7+&TO%[Q^O7+&TO%8nQ07hO7+&TO!@rQ07hO7+%wO!@}Q`O7+%wO%8yQ07hO7+&TO%9XQ08SO7++hO%[Q^O7++hO%9iQWO7++gO%9iQWO7++gOOQO1G4l1G4lO9ZQWO1G4lO%9qQWO1G4lOOQO7+%|7+%|O#%sQWO<<KyO%0oQrO<<KyO%:PQWO<<KyOOQU<<Ky<<KyO!&dQ7[O<<KyO%[Q^O<<KyO%:XQWO<<KyO%:dQ08SO,5?YO%<oQ08SO,5?[O%>zQ08SO1G2ZO%A]Q08SO1G2mO%ChQ08SO1G2oO%EsQ7[O,5>yOOQO-E<]-E<]O%E}QrO,5>zO%[Q^O,5>zOOQO-E<^-E<^O%FXQWO1G5uOOQ07b<<JQ<<JQO%FaQ(CYO1G0qO%HkQ(CYO1G0{O%HrQ(CYO1G0{O%JvQ(CYO1G0{O%J}Q(CYO1G0{O%LrQ(CYO1G0{O%MYQ(CYO1G0{O& mQ(CYO1G0{O& tQ(CYO1G0{O&#rQ(CYO1G0{O&$PQ(CYO1G0{O&%}Q(CYO1G0{O&&bQ08SO<<JdO&'gQ(CYO1G0{O&)]Q(CYO'#JdO&+`Q(CYO1G1aO&+mQ(CYO1G0TO!*fQ^O'#FnOOQO'#KP'#KPOOQO1G1r1G1rO&+wQWO1G1qO&+|Q(CYO,5?TOOOS7+'e7+'eOOOO1G/V1G/VOOQ07b1G4q1G4qO!(SQ7[O7+(]O&,WQWO,5?UO9aQWO,5?UOOQO-E<h-E<hO&,fQWO1G6XO&,fQWO1G6XO&,nQWO1G6XO&,yQ7[O7+'uO&-ZQpO,5?WO&-eQWO,5?WO!&dQ7[O,5?WOOQO-E<j-E<jO&-jQpO1G6YO&-tQWO1G6YOOQ07`1G2e1G2eO$'ZQWO1G2eOOQ07`1G2d1G2dO&-|QWO1G2fO!&dQ7[O1G2fOOQ07`1G2k1G2kO!@}Q`O1G2dOC_QWO1G2eO&.RQWO1G2fO&.ZQWO1G2eO&.}Q7[O,5?YOOQ07b-E<m-E<mO&/pQ7[O,5?[OOQ07b-E<o-E<oO!(SQ7[O7++TOOQ07b1G/_1G/_O&/zQWO1G/_OOQ07b7+'p7+'pO&0PQ7[O7+'wO&0aQ08SO<<KTOOQ07b<<KT<<KTO&1TQWO1G0vO!&dQ7[O'#IsO&1YQWO,5@oO!&dQ7[O1G2iOOQU<<Gz<<GzO!@rQ07hO<<GzO&1bQ08SO<<IwOOQ07b<<Iw<<IwOOQO,5?e,5?eO&2UQWO,5?eO&2ZQWO,5?eOOQO-E<w-E<wO&2iQWO1G6bO&2iQWO1G6bO9aQWO1G6bO@bQWO<<LfOOQU<<Lf<<LfO&2qQWO<<LfO9kQ07hO<<LfOOQU<<LR<<LRO%2{Q08QO<<LROOQU<<LS<<LSO%3VQpO<<LSO&2vQ`O'#IuO&3RQWO,5@sO!*fQ^O,5@sOOQU1G3Q1G3QO&3ZQ^O'#JmOOQO'#Iw'#IwO9kQ07hO'#IwO&3eQ`O,5=oOOQU,5=o,5=oO&3lQ`O'#EcO&4QQWO7+(tO&4VQWO7+(tOOQU7+(t7+(tO!&dQ7[O7+(tO%[Q^O7+(tO&4_QWO7+(tOOQU7+(v7+(vO9kQ07hO7+(vO$![QWO7+(vO9UQWO7+(vO!@}Q`O7+(vO&4jQWO,5?dOOQO-E<v-E<vOOQO'#HW'#HWO&4uQWO1G6`O9kQ07hO<<GpOOQU<<Gp<<GpO@bQWO<<GpO&4}QWO7++}O&5SQWO7+,OO%[Q^O7++}O%[Q^O7+,OOOQU7+)O7+)OO&5XQWO7+)OO&5^Q^O7+)OO&5eQWO7+)OOOQU<<Lr<<LrOOQU<<Lt<<LtOOQU-E<y-E<yOOQU1G3s1G3sO&5jQWO,5>YOOQU,5>[,5>[O&5oQWO1G3yO9ZQWO7+&bO!*fQ^O7+&bOOQO7+%[7+%[O&5tQ(CYO1G6PO>pQWO7+%[OOQ07b<<I`<<I`OOQ07b<<Iv<<IvO>pQWO<<IvOOQO<<Io<<IoO$=mQ08SO<<IoO%[Q^O<<IoOOQO<<Ic<<IcO!@rQ07hO<<IcO&6OQ07hO<<IoO&6ZQ08SO<= SO&6kQWO<= ROOQO7+*W7+*WO9ZQWO7+*WOOQUANAeANAeO&6sQWOANAeO!&dQ7[OANAeO#%sQWOANAeO%0oQrOANAeO%[Q^OANAeO&6{Q08SO7+'uO&9^Q08SO,5?YO&;iQ08SO,5?[O&=tQ08SO7+'wO&@VQrO1G4fO&@aQ(CYO7+&]O&BeQ(CYO,5=RO&DlQ(CYO,5=TO&D|Q(CYO,5=RO&E^Q(CYO,5=TO&EnQ(CYO,59qO&GqQ(CYO,5<fO&ItQ(CYO,5<hO&KwQ(CYO,5<vO&MmQ(CYO7+'hO&MzQ(CYO7+'iO&NXQWO,5<YOOQO7+']7+']O&N^Q7[O<<KwOOQO1G4p1G4pO&NeQWO1G4pO&NpQWO1G4pO' OQWO7++sO' OQWO7++sO!&dQ7[O1G4rO' WQpO1G4rO' bQWO7++tOOQ07`7+(P7+(PO$'ZQWO7+(QO' jQpO7+(QOOQ07`7+(O7+(OO$'ZQWO7+(PO' qQWO7+(QO!&dQ7[O7+(QOC_QWO7+(PO' vQ7[O<<NoOOQ07b7+$y7+$yO'!QQpO,5?_OOQO-E<q-E<qO'![Q08QO7+(TOOQUAN=fAN=fO9aQWO1G5POOQO1G5P1G5PO'!lQWO1G5PO'!qQWO7++|O'!qQWO7++|O9kQ07hOANBQO@bQWOANBQOOQUANBQANBQOOQUANAmANAmOOQUANAnANAnO'!yQWO,5?aOOQO-E<s-E<sO'#UQ(CYO1G6_O'%fQrO'#ChOOQO,5?c,5?cOOQO-E<u-E<uOOQU1G3Z1G3ZO&3ZQ^O,5<zOOQU<<L`<<L`O!&dQ7[O<<L`O&4QQWO<<L`O'%pQWO<<L`O%[Q^O<<L`OOQU<<Lb<<LbO9kQ07hO<<LbO$![QWO<<LbO9UQWO<<LbO'%xQ`O1G5OO'&TQWO7++zOOQUAN=[AN=[O9kQ07hOAN=[OOQU<= i<= iOOQU<= j<= jO'&]QWO<= iO'&bQWO<= jOOQU<<Lj<<LjO'&gQWO<<LjO'&lQ^O<<LjOOQU1G3t1G3tO>pQWO7+)eO'&sQWO<<I|O''OQ(CYO<<I|OOQO<<Hv<<HvOOQ07bAN?bAN?bOOQOAN?ZAN?ZO$=mQ08SOAN?ZOOQOAN>}AN>}O%[Q^OAN?ZOOQO<<Mr<<MrOOQUG27PG27PO!&dQ7[OG27PO#%sQWOG27PO''YQWOG27PO%0oQrOG27PO''bQ(CYO<<JdO''oQ(CYO1G2ZO')eQ(CYO,5?YO'+hQ(CYO,5?[O'-kQ(CYO1G2mO'/nQ(CYO1G2oO'1qQ(CYO<<KTO'2OQ(CYO<<IwOOQO1G1t1G1tO!(SQ7[OANAcOOQO7+*[7+*[O'2]QWO7+*[O'2hQWO<= _O'2pQpO7+*^OOQ07`<<Kl<<KlO$'ZQWO<<KlOOQ07`<<Kk<<KkO'2zQpO<<KlO$'ZQWO<<KkOOQO7+*k7+*kO9aQWO7+*kO'3RQWO<= hOOQUG27lG27lO9kQ07hOG27lO!*fQ^O1G4{O'3ZQWO7++yO&4QQWOANAzOOQUANAzANAzO!&dQ7[OANAzO'3cQWOANAzOOQUANA|ANA|O9kQ07hOANA|O$![QWOANA|OOQO'#HX'#HXOOQO7+*j7+*jOOQUG22vG22vOOQUANETANETOOQUANEUANEUOOQUANBUANBUO'3kQWOANBUOOQU<<MP<<MPO!*fQ^OAN?hOOQOG24uG24uO$=mQ08SOG24uO#%sQWOLD,kOOQULD,kLD,kO!&dQ7[OLD,kO'3pQWOLD,kO'3xQ(CYO7+'uO'5nQ(CYO,5?YO'7qQ(CYO,5?[O'9tQ(CYO7+'wO';jQ7[OG26}OOQO<<Mv<<MvOOQ07`ANAWANAWO$'ZQWOANAWOOQ07`ANAVANAVOOQO<<NV<<NVOOQULD-WLD-WO';zQ(CYO7+*gOOQUG27fG27fO&4QQWOG27fO!&dQ7[OG27fOOQUG27hG27hO9kQ07hOG27hOOQUG27pG27pO'<UQ(CYOG25SOOQOLD*aLD*aOOQU!$(!V!$(!VO#%sQWO!$(!VO!&dQ7[O!$(!VO'<`Q08SOG26}OOQ07`G26rG26rOOQULD-QLD-QO&4QQWOLD-QOOQULD-SLD-SOOQU!)9Eq!)9EqO#%sQWO!)9EqOOQU!$(!l!$(!lOOQU!.K;]!.K;]O'>qQ(CYOG26}O!*fQ^O'#DyO1PQWO'#EWO'@gQrO'#JiO!*fQ^O'#DqO'@nQ^O'#D}O'@uQrO'#ChO'C]QrO'#ChO!*fQ^O'#EPO'CmQ^O,5;VO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O'#IiO'EpQWO,5<eO'ExQ7[O,5;aO'GcQ7[O,5;aO!*fQ^O,5;uO!&dQ7[O'#GgO'ExQ7[O'#GgO!&dQ7[O'#GiO'ExQ7[O'#GiO1SQWO'#DVO1SQWO'#DVO!&dQ7[O'#FzO'ExQ7[O'#FzO!&dQ7[O'#F|O'ExQ7[O'#F|O!&dQ7[O'#G[O'ExQ7[O'#G[O!*fQ^O,5:iO!*fQ^O,5@eO'CmQ^O1G0qO'GjQ(CYO'#ChO!*fQ^O1G1|O!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O,5<oO'ExQ7[O,5<oO'CmQ^O1G1}O!*fQ^O7+&xO!&dQ7[O1G2ZO'ExQ7[O1G2ZO!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O1G2]O'ExQ7[O1G2]O'CmQ^O7+'iO'CmQ^O7+&]O!&dQ7[OANAcO'ExQ7[OANAcO'GtQWO'#EkO'GyQWO'#EkO'HRQWO'#FZO'HWQWO'#EuO'H]QWO'#JyO'HhQWO'#JwO'HsQWO,5;VO'HxQ7[O,5<bO'IPQWO'#GTO'IUQWO'#GTO'IZQWO,5<cO'IcQWO,5;VO'IkQ(CYO1G1^O'IrQWO,5<oO'IwQWO,5<oO'I|QWO,5<qO'JRQWO,5<qO'JWQWO1G1}O'J]QWO1G0qO'JbQ7[O<<KwO'JiQ7[O<<KwO7hQ7[O'#FxO9UQWO'#FwOA]QWO'#EjO!*fQ^O,5;rO!3fQWO'#GTO!3fQWO'#GTO!3fQWO'#GVO!3fQWO'#GVO!(SQ7[O7+(]O!(SQ7[O7+(]O%*yQpO1G2qO%*yQpO1G2qO!&dQ7[O,5=VO!&dQ7[O,5=V",
  stateData: "'Km~O'tOS'uOSSOS'vRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!twO!wxO!{]O#s!PO$T|O%b}O%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO&P!WO&V!XO&X!YO&Z!ZO&]![O&`!]O&f!^O&l!_O&n!`O&p!aO&r!bO&t!cO'{SO'}TO(QUO(XVO(g[O(tiO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`!vOo!nO!P!oO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!wO#S!pO#T!pO#W!yO#X!yO'|!lO'}TO(QUO([!mO(g!sO~O'v!zO~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X'r[X(X[X(h[X(o[X(p[X~O!d$|X~P(qO^!|O'}#OO(O!|O(P#OO~O^#PO(P#OO(Q#OO(R#PO~Ot#RO!R#SO(Y#SO(Z#UO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{:hO'}TO(QUO(XVO(g[O(tiO~O!X#YO!Y#VO!V(_P!V(lP~P+}O!Z#bO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'}TO(QUO(XVO(g[O(tiO~Ol#lO!X#hO!{]O#e#kO#f#hO'{:iO!j(iP~P.iO!k#nO'{#mO~O!w#rO!{]O%b#sO~O#g#tO~O!d#uO#g#tO~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y$aO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`(]X'r(]X'p(]X!j(]X!V(]X![(]X%c(]X!d(]X~P1qO#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X![(^X%c(^X~O`(^X!i(^X'r(^X'p(^X!V(^X!j(^Xr(^X!d(^X~P4XO#[$eO~O$Y$gO$[$fO$c$lO~ORfO![$mO$f$nO$h$pO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{$rO'}TO(QUO(X$uO(o$}O(p%POf(UP~O!k%bO~O!P%eO![%fO'{%dO~O!d%jO~O`%kO'r%kO~O'|!lO~P%[O%h%rO~P%[Og%VO!k%bO'{%dO'|!lO~Od%yO!k%bO'{%dO~O#r$SO~O|&OO![%{O!k%}O%d&RO'{%dO'|!lO'}TO(QUO_(}P~O!w#rO~O%m&TO!P(yX![(yX'{(yX~O'{&UO~O!t&ZO#s!PO%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO~Oc&`Od&_O!w&]O%b&^O%u&[O~P;xOc&cOdyO![&bO!t&ZO!wxO!{]O#s!PO%b}O%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO~Oa&fO#[&iO%d&dO'|!lO~P<}O!k&jO!t&nO~O!k#nO~O![XO~O`%kO'q&vO'r%kO~O`%kO'q&yO'r%kO~O`%kO'q&{O'r%kO~O'p[X!V[Xr[X!j[X&T[X![[X%c[X!d[X~P(qO!_'YO!`'RO!a'RO'|!lO'}TO(QUO~Oo'PO!P'OO!X'SO([&}O!Z(`P!Z(nP~P@UOj']O!['ZO'{%dO~Od'bO!k%bO'{%dO~O|&OO!k%}O~Oo!nO!P!oO!{:dO#P!pO#Q!pO#S!pO#T!pO'|!lO'}TO(QUO([!mO(g!sO~O!_'hO!`'gO!a'gO#R!pO#W'iO#X'iO~PApO`%kOg%VO!d#uO!k%bO'r%kO(h'kO~O!o'oO#['mO~PCOOo!nO!P!oO'}TO(QUO([!mO(g!sO~O![XOo(eX!P(eX!_(eX!`(eX!a(eX!{(eX#P(eX#Q(eX#R(eX#S(eX#T(eX#W(eX#X(eX'|(eX'}(eX(Q(eX([(eX(g(eX~O!`'gO!a'gO'|!lO~PCnO'w'sO'x'sO'y'uO~O^!|O'}'wO(O!|O(P'wO~O^#PO(P'wO(Q'wO(R#PO~Ot#RO!R#SO(Y#SO(Z'{O~O!X'}O!V'PX!V'VX!Y'PX!Y'VX~P+}O!Y(PO!V(_X~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y(PO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O!V(_X~PGbO!V(UO~O!V(kX!Y(kX!d(kX!j(kX(h(kX~O#[(kX#g#`X!Z(kX~PIhO#[(VO!V(mX!Y(mX~O!Y(WO!V(lX~O!V(ZO~O#[$eO~PIhO!Z([O~P`O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!maZ!man!ma!Y!ma!h!ma!o!ma#j!ma#k!ma#l!ma#m!ma#n!ma#o!ma#p!ma#q!ma#r!ma#t!ma#v!ma#x!ma#y!ma(h!ma(o!ma(p!ma~O`!ma'r!ma'p!ma!V!ma!j!mar!ma![!ma%c!ma!d!ma~PKOO!j(]O~O!d#uO#[(^O(h'kO!Y(jX`(jX'r(jX~O!j(jX~PMnO!P%eO![%fO!{]O#e(cO#f(bO'{%dO~O!Y(dO!j(iX~O!j(fO~O!P%eO![%fO#f(bO'{%dO~OP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!i(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O!d#uO!j(^X~P! [O|(gO}(hO!i#wO!k#xO!{!za!P!za~O!w!za%b!za![!za#e!za#f!za'{!za~P!#`O!w(lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#g(rO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~Of(bP~P!(SO!X(vO!j(cP~P%[O([(xO(g[O~O!P(zO!k#xO([(xO(g[O~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O})]O!k#xO~O!Y$aO`$ma'r$ma'p$ma!j$ma!V$ma![$ma%c$ma!d$ma~O#s)aO~P!&dO|)dO!d)cO![$ZX$W$ZX$Y$ZX$[$ZX$c$ZX~O!d)cO![(qX$W(qX$Y(qX$[(qX$c(qX~O|)dO~P!.OO|)dO![(qX$W(qX$Y(qX$[(qX$c(qX~O![)fO$W)jO$Y)eO$[)eO$c)kO~O!X)nO~P!*fO$Y$gO$[$fO$c)rO~Oj$uX|$uX!P$uX!i$uX(o$uX(p$uX~OfiXf$uXjiX!YiX#[iX~P!/tOo)tO~Ot)uO(Y)vO(Z)xO~Oj*RO|)zO!P){O(o$}O(p%PO~Of)yO~P!0}Of*SO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~O!X*WO'{*TO!j(uP~P!1lO#g*YO~O!k*ZO~O!X*`O'{*]O!V(vP~P!1lOn*lO!P*dO!_*jO!`*cO!a*cO!k*ZO#W*kO%Y*fO'|!lO([!mO~O!Z*iO~P!3xO!i#wOj(WX|(WX!P(WX(o(WX(p(WX!Y(WX#[(WX~Of(WX#|(WX~P!4qOj*qO#[*pOf(VX!Y(VX~O!Y*rOf(UX~O'{&UOf(UP~O!k*yO~O'{(pO~Ol*}O!P%eO!X#hO![%fO!{]O#e#kO#f#hO'{%dO!j(iP~O!d#uO#g+OO~O!P%eO!X+QO!Y(WO![%fO'{%dO!V(lP~Oo'VO!P+SO!X+RO'}TO(QUO([(xO~O!Z(nP~P!7lO!Y+TO`(zX'r(zX~OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`!ea!Y!ea'r!ea'p!ea!V!ea!j!ear!ea![!ea%c!ea!d!ea~P!8dO|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qaZ!qan!qa!Y!qa!h!qa!o!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#t!qa#v!qa#x!qa#y!qa(h!qa(o!qa(p!qa~O`!qa'r!qa'p!qa!V!qa!j!qar!qa![!qa%c!qa!d!qa~P!:}O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!saZ!san!sa!Y!sa!h!sa!o!sa#j!sa#k!sa#l!sa#m!sa#n!sa#o!sa#p!sa#q!sa#r!sa#t!sa#v!sa#x!sa#y!sa(h!sa(o!sa(p!sa~O`!sa'r!sa'p!sa!V!sa!j!sar!sa![!sa%c!sa!d!sa~P!=hOg%VOj+^O!['ZO%c+]O~O!d+`O`(TX![(TX'r(TX!Y(TX~O`%kO![XO'r%kO~Og%VO!k%bO~Og%VO!k%bO'{%dO~O!d#uO#g(rO~Oa+kO%d+lO'{+hO'}TO(QUO!Z)OP~O!Y+mO_(}X~OZ+qO~O_+rO~O![%{O'{%dO'|!lO_(}P~Og%VO#[+wO~Og%VOj+zO![$|O~O![+|O~O|,OO![XO~O%h%rO~O!w,TO~Od,YO~Oa,ZO'{#mO'}TO(QUO!Z(|P~Od%yO~O%d!QO'{&UO~P<}OZ,`O_,_O~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!kZO!nYO!oYO!pYO!rvO!wxO!{]O%b}O'}TO(QUO(XVO(g[O(tiO~O![!eO!t!gO$T!kO'{!dO~P!DkO_,_O`%kO'r%kO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`,eO!twO#s!OO%f!OO%g!OO%h!OO~P!GTO!k&jO~O&V,kO~O![,mO~O&h,oO&j,pOP&eaQ&eaR&eaX&ea`&eac&ead&eal&ean&eao&eap&eav&eax&eaz&ea!P&ea!T&ea!U&ea![&ea!f&ea!k&ea!n&ea!o&ea!p&ea!r&ea!t&ea!w&ea!{&ea#s&ea$T&ea%b&ea%d&ea%f&ea%g&ea%h&ea%k&ea%m&ea%p&ea%q&ea%s&ea&P&ea&V&ea&X&ea&Z&ea&]&ea&`&ea&f&ea&l&ea&n&ea&p&ea&r&ea&t&ea'p&ea'{&ea'}&ea(Q&ea(X&ea(g&ea(t&ea!Z&ea&^&eaa&ea&c&ea~O'{,uO~Og!bX!Y!OX!Y!bX!Z!OX!Z!bX!d!OX!d!bX!k!bX#[!OX~O!d,zO#[,yOg(aX!Y#dX!Y(aX!Z#dX!Z(aX!d(aX!k(aX~Og%VO!d,|O!k%bO!Y!^X!Z!^X~Oo!nO!P!oO'}TO(QUO([!mO~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'}TO(QUO(XVO(g[O(t<YO~O'{;]O~P#!ZO!Y-QO!Z(`X~O!Z-SO~O!d,zO#[,yO!Y#dX!Z#dX~O!Y-TO!Z(nX~O!Z-VO~O!`-WO!a-WO'|!lO~P# xO!Z-ZO~P'_Oj-^O!['ZO~O!V-cO~Oo!za!_!za!`!za!a!za#P!za#Q!za#R!za#S!za#T!za#W!za#X!za'|!za'}!za(Q!za([!za(g!za~P!#`O!o-hO#[-fO~PCOO!`-jO!a-jO'|!lO~PCnO`%kO#[-fO'r%kO~O`%kO!d#uO#[-fO'r%kO~O`%kO!d#uO!o-hO#[-fO'r%kO(h'kO~O'w'sO'x'sO'y-oO~Or-pO~O!V'Pa!Y'Pa~P!8dO!X-tO!V'PX!Y'PX~P%[O!Y(PO!V(_a~O!V(_a~PGbO!Y(WO!V(la~O!P%eO!X-xO![%fO'{%dO!V'VX!Y'VX~O#[-zO!Y(ja!j(ja`(ja'r(ja~O!d#uO~P#*aO!Y(dO!j(ia~O!P%eO![%fO#f.OO'{%dO~Ol.TO!P%eO!X.QO![%fO!{]O#e.SO#f.QO'{%dO!Y'YX!j'YX~O}.XO!k#xO~Og%VOj.[O!['ZO%c.ZO~O`#_i!Y#_i'r#_i'p#_i!V#_i!j#_ir#_i![#_i%c#_i!d#_i~P!8dOj<fO|)zO!P){O(o$}O(p%PO~O#g#Za`#Za#[#Za'r#Za!Y#Za!j#Za![#Za!V#Za~P#-]O#g(WXP(WXZ(WX`(WXn(WX}(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX'r(WX(X(WX(h(WX!j(WX!V(WX'p(WXr(WX![(WX%c(WX!d(WX~P!4qO!Y.iOf(bX~P!0}Of.kO~O!Y.lO!j(cX~P!8dO!j.oO~O!V.qO~OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#ii`#iin#ii!Y#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#j#ii~P#1XO#j$OO~P#1XOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO(XVOZ#ii`#ii!Y#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~On#ii~P#3yOn$QO~P#3yOP$]On$QO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO(XVO`#ii!Y#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P#6kOZ$dO!h$SO#o$SO#p$SO#q$cO#r$SO~P#6kOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO(p#}O`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii(o#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v$VO~P#9lO#v#ii~P#9lOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v#ii(o#ii(p#ii~P#<^O#v$VO(o#|O(p#}O~P#<^OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO(XVO(o#|O(p#}O~O`#ii!Y#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#?UOP[XZ[Xn[X|[X}[X!P[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X!Y[X!Z[X~O#|[X~P#AoOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO#y:vO(XVO(h$ZO(o#|O(p#}O~O#|.sO~P#C|O#[:{O$O:{O#|(^X!Z(^X~P! [O`']a!Y']a'r']a'p']a!j']a!V']ar']a![']a%c']a!d']a~P!8dOP#iiZ#ii`#iin#ii}#ii!Y#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(X#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#-]O`#}i!Y#}i'r#}i'p#}i!V#}i!j#}ir#}i![#}i%c#}i!d#}i~P!8dO$Y.xO$[.xO~O$Y.yO$[.yO~O!d)cO#[.zO![$`X$W$`X$Y$`X$[$`X$c$`X~O!X.{O~O![)fO$W.}O$Y)eO$[)eO$c/OO~O!Y:wO!Z(]X~P#C|O!Z/PO~O!d)cO$c(qX~O$c/RO~Ot)uO(Y)vO(Z/UO~O!V/YO~P!&dO(o$}Oj%Za|%Za!P%Za(p%Za!Y%Za#[%Za~Of%Za#|%Za~P#L^O(p%POj%]a|%]a!P%]a(o%]a!Y%]a#[%]a~Of%]a#|%]a~P#MPO!YeX!deX!jeX!j$uX(heX~P!/tO!j/bO~P#-]O!Y/cO!d#uO(h'kO!j(uX~O!j/hO~O!X*WO'{%dO!j(uP~O#g/jO~O!V$uX!Y$uX!d$|X~P!/tO!Y/kO!V(vX~P#-]O!d/mO~O!V/oO~Og%VOn/sO!d#uO!k%bO(h'kO~O'{/uO~O!d+`O~O`%kO!Y/yO'r%kO~O!Z/{O~P!3xO!`/|O!a/|O'|!lO([!mO~O!P0OO([!mO~O#W0PO~Of%Za!Y%Za#[%Za#|%Za~P!0}Of%]a!Y%]a#[%]a#|%]a~P!0}O'{&UOf'fX!Y'fX~O!Y*rOf(Ua~Of0YO~O|0ZO}0ZO!P0[Ojya(oya(pya!Yya#[ya~Ofya#|ya~P$$jO|)zO!P){Oj$na(o$na(p$na!Y$na#[$na~Of$na#|$na~P$%`O|)zO!P){Oj$pa(o$pa(p$pa!Y$pa#[$pa~Of$pa#|$pa~P$&RO#g0^O~Of%Oa!Y%Oa#[%Oa#|%Oa~P!0}O!d#uO~O#g0aO~O!Y+TO`(za'r(za~O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qiZ!qin!qi!Y!qi!h!qi!o!qi#j!qi#k!qi#l!qi#m!qi#n!qi#o!qi#p!qi#q!qi#r!qi#t!qi#v!qi#x!qi#y!qi(h!qi(o!qi(p!qi~O`!qi'r!qi'p!qi!V!qi!j!qir!qi![!qi%c!qi!d!qi~P$'pOg%VOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~Ol0kO'{0jO~P$*ZO!d+`O`(Ta![(Ta'r(Ta!Y(Ta~O#g0qO~OZ[X!YeX!ZeX~O!Y0rO!Z)OX~O!Z0tO~OZ0uO~Oa0wO'{+hO'}TO(QUO~O![%{O'{%dO_'nX!Y'nX~O!Y+mO_(}a~O!j0zO~P!8dOZ0}O~O_1OO~O#[1RO~Oj1UO![$|O~O([(xO!Z({P~Og%VOj1_O![1[O%c1^O~OZ1iO!Y1gO!Z(|X~O!Z1jO~O_1lO`%kO'r%kO~O'{#mO'}TO(QUO~O#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O#r1oO&T1pO`(^X!i(^X~P$/qO#[$eO#r1oO&T1pO~O`1rO~P%[O`1tO~O&^1wOP&[iQ&[iR&[iX&[i`&[ic&[id&[il&[in&[io&[ip&[iv&[ix&[iz&[i!P&[i!T&[i!U&[i![&[i!f&[i!k&[i!n&[i!o&[i!p&[i!r&[i!t&[i!w&[i!{&[i#s&[i$T&[i%b&[i%d&[i%f&[i%g&[i%h&[i%k&[i%m&[i%p&[i%q&[i%s&[i&P&[i&V&[i&X&[i&Z&[i&]&[i&`&[i&f&[i&l&[i&n&[i&p&[i&r&[i&t&[i'p&[i'{&[i'}&[i(Q&[i(X&[i(g&[i(t&[i!Z&[ia&[i&c&[i~Oa1}O!Z1{O&c1|O~P`O![XO!k2PO~O&j,pOP&eiQ&eiR&eiX&ei`&eic&eid&eil&ein&eio&eip&eiv&eix&eiz&ei!P&ei!T&ei!U&ei![&ei!f&ei!k&ei!n&ei!o&ei!p&ei!r&ei!t&ei!w&ei!{&ei#s&ei$T&ei%b&ei%d&ei%f&ei%g&ei%h&ei%k&ei%m&ei%p&ei%q&ei%s&ei&P&ei&V&ei&X&ei&Z&ei&]&ei&`&ei&f&ei&l&ei&n&ei&p&ei&r&ei&t&ei'p&ei'{&ei'}&ei(Q&ei(X&ei(g&ei(t&ei!Z&ei&^&eia&ei&c&ei~O!V2VO~O!Y!^a!Z!^a~P#C|Oo!nO!P!oO!X2]O([!mO!Y'QX!Z'QX~P@UO!Y-QO!Z(`a~O!Y'WX!Z'WX~P!7lO!Y-TO!Z(na~O!Z2dO~P'_O`%kO#[2mO'r%kO~O`%kO!d#uO#[2mO'r%kO~O`%kO!d#uO!o2qO#[2mO'r%kO(h'kO~O`%kO'r%kO~P!8dO!Y$aOr$ma~O!V'Pi!Y'Pi~P!8dO!Y(PO!V(_i~O!Y(WO!V(li~O!V(mi!Y(mi~P!8dO!Y(ji!j(ji`(ji'r(ji~P!8dO#[2sO!Y(ji!j(ji`(ji'r(ji~O!Y(dO!j(ii~O!P%eO![%fO!{]O#e2xO#f2wO'{%dO~O!P%eO![%fO#f2wO'{%dO~Oj3PO!['ZO%c3OO~Og%VOj3PO!['ZO%c3OO~O#g%ZaP%ZaZ%Za`%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Zar%Za![%Za%c%Za!d%Za~P#L^O#g%]aP%]aZ%]a`%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]ar%]a![%]a%c%]a!d%]a~P#MPO#g%ZaP%ZaZ%Za`%Zan%Za}%Za!Y%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Za#[%Zar%Za![%Za%c%Za!d%Za~P#-]O#g%]aP%]aZ%]a`%]an%]a}%]a!Y%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]a#[%]ar%]a![%]a%c%]a!d%]a~P#-]O#gyaPyaZya`yanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya'rya(Xya(hya!jya!Vya'pyarya![ya%cya!dya~P$$jO#g$naP$naZ$na`$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na'r$na(X$na(h$na!j$na!V$na'p$nar$na![$na%c$na!d$na~P$%`O#g$paP$paZ$pa`$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa'r$pa(X$pa(h$pa!j$pa!V$pa'p$par$pa![$pa%c$pa!d$pa~P$&RO#g%OaP%OaZ%Oa`%Oan%Oa}%Oa!Y%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa'r%Oa(X%Oa(h%Oa!j%Oa!V%Oa'p%Oa#[%Oar%Oa![%Oa%c%Oa!d%Oa~P#-]O`#_q!Y#_q'r#_q'p#_q!V#_q!j#_qr#_q![#_q%c#_q!d#_q~P!8dOf'RX!Y'RX~P!(SO!Y.iOf(ba~O!X3ZO!Y'SX!j'SX~P%[O!Y.lO!j(ca~O!Y.lO!j(ca~P!8dO!V3^O~O#|!ma!Z!ma~PKOO#|!ea!Y!ea!Z!ea~P#C|O#|!qa!Z!qa~P!:}O#|!sa!Z!sa~P!=hORfO![3pO$a3qO~O!Z3uO~Or3vO~P#-]O`$jq!Y$jq'r$jq'p$jq!V$jq!j$jqr$jq![$jq%c$jq!d$jq~P!8dO!V3wO~P#-]O|)zO!P){O(p%POj'ba(o'ba!Y'ba#['ba~Of'ba#|'ba~P%)eO|)zO!P){Oj'da(o'da(p'da!Y'da#['da~Of'da#|'da~P%*WO(h$ZO~P#-]O!X3zO'{%dO!Y'^X!j'^X~O!Y/cO!j(ua~O!Y/cO!d#uO!j(ua~O!Y/cO!d#uO(h'kO!j(ua~Of$wi!Y$wi#[$wi#|$wi~P!0}O!X4SO'{*]O!V'`X!Y'`X~P!1lO!Y/kO!V(va~O!Y/kO!V(va~P#-]O!d#uO#r4[O~On4_O!d#uO(h'kO~O(o$}Oj%Zi|%Zi!P%Zi(p%Zi!Y%Zi#[%Zi~Of%Zi#|%Zi~P%-jO(p%POj%]i|%]i!P%]i(o%]i!Y%]i#[%]i~Of%]i#|%]i~P%.]Of(Vi!Y(Vi~P!0}O#[4fOf(Vi!Y(Vi~P!0}O!j4iO~O`$kq!Y$kq'r$kq'p$kq!V$kq!j$kqr$kq![$kq%c$kq!d$kq~P!8dO!V4mO~O!Y4nO![(wX~P#-]O!i#wO~P4XO`$uX![$uX%W[X'r$uX!Y$uX~P!/tO%W4pO`kXjkX|kX!PkX![kX'rkX(okX(pkX!YkX~O%W4pO~Oa4vO%d4wO'{+hO'}TO(QUO!Y'mX!Z'mX~O!Y0rO!Z)Oa~OZ4{O~O_4|O~O`%kO'r%kO~P#-]O![$|O~P#-]O!Y5UO#[5WO!Z({X~O!Z5XO~Oo!nO!P5YO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!pO#S!pO#T!pO#W5_O#X!yO'|!lO'}TO(QUO([!mO(g!sO~O!Z5^O~P%3nOj5dO![1[O%c5cO~Og%VOj5dO![1[O%c5cO~Oa5kO'{#mO'}TO(QUO!Y'lX!Z'lX~O!Y1gO!Z(|a~O'}TO(QUO([5mO~O_5qO~O#r5tO&T5uO~PMnO!j5vO~P%[O`5xO~O`5xO~P%[Oa1}O!Z5}O&c1|O~P`O!d6PO~O!d6ROg(ai!Y(ai!Z(ai!d(ai!k(ai~O!Y#di!Z#di~P#C|O#[6SO!Y#di!Z#di~O!Y!^i!Z!^i~P#C|O`%kO#[6]O'r%kO~O`%kO!d#uO#[6]O'r%kO~O!Y(jq!j(jq`(jq'r(jq~P!8dO!Y(dO!j(iq~O!P%eO![%fO#f6dO'{%dO~O!['ZO%c6gO~Oj6jO!['ZO%c6gO~O#g'baP'baZ'ba`'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba'r'ba(X'ba(h'ba!j'ba!V'ba'p'bar'ba!['ba%c'ba!d'ba~P%)eO#g'daP'daZ'da`'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da'r'da(X'da(h'da!j'da!V'da'p'dar'da!['da%c'da!d'da~P%*WO#g$wiP$wiZ$wi`$win$wi}$wi!Y$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi'r$wi(X$wi(h$wi!j$wi!V$wi'p$wi#[$wir$wi![$wi%c$wi!d$wi~P#-]O#g%ZiP%ZiZ%Zi`%Zin%Zi}%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi'r%Zi(X%Zi(h%Zi!j%Zi!V%Zi'p%Zir%Zi![%Zi%c%Zi!d%Zi~P%-jO#g%]iP%]iZ%]i`%]in%]i}%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i'r%]i(X%]i(h%]i!j%]i!V%]i'p%]ir%]i![%]i%c%]i!d%]i~P%.]Of'Ra!Y'Ra~P!0}O!Y'Sa!j'Sa~P!8dO!Y.lO!j(ci~O#|#_i!Y#_i!Z#_i~P#C|OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#iin#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~O#j#ii~P%FnO#j:lO~P%FnOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO(XVOZ#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~On#ii~P%HyOn:nO~P%HyOP$]On:nO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO(XVO#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P%KUOZ:zO!h:pO#o:pO#p:pO#q:yO#r:pO~P%KUOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO(p#}O#x#ii#y#ii#|#ii(h#ii(o#ii!Y#ii!Z#ii~O#v:sO~P%MpO#v#ii~P%MpOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO#x#ii#y#ii#|#ii(h#ii!Y#ii!Z#ii~O#v#ii(o#ii(p#ii~P& {O#v:sO(o#|O(p#}O~P& {OP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO(XVO(o#|O(p#}O~O#y#ii#|#ii(h#ii!Y#ii!Z#ii~P&$^O`#zy!Y#zy'r#zy'p#zy!V#zy!j#zyr#zy![#zy%c#zy!d#zy~P!8dOj<gO|)zO!P){O(o$}O(p%PO~OP#iiZ#iin#ii}#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(X#ii(h#ii!Y#ii!Z#ii~P&'UO!i#wOP(WXZ(WXj(WXn(WX|(WX}(WX!P(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX#|(WX(X(WX(h(WX(o(WX(p(WX!Y(WX!Z(WX~O#|#}i!Y#}i!Z#}i~P#C|O#|!qi!Z!qi~P$'pO!Z6|O~O!Y']a!Z']a~P#C|O!d#uO(h'kO!Y'^a!j'^a~O!Y/cO!j(ui~O!Y/cO!d#uO!j(ui~Of$wq!Y$wq#[$wq#|$wq~P!0}O!V'`a!Y'`a~P#-]O!d7TO~O!Y/kO!V(vi~P#-]O!Y/kO!V(vi~O!V7XO~O!d#uO#r7^O~On7_O!d#uO(h'kO~O|)zO!P){O(p%POj'ca(o'ca!Y'ca#['ca~Of'ca#|'ca~P&.fO|)zO!P){Oj'ea(o'ea(p'ea!Y'ea#['ea~Of'ea#|'ea~P&/XO!V7aO~Of$yq!Y$yq#[$yq#|$yq~P!0}O`$ky!Y$ky'r$ky'p$ky!V$ky!j$kyr$ky![$ky%c$ky!d$ky~P!8dO!d6RO~O!Y4nO![(wa~O`#_y!Y#_y'r#_y'p#_y!V#_y!j#_yr#_y![#_y%c#_y!d#_y~P!8dOZ7fO~Oa7hO'{+hO'}TO(QUO~O!Y0rO!Z)Oi~O_7lO~O([(xO!Y'iX!Z'iX~O!Y5UO!Z({a~OlkO'{7sO~P.iO!Z7vO~P%3nOo!nO!P7wO'}TO(QUO([!mO(g!sO~O![1[O~O![1[O%c7yO~Oj7|O![1[O%c7yO~OZ8RO!Y'la!Z'la~O!Y1gO!Z(|i~O!j8VO~O!j8WO~O!j8ZO~O!j8ZO~P%[O`8]O~O!d8^O~O!j8_O~O!Y(mi!Z(mi~P#C|O`%kO#[8gO'r%kO~O!Y(jy!j(jy`(jy'r(jy~P!8dO!Y(dO!j(iy~O!['ZO%c8jO~O#g$wqP$wqZ$wq`$wqn$wq}$wq!Y$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq'r$wq(X$wq(h$wq!j$wq!V$wq'p$wq#[$wqr$wq![$wq%c$wq!d$wq~P#-]O#g'caP'caZ'ca`'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca'r'ca(X'ca(h'ca!j'ca!V'ca'p'car'ca!['ca%c'ca!d'ca~P&.fO#g'eaP'eaZ'ea`'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea'r'ea(X'ea(h'ea!j'ea!V'ea'p'ear'ea!['ea%c'ea!d'ea~P&/XO#g$yqP$yqZ$yq`$yqn$yq}$yq!Y$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq'r$yq(X$yq(h$yq!j$yq!V$yq'p$yq#[$yqr$yq![$yq%c$yq!d$yq~P#-]O!Y'Si!j'Si~P!8dO#|#_q!Y#_q!Z#_q~P#C|O(o$}OP%ZaZ%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za#|%Za(X%Za(h%Za!Y%Za!Z%Za~Oj%Za|%Za!P%Za(p%Za~P&@nO(p%POP%]aZ%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a#|%]a(X%]a(h%]a!Y%]a!Z%]a~Oj%]a|%]a!P%]a(o%]a~P&BuOj<gO|)zO!P){O(p%PO~P&@nOj<gO|)zO!P){O(o$}O~P&BuO|0ZO}0ZO!P0[OPyaZyajyanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya#|ya(Xya(hya(oya(pya!Yya!Zya~O|)zO!P){OP$naZ$naj$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na#|$na(X$na(h$na(o$na(p$na!Y$na!Z$na~O|)zO!P){OP$paZ$paj$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa#|$pa(X$pa(h$pa(o$pa(p$pa!Y$pa!Z$pa~OP%OaZ%Oan%Oa}%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa#|%Oa(X%Oa(h%Oa!Y%Oa!Z%Oa~P&'UO#|$jq!Y$jq!Z$jq~P#C|O#|$kq!Y$kq!Z$kq~P#C|O!Z8vO~O#|8wO~P!0}O!d#uO!Y'^i!j'^i~O!d#uO(h'kO!Y'^i!j'^i~O!Y/cO!j(uq~O!V'`i!Y'`i~P#-]O!Y/kO!V(vq~O!V8}O~P#-]O!V8}O~Of(Vy!Y(Vy~P!0}O!Y'ga!['ga~P#-]O`%Vq![%Vq'r%Vq!Y%Vq~P#-]OZ9SO~O!Y0rO!Z)Oq~O#[9WO!Y'ia!Z'ia~O!Y5UO!Z({i~P#C|OP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!d%TX#r%TX~P'#`O![1[O%c9[O~O'}TO(QUO([9aO~O!Y1gO!Z(|q~O!j9dO~O!j9eO~O!j9fO~O!j9fO~P%[O#[9iO!Y#dy!Z#dy~O!Y#dy!Z#dy~P#C|O!['ZO%c9nO~O#|#zy!Y#zy!Z#zy~P#C|OP$wiZ$win$wi}$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi#|$wi(X$wi(h$wi!Y$wi!Z$wi~P&'UO|)zO!P){O(p%POP'baZ'baj'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba#|'ba(X'ba(h'ba(o'ba!Y'ba!Z'ba~O|)zO!P){OP'daZ'daj'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da#|'da(X'da(h'da(o'da(p'da!Y'da!Z'da~O(o$}OP%ZiZ%Zij%Zin%Zi|%Zi}%Zi!P%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi#|%Zi(X%Zi(h%Zi(p%Zi!Y%Zi!Z%Zi~O(p%POP%]iZ%]ij%]in%]i|%]i}%]i!P%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i#|%]i(X%]i(h%]i(o%]i!Y%]i!Z%]i~O#|$ky!Y$ky!Z$ky~P#C|O#|#_y!Y#_y!Z#_y~P#C|O!d#uO!Y'^q!j'^q~O!Y/cO!j(uy~O!V'`q!Y'`q~P#-]O!V9wO~P#-]O!Y0rO!Z)Oy~O!Y5UO!Z({q~O![1[O%c:OO~O!j:RO~O!['ZO%c:WO~OP$wqZ$wqn$wq}$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq#|$wq(X$wq(h$wq!Y$wq!Z$wq~P&'UO|)zO!P){O(p%POP'caZ'caj'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca#|'ca(X'ca(h'ca(o'ca!Y'ca!Z'ca~O|)zO!P){OP'eaZ'eaj'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea#|'ea(X'ea(h'ea(o'ea(p'ea!Y'ea!Z'ea~OP$yqZ$yqn$yq}$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq#|$yq(X$yq(h$yq!Y$yq!Z$yq~P&'UOf%_!Z!Y%_!Z#[%_!Z#|%_!Z~P!0}O!Y'iq!Z'iq~P#C|O!Y#d!Z!Z#d!Z~P#C|O#g%_!ZP%_!ZZ%_!Z`%_!Zn%_!Z}%_!Z!Y%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z'r%_!Z(X%_!Z(h%_!Z!j%_!Z!V%_!Z'p%_!Z#[%_!Zr%_!Z![%_!Z%c%_!Z!d%_!Z~P#-]OP%_!ZZ%_!Zn%_!Z}%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z#|%_!Z(X%_!Z(h%_!Z!Y%_!Z!Z%_!Z~P&'UOr(]X~P1qO'|!lO~P!*fO!VeX!YeX#[eX~P'#`OP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!h[X!i[X!k[X!o[X#[[X#[eX#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!deX!j[X!jeX(heX~P'ASOP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![XO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O!Y:wO!Z$ma~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;RO!P${O![$|O!f<aO!k$xO#f;XO$T%^O$o;TO$q;VO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#s)aO~P'ExO!Z[X!ZeX~P'ASO#g:kO~O!d#uO#g:kO~O#[:{O~O#r:pO~O#[;ZO!Y(mX!Z(mX~O#[:{O!Y(kX!Z(kX~O#g;[O~Of;^O~P!0}O#g;cO~O#g;dO~O!d#uO#g;eO~O!d#uO#g;[O~O#|;fO~P#C|O#g;gO~O#g;hO~O#g;mO~O#g;nO~O#g;oO~O#g;pO~O#|;qO~P!0}O#|;rO~P!0}O!i#P#Q#S#T#W#e#f#q(t$o$q$t%W%b%c%d%k%m%p%q%s%u~'vS#k!U't'|#lo#j#mn|'u$Y'u'{$[([~",
  goto: "$2p)SPPPPP)TPP)WP)iP*x.|PPPP5pPP6WPP<S?gP?zP?zPPP?zPAxP?zP?zP?zPA|PPBRPBlPGdPPPGhPPPPGhJiPPPJoKjPGhPMxPPPP!!WGhPPPGhPGhP!$fGhP!'z!(|!)VP!)y!)}!)yPPPPP!-Y!(|PP!-v!.pP!1dGhGh!1i!4s!9Y!9Y!=OPPP!=VGhPPPPPPPPPPP!@dP!AqPPGh!CSPGhPGhGhGhGhPGh!DfP!GnP!JrP!Jv!KQ!KU!KUP!GkP!KY!KYP!N^P!NbGhGh!Nh##k?zP?zP?z?zP#$v?z?z#'O?z#)k?z#+m?z?z#,[#.f#.f#.j#.r#.f#.zP#.fP?z#/d?z#3R?z?z5pPPP#6vPPP#7a#7aP#7aP#7w#7aPP#7}P#7tP#7t#8b#7t#8|#9S5m)W#9V)WP#9^#9^#9^P)WP)WP)WP)WPP)WP#9d#9gP#9g)WP#9kP#9nP)WP)WP)WP)WP)WP)W)WPP#9t#9z#:V#:]#:c#:i#:o#:}#;T#;Z#;e#;k#;u#<U#<[#<|#=`#=f#=l#=z#>a#@O#@^#@d#Ax#BW#Cr#DQ#DW#D^#Dd#Dn#Dt#Dz#EU#Eh#EnPPPPPPPPPP#EtPPPPPPP#Fi#Ip#KP#KW#K`PPPP$!d$%Z$+r$+u$+x$,q$,t$,w$-O$-WPP$-^$-b$.Y$/X$/]$/qPP$/u$/{$0PP$0S$0W$0Z$1P$1h$2P$2T$2W$2Z$2a$2d$2h$2lR!{RoqOXst!Z#c%j&m&o&p&r,h,m1w1zY!uQ'Z-Y1[5]Q%pvQ%xyQ&P|Q&e!VS'R!e-QQ'a!iS'g!r!xS*c$|*hQ+f%yQ+s&RQ,X&_Q-W'YQ-b'bQ-j'hQ/|*jQ1f,YR;Y:g%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8gS#p]:d!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q*u%ZQ+k%{Q,Z&bQ,b&jQ.c;QQ0h+^Q0l+`Q0w+lQ1n,`Q2{.[Q4v0rQ5k1gQ6i3PQ6u;RQ7h4wR8m6j&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]t!nQ!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_$v$si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ&S|Q'P!eS'V%f-TQ+k%{Q,Z&bQ0]*yQ0w+lQ0|+rQ1m,_Q1n,`Q4v0rQ5P1OQ5k1gQ5n1iQ5o1lQ7h4wQ7k4|Q8U5qQ9V7lR9b8RrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR,]&f&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O']'m(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<[<][#[WZ#V#Y'S'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ%sxQ%wyS%||&RQ&Y!TQ'^!hQ'`!iQ(k#rS*V$x*ZS+e%x%yQ+i%{Q,S&]Q,W&_S-a'a'bQ.^(lQ/g*WQ0p+fQ0v+lQ0x+mQ0{+qQ1a,TS1e,X,YQ2i-bQ3y/cQ4u0rQ4y0uQ5O0}Q5j1fQ7Q3zQ7g4wQ7j4{Q9R7fR9y9S!O$zi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c!S%uy!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^Q+_%sQ+x&VQ+{&WQ,V&_Q.](kQ1`,SU1d,W,X,YQ3Q.^Q5e1aS5i1e1fQ8Q5j#W<^#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go<_:y:z:};P;T;V;X;`;b;d;h;j;l;n;rW%Ti%V*r<YS&V!Q&dQ&W!RQ&X!SR+v&T$w%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gT)v$u)wV*v%Z;Q;RU'V!e%f-TS(y#y#zQ+p&OS.V(g(hQ1V+|Q4g0ZR7p5U&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]$i$`c#X#d%n%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.t.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q'T!eR2^-Qv!nQ!e!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_S*b$|*hS/t*c*jQ/}*kQ1X,OQ4^/|R4a0PnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&t!^Q'q!wS(m#t:kQ+c%vQ,Q&YQ,R&[Q-_'_Q-l'jS.g(r;[S0`+O;eQ0n+dQ1Z,PQ2O,oQ2Q,pQ2Y,{Q2g-`Q2j-dS4l0a;oQ4q0oS4t0q;pQ6T2[Q6X2hQ6^2oQ7e4rQ8b6VQ8c6YQ8f6_R9h8_$d$_c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(j#o'dU*o%R(q3mS+Y%n.tQ2|0hQ6f2{Q8l6iR9o8m$d$^c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(i#o'dS({#z$_S+X%n.tS.W(h(jQ.w)]Q0e+YR2y.X&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S#p]:dQ&o!XQ&p!YQ&r![Q&s!]R1v,kQ'[!hQ+[%sQ-]'^S.Y(k+_Q2e-[W2}.].^0g0iQ6W2fU6e2z2|3QS8i6f6hS9m8k8lS:U9l9oQ:^:VR:a:_U!vQ'Z-YT5Z1[5]!Q_OXZ`st!V!Z#c#g%b%j&d&f&m&o&p&r(d,h,m.P1w1z]!pQ!r'Z-Y1[5]T#p]:d%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS(y#y#zS.V(g(h!s;v$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Y!tQ'Z-Y1[5]Q'f!rS'p!u!xS'r!y5_S-i'g'hQ-k'iR2p-jQ'o!tS(`#f1qS-h'f'rQ/f*VQ/r*bQ2q-kQ4O/gS4X/s/}Q7P3yS7[4_4aQ8y7QR9Q7_Q#vbQ'n!tS(_#f1qS(a#l*}Q+P%cQ+a%tQ+g%zU-g'f'o'rQ-{(`Q/e*VQ/q*bQ/w*eQ0m+bQ1b,US2n-h-kQ2v.TS3}/f/gS4W/r/}Q4Z/vQ4]/xQ5g1cQ6`2qQ7O3yQ7S4OS7W4X4aQ7]4`Q8O5hS8x7P7QQ8|7XQ9O7[Q9_8PQ9u8yQ9v8}Q9x9QQ:Q9`Q:Y9wQ;y;tQ<U;}R<V<OV!vQ'Z-Y%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS#vz!j!r;s$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;y<[%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gQ%cj!S%ty!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^S%zz!jQ+b%uQ,U&_W1c,V,W,X,YU5h1d1e1fS8P5i5jQ9`8Q!r;t$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q;}<ZR<O<[$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gY#aWZ#V#Y'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ,c&j!p;u$[$m)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;x'SS'W!e%fR2`-T%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8g!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q,b&jQ0h+^Q2{.[Q6i3PR8m6j!b$Uc#X%n'|(S(n(u)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!P:r)Z)l-O.t2W2Z3_3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!f$Wc#X%n'|(S(n(u)T)U)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!T:t)Z)l-O.t2W2Z3_3f3g3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!^$[c#X%n'|(S(n(u)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:eQ3x/az<])Z)l-O.t2W2Z3_3n3t6U6p6y6z7r8a8n8t8u9{:S<PQ<b<dR<c<e&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S$nh$oR3q.z'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$jf$pQ$hfS)e$k)iR)q$pT$if$pT)g$k)i'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$nh$oQ$qhR)p$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8g!s<Z$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]#clOPXZst!Z!`!o#R#c#n#{$m%j&f&i&j&m&o&p&r&v'O'](z)n+S+^,e,h,m-^.[.{0[1_1o1p1r1t1w1z1|3P3p5Y5d5t5u5x6j7w7|8]!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gQ*z%_Q/W)zo3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!O$yi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cQ*[$zS*e$|*hQ*{%`Q/x*f#W;{#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;|:y:z:};P;T;V;X;`;b;d;h;j;l;n;rQ<Q<^Q<R<_Q<S<`R<T<a!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;rnoOXst!Z#c%j&m&o&p&r,h,m1w1zQ*_${Q,v&yQ,w&{R4R/k$v%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ+y&WQ1T+{Q5S1SR7o5TT*g$|*hS*g$|*hT5[1[5]S/v*d5YT4`0O7wQ+a%tQ/w*eQ0m+bQ1b,UQ5g1cQ8O5hQ9_8PR:Q9`!O%Oi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cr)}$v(s*O*n*|/i0U0V3W4P4j6}7`9t;z<W<XS0Q*m0R#W:|#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn:}:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!^;_(o)`*U*^._.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<e`;`3l6q6t6x8o9p9s:bS;i.a3UT;j6s8r!O%Qi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cv*P$v(s*Q*m*|/]/i0U0V3W4P4b4j6}7`9t;z<W<XS0S*n0T#W;O#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;P:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!b;a(o)`*U*^.`.a.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<ed;b3l6r6s6x8o8p9p9q9s:bS;k.b3VT;l6t8srnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ&a!UR,e&jrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR&a!UQ+}&XR1P+vsnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ1],SS5b1`1aU7x5`5a5eS9Z7z7{S9|9Y9]Q:Z9}R:`:[Q&h!VR,^&dR5n1iS%||&RR0x+mQ&m!WR,h&nR,n&sT1x,m1zR,r&tQ,q&tR2R,rQ't!zR-n'tSsOtQ#cXT%ms#cQ!}TR'v!}Q#QUR'x#QQ)w$uR/T)wQ#TVR'z#TQ#WWU(Q#W(R-uQ(R#XR-u(SQ-R'TR2_-RQ.j(sR3X.jQ.m(uS3[.m3]R3].nQ-Y'ZR2c-YY!rQ'Z-Y1[5]R'e!rS#^W%eU(X#^(Y-vQ(Y#_R-v(TQ-U'WR2a-Ut`OXst!V!Z#c%j&d&f&m&o&p&r,h,m1w1zS#gZ%bU#q`#g.PR.P(dQ(e#iQ-|(aW.U(e-|2t6bQ2t-}R6b2uQ)i$kR.|)iQ$ohR)o$oQ$bcU)_$b-q:xQ-q:eR:x)lQ/d*VW3{/d3|7R8zU3|/e/f/gS7R3}4OR8z7S$X)|$v(o(s)`*U*^*m*n*w*x*|.a.b.d.e.f/S/X/]/_/a/i/n0U0V0f1Q1S3R3S3T3W3l4P4Q4U4b4d4j5R5T6k6l6m6n6s6t6v6w6x6}7U7Y7`7b7d8o8p8q8{9P9p9q9r9s9t:X:b;z<W<X<d<eQ/l*^U4T/l4V7VQ4V/nR7V4UQ*h$|R/z*hr*O$v(s*m*n*|/i0U0V3W4P4j6}7`9t;z<W<X!^._(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<eU/^*O._6qa6q3l6s6t6x8o9p9s:bQ0R*mQ3U.aU4c0R3U8rR8r6sv*Q$v(s*m*n*|/]/i0U0V3W4P4b4j6}7`9t;z<W<X!b.`(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<eU/`*Q.`6re6r3l6s6t6x8o8p9p9q9s:bQ0T*nQ3V.bU4e0T3V8sR8s6tQ*s%UR0X*sQ4o0fR7c4oQ+U%hR0d+UQ5V1VS7q5V9XR9X7rQ,P&YR1Y,PQ5]1[R7u5]Q1h,ZS5l1h8SR8S5nQ0s+iW4x0s4z7i9TQ4z0vQ7i4yR9T7jQ+n%|R0y+nQ1z,mR5|1zYrOXst#cQ&q!ZQ+W%jQ,g&mQ,i&oQ,j&pQ,l&rQ1u,hS1x,m1zR5{1wQ%lpQ&u!_Q&x!aQ&z!bQ&|!cQ'l!tQ+V%iQ+c%vQ+u&SQ,]&hQ,t&wW-e'f'n'o'rQ-l'jQ/y*gQ0n+dS1k,^,aQ2S,sQ2T,vQ2U,wQ2j-dW2l-g-h-k-mQ4q0oQ4}0|Q5Q1QQ5f1bQ5p1mQ5z1vU6Z2k2n2qQ6^2oQ7e4rQ7m5PQ7n5RQ7t5[Q7}5gQ8T5oS8d6[6`Q8f6_Q9U7kQ9^8OQ9c8UQ9j8eQ9z9VQ:P9_Q:T9kR:]:QQ%vyQ'_!iQ'j!tU+d%w%x%yQ,{'QU-`'`'a'bS-d'f'pQ/p*bS0o+e+fQ2[,}S2h-a-bQ2o-iQ4Y/tQ4r0pQ6V2bQ6Y2iQ6_2pR7Z4^S$wi<YR*t%VU%Ui%V<YR0W*rQ$viS(o#u+`Q(s#wS)`$c$dQ*U$xQ*^${Q*m%OQ*n%QQ*w%[Q*x%]Q*|%aQ.a:|Q.b;OQ.d;SQ.e;UQ.f;WQ/S)uS/X){/ZQ/])}Q/_*PQ/a*RQ/i*YQ/n*`Q0U*pQ0V*qh0f+].Z1^3O5c6g7y8j9[9n:O:WQ1Q+wQ1S+zQ3R;_Q3S;aQ3T;cQ3W.iS3l:y:zQ4P/jQ4Q/kQ4U/mQ4b0QQ4d0SQ4j0^Q5R1RQ5T1UQ6k;gQ6l;iQ6m;kQ6n;mQ6s:}Q6t;PQ6v;TQ6w;VQ6x;XQ6}3xQ7U4SQ7Y4[Q7`4fQ7b4nQ7d4pQ8o;dQ8p;`Q8q;bQ8{7TQ9P7^Q9p;hQ9q;jQ9r;lQ9s;nQ9t8wQ:X;qQ:b;rQ;z<YQ<W<bQ<X<cQ<d<fR<e<gnpOXst!Z#c%j&m&o&p&r,h,m1w1zQ!fPS#eZ#nQ&w!`U'c!o5Y7wQ'y#RQ(|#{Q)m$mS,a&f&iQ,f&jQ,s&vQ,x'OQ-[']Q.p(zQ/Q)nQ0b+SQ0i+^Q1s,eQ2f-^Q2|.[Q3s.{Q4h0[Q5a1_Q5r1oQ5s1pQ5w1rQ5y1tQ6O1|Q6f3PQ6{3pQ7{5dQ8X5tQ8Y5uQ8[5xQ8l6jQ9]7|R9g8]#WcOPXZst!Z!`!o#c#n#{%j&f&i&j&m&o&p&r&v'O'](z+S+^,e,h,m-^.[0[1_1o1p1r1t1w1z1|3P5Y5d5t5u5x6j7w7|8]Q#XWQ#dYQ%nuQ%ovS%qw!gS'|#V(PQ(S#YQ(n#tQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)X$YQ)Z$[Q)^$aQ)b$eW)l$m)n.{3pQ+Z%pQ+o%}S-O'S2]Q-m'mS-r'}-tQ-w(VQ-y(^Q.h(rQ.n(vQ.r:cQ.t:fQ.u:gQ.v:jQ/V)yQ0_+OQ2W,yQ2Z,|Q2k-fQ2r-zQ3Y.lQ3_:kQ3`:lQ3a:mQ3b:nQ3c:oQ3d:pQ3e:qQ3f:rQ3g:sQ3h:tQ3i:uQ3j:vQ3k.sQ3n:{Q3o;YQ3t:wQ4k0aQ4s0qQ6U;ZQ6[2mQ6a2sQ6o3ZQ6p;[Q6y;^Q6z;eQ7r5WQ8a6SQ8e6]Q8n;fQ8t;oQ8u;pQ9k8gQ9{9WQ:S9iQ:e#RR<P<]R#ZWR'U!eY!tQ'Z-Y1[5]S'Q!e-QQ'f!rS'p!u!xS'r!y5_S,}'R'YS-i'g'hQ-k'iQ2b-WR2p-jR(t#wR(w#xQ!fQT-X'Z-Y]!qQ!r'Z-Y1[5]Q#o]R'd:dT#jZ%bS#iZ%bS%hm,dU(a#g#h#kS-}(b(cQ.R(dQ0c+TQ2u.OU2v.P.Q.SS6c2w2xR8h6d`#]W#V#Y%e'}(W+Q-xr#fZm#g#h#k%b(b(c(d+T.O.P.Q.S2w2x6dQ1q,dQ2X,zQ6Q2PQ8`6RT;w'S+RT#`W%eS#_W%eS(O#V(WS(T#Y+QS-P'S+RT-s'}-xT'X!e%fQ$kfR)s$pT)h$k)iR3r.zT*X$x*ZR*a${Q0g+]Q2z.ZQ5`1^Q6h3OQ7z5cQ8k6gQ9Y7yQ9l8jQ9}9[Q:V9nQ:[:OR:_:WnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&g!VR,]&dtmOXst!U!V!Z#c%j&d&m&o&p&r,h,m1w1zR,d&jT%im,dR1W+|R,[&bQ&Q|R+t&RR+j%{T&k!W&nT&l!W&nT1y,m1z",
  nodeNames: " ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 371,
  context: jz,
  nodeProps: [
    ["isolate", -8, 4, 5, 13, 33, 35, 48, 50, 52, ""],
    ["group", -26, 8, 16, 18, 65, 201, 205, 209, 210, 212, 215, 218, 228, 230, 236, 238, 240, 242, 245, 251, 257, 259, 261, 263, 265, 267, 268, "Statement", -32, 12, 13, 28, 31, 32, 38, 48, 51, 52, 54, 59, 67, 75, 79, 81, 83, 84, 106, 107, 116, 117, 134, 137, 139, 140, 141, 142, 144, 145, 164, 165, 167, "Expression", -23, 27, 29, 33, 37, 39, 41, 168, 170, 172, 173, 175, 176, 177, 179, 180, 181, 183, 184, 185, 195, 197, 199, 200, "Type", -3, 87, 99, 105, "ClassItem"],
    ["openedBy", 22, "<", 34, "InterpolationStart", 53, "[", 57, "{", 72, "(", 157, "JSXStartCloseTag"],
    ["closedBy", 23, ">", 36, "InterpolationEnd", 47, "]", 58, "}", 73, ")", 162, "JSXEndTag"]
  ],
  propSources: [Vz],
  skippedNodes: [0, 4, 5, 271],
  repeatNodeCount: 37,
  tokenData: "$Fj(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Ns!`!a$#_!a!b$(l!b!c$,k!c!}Er!}#O$-u#O#P$/P#P#Q$4h#Q#R$5r#R#SEr#S#T$7P#T#o$8Z#o#p$<k#p#q$=a#q#r$>q#r#s$?}#s$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$I|Er$I|$I}$Dd$I}$JO$Dd$JO$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(n%d_$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$f&j(Op(R!b't(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST(P#S$f&j'u(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$f&j(Op(R!b'u(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$f&j!o$Ip(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|3l_'}$(n$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$f&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$a`$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$a``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$a`$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(R!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$a`(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k#%|:hh$f&j(Op(R!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$f&j(Op(R!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$f&j(R!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$f&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(R!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$f&j(OpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(OpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Op(R!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$f&j(g!L^(Op(R!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$f&j(Op(R!b$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$f&j(Op(R!b$Y#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$f&j(Op(R!b#l$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$f&j$O$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&COLva(p&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$f&j#x$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|! c_(Q$)`$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$f&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$a`$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(OpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$a`(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b(*Q!'t_!k(!b$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!jM|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$f&j(Op(R!b'|#)d#m$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$f&j(Op(R!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$f&j(Op(R!bn&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!Y&;l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$f&j(Op(R!b|'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!XMt$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$f&j(Op(R!b#k$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$f&j(R!b!USOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$f&j!USOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$f&j!USO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!USOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!US#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$f&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$f&j(R!b!USOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ(R!b!USOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb(R!b!USOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX(R!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$f&j(R!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$f&j(Op!USOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$f&j(Op!USOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ(Op!USOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb(Op!USOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX(OpOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$f&j(OpOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$f&j(Op(R!b!USOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d](Op(R!b!USOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe(Op(R!b!USOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ(Op(R!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$f&j(Op(R!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$f&j(Op(R!b'v(;d!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$f&j(Op(R!bS(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$f&j(R!bS(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$f&jS(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSS(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW(R!bS(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$f&j(OpS(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW(OpS(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY(Op(R!bS(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$f&j$O$Id(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$W#t$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!d$b$f&j#|%<f(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I__`l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^#Jk^g!*v!h'.r(Op(R!b(tSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Kg!Q!^*g!^!_#L]!_!`#M}!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KpX$h&j(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LfZ#n$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MX!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MbX$O$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NWX#o$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Oa#[%?x$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!T!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!`_#g$Ih$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#nafBf#o$Id$c#|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$s!`!a$%}!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%O_#o$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&Ya#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'_!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'j`#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(wc(h$Ip$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*S!P!^%Z!^!_*g!_!a%Z!a!b$+^!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*__}'#p$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+i`$f&j#y$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,v_!{!Ln$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.Q_!P(8n$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/UZ$f&jO!^$/w!^!_$0_!_#i$/w#i#j$0d#j#l$/w#l#m$2V#m#o$/w#o#p$0_#p;'S$/w;'S;=`$4b<%lO$/w(n$0OT^#S$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0dO^#S(n$0i[$f&jO!Q&c!Q![$1_![!^&c!_!c&c!c!i$1_!i#T&c#T#Z$1_#Z#o&c#o#p$3u#p;'S&c;'S;=`&w<%lO&c(n$1dZ$f&jO!Q&c!Q![$2V![!^&c!_!c&c!c!i$2V!i#T&c#T#Z$2V#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2[Z$f&jO!Q&c!Q![$2}![!^&c!_!c&c!c!i$2}!i#T&c#T#Z$2}#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3SZ$f&jO!Q&c!Q![$/w![!^&c!_!c&c!c!i$/w!i#T&c#T#Z$/w#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3xR!Q![$4R!c!i$4R#T#Z$4R#S$4US!Q![$4R!c!i$4R#T#Z$4R#q#r$0_(n$4eP;=`<%l$/w!2r$4s_!V!+S$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$5}`#v$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7[_$f&j(Op(R!b(X&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8jk$f&j(Op(R!b'{&;d$[#t([!LYOY%ZYZ&cZr%Zrs&}st%Ztu$8Zuw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$8Z![!^%Z!^!_*g!_!c%Z!c!}$8Z!}#O%Z#O#P&c#P#R%Z#R#S$8Z#S#T%Z#T#o$8Z#o#p*g#p$g%Z$g;'S$8Z;'S;=`$<e<%lO$8Z+d$:jk$f&j(Op(R!b$[#tOY%ZYZ&cZr%Zrs&}st%Ztu$:_uw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$:_![!^%Z!^!_*g!_!c%Z!c!}$:_!}#O%Z#O#P&c#P#R%Z#R#S$:_#S#T%Z#T#o$:_#o#p*g#p$g%Z$g;'S$:_;'S;=`$<_<%lO$:_+d$<bP;=`<%l$:_(CS$<hP;=`<%l$8Z!5p$<tX![!3l(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g&CO$=la(o&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+^#q;'S%Z;'S;=`+a<%lO%Z%#`$?O_!Z$I`r`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@Y_!pS$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Aj|$f&j(Op(R!b't(;d$Y#t'{&;d([!LYOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(CS$Duk$f&j(Op(R!b'u(;d$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [Wz, qz, Xz, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, Zz, new oh("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(Z~~", 141, 332), new oh("j~RQYZXz{^~^O'x~~aP!P!Qd~iO'y~~", 25, 315)],
  topRules: { Script: [0, 6], SingleExpression: [1, 269], SingleClassItem: [2, 270] },
  dialects: { jsx: 0, ts: 14614 },
  dynamicPrecedences: { 69: 1, 79: 1, 81: 1, 165: 1, 193: 1 },
  specialized: [{ term: 319, get: (t) => Yz[t] || -1 }, { term: 334, get: (t) => Uz[t] || -1 }, { term: 70, get: (t) => zz[t] || -1 }],
  tokenPrec: 14638
}), ek = [
  /* @__PURE__ */ rr("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ rr("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ rr("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ rr("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ rr("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ rr(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ rr("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ rr(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ rr(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ rr('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ rr('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], Hz = /* @__PURE__ */ ek.concat([
  /* @__PURE__ */ rr("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ rr("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ rr("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), cb = /* @__PURE__ */ new oA(), tk = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function ko(t) {
  return (e, r) => {
    let i = e.node.getChild("VariableDefinition");
    return i && r(i, t), !0;
  };
}
const Jz = ["FunctionDeclaration"], Kz = {
  FunctionDeclaration: /* @__PURE__ */ ko("function"),
  ClassDeclaration: /* @__PURE__ */ ko("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ ko("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ ko("type"),
  NamespaceDeclaration: /* @__PURE__ */ ko("namespace"),
  VariableDefinition(t, e) {
    t.matchContext(Jz) || e(t, "variable");
  },
  TypeDefinition(t, e) {
    e(t, "type");
  },
  __proto__: null
};
function rk(t, e) {
  let r = cb.get(e);
  if (r)
    return r;
  let i = [], n = !0;
  function s(a, o) {
    let u = t.sliceString(a.from, a.to);
    i.push({ label: u, type: o });
  }
  return e.cursor(Ke.IncludeAnonymous).iterate((a) => {
    if (n)
      n = !1;
    else if (a.name) {
      let o = Kz[a.name];
      if (o && o(a, s) || tk.has(a.name))
        return !1;
    } else if (a.to - a.from > 8192) {
      for (let o of rk(t, a.node))
        i.push(o);
      return !1;
    }
  }), cb.set(e, i), i;
}
const hb = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, ik = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function eG(t) {
  let e = ht(t.state).resolveInner(t.pos, -1);
  if (ik.indexOf(e.name) > -1)
    return null;
  let r = e.name == "VariableName" || e.to - e.from < 20 && hb.test(t.state.sliceDoc(e.from, e.to));
  if (!r && !t.explicit)
    return null;
  let i = [];
  for (let n = e; n; n = n.parent)
    tk.has(n.name) && (i = i.concat(rk(t.state.doc, n)));
  return {
    options: i,
    from: r ? e.from : t.pos,
    validFor: hb
  };
}
const $i = /* @__PURE__ */ Fs.define({
  name: "javascript",
  parser: /* @__PURE__ */ Gz.configure({
    props: [
      /* @__PURE__ */ Kl.add({
        IfStatement: /* @__PURE__ */ wa({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ wa({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: vq,
        SwitchBody: (t) => {
          let e = t.textAfter, r = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (r ? 0 : i ? 1 : 2) * t.unit;
        },
        Block: /* @__PURE__ */ Dq({ closing: "}" }),
        ArrowFunction: (t) => t.baseIndent + t.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ wa({ except: /^{/ }),
        JSXElement(t) {
          let e = /^\s*<\//.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        JSXEscape(t) {
          let e = /\s*\}/.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        }
      }),
      /* @__PURE__ */ eu.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": vy,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), nk = {
  test: (t) => /^JSX/.test(t.name),
  facet: /* @__PURE__ */ hA({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, sk = /* @__PURE__ */ $i.configure({ dialect: "ts" }, "typescript"), ak = /* @__PURE__ */ $i.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ xy.add((t) => t.isTop ? [nk] : void 0)]
}), ok = /* @__PURE__ */ $i.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ xy.add((t) => t.isTop ? [nk] : void 0)]
}, "typescript");
let lk = (t) => ({ label: t, type: "keyword" });
const uk = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(lk), tG = /* @__PURE__ */ uk.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(lk));
function ck(t = {}) {
  let e = t.jsx ? t.typescript ? ok : ak : t.typescript ? sk : $i, r = t.typescript ? Hz.concat(tG) : ek.concat(uk);
  return new op(e, [
    $i.data.of({
      autocomplete: LV(ik, yE(r))
    }),
    $i.data.of({
      autocomplete: eG
    }),
    t.jsx ? nG : []
  ]);
}
function rG(t) {
  for (; ; ) {
    if (t.name == "JSXOpenTag" || t.name == "JSXSelfClosingTag" || t.name == "JSXFragmentTag")
      return t;
    if (t.name == "JSXEscape" || !t.parent)
      return null;
    t = t.parent;
  }
}
function pb(t, e, r = t.length) {
  for (let i = e == null ? void 0 : e.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return t.sliceString(i.from, Math.min(i.to, r));
  return "";
}
const iG = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), nG = /* @__PURE__ */ oe.inputHandler.of((t, e, r, i, n) => {
  if ((iG ? t.composing : t.compositionStarted) || t.state.readOnly || e != r || i != ">" && i != "/" || !$i.isActiveAt(t.state, e, -1))
    return !1;
  let s = n(), { state: a } = s, o = a.changeByRange((u) => {
    var c;
    let { head: h } = u, d = ht(a).resolveInner(h - 1, -1), m;
    if (d.name == "JSXStartTag" && (d = d.parent), !(a.doc.sliceString(h - 1, h) != i || d.name == "JSXAttributeValue" && d.to > h)) {
      if (i == ">" && d.name == "JSXFragmentTag")
        return { range: u, changes: { from: h, insert: "</>" } };
      if (i == "/" && d.name == "JSXStartCloseTag") {
        let y = d.parent, O = y.parent;
        if (O && y.from == h - 2 && ((m = pb(a.doc, O.firstChild, h)) || ((c = O.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")) {
          let b = `${m}>`;
          return { range: U.cursor(h + b.length, -1), changes: { from: h, insert: b } };
        }
      } else if (i == ">") {
        let y = rG(d);
        if (y && !/^\/?>|^<\//.test(a.doc.sliceString(h, h + 2)) && (m = pb(a.doc, y, h)))
          return { range: u, changes: { from: h, insert: `</${m}>` } };
      }
    }
    return { range: u };
  });
  return o.changes.empty ? !1 : (t.dispatch([
    s,
    a.update(o, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
}), To = ["_blank", "_self", "_top", "_parent"], Bd = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], Id = ["get", "post", "put", "delete"], Nd = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], fr = ["true", "false"], ye = {}, sG = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: To,
      hreflang: null
    }
  },
  abbr: ye,
  address: ye,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: ye,
  aside: ye,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: ye,
  base: { attrs: { href: null, target: To } },
  bdi: ye,
  bdo: ye,
  blockquote: { attrs: { cite: null } },
  body: ye,
  br: ye,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: Nd,
      formmethod: Id,
      formnovalidate: ["novalidate"],
      formtarget: To,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: ye,
  center: ye,
  cite: ye,
  code: ye,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: ye,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: ye,
  div: ye,
  dl: ye,
  dt: ye,
  em: ye,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: ye,
  figure: ye,
  footer: ye,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Bd,
      autocomplete: ["on", "off"],
      enctype: Nd,
      method: Id,
      novalidate: ["novalidate"],
      target: To
    }
  },
  h1: ye,
  h2: ye,
  h3: ye,
  h4: ye,
  h5: ye,
  h6: ye,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: ye,
  hgroup: ye,
  hr: ye,
  html: {
    attrs: { manifest: null }
  },
  i: ye,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: Nd,
      formmethod: Id,
      formnovalidate: ["novalidate"],
      formtarget: To,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: ye,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: ye,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: ye,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Bd,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: ye,
  noscript: ye,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: ye,
  param: { attrs: { name: null, value: null } },
  pre: ye,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: ye,
  rt: ye,
  ruby: ye,
  samp: ye,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Bd
    }
  },
  section: ye,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: ye,
  source: { attrs: { src: null, type: null, media: null } },
  span: ye,
  strong: ye,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: ye,
  summary: ye,
  sup: ye,
  table: ye,
  tbody: ye,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: ye,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: ye,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: ye,
  time: { attrs: { datetime: null } },
  title: ye,
  tr: ye,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: ye,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: ye
}, hk = {
  accesskey: null,
  class: null,
  contenteditable: fr,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: fr,
  autocorrect: fr,
  autocapitalize: fr,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": fr,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": fr,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": fr,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": fr,
  "aria-hidden": fr,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": fr,
  "aria-multiselectable": fr,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": fr,
  "aria-relevant": null,
  "aria-required": fr,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, pk = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((t) => "on" + t);
for (let t of pk)
  hk[t] = null;
class hh {
  constructor(e, r) {
    this.tags = Object.assign(Object.assign({}, sG), e), this.globalAttrs = Object.assign(Object.assign({}, hk), r), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
hh.default = /* @__PURE__ */ new hh();
function ja(t, e, r = t.length) {
  if (!e)
    return "";
  let i = e.firstChild, n = i && i.getChild("TagName");
  return n ? t.sliceString(n.from, Math.min(n.to, r)) : "";
}
function Za(t, e = !1) {
  for (; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = !1;
      else
        return t;
  return null;
}
function dk(t, e, r) {
  let i = r.tags[ja(t, Za(e))];
  return (i == null ? void 0 : i.children) || r.allTags;
}
function My(t, e) {
  let r = [];
  for (let i = Za(e); i && !i.type.isTop; i = Za(i.parent)) {
    let n = ja(t, i);
    if (n && i.lastChild.name == "CloseTag")
      break;
    n && r.indexOf(n) < 0 && (e.name == "EndTag" || e.from >= i.firstChild.to) && r.push(n);
  }
  return r;
}
const fk = /^[:\-\.\w\u00b7-\uffff]*$/;
function db(t, e, r, i, n) {
  let s = /\s*>/.test(t.sliceDoc(n, n + 5)) ? "" : ">", a = Za(r, !0);
  return {
    from: i,
    to: n,
    options: dk(t.doc, a, e).map((o) => ({ label: o, type: "type" })).concat(My(t.doc, r).map((o, u) => ({
      label: "/" + o,
      apply: "/" + o + s,
      type: "type",
      boost: 99 - u
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function fb(t, e, r, i) {
  let n = /\s*>/.test(t.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: r,
    to: i,
    options: My(t.doc, e).map((s, a) => ({ label: s, apply: s + n, type: "type", boost: 99 - a })),
    validFor: fk
  };
}
function aG(t, e, r, i) {
  let n = [], s = 0;
  for (let a of dk(t.doc, r, e))
    n.push({ label: "<" + a, type: "type" });
  for (let a of My(t.doc, r))
    n.push({ label: "</" + a + ">", type: "type", boost: 99 - s++ });
  return { from: i, to: i, options: n, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function oG(t, e, r, i, n) {
  let s = Za(r), a = s ? e.tags[ja(t.doc, s)] : null, o = a && a.attrs ? Object.keys(a.attrs) : [], u = a && a.globalAttrs === !1 ? o : o.length ? o.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: i,
    to: n,
    options: u.map((c) => ({ label: c, type: "property" })),
    validFor: fk
  };
}
function lG(t, e, r, i, n) {
  var s;
  let a = (s = r.parent) === null || s === void 0 ? void 0 : s.getChild("AttributeName"), o = [], u;
  if (a) {
    let c = t.sliceDoc(a.from, a.to), h = e.globalAttrs[c];
    if (!h) {
      let d = Za(r), m = d ? e.tags[ja(t.doc, d)] : null;
      h = (m == null ? void 0 : m.attrs) && m.attrs[c];
    }
    if (h) {
      let d = t.sliceDoc(i, n).toLowerCase(), m = '"', y = '"';
      /^['"]/.test(d) ? (u = d[0] == '"' ? /^[^"]*$/ : /^[^']*$/, m = "", y = t.sliceDoc(n, n + 1) == d[0] ? "" : d[0], d = d.slice(1), i++) : u = /^[^\s<>='"]*$/;
      for (let O of h)
        o.push({ label: O, apply: m + O + y, type: "constant" });
    }
  }
  return { from: i, to: n, options: o, validFor: u };
}
function uG(t, e) {
  let { state: r, pos: i } = e, n = ht(r).resolveInner(i, -1), s = n.resolve(i);
  for (let a = i, o; s == n && (o = n.childBefore(a)); ) {
    let u = o.lastChild;
    if (!u || !u.type.isError || u.from < u.to)
      break;
    s = n = o, a = u.from;
  }
  return n.name == "TagName" ? n.parent && /CloseTag$/.test(n.parent.name) ? fb(r, n, n.from, i) : db(r, t, n, n.from, i) : n.name == "StartTag" ? db(r, t, n, i, i) : n.name == "StartCloseTag" || n.name == "IncompleteCloseTag" ? fb(r, n, i, i) : n.name == "OpenTag" || n.name == "SelfClosingTag" || n.name == "AttributeName" ? oG(r, t, n, n.name == "AttributeName" ? n.from : i, i) : n.name == "Is" || n.name == "AttributeValue" || n.name == "UnquotedAttributeValue" ? lG(r, t, n, n.name == "Is" ? i : n.from, i) : e.explicit && (s.name == "Element" || s.name == "Text" || s.name == "Document") ? aG(r, t, n, i) : null;
}
function cG(t) {
  let { extraTags: e, extraGlobalAttributes: r } = t, i = r || e ? new hh(e, r) : hh.default;
  return (n) => uG(i, n);
}
const hG = /* @__PURE__ */ $i.parser.configure({ top: "SingleExpression" }), mk = [
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript" || t.lang == "ts",
    parser: sk.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/babel" || t.type == "text/jsx",
    parser: ak.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript-jsx",
    parser: ok.parser
  },
  {
    tag: "script",
    attrs(t) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(t.type);
    },
    parser: hG
  },
  {
    tag: "script",
    attrs(t) {
      return !t.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t.type);
    },
    parser: $i.parser
  },
  {
    tag: "style",
    attrs(t) {
      return (!t.lang || t.lang == "css") && (!t.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t.type));
    },
    parser: ch.parser
  }
], gk = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ ch.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ pk.map((t) => ({ name: t, parser: $i.parser }))), yk = /* @__PURE__ */ Fs.define({
  name: "html",
  parser: /* @__PURE__ */ HU.configure({
    props: [
      /* @__PURE__ */ Kl.add({
        Element(t) {
          let e = /^(\s*)(<\/)?/.exec(t.textAfter);
          return t.node.to <= t.pos + e[0].length ? t.continue() : t.lineIndent(t.node.from) + (e[2] ? 0 : t.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        },
        Document(t) {
          if (t.pos + /\s*/.exec(t.textAfter)[0].length < t.node.to)
            return t.continue();
          let e = null, r;
          for (let i = t.node; ; ) {
            let n = i.lastChild;
            if (!n || n.name != "Element" || n.to != i.to)
              break;
            e = i = n;
          }
          return e && !((r = e.lastChild) && (r.name == "CloseTag" || r.name == "SelfClosingTag")) ? t.lineIndent(e.from) + t.unit : null;
        }
      }),
      /* @__PURE__ */ eu.add({
        Element(t) {
          let e = t.firstChild, r = t.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: r.name == "CloseTag" ? r.from : t.to };
        }
      }),
      /* @__PURE__ */ AA.add({
        "OpenTag CloseTag": (t) => t.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), vc = /* @__PURE__ */ yk.configure({
  wrap: /* @__PURE__ */ UE(mk, gk)
});
function pG(t = {}) {
  let e = "", r;
  t.matchClosingTags === !1 && (e = "noMatch"), t.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"), (t.nestedLanguages && t.nestedLanguages.length || t.nestedAttributes && t.nestedAttributes.length) && (r = UE((t.nestedLanguages || []).concat(mk), (t.nestedAttributes || []).concat(gk)));
  let i = r ? yk.configure({ wrap: r, dialect: e }) : e ? vc.configure({ dialect: e }) : vc;
  return new op(i, [
    vc.data.of({ autocomplete: cG(t) }),
    t.autoCloseTags !== !1 ? dG : [],
    ck().support,
    JE().support
  ]);
}
const mb = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), dG = /* @__PURE__ */ oe.inputHandler.of((t, e, r, i, n) => {
  if (t.composing || t.state.readOnly || e != r || i != ">" && i != "/" || !vc.isActiveAt(t.state, e, -1))
    return !1;
  let s = n(), { state: a } = s, o = a.changeByRange((u) => {
    var c, h, d;
    let m = a.doc.sliceString(u.from - 1, u.to) == i, { head: y } = u, O = ht(a).resolveInner(y - 1, -1), b;
    if ((O.name == "TagName" || O.name == "StartTag") && (O = O.parent), m && i == ">" && O.name == "OpenTag") {
      if (((h = (c = O.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || h === void 0 ? void 0 : h.name) != "CloseTag" && (b = ja(a.doc, O.parent, y)) && !mb.has(b)) {
        let v = y + (a.doc.sliceString(y, y + 1) === ">" ? 1 : 0), S = `</${b}>`;
        return { range: u, changes: { from: y, to: v, insert: S } };
      }
    } else if (m && i == "/" && O.name == "IncompleteCloseTag") {
      let v = O.parent;
      if (O.from == y - 2 && ((d = v.lastChild) === null || d === void 0 ? void 0 : d.name) != "CloseTag" && (b = ja(a.doc, v, y)) && !mb.has(b)) {
        let S = y + (a.doc.sliceString(y, y + 1) === ">" ? 1 : 0), x = `${b}>`;
        return {
          range: U.cursor(y + x.length, -1),
          changes: { from: y, to: S, insert: x }
        };
      }
    }
    return { range: u };
  });
  return o.changes.empty ? !1 : (t.dispatch([
    s,
    a.update(o, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), fG = Hl({
  String: _.string,
  Number: _.number,
  "True False": _.bool,
  PropertyName: _.propertyName,
  Null: _.null,
  ",": _.separator,
  "[ ]": _.squareBracket,
  "{ }": _.brace
}), mG = Bs.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: " JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [fG],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), gG = /* @__PURE__ */ Fs.define({
  name: "json",
  parser: /* @__PURE__ */ mG.configure({
    props: [
      /* @__PURE__ */ Kl.add({
        Object: /* @__PURE__ */ wa({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ wa({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ eu.add({
        "Object Array": vy
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function yG() {
  return new op(gG);
}
const OG = () => {
  const { config: t } = Er();
  return WT(t);
}, xG = {
  html: pG(),
  css: JE(),
  js: ck(),
  json: yG()
}, bG = () => {
  var c;
  const [t, e] = In("light"), {
    project: r,
    saveFile: i,
    config: { editableFileTypes: n }
  } = Er(), s = OG(), a = (c = Object.values(r.files).filter((h) => h.active)) == null ? void 0 : c[0], o = BT(
    (h) => {
      i(a.id, h);
    },
    [i, a]
  ), u = async () => {
    try {
      const h = await IR(a.contents, a.language);
      i(a.id, h);
    } catch (h) {
      console.log("FAILURE : ", h);
    }
  };
  return a ? bb(a.language, n) ? /* @__PURE__ */ z.jsxs("div", { className: "editor-container", children: [
    /* @__PURE__ */ z.jsx("button", { onClick: () => u(), children: "Format" }),
    /* @__PURE__ */ z.jsxs("select", { onChange: (h) => e(h.target.value), children: [
      /* @__PURE__ */ z.jsx("option", { value: "light", children: "light theme" }),
      /* @__PURE__ */ z.jsx("option", { value: "dark", children: "dark theme" })
    ] }),
    a && /* @__PURE__ */ z.jsx(
      NE,
      {
        value: a.contents,
        width: "100%",
        height: "100%",
        extensions: [xG[a.language]],
        onChange: o,
        theme: t
      }
    )
  ] }) : /* @__PURE__ */ z.jsxs("div", { children: [
    "Can only edit html, css, or javascript files. Cannot edit",
    " ",
    a.language,
    " files."
  ] }) : /* @__PURE__ */ z.jsx(s, {});
}, DG = () => {
  const { config: t } = Er(), e = t.EditorComponent || bG;
  return /* @__PURE__ */ z.jsxs("div", { className: "center-pane", children: [
    /* @__PURE__ */ z.jsx("div", { className: "center-nav", children: /* @__PURE__ */ z.jsx(UR, {}) }),
    /* @__PURE__ */ z.jsx("div", { className: "center-main", children: /* @__PURE__ */ z.jsx(e, {}) })
  ] });
}, vG = ({ file: t }) => {
  const e = Sm(null), {
    project: { files: r, folders: i }
  } = Er(), n = Ob(() => t ? t.contents.replace(
    new RegExp('<link rel="stylesheet" href="([^"]+)"\\s*/>', "g"),
    (a, o) => {
      const u = o.split("/"), c = u.pop(), h = Db(u, {
        folders: Object.values(i)
      }), d = Object.values(r).find(
        (m) => m.name === c && m.folderId === h
      );
      return `
          <style>
            ${d == null ? void 0 : d.contents}
          </style>
      `;
    }
  ) : "", [r, t]);
  return /* @__PURE__ */ z.jsx(z.Fragment, { children: t && /* @__PURE__ */ z.jsx(
    "iframe",
    {
      allow: "self",
      title: "Web Preview",
      ref: e,
      id: "preview",
      style: { width: "100%", height: "100%" },
      srcDoc: n
    }
  ) });
};
var Ok = { exports: {} };
(function(t, e) {
  (function(i, n) {
    t.exports = n();
  })(NT, function() {
    return (
      /******/
      function(r) {
        var i = {};
        function n(s) {
          if (i[s])
            return i[s].exports;
          var a = i[s] = {
            /******/
            i: s,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return r[s].call(a.exports, a, a.exports, n), a.l = !0, a.exports;
        }
        return n.m = r, n.c = i, n.i = function(s) {
          return s;
        }, n.d = function(s, a, o) {
          n.o(s, a) || Object.defineProperty(s, a, {
            /******/
            configurable: !1,
            /******/
            enumerable: !0,
            /******/
            get: o
            /******/
          });
        }, n.n = function(s) {
          var a = s && s.__esModule ? (
            /******/
            function() {
              return s.default;
            }
          ) : (
            /******/
            function() {
              return s;
            }
          );
          return n.d(a, "a", a), a;
        }, n.o = function(s, a) {
          return Object.prototype.hasOwnProperty.call(s, a);
        }, n.p = "", n(n.s = 3);
      }([
        /* 0 */
        /***/
        function(r, i, n) {
          Object.defineProperty(i, "__esModule", {
            value: !0
          });
          var s = Object.assign || function(v) {
            for (var S = 1; S < arguments.length; S++) {
              var x = arguments[S];
              for (var w in x)
                Object.prototype.hasOwnProperty.call(x, w) && (v[w] = x[w]);
            }
            return v;
          }, a = /* @__PURE__ */ function() {
            function v(S, x) {
              for (var w = 0; w < x.length; w++) {
                var k = x[w];
                k.enumerable = k.enumerable || !1, k.configurable = !0, "value" in k && (k.writable = !0), Object.defineProperty(S, k.key, k);
              }
            }
            return function(S, x, w) {
              return x && v(S.prototype, x), w && v(S, w), S;
            };
          }();
          function o(v) {
            if (Array.isArray(v)) {
              for (var S = 0, x = Array(v.length); S < v.length; S++)
                x[S] = v[S];
              return x;
            } else
              return Array.from(v);
          }
          function u(v, S) {
            if (!(v instanceof S))
              throw new TypeError("Cannot call a class as a function");
          }
          var c = i.TYPE_MESSAGE = "message", h = i.TYPE_RESPONSE = "response", d = i.TYPE_SET_INTERFACE = "set-interface", m = i.TYPE_SERVICE_MESSAGE = "service-message", y = !!window.MSInputMethodContext && !!document.documentMode, O = {
            //Will not affect IE11 because there sandboxed iframe has not 'null' origin
            //but base URL of iframe's src
            allowedSenderOrigin: void 0
          }, b = function() {
            function v(S, x, w) {
              var k = this;
              u(this, v), this.options = s({}, O, w), this.incrementalID = Math.floor(Math.random() * 1e5), this.postMessage = S, this.remote = {}, this.callbacks = {}, this.remoteMethodsWaitPromise = new Promise(function(C) {
                k._resolveRemoteMethodsPromise = C;
              }), x(function() {
                return k.onMessageListener.apply(k, arguments);
              });
            }
            return a(v, [{
              key: "onMessageListener",
              value: function(x) {
                var w = this, k = x.data, C = this.options.allowedSenderOrigin;
                C && x.origin !== C && !y || (k.type === h ? this.popCallback(k.callId, k.success, k.result) : k.type === c ? this.callLocalApi(k.methodName, k.arguments).then(function(E) {
                  return w.responseOtherSide(k.callId, E);
                }).catch(function(E) {
                  return w.responseOtherSide(k.callId, E, !1);
                }) : k.type === d ? (this.setInterface(k.apiMethods), this.responseOtherSide(k.callId)) : k.type === m && this.callLocalServiceMethod(k.methodName, k.arguments).then(function(E) {
                  return w.responseOtherSide(k.callId, E);
                }).catch(function(E) {
                  return w.responseOtherSide(k.callId, E, !1);
                }));
              }
            }, {
              key: "postMessageToOtherSide",
              value: function(x) {
                this.postMessage(x, "*");
              }
              /**
                 * Sets remote interface methods
                 * @param remote - hash with keys of remote API methods. Values is ignored
                 */
            }, {
              key: "setInterface",
              value: function(x) {
                var w = this;
                this.remote = {}, x.forEach(function(k) {
                  return w.remote[k] = w.createMethodWrapper(k);
                }), this._resolveRemoteMethodsPromise();
              }
            }, {
              key: "setLocalApi",
              value: function(x) {
                var w = this;
                return new Promise(function(k, C) {
                  var E = w.registerCallback(k, C);
                  w.postMessageToOtherSide({
                    callId: E,
                    apiMethods: Object.keys(x),
                    type: d
                  });
                }).then(function() {
                  return w.localApi = x;
                });
              }
            }, {
              key: "setServiceMethods",
              value: function(x) {
                this.serviceMethods = x;
              }
              /**
                 * Calls local method
                 * @param methodName
                 * @param args
                 * @returns {Promise.<*>|string}
                 */
            }, {
              key: "callLocalApi",
              value: function(x, w) {
                var k;
                return Promise.resolve((k = this.localApi)[x].apply(k, o(w)));
              }
              /**
                 * Calls local method registered as "service method"
                 * @param methodName
                 * @param args
                 * @returns {Promise.<*>}
                 */
            }, {
              key: "callLocalServiceMethod",
              value: function(x, w) {
                var k;
                if (!this.serviceMethods[x])
                  throw new Error("Serivce method " + x + " is not registered");
                return Promise.resolve((k = this.serviceMethods)[x].apply(k, o(w)));
              }
              /**
                 * Wraps remote method with callback storing code
                 * @param methodName - method to wrap
                 * @returns {Function} - function to call as remote API interface
                 */
            }, {
              key: "createMethodWrapper",
              value: function(x) {
                var w = this;
                return function() {
                  for (var k = arguments.length, C = Array(k), E = 0; E < k; E++)
                    C[E] = arguments[E];
                  return w.callRemoteMethod.apply(w, [x].concat(C));
                };
              }
              /**
                 * Calls other side with arguments provided
                 * @param id
                 * @param methodName
                 * @param args
                 */
            }, {
              key: "callRemoteMethod",
              value: function(x) {
                for (var w = this, k = arguments.length, C = Array(k > 1 ? k - 1 : 0), E = 1; E < k; E++)
                  C[E - 1] = arguments[E];
                return new Promise(function(P, I) {
                  var B = w.registerCallback(P, I);
                  w.postMessageToOtherSide({
                    callId: B,
                    methodName: x,
                    type: c,
                    arguments: C
                  });
                });
              }
              /**
                 * Calls remote service method
                 * @param methodName
                 * @param args
                 * @returns {*}
                 */
            }, {
              key: "callRemoteServiceMethod",
              value: function(x) {
                for (var w = this, k = arguments.length, C = Array(k > 1 ? k - 1 : 0), E = 1; E < k; E++)
                  C[E - 1] = arguments[E];
                return new Promise(function(P, I) {
                  var B = w.registerCallback(P, I);
                  w.postMessageToOtherSide({
                    callId: B,
                    methodName: x,
                    type: m,
                    arguments: C
                  });
                });
              }
              /**
                 * Respond to remote call
                 * @param id - remote call ID
                 * @param result - result to pass to calling function
                 */
            }, {
              key: "responseOtherSide",
              value: function(x, w) {
                var k = this, C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
                w instanceof Error && (w = [].concat(o(Object.keys(w)), ["message"]).reduce(function(P, I) {
                  return P[I] = w[I], P;
                }, {}));
                var E = function() {
                  return k.postMessage({
                    callId: x,
                    type: h,
                    success: C,
                    result: w
                  }, "*");
                };
                try {
                  E();
                } catch (P) {
                  console.error("Failed to post response, recovering...", P), P instanceof DOMException && (w = JSON.parse(JSON.stringify(w)), E());
                }
              }
              /**
                 * Stores callbacks to call later when remote call will be answered
                 * @param successCallback
                 * @param failureCallback
                 */
            }, {
              key: "registerCallback",
              value: function(x, w) {
                var k = (++this.incrementalID).toString();
                return this.callbacks[k] = { successCallback: x, failureCallback: w }, k;
              }
              /**
                 * Calls and delete stored callback
                 * @param id - call id
                 * @param success - was call successful
                 * @param result - result of remote call
                 */
            }, {
              key: "popCallback",
              value: function(x, w, k) {
                w ? this.callbacks[x].successCallback(k) : this.callbacks[x].failureCallback(k), delete this.callbacks[x];
              }
            }]), v;
          }();
          i.default = b;
        },
        /* 1 */
        /***/
        function(r, i) {
          r.exports = `/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TYPE_MESSAGE = exports.TYPE_MESSAGE = 'message';
var TYPE_RESPONSE = exports.TYPE_RESPONSE = 'response';
var TYPE_SET_INTERFACE = exports.TYPE_SET_INTERFACE = 'set-interface';
var TYPE_SERVICE_MESSAGE = exports.TYPE_SERVICE_MESSAGE = 'service-message';

var isIE11 = !!window.MSInputMethodContext && !!document.documentMode;

var defaultOptions = {
  //Will not affect IE11 because there sandboxed iframe has not 'null' origin
  //but base URL of iframe's src
  allowedSenderOrigin: undefined
};

var Connection = function () {
  function Connection(postMessage, registerOnMessageListener, options) {
    var _this = this;

    _classCallCheck(this, Connection);

    this.options = _extends({}, defaultOptions, options);
    //Random number between 0 and 100000
    this.incrementalID = Math.floor(Math.random() * 100000);

    this.postMessage = postMessage;
    this.remote = {};
    this.callbacks = {};

    this.remoteMethodsWaitPromise = new Promise(function (resolve) {
      _this._resolveRemoteMethodsPromise = resolve;
    });

    registerOnMessageListener(function () {
      return _this.onMessageListener.apply(_this, arguments);
    });
  }

  /**
     * Listens to remote messages. Calls local method if it is called outside or call stored callback if it is response.
     * @param e - onMessage event
     */


  _createClass(Connection, [{
    key: 'onMessageListener',
    value: function onMessageListener(e) {
      var _this2 = this;

      var data = e.data;

      var allowedSenderOrigin = this.options.allowedSenderOrigin;

      if (allowedSenderOrigin && e.origin !== allowedSenderOrigin && !isIE11) {
        return;
      }

      if (data.type === TYPE_RESPONSE) {
        this.popCallback(data.callId, data.success, data.result);
      } else if (data.type === TYPE_MESSAGE) {
        this.callLocalApi(data.methodName, data.arguments).then(function (res) {
          return _this2.responseOtherSide(data.callId, res);
        }).catch(function (err) {
          return _this2.responseOtherSide(data.callId, err, false);
        });
      } else if (data.type === TYPE_SET_INTERFACE) {
        this.setInterface(data.apiMethods);
        this.responseOtherSide(data.callId);
      } else if (data.type === TYPE_SERVICE_MESSAGE) {
        this.callLocalServiceMethod(data.methodName, data.arguments).then(function (res) {
          return _this2.responseOtherSide(data.callId, res);
        }).catch(function (err) {
          return _this2.responseOtherSide(data.callId, err, false);
        });
      }
    }
  }, {
    key: 'postMessageToOtherSide',
    value: function postMessageToOtherSide(dataToPost) {
      this.postMessage(dataToPost, '*');
    }

    /**
       * Sets remote interface methods
       * @param remote - hash with keys of remote API methods. Values is ignored
       */

  }, {
    key: 'setInterface',
    value: function setInterface(remoteMethods) {
      var _this3 = this;

      this.remote = {};

      remoteMethods.forEach(function (key) {
        return _this3.remote[key] = _this3.createMethodWrapper(key);
      });

      this._resolveRemoteMethodsPromise();
    }
  }, {
    key: 'setLocalApi',
    value: function setLocalApi(api) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        var id = _this4.registerCallback(resolve, reject);
        _this4.postMessageToOtherSide({
          callId: id,
          apiMethods: Object.keys(api),
          type: TYPE_SET_INTERFACE
        });
      }).then(function () {
        return _this4.localApi = api;
      });
    }
  }, {
    key: 'setServiceMethods',
    value: function setServiceMethods(api) {
      this.serviceMethods = api;
    }

    /**
       * Calls local method
       * @param methodName
       * @param args
       * @returns {Promise.<*>|string}
       */

  }, {
    key: 'callLocalApi',
    value: function callLocalApi(methodName, args) {
      var _localApi;

      return Promise.resolve((_localApi = this.localApi)[methodName].apply(_localApi, _toConsumableArray(args)));
    }

    /**
       * Calls local method registered as "service method"
       * @param methodName
       * @param args
       * @returns {Promise.<*>}
       */

  }, {
    key: 'callLocalServiceMethod',
    value: function callLocalServiceMethod(methodName, args) {
      var _serviceMethods;

      if (!this.serviceMethods[methodName]) {
        throw new Error('Serivce method ' + methodName + ' is not registered');
      }
      return Promise.resolve((_serviceMethods = this.serviceMethods)[methodName].apply(_serviceMethods, _toConsumableArray(args)));
    }

    /**
       * Wraps remote method with callback storing code
       * @param methodName - method to wrap
       * @returns {Function} - function to call as remote API interface
       */

  }, {
    key: 'createMethodWrapper',
    value: function createMethodWrapper(methodName) {
      var _this5 = this;

      return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _this5.callRemoteMethod.apply(_this5, [methodName].concat(args));
      };
    }

    /**
       * Calls other side with arguments provided
       * @param id
       * @param methodName
       * @param args
       */

  }, {
    key: 'callRemoteMethod',
    value: function callRemoteMethod(methodName) {
      var _this6 = this;

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return new Promise(function (resolve, reject) {
        var id = _this6.registerCallback(resolve, reject);
        _this6.postMessageToOtherSide({
          callId: id,
          methodName: methodName,
          type: TYPE_MESSAGE,
          arguments: args
        });
      });
    }

    /**
       * Calls remote service method
       * @param methodName
       * @param args
       * @returns {*}
       */

  }, {
    key: 'callRemoteServiceMethod',
    value: function callRemoteServiceMethod(methodName) {
      var _this7 = this;

      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return new Promise(function (resolve, reject) {
        var id = _this7.registerCallback(resolve, reject);
        _this7.postMessageToOtherSide({
          callId: id,
          methodName: methodName,
          type: TYPE_SERVICE_MESSAGE,
          arguments: args
        });
      });
    }

    /**
       * Respond to remote call
       * @param id - remote call ID
       * @param result - result to pass to calling function
       */

  }, {
    key: 'responseOtherSide',
    value: function responseOtherSide(id, result) {
      var _this8 = this;

      var success = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (result instanceof Error) {
        // Error could be non-serializable, so we copy properties manually
        result = [].concat(_toConsumableArray(Object.keys(result)), ['message']).reduce(function (acc, it) {
          acc[it] = result[it];
          return acc;
        }, {});
      }

      var doPost = function doPost() {
        return _this8.postMessage({
          callId: id,
          type: TYPE_RESPONSE,
          success: success,
          result: result
        }, '*');
      };

      try {
        doPost();
      } catch (err) {
        console.error('Failed to post response, recovering...', err); // eslint-disable-line no-console
        if (err instanceof DOMException) {
          result = JSON.parse(JSON.stringify(result));
          doPost();
        }
      }
    }

    /**
       * Stores callbacks to call later when remote call will be answered
       * @param successCallback
       * @param failureCallback
       */

  }, {
    key: 'registerCallback',
    value: function registerCallback(successCallback, failureCallback) {
      var id = (++this.incrementalID).toString();
      this.callbacks[id] = { successCallback: successCallback, failureCallback: failureCallback };
      return id;
    }

    /**
       * Calls and delete stored callback
       * @param id - call id
       * @param success - was call successful
       * @param result - result of remote call
       */

  }, {
    key: 'popCallback',
    value: function popCallback(id, success, result) {
      if (success) {
        this.callbacks[id].successCallback(result);
      } else {
        this.callbacks[id].failureCallback(result);
      }
      delete this.callbacks[id];
    }
  }]);

  return Connection;
}();

exports.default = Connection;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _connection = __webpack_require__(0);

var _connection2 = _interopRequireDefault(_connection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Frame = function () {
  function Frame() {
    var _this = this;

    _classCallCheck(this, Frame);

    this.connection = new _connection2.default(window.parent.postMessage.bind(window.parent), function (listener) {
      window.addEventListener('message', listener);
    });

    this.connection.setServiceMethods({
      runCode: function runCode(code) {
        return _this.runCode(code);
      },
      importScript: function importScript(path) {
        return _this.importScript(path);
      },
      injectStyle: function injectStyle(style) {
        return _this.injectStyle(style);
      },
      importStyle: function importStyle(path) {
        return _this.importStyle(path);
      }
    });

    this.connection.callRemoteServiceMethod('iframeInitialized');
  }

  /**
     * Creates script tag with passed code and attaches it. Runs synchronous
     * @param code
     */


  _createClass(Frame, [{
    key: 'runCode',
    value: function runCode(code) {
      var scriptTag = document.createElement('script');
      scriptTag.innerHTML = code;
      document.getElementsByTagName('head')[0].appendChild(scriptTag);
    }
  }, {
    key: 'importScript',
    value: function importScript(scriptUrl) {
      var scriptTag = document.createElement('script');
      scriptTag.src = scriptUrl;
      document.getElementsByTagName('head')[0].appendChild(scriptTag);
      return new Promise(function (resolve) {
        return scriptTag.onload = function () {
          return resolve();
        };
      });
    }
  }, {
    key: 'injectStyle',
    value: function injectStyle(style) {
      var styleTag = document.createElement('style');
      styleTag.innerHTML = style;
      document.getElementsByTagName('head')[0].appendChild(styleTag);
    }
  }, {
    key: 'importStyle',
    value: function importStyle(styleUrl) {
      var linkTag = document.createElement('link');
      linkTag.rel = 'stylesheet';
      linkTag.href = styleUrl;
      document.getElementsByTagName('head')[0].appendChild(linkTag);
    }
  }]);

  return Frame;
}();

var Websandbox = new Frame();
window.Websandbox = window.Websandbox || Websandbox;
module.exports = Websandbox; // eslint-disable-line

/***/ })
/******/ ]);
//# sourceMappingURL=compile-loader-file-name.js.map`;
        },
        ,
        /* 3 */
        /***/
        function(r, i, n) {
          Object.defineProperty(i, "__esModule", {
            value: !0
          }), i.BaseOptions = void 0;
          var s = Object.assign || function(b) {
            for (var v = 1; v < arguments.length; v++) {
              var S = arguments[v];
              for (var x in S)
                Object.prototype.hasOwnProperty.call(S, x) && (b[x] = S[x]);
            }
            return b;
          }, a = /* @__PURE__ */ function() {
            function b(v, S) {
              for (var x = 0; x < S.length; x++) {
                var w = S[x];
                w.enumerable = w.enumerable || !1, w.configurable = !0, "value" in w && (w.writable = !0), Object.defineProperty(v, w.key, w);
              }
            }
            return function(v, S, x) {
              return S && b(v.prototype, S), x && b(v, x), v;
            };
          }(), o = n(0), u = d(o), c = n(1), h = d(c);
          function d(b) {
            return b && b.__esModule ? b : { default: b };
          }
          function m(b, v) {
            if (!(b instanceof v))
              throw new TypeError("Cannot call a class as a function");
          }
          var y = i.BaseOptions = {
            frameContainer: "body",
            frameClassName: "websandbox__frame",
            frameSrc: null,
            frameContent: `
<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"></head>
<body></body>
</html>
  `,
            codeToRunBeforeInit: null,
            initialStyles: null,
            baseUrl: null,
            allowPointerLock: !1,
            allowFullScreen: !1,
            sandboxAdditionalAttributes: ""
          }, O = function() {
            a(b, null, [{
              key: "create",
              /**
               * Creates sandbox instancea
               * @param {?Object} localApi Api of this side. Will be available for sandboxed code as remoteApi
               * @param {?SandboxOptions} options Options of created sandbox
               */
              value: function(S) {
                var x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                return new b(S, s(y, x));
              }
              /**
               * {Constructor}
               * @param {?Object} localApi
               * @param {?SandboxOptions} options
               */
            }]);
            function b(v, S) {
              var x = this;
              m(this, b), this.options = S, this.iframe = this.createIframe(), this.promise = new Promise(function(w) {
                x.connection = new u.default(x.iframe.contentWindow.postMessage.bind(x.iframe.contentWindow), function(k) {
                  var C = function(P) {
                    if (P.source === x.iframe.contentWindow)
                      return k(P);
                  };
                  window.addEventListener("message", C), x.removeMessageListener = function() {
                    return window.removeEventListener("message", C);
                  };
                }, { allowedSenderOrigin: "null" }), x.connection.setServiceMethods({
                  iframeInitialized: function() {
                    return x.connection.setLocalApi(v).then(function() {
                      return w(x);
                    });
                  }
                });
              });
            }
            return a(b, [{
              key: "_prepareFrameContent",
              value: function(S) {
                var x = S.frameContent.replace("</head>", "<script>" + h.default + `<\/script>
</head>`);
                return S.initialStyles && (x = x.replace("</head>", "<style>" + S.initialStyles + `</style>
</head>`)), S.baseUrl && (x = x.replace("<head>", `<head>
<base href="` + S.baseUrl + '"/>')), S.codeToRunBeforeInit && (x = x.replace("<head>", `<head>
<script>` + S.codeToRunBeforeInit + "<\/script>")), x;
              }
            }, {
              key: "createIframe",
              value: function() {
                var S = this.options.frameContainer, x = typeof S == "string" ? document.querySelector(S) : S;
                if (!x)
                  throw new Error("Websandbox: Cannot find container for sandbox " + x);
                var w = document.createElement("iframe");
                if (w.sandbox = "allow-scripts " + this.options.sandboxAdditionalAttributes, w.className = this.options.frameClassName, this.options.allowFullScreen && (w.allowfullscreen = "true"), this.options.frameSrc)
                  return w.src = this.options.frameSrc, x.appendChild(w), w;
                if (this.options.frameContent.indexOf("<head>") < 0)
                  throw new Error('Websandbox: iFrame content must have "<head>" tag.');
                return w.setAttribute("srcdoc", this._prepareFrameContent(this.options)), x.appendChild(w), w;
              }
            }, {
              key: "destroy",
              value: function() {
                this.iframe.remove(), this.removeMessageListener();
              }
            }, {
              key: "_runCode",
              value: function(S) {
                return this.connection.callRemoteServiceMethod("runCode", S);
              }
            }, {
              key: "_runFunction",
              value: function(S) {
                return this._runCode("(" + S.toString() + ")()");
              }
            }, {
              key: "run",
              value: function(S) {
                return S.name ? this._runFunction(S) : this._runCode(S);
              }
            }, {
              key: "importScript",
              value: function(S) {
                return this.connection.callRemoteServiceMethod("importScript", S);
              }
            }, {
              key: "injectStyle",
              value: function(S) {
                return this.connection.callRemoteServiceMethod("injectStyle", S);
              }
            }]), b;
          }();
          i.default = O;
        }
        /******/
      ])
    );
  });
})(Ok);
var SG = Ok.exports;
const wG = /* @__PURE__ */ _T(SG), CG = ({ output: t }) => {
  const [e, r] = In(t);
  return ti(() => r(t), [t]), /* @__PURE__ */ z.jsxs("div", { className: "debugger-pane", children: [
    /* @__PURE__ */ z.jsxs("div", { className: "debugger-title-bar", children: [
      /* @__PURE__ */ z.jsx("div", { className: "debugger-title", children: "Console" }),
      /* @__PURE__ */ z.jsx("button", { type: "button", onClick: () => r(void 0), children: "Clear console" })
    ] }),
    /* @__PURE__ */ z.jsx("div", { className: "debugger-view", children: e == null ? void 0 : e.map((i) => i.join(", ")).join(`
`) })
  ] });
}, AG = ({
  contentFrameHeight: t = "1fr",
  debuggerOutput: e,
  children: r
}) => {
  const { config: i } = Er();
  return /* @__PURE__ */ z.jsxs(
    "div",
    {
      className: "debugger-wrapper",
      style: {
        gridTemplateRows: i.showDebug ? `${t} 1fr` : "auto"
      },
      children: [
        /* @__PURE__ */ z.jsx("div", { className: "debugger-wrapper-child", children: r }),
        /* @__PURE__ */ z.jsx(CG, { output: e })
      ]
    }
  );
}, EG = ({ file: t }) => {
  const [e, r] = In([]), i = () => {
    const n = {
      consoleLog: (...s) => (r((a) => [...a, s]), Promise.resolve("messaged"))
    };
    for (let s of document.getElementsByClassName("js-preview-output"))
      s.innerHTML = "";
    wG.create(n, {
      frameContainer: ".js-preview-output"
    }).promise.then(function(s) {
      r([]), s.run(
        `
        console.log = Websandbox.connection.remote.consoleLog;
        ${t.contents}
      `
      );
    });
  };
  return /* @__PURE__ */ z.jsx(AG, { contentFrameHeight: "1fr", debuggerOutput: e, children: /* @__PURE__ */ z.jsxs("div", { className: "js-preview-container", children: [
    /* @__PURE__ */ z.jsx("div", { className: "js-preview-output", children: "pending..." }),
    /* @__PURE__ */ z.jsx("div", { className: "button-bar", children: /* @__PURE__ */ z.jsx("button", { onClick: i, children: "Run" }) })
  ] }) });
}, kG = ({ file: t }) => {
  let e = "";
  try {
    e = JSON.stringify(JSON.parse(t.contents), void 0, 2);
  } catch (r) {
    const i = vb(r);
    return /* @__PURE__ */ z.jsxs("div", { className: "json-preview", children: [
      "Cannot display json: invalid format.",
      i
    ] });
  }
  return /* @__PURE__ */ z.jsx("div", { className: "json-preview", children: e });
}, gb = {
  html: vG,
  js: EG,
  json: kG
}, TG = (t, e = {}) => t ? e[t == null ? void 0 : t.language] ? e[t == null ? void 0 : t.language] : gb[t == null ? void 0 : t.language] ? gb[t == null ? void 0 : t.language] : () => /* @__PURE__ */ z.jsxs("div", { children: [
  "Cannot preview files of type ",
  t == null ? void 0 : t.language
] }) : () => "", PG = () => {
  const {
    project: { files: t },
    config: { previewFileTypes: e, PreviewComponents: r }
  } = Er(), [i, n] = In(
    Object.values(t).find((o) => o.name === "index.html" && !o.folderId)
  ), s = Object.values(t).find(
    (o) => o.active && mu(o.language)
  );
  ti(() => {
    mu(s == null ? void 0 : s.language, e) && n(s);
  }, [s]), ti(() => {
    i && !t[i.id] && n(
      Object.values(t).find(
        (o) => mu(o.language, e)
      )
    );
  }, [i, t]);
  const a = TG(i, r);
  return /* @__PURE__ */ z.jsxs("div", { className: "right-pane", children: [
    /* @__PURE__ */ z.jsx(
      "select",
      {
        onChange: (o) => {
          const u = Object.values(t).find(
            (c) => c.id === o.target.value
          );
          n(u);
        },
        value: i == null ? void 0 : i.id,
        children: Object.values(t).sort().filter((o) => mu(o.language, e)).map((o) => /* @__PURE__ */ z.jsx("option", { value: o.id, children: o.name }, o.id))
      }
    ),
    i && /* @__PURE__ */ z.jsx(a, { file: i })
  ] });
}, FG = () => /* @__PURE__ */ z.jsxs("div", { className: "run-bar", children: [
  /* @__PURE__ */ z.jsx("div", { children: /* @__PURE__ */ z.jsx("button", { type: "button", onClick: () => alert("not implemented"), children: "Share" }) }),
  /* @__PURE__ */ z.jsx("div", { children: /* @__PURE__ */ z.jsx("button", { type: "button", onClick: () => alert("not implemented"), children: "Finish" }) })
] }), $G = {
  showPreview: !0,
  showEditor: !0,
  showLeftNav: !0,
  showRunBar: !1
}, sa = (t, e) => e[t] ?? $G[t] ?? !1, BG = [
  { key: "showLeftNav", width: "1fr" },
  { key: "showPreview", width: "2fr" },
  { key: "showEditor", width: "2fr" }
], IG = [
  { key: "showRunBar", height: "40px" }
], $H = ({
  project: t,
  config: e,
  setProject: r,
  setConfig: i
}) => {
  const n = Sm(!0), [s, a] = IT(RR, t), o = LR(a);
  ti(() => {
    n.current && r(s), n.current = !0;
  }, [s]), ti(() => {
    o.replaceProject(t, n);
  }, [t, o.replaceProject]);
  const u = ["auto"];
  IG.forEach((h) => {
    sa(h.key, e) && u.push(h.height);
  });
  const c = [];
  return BG.forEach((h) => {
    sa(h.key, e) && c.push(h.width);
  }), /* @__PURE__ */ z.jsx(
    LT,
    {
      value: {
        project: s,
        config: e,
        setProject: r,
        setConfig: i,
        ...o
      },
      children: /* @__PURE__ */ z.jsxs(
        "div",
        {
          className: "cdo-ide-outer",
          style: { gridTemplateRows: u.join(" ") },
          children: [
            /* @__PURE__ */ z.jsxs(
              "div",
              {
                className: "cdo-ide-inner",
                style: {
                  gridTemplateColumns: c.join(" ")
                },
                children: [
                  sa("showLeftNav", e) && /* @__PURE__ */ z.jsx("div", { className: "cdo-ide-area", children: /* @__PURE__ */ z.jsx(YR, {}) }),
                  sa("showEditor", e) && /* @__PURE__ */ z.jsx("div", { className: "cdo-ide-area", children: /* @__PURE__ */ z.jsx(DG, {}) }),
                  sa("showPreview", e) && /* @__PURE__ */ z.jsx(PG, {})
                ]
              }
            ),
            sa("showRunBar", e) && /* @__PURE__ */ z.jsx(FG, {})
          ]
        }
      )
    }
  );
};
export {
  $H as CDOIDE,
  xb as CDOIDEContext,
  LT as CDOIDEContextProvider,
  bb as editableFileType,
  MR as findFiles,
  Db as findFolder,
  ry as findSubFolders,
  WT as getEmptyEditor,
  QG as getEmptyProject,
  vb as getErrorMessage,
  _R as getNextFileId,
  QR as getNextFolderId,
  IR as prettify,
  mu as previewFileType,
  RR as projectReducer,
  Fw as sortFilesByName,
  Er as useCDOIDEContext,
  LR as useProjectUtilities
};
//# sourceMappingURL=cdo-ide-poc.js.map
