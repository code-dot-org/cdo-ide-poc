import './style.css';
var YS = Object.defineProperty;
var QS = (t, e, r) => e in t ? YS(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var Vr = (t, e, r) => (QS(t, typeof e != "symbol" ? e + "" : e, r), r);
import ND, { createContext as ZS, useContext as eT, useMemo as MD, useState as Ei, useEffect as Xr, forwardRef as tT, useRef as Tf, useImperativeHandle as rT, useCallback as nT, useReducer as iT } from "react";
import { html as sT } from "@codemirror/lang-html";
import { css as oT } from "@codemirror/lang-css";
import { javascript as aT } from "@codemirror/lang-javascript";
import { json as lT } from "@codemirror/lang-json";
var uT = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function cT(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Hp = { exports: {} }, js = {};
/** @license React v16.14.0
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iy;
function hT() {
  if (iy)
    return js;
  iy = 1;
  var t = ND, e = 60103;
  if (js.Fragment = 60107, typeof Symbol == "function" && Symbol.for) {
    var r = Symbol.for;
    e = r("react.element"), js.Fragment = r("react.fragment");
  }
  var n = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = Object.prototype.hasOwnProperty, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(l, u, h) {
    var p, d = {}, m = null, y = null;
    h !== void 0 && (m = "" + h), u.key !== void 0 && (m = "" + u.key), u.ref !== void 0 && (y = u.ref);
    for (p in u)
      i.call(u, p) && !s.hasOwnProperty(p) && (d[p] = u[p]);
    if (l && l.defaultProps)
      for (p in u = l.defaultProps, u)
        d[p] === void 0 && (d[p] = u[p]);
    return { $$typeof: e, type: l, key: m, ref: y, props: d, _owner: n.current };
  }
  return js.jsx = o, js.jsxs = o, js;
}
var Uh = {};
/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sy;
function pT() {
  return sy || (sy = 1, function(t) {
    process.env.NODE_ENV !== "production" && function() {
      var e = ND, r = 60103, n = 60106;
      t.Fragment = 60107;
      var i = 60108, s = 60114, o = 60109, l = 60110, u = 60112, h = 60113, p = 60120, d = 60115, m = 60116, y = 60121, D = 60122, b = 60117, C = 60129, A = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var x = Symbol.for;
        r = x("react.element"), n = x("react.portal"), t.Fragment = x("react.fragment"), i = x("react.strict_mode"), s = x("react.profiler"), o = x("react.provider"), l = x("react.context"), u = x("react.forward_ref"), h = x("react.suspense"), p = x("react.suspense_list"), d = x("react.memo"), m = x("react.lazy"), y = x("react.block"), D = x("react.server.block"), b = x("react.fundamental"), x("react.scope"), x("react.opaque.id"), C = x("react.debug_trace_mode"), x("react.offscreen"), A = x("react.legacy_hidden");
      }
      var E = typeof Symbol == "function" && Symbol.iterator, k = "@@iterator";
      function w(_) {
        if (_ === null || typeof _ != "object")
          return null;
        var ie = E && _[E] || _[k];
        return typeof ie == "function" ? ie : null;
      }
      var T = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function P(_) {
        {
          for (var ie = arguments.length, pe = new Array(ie > 1 ? ie - 1 : 0), Pe = 1; Pe < ie; Pe++)
            pe[Pe - 1] = arguments[Pe];
          M("error", _, pe);
        }
      }
      function M(_, ie, pe) {
        {
          var Pe = T.ReactDebugCurrentFrame, ze = "";
          if (ye) {
            var Oe = H(ye.type), Be = ye._owner;
            ze += X(Oe, ye._source, Be && H(Be.type));
          }
          ze += Pe.getStackAddendum(), ze !== "" && (ie += "%s", pe = pe.concat([ze]));
          var ke = pe.map(function(Ot) {
            return "" + Ot;
          });
          ke.unshift("Warning: " + ie), Function.prototype.apply.call(console[_], console, ke);
        }
      }
      var N = !1;
      function L(_) {
        return !!(typeof _ == "string" || typeof _ == "function" || _ === t.Fragment || _ === s || _ === C || _ === i || _ === h || _ === p || _ === A || N || typeof _ == "object" && _ !== null && (_.$$typeof === m || _.$$typeof === d || _.$$typeof === o || _.$$typeof === l || _.$$typeof === u || _.$$typeof === b || _.$$typeof === y || _[0] === D));
      }
      var j = /^(.*)[\\\/]/;
      function X(_, ie, pe) {
        var Pe = "";
        if (ie) {
          var ze = ie.fileName, Oe = ze.replace(j, "");
          if (/^index\./.test(Oe)) {
            var Be = ze.match(j);
            if (Be) {
              var ke = Be[1];
              if (ke) {
                var Ot = ke.replace(j, "");
                Oe = Ot + "/" + Oe;
              }
            }
          }
          Pe = " (at " + Oe + ":" + ie.lineNumber + ")";
        } else
          pe && (Pe = " (created by " + pe + ")");
        return `
    in ` + (_ || "Unknown") + Pe;
      }
      var Q = 1;
      function $(_) {
        return _._status === Q ? _._result : null;
      }
      function U(_, ie, pe) {
        var Pe = ie.displayName || ie.name || "";
        return _.displayName || (Pe !== "" ? pe + "(" + Pe + ")" : pe);
      }
      function H(_) {
        if (_ == null)
          return null;
        if (typeof _.tag == "number" && P("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof _ == "function")
          return _.displayName || _.name || null;
        if (typeof _ == "string")
          return _;
        switch (_) {
          case t.Fragment:
            return "Fragment";
          case n:
            return "Portal";
          case s:
            return "Profiler";
          case i:
            return "StrictMode";
          case h:
            return "Suspense";
          case p:
            return "SuspenseList";
        }
        if (typeof _ == "object")
          switch (_.$$typeof) {
            case l:
              return "Context.Consumer";
            case o:
              return "Context.Provider";
            case u:
              return U(_, _.render, "ForwardRef");
            case d:
              return H(_.type);
            case y:
              return H(_.render);
            case m: {
              var ie = _, pe = $(ie);
              if (pe)
                return H(pe);
              break;
            }
          }
        return null;
      }
      var Z = {};
      T.ReactDebugCurrentFrame;
      var ye = null;
      function Ee(_) {
        ye = _;
      }
      function ve(_, ie, pe, Pe, ze) {
        {
          var Oe = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var Be in _)
            if (Oe(_, Be)) {
              var ke = void 0;
              try {
                if (typeof _[Be] != "function") {
                  var Ot = Error((Pe || "React class") + ": " + pe + " type `" + Be + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof _[Be] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Ot.name = "Invariant Violation", Ot;
                }
                ke = _[Be](ie, Be, Pe, pe, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (wr) {
                ke = wr;
              }
              ke && !(ke instanceof Error) && (Ee(ze), P("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Pe || "React class", pe, Be, typeof ke), Ee(null)), ke instanceof Error && !(ke.message in Z) && (Z[ke.message] = !0, Ee(ze), P("Failed %s type: %s", pe, ke.message), Ee(null));
            }
        }
      }
      var $e = T.ReactCurrentOwner, Ke = Object.prototype.hasOwnProperty, Qe = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Fe, ht, le;
      le = {};
      function z(_) {
        if (Ke.call(_, "ref")) {
          var ie = Object.getOwnPropertyDescriptor(_, "ref").get;
          if (ie && ie.isReactWarning)
            return !1;
        }
        return _.ref !== void 0;
      }
      function W(_) {
        if (Ke.call(_, "key")) {
          var ie = Object.getOwnPropertyDescriptor(_, "key").get;
          if (ie && ie.isReactWarning)
            return !1;
        }
        return _.key !== void 0;
      }
      function R(_, ie) {
        if (typeof _.ref == "string" && $e.current && ie && $e.current.stateNode !== ie) {
          var pe = H($e.current.type);
          le[pe] || (P('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', H($e.current.type), _.ref), le[pe] = !0);
        }
      }
      function Ce(_, ie) {
        {
          var pe = function() {
            Fe || (Fe = !0, P("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ie));
          };
          pe.isReactWarning = !0, Object.defineProperty(_, "key", {
            get: pe,
            configurable: !0
          });
        }
      }
      function be(_, ie) {
        {
          var pe = function() {
            ht || (ht = !0, P("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ie));
          };
          pe.isReactWarning = !0, Object.defineProperty(_, "ref", {
            get: pe,
            configurable: !0
          });
        }
      }
      var Te = function(_, ie, pe, Pe, ze, Oe, Be) {
        var ke = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: r,
          // Built-in properties that belong on the element
          type: _,
          key: ie,
          ref: pe,
          props: Be,
          // Record the component responsible for creating this element.
          _owner: Oe
        };
        return ke._store = {}, Object.defineProperty(ke._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(ke, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Pe
        }), Object.defineProperty(ke, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: ze
        }), Object.freeze && (Object.freeze(ke.props), Object.freeze(ke)), ke;
      };
      function Qt(_, ie, pe, Pe, ze) {
        {
          var Oe, Be = {}, ke = null, Ot = null;
          pe !== void 0 && (ke = "" + pe), W(ie) && (ke = "" + ie.key), z(ie) && (Ot = ie.ref, R(ie, ze));
          for (Oe in ie)
            Ke.call(ie, Oe) && !Qe.hasOwnProperty(Oe) && (Be[Oe] = ie[Oe]);
          if (_ && _.defaultProps) {
            var wr = _.defaultProps;
            for (Oe in wr)
              Be[Oe] === void 0 && (Be[Oe] = wr[Oe]);
          }
          if (ke || Ot) {
            var ln = typeof _ == "function" ? _.displayName || _.name || "Unknown" : _;
            ke && Ce(Be, ln), Ot && be(Be, ln);
          }
          return Te(_, ke, Ot, ze, Pe, $e.current, Be);
        }
      }
      var Mt = T.ReactCurrentOwner;
      T.ReactDebugCurrentFrame;
      function xt(_) {
        ye = _;
      }
      var Ur;
      Ur = !1;
      function ii(_) {
        return typeof _ == "object" && _ !== null && _.$$typeof === r;
      }
      function or() {
        {
          if (Mt.current) {
            var _ = H(Mt.current.type);
            if (_)
              return `

Check the render method of \`` + _ + "`.";
          }
          return "";
        }
      }
      function Er(_) {
        {
          if (_ !== void 0) {
            var ie = _.fileName.replace(/^.*[\\\/]/, ""), pe = _.lineNumber;
            return `

Check your code at ` + ie + ":" + pe + ".";
          }
          return "";
        }
      }
      var on = {};
      function si(_) {
        {
          var ie = or();
          if (!ie) {
            var pe = typeof _ == "string" ? _ : _.displayName || _.name;
            pe && (ie = `

Check the top-level render call using <` + pe + ">.");
          }
          return ie;
        }
      }
      function Ln(_, ie) {
        {
          if (!_._store || _._store.validated || _.key != null)
            return;
          _._store.validated = !0;
          var pe = si(ie);
          if (on[pe])
            return;
          on[pe] = !0;
          var Pe = "";
          _ && _._owner && _._owner !== Mt.current && (Pe = " It was passed a child from " + H(_._owner.type) + "."), xt(_), P('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', pe, Pe), xt(null);
        }
      }
      function _n(_, ie) {
        {
          if (typeof _ != "object")
            return;
          if (Array.isArray(_))
            for (var pe = 0; pe < _.length; pe++) {
              var Pe = _[pe];
              ii(Pe) && Ln(Pe, ie);
            }
          else if (ii(_))
            _._store && (_._store.validated = !0);
          else if (_) {
            var ze = w(_);
            if (typeof ze == "function" && ze !== _.entries)
              for (var Oe = ze.call(_), Be; !(Be = Oe.next()).done; )
                ii(Be.value) && Ln(Be.value, ie);
          }
        }
      }
      function an(_) {
        {
          var ie = _.type;
          if (ie == null || typeof ie == "string")
            return;
          var pe;
          if (typeof ie == "function")
            pe = ie.propTypes;
          else if (typeof ie == "object" && (ie.$$typeof === u || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          ie.$$typeof === d))
            pe = ie.propTypes;
          else
            return;
          if (pe) {
            var Pe = H(ie);
            ve(pe, _.props, "prop", Pe, _);
          } else if (ie.PropTypes !== void 0 && !Ur) {
            Ur = !0;
            var ze = H(ie);
            P("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ze || "Unknown");
          }
          typeof ie.getDefaultProps == "function" && !ie.getDefaultProps.isReactClassApproved && P("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Ls(_) {
        {
          for (var ie = Object.keys(_.props), pe = 0; pe < ie.length; pe++) {
            var Pe = ie[pe];
            if (Pe !== "children" && Pe !== "key") {
              xt(_), P("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Pe), xt(null);
              break;
            }
          }
          _.ref !== null && (xt(_), P("Invalid attribute `ref` supplied to `React.Fragment`."), xt(null));
        }
      }
      function Il(_, ie, pe, Pe, ze, Oe) {
        {
          var Be = L(_);
          if (!Be) {
            var ke = "";
            (_ === void 0 || typeof _ == "object" && _ !== null && Object.keys(_).length === 0) && (ke += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var Ot = Er(ze);
            Ot ? ke += Ot : ke += or();
            var wr;
            _ === null ? wr = "null" : Array.isArray(_) ? wr = "array" : _ !== void 0 && _.$$typeof === r ? (wr = "<" + (H(_.type) || "Unknown") + " />", ke = " Did you accidentally export a JSX literal instead of a component?") : wr = typeof _, P("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", wr, ke);
          }
          var ln = Qt(_, ie, pe, ze, Oe);
          if (ln == null)
            return ln;
          if (Be) {
            var $n = ie.children;
            if ($n !== void 0)
              if (Pe)
                if (Array.isArray($n)) {
                  for (var $s = 0; $s < $n.length; $s++)
                    _n($n[$s], _);
                  Object.freeze && Object.freeze($n);
                } else
                  P("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                _n($n, _);
          }
          return _ === t.Fragment ? Ls(ln) : an(ln), ln;
        }
      }
      function _s(_, ie, pe) {
        return Il(_, ie, pe, !0);
      }
      function Hr(_, ie, pe) {
        return Il(_, ie, pe, !1);
      }
      var Ho = Hr, Nl = _s;
      t.jsx = Ho, t.jsxs = Nl;
    }();
  }(Uh)), Uh;
}
process.env.NODE_ENV === "production" ? Hp.exports = hT() : Hp.exports = pT();
var G = Hp.exports;
const OD = ZS(null), vr = () => {
  const t = eT(OD);
  if (t === null)
    throw new Error("CDO IDE Context has not been provided!");
  return t;
}, dT = ({
  children: t,
  value: e
}) => /* @__PURE__ */ G.jsx(OD.Provider, { value: e, children: t }), fT = ["html", "css", "js", "json"], LD = (t, e = fT) => new Set(e).has(t), as = "0", _D = (t = [], e) => t.reduce((r, n) => {
  if (!n.length)
    return r;
  const i = Object.values(e.folders).find(
    (s) => s.name === n && s.parentId === r
  );
  if (!i) {
    if (e.required)
      throw new Error(`Could not find folder ${t.join("/")}`);
    return as;
  }
  return i.id;
}, as), mT = () => /* @__PURE__ */ G.jsx("div", { children: "No files are open. Choose a file from the browser to the left." }), gT = () => /* @__PURE__ */ G.jsx("div", {}), yT = (t) => t.EmptyEditorComponent ? t.EmptyEditorComponent : t.blankEmptyEditor ? gT : mT, KV = () => ({ files: {}, folders: {} }), $D = (t) => typeof t == "string" ? t : t instanceof Error ? t.message : "", DT = ["html", "js", "json"], ql = (t, e = DT) => new Set(e).has(t);
var xT = Object.create, kc = Object.defineProperty, bT = Object.getOwnPropertyDescriptor, vT = Object.getOwnPropertyNames, CT = Object.getPrototypeOf, AT = Object.prototype.hasOwnProperty, ET = (t, e) => () => (t && (e = t(t = 0)), e), Fc = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Pc = (t, e) => {
  for (var r in e)
    kc(t, r, { get: e[r], enumerable: !0 });
}, RD = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of vT(e))
      !AT.call(t, i) && i !== r && kc(t, i, { get: () => e[i], enumerable: !(n = bT(e, i)) || n.enumerable });
  return t;
}, ol = (t, e, r) => (r = t != null ? xT(CT(t)) : {}, RD(e || !t || !t.__esModule ? kc(r, "default", { value: t, enumerable: !0 }) : r, t)), wT = (t) => RD(kc({}, "__esModule", { value: !0 }), t), ST = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, oy = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, Xo = (t, e, r) => (ST(t, e, "access private method"), r), TT = Fc((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = e;
  function e() {
  }
  e.prototype = { diff: function(i, s) {
    var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = o.callback;
    typeof o == "function" && (l = o, o = {}), this.options = o;
    var u = this;
    function h(x) {
      return l ? (setTimeout(function() {
        l(void 0, x);
      }, 0), !0) : x;
    }
    i = this.castInput(i), s = this.castInput(s), i = this.removeEmpty(this.tokenize(i)), s = this.removeEmpty(this.tokenize(s));
    var p = s.length, d = i.length, m = 1, y = p + d;
    o.maxEditLength && (y = Math.min(y, o.maxEditLength));
    var D = [{ newPos: -1, components: [] }], b = this.extractCommon(D[0], s, i, 0);
    if (D[0].newPos + 1 >= p && b + 1 >= d)
      return h([{ value: this.join(s), count: s.length }]);
    function C() {
      for (var x = -1 * m; x <= m; x += 2) {
        var E = void 0, k = D[x - 1], w = D[x + 1], T = (w ? w.newPos : 0) - x;
        k && (D[x - 1] = void 0);
        var P = k && k.newPos + 1 < p, M = w && 0 <= T && T < d;
        if (!P && !M) {
          D[x] = void 0;
          continue;
        }
        if (!P || M && k.newPos < w.newPos ? (E = n(w), u.pushComponent(E.components, void 0, !0)) : (E = k, E.newPos++, u.pushComponent(E.components, !0, void 0)), T = u.extractCommon(E, s, i, x), E.newPos + 1 >= p && T + 1 >= d)
          return h(r(u, E.components, s, i, u.useLongestToken));
        D[x] = E;
      }
      m++;
    }
    if (l)
      (function x() {
        setTimeout(function() {
          if (m > y)
            return l();
          C() || x();
        }, 0);
      })();
    else
      for (; m <= y; ) {
        var A = C();
        if (A)
          return A;
      }
  }, pushComponent: function(i, s, o) {
    var l = i[i.length - 1];
    l && l.added === s && l.removed === o ? i[i.length - 1] = { count: l.count + 1, added: s, removed: o } : i.push({ count: 1, added: s, removed: o });
  }, extractCommon: function(i, s, o, l) {
    for (var u = s.length, h = o.length, p = i.newPos, d = p - l, m = 0; p + 1 < u && d + 1 < h && this.equals(s[p + 1], o[d + 1]); )
      p++, d++, m++;
    return m && i.components.push({ count: m }), i.newPos = p, d;
  }, equals: function(i, s) {
    return this.options.comparator ? this.options.comparator(i, s) : i === s || this.options.ignoreCase && i.toLowerCase() === s.toLowerCase();
  }, removeEmpty: function(i) {
    for (var s = [], o = 0; o < i.length; o++)
      i[o] && s.push(i[o]);
    return s;
  }, castInput: function(i) {
    return i;
  }, tokenize: function(i) {
    return i.split("");
  }, join: function(i) {
    return i.join("");
  } };
  function r(i, s, o, l, u) {
    for (var h = 0, p = s.length, d = 0, m = 0; h < p; h++) {
      var y = s[h];
      if (y.removed) {
        if (y.value = i.join(l.slice(m, m + y.count)), m += y.count, h && s[h - 1].added) {
          var D = s[h - 1];
          s[h - 1] = s[h], s[h] = D;
        }
      } else {
        if (!y.added && u) {
          var b = o.slice(d, d + y.count);
          b = b.map(function(A, x) {
            var E = l[m + x];
            return E.length > A.length ? E : A;
          }), y.value = i.join(b);
        } else
          y.value = i.join(o.slice(d, d + y.count));
        d += y.count, y.added || (m += y.count);
      }
    }
    var C = s[p - 1];
    return p > 1 && typeof C.value == "string" && (C.added || C.removed) && i.equals("", C.value) && (s[p - 2].value += C.value, s.pop()), s;
  }
  function n(i) {
    return { newPos: i.newPos, components: i.components.slice(0) };
  }
}), kT = Fc((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.diffArrays = i, t.arrayDiff = void 0;
  var e = r(TT());
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  var n = new e.default();
  t.arrayDiff = n, n.tokenize = function(s) {
    return s.slice();
  }, n.join = n.removeEmpty = function(s) {
    return s;
  };
  function i(s, o, l) {
    return n.diff(s, o, l);
  }
}), Bc = Fc((t, e) => {
  var r = new Proxy(String, { get: () => r });
  e.exports = r;
}), jD = {};
Pc(jD, { default: () => WD, shouldHighlight: () => qD });
var qD, WD, FT = ET(() => {
  qD = () => !1, WD = String;
}), PT = Fc((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.codeFrameColumns = d, t.default = m;
  var e = (FT(), wT(jD)), r = i(Bc(), !0);
  function n(y) {
    if (typeof WeakMap != "function")
      return null;
    var D = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap();
    return (n = function(C) {
      return C ? b : D;
    })(y);
  }
  function i(y, D) {
    if (!D && y && y.__esModule)
      return y;
    if (y === null || typeof y != "object" && typeof y != "function")
      return { default: y };
    var b = n(D);
    if (b && b.has(y))
      return b.get(y);
    var C = { __proto__: null }, A = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var x in y)
      if (x !== "default" && Object.prototype.hasOwnProperty.call(y, x)) {
        var E = A ? Object.getOwnPropertyDescriptor(y, x) : null;
        E && (E.get || E.set) ? Object.defineProperty(C, x, E) : C[x] = y[x];
      }
    return C.default = y, b && b.set(y, C), C;
  }
  var s;
  function o(y) {
    return y ? (s != null || (s = new r.default.constructor({ enabled: !0, level: 1 })), s) : r.default;
  }
  var l = !1;
  function u(y) {
    return { gutter: y.grey, marker: y.red.bold, message: y.red.bold };
  }
  var h = /\r\n|[\n\r\u2028\u2029]/;
  function p(y, D, b) {
    let C = Object.assign({ column: 0, line: -1 }, y.start), A = Object.assign({}, C, y.end), { linesAbove: x = 2, linesBelow: E = 3 } = b || {}, k = C.line, w = C.column, T = A.line, P = A.column, M = Math.max(k - (x + 1), 0), N = Math.min(D.length, T + E);
    k === -1 && (M = 0), T === -1 && (N = D.length);
    let L = T - k, j = {};
    if (L)
      for (let X = 0; X <= L; X++) {
        let Q = X + k;
        if (!w)
          j[Q] = !0;
        else if (X === 0) {
          let $ = D[Q - 1].length;
          j[Q] = [w, $ - w + 1];
        } else if (X === L)
          j[Q] = [0, P];
        else {
          let $ = D[Q - X].length;
          j[Q] = [0, $];
        }
      }
    else
      w === P ? w ? j[k] = [w, 0] : j[k] = !0 : j[k] = [w, P - w];
    return { start: M, end: N, markerLines: j };
  }
  function d(y, D, b = {}) {
    let C = (b.highlightCode || b.forceColor) && (0, e.shouldHighlight)(b), A = o(b.forceColor), x = u(A), E = (j, X) => C ? j(X) : X, k = y.split(h), { start: w, end: T, markerLines: P } = p(D, k, b), M = D.start && typeof D.start.column == "number", N = String(T).length, L = (C ? (0, e.default)(y, b) : y).split(h, T).slice(w, T).map((j, X) => {
      let Q = w + 1 + X, $ = ` ${` ${Q}`.slice(-N)} |`, U = P[Q], H = !P[Q + 1];
      if (U) {
        let Z = "";
        if (Array.isArray(U)) {
          let ye = j.slice(0, Math.max(U[0] - 1, 0)).replace(/[^\t]/g, " "), Ee = U[1] || 1;
          Z = [`
 `, E(x.gutter, $.replace(/\d/g, " ")), " ", ye, E(x.marker, "^").repeat(Ee)].join(""), H && b.message && (Z += " " + E(x.message, b.message));
        }
        return [E(x.marker, ">"), E(x.gutter, $), j.length > 0 ? ` ${j}` : "", Z].join("");
      } else
        return ` ${E(x.gutter, $)}${j.length > 0 ? ` ${j}` : ""}`;
    }).join(`
`);
    return b.message && !M && (L = `${" ".repeat(N + 1)}${b.message}
${L}`), C ? A.reset(L) : L;
  }
  function m(y, D, b, C = {}) {
    if (!l) {
      l = !0;
      let A = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      {
        let x = new Error(A);
        x.name = "DeprecationWarning", console.warn(new Error(A));
      }
    }
    return b = Math.max(b, 0), d(y, { start: { column: b, line: D } }, C);
  }
}), UD = {};
Pc(UD, { __debug: () => TP, check: () => wP, doc: () => Tx, format: () => Px, formatWithCursor: () => Fx, getSupportInfo: () => SP, util: () => kx, version: () => tP });
var BT = (t, e, r, n) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
}, Ic = BT, IT = ol(kT(), 1);
function NT(t) {
  let e = t.indexOf("\r");
  return e >= 0 ? t.charAt(e + 1) === `
` ? "crlf" : "cr" : "lf";
}
function kf(t) {
  switch (t) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function HD(t, e) {
  let r;
  switch (e) {
    case `
`:
      r = /\n/g;
      break;
    case "\r":
      r = /\r/g;
      break;
    case `\r
`:
      r = /\r\n/g;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(e)}.`);
  }
  let n = t.match(r);
  return n ? n.length : 0;
}
function MT(t) {
  return Ic(!1, t, /\r\n?/g, `
`);
}
var As = "string", Fi = "array", Es = "cursor", Gn = "indent", Xn = "align", Yn = "trim", nr = "group", Mr = "fill", yr = "if-break", Qn = "indent-if-break", Zn = "line-suffix", ei = "line-suffix-boundary", Pt = "line", Bn = "label", Or = "break-parent", VD = /* @__PURE__ */ new Set([Es, Gn, Xn, Yn, nr, Mr, yr, Qn, Zn, ei, Pt, Bn, Or]);
function OT(t) {
  if (typeof t == "string")
    return As;
  if (Array.isArray(t))
    return Fi;
  if (!t)
    return;
  let { type: e } = t;
  if (VD.has(e))
    return e;
}
var ws = OT, LT = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function _T(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (ws(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = LT([...VD].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`;
}
var $T = class extends Error {
  constructor(r) {
    super(_T(r));
    Vr(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, fo = $T, ay = {};
function RT(t, e, r, n) {
  let i = [t];
  for (; i.length > 0; ) {
    let s = i.pop();
    if (s === ay) {
      r(i.pop());
      continue;
    }
    r && i.push(s, ay);
    let o = ws(s);
    if (!o)
      throw new fo(s);
    if ((e == null ? void 0 : e(s)) !== !1)
      switch (o) {
        case Fi:
        case Mr: {
          let l = o === Fi ? s : s.parts;
          for (let u = l.length, h = u - 1; h >= 0; --h)
            i.push(l[h]);
          break;
        }
        case yr:
          i.push(s.flatContents, s.breakContents);
          break;
        case nr:
          if (n && s.expandedStates)
            for (let l = s.expandedStates.length, u = l - 1; u >= 0; --u)
              i.push(s.expandedStates[u]);
          else
            i.push(s.contents);
          break;
        case Xn:
        case Gn:
        case Qn:
        case Bn:
        case Zn:
          i.push(s.contents);
          break;
        case As:
        case Es:
        case Yn:
        case ei:
        case Pt:
        case Or:
          break;
        default:
          throw new fo(s);
      }
  }
}
var Ff = RT, jT = () => {
}, qT = jT;
function zu(t) {
  return { type: Gn, contents: t };
}
function mo(t, e) {
  return { type: Xn, contents: e, n: t };
}
function zD(t, e = {}) {
  return qT(e.expandedStates), { type: nr, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function WT(t) {
  return mo(Number.NEGATIVE_INFINITY, t);
}
function UT(t) {
  return mo({ type: "root" }, t);
}
function HT(t) {
  return mo(-1, t);
}
function VT(t, e) {
  return zD(t[0], { ...e, expandedStates: t });
}
function JD(t) {
  return { type: Mr, parts: t };
}
function zT(t, e = "", r = {}) {
  return { type: yr, breakContents: t, flatContents: e, groupId: r.groupId };
}
function JT(t, e) {
  return { type: Qn, contents: t, groupId: e.groupId, negate: e.negate };
}
function Vp(t) {
  return { type: Zn, contents: t };
}
var KT = { type: ei }, Nc = { type: Or }, GT = { type: Yn }, Pf = { type: Pt, hard: !0 }, KD = { type: Pt, hard: !0, literal: !0 }, GD = { type: Pt }, XT = { type: Pt, soft: !0 }, ls = [Pf, Nc], XD = [KD, Nc], zp = { type: Es };
function YD(t, e) {
  let r = [];
  for (let n = 0; n < e.length; n++)
    n !== 0 && r.push(t), r.push(e[n]);
  return r;
}
function QD(t, e, r) {
  let n = t;
  if (e > 0) {
    for (let i = 0; i < Math.floor(e / r); ++i)
      n = zu(n);
    n = mo(e % r, n), n = mo(Number.NEGATIVE_INFINITY, n);
  }
  return n;
}
function YT(t, e) {
  return t ? { type: Bn, label: t, contents: e } : e;
}
function jn(t) {
  var e;
  if (!t)
    return "";
  if (Array.isArray(t)) {
    let r = [];
    for (let n of t)
      if (Array.isArray(n))
        r.push(...jn(n));
      else {
        let i = jn(n);
        i !== "" && r.push(i);
      }
    return r;
  }
  return t.type === yr ? { ...t, breakContents: jn(t.breakContents), flatContents: jn(t.flatContents) } : t.type === nr ? { ...t, contents: jn(t.contents), expandedStates: (e = t.expandedStates) == null ? void 0 : e.map(jn) } : t.type === Mr ? { type: "fill", parts: t.parts.map(jn) } : t.contents ? { ...t, contents: jn(t.contents) } : t;
}
function QT(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Set();
  return n(jn(t));
  function n(s, o, l) {
    var u, h;
    if (typeof s == "string")
      return JSON.stringify(s);
    if (Array.isArray(s)) {
      let p = s.map(n).filter(Boolean);
      return p.length === 1 ? p[0] : `[${p.join(", ")}]`;
    }
    if (s.type === Pt) {
      let p = ((u = l == null ? void 0 : l[o + 1]) == null ? void 0 : u.type) === Or;
      return s.literal ? p ? "literalline" : "literallineWithoutBreakParent" : s.hard ? p ? "hardline" : "hardlineWithoutBreakParent" : s.soft ? "softline" : "line";
    }
    if (s.type === Or)
      return ((h = l == null ? void 0 : l[o - 1]) == null ? void 0 : h.type) === Pt && l[o - 1].hard ? void 0 : "breakParent";
    if (s.type === Yn)
      return "trim";
    if (s.type === Gn)
      return "indent(" + n(s.contents) + ")";
    if (s.type === Xn)
      return s.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n(s.contents) + ")" : s.n < 0 ? "dedent(" + n(s.contents) + ")" : s.n.type === "root" ? "markAsRoot(" + n(s.contents) + ")" : "align(" + JSON.stringify(s.n) + ", " + n(s.contents) + ")";
    if (s.type === yr)
      return "ifBreak(" + n(s.breakContents) + (s.flatContents ? ", " + n(s.flatContents) : "") + (s.groupId ? (s.flatContents ? "" : ', ""') + `, { groupId: ${i(s.groupId)} }` : "") + ")";
    if (s.type === Qn) {
      let p = [];
      s.negate && p.push("negate: true"), s.groupId && p.push(`groupId: ${i(s.groupId)}`);
      let d = p.length > 0 ? `, { ${p.join(", ")} }` : "";
      return `indentIfBreak(${n(s.contents)}${d})`;
    }
    if (s.type === nr) {
      let p = [];
      s.break && s.break !== "propagated" && p.push("shouldBreak: true"), s.id && p.push(`id: ${i(s.id)}`);
      let d = p.length > 0 ? `, { ${p.join(", ")} }` : "";
      return s.expandedStates ? `conditionalGroup([${s.expandedStates.map((m) => n(m)).join(",")}]${d})` : `group(${n(s.contents)}${d})`;
    }
    if (s.type === Mr)
      return `fill([${s.parts.map((p) => n(p)).join(", ")}])`;
    if (s.type === Zn)
      return "lineSuffix(" + n(s.contents) + ")";
    if (s.type === ei)
      return "lineSuffixBoundary";
    if (s.type === Bn)
      return `label(${JSON.stringify(s.label)}, ${n(s.contents)})`;
    throw new Error("Unknown doc type " + s.type);
  }
  function i(s) {
    if (typeof s != "symbol")
      return JSON.stringify(String(s));
    if (s in e)
      return e[s];
    let o = s.description || "symbol";
    for (let l = 0; ; l++) {
      let u = o + (l > 0 ? ` #${l}` : "");
      if (!r.has(u))
        return r.add(u), e[s] = `Symbol.for(${JSON.stringify(u)})`;
    }
  }
}
var ZT = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, yt = ZT, ek = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function tk(t) {
  return t === 12288 || t >= 65281 && t <= 65376 || t >= 65504 && t <= 65510;
}
function rk(t) {
  return t >= 4352 && t <= 4447 || t === 8986 || t === 8987 || t === 9001 || t === 9002 || t >= 9193 && t <= 9196 || t === 9200 || t === 9203 || t === 9725 || t === 9726 || t === 9748 || t === 9749 || t >= 9800 && t <= 9811 || t === 9855 || t === 9875 || t === 9889 || t === 9898 || t === 9899 || t === 9917 || t === 9918 || t === 9924 || t === 9925 || t === 9934 || t === 9940 || t === 9962 || t === 9970 || t === 9971 || t === 9973 || t === 9978 || t === 9981 || t === 9989 || t === 9994 || t === 9995 || t === 10024 || t === 10060 || t === 10062 || t >= 10067 && t <= 10069 || t === 10071 || t >= 10133 && t <= 10135 || t === 10160 || t === 10175 || t === 11035 || t === 11036 || t === 11088 || t === 11093 || t >= 11904 && t <= 11929 || t >= 11931 && t <= 12019 || t >= 12032 && t <= 12245 || t >= 12272 && t <= 12287 || t >= 12289 && t <= 12350 || t >= 12353 && t <= 12438 || t >= 12441 && t <= 12543 || t >= 12549 && t <= 12591 || t >= 12593 && t <= 12686 || t >= 12688 && t <= 12771 || t >= 12783 && t <= 12830 || t >= 12832 && t <= 12871 || t >= 12880 && t <= 19903 || t >= 19968 && t <= 42124 || t >= 42128 && t <= 42182 || t >= 43360 && t <= 43388 || t >= 44032 && t <= 55203 || t >= 63744 && t <= 64255 || t >= 65040 && t <= 65049 || t >= 65072 && t <= 65106 || t >= 65108 && t <= 65126 || t >= 65128 && t <= 65131 || t >= 94176 && t <= 94180 || t === 94192 || t === 94193 || t >= 94208 && t <= 100343 || t >= 100352 && t <= 101589 || t >= 101632 && t <= 101640 || t >= 110576 && t <= 110579 || t >= 110581 && t <= 110587 || t === 110589 || t === 110590 || t >= 110592 && t <= 110882 || t === 110898 || t >= 110928 && t <= 110930 || t === 110933 || t >= 110948 && t <= 110951 || t >= 110960 && t <= 111355 || t === 126980 || t === 127183 || t === 127374 || t >= 127377 && t <= 127386 || t >= 127488 && t <= 127490 || t >= 127504 && t <= 127547 || t >= 127552 && t <= 127560 || t === 127568 || t === 127569 || t >= 127584 && t <= 127589 || t >= 127744 && t <= 127776 || t >= 127789 && t <= 127797 || t >= 127799 && t <= 127868 || t >= 127870 && t <= 127891 || t >= 127904 && t <= 127946 || t >= 127951 && t <= 127955 || t >= 127968 && t <= 127984 || t === 127988 || t >= 127992 && t <= 128062 || t === 128064 || t >= 128066 && t <= 128252 || t >= 128255 && t <= 128317 || t >= 128331 && t <= 128334 || t >= 128336 && t <= 128359 || t === 128378 || t === 128405 || t === 128406 || t === 128420 || t >= 128507 && t <= 128591 || t >= 128640 && t <= 128709 || t === 128716 || t >= 128720 && t <= 128722 || t >= 128725 && t <= 128727 || t >= 128732 && t <= 128735 || t === 128747 || t === 128748 || t >= 128756 && t <= 128764 || t >= 128992 && t <= 129003 || t === 129008 || t >= 129292 && t <= 129338 || t >= 129340 && t <= 129349 || t >= 129351 && t <= 129535 || t >= 129648 && t <= 129660 || t >= 129664 && t <= 129672 || t >= 129680 && t <= 129725 || t >= 129727 && t <= 129733 || t >= 129742 && t <= 129755 || t >= 129760 && t <= 129768 || t >= 129776 && t <= 129784 || t >= 131072 && t <= 196605 || t >= 196608 && t <= 262141;
}
var nk = (t) => !(tk(t) || rk(t)), ik = /[^\x20-\x7F]/;
function sk(t) {
  if (!t)
    return 0;
  if (!ik.test(t))
    return t.length;
  t = t.replace(ek(), "  ");
  let e = 0;
  for (let r of t) {
    let n = r.codePointAt(0);
    n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (e += nk(n) ? 1 : 2);
  }
  return e;
}
var Bf = sk, ok = (t) => {
  if (Array.isArray(t))
    return t;
  if (t.type !== Mr)
    throw new Error(`Expect doc to be 'array' or '${Mr}'.`);
  return t.parts;
};
function Mc(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return n(t);
  function n(s) {
    if (r.has(s))
      return r.get(s);
    let o = i(s);
    return r.set(s, o), o;
  }
  function i(s) {
    switch (ws(s)) {
      case Fi:
        return e(s.map(n));
      case Mr:
        return e({ ...s, parts: s.parts.map(n) });
      case yr:
        return e({ ...s, breakContents: n(s.breakContents), flatContents: n(s.flatContents) });
      case nr: {
        let { expandedStates: o, contents: l } = s;
        return o ? (o = o.map(n), l = o[0]) : l = n(l), e({ ...s, contents: l, expandedStates: o });
      }
      case Xn:
      case Gn:
      case Qn:
      case Bn:
      case Zn:
        return e({ ...s, contents: n(s.contents) });
      case As:
      case Es:
      case Yn:
      case ei:
      case Pt:
      case Or:
        return e(s);
      default:
        throw new fo(s);
    }
  }
}
function If(t, e, r) {
  let n = r, i = !1;
  function s(o) {
    if (i)
      return !1;
    let l = e(o);
    l !== void 0 && (i = !0, n = l);
  }
  return Ff(t, s), n;
}
function ak(t) {
  if (t.type === nr && t.break || t.type === Pt && t.hard || t.type === Or)
    return !0;
}
function lk(t) {
  return If(t, ak, !1);
}
function ly(t) {
  if (t.length > 0) {
    let e = yt(!1, t, -1);
    !e.expandedStates && !e.break && (e.break = "propagated");
  }
  return null;
}
function uk(t) {
  let e = /* @__PURE__ */ new Set(), r = [];
  function n(s) {
    if (s.type === Or && ly(r), s.type === nr) {
      if (r.push(s), e.has(s))
        return !1;
      e.add(s);
    }
  }
  function i(s) {
    s.type === nr && r.pop().break && ly(r);
  }
  Ff(t, n, i, !0);
}
function ck(t) {
  return t.type === Pt && !t.hard ? t.soft ? "" : " " : t.type === yr ? t.flatContents : t;
}
function hk(t) {
  return Mc(t, ck);
}
function uy(t) {
  for (t = [...t]; t.length >= 2 && yt(!1, t, -2).type === Pt && yt(!1, t, -1).type === Or; )
    t.length -= 2;
  if (t.length > 0) {
    let e = va(yt(!1, t, -1));
    t[t.length - 1] = e;
  }
  return t;
}
function va(t) {
  switch (ws(t)) {
    case Xn:
    case Gn:
    case Qn:
    case nr:
    case Zn:
    case Bn: {
      let e = va(t.contents);
      return { ...t, contents: e };
    }
    case yr:
      return { ...t, breakContents: va(t.breakContents), flatContents: va(t.flatContents) };
    case Mr:
      return { ...t, parts: uy(t.parts) };
    case Fi:
      return uy(t);
    case As:
      return t.replace(/[\n\r]*$/, "");
    case Es:
    case Yn:
    case ei:
    case Pt:
    case Or:
      break;
    default:
      throw new fo(t);
  }
  return t;
}
function ZD(t) {
  return va(dk(t));
}
function pk(t) {
  switch (ws(t)) {
    case Mr:
      if (t.parts.every((e) => e === ""))
        return "";
      break;
    case nr:
      if (!t.contents && !t.id && !t.break && !t.expandedStates)
        return "";
      if (t.contents.type === nr && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates)
        return t.contents;
      break;
    case Xn:
    case Gn:
    case Qn:
    case Zn:
      if (!t.contents)
        return "";
      break;
    case yr:
      if (!t.flatContents && !t.breakContents)
        return "";
      break;
    case Fi: {
      let e = [];
      for (let r of t) {
        if (!r)
          continue;
        let [n, ...i] = Array.isArray(r) ? r : [r];
        typeof n == "string" && typeof yt(!1, e, -1) == "string" ? e[e.length - 1] += n : e.push(n), e.push(...i);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case As:
    case Es:
    case Yn:
    case ei:
    case Pt:
    case Bn:
    case Or:
      break;
    default:
      throw new fo(t);
  }
  return t;
}
function dk(t) {
  return Mc(t, (e) => pk(e));
}
function fk(t, e = XD) {
  return Mc(t, (r) => typeof r == "string" ? YD(e, r.split(`
`)) : r);
}
function mk(t) {
  if (t.type === Pt)
    return !0;
}
function gk(t) {
  return If(t, mk, !1);
}
function ex(t, e) {
  return t.type === Bn ? { ...t, contents: e(t.contents) } : e(t);
}
var Zt = Symbol("MODE_BREAK"), dn = Symbol("MODE_FLAT"), Ca = Symbol("cursor");
function tx() {
  return { value: "", length: 0, queue: [] };
}
function yk(t, e) {
  return Jp(t, { type: "indent" }, e);
}
function Dk(t, e, r) {
  return e === Number.NEGATIVE_INFINITY ? t.root || tx() : e < 0 ? Jp(t, { type: "dedent" }, r) : e ? e.type === "root" ? { ...t, root: t } : Jp(t, { type: typeof e == "string" ? "stringAlign" : "numberAlign", n: e }, r) : t;
}
function Jp(t, e, r) {
  let n = e.type === "dedent" ? t.queue.slice(0, -1) : [...t.queue, e], i = "", s = 0, o = 0, l = 0;
  for (let D of n)
    switch (D.type) {
      case "indent":
        p(), r.useTabs ? u(1) : h(r.tabWidth);
        break;
      case "stringAlign":
        p(), i += D.n, s += D.n.length;
        break;
      case "numberAlign":
        o += 1, l += D.n;
        break;
      default:
        throw new Error(`Unexpected type '${D.type}'`);
    }
  return m(), { ...t, value: i, length: s, queue: n };
  function u(D) {
    i += "	".repeat(D), s += r.tabWidth * D;
  }
  function h(D) {
    i += " ".repeat(D), s += D;
  }
  function p() {
    r.useTabs ? d() : m();
  }
  function d() {
    o > 0 && u(o), y();
  }
  function m() {
    l > 0 && h(l), y();
  }
  function y() {
    o = 0, l = 0;
  }
}
function Kp(t) {
  let e = 0, r = 0, n = t.length;
  e:
    for (; n--; ) {
      let i = t[n];
      if (i === Ca) {
        r++;
        continue;
      }
      for (let s = i.length - 1; s >= 0; s--) {
        let o = i[s];
        if (o === " " || o === "	")
          e++;
        else {
          t[n] = i.slice(0, s + 1);
          break e;
        }
      }
    }
  if (e > 0 || r > 0)
    for (t.length = n + 1; r-- > 0; )
      t.push(Ca);
  return e;
}
function Wl(t, e, r, n, i, s) {
  if (r === Number.POSITIVE_INFINITY)
    return !0;
  let o = e.length, l = [t], u = [];
  for (; r >= 0; ) {
    if (l.length === 0) {
      if (o === 0)
        return !0;
      l.push(e[--o]);
      continue;
    }
    let { mode: h, doc: p } = l.pop();
    switch (ws(p)) {
      case As:
        u.push(p), r -= Bf(p);
        break;
      case Fi:
      case Mr: {
        let d = ok(p);
        for (let m = d.length - 1; m >= 0; m--)
          l.push({ mode: h, doc: d[m] });
        break;
      }
      case Gn:
      case Xn:
      case Qn:
      case Bn:
        l.push({ mode: h, doc: p.contents });
        break;
      case Yn:
        r += Kp(u);
        break;
      case nr: {
        if (s && p.break)
          return !1;
        let d = p.break ? Zt : h, m = p.expandedStates && d === Zt ? yt(!1, p.expandedStates, -1) : p.contents;
        l.push({ mode: d, doc: m });
        break;
      }
      case yr: {
        let d = (p.groupId ? i[p.groupId] || dn : h) === Zt ? p.breakContents : p.flatContents;
        d && l.push({ mode: h, doc: d });
        break;
      }
      case Pt:
        if (h === Zt || p.hard)
          return !0;
        p.soft || (u.push(" "), r--);
        break;
      case Zn:
        n = !0;
        break;
      case ei:
        if (n)
          return !1;
        break;
    }
  }
  return !1;
}
function Oc(t, e) {
  let r = {}, n = e.printWidth, i = kf(e.endOfLine), s = 0, o = [{ ind: tx(), mode: Zt, doc: t }], l = [], u = !1, h = [], p = 0;
  for (uk(t); o.length > 0; ) {
    let { ind: m, mode: y, doc: D } = o.pop();
    switch (ws(D)) {
      case As: {
        let b = i !== `
` ? Ic(!1, D, `
`, i) : D;
        l.push(b), o.length > 0 && (s += Bf(b));
        break;
      }
      case Fi:
        for (let b = D.length - 1; b >= 0; b--)
          o.push({ ind: m, mode: y, doc: D[b] });
        break;
      case Es:
        if (p >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        l.push(Ca), p++;
        break;
      case Gn:
        o.push({ ind: yk(m, e), mode: y, doc: D.contents });
        break;
      case Xn:
        o.push({ ind: Dk(m, D.n, e), mode: y, doc: D.contents });
        break;
      case Yn:
        s -= Kp(l);
        break;
      case nr:
        switch (y) {
          case dn:
            if (!u) {
              o.push({ ind: m, mode: D.break ? Zt : dn, doc: D.contents });
              break;
            }
          case Zt: {
            u = !1;
            let b = { ind: m, mode: dn, doc: D.contents }, C = n - s, A = h.length > 0;
            if (!D.break && Wl(b, o, C, A, r))
              o.push(b);
            else if (D.expandedStates) {
              let x = yt(!1, D.expandedStates, -1);
              if (D.break) {
                o.push({ ind: m, mode: Zt, doc: x });
                break;
              } else
                for (let E = 1; E < D.expandedStates.length + 1; E++)
                  if (E >= D.expandedStates.length) {
                    o.push({ ind: m, mode: Zt, doc: x });
                    break;
                  } else {
                    let k = D.expandedStates[E], w = { ind: m, mode: dn, doc: k };
                    if (Wl(w, o, C, A, r)) {
                      o.push(w);
                      break;
                    }
                  }
            } else
              o.push({ ind: m, mode: Zt, doc: D.contents });
            break;
          }
        }
        D.id && (r[D.id] = yt(!1, o, -1).mode);
        break;
      case Mr: {
        let b = n - s, { parts: C } = D;
        if (C.length === 0)
          break;
        let [A, x] = C, E = { ind: m, mode: dn, doc: A }, k = { ind: m, mode: Zt, doc: A }, w = Wl(E, [], b, h.length > 0, r, !0);
        if (C.length === 1) {
          w ? o.push(E) : o.push(k);
          break;
        }
        let T = { ind: m, mode: dn, doc: x }, P = { ind: m, mode: Zt, doc: x };
        if (C.length === 2) {
          w ? o.push(T, E) : o.push(P, k);
          break;
        }
        C.splice(0, 2);
        let M = { ind: m, mode: y, doc: JD(C) }, N = C[0];
        Wl({ ind: m, mode: dn, doc: [A, x, N] }, [], b, h.length > 0, r, !0) ? o.push(M, T, E) : w ? o.push(M, P, E) : o.push(M, P, k);
        break;
      }
      case yr:
      case Qn: {
        let b = D.groupId ? r[D.groupId] : y;
        if (b === Zt) {
          let C = D.type === yr ? D.breakContents : D.negate ? D.contents : zu(D.contents);
          C && o.push({ ind: m, mode: y, doc: C });
        }
        if (b === dn) {
          let C = D.type === yr ? D.flatContents : D.negate ? zu(D.contents) : D.contents;
          C && o.push({ ind: m, mode: y, doc: C });
        }
        break;
      }
      case Zn:
        h.push({ ind: m, mode: y, doc: D.contents });
        break;
      case ei:
        h.length > 0 && o.push({ ind: m, mode: y, doc: Pf });
        break;
      case Pt:
        switch (y) {
          case dn:
            if (D.hard)
              u = !0;
            else {
              D.soft || (l.push(" "), s += 1);
              break;
            }
          case Zt:
            if (h.length > 0) {
              o.push({ ind: m, mode: y, doc: D }, ...h.reverse()), h.length = 0;
              break;
            }
            D.literal ? m.root ? (l.push(i, m.root.value), s = m.root.length) : (l.push(i), s = 0) : (s -= Kp(l), l.push(i + m.value), s = m.length);
            break;
        }
        break;
      case Bn:
        o.push({ ind: m, mode: y, doc: D.contents });
        break;
      case Or:
        break;
      default:
        throw new fo(D);
    }
    o.length === 0 && h.length > 0 && (o.push(...h.reverse()), h.length = 0);
  }
  let d = l.indexOf(Ca);
  if (d !== -1) {
    let m = l.indexOf(Ca, d + 1), y = l.slice(0, d).join(""), D = l.slice(d + 1, m).join(""), b = l.slice(m + 1).join("");
    return { formatted: y + D + b, cursorNodeStart: y.length, cursorNodeText: D };
  }
  return { formatted: l.join("") };
}
function xk(t, e, r = 0) {
  let n = 0;
  for (let i = r; i < t.length; ++i)
    t[i] === "	" ? n = n + e - n % e : n++;
  return n;
}
var Nf = xk, Su, Gp, ha, Tu, bk = class {
  constructor(e) {
    oy(this, Su), oy(this, ha), this.stack = [e];
  }
  get key() {
    let { stack: e, siblings: r } = this;
    return yt(!1, e, r === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : yt(!1, this.stack, -2);
  }
  get node() {
    return yt(!1, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: e } = this, r = yt(!1, e, -3);
    return Array.isArray(r) ? r : null;
  }
  get next() {
    let { siblings: e } = this;
    return e === null ? null : e[this.index + 1];
  }
  get previous() {
    let { siblings: e } = this;
    return e === null ? null : e[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: e, index: r } = this;
    return e !== null && r === e.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...Xo(this, ha, Tu).call(this)];
  }
  getName() {
    let { stack: e } = this, { length: r } = e;
    return r > 1 ? yt(!1, e, -2) : null;
  }
  getValue() {
    return yt(!1, this.stack, -1);
  }
  getNode(e = 0) {
    let r = Xo(this, Su, Gp).call(this, e);
    return r === -1 ? null : this.stack[r];
  }
  getParentNode(e = 0) {
    return this.getNode(e + 1);
  }
  call(e, ...r) {
    let { stack: n } = this, { length: i } = n, s = yt(!1, n, -1);
    for (let o of r)
      s = s[o], n.push(o, s);
    try {
      return e(this);
    } finally {
      n.length = i;
    }
  }
  callParent(e, r = 0) {
    let n = Xo(this, Su, Gp).call(this, r + 1), i = this.stack.splice(n + 1);
    try {
      return e(this);
    } finally {
      this.stack.push(...i);
    }
  }
  each(e, ...r) {
    let { stack: n } = this, { length: i } = n, s = yt(!1, n, -1);
    for (let o of r)
      s = s[o], n.push(o, s);
    try {
      for (let o = 0; o < s.length; ++o)
        n.push(o, s[o]), e(this, o, s), n.length -= 2;
    } finally {
      n.length = i;
    }
  }
  map(e, ...r) {
    let n = [];
    return this.each((i, s, o) => {
      n[s] = e(i, s, o);
    }, ...r), n;
  }
  match(...e) {
    let r = this.stack.length - 1, n = null, i = this.stack[r--];
    for (let s of e) {
      if (i === void 0)
        return !1;
      let o = null;
      if (typeof n == "number" && (o = n, n = this.stack[r--], i = this.stack[r--]), s && !s(i, n, o))
        return !1;
      n = this.stack[r--], i = this.stack[r--];
    }
    return !0;
  }
  findAncestor(e) {
    for (let r of Xo(this, ha, Tu).call(this))
      if (e(r))
        return r;
  }
  hasAncestor(e) {
    for (let r of Xo(this, ha, Tu).call(this))
      if (e(r))
        return !0;
    return !1;
  }
};
Su = /* @__PURE__ */ new WeakSet(), Gp = function(t) {
  let { stack: e } = this;
  for (let r = e.length - 1; r >= 0; r -= 2)
    if (!Array.isArray(e[r]) && --t < 0)
      return r;
  return -1;
}, ha = /* @__PURE__ */ new WeakSet(), Tu = function* () {
  let { stack: t } = this;
  for (let e = t.length - 3; e >= 0; e -= 2) {
    let r = t[e];
    Array.isArray(r) || (yield r);
  }
};
var vk = bk, rx = new Proxy(() => {
}, { get: () => rx }), Xp = rx;
function Ck(t) {
  return t !== null && typeof t == "object";
}
var Ak = Ck;
function* nx(t, e) {
  let { getVisitorKeys: r, filter: n = () => !0 } = e, i = (s) => Ak(s) && n(s);
  for (let s of r(t)) {
    let o = t[s];
    if (Array.isArray(o))
      for (let l of o)
        i(l) && (yield l);
    else
      i(o) && (yield o);
  }
}
function* Ek(t, e) {
  let r = [t];
  for (let n = 0; n < r.length; n++) {
    let i = r[n];
    for (let s of nx(i, e))
      yield s, r.push(s);
  }
}
function al(t) {
  return (e, r, n) => {
    let i = !!(n != null && n.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, o = r;
    for (; o >= 0 && o < s; ) {
      let l = e.charAt(o);
      if (t instanceof RegExp) {
        if (!t.test(l))
          return o;
      } else if (!t.includes(l))
        return o;
      i ? o-- : o++;
    }
    return o === -1 || o === s ? o : !1;
  };
}
var wk = al(/\s/), Pi = al(" 	"), ix = al(",; 	"), sx = al(/[^\n\r]/);
function Sk(t, e, r) {
  let n = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let i = t.charAt(e);
  if (n) {
    if (t.charAt(e - 1) === "\r" && i === `
`)
      return e - 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e - 1;
  } else {
    if (i === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e + 1;
  }
  return e;
}
var cs = Sk;
function Tk(t, e, r = {}) {
  let n = Pi(t, r.backwards ? e - 1 : e, r), i = cs(t, n, r);
  return n !== i;
}
var wi = Tk;
function kk(t) {
  return Array.isArray(t) && t.length > 0;
}
var Fk = kk, ox = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]), Pk = (t) => Object.keys(t).filter((e) => !ox.has(e));
function Bk(t) {
  return t ? (e) => t(e, ox) : Pk;
}
var Lc = Bk;
function Ik(t) {
  let e = t.type || t.kind || "(unknown type)", r = String(t.name || t.id && (typeof t.id == "object" ? t.id.name : t.id) || t.key && (typeof t.key == "object" ? t.key.name : t.key) || t.value && (typeof t.value == "object" ? "" : String(t.value)) || t.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + ""), e + (r ? " " + r : "");
}
function Mf(t, e) {
  (t.comments ?? (t.comments = [])).push(e), e.printed = !1, e.nodeDescription = Ik(t);
}
function eo(t, e) {
  e.leading = !0, e.trailing = !1, Mf(t, e);
}
function Yi(t, e, r) {
  e.leading = !1, e.trailing = !1, r && (e.marker = r), Mf(t, e);
}
function to(t, e) {
  e.leading = !1, e.trailing = !0, Mf(t, e);
}
var Hh = /* @__PURE__ */ new WeakMap();
function Of(t, e) {
  if (Hh.has(t))
    return Hh.get(t);
  let { printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: i }, locStart: s, locEnd: o } = e;
  if (!n)
    return [];
  let l = ((r == null ? void 0 : r(t, e)) ?? [...nx(t, { getVisitorKeys: Lc(i) })]).flatMap((u) => n(u) ? [u] : Of(u, e));
  return l.sort((u, h) => s(u) - s(h) || o(u) - o(h)), Hh.set(t, l), l;
}
function ax(t, e, r, n) {
  let { locStart: i, locEnd: s } = r, o = i(e), l = s(e), u = Of(t, r), h, p, d = 0, m = u.length;
  for (; d < m; ) {
    let y = d + m >> 1, D = u[y], b = i(D), C = s(D);
    if (b <= o && l <= C)
      return ax(D, e, r, D);
    if (C <= o) {
      h = D, d = y + 1;
      continue;
    }
    if (l <= b) {
      p = D, m = y;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((n == null ? void 0 : n.type) === "TemplateLiteral") {
    let { quasis: y } = n, D = zh(y, e, r);
    h && zh(y, h, r) !== D && (h = null), p && zh(y, p, r) !== D && (p = null);
  }
  return { enclosingNode: n, precedingNode: h, followingNode: p };
}
var Vh = () => !1;
function Nk(t, e) {
  let { comments: r } = t;
  if (delete t.comments, !Fk(r) || !e.printer.canAttachComment)
    return;
  let n = [], { locStart: i, locEnd: s, printer: { experimentalFeatures: { avoidAstMutation: o = !1 } = {}, handleComments: l = {} }, originalText: u } = e, { ownLine: h = Vh, endOfLine: p = Vh, remaining: d = Vh } = l, m = r.map((y, D) => ({ ...ax(t, y, e), comment: y, text: u, options: e, ast: t, isLastComment: r.length - 1 === D }));
  for (let [y, D] of m.entries()) {
    let { comment: b, precedingNode: C, enclosingNode: A, followingNode: x, text: E, options: k, ast: w, isLastComment: T } = D;
    if (k.parser === "json" || k.parser === "json5" || k.parser === "jsonc" || k.parser === "__js_expression" || k.parser === "__ts_expression" || k.parser === "__vue_expression" || k.parser === "__vue_ts_expression") {
      if (i(b) - i(w) <= 0) {
        eo(w, b);
        continue;
      }
      if (s(b) - s(w) >= 0) {
        to(w, b);
        continue;
      }
    }
    let P;
    if (o ? P = [D] : (b.enclosingNode = A, b.precedingNode = C, b.followingNode = x, P = [b, E, k, w, T]), Mk(E, k, m, y))
      b.placement = "ownLine", h(...P) || (x ? eo(x, b) : C ? to(C, b) : Yi(A || w, b));
    else if (Ok(E, k, m, y))
      b.placement = "endOfLine", p(...P) || (C ? to(C, b) : x ? eo(x, b) : Yi(A || w, b));
    else if (b.placement = "remaining", !d(...P))
      if (C && x) {
        let M = n.length;
        M > 0 && n[M - 1].followingNode !== x && cy(n, k), n.push(D);
      } else
        C ? to(C, b) : x ? eo(x, b) : Yi(A || w, b);
  }
  if (cy(n, e), !o)
    for (let y of r)
      delete y.precedingNode, delete y.enclosingNode, delete y.followingNode;
}
var lx = (t) => !/[\S\n\u2028\u2029]/.test(t);
function Mk(t, e, r, n) {
  let { comment: i, precedingNode: s } = r[n], { locStart: o, locEnd: l } = e, u = o(i);
  if (s)
    for (let h = n - 1; h >= 0; h--) {
      let { comment: p, precedingNode: d } = r[h];
      if (d !== s || !lx(t.slice(l(p), u)))
        break;
      u = o(p);
    }
  return wi(t, u, { backwards: !0 });
}
function Ok(t, e, r, n) {
  let { comment: i, followingNode: s } = r[n], { locStart: o, locEnd: l } = e, u = l(i);
  if (s)
    for (let h = n + 1; h < r.length; h++) {
      let { comment: p, followingNode: d } = r[h];
      if (d !== s || !lx(t.slice(u, o(p))))
        break;
      u = l(p);
    }
  return wi(t, u);
}
function cy(t, e) {
  var r, n;
  let i = t.length;
  if (i === 0)
    return;
  let { precedingNode: s, followingNode: o } = t[0], l = e.locStart(o), u;
  for (u = i; u > 0; --u) {
    let { comment: h, precedingNode: p, followingNode: d } = t[u - 1];
    Xp.strictEqual(p, s), Xp.strictEqual(d, o);
    let m = e.originalText.slice(e.locEnd(h), l);
    if (((n = (r = e.printer).isGap) == null ? void 0 : n.call(r, m, e)) ?? /^[\s(]*$/.test(m))
      l = e.locStart(h);
    else
      break;
  }
  for (let [h, { comment: p }] of t.entries())
    h < u ? to(s, p) : eo(o, p);
  for (let h of [s, o])
    h.comments && h.comments.length > 1 && h.comments.sort((p, d) => e.locStart(p) - e.locStart(d));
  t.length = 0;
}
function zh(t, e, r) {
  let n = r.locStart(e) - 1;
  for (let i = 1; i < t.length; ++i)
    if (n < r.locStart(t[i]))
      return i - 1;
  return 0;
}
function Lk(t, e) {
  let r = e - 1;
  r = Pi(t, r, { backwards: !0 }), r = cs(t, r, { backwards: !0 }), r = Pi(t, r, { backwards: !0 });
  let n = cs(t, r, { backwards: !0 });
  return r !== n;
}
var Lf = Lk;
function ux(t, e) {
  let r = t.node;
  return r.printed = !0, e.printer.printComment(t, e);
}
function _k(t, e) {
  var r;
  let n = t.node, i = [ux(t, e)], { printer: s, originalText: o, locStart: l, locEnd: u } = e;
  if ((r = s.isBlockComment) != null && r.call(s, n)) {
    let p = wi(o, u(n)) ? wi(o, l(n), { backwards: !0 }) ? ls : GD : " ";
    i.push(p);
  } else
    i.push(ls);
  let h = cs(o, Pi(o, u(n)));
  return h !== !1 && wi(o, h) && i.push(ls), i;
}
function $k(t, e, r) {
  var n;
  let i = t.node, s = ux(t, e), { printer: o, originalText: l, locStart: u } = e, h = (n = o.isBlockComment) == null ? void 0 : n.call(o, i);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || wi(l, u(i), { backwards: !0 })) {
    let p = Lf(l, u(i));
    return { doc: Vp([ls, p ? ls : "", s]), isBlock: h, hasLineSuffix: !0 };
  }
  return !h || r != null && r.hasLineSuffix ? { doc: [Vp([" ", s]), Nc], isBlock: h, hasLineSuffix: !0 } : { doc: [" ", s], isBlock: h, hasLineSuffix: !1 };
}
function Rk(t, e) {
  let r = t.node;
  if (!r)
    return {};
  let n = e[Symbol.for("printedComments")];
  if ((r.comments || []).filter((l) => !n.has(l)).length === 0)
    return { leading: "", trailing: "" };
  let i = [], s = [], o;
  return t.each(() => {
    let l = t.node;
    if (n != null && n.has(l))
      return;
    let { leading: u, trailing: h } = l;
    u ? i.push(_k(t, e)) : h && (o = $k(t, e, o), s.push(o.doc));
  }, "comments"), { leading: i, trailing: s };
}
function jk(t, e, r) {
  let { leading: n, trailing: i } = Rk(t, r);
  return !n && !i ? e : ex(e, (s) => [n, s, i]);
}
function qk(t) {
  let { [Symbol.for("comments")]: e, [Symbol.for("printedComments")]: r } = t;
  for (let n of e) {
    if (!n.printed && !r.has(n))
      throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
    delete n.printed;
  }
}
var cx = class extends Error {
  constructor() {
    super(...arguments);
    Vr(this, "name", "ConfigError");
  }
}, hy = class extends Error {
  constructor() {
    super(...arguments);
    Vr(this, "name", "UndefinedParserError");
  }
}, Wk = { cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (t) => typeof t == "string" || typeof t == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }] }, plugins: { type: "path", array: !0, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (t) => typeof t == "string" || typeof t == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: !1, description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: !1, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function hx({ plugins: t = [], showDeprecated: e = !1 } = {}) {
  let r = t.flatMap((i) => i.languages ?? []), n = [];
  for (let i of Hk(Object.assign({}, ...t.map(({ options: s }) => s), Wk)))
    !e && i.deprecated || (Array.isArray(i.choices) && (e || (i.choices = i.choices.filter((s) => !s.deprecated)), i.name === "parser" && (i.choices = [...i.choices, ...Uk(i.choices, r, t)])), i.pluginDefaults = Object.fromEntries(t.filter((s) => {
      var o;
      return ((o = s.defaultOptions) == null ? void 0 : o[i.name]) !== void 0;
    }).map((s) => [s.name, s.defaultOptions[i.name]])), n.push(i));
  return { languages: r, options: n };
}
function* Uk(t, e, r) {
  let n = new Set(t.map((i) => i.value));
  for (let i of e)
    if (i.parsers) {
      for (let s of i.parsers)
        if (!n.has(s)) {
          n.add(s);
          let o = r.find((u) => u.parsers && Object.prototype.hasOwnProperty.call(u.parsers, s)), l = i.name;
          o != null && o.name && (l += ` (plugin: ${o.name})`), yield { value: s, description: l };
        }
    }
}
function Hk(t) {
  let e = [];
  for (let [r, n] of Object.entries(t)) {
    let i = { name: r, ...n };
    Array.isArray(i.default) && (i.default = yt(!1, i.default, -1).value), e.push(i);
  }
  return e;
}
var Vk = (t) => String(t).split(/[/\\]/).pop();
function py(t, e) {
  if (!e)
    return;
  let r = Vk(e).toLowerCase();
  return t.find(({ filenames: n }) => n == null ? void 0 : n.some((i) => i.toLowerCase() === r)) ?? t.find(({ extensions: n }) => n == null ? void 0 : n.some((i) => r.endsWith(i)));
}
function zk(t, e) {
  if (e)
    return t.find(({ name: r }) => r.toLowerCase() === e) ?? t.find(({ aliases: r }) => r == null ? void 0 : r.includes(e)) ?? t.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${e}`));
}
function Jk(t, e) {
  let r = t.plugins.flatMap((i) => i.languages ?? []), n = zk(r, e.language) ?? py(r, e.physicalFile) ?? py(r, e.file) ?? (e.physicalFile, void 0);
  return n == null ? void 0 : n.parsers[0];
}
var Kk = Jk, ro = { key: (t) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(t) ? t : JSON.stringify(t), value(t) {
  if (t === null || typeof t != "object")
    return JSON.stringify(t);
  if (Array.isArray(t))
    return `[${t.map((r) => ro.value(r)).join(", ")}]`;
  let e = Object.keys(t);
  return e.length === 0 ? "{}" : `{ ${e.map((r) => `${ro.key(r)}: ${ro.value(t[r])}`).join(", ")} }`;
}, pair: ({ key: t, value: e }) => ro.value({ [t]: e }) }, dy = ol(Bc(), 1), Gk = (t, e, { descriptor: r }) => {
  let n = [`${dy.default.yellow(typeof t == "string" ? r.key(t) : r.pair(t))} is deprecated`];
  return e && n.push(`we now treat it as ${dy.default.blue(typeof e == "string" ? r.key(e) : r.pair(e))}`), n.join("; ") + ".";
}, no = ol(Bc(), 1), px = Symbol.for("vnopts.VALUE_NOT_EXIST"), ku = Symbol.for("vnopts.VALUE_UNCHANGED"), fy = " ".repeat(2), Xk = (t, e, r) => {
  let { text: n, list: i } = r.normalizeExpectedResult(r.schemas[t].expected(r)), s = [];
  return n && s.push(my(t, e, n, r.descriptor)), i && s.push([my(t, e, i.title, r.descriptor)].concat(i.values.map((o) => dx(o, r.loggerPrintWidth))).join(`
`)), fx(s, r.loggerPrintWidth);
};
function my(t, e, r, n) {
  return [`Invalid ${no.default.red(n.key(t))} value.`, `Expected ${no.default.blue(r)},`, `but received ${e === px ? no.default.gray("nothing") : no.default.red(n.value(e))}.`].join(" ");
}
function dx({ text: t, list: e }, r) {
  let n = [];
  return t && n.push(`- ${no.default.blue(t)}`), e && n.push([`- ${no.default.blue(e.title)}:`].concat(e.values.map((i) => dx(i, r - fy.length).replace(/^|\n/g, `$&${fy}`))).join(`
`)), fx(n, r);
}
function fx(t, e) {
  if (t.length === 1)
    return t[0];
  let [r, n] = t, [i, s] = t.map((o) => o.split(`
`, 1)[0].length);
  return i > e && i > s ? n : r;
}
var gy = ol(Bc(), 1), Jh = [], yy = [];
function Yk(t, e) {
  if (t === e)
    return 0;
  let r = t;
  t.length > e.length && (t = e, e = r);
  let n = t.length, i = e.length;
  for (; n > 0 && t.charCodeAt(~-n) === e.charCodeAt(~-i); )
    n--, i--;
  let s = 0;
  for (; s < n && t.charCodeAt(s) === e.charCodeAt(s); )
    s++;
  if (n -= s, i -= s, n === 0)
    return i;
  let o, l, u, h, p = 0, d = 0;
  for (; p < n; )
    yy[p] = t.charCodeAt(s + p), Jh[p] = ++p;
  for (; d < i; )
    for (o = e.charCodeAt(s + d), u = d++, l = d, p = 0; p < n; p++)
      h = o === yy[p] ? u : u + 1, u = Jh[p], l = Jh[p] = u > l ? h > l ? l + 1 : h : h > u ? u + 1 : h;
  return l;
}
var mx = (t, e, { descriptor: r, logger: n, schemas: i }) => {
  let s = [`Ignored unknown option ${gy.default.yellow(r.pair({ key: t, value: e }))}.`], o = Object.keys(i).sort().find((l) => Yk(t, l) < 3);
  o && s.push(`Did you mean ${gy.default.blue(r.key(o))}?`), n.warn(s.join(" "));
}, Qk = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function Zk(t, e) {
  let r = new t(e), n = Object.create(r);
  for (let i of Qk)
    i in e && (n[i] = eF(e[i], r, ji.prototype[i].length));
  return n;
}
var ji = class {
  static create(e) {
    return Zk(this, e);
  }
  constructor(e) {
    this.name = e.name;
  }
  default(e) {
  }
  expected(e) {
    return "nothing";
  }
  validate(e, r) {
    return !1;
  }
  deprecated(e, r) {
    return !1;
  }
  forward(e, r) {
  }
  redirect(e, r) {
  }
  overlap(e, r, n) {
    return e;
  }
  preprocess(e, r) {
    return e;
  }
  postprocess(e, r) {
    return ku;
  }
};
function eF(t, e, r) {
  return typeof t == "function" ? (...n) => t(...n.slice(0, r - 1), e, ...n.slice(r - 1)) : () => t;
}
var tF = class extends ji {
  constructor(e) {
    super(e), this._sourceName = e.sourceName;
  }
  expected(e) {
    return e.schemas[this._sourceName].expected(e);
  }
  validate(e, r) {
    return r.schemas[this._sourceName].validate(e, r);
  }
  redirect(e, r) {
    return this._sourceName;
  }
}, rF = class extends ji {
  expected() {
    return "anything";
  }
  validate() {
    return !0;
  }
}, nF = class extends ji {
  constructor({ valueSchema: e, name: r = e.name, ...n }) {
    super({ ...n, name: r }), this._valueSchema = e;
  }
  expected(e) {
    let { text: r, list: n } = e.normalizeExpectedResult(this._valueSchema.expected(e));
    return { text: r && `an array of ${r}`, list: n && { title: "an array of the following values", values: [{ list: n }] } };
  }
  validate(e, r) {
    if (!Array.isArray(e))
      return !1;
    let n = [];
    for (let i of e) {
      let s = r.normalizeValidateResult(this._valueSchema.validate(i, r), i);
      s !== !0 && n.push(s.value);
    }
    return n.length === 0 ? !0 : { value: n };
  }
  deprecated(e, r) {
    let n = [];
    for (let i of e) {
      let s = r.normalizeDeprecatedResult(this._valueSchema.deprecated(i, r), i);
      s !== !1 && n.push(...s.map(({ value: o }) => ({ value: [o] })));
    }
    return n;
  }
  forward(e, r) {
    let n = [];
    for (let i of e) {
      let s = r.normalizeForwardResult(this._valueSchema.forward(i, r), i);
      n.push(...s.map(Dy));
    }
    return n;
  }
  redirect(e, r) {
    let n = [], i = [];
    for (let s of e) {
      let o = r.normalizeRedirectResult(this._valueSchema.redirect(s, r), s);
      "remain" in o && n.push(o.remain), i.push(...o.redirect.map(Dy));
    }
    return n.length === 0 ? { redirect: i } : { redirect: i, remain: n };
  }
  overlap(e, r) {
    return e.concat(r);
  }
};
function Dy({ from: t, to: e }) {
  return { from: [t], to: e };
}
var iF = class extends ji {
  expected() {
    return "true or false";
  }
  validate(e) {
    return typeof e == "boolean";
  }
};
function sF(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let n of t) {
    let i = n[e];
    if (r[i])
      throw new Error(`Duplicate ${e} ${JSON.stringify(i)}`);
    r[i] = n;
  }
  return r;
}
function oF(t, e) {
  let r = /* @__PURE__ */ new Map();
  for (let n of t) {
    let i = n[e];
    if (r.has(i))
      throw new Error(`Duplicate ${e} ${JSON.stringify(i)}`);
    r.set(i, n);
  }
  return r;
}
function aF() {
  let t = /* @__PURE__ */ Object.create(null);
  return (e) => {
    let r = JSON.stringify(e);
    return t[r] ? !0 : (t[r] = !0, !1);
  };
}
function lF(t, e) {
  let r = [], n = [];
  for (let i of t)
    e(i) ? r.push(i) : n.push(i);
  return [r, n];
}
function uF(t) {
  return t === Math.floor(t);
}
function cF(t, e) {
  if (t === e)
    return 0;
  let r = typeof t, n = typeof e, i = ["undefined", "object", "boolean", "number", "string"];
  return r !== n ? i.indexOf(r) - i.indexOf(n) : r !== "string" ? Number(t) - Number(e) : t.localeCompare(e);
}
function hF(t) {
  return (...e) => {
    let r = t(...e);
    return typeof r == "string" ? new Error(r) : r;
  };
}
function xy(t) {
  return t === void 0 ? {} : t;
}
function gx(t) {
  if (typeof t == "string")
    return { text: t };
  let { text: e, list: r } = t;
  return pF((e || r) !== void 0, "Unexpected `expected` result, there should be at least one field."), r ? { text: e, list: { title: r.title, values: r.values.map(gx) } } : { text: e };
}
function by(t, e) {
  return t === !0 ? !0 : t === !1 ? { value: e } : t;
}
function vy(t, e, r = !1) {
  return t === !1 ? !1 : t === !0 ? r ? !0 : [{ value: e }] : "value" in t ? [t] : t.length === 0 ? !1 : t;
}
function Cy(t, e) {
  return typeof t == "string" || "key" in t ? { from: e, to: t } : "from" in t ? { from: t.from, to: t.to } : { from: e, to: t.to };
}
function Yp(t, e) {
  return t === void 0 ? [] : Array.isArray(t) ? t.map((r) => Cy(r, e)) : [Cy(t, e)];
}
function Ay(t, e) {
  let r = Yp(typeof t == "object" && "redirect" in t ? t.redirect : t, e);
  return r.length === 0 ? { remain: e, redirect: r } : typeof t == "object" && "remain" in t ? { remain: t.remain, redirect: r } : { redirect: r };
}
function pF(t, e) {
  if (!t)
    throw new Error(e);
}
var dF = class extends ji {
  constructor(e) {
    super(e), this._choices = oF(e.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
  }
  expected({ descriptor: e }) {
    let r = Array.from(this._choices.keys()).map((s) => this._choices.get(s)).filter(({ hidden: s }) => !s).map((s) => s.value).sort(cF).map(e.value), n = r.slice(0, -2), i = r.slice(-2);
    return { text: n.concat(i.join(" or ")).join(", "), list: { title: "one of the following values", values: r } };
  }
  validate(e) {
    return this._choices.has(e);
  }
  deprecated(e) {
    let r = this._choices.get(e);
    return r && r.deprecated ? { value: e } : !1;
  }
  forward(e) {
    let r = this._choices.get(e);
    return r ? r.forward : void 0;
  }
  redirect(e) {
    let r = this._choices.get(e);
    return r ? r.redirect : void 0;
  }
}, fF = class extends ji {
  expected() {
    return "a number";
  }
  validate(e, r) {
    return typeof e == "number";
  }
}, mF = class extends fF {
  expected() {
    return "an integer";
  }
  validate(e, r) {
    return r.normalizeValidateResult(super.validate(e, r), e) === !0 && uF(e);
  }
}, Ey = class extends ji {
  expected() {
    return "a string";
  }
  validate(e) {
    return typeof e == "string";
  }
}, gF = ro, yF = mx, DF = Xk, xF = Gk, bF = class {
  constructor(e, r) {
    let { logger: n = console, loggerPrintWidth: i = 80, descriptor: s = gF, unknown: o = yF, invalid: l = DF, deprecated: u = xF, missing: h = () => !1, required: p = () => !1, preprocess: d = (y) => y, postprocess: m = () => ku } = r || {};
    this._utils = { descriptor: s, logger: n || { warn: () => {
    } }, loggerPrintWidth: i, schemas: sF(e, "name"), normalizeDefaultResult: xy, normalizeExpectedResult: gx, normalizeDeprecatedResult: vy, normalizeForwardResult: Yp, normalizeRedirectResult: Ay, normalizeValidateResult: by }, this._unknownHandler = o, this._invalidHandler = hF(l), this._deprecatedHandler = u, this._identifyMissing = (y, D) => !(y in D) || h(y, D), this._identifyRequired = p, this._preprocess = d, this._postprocess = m, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = aF();
  }
  normalize(e) {
    let r = {}, n = [this._preprocess(e, this._utils)], i = () => {
      for (; n.length !== 0; ) {
        let s = n.shift(), o = this._applyNormalization(s, r);
        n.push(...o);
      }
    };
    i();
    for (let s of Object.keys(this._utils.schemas)) {
      let o = this._utils.schemas[s];
      if (!(s in r)) {
        let l = xy(o.default(this._utils));
        "value" in l && n.push({ [s]: l.value });
      }
    }
    i();
    for (let s of Object.keys(this._utils.schemas)) {
      if (!(s in r))
        continue;
      let o = this._utils.schemas[s], l = r[s], u = o.postprocess(l, this._utils);
      u !== ku && (this._applyValidation(u, s, o), r[s] = u);
    }
    return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
  }
  _applyNormalization(e, r) {
    let n = [], { knownKeys: i, unknownKeys: s } = this._partitionOptionKeys(e);
    for (let o of i) {
      let l = this._utils.schemas[o], u = l.preprocess(e[o], this._utils);
      this._applyValidation(u, o, l);
      let h = ({ from: m, to: y }) => {
        n.push(typeof y == "string" ? { [y]: m } : { [y.key]: y.value });
      }, p = ({ value: m, redirectTo: y }) => {
        let D = vy(l.deprecated(m, this._utils), u, !0);
        if (D !== !1)
          if (D === !0)
            this._hasDeprecationWarned(o) || this._utils.logger.warn(this._deprecatedHandler(o, y, this._utils));
          else
            for (let { value: b } of D) {
              let C = { key: o, value: b };
              if (!this._hasDeprecationWarned(C)) {
                let A = typeof y == "string" ? { key: y, value: b } : y;
                this._utils.logger.warn(this._deprecatedHandler(C, A, this._utils));
              }
            }
      };
      Yp(l.forward(u, this._utils), u).forEach(h);
      let d = Ay(l.redirect(u, this._utils), u);
      if (d.redirect.forEach(h), "remain" in d) {
        let m = d.remain;
        r[o] = o in r ? l.overlap(r[o], m, this._utils) : m, p({ value: m });
      }
      for (let { from: m, to: y } of d.redirect)
        p({ value: m, redirectTo: y });
    }
    for (let o of s) {
      let l = e[o];
      this._applyUnknownHandler(o, l, r, (u, h) => {
        n.push({ [u]: h });
      });
    }
    return n;
  }
  _applyRequiredCheck(e) {
    for (let r of Object.keys(this._utils.schemas))
      if (this._identifyMissing(r, e) && this._identifyRequired(r))
        throw this._invalidHandler(r, px, this._utils);
  }
  _partitionOptionKeys(e) {
    let [r, n] = lF(Object.keys(e).filter((i) => !this._identifyMissing(i, e)), (i) => i in this._utils.schemas);
    return { knownKeys: r, unknownKeys: n };
  }
  _applyValidation(e, r, n) {
    let i = by(n.validate(e, this._utils), e);
    if (i !== !0)
      throw this._invalidHandler(r, i.value, this._utils);
  }
  _applyUnknownHandler(e, r, n, i) {
    let s = this._unknownHandler(e, r, this._utils);
    if (s)
      for (let o of Object.keys(s)) {
        if (this._identifyMissing(o, s))
          continue;
        let l = s[o];
        o in this._utils.schemas ? i(o, l) : n[o] = l;
      }
  }
  _applyPostprocess(e) {
    let r = this._postprocess(e, this._utils);
    if (r !== ku) {
      if (r.delete)
        for (let n of r.delete)
          delete e[n];
      if (r.override) {
        let { knownKeys: n, unknownKeys: i } = this._partitionOptionKeys(r.override);
        for (let s of n) {
          let o = r.override[s];
          this._applyValidation(o, s, this._utils.schemas[s]), e[s] = o;
        }
        for (let s of i) {
          let o = r.override[s];
          this._applyUnknownHandler(s, o, e, (l, u) => {
            let h = this._utils.schemas[l];
            this._applyValidation(u, l, h), e[l] = u;
          });
        }
      }
    }
  }
}, Kh;
function vF(t, e, { logger: r = !1, isCLI: n = !1, passThrough: i = !1, FlagSchema: s, descriptor: o } = {}) {
  if (n) {
    if (!s)
      throw new Error("'FlagSchema' option is required.");
    if (!o)
      throw new Error("'descriptor' option is required.");
  } else
    o = ro;
  let l = i ? Array.isArray(i) ? (m, y) => i.includes(m) ? { [m]: y } : void 0 : (m, y) => ({ [m]: y }) : (m, y, D) => {
    let { _: b, ...C } = D.schemas;
    return mx(m, y, { ...D, schemas: C });
  }, u = CF(e, { isCLI: n, FlagSchema: s }), h = new bF(u, { logger: r, unknown: l, descriptor: o }), p = r !== !1;
  p && Kh && (h._hasDeprecationWarned = Kh);
  let d = h.normalize(t);
  return p && (Kh = h._hasDeprecationWarned), d;
}
function CF(t, { isCLI: e, FlagSchema: r }) {
  let n = [];
  e && n.push(rF.create({ name: "_" }));
  for (let i of t)
    n.push(AF(i, { isCLI: e, optionInfos: t, FlagSchema: r })), i.alias && e && n.push(tF.create({ name: i.alias, sourceName: i.name }));
  return n;
}
function AF(t, { isCLI: e, optionInfos: r, FlagSchema: n }) {
  let { name: i } = t, s = { name: i }, o, l = {};
  switch (t.type) {
    case "int":
      o = mF, e && (s.preprocess = Number);
      break;
    case "string":
      o = Ey;
      break;
    case "choice":
      o = dF, s.choices = t.choices.map((u) => u != null && u.redirect ? { ...u, redirect: { to: { key: t.name, value: u.redirect } } } : u);
      break;
    case "boolean":
      o = iF;
      break;
    case "flag":
      o = n, s.flags = r.flatMap((u) => [u.alias, u.description && u.name, u.oppositeDescription && `no-${u.name}`].filter(Boolean));
      break;
    case "path":
      o = Ey;
      break;
    default:
      throw new Error(`Unexpected type ${t.type}`);
  }
  if (t.exception ? s.validate = (u, h, p) => t.exception(u) || h.validate(u, p) : s.validate = (u, h, p) => u === void 0 || h.validate(u, p), t.redirect && (l.redirect = (u) => u ? { to: { key: t.redirect.option, value: t.redirect.value } } : void 0), t.deprecated && (l.deprecated = !0), e && !t.array) {
    let u = s.preprocess || ((h) => h);
    s.preprocess = (h, p, d) => p.preprocess(u(Array.isArray(h) ? yt(!1, h, -1) : h), d);
  }
  return t.array ? nF.create({ ...e ? { preprocess: (u) => Array.isArray(u) ? u : [u] } : {}, ...l, valueSchema: o.create(s) }) : o.create({ ...s, ...l });
}
var EF = vF, wF = (t, e, r) => {
  if (!(t && e == null)) {
    if (e.findLast)
      return e.findLast(r);
    for (let n = e.length - 1; n >= 0; n--) {
      let i = e[n];
      if (r(i, n, e))
        return i;
    }
  }
}, yx = wF;
function Dx(t, e) {
  if (!e)
    throw new Error("parserName is required.");
  let r = yx(!1, t, (i) => i.parsers && Object.prototype.hasOwnProperty.call(i.parsers, e));
  if (r)
    return r;
  let n = `Couldn't resolve parser "${e}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new cx(n);
}
function SF(t, e) {
  if (!e)
    throw new Error("astFormat is required.");
  let r = yx(!1, t, (i) => i.printers && Object.prototype.hasOwnProperty.call(i.printers, e));
  if (r)
    return r;
  let n = `Couldn't find plugin for AST format "${e}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new cx(n);
}
function xx({ plugins: t, parser: e }) {
  let r = Dx(t, e);
  return bx(r, e);
}
function bx(t, e) {
  let r = t.parsers[e];
  return typeof r == "function" ? r() : r;
}
function TF(t, e) {
  let r = t.printers[e];
  return typeof r == "function" ? r() : r;
}
var wy = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
async function kF(t, e = {}) {
  var r;
  let n = { ...t };
  if (!n.parser)
    if (n.filepath) {
      if (n.parser = Kk(n, { physicalFile: n.filepath }), !n.parser)
        throw new hy(`No parser could be inferred for file "${n.filepath}".`);
    } else
      throw new hy("No parser and no file path given, couldn't infer a parser.");
  let i = hx({ plugins: t.plugins, showDeprecated: !0 }).options, s = { ...wy, ...Object.fromEntries(i.filter((m) => m.default !== void 0).map((m) => [m.name, m.default])) }, o = Dx(n.plugins, n.parser), l = await bx(o, n.parser);
  n.astFormat = l.astFormat, n.locEnd = l.locEnd, n.locStart = l.locStart;
  let u = (r = o.printers) != null && r[l.astFormat] ? o : SF(n.plugins, l.astFormat), h = await TF(u, l.astFormat);
  n.printer = h;
  let p = u.defaultOptions ? Object.fromEntries(Object.entries(u.defaultOptions).filter(([, m]) => m !== void 0)) : {}, d = { ...s, ...p };
  for (let [m, y] of Object.entries(d))
    (n[m] === null || n[m] === void 0) && (n[m] = y);
  return n.parser === "json" && (n.trailingComma = "none"), EF(n, i, { passThrough: Object.keys(wy), ...e });
}
var To = kF, FF = ol(PT(), 1);
async function PF(t, e) {
  let r = await xx(e), n = r.preprocess ? r.preprocess(t, e) : t;
  e.originalText = n;
  let i;
  try {
    i = await r.parse(n, e, e);
  } catch (s) {
    BF(s, t);
  }
  return { text: n, ast: i };
}
function BF(t, e) {
  let { loc: r } = t;
  if (r) {
    let n = (0, FF.codeFrameColumns)(e, r, { highlightCode: !0 });
    throw t.message += `
` + n, t.codeFrame = n, t;
  }
  throw t;
}
var ll = PF;
async function IF(t, e, r, n, i) {
  let { embeddedLanguageFormatting: s, printer: { embed: o, hasPrettierIgnore: l = () => !1, getVisitorKeys: u } } = r;
  if (!o || s !== "auto")
    return;
  if (o.length > 2)
    throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed");
  let h = Lc(o.getVisitorKeys ?? u), p = [];
  y();
  let d = t.stack;
  for (let { print: D, node: b, pathStack: C } of p)
    try {
      t.stack = C;
      let A = await D(m, e, t, r);
      A && i.set(b, A);
    } catch (A) {
      if (globalThis.PRETTIER_DEBUG)
        throw A;
    }
  t.stack = d;
  function m(D, b) {
    return NF(D, b, r, n);
  }
  function y() {
    let { node: D } = t;
    if (D === null || typeof D != "object" || l(t))
      return;
    for (let C of h(D))
      Array.isArray(D[C]) ? t.each(y, C) : t.call(y, C);
    let b = o(t, r);
    if (b) {
      if (typeof b == "function") {
        p.push({ print: b, node: D, pathStack: [...t.stack] });
        return;
      }
      i.set(D, b);
    }
  }
}
async function NF(t, e, r, n) {
  let i = await To({ ...r, ...e, parentParser: r.parser, originalText: t }, { passThrough: !0 }), { ast: s } = await ll(t, i), o = await n(s, i);
  return ZD(o);
}
function MF(t, e) {
  let { originalText: r, [Symbol.for("comments")]: n, locStart: i, locEnd: s, [Symbol.for("printedComments")]: o } = e, { node: l } = t, u = i(l), h = s(l);
  for (let p of n)
    i(p) >= u && s(p) <= h && o.add(p);
  return r.slice(u, h);
}
var OF = MF;
async function _c(t, e) {
  ({ ast: t } = await vx(t, e));
  let r = /* @__PURE__ */ new Map(), n = new vk(t), i = /* @__PURE__ */ new Map();
  await IF(n, o, e, _c, i);
  let s = await Sy(n, e, o, void 0, i);
  return qk(e), s;
  function o(u, h) {
    return u === void 0 || u === n ? l(h) : Array.isArray(u) ? n.call(() => l(h), ...u) : n.call(() => l(h), u);
  }
  function l(u) {
    let h = n.node;
    if (h == null)
      return "";
    let p = h && typeof h == "object" && u === void 0;
    if (p && r.has(h))
      return r.get(h);
    let d = Sy(n, e, o, u, i);
    return p && r.set(h, d), d;
  }
}
function Sy(t, e, r, n, i) {
  var s;
  let { node: o } = t, { printer: l } = e, u;
  return (s = l.hasPrettierIgnore) != null && s.call(l, t) ? u = OF(t, e) : i.has(o) ? u = i.get(o) : u = l.print(t, e, r, n), o === e.cursorNode && (u = ex(u, (h) => [zp, h, zp])), l.printComment && (!l.willPrintOwnComments || !l.willPrintOwnComments(t, e)) && (u = jk(t, u, e)), u;
}
async function vx(t, e) {
  let r = t.comments ?? [];
  e[Symbol.for("comments")] = r, e[Symbol.for("tokens")] = t.tokens ?? [], e[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), Nk(t, e);
  let { printer: { preprocess: n } } = e;
  return t = n ? await n(t, e) : t, { ast: t, comments: r };
}
function LF(t, e) {
  let { cursorOffset: r, locStart: n, locEnd: i } = e, s = Lc(e.printer.getVisitorKeys), o = (u) => n(u) <= r && i(u) >= r, l = t;
  for (let u of Ek(t, { getVisitorKeys: s, filter: o }))
    l = u;
  return l;
}
var _F = LF;
function $F(t, e) {
  let { printer: { massageAstNode: r, getVisitorKeys: n } } = e;
  if (!r)
    return t;
  let i = Lc(n), s = r.ignoredProperties ?? /* @__PURE__ */ new Set();
  return o(t);
  function o(l, u) {
    if (!(l !== null && typeof l == "object"))
      return l;
    if (Array.isArray(l))
      return l.map((m) => o(m, u)).filter(Boolean);
    let h = {}, p = new Set(i(l));
    for (let m in l)
      !Object.prototype.hasOwnProperty.call(l, m) || s.has(m) || (p.has(m) ? h[m] = o(l[m], l) : h[m] = l[m]);
    let d = r(l, h, u);
    if (d !== null)
      return d ?? h;
  }
}
var RF = $F, jF = ({ parser: t }) => t === "json" || t === "json5" || t === "jsonc" || t === "json-stringify";
function qF(t, e) {
  let r = [t.node, ...t.parentNodes], n = /* @__PURE__ */ new Set([e.node, ...e.parentNodes]);
  return r.find((i) => Cx.has(i.type) && n.has(i));
}
function Ty(t) {
  let e = t.length - 1;
  for (; ; ) {
    let r = t[e];
    if ((r == null ? void 0 : r.type) === "Program" || (r == null ? void 0 : r.type) === "File")
      e--;
    else
      break;
  }
  return t.slice(0, e + 1);
}
function WF(t, e, { locStart: r, locEnd: n }) {
  let i = t.node, s = e.node;
  if (i === s)
    return { startNode: i, endNode: s };
  let o = r(t.node);
  for (let u of Ty(e.parentNodes))
    if (r(u) >= o)
      s = u;
    else
      break;
  let l = n(e.node);
  for (let u of Ty(t.parentNodes)) {
    if (n(u) <= l)
      i = u;
    else
      break;
    if (i === s)
      break;
  }
  return { startNode: i, endNode: s };
}
function Qp(t, e, r, n, i = [], s) {
  let { locStart: o, locEnd: l } = r, u = o(t), h = l(t);
  if (!(e > h || e < u || s === "rangeEnd" && e === u || s === "rangeStart" && e === h)) {
    for (let p of Of(t, r)) {
      let d = Qp(p, e, r, n, [t, ...i], s);
      if (d)
        return d;
    }
    if (!n || n(t, i[0]))
      return { node: t, parentNodes: i };
  }
}
function UF(t, e) {
  return e !== "DeclareExportDeclaration" && t !== "TypeParameterDeclaration" && (t === "Directive" || t === "TypeAlias" || t === "TSExportAssignment" || t.startsWith("Declare") || t.startsWith("TSDeclare") || t.endsWith("Statement") || t.endsWith("Declaration"));
}
var Cx = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), HF = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function ky(t, e, r) {
  if (!e)
    return !1;
  switch (t.parser) {
    case "flow":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "__babel_estree":
      return UF(e.type, r == null ? void 0 : r.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return Cx.has(e.type);
    case "graphql":
      return HF.has(e.kind);
    case "vue":
      return e.tag !== "root";
  }
  return !1;
}
function VF(t, e, r) {
  let { rangeStart: n, rangeEnd: i, locStart: s, locEnd: o } = e;
  Xp.ok(i > n);
  let l = t.slice(n, i).search(/\S/), u = l === -1;
  if (!u)
    for (n += l; i > n && !/\S/.test(t[i - 1]); --i)
      ;
  let h = Qp(r, n, e, (y, D) => ky(e, y, D), [], "rangeStart"), p = u ? h : Qp(r, i, e, (y) => ky(e, y), [], "rangeEnd");
  if (!h || !p)
    return { rangeStart: 0, rangeEnd: 0 };
  let d, m;
  if (jF(e)) {
    let y = qF(h, p);
    d = y, m = y;
  } else
    ({ startNode: d, endNode: m } = WF(h, p, e));
  return { rangeStart: Math.min(s(d), s(m)), rangeEnd: Math.max(o(d), o(m)) };
}
var Ax = "\uFEFF", Fy = Symbol("cursor");
async function Ex(t, e, r = 0) {
  if (!t || t.trim().length === 0)
    return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: n, text: i } = await ll(t, e);
  e.cursorOffset >= 0 && (e.cursorNode = _F(n, e));
  let s = await _c(n, e);
  r > 0 && (s = QD([ls, s], r, e.tabWidth));
  let o = Oc(s, e);
  if (r > 0) {
    let u = o.formatted.trim();
    o.cursorNodeStart !== void 0 && (o.cursorNodeStart -= o.formatted.indexOf(u)), o.formatted = u + kf(e.endOfLine);
  }
  let l = e[Symbol.for("comments")];
  if (e.cursorOffset >= 0) {
    let u, h, p, d, m;
    if (e.cursorNode && o.cursorNodeText ? (u = e.locStart(e.cursorNode), h = i.slice(u, e.locEnd(e.cursorNode)), p = e.cursorOffset - u, d = o.cursorNodeStart, m = o.cursorNodeText) : (u = 0, h = i, p = e.cursorOffset, d = 0, m = o.formatted), h === m)
      return { formatted: o.formatted, cursorOffset: d + p, comments: l };
    let y = h.split("");
    y.splice(p, 0, Fy);
    let D = m.split(""), b = (0, IT.diffArrays)(y, D), C = d;
    for (let A of b)
      if (A.removed) {
        if (A.value.includes(Fy))
          break;
      } else
        C += A.count;
    return { formatted: o.formatted, cursorOffset: C, comments: l };
  }
  return { formatted: o.formatted, cursorOffset: -1, comments: l };
}
async function zF(t, e) {
  let { ast: r, text: n } = await ll(t, e), { rangeStart: i, rangeEnd: s } = VF(n, e, r), o = n.slice(i, s), l = Math.min(i, n.lastIndexOf(`
`, i) + 1), u = n.slice(l, i).match(/^\s*/)[0], h = Nf(u, e.tabWidth), p = await Ex(o, { ...e, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: e.cursorOffset > i && e.cursorOffset <= s ? e.cursorOffset - i : -1, endOfLine: "lf" }, h), d = p.formatted.trimEnd(), { cursorOffset: m } = e;
  m > s ? m += d.length - o.length : p.cursorOffset >= 0 && (m = p.cursorOffset + i);
  let y = n.slice(0, i) + d + n.slice(s);
  if (e.endOfLine !== "lf") {
    let D = kf(e.endOfLine);
    m >= 0 && D === `\r
` && (m += HD(y.slice(0, m), `
`)), y = Ic(!1, y, `
`, D);
  }
  return { formatted: y, cursorOffset: m, comments: p.comments };
}
function Gh(t, e, r) {
  return typeof e != "number" || Number.isNaN(e) || e < 0 || e > t.length ? r : e;
}
function Py(t, e) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: i } = e;
  return r = Gh(t, r, -1), n = Gh(t, n, 0), i = Gh(t, i, t.length), { ...e, cursorOffset: r, rangeStart: n, rangeEnd: i };
}
function wx(t, e) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: i, endOfLine: s } = Py(t, e), o = t.charAt(0) === Ax;
  if (o && (t = t.slice(1), r--, n--, i--), s === "auto" && (s = NT(t)), t.includes("\r")) {
    let l = (u) => HD(t.slice(0, Math.max(u, 0)), `\r
`);
    r -= l(r), n -= l(n), i -= l(i), t = MT(t);
  }
  return { hasBOM: o, text: t, options: Py(t, { ...e, cursorOffset: r, rangeStart: n, rangeEnd: i, endOfLine: s }) };
}
async function By(t, e) {
  let r = await xx(e);
  return !r.hasPragma || r.hasPragma(t);
}
async function Sx(t, e) {
  let { hasBOM: r, text: n, options: i } = wx(t, await To(e));
  if (i.rangeStart >= i.rangeEnd && n !== "" || i.requirePragma && !await By(n, i))
    return { formatted: t, cursorOffset: e.cursorOffset, comments: [] };
  let s;
  return i.rangeStart > 0 || i.rangeEnd < n.length ? s = await zF(n, i) : (!i.requirePragma && i.insertPragma && i.printer.insertPragma && !await By(n, i) && (n = i.printer.insertPragma(n)), s = await Ex(n, i)), r && (s.formatted = Ax + s.formatted, s.cursorOffset >= 0 && s.cursorOffset++), s;
}
async function JF(t, e, r) {
  let { text: n, options: i } = wx(t, await To(e)), s = await ll(n, i);
  return r && (r.preprocessForPrint && (s.ast = await vx(s.ast, i)), r.massage && (s.ast = RF(s.ast, i))), s;
}
async function KF(t, e) {
  e = await To(e);
  let r = await _c(t, e);
  return Oc(r, e);
}
async function GF(t, e) {
  let r = QT(t), { formatted: n } = await Sx(r, { ...e, parser: "__js_expression" });
  return n;
}
async function XF(t, e) {
  e = await To(e);
  let { ast: r } = await ll(t, e);
  return _c(r, e);
}
async function YF(t, e) {
  return Oc(t, await To(e));
}
var Tx = {};
Pc(Tx, { builders: () => QF, printer: () => ZF, utils: () => eP });
var QF = { join: YD, line: GD, softline: XT, hardline: ls, literalline: XD, group: zD, conditionalGroup: VT, fill: JD, lineSuffix: Vp, lineSuffixBoundary: KT, cursor: zp, breakParent: Nc, ifBreak: zT, trim: GT, indent: zu, indentIfBreak: JT, align: mo, addAlignmentToDoc: QD, markAsRoot: UT, dedentToRoot: WT, dedent: HT, hardlineWithoutBreakParent: Pf, literallineWithoutBreakParent: KD, label: YT, concat: (t) => t }, ZF = { printDocToString: Oc }, eP = { willBreak: lk, traverseDoc: Ff, findInDoc: If, mapDoc: Mc, removeLines: hk, stripTrailingHardline: ZD, replaceEndOfLine: fk, canBreak: gk }, tP = "3.2.5", kx = {};
Pc(kx, { addDanglingComment: () => Yi, addLeadingComment: () => eo, addTrailingComment: () => to, getAlignmentSize: () => Nf, getIndentSize: () => aP, getMaxContinuousCount: () => cP, getNextNonSpaceNonCommentCharacter: () => pP, getNextNonSpaceNonCommentCharacterIndex: () => bP, getStringWidth: () => Bf, hasNewline: () => wi, hasNewlineInRange: () => fP, hasSpaces: () => gP, isNextLineEmpty: () => EP, isNextLineEmptyAfterIndex: () => jf, isPreviousLineEmpty: () => CP, makeString: () => DP, skip: () => al, skipEverythingButNewLine: () => sx, skipInlineComment: () => _f, skipNewline: () => cs, skipSpaces: () => Pi, skipToLineEnd: () => ix, skipTrailingComment: () => $f, skipWhitespace: () => wk });
function rP(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var _f = rP;
function nP(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? sx(t, e) : e;
}
var $f = nP;
function iP(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = Pi(t, n), n = _f(t, n), n = $f(t, n), n = cs(t, n);
  return n;
}
var Rf = iP;
function sP(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = ix(t, n), n = _f(t, n), n = Pi(t, n);
  return n = $f(t, n), n = cs(t, n), n !== !1 && wi(t, n);
}
var jf = sP;
function oP(t, e) {
  let r = t.lastIndexOf(`
`);
  return r === -1 ? 0 : Nf(t.slice(r + 1).match(/^[\t ]*/)[0], e);
}
var aP = oP;
function lP(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function uP(t, e) {
  let r = t.match(new RegExp(`(${lP(e)})+`, "g"));
  return r === null ? 0 : r.reduce((n, i) => Math.max(n, i.length / e.length), 0);
}
var cP = uP;
function hP(t, e) {
  let r = Rf(t, e);
  return r === !1 ? "" : t.charAt(r);
}
var pP = hP;
function dP(t, e, r) {
  for (let n = e; n < r; ++n)
    if (t.charAt(n) === `
`)
      return !0;
  return !1;
}
var fP = dP;
function mP(t, e, r = {}) {
  return Pi(t, r.backwards ? e - 1 : e, r) !== e;
}
var gP = mP;
function yP(t, e, r) {
  let n = e === '"' ? "'" : '"', i = Ic(!1, t, /\\(.)|(["'])/gs, (s, o, l) => o === n ? o : l === e ? "\\" + l : l || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o) ? o : "\\" + o));
  return e + i + e;
}
var DP = yP;
function xP(t, e, r) {
  return Rf(t, r(e));
}
function bP(t, e) {
  return arguments.length === 2 || typeof e == "number" ? Rf(t, e) : xP(...arguments);
}
function vP(t, e, r) {
  return Lf(t, r(e));
}
function CP(t, e) {
  return arguments.length === 2 || typeof e == "number" ? Lf(t, e) : vP(...arguments);
}
function AP(t, e, r) {
  return jf(t, r(e));
}
function EP(t, e) {
  return arguments.length === 2 || typeof e == "number" ? jf(t, e) : AP(...arguments);
}
function Zi(t, e = 1) {
  return async (...r) => {
    let n = r[e] ?? {}, i = n.plugins ?? [];
    return r[e] = { ...n, plugins: Array.isArray(i) ? i : Object.values(i) }, t(...r);
  };
}
var Fx = Zi(Sx);
async function Px(t, e) {
  let { formatted: r } = await Fx(t, { ...e, cursorOffset: -1 });
  return r;
}
async function wP(t, e) {
  return await Px(t, e) === t;
}
var SP = Zi(hx, 0), TP = { parse: Zi(JF), formatAST: Zi(KF), formatDoc: Zi(GF), printToDoc: Zi(XF), printDocToString: Zi(YF) }, kP = UD, FP = Object.defineProperty, Bx = (t, e) => {
  for (var r in e)
    FP(t, r, { get: e[r], enumerable: !0 });
}, Ix = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, ui = (t, e, r) => (Ix(t, e, "read from private field"), r ? r.call(t) : e.get(t)), PP = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, BP = (t, e, r, n) => (Ix(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r), Nx = {};
Bx(Nx, { languages: () => gI, options: () => DI, parsers: () => d2, printers: () => AN });
var IP = (t, e, r, n) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
}, Dr = IP, qf = "string", Wf = "array", Uf = "cursor", $c = "indent", Rc = "align", Hf = "trim", _a = "group", jc = "fill", qc = "if-break", Wc = "indent-if-break", Vf = "line-suffix", zf = "line-suffix-boundary", Ss = "line", Jf = "label", Uc = "break-parent", Mx = /* @__PURE__ */ new Set([Uf, $c, Rc, Hf, _a, jc, qc, Wc, Vf, zf, Ss, Jf, Uc]);
function NP(t) {
  if (typeof t == "string")
    return qf;
  if (Array.isArray(t))
    return Wf;
  if (!t)
    return;
  let { type: e } = t;
  if (Mx.has(e))
    return e;
}
var Kf = NP, MP = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function OP(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (Kf(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = MP([...Mx].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`;
}
var LP = class extends Error {
  constructor(r) {
    super(OP(r));
    Vr(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, Ox = LP, _P = () => {
}, $P = _P;
function ti(t) {
  return { type: $c, contents: t };
}
function Lx(t, e) {
  return { type: Rc, contents: e, n: t };
}
function qt(t, e = {}) {
  return $P(e.expandedStates), { type: _a, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function RP(t) {
  return Lx(Number.NEGATIVE_INFINITY, t);
}
function jP(t) {
  return Lx({ type: "root" }, t);
}
function _x(t) {
  return { type: jc, parts: t };
}
function Ju(t, e = "", r = {}) {
  return { type: qc, breakContents: t, flatContents: e, groupId: r.groupId };
}
function qP(t, e) {
  return { type: Wc, contents: t, groupId: e.groupId, negate: e.negate };
}
var ul = { type: Uc }, WP = { type: Ss, hard: !0 }, UP = { type: Ss, hard: !0, literal: !0 }, kt = { type: Ss }, $t = { type: Ss, soft: !0 }, rt = [WP, ul], HP = [UP, ul];
function ko(t, e) {
  let r = [];
  for (let n = 0; n < e.length; n++)
    n !== 0 && r.push(t), r.push(e[n]);
  return r;
}
var VP = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, cl = VP;
function Gf(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return n(t);
  function n(s) {
    if (r.has(s))
      return r.get(s);
    let o = i(s);
    return r.set(s, o), o;
  }
  function i(s) {
    switch (Kf(s)) {
      case Wf:
        return e(s.map(n));
      case jc:
        return e({ ...s, parts: s.parts.map(n) });
      case qc:
        return e({ ...s, breakContents: n(s.breakContents), flatContents: n(s.flatContents) });
      case _a: {
        let { expandedStates: o, contents: l } = s;
        return o ? (o = o.map(n), l = o[0]) : l = n(l), e({ ...s, contents: l, expandedStates: o });
      }
      case Rc:
      case $c:
      case Wc:
      case Jf:
      case Vf:
        return e({ ...s, contents: n(s.contents) });
      case qf:
      case Uf:
      case Hf:
      case zf:
      case Ss:
      case Uc:
        return e(s);
      default:
        throw new Ox(s);
    }
  }
}
function zP(t) {
  switch (Kf(t)) {
    case jc:
      if (t.parts.every((e) => e === ""))
        return "";
      break;
    case _a:
      if (!t.contents && !t.id && !t.break && !t.expandedStates)
        return "";
      if (t.contents.type === _a && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates)
        return t.contents;
      break;
    case Rc:
    case $c:
    case Wc:
    case Vf:
      if (!t.contents)
        return "";
      break;
    case qc:
      if (!t.flatContents && !t.breakContents)
        return "";
      break;
    case Wf: {
      let e = [];
      for (let r of t) {
        if (!r)
          continue;
        let [n, ...i] = Array.isArray(r) ? r : [r];
        typeof n == "string" && typeof cl(!1, e, -1) == "string" ? e[e.length - 1] += n : e.push(n), e.push(...i);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case qf:
    case Uf:
    case Hf:
    case zf:
    case Ss:
    case Jf:
    case Uc:
      break;
    default:
      throw new Ox(t);
  }
  return t;
}
function JP(t) {
  return Gf(t, (e) => zP(e));
}
function Zr(t, e = HP) {
  return Gf(t, (r) => typeof r == "string" ? ko(e, r.split(`
`)) : r);
}
var Ul = "'", Iy = '"';
function KP(t, e) {
  let r = e === !0 || e === Ul ? Ul : Iy, n = r === Ul ? Iy : Ul, i = 0, s = 0;
  for (let o of t)
    o === r ? i++ : o === n && s++;
  return i > s ? n : r;
}
var GP = KP;
function XP(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var zr, YP = class {
  constructor(e) {
    PP(this, zr, void 0), BP(this, zr, new Set(e));
  }
  getLeadingWhitespaceCount(e) {
    let r = ui(this, zr), n = 0;
    for (let i = 0; i < e.length && r.has(e.charAt(i)); i++)
      n++;
    return n;
  }
  getTrailingWhitespaceCount(e) {
    let r = ui(this, zr), n = 0;
    for (let i = e.length - 1; i >= 0 && r.has(e.charAt(i)); i--)
      n++;
    return n;
  }
  getLeadingWhitespace(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(0, r);
  }
  getTrailingWhitespace(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(e.length - r);
  }
  hasLeadingWhitespace(e) {
    return ui(this, zr).has(e.charAt(0));
  }
  hasTrailingWhitespace(e) {
    return ui(this, zr).has(cl(!1, e, -1));
  }
  trimStart(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(r);
  }
  trimEnd(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(0, e.length - r);
  }
  trim(e) {
    return this.trimEnd(this.trimStart(e));
  }
  split(e, r = !1) {
    let n = `[${XP([...ui(this, zr)].join(""))}]+`, i = new RegExp(r ? `(${n})` : n);
    return e.split(i);
  }
  hasWhitespaceCharacter(e) {
    let r = ui(this, zr);
    return Array.prototype.some.call(e, (n) => r.has(n));
  }
  hasNonWhitespaceCharacter(e) {
    let r = ui(this, zr);
    return Array.prototype.some.call(e, (n) => !r.has(n));
  }
  isWhitespaceOnly(e) {
    let r = ui(this, zr);
    return Array.prototype.every.call(e, (n) => r.has(n));
  }
};
zr = /* @__PURE__ */ new WeakMap();
var QP = YP, ZP = ["	", `
`, "\f", "\r", " "], e3 = new QP(ZP), Sn = e3, t3 = class extends Error {
  constructor(r, n, i = "type") {
    super(`Unexpected ${n} node ${i}: ${JSON.stringify(r[i])}.`);
    Vr(this, "name", "UnexpectedNodeError");
    this.node = r;
  }
}, r3 = t3;
function n3(t) {
  return (t == null ? void 0 : t.type) === "front-matter";
}
var Hc = n3, i3 = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "keySpan", "tagDefinition", "tokens", "valueTokens", "switchValueSourceSpan", "expSourceSpan", "valueSourceSpan"]), s3 = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function $x(t, e) {
  var r;
  if (t.type === "text" || t.type === "comment" || Hc(t) || t.type === "yaml" || t.type === "toml")
    return null;
  if (t.type === "attribute" && delete e.value, t.type === "docType" && delete e.value, t.type === "angularControlFlowBlock" && (r = e.parameters) != null && r.children)
    for (let n of e.parameters.children)
      s3.has(t.name) ? delete n.expression : n.expression = n.expression.trim();
  t.type === "angularIcuExpression" && (e.switchValue = t.switchValue.trim());
}
$x.ignoredProperties = i3;
var o3 = $x;
async function a3(t, e) {
  if (t.lang === "yaml") {
    let r = t.value.trim(), n = r ? await e(r, { parser: "yaml" }) : "";
    return jP([t.startDelimiter, rt, n, n ? rt : "", t.endDelimiter]);
  }
}
var l3 = a3;
function Vc(t, e = !0) {
  return [ti([$t, t]), e ? $t : ""];
}
function Fo(t, e) {
  let r = t.type === "NGRoot" ? t.node.type === "NGMicrosyntax" && t.node.body.length === 1 && t.node.body[0].type === "NGMicrosyntaxExpression" ? t.node.body[0].expression : t.node : t.type === "JsExpressionRoot" ? t.node : t;
  return r && (r.type === "ObjectExpression" || r.type === "ArrayExpression" || (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && (r.type === "TemplateLiteral" || r.type === "StringLiteral"));
}
async function Tn(t, e, r, n) {
  r = { __isInHtmlAttribute: !0, __embeddedInHtml: !0, ...r };
  let i = !0;
  n && (r.__onHtmlBindingRoot = (o, l) => {
    i = n(o, l);
  });
  let s = await e(t, r, e);
  return i ? qt(s) : Vc(s);
}
function u3(t, e, r, n) {
  let { node: i } = r, s = n.originalText.slice(i.sourceSpan.start.offset, i.sourceSpan.end.offset);
  return /^\s*$/.test(s) ? "" : Tn(s, t, { parser: "__ng_directive", __isInHtmlAttribute: !1, trailingComma: "none" }, Fo);
}
var c3 = u3, h3 = (t) => String(t).split(/[/\\]/).pop();
function Ny(t, e) {
  if (!e)
    return;
  let r = h3(e).toLowerCase();
  return t.find(({ filenames: n }) => n == null ? void 0 : n.some((i) => i.toLowerCase() === r)) ?? t.find(({ extensions: n }) => n == null ? void 0 : n.some((i) => r.endsWith(i)));
}
function p3(t, e) {
  if (e)
    return t.find(({ name: r }) => r.toLowerCase() === e) ?? t.find(({ aliases: r }) => r == null ? void 0 : r.includes(e)) ?? t.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${e}`));
}
function d3(t, e) {
  let r = t.plugins.flatMap((i) => i.languages ?? []), n = p3(r, e.language) ?? Ny(r, e.physicalFile) ?? Ny(r, e.file) ?? (e.physicalFile, void 0);
  return n == null ? void 0 : n.parsers[0];
}
var zc = d3, f3 = "inline", m3 = { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", style: "none", template: "inline", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", dialog: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", search: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", menu: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", input: "inline-block", button: "inline-block", fieldset: "block", marquee: "inline-block", source: "block", track: "block", details: "block", summary: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, g3 = "normal", y3 = { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" };
function D3(t) {
  return t.type === "element" && !t.hasExplicitNamespace && !["html", "svg"].includes(t.namespace);
}
var $a = D3, x3 = (t) => Dr(!1, t, /^[\t\f\r ]*\n/g, ""), Rx = (t) => x3(Sn.trimEnd(t)), b3 = (t) => {
  let e = t, r = Sn.getLeadingWhitespace(e);
  r && (e = e.slice(r.length));
  let n = Sn.getTrailingWhitespace(e);
  return n && (e = e.slice(0, -n.length)), { leadingWhitespace: r, trailingWhitespace: n, text: e };
};
function jx(t, e) {
  return !!(t.type === "ieConditionalComment" && t.lastChild && !t.lastChild.isSelfClosing && !t.lastChild.endSourceSpan || t.type === "ieConditionalComment" && !t.complete || go(t) && t.children.some((r) => r.type !== "text" && r.type !== "interpolation") || Yf(t, e) && !qn(t) && t.type !== "interpolation");
}
function Jc(t) {
  return t.type === "attribute" || !t.parent || !t.prev ? !1 : v3(t.prev);
}
function v3(t) {
  return t.type === "comment" && t.value.trim() === "prettier-ignore";
}
function Tr(t) {
  return t.type === "text" || t.type === "comment";
}
function qn(t) {
  return t.type === "element" && (t.fullName === "script" || t.fullName === "style" || t.fullName === "svg:style" || t.fullName === "svg:script" || $a(t) && (t.name === "script" || t.name === "style"));
}
function C3(t) {
  return t.children && !qn(t);
}
function A3(t) {
  return qn(t) || t.type === "interpolation" || qx(t);
}
function qx(t) {
  return Kx(t).startsWith("pre");
}
function E3(t, e) {
  var r, n;
  let i = s();
  if (i && !t.prev && (n = (r = t.parent) == null ? void 0 : r.tagDefinition) != null && n.ignoreFirstLf)
    return t.type === "interpolation";
  return i;
  function s() {
    return Hc(t) || t.type === "angularControlFlowBlock" ? !1 : (t.type === "text" || t.type === "interpolation") && t.prev && (t.prev.type === "text" || t.prev.type === "interpolation") ? !0 : !t.parent || t.parent.cssDisplay === "none" ? !1 : go(t.parent) ? !0 : !(!t.prev && (t.parent.type === "root" || go(t) && t.parent || qn(t.parent) || Kc(t.parent, e) || !N3(t.parent.cssDisplay)) || t.prev && !L3(t.prev.cssDisplay));
  }
}
function w3(t, e) {
  return Hc(t) || t.type === "angularControlFlowBlock" ? !1 : (t.type === "text" || t.type === "interpolation") && t.next && (t.next.type === "text" || t.next.type === "interpolation") ? !0 : !t.parent || t.parent.cssDisplay === "none" ? !1 : go(t.parent) ? !0 : !(!t.next && (t.parent.type === "root" || go(t) && t.parent || qn(t.parent) || Kc(t.parent, e) || !M3(t.parent.cssDisplay)) || t.next && !O3(t.next.cssDisplay));
}
function S3(t) {
  return _3(t.cssDisplay) && !qn(t);
}
function Hl(t) {
  return Hc(t) || t.next && t.sourceSpan.end && t.sourceSpan.end.line + 1 < t.next.sourceSpan.start.line;
}
function T3(t) {
  return Wx(t) || t.type === "element" && t.children.length > 0 && (["body", "script", "style"].includes(t.name) || t.children.some((e) => F3(e))) || t.firstChild && t.firstChild === t.lastChild && t.firstChild.type !== "text" && Hx(t.firstChild) && (!t.lastChild.isTrailingSpaceSensitive || Vx(t.lastChild));
}
function Wx(t) {
  return t.type === "element" && t.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(t.name) || t.cssDisplay.startsWith("table") && t.cssDisplay !== "table-cell");
}
function Xh(t) {
  return zx(t) || t.prev && k3(t.prev) || Ux(t);
}
function k3(t) {
  return zx(t) || t.type === "element" && t.fullName === "br" || Ux(t);
}
function Ux(t) {
  return Hx(t) && Vx(t);
}
function Hx(t) {
  return t.hasLeadingSpaces && (t.prev ? t.prev.sourceSpan.end.line < t.sourceSpan.start.line : t.parent.type === "root" || t.parent.startSourceSpan.end.line < t.sourceSpan.start.line);
}
function Vx(t) {
  return t.hasTrailingSpaces && (t.next ? t.next.sourceSpan.start.line > t.sourceSpan.end.line : t.parent.type === "root" || t.parent.endSourceSpan && t.parent.endSourceSpan.start.line > t.sourceSpan.end.line);
}
function zx(t) {
  switch (t.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return !0;
    case "element":
      return ["script", "select"].includes(t.name);
  }
  return !1;
}
function Xf(t) {
  return t.lastChild ? Xf(t.lastChild) : t;
}
function F3(t) {
  var e;
  return (e = t.children) == null ? void 0 : e.some((r) => r.type !== "text");
}
function Jx(t) {
  if (t)
    switch (t) {
      case "module":
      case "text/javascript":
      case "text/babel":
      case "application/javascript":
        return "babel";
      case "application/x-typescript":
        return "typescript";
      case "text/markdown":
        return "markdown";
      case "text/html":
        return "html";
      case "text/x-handlebars-template":
        return "glimmer";
      default:
        if (t.endsWith("json") || t.endsWith("importmap") || t === "speculationrules")
          return "json";
    }
}
function P3(t, e) {
  let { name: r, attrMap: n } = t;
  if (r !== "script" || Object.prototype.hasOwnProperty.call(n, "src"))
    return;
  let { type: i, lang: s } = t.attrMap;
  return !s && !i ? "babel" : zc(e, { language: s }) ?? Jx(i);
}
function B3(t, e) {
  if (!Yf(t, e))
    return;
  let { attrMap: r } = t;
  if (Object.prototype.hasOwnProperty.call(r, "src"))
    return;
  let { type: n, lang: i } = r;
  return zc(e, { language: i }) ?? Jx(n);
}
function I3(t, e) {
  if (t.name !== "style")
    return;
  let { lang: r } = t.attrMap;
  return r ? zc(e, { language: r }) : "css";
}
function My(t, e) {
  return P3(t, e) ?? I3(t, e) ?? B3(t, e);
}
function hl(t) {
  return t === "block" || t === "list-item" || t.startsWith("table");
}
function N3(t) {
  return !hl(t) && t !== "inline-block";
}
function M3(t) {
  return !hl(t) && t !== "inline-block";
}
function O3(t) {
  return !hl(t);
}
function L3(t) {
  return !hl(t);
}
function _3(t) {
  return !hl(t) && t !== "inline-block";
}
function go(t) {
  return Kx(t).startsWith("pre");
}
function $3(t, e) {
  let r = t;
  for (; r; ) {
    if (e(r))
      return !0;
    r = r.parent;
  }
  return !1;
}
function R3(t, e) {
  var r;
  if (Po(t, e))
    return "block";
  if (((r = t.prev) == null ? void 0 : r.type) === "comment") {
    let i = t.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
    if (i)
      return i[1];
  }
  let n = !1;
  if (t.type === "element" && t.namespace === "svg")
    if ($3(t, (i) => i.fullName === "svg:foreignObject"))
      n = !0;
    else
      return t.name === "svg" ? "inline-block" : "block";
  switch (e.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      return t.type === "element" && (!t.namespace || n || $a(t)) && m3[t.name] || f3;
  }
}
function Kx(t) {
  return t.type === "element" && (!t.namespace || $a(t)) && y3[t.name] || g3;
}
function j3(t) {
  let e = Number.POSITIVE_INFINITY;
  for (let r of t.split(`
`)) {
    if (r.length === 0)
      continue;
    let n = Sn.getLeadingWhitespaceCount(r);
    if (n === 0)
      return 0;
    r.length !== n && n < e && (e = n);
  }
  return e === Number.POSITIVE_INFINITY ? 0 : e;
}
function Gx(t, e = j3(t)) {
  return e === 0 ? t : t.split(`
`).map((r) => r.slice(e)).join(`
`);
}
function Xx(t) {
  return Dr(!1, Dr(!1, t, "&apos;", "'"), "&quot;", '"');
}
function qi(t) {
  return Xx(t.value);
}
var q3 = /* @__PURE__ */ new Set(["template", "style", "script"]);
function Kc(t, e) {
  return Po(t, e) && !q3.has(t.fullName);
}
function Po(t, e) {
  return e.parser === "vue" && t.type === "element" && t.parent.type === "root" && t.fullName.toLowerCase() !== "html";
}
function Yf(t, e) {
  return Po(t, e) && (Kc(t, e) || t.attrMap.lang && t.attrMap.lang !== "html");
}
function W3(t) {
  let e = t.fullName;
  return e.charAt(0) === "#" || e === "slot-scope" || e === "v-slot" || e.startsWith("v-slot:");
}
function U3(t, e) {
  let r = t.parent;
  if (!Po(r, e))
    return !1;
  let n = r.fullName, i = t.fullName;
  return n === "script" && i === "setup" || n === "style" && i === "vars";
}
function Yx(t, e = t.value) {
  return t.parent.isWhitespaceSensitive ? t.parent.isIndentationSensitive ? Zr(e) : Zr(Gx(Rx(e)), rt) : ko(kt, Sn.split(e));
}
function Qx(t, e) {
  return Po(t, e) && t.name === "script";
}
var Zx = /{{(.+?)}}/s;
async function H3(t, e) {
  let r = [];
  for (let [n, i] of t.split(Zx).entries())
    if (n % 2 === 0)
      r.push(Zr(i));
    else
      try {
        r.push(qt(["{{", ti([kt, await Tn(i, e, { parser: "__ng_interpolation", __isInHtmlInterpolation: !0, trailingComma: "none" })]), kt, "}}"]));
      } catch {
        r.push("{{", Zr(i), "}}");
      }
  return r;
}
function Qf({ parser: t }) {
  return (e, r, n) => Tn(qi(n.node), e, { parser: t, trailingComma: "none" }, Fo);
}
var V3 = Qf({ parser: "__ng_action" }), z3 = Qf({ parser: "__ng_binding" }), J3 = Qf({ parser: "__ng_directive" });
function K3(t, e) {
  if (e.parser !== "angular")
    return;
  let { node: r } = t, n = r.fullName;
  if (n.startsWith("(") && n.endsWith(")") || n.startsWith("on-"))
    return V3;
  if (n.startsWith("[") && n.endsWith("]") || /^bind(?:on)?-/.test(n) || /^ng-(?:if|show|hide|class|style)$/.test(n))
    return z3;
  if (n.startsWith("*"))
    return J3;
  let i = qi(r);
  if (/^i18n(?:-.+)?$/.test(n))
    return () => Vc(_x(Yx(r, i.trim())), !i.includes("@@"));
  if (Zx.test(i))
    return (s) => H3(i, s);
}
var G3 = K3;
function X3(t, e) {
  let { node: r } = t, n = qi(r);
  if (r.fullName === "class" && !e.parentParser && !n.includes("{{"))
    return () => n.trim().split(/\s+/).join(" ");
}
var Y3 = X3;
function Oy(t) {
  return t === "	" || t === `
` || t === "\f" || t === "\r" || t === " ";
}
var Q3 = /^[ \t\n\r\u000c]+/, Z3 = /^[, \t\n\r\u000c]+/, eB = /^[^ \t\n\r\u000c]+/, tB = /[,]+$/, Ly = /^\d+$/, rB = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
function nB(t) {
  let e = t.length, r, n, i, s, o, l = 0, u;
  function h(y) {
    let D, b = y.exec(t.substring(l));
    if (b)
      return [D] = b, l += D.length, D;
  }
  let p = [];
  for (; ; ) {
    if (h(Z3), l >= e) {
      if (p.length === 0)
        throw new Error("Must contain one or more image candidate strings.");
      return p;
    }
    u = l, r = h(eB), n = [], r.slice(-1) === "," ? (r = r.replace(tB, ""), m()) : d();
  }
  function d() {
    for (h(Q3), i = "", s = "in descriptor"; ; ) {
      if (o = t.charAt(l), s === "in descriptor")
        if (Oy(o))
          i && (n.push(i), i = "", s = "after descriptor");
        else if (o === ",") {
          l += 1, i && n.push(i), m();
          return;
        } else if (o === "(")
          i += o, s = "in parens";
        else if (o === "") {
          i && n.push(i), m();
          return;
        } else
          i += o;
      else if (s === "in parens")
        if (o === ")")
          i += o, s = "in descriptor";
        else if (o === "") {
          n.push(i), m();
          return;
        } else
          i += o;
      else if (s === "after descriptor" && !Oy(o))
        if (o === "") {
          m();
          return;
        } else
          s = "in descriptor", l -= 1;
      l += 1;
    }
  }
  function m() {
    let y = !1, D, b, C, A, x = {}, E, k, w, T, P;
    for (A = 0; A < n.length; A++)
      E = n[A], k = E[E.length - 1], w = E.substring(0, E.length - 1), T = parseInt(w, 10), P = parseFloat(w), Ly.test(w) && k === "w" ? ((D || b) && (y = !0), T === 0 ? y = !0 : D = T) : rB.test(w) && k === "x" ? ((D || b || C) && (y = !0), P < 0 ? y = !0 : b = P) : Ly.test(w) && k === "h" ? ((C || b) && (y = !0), T === 0 ? y = !0 : C = T) : y = !0;
    if (!y)
      x.source = { value: r, startOffset: u }, D && (x.width = { value: D }), b && (x.density = { value: b }), C && (x.height = { value: C }), p.push(x);
    else
      throw new Error(`Invalid srcset descriptor found in "${t}" at "${E}".`);
  }
}
var iB = nB;
function sB(t) {
  if (t.node.fullName === "srcset" && (t.parent.fullName === "img" || t.parent.fullName === "source"))
    return () => aB(qi(t.node));
}
var e2 = { width: "w", height: "h", density: "x" }, oB = Object.keys(e2);
function aB(t) {
  let e = iB(t), r = oB.filter((p) => e.some((d) => Object.prototype.hasOwnProperty.call(d, p)));
  if (r.length > 1)
    throw new Error("Mixed descriptor in srcset is not supported");
  let [n] = r, i = e2[n], s = e.map((p) => p.source.value), o = Math.max(...s.map((p) => p.length)), l = e.map((p) => p[n] ? String(p[n].value) : ""), u = l.map((p) => {
    let d = p.indexOf(".");
    return d === -1 ? p.length : d;
  }), h = Math.max(...u);
  return Vc(ko([",", kt], s.map((p, d) => {
    let m = [p], y = l[d];
    if (y) {
      let D = o - p.length + 1, b = h - u[d], C = " ".repeat(D + b);
      m.push(Ju(C, " "), y + i);
    }
    return m;
  })));
}
var lB = sB;
function uB(t, e) {
  let { node: r } = t, n = qi(t.node).trim();
  if (r.fullName === "style" && !e.parentParser && !n.includes("{{"))
    return async (i) => Vc(await i(n, { parser: "css", __isHTMLStyleAttribute: !0 }));
}
var Yh = /* @__PURE__ */ new WeakMap();
function cB(t, e) {
  let { root: r } = t;
  return Yh.has(r) || Yh.set(r, r.children.some((n) => Qx(n, e) && ["ts", "typescript"].includes(n.attrMap.lang))), Yh.get(r);
}
var Zf = cB;
function hB(t, e, r) {
  let { node: n } = r, i = qi(n);
  return Tn(`type T<${i}> = any`, t, { parser: "babel-ts", __isEmbeddedTypescriptGenericParameters: !0 }, Fo);
}
function pB(t, e, { parseWithTs: r }) {
  return Tn(`function _(${t}) {}`, e, { parser: r ? "babel-ts" : "babel", __isVueBindings: !0 });
}
function dB(t) {
  let e = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, r = /^[$_a-z][\w$]*(?:\.[$_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$_a-z][\w$]*])*$/i, n = t.trim();
  return e.test(n) || r.test(n);
}
async function fB(t, e, r, n) {
  let i = qi(r.node), { left: s, operator: o, right: l } = mB(i), u = Zf(r, n);
  return [qt(await Tn(`function _(${s}) {}`, t, { parser: u ? "babel-ts" : "babel", __isVueForBindingLeft: !0 })), " ", o, " ", await Tn(l, t, { parser: u ? "__ts_expression" : "__js_expression" })];
}
function mB(t) {
  let e = /(.*?)\s+(in|of)\s+(.*)/s, r = /,([^,\]}]*)(?:,([^,\]}]*))?$/, n = /^\(|\)$/g, i = t.match(e);
  if (!i)
    return;
  let s = {};
  if (s.for = i[3].trim(), !s.for)
    return;
  let o = Dr(!1, i[1].trim(), n, ""), l = o.match(r);
  l ? (s.alias = o.replace(r, ""), s.iterator1 = l[1].trim(), l[2] && (s.iterator2 = l[2].trim())) : s.alias = o;
  let u = [s.alias, s.iterator1, s.iterator2];
  if (!u.some((h, p) => !h && (p === 0 || u.slice(p + 1).some(Boolean))))
    return { left: u.filter(Boolean).join(","), operator: i[2], right: s.for };
}
function gB(t, e) {
  if (e.parser !== "vue")
    return;
  let { node: r } = t, n = r.fullName;
  if (n === "v-for")
    return fB;
  if (n === "generic" && Qx(r.parent, e))
    return hB;
  let i = qi(r), s = Zf(t, e);
  if (W3(r) || U3(r, e))
    return (o) => pB(i, o, { parseWithTs: s });
  if (n.startsWith("@") || n.startsWith("v-on:"))
    return (o) => yB(i, o, { parseWithTs: s });
  if (n.startsWith(":") || n.startsWith("v-bind:"))
    return (o) => DB(i, o, { parseWithTs: s });
  if (n.startsWith("v-"))
    return (o) => t2(i, o, { parseWithTs: s });
}
function yB(t, e, { parseWithTs: r }) {
  return dB(t) ? t2(t, e, { parseWithTs: r }) : Tn(t, e, { parser: r ? "__vue_ts_event_binding" : "__vue_event_binding" }, Fo);
}
function DB(t, e, { parseWithTs: r }) {
  return Tn(t, e, { parser: r ? "__vue_ts_expression" : "__vue_expression" }, Fo);
}
function t2(t, e, { parseWithTs: r }) {
  return Tn(t, e, { parser: r ? "__ts_expression" : "__js_expression" }, Fo);
}
var xB = gB;
function bB(t, e) {
  let { node: r } = t;
  if (r.value) {
    if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(e.originalText.slice(r.valueSpan.start.offset, r.valueSpan.end.offset)) || e.parser === "lwc" && r.value.startsWith("{") && r.value.endsWith("}"))
      return [r.rawName, "=", r.value];
    for (let n of [lB, uB, Y3, xB, G3]) {
      let i = n(t, e);
      if (i)
        return vB(i);
    }
  }
}
function vB(t) {
  return async (e, r, n, i) => {
    let s = await t(e, r, n, i);
    if (s)
      return s = Gf(s, (o) => typeof o == "string" ? Dr(!1, o, '"', "&quot;") : o), [n.node.rawName, '="', qt(s), '"'];
  };
}
var CB = bB, r2 = new Proxy(() => {
}, { get: () => r2 }), n2 = r2;
function AB(t) {
  return Array.isArray(t) && t.length > 0;
}
var em = AB;
function Gc(t) {
  return t.sourceSpan.start.offset;
}
function Xc(t) {
  return t.sourceSpan.end.offset;
}
function Zp(t, e) {
  return [t.isSelfClosing ? "" : EB(t, e), Aa(t, e)];
}
function EB(t, e) {
  return t.lastChild && Ra(t.lastChild) ? "" : [wB(t, e), tm(t, e)];
}
function Aa(t, e) {
  return (t.next ? ps(t.next) : dl(t.parent)) ? "" : [pl(t, e), hs(t, e)];
}
function wB(t, e) {
  return dl(t) ? pl(t.lastChild, e) : "";
}
function hs(t, e) {
  return Ra(t) ? tm(t.parent, e) : Yc(t) ? rm(t.next) : "";
}
function tm(t, e) {
  if (n2(!t.isSelfClosing), i2(t, e))
    return "";
  switch (t.type) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (t.hasHtmComponentClosingTag)
        return "<//";
    default:
      return `</${t.rawName}`;
  }
}
function pl(t, e) {
  if (i2(t, e))
    return "";
  switch (t.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "angularIcuExpression":
      return "}";
    case "element":
      if (t.isSelfClosing)
        return "/>";
    default:
      return ">";
  }
}
function i2(t, e) {
  return !t.isSelfClosing && !t.endSourceSpan && (Jc(t) || jx(t.parent, e));
}
function ps(t) {
  return t.prev && t.prev.type !== "docType" && t.type !== "angularControlFlowBlock" && !Tr(t.prev) && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
}
function dl(t) {
  var e;
  return ((e = t.lastChild) == null ? void 0 : e.isTrailingSpaceSensitive) && !t.lastChild.hasTrailingSpaces && !Tr(Xf(t.lastChild)) && !go(t);
}
function Ra(t) {
  return !t.next && !t.hasTrailingSpaces && t.isTrailingSpaceSensitive && Tr(Xf(t));
}
function Yc(t) {
  return t.next && !Tr(t.next) && Tr(t) && t.isTrailingSpaceSensitive && !t.hasTrailingSpaces;
}
function SB(t) {
  let e = t.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
  return e ? e[1] ? e[1].split(/\s+/) : !0 : !1;
}
function Qc(t) {
  return !t.prev && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
}
function TB(t, e, r) {
  var n;
  let { node: i } = t;
  if (!em(i.attrs))
    return i.isSelfClosing ? " " : "";
  let s = ((n = i.prev) == null ? void 0 : n.type) === "comment" && SB(i.prev.value), o = typeof s == "boolean" ? () => s : Array.isArray(s) ? (d) => s.includes(d.rawName) : () => !1, l = t.map(({ node: d }) => o(d) ? Zr(e.originalText.slice(Gc(d), Xc(d))) : r(), "attrs"), u = i.type === "element" && i.fullName === "script" && i.attrs.length === 1 && i.attrs[0].fullName === "src" && i.children.length === 0, h = e.singleAttributePerLine && i.attrs.length > 1 && !Po(i, e) ? rt : kt, p = [ti([u ? " " : kt, ko(h, l)])];
  return i.firstChild && Qc(i.firstChild) || i.isSelfClosing && dl(i.parent) || u ? p.push(i.isSelfClosing ? " " : "") : p.push(e.bracketSameLine ? i.isSelfClosing ? " " : "" : i.isSelfClosing ? kt : $t), p;
}
function kB(t) {
  return t.firstChild && Qc(t.firstChild) ? "" : nm(t);
}
function ed(t, e, r) {
  let { node: n } = t;
  return [Ea(n, e), TB(t, e, r), n.isSelfClosing ? "" : kB(n)];
}
function Ea(t, e) {
  return t.prev && Yc(t.prev) ? "" : [ds(t, e), rm(t)];
}
function ds(t, e) {
  return Qc(t) ? nm(t.parent) : ps(t) ? pl(t.prev, e) : "";
}
function rm(t) {
  switch (t.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${t.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType":
      return t.value === "html" ? "<!doctype" : "<!DOCTYPE";
    case "angularIcuExpression":
      return "{";
    case "element":
      if (t.condition)
        return `<!--[if ${t.condition}]><!--><${t.rawName}`;
    default:
      return `<${t.rawName}`;
  }
}
function nm(t) {
  switch (n2(!t.isSelfClosing), t.type) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (t.condition)
        return "><!--<![endif]-->";
    default:
      return ">";
  }
}
function FB(t, e) {
  if (!t.endSourceSpan)
    return "";
  let r = t.startSourceSpan.end.offset;
  t.firstChild && Qc(t.firstChild) && (r -= nm(t).length);
  let n = t.endSourceSpan.start.offset;
  return t.lastChild && Ra(t.lastChild) ? n += tm(t, e).length : dl(t) && (n -= pl(t.lastChild, e).length), e.originalText.slice(r, n);
}
var s2 = FB, PB = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function BB(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "element":
      if (qn(r) || r.type === "interpolation")
        return;
      if (!r.isSelfClosing && Yf(r, e)) {
        let n = My(r, e);
        return n ? async (i, s) => {
          let o = s2(r, e), l = /^\s*$/.test(o), u = "";
          return l || (u = await i(Rx(o), { parser: n, __embeddedInHtml: !0 }), l = u === ""), [ds(r, e), qt(ed(t, e, s)), l ? "" : rt, u, l ? "" : rt, Zp(r, e), hs(r, e)];
        } : void 0;
      }
      break;
    case "text":
      if (qn(r.parent)) {
        let n = My(r.parent, e);
        if (n)
          return async (i) => {
            let s = n === "markdown" ? Gx(r.value.replace(/^[^\S\n]*\n/, "")) : r.value, o = { parser: n, __embeddedInHtml: !0 };
            if (e.parser === "html" && n === "babel") {
              let l = "script", { attrMap: u } = r.parent;
              u && (u.type === "module" || u.type === "text/babel" && u["data-type"] === "module") && (l = "module"), o.__babelSourceType = l;
            }
            return [ul, ds(r, e), await i(s, o), hs(r, e)];
          };
      } else if (r.parent.type === "interpolation")
        return async (n) => {
          let i = { __isInHtmlInterpolation: !0, __embeddedInHtml: !0 };
          return e.parser === "angular" ? (i.parser = "__ng_interpolation", i.trailingComma = "none") : e.parser === "vue" ? i.parser = Zf(t, e) ? "__vue_ts_expression" : "__vue_expression" : i.parser = "__js_expression", [ti([kt, await n(r.value, i)]), r.parent.next && ps(r.parent.next) ? " " : kt];
        };
      break;
    case "attribute":
      return CB(t, e);
    case "front-matter":
      return (n) => l3(r, n);
    case "angularControlFlowBlockParameters":
      return PB.has(t.parent.name) ? c3 : void 0;
  }
}
var IB = BB, Yo = null;
function wa(t) {
  if (Yo !== null && typeof Yo.property) {
    let e = Yo;
    return Yo = wa.prototype = null, e;
  }
  return Yo = wa.prototype = t ?? /* @__PURE__ */ Object.create(null), new wa();
}
var NB = 10;
for (let t = 0; t <= NB; t++)
  wa();
function MB(t) {
  return wa(t);
}
function OB(t, e = "type") {
  MB(t);
  function r(n) {
    let i = n[e], s = t[i];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: n });
    return s;
  }
  return r;
}
var LB = OB, _B = { "front-matter": [], root: ["children"], element: ["attrs", "children"], ieConditionalComment: ["children"], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ["children"], text: ["children"], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ["children", "parameters"], angularControlFlowBlockParameters: ["children"], angularControlFlowBlockParameter: [], angularIcuExpression: ["cases"], angularIcuCase: ["expression"] }, $B = _B, RB = LB($B), jB = RB;
function qB(t) {
  return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(t);
}
function WB(t) {
  return `<!-- @format -->

` + t;
}
var UB = /* @__PURE__ */ new Map([["if", /* @__PURE__ */ new Set(["else if", "else"])], ["else if", /* @__PURE__ */ new Set(["else if", "else"])], ["for", /* @__PURE__ */ new Set(["empty"])], ["defer", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["placeholder", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["error", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["loading", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])]]);
function o2(t) {
  let e = Xc(t);
  return t.type === "element" && !t.endSourceSpan && em(t.children) ? Math.max(e, o2(cl(!1, t.children, -1))) : e;
}
function Qo(t, e, r) {
  let n = t.node;
  if (Jc(n)) {
    let i = o2(n);
    return [ds(n, e), Zr(Sn.trimEnd(e.originalText.slice(Gc(n) + (n.prev && Yc(n.prev) ? rm(n).length : 0), i - (n.next && ps(n.next) ? pl(n, e).length : 0)))), hs(n, e)];
  }
  return r();
}
function Vl(t, e) {
  return Tr(t) && Tr(e) ? t.isTrailingSpaceSensitive ? t.hasTrailingSpaces ? Xh(e) ? rt : kt : "" : Xh(e) ? rt : $t : Yc(t) && (Jc(e) || e.firstChild || e.isSelfClosing || e.type === "element" && e.attrs.length > 0) || t.type === "element" && t.isSelfClosing && ps(e) ? "" : !e.isLeadingSpaceSensitive || Xh(e) || ps(e) && t.lastChild && Ra(t.lastChild) && t.lastChild.lastChild && Ra(t.lastChild.lastChild) ? rt : e.hasLeadingSpaces ? kt : $t;
}
function im(t, e, r) {
  let { node: n } = t;
  if (Wx(n))
    return [ul, ...t.map((s) => {
      let o = s.node, l = o.prev ? Vl(o.prev, o) : "";
      return [l ? [l, Hl(o.prev) ? rt : ""] : "", Qo(s, e, r)];
    }, "children")];
  let i = n.children.map(() => Symbol(""));
  return t.map((s, o) => {
    let l = s.node;
    if (Tr(l)) {
      if (l.prev && Tr(l.prev)) {
        let D = Vl(l.prev, l);
        if (D)
          return Hl(l.prev) ? [rt, rt, Qo(s, e, r)] : [D, Qo(s, e, r)];
      }
      return Qo(s, e, r);
    }
    let u = [], h = [], p = [], d = [], m = l.prev ? Vl(l.prev, l) : "", y = l.next ? Vl(l, l.next) : "";
    return m && (Hl(l.prev) ? u.push(rt, rt) : m === rt ? u.push(rt) : Tr(l.prev) ? h.push(m) : h.push(Ju("", $t, { groupId: i[o - 1] }))), y && (Hl(l) ? Tr(l.next) && d.push(rt, rt) : y === rt ? Tr(l.next) && d.push(rt) : p.push(y)), [...u, qt([...h, qt([Qo(s, e, r), ...p], { id: i[o] })]), ...d];
  }, "children");
}
function HB(t, e, r) {
  let { node: n } = t, i = [];
  VB(t) && i.push("} "), i.push("@", n.name), n.parameters && i.push(" (", qt(r("parameters")), ")"), i.push(" {");
  let s = a2(n);
  return n.children.length > 0 ? (n.firstChild.hasLeadingSpaces = !0, n.lastChild.hasTrailingSpaces = !0, i.push(ti([rt, im(t, e, r)])), s && i.push(rt, "}")) : s && i.push("}"), qt(i, { shouldBreak: !0 });
}
function a2(t) {
  var e, r;
  return !(((e = t.next) == null ? void 0 : e.type) === "angularControlFlowBlock" && (r = UB.get(t.name)) != null && r.has(t.next.name));
}
function VB(t) {
  let { previous: e } = t;
  return (e == null ? void 0 : e.type) === "angularControlFlowBlock" && !Jc(e) && !a2(e);
}
function zB(t, e, r) {
  return [ti([$t, ko([";", kt], t.map(r, "children"))]), $t];
}
function JB(t, e, r) {
  let { node: n } = t;
  return [Ea(n, e), qt([n.switchValue.trim(), ", ", n.clause, n.cases.length > 0 ? [",", ti([kt, ko(kt, t.map(r, "cases"))])] : "", $t]), Aa(n, e)];
}
function KB(t, e, r) {
  let { node: n } = t;
  return [n.value, " {", qt([ti([$t, t.map(({ node: i }) => i.type === "text" && !Sn.trim(i.value) ? "" : r(), "expression")]), $t]), "}"];
}
function GB(t, e, r) {
  let { node: n } = t;
  if (jx(n, e))
    return [ds(n, e), qt(ed(t, e, r)), Zr(s2(n, e)), ...Zp(n, e), hs(n, e)];
  let i = n.children.length === 1 && (n.firstChild.type === "interpolation" || n.firstChild.type === "angularIcuExpression") && n.firstChild.isLeadingSpaceSensitive && !n.firstChild.hasLeadingSpaces && n.lastChild.isTrailingSpaceSensitive && !n.lastChild.hasTrailingSpaces, s = Symbol("element-attr-group-id"), o = (p) => qt([qt(ed(t, e, r), { id: s }), p, Zp(n, e)]), l = (p) => i ? qP(p, { groupId: s }) : (qn(n) || Kc(n, e)) && n.parent.type === "root" && e.parser === "vue" && !e.vueIndentScriptAndStyle ? p : ti(p), u = () => i ? Ju($t, "", { groupId: s }) : n.firstChild.hasLeadingSpaces && n.firstChild.isLeadingSpaceSensitive ? kt : n.firstChild.type === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive ? RP($t) : $t, h = () => (n.next ? ps(n.next) : dl(n.parent)) ? n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? " " : "" : i ? Ju($t, "", { groupId: s }) : n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? kt : (n.lastChild.type === "comment" || n.lastChild.type === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${e.tabWidth * (t.ancestors.length - 1)}}$`).test(n.lastChild.value) ? "" : $t;
  return n.children.length === 0 ? o(n.hasDanglingSpaces && n.isDanglingSpaceSensitive ? kt : "") : o([T3(n) ? ul : "", l([u(), im(t, e, r)]), h()]);
}
function sm(t) {
  return t >= 9 && t <= 32 || t == 160;
}
function l2(t) {
  return 48 <= t && t <= 57;
}
function om(t) {
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function XB(t) {
  return t >= 97 && t <= 102 || t >= 65 && t <= 70 || l2(t);
}
function u2(t) {
  return t === 10 || t === 13;
}
function _y(t) {
  return 48 <= t && t <= 55;
}
function $y(t) {
  return t === 39 || t === 34 || t === 96;
}
var YB = /-+([a-z0-9])/g;
function QB(t) {
  return t.replace(YB, (...e) => e[1].toUpperCase());
}
var td = class c2 {
  constructor(e, r, n, i) {
    this.file = e, this.offset = r, this.line = n, this.col = i;
  }
  toString() {
    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
  }
  moveBy(e) {
    let r = this.file.content, n = r.length, i = this.offset, s = this.line, o = this.col;
    for (; i > 0 && e < 0; )
      if (i--, e++, r.charCodeAt(i) == 10) {
        s--;
        let l = r.substring(0, i - 1).lastIndexOf(`
`);
        o = l > 0 ? i - l : i;
      } else
        o--;
    for (; i < n && e > 0; ) {
      let l = r.charCodeAt(i);
      i++, e--, l == 10 ? (s++, o = 0) : o++;
    }
    return new c2(this.file, i, s, o);
  }
  getContext(e, r) {
    let n = this.file.content, i = this.offset;
    if (i != null) {
      i > n.length - 1 && (i = n.length - 1);
      let s = i, o = 0, l = 0;
      for (; o < e && i > 0 && (i--, o++, !(n[i] == `
` && ++l == r)); )
        ;
      for (o = 0, l = 0; o < e && s < n.length - 1 && (s++, o++, !(n[s] == `
` && ++l == r)); )
        ;
      return { before: n.substring(i, this.offset), after: n.substring(this.offset, s + 1) };
    }
    return null;
  }
}, h2 = class {
  constructor(e, r) {
    this.content = e, this.url = r;
  }
}, Le = class {
  constructor(t, e, r = t, n = null) {
    this.start = t, this.end = e, this.fullStart = r, this.details = n;
  }
  toString() {
    return this.start.file.content.substring(this.start.offset, this.end.offset);
  }
}, Ku;
(function(t) {
  t[t.WARNING = 0] = "WARNING", t[t.ERROR = 1] = "ERROR";
})(Ku || (Ku = {}));
var p2 = class {
  constructor(e, r, n = Ku.ERROR) {
    this.span = e, this.msg = r, this.level = n;
  }
  contextualMessage() {
    let e = this.span.start.getContext(100, 3);
    return e ? `${this.msg} ("${e.before}[${Ku[this.level]} ->]${e.after}")` : this.msg;
  }
  toString() {
    let e = this.span.details ? `, ${this.span.details}` : "";
    return `${this.contextualMessage()}: ${this.span.start}${e}`;
  }
}, ZB = [tI, rI, iI, oI, aI, cI, lI, uI, hI, sI];
function eI(t, e) {
  for (let r of ZB)
    r(t, e);
  return t;
}
function tI(t) {
  t.walk((e) => {
    if (e.type === "element" && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && e.children[0].type === "text" && e.children[0].value[0] === `
`) {
      let r = e.children[0];
      r.value.length === 1 ? e.removeChild(r) : r.value = r.value.slice(1);
    }
  });
}
function rI(t) {
  let e = (r) => {
    var n, i;
    return r.type === "element" && ((n = r.prev) == null ? void 0 : n.type) === "ieConditionalStartComment" && r.prev.sourceSpan.end.offset === r.startSourceSpan.start.offset && ((i = r.firstChild) == null ? void 0 : i.type) === "ieConditionalEndComment" && r.firstChild.sourceSpan.start.offset === r.startSourceSpan.end.offset;
  };
  t.walk((r) => {
    if (r.children)
      for (let n = 0; n < r.children.length; n++) {
        let i = r.children[n];
        if (!e(i))
          continue;
        let s = i.prev, o = i.firstChild;
        r.removeChild(s), n--;
        let l = new Le(s.sourceSpan.start, o.sourceSpan.end), u = new Le(l.start, i.sourceSpan.end);
        i.condition = s.condition, i.sourceSpan = u, i.startSourceSpan = l, i.removeChild(o);
      }
  });
}
function nI(t, e, r) {
  t.walk((n) => {
    if (n.children)
      for (let i = 0; i < n.children.length; i++) {
        let s = n.children[i];
        if (s.type !== "text" && !e(s))
          continue;
        s.type !== "text" && (s.type = "text", s.value = r(s));
        let o = s.prev;
        !o || o.type !== "text" || (o.value += s.value, o.sourceSpan = new Le(o.sourceSpan.start, s.sourceSpan.end), n.removeChild(s), i--);
      }
  });
}
function iI(t) {
  return nI(t, (e) => e.type === "cdata", (e) => `<![CDATA[${e.value}]]>`);
}
function sI(t) {
  let e = (r) => {
    var n, i;
    return r.type === "element" && r.attrs.length === 0 && r.children.length === 1 && r.firstChild.type === "text" && !Sn.hasWhitespaceCharacter(r.children[0].value) && !r.firstChild.hasLeadingSpaces && !r.firstChild.hasTrailingSpaces && r.isLeadingSpaceSensitive && !r.hasLeadingSpaces && r.isTrailingSpaceSensitive && !r.hasTrailingSpaces && ((n = r.prev) == null ? void 0 : n.type) === "text" && ((i = r.next) == null ? void 0 : i.type) === "text";
  };
  t.walk((r) => {
    if (r.children)
      for (let n = 0; n < r.children.length; n++) {
        let i = r.children[n];
        if (!e(i))
          continue;
        let s = i.prev, o = i.next;
        s.value += `<${i.rawName}>` + i.firstChild.value + `</${i.rawName}>` + o.value, s.sourceSpan = new Le(s.sourceSpan.start, o.sourceSpan.end), s.isTrailingSpaceSensitive = o.isTrailingSpaceSensitive, s.hasTrailingSpaces = o.hasTrailingSpaces, r.removeChild(i), n--, r.removeChild(o);
      }
  });
}
function oI(t, e) {
  if (e.parser === "html")
    return;
  let r = /{{(.+?)}}/s;
  t.walk((n) => {
    if (C3(n))
      for (let i of n.children) {
        if (i.type !== "text")
          continue;
        let s = i.sourceSpan.start, o = null, l = i.value.split(r);
        for (let u = 0; u < l.length; u++, s = o) {
          let h = l[u];
          if (u % 2 === 0) {
            o = s.moveBy(h.length), h.length > 0 && n.insertChildBefore(i, { type: "text", value: h, sourceSpan: new Le(s, o) });
            continue;
          }
          o = s.moveBy(h.length + 4), n.insertChildBefore(i, { type: "interpolation", sourceSpan: new Le(s, o), children: h.length === 0 ? [] : [{ type: "text", value: h, sourceSpan: new Le(s.moveBy(2), o.moveBy(-2)) }] });
        }
        n.removeChild(i);
      }
  });
}
function aI(t) {
  t.walk((e) => {
    if (!e.children)
      return;
    if (e.children.length === 0 || e.children.length === 1 && e.children[0].type === "text" && Sn.trim(e.children[0].value).length === 0) {
      e.hasDanglingSpaces = e.children.length > 0, e.children = [];
      return;
    }
    let r = A3(e), n = qx(e);
    if (!r)
      for (let i = 0; i < e.children.length; i++) {
        let s = e.children[i];
        if (s.type !== "text")
          continue;
        let { leadingWhitespace: o, text: l, trailingWhitespace: u } = b3(s.value), h = s.prev, p = s.next;
        l ? (s.value = l, s.sourceSpan = new Le(s.sourceSpan.start.moveBy(o.length), s.sourceSpan.end.moveBy(-u.length)), o && (h && (h.hasTrailingSpaces = !0), s.hasLeadingSpaces = !0), u && (s.hasTrailingSpaces = !0, p && (p.hasLeadingSpaces = !0))) : (e.removeChild(s), i--, (o || u) && (h && (h.hasTrailingSpaces = !0), p && (p.hasLeadingSpaces = !0)));
      }
    e.isWhitespaceSensitive = r, e.isIndentationSensitive = n;
  });
}
function lI(t) {
  t.walk((e) => {
    e.isSelfClosing = !e.children || e.type === "element" && (e.tagDefinition.isVoid || e.endSourceSpan && e.startSourceSpan.start === e.endSourceSpan.start && e.startSourceSpan.end === e.endSourceSpan.end);
  });
}
function uI(t, e) {
  t.walk((r) => {
    r.type === "element" && (r.hasHtmComponentClosingTag = r.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(e.originalText.slice(r.endSourceSpan.start.offset, r.endSourceSpan.end.offset)));
  });
}
function cI(t, e) {
  t.walk((r) => {
    r.cssDisplay = R3(r, e);
  });
}
function hI(t, e) {
  t.walk((r) => {
    let { children: n } = r;
    if (n) {
      if (n.length === 0) {
        r.isDanglingSpaceSensitive = S3(r);
        return;
      }
      for (let i of n)
        i.isLeadingSpaceSensitive = E3(i, e), i.isTrailingSpaceSensitive = w3(i, e);
      for (let i = 0; i < n.length; i++) {
        let s = n[i];
        s.isLeadingSpaceSensitive = (i === 0 || s.prev.isTrailingSpaceSensitive) && s.isLeadingSpaceSensitive, s.isTrailingSpaceSensitive = (i === n.length - 1 || s.next.isLeadingSpaceSensitive) && s.isTrailingSpaceSensitive;
      }
    }
  });
}
var pI = eI;
function dI(t, e, r) {
  let { node: n } = t;
  switch (n.type) {
    case "front-matter":
      return Zr(n.raw);
    case "root":
      return e.__onHtmlRoot && e.__onHtmlRoot(n), [qt(im(t, e, r)), rt];
    case "element":
    case "ieConditionalComment":
      return GB(t, e, r);
    case "angularControlFlowBlock":
      return HB(t, e, r);
    case "angularControlFlowBlockParameters":
      return zB(t, e, r);
    case "angularControlFlowBlockParameter":
      return Sn.trim(n.expression);
    case "angularIcuExpression":
      return JB(t, e, r);
    case "angularIcuCase":
      return KB(t, e, r);
    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return [Ea(n), Aa(n)];
    case "interpolation":
      return [Ea(n, e), ...t.map(r, "children"), Aa(n, e)];
    case "text": {
      if (n.parent.type === "interpolation") {
        let s = /\n[^\S\n]*$/, o = s.test(n.value), l = o ? n.value.replace(s, "") : n.value;
        return [Zr(l), o ? rt : ""];
      }
      let i = JP([ds(n, e), ...Yx(n), hs(n, e)]);
      return Array.isArray(i) ? _x(i) : i;
    }
    case "docType":
      return [qt([Ea(n, e), " ", Dr(!1, n.value.replace(/^html\b/i, "html"), /\s+/g, " ")]), Aa(n, e)];
    case "comment":
      return [ds(n, e), Zr(e.originalText.slice(Gc(n), Xc(n))), hs(n, e)];
    case "attribute": {
      if (n.value === null)
        return n.rawName;
      let i = Xx(n.value), s = GP(i, '"');
      return [n.rawName, "=", s, Zr(s === '"' ? Dr(!1, i, '"', "&quot;") : Dr(!1, i, "'", "&apos;")), s];
    }
    case "cdata":
    default:
      throw new r3(n, "HTML");
  }
}
var fI = { preprocess: pI, print: dI, insertPragma: WB, massageAstNode: o3, embed: IB, getVisitorKeys: jB }, mI = fI, gI = [{ linguistLanguageId: 146, name: "Angular", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".component.html"], parsers: ["angular"], vscodeLanguageIds: ["html"], filenames: [] }, { linguistLanguageId: 146, name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml", ".mjml"], parsers: ["html"], vscodeLanguageIds: ["html"] }, { linguistLanguageId: 146, name: "Lightning Web Components", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [], parsers: ["lwc"], vscodeLanguageIds: ["html"], filenames: [] }, { linguistLanguageId: 391, name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", parsers: ["vue"], vscodeLanguageIds: ["vue"] }], Ry = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, jy = "HTML", yI = { bracketSameLine: Ry.bracketSameLine, htmlWhitespaceSensitivity: { category: jy, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: Ry.singleAttributePerLine, vueIndentScriptAndStyle: { category: jy, type: "boolean", default: !1, description: "Indent script and style tags in Vue files." } }, DI = yI, d2 = {};
Bx(d2, { angular: () => bN, html: () => xN, lwc: () => CN, vue: () => vN });
var qy;
(function(t) {
  t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom";
})(qy || (qy = {}));
var Wy;
(function(t) {
  t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default";
})(Wy || (Wy = {}));
var Uy = { name: "custom-elements" }, Hy = { name: "no-errors-schema" }, rs;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL";
})(rs || (rs = {}));
var Vy;
(function(t) {
  t[t.Error = 0] = "Error", t[t.Warning = 1] = "Warning", t[t.Ignore = 2] = "Ignore";
})(Vy || (Vy = {}));
var Qr;
(function(t) {
  t[t.RAW_TEXT = 0] = "RAW_TEXT", t[t.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", t[t.PARSABLE_DATA = 2] = "PARSABLE_DATA";
})(Qr || (Qr = {}));
function Zc(t) {
  if (t[0] != ":")
    return [null, t];
  let e = t.indexOf(":", 1);
  if (e === -1)
    throw new Error(`Unsupported format "${t}" expecting ":namespace:name"`);
  return [t.slice(1, e), t.slice(e + 1)];
}
function zy(t) {
  return Zc(t)[1] === "ng-container";
}
function Jy(t) {
  return Zc(t)[1] === "ng-content";
}
function Fu(t) {
  return t === null ? null : Zc(t)[0];
}
function Gu(t, e) {
  return t ? `:${t}:${e}` : e;
}
var Pu;
function Ky() {
  return Pu || (Pu = {}, zl(rs.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), zl(rs.STYLE, ["*|style"]), zl(rs.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), zl(rs.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), Pu;
}
function zl(t, e) {
  for (let r of e)
    Pu[r.toLowerCase()] = t;
}
var xI = class {
}, bI = "boolean", vI = "number", CI = "string", AI = "object", EI = ["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|"], f2 = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" })), wI = Array.from(f2).reduce((t, [e, r]) => (t.set(e, r), t), /* @__PURE__ */ new Map()), SI = class extends xI {
  constructor() {
    super(), this._schema = /* @__PURE__ */ new Map(), this._eventSchema = /* @__PURE__ */ new Map(), EI.forEach((e) => {
      let r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), [i, s] = e.split("|"), o = s.split(","), [l, u] = i.split("^");
      l.split(",").forEach((p) => {
        this._schema.set(p.toLowerCase(), r), this._eventSchema.set(p.toLowerCase(), n);
      });
      let h = u && this._schema.get(u.toLowerCase());
      if (h) {
        for (let [p, d] of h)
          r.set(p, d);
        for (let p of this._eventSchema.get(u.toLowerCase()))
          n.add(p);
      }
      o.forEach((p) => {
        if (p.length > 0)
          switch (p[0]) {
            case "*":
              n.add(p.substring(1));
              break;
            case "!":
              r.set(p.substring(1), bI);
              break;
            case "#":
              r.set(p.substring(1), vI);
              break;
            case "%":
              r.set(p.substring(1), AI);
              break;
            default:
              r.set(p, CI);
          }
      });
    });
  }
  hasProperty(e, r, n) {
    if (n.some((i) => i.name === Hy.name))
      return !0;
    if (e.indexOf("-") > -1) {
      if (zy(e) || Jy(e))
        return !1;
      if (n.some((i) => i.name === Uy.name))
        return !0;
    }
    return (this._schema.get(e.toLowerCase()) || this._schema.get("unknown")).has(r);
  }
  hasElement(e, r) {
    return r.some((n) => n.name === Hy.name) || e.indexOf("-") > -1 && (zy(e) || Jy(e) || r.some((n) => n.name === Uy.name)) ? !0 : this._schema.has(e.toLowerCase());
  }
  securityContext(e, r, n) {
    n && (r = this.getMappedPropName(r)), e = e.toLowerCase(), r = r.toLowerCase();
    let i = Ky()[e + "|" + r];
    return i || (i = Ky()["*|" + r], i || rs.NONE);
  }
  getMappedPropName(e) {
    return f2.get(e) ?? e;
  }
  getDefaultComponentElementName() {
    return "ng-component";
  }
  validateProperty(e) {
    return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...
If '${e}' is a directive input, make sure the directive is imported by the current module.` } : { error: !1 };
  }
  validateAttribute(e) {
    return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...` } : { error: !1 };
  }
  allKnownElementNames() {
    return Array.from(this._schema.keys());
  }
  allKnownAttributesOfElement(e) {
    let r = this._schema.get(e.toLowerCase()) || this._schema.get("unknown");
    return Array.from(r.keys()).map((n) => wI.get(n) ?? n);
  }
  allKnownEventsOfElement(e) {
    return Array.from(this._eventSchema.get(e.toLowerCase()) ?? []);
  }
  normalizeAnimationStyleProperty(e) {
    return QB(e);
  }
  normalizeAnimationStyleValue(e, r, n) {
    let i = "", s = n.toString().trim(), o = null;
    if (TI(e) && n !== 0 && n !== "0")
      if (typeof n == "number")
        i = "px";
      else {
        let l = n.match(/^[+-]?[\d\.]+([a-z]*)$/);
        l && l[1].length == 0 && (o = `Please provide a CSS unit value for ${r}:${n}`);
      }
    return { error: o, value: s + i };
  }
};
function TI(t) {
  switch (t) {
    case "width":
    case "height":
    case "minWidth":
    case "minHeight":
    case "maxWidth":
    case "maxHeight":
    case "left":
    case "top":
    case "bottom":
    case "right":
    case "fontSize":
    case "outlineWidth":
    case "outlineOffset":
    case "paddingTop":
    case "paddingLeft":
    case "paddingBottom":
    case "paddingRight":
    case "marginTop":
    case "marginLeft":
    case "marginBottom":
    case "marginRight":
    case "borderRadius":
    case "borderWidth":
    case "borderTopWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderBottomWidth":
    case "textIndent":
      return !0;
    default:
      return !1;
  }
}
var Ae = class {
  constructor({ closedByChildren: t, implicitNamespacePrefix: e, contentType: r = Qr.PARSABLE_DATA, closedByParent: n = !1, isVoid: i = !1, ignoreFirstLf: s = !1, preventNamespaceInheritance: o = !1, canSelfClose: l = !1 } = {}) {
    this.closedByChildren = {}, this.closedByParent = !1, t && t.length > 0 && t.forEach((u) => this.closedByChildren[u] = !0), this.isVoid = i, this.closedByParent = n || i, this.implicitNamespacePrefix = e || null, this.contentType = r, this.ignoreFirstLf = s, this.preventNamespaceInheritance = o, this.canSelfClose = l ?? i;
  }
  isClosedByChild(t) {
    return this.isVoid || t.toLowerCase() in this.closedByChildren;
  }
  getContentType(t) {
    return typeof this.contentType == "object" ? (t === void 0 ? void 0 : this.contentType[t]) ?? this.contentType.default : this.contentType;
  }
}, Gy, Zo;
function rd(t) {
  return Zo || (Gy = new Ae({ canSelfClose: !0 }), Zo = Object.assign(/* @__PURE__ */ Object.create(null), { base: new Ae({ isVoid: !0 }), meta: new Ae({ isVoid: !0 }), area: new Ae({ isVoid: !0 }), embed: new Ae({ isVoid: !0 }), link: new Ae({ isVoid: !0 }), img: new Ae({ isVoid: !0 }), input: new Ae({ isVoid: !0 }), param: new Ae({ isVoid: !0 }), hr: new Ae({ isVoid: !0 }), br: new Ae({ isVoid: !0 }), source: new Ae({ isVoid: !0 }), track: new Ae({ isVoid: !0 }), wbr: new Ae({ isVoid: !0 }), p: new Ae({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: !0 }), thead: new Ae({ closedByChildren: ["tbody", "tfoot"] }), tbody: new Ae({ closedByChildren: ["tbody", "tfoot"], closedByParent: !0 }), tfoot: new Ae({ closedByChildren: ["tbody"], closedByParent: !0 }), tr: new Ae({ closedByChildren: ["tr"], closedByParent: !0 }), td: new Ae({ closedByChildren: ["td", "th"], closedByParent: !0 }), th: new Ae({ closedByChildren: ["td", "th"], closedByParent: !0 }), col: new Ae({ isVoid: !0 }), svg: new Ae({ implicitNamespacePrefix: "svg" }), foreignObject: new Ae({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: !0 }), math: new Ae({ implicitNamespacePrefix: "math" }), li: new Ae({ closedByChildren: ["li"], closedByParent: !0 }), dt: new Ae({ closedByChildren: ["dt", "dd"] }), dd: new Ae({ closedByChildren: ["dt", "dd"], closedByParent: !0 }), rb: new Ae({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rt: new Ae({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rtc: new Ae({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: !0 }), rp: new Ae({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), optgroup: new Ae({ closedByChildren: ["optgroup"], closedByParent: !0 }), option: new Ae({ closedByChildren: ["option", "optgroup"], closedByParent: !0 }), pre: new Ae({ ignoreFirstLf: !0 }), listing: new Ae({ ignoreFirstLf: !0 }), style: new Ae({ contentType: Qr.RAW_TEXT }), script: new Ae({ contentType: Qr.RAW_TEXT }), title: new Ae({ contentType: { default: Qr.ESCAPABLE_RAW_TEXT, svg: Qr.PARSABLE_DATA } }), textarea: new Ae({ contentType: Qr.ESCAPABLE_RAW_TEXT, ignoreFirstLf: !0 }) }), new SI().allKnownElementNames().forEach((e) => {
    !Zo[e] && Fu(e) === null && (Zo[e] = new Ae({ canSelfClose: !1 }));
  })), Zo[t] ?? Gy;
}
var fl = class {
  constructor(e, r) {
    this.sourceSpan = e, this.i18n = r;
  }
}, kI = class extends fl {
  constructor(e, r, n, i) {
    super(r, i), this.value = e, this.tokens = n, this.type = "text";
  }
  visit(e, r) {
    return e.visitText(this, r);
  }
}, FI = class extends fl {
  constructor(e, r, n, i) {
    super(r, i), this.value = e, this.tokens = n, this.type = "cdata";
  }
  visit(e, r) {
    return e.visitCdata(this, r);
  }
}, PI = class extends fl {
  constructor(e, r, n, i, s, o) {
    super(i, o), this.switchValue = e, this.type = r, this.cases = n, this.switchValueSourceSpan = s;
  }
  visit(e, r) {
    return e.visitExpansion(this, r);
  }
}, BI = class {
  constructor(e, r, n, i, s) {
    this.value = e, this.expression = r, this.sourceSpan = n, this.valueSourceSpan = i, this.expSourceSpan = s, this.type = "expansionCase";
  }
  visit(e, r) {
    return e.visitExpansionCase(this, r);
  }
}, II = class extends fl {
  constructor(e, r, n, i, s, o, l) {
    super(n, l), this.name = e, this.value = r, this.keySpan = i, this.valueSpan = s, this.valueTokens = o, this.type = "attribute";
  }
  visit(e, r) {
    return e.visitAttribute(this, r);
  }
  get nameSpan() {
    return this.keySpan;
  }
}, ci = class extends fl {
  constructor(e, r, n, i, s, o = null, l = null, u) {
    super(i, u), this.name = e, this.attrs = r, this.children = n, this.startSourceSpan = s, this.endSourceSpan = o, this.nameSpan = l, this.type = "element";
  }
  visit(e, r) {
    return e.visitElement(this, r);
  }
}, NI = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "comment";
  }
  visit(e, r) {
    return e.visitComment(this, r);
  }
}, MI = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "docType";
  }
  visit(e, r) {
    return e.visitDocType(this, r);
  }
}, qs = class {
  constructor(e, r, n, i, s, o = null) {
    this.name = e, this.parameters = r, this.children = n, this.sourceSpan = i, this.startSourceSpan = s, this.endSourceSpan = o, this.type = "block";
  }
  visit(e, r) {
    return e.visitBlock(this, r);
  }
}, Xy = class {
  constructor(e, r) {
    this.expression = e, this.sourceSpan = r, this.type = "blockParameter", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e, r) {
    return e.visitBlockParameter(this, r);
  }
};
function m2(t, e, r = null) {
  let n = [], i = t.visit ? (s) => t.visit(s, r) || s.visit(t, r) : (s) => s.visit(t, r);
  return e.forEach((s) => {
    let o = i(s);
    o && n.push(o);
  }), n;
}
var OI = class {
  constructor() {
  }
  visitElement(e, r) {
    this.visitChildren(r, (n) => {
      n(e.attrs), n(e.children);
    });
  }
  visitAttribute(e, r) {
  }
  visitText(e, r) {
  }
  visitCdata(e, r) {
  }
  visitComment(e, r) {
  }
  visitDocType(e, r) {
  }
  visitExpansion(e, r) {
    return this.visitChildren(r, (n) => {
      n(e.cases);
    });
  }
  visitExpansionCase(e, r) {
  }
  visitBlock(e, r) {
    this.visitChildren(r, (n) => {
      n(e.parameters), n(e.children);
    });
  }
  visitBlockParameter(e, r) {
  }
  visitChildren(e, r) {
    let n = [], i = this;
    function s(o) {
      o && n.push(m2(i, o, e));
    }
    return r(s), Array.prototype.concat.apply([], n);
  }
}, Xu = { AElig: "", AMP: "&", amp: "&", Aacute: "", Abreve: "", Acirc: "", Acy: "", Afr: "", Agrave: "", Alpha: "", Amacr: "", And: "", Aogon: "", Aopf: "", ApplyFunction: "", af: "", Aring: "", angst: "", Ascr: "", Assign: "", colone: "", coloneq: "", Atilde: "", Auml: "", Backslash: "", setminus: "", setmn: "", smallsetminus: "", ssetmn: "", Barv: "", Barwed: "", doublebarwedge: "", Bcy: "", Because: "", becaus: "", because: "", Bernoullis: "", Bscr: "", bernou: "", Beta: "", Bfr: "", Bopf: "", Breve: "", breve: "", Bumpeq: "", HumpDownHump: "", bump: "", CHcy: "", COPY: "", copy: "", Cacute: "", Cap: "", CapitalDifferentialD: "", DD: "", Cayleys: "", Cfr: "", Ccaron: "", Ccedil: "", Ccirc: "", Cconint: "", Cdot: "", Cedilla: "", cedil: "", CenterDot: "", centerdot: "", middot: "", Chi: "", CircleDot: "", odot: "", CircleMinus: "", ominus: "", CirclePlus: "", oplus: "", CircleTimes: "", otimes: "", ClockwiseContourIntegral: "", cwconint: "", CloseCurlyDoubleQuote: "", rdquo: "", rdquor: "", CloseCurlyQuote: "", rsquo: "", rsquor: "", Colon: "", Proportion: "", Colone: "", Congruent: "", equiv: "", Conint: "", DoubleContourIntegral: "", ContourIntegral: "", conint: "", oint: "", Copf: "", complexes: "", Coproduct: "", coprod: "", CounterClockwiseContourIntegral: "", awconint: "", Cross: "", Cscr: "", Cup: "", CupCap: "", asympeq: "", DDotrahd: "", DJcy: "", DScy: "", DZcy: "", Dagger: "", ddagger: "", Darr: "", Dashv: "", DoubleLeftTee: "", Dcaron: "", Dcy: "", Del: "", nabla: "", Delta: "", Dfr: "", DiacriticalAcute: "", acute: "", DiacriticalDot: "", dot: "", DiacriticalDoubleAcute: "", dblac: "", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "", tilde: "", Diamond: "", diam: "", diamond: "", DifferentialD: "", dd: "", Dopf: "", Dot: "", DoubleDot: "", die: "", uml: "", DotDot: "", DotEqual: "", doteq: "", esdot: "", DoubleDownArrow: "", Downarrow: "", dArr: "", DoubleLeftArrow: "", Leftarrow: "", lArr: "", DoubleLeftRightArrow: "", Leftrightarrow: "", hArr: "", iff: "", DoubleLongLeftArrow: "", Longleftarrow: "", xlArr: "", DoubleLongLeftRightArrow: "", Longleftrightarrow: "", xhArr: "", DoubleLongRightArrow: "", Longrightarrow: "", xrArr: "", DoubleRightArrow: "", Implies: "", Rightarrow: "", rArr: "", DoubleRightTee: "", vDash: "", DoubleUpArrow: "", Uparrow: "", uArr: "", DoubleUpDownArrow: "", Updownarrow: "", vArr: "", DoubleVerticalBar: "", par: "", parallel: "", shortparallel: "", spar: "", DownArrow: "", ShortDownArrow: "", darr: "", downarrow: "", DownArrowBar: "", DownArrowUpArrow: "", duarr: "", DownBreve: "", DownLeftRightVector: "", DownLeftTeeVector: "", DownLeftVector: "", leftharpoondown: "", lhard: "", DownLeftVectorBar: "", DownRightTeeVector: "", DownRightVector: "", rhard: "", rightharpoondown: "", DownRightVectorBar: "", DownTee: "", top: "", DownTeeArrow: "", mapstodown: "", Dscr: "", Dstrok: "", ENG: "", ETH: "", Eacute: "", Ecaron: "", Ecirc: "", Ecy: "", Edot: "", Efr: "", Egrave: "", Element: "", in: "", isin: "", isinv: "", Emacr: "", EmptySmallSquare: "", EmptyVerySmallSquare: "", Eogon: "", Eopf: "", Epsilon: "", Equal: "", EqualTilde: "", eqsim: "", esim: "", Equilibrium: "", rightleftharpoons: "", rlhar: "", Escr: "", expectation: "", Esim: "", Eta: "", Euml: "", Exists: "", exist: "", ExponentialE: "", ee: "", exponentiale: "", Fcy: "", Ffr: "", FilledSmallSquare: "", FilledVerySmallSquare: "", blacksquare: "", squarf: "", squf: "", Fopf: "", ForAll: "", forall: "", Fouriertrf: "", Fscr: "", GJcy: "", GT: ">", gt: ">", Gamma: "", Gammad: "", Gbreve: "", Gcedil: "", Gcirc: "", Gcy: "", Gdot: "", Gfr: "", Gg: "", ggg: "", Gopf: "", GreaterEqual: "", ge: "", geq: "", GreaterEqualLess: "", gel: "", gtreqless: "", GreaterFullEqual: "", gE: "", geqq: "", GreaterGreater: "", GreaterLess: "", gl: "", gtrless: "", GreaterSlantEqual: "", geqslant: "", ges: "", GreaterTilde: "", gsim: "", gtrsim: "", Gscr: "", Gt: "", NestedGreaterGreater: "", gg: "", HARDcy: "", Hacek: "", caron: "", Hat: "^", Hcirc: "", Hfr: "", Poincareplane: "", HilbertSpace: "", Hscr: "", hamilt: "", Hopf: "", quaternions: "", HorizontalLine: "", boxh: "", Hstrok: "", HumpEqual: "", bumpe: "", bumpeq: "", IEcy: "", IJlig: "", IOcy: "", Iacute: "", Icirc: "", Icy: "", Idot: "", Ifr: "", Im: "", image: "", imagpart: "", Igrave: "", Imacr: "", ImaginaryI: "", ii: "", Int: "", Integral: "", int: "", Intersection: "", bigcap: "", xcap: "", InvisibleComma: "", ic: "", InvisibleTimes: "", it: "", Iogon: "", Iopf: "", Iota: "", Iscr: "", imagline: "", Itilde: "", Iukcy: "", Iuml: "", Jcirc: "", Jcy: "", Jfr: "", Jopf: "", Jscr: "", Jsercy: "", Jukcy: "", KHcy: "", KJcy: "", Kappa: "", Kcedil: "", Kcy: "", Kfr: "", Kopf: "", Kscr: "", LJcy: "", LT: "<", lt: "<", Lacute: "", Lambda: "", Lang: "", Laplacetrf: "", Lscr: "", lagran: "", Larr: "", twoheadleftarrow: "", Lcaron: "", Lcedil: "", Lcy: "", LeftAngleBracket: "", lang: "", langle: "", LeftArrow: "", ShortLeftArrow: "", larr: "", leftarrow: "", slarr: "", LeftArrowBar: "", larrb: "", LeftArrowRightArrow: "", leftrightarrows: "", lrarr: "", LeftCeiling: "", lceil: "", LeftDoubleBracket: "", lobrk: "", LeftDownTeeVector: "", LeftDownVector: "", dharl: "", downharpoonleft: "", LeftDownVectorBar: "", LeftFloor: "", lfloor: "", LeftRightArrow: "", harr: "", leftrightarrow: "", LeftRightVector: "", LeftTee: "", dashv: "", LeftTeeArrow: "", mapstoleft: "", LeftTeeVector: "", LeftTriangle: "", vartriangleleft: "", vltri: "", LeftTriangleBar: "", LeftTriangleEqual: "", ltrie: "", trianglelefteq: "", LeftUpDownVector: "", LeftUpTeeVector: "", LeftUpVector: "", uharl: "", upharpoonleft: "", LeftUpVectorBar: "", LeftVector: "", leftharpoonup: "", lharu: "", LeftVectorBar: "", LessEqualGreater: "", leg: "", lesseqgtr: "", LessFullEqual: "", lE: "", leqq: "", LessGreater: "", lessgtr: "", lg: "", LessLess: "", LessSlantEqual: "", leqslant: "", les: "", LessTilde: "", lesssim: "", lsim: "", Lfr: "", Ll: "", Lleftarrow: "", lAarr: "", Lmidot: "", LongLeftArrow: "", longleftarrow: "", xlarr: "", LongLeftRightArrow: "", longleftrightarrow: "", xharr: "", LongRightArrow: "", longrightarrow: "", xrarr: "", Lopf: "", LowerLeftArrow: "", swarr: "", swarrow: "", LowerRightArrow: "", searr: "", searrow: "", Lsh: "", lsh: "", Lstrok: "", Lt: "", NestedLessLess: "", ll: "", Map: "", Mcy: "", MediumSpace: "", Mellintrf: "", Mscr: "", phmmat: "", Mfr: "", MinusPlus: "", mnplus: "", mp: "", Mopf: "", Mu: "", NJcy: "", Nacute: "", Ncaron: "", Ncedil: "", Ncy: "", NegativeMediumSpace: "", NegativeThickSpace: "", NegativeThinSpace: "", NegativeVeryThinSpace: "", ZeroWidthSpace: "", NewLine: `
`, Nfr: "", NoBreak: "", NonBreakingSpace: "", nbsp: "", Nopf: "", naturals: "", Not: "", NotCongruent: "", nequiv: "", NotCupCap: "", NotDoubleVerticalBar: "", npar: "", nparallel: "", nshortparallel: "", nspar: "", NotElement: "", notin: "", notinva: "", NotEqual: "", ne: "", NotEqualTilde: "", nesim: "", NotExists: "", nexist: "", nexists: "", NotGreater: "", ngt: "", ngtr: "", NotGreaterEqual: "", nge: "", ngeq: "", NotGreaterFullEqual: "", ngE: "", ngeqq: "", NotGreaterGreater: "", nGtv: "", NotGreaterLess: "", ntgl: "", NotGreaterSlantEqual: "", ngeqslant: "", nges: "", NotGreaterTilde: "", ngsim: "", NotHumpDownHump: "", nbump: "", NotHumpEqual: "", nbumpe: "", NotLeftTriangle: "", nltri: "", ntriangleleft: "", NotLeftTriangleBar: "", NotLeftTriangleEqual: "", nltrie: "", ntrianglelefteq: "", NotLess: "", nless: "", nlt: "", NotLessEqual: "", nle: "", nleq: "", NotLessGreater: "", ntlg: "", NotLessLess: "", nLtv: "", NotLessSlantEqual: "", nleqslant: "", nles: "", NotLessTilde: "", nlsim: "", NotNestedGreaterGreater: "", NotNestedLessLess: "", NotPrecedes: "", npr: "", nprec: "", NotPrecedesEqual: "", npre: "", npreceq: "", NotPrecedesSlantEqual: "", nprcue: "", NotReverseElement: "", notni: "", notniva: "", NotRightTriangle: "", nrtri: "", ntriangleright: "", NotRightTriangleBar: "", NotRightTriangleEqual: "", nrtrie: "", ntrianglerighteq: "", NotSquareSubset: "", NotSquareSubsetEqual: "", nsqsube: "", NotSquareSuperset: "", NotSquareSupersetEqual: "", nsqsupe: "", NotSubset: "", nsubset: "", vnsub: "", NotSubsetEqual: "", nsube: "", nsubseteq: "", NotSucceeds: "", nsc: "", nsucc: "", NotSucceedsEqual: "", nsce: "", nsucceq: "", NotSucceedsSlantEqual: "", nsccue: "", NotSucceedsTilde: "", NotSuperset: "", nsupset: "", vnsup: "", NotSupersetEqual: "", nsupe: "", nsupseteq: "", NotTilde: "", nsim: "", NotTildeEqual: "", nsime: "", nsimeq: "", NotTildeFullEqual: "", ncong: "", NotTildeTilde: "", nap: "", napprox: "", NotVerticalBar: "", nmid: "", nshortmid: "", nsmid: "", Nscr: "", Ntilde: "", Nu: "", OElig: "", Oacute: "", Ocirc: "", Ocy: "", Odblac: "", Ofr: "", Ograve: "", Omacr: "", Omega: "", ohm: "", Omicron: "", Oopf: "", OpenCurlyDoubleQuote: "", ldquo: "", OpenCurlyQuote: "", lsquo: "", Or: "", Oscr: "", Oslash: "", Otilde: "", Otimes: "", Ouml: "", OverBar: "", oline: "", OverBrace: "", OverBracket: "", tbrk: "", OverParenthesis: "", PartialD: "", part: "", Pcy: "", Pfr: "", Phi: "", Pi: "", PlusMinus: "", plusmn: "", pm: "", Popf: "", primes: "", Pr: "", Precedes: "", pr: "", prec: "", PrecedesEqual: "", pre: "", preceq: "", PrecedesSlantEqual: "", prcue: "", preccurlyeq: "", PrecedesTilde: "", precsim: "", prsim: "", Prime: "", Product: "", prod: "", Proportional: "", prop: "", propto: "", varpropto: "", vprop: "", Pscr: "", Psi: "", QUOT: '"', quot: '"', Qfr: "", Qopf: "", rationals: "", Qscr: "", RBarr: "", drbkarow: "", REG: "", circledR: "", reg: "", Racute: "", Rang: "", Rarr: "", twoheadrightarrow: "", Rarrtl: "", Rcaron: "", Rcedil: "", Rcy: "", Re: "", Rfr: "", real: "", realpart: "", ReverseElement: "", SuchThat: "", ni: "", niv: "", ReverseEquilibrium: "", leftrightharpoons: "", lrhar: "", ReverseUpEquilibrium: "", duhar: "", Rho: "", RightAngleBracket: "", rang: "", rangle: "", RightArrow: "", ShortRightArrow: "", rarr: "", rightarrow: "", srarr: "", RightArrowBar: "", rarrb: "", RightArrowLeftArrow: "", rightleftarrows: "", rlarr: "", RightCeiling: "", rceil: "", RightDoubleBracket: "", robrk: "", RightDownTeeVector: "", RightDownVector: "", dharr: "", downharpoonright: "", RightDownVectorBar: "", RightFloor: "", rfloor: "", RightTee: "", vdash: "", RightTeeArrow: "", map: "", mapsto: "", RightTeeVector: "", RightTriangle: "", vartriangleright: "", vrtri: "", RightTriangleBar: "", RightTriangleEqual: "", rtrie: "", trianglerighteq: "", RightUpDownVector: "", RightUpTeeVector: "", RightUpVector: "", uharr: "", upharpoonright: "", RightUpVectorBar: "", RightVector: "", rharu: "", rightharpoonup: "", RightVectorBar: "", Ropf: "", reals: "", RoundImplies: "", Rrightarrow: "", rAarr: "", Rscr: "", realine: "", Rsh: "", rsh: "", RuleDelayed: "", SHCHcy: "", SHcy: "", SOFTcy: "", Sacute: "", Sc: "", Scaron: "", Scedil: "", Scirc: "", Scy: "", Sfr: "", ShortUpArrow: "", UpArrow: "", uarr: "", uparrow: "", Sigma: "", SmallCircle: "", compfn: "", Sopf: "", Sqrt: "", radic: "", Square: "", squ: "", square: "", SquareIntersection: "", sqcap: "", SquareSubset: "", sqsub: "", sqsubset: "", SquareSubsetEqual: "", sqsube: "", sqsubseteq: "", SquareSuperset: "", sqsup: "", sqsupset: "", SquareSupersetEqual: "", sqsupe: "", sqsupseteq: "", SquareUnion: "", sqcup: "", Sscr: "", Star: "", sstarf: "", Sub: "", Subset: "", SubsetEqual: "", sube: "", subseteq: "", Succeeds: "", sc: "", succ: "", SucceedsEqual: "", sce: "", succeq: "", SucceedsSlantEqual: "", sccue: "", succcurlyeq: "", SucceedsTilde: "", scsim: "", succsim: "", Sum: "", sum: "", Sup: "", Supset: "", Superset: "", sup: "", supset: "", SupersetEqual: "", supe: "", supseteq: "", THORN: "", TRADE: "", trade: "", TSHcy: "", TScy: "", Tab: "	", Tau: "", Tcaron: "", Tcedil: "", Tcy: "", Tfr: "", Therefore: "", there4: "", therefore: "", Theta: "", ThickSpace: "", ThinSpace: "", thinsp: "", Tilde: "", sim: "", thicksim: "", thksim: "", TildeEqual: "", sime: "", simeq: "", TildeFullEqual: "", cong: "", TildeTilde: "", ap: "", approx: "", asymp: "", thickapprox: "", thkap: "", Topf: "", TripleDot: "", tdot: "", Tscr: "", Tstrok: "", Uacute: "", Uarr: "", Uarrocir: "", Ubrcy: "", Ubreve: "", Ucirc: "", Ucy: "", Udblac: "", Ufr: "", Ugrave: "", Umacr: "", UnderBar: "_", lowbar: "_", UnderBrace: "", UnderBracket: "", bbrk: "", UnderParenthesis: "", Union: "", bigcup: "", xcup: "", UnionPlus: "", uplus: "", Uogon: "", Uopf: "", UpArrowBar: "", UpArrowDownArrow: "", udarr: "", UpDownArrow: "", updownarrow: "", varr: "", UpEquilibrium: "", udhar: "", UpTee: "", bot: "", bottom: "", perp: "", UpTeeArrow: "", mapstoup: "", UpperLeftArrow: "", nwarr: "", nwarrow: "", UpperRightArrow: "", nearr: "", nearrow: "", Upsi: "", upsih: "", Upsilon: "", Uring: "", Uscr: "", Utilde: "", Uuml: "", VDash: "", Vbar: "", Vcy: "", Vdash: "", Vdashl: "", Vee: "", bigvee: "", xvee: "", Verbar: "", Vert: "", VerticalBar: "", mid: "", shortmid: "", smid: "", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "", VerticalTilde: "", wr: "", wreath: "", VeryThinSpace: "", hairsp: "", Vfr: "", Vopf: "", Vscr: "", Vvdash: "", Wcirc: "", Wedge: "", bigwedge: "", xwedge: "", Wfr: "", Wopf: "", Wscr: "", Xfr: "", Xi: "", Xopf: "", Xscr: "", YAcy: "", YIcy: "", YUcy: "", Yacute: "", Ycirc: "", Ycy: "", Yfr: "", Yopf: "", Yscr: "", Yuml: "", ZHcy: "", Zacute: "", Zcaron: "", Zcy: "", Zdot: "", Zeta: "", Zfr: "", zeetrf: "", Zopf: "", integers: "", Zscr: "", aacute: "", abreve: "", ac: "", mstpos: "", acE: "", acd: "", acirc: "", acy: "", aelig: "", afr: "", agrave: "", alefsym: "", aleph: "", alpha: "", amacr: "", amalg: "", and: "", wedge: "", andand: "", andd: "", andslope: "", andv: "", ang: "", angle: "", ange: "", angmsd: "", measuredangle: "", angmsdaa: "", angmsdab: "", angmsdac: "", angmsdad: "", angmsdae: "", angmsdaf: "", angmsdag: "", angmsdah: "", angrt: "", angrtvb: "", angrtvbd: "", angsph: "", angzarr: "", aogon: "", aopf: "", apE: "", apacir: "", ape: "", approxeq: "", apid: "", apos: "'", aring: "", ascr: "", ast: "*", midast: "*", atilde: "", auml: "", awint: "", bNot: "", backcong: "", bcong: "", backepsilon: "", bepsi: "", backprime: "", bprime: "", backsim: "", bsim: "", backsimeq: "", bsime: "", barvee: "", barwed: "", barwedge: "", bbrktbrk: "", bcy: "", bdquo: "", ldquor: "", bemptyv: "", beta: "", beth: "", between: "", twixt: "", bfr: "", bigcirc: "", xcirc: "", bigodot: "", xodot: "", bigoplus: "", xoplus: "", bigotimes: "", xotime: "", bigsqcup: "", xsqcup: "", bigstar: "", starf: "", bigtriangledown: "", xdtri: "", bigtriangleup: "", xutri: "", biguplus: "", xuplus: "", bkarow: "", rbarr: "", blacklozenge: "", lozf: "", blacktriangle: "", utrif: "", blacktriangledown: "", dtrif: "", blacktriangleleft: "", ltrif: "", blacktriangleright: "", rtrif: "", blank: "", blk12: "", blk14: "", blk34: "", block: "", bne: "=", bnequiv: "", bnot: "", bopf: "", bowtie: "", boxDL: "", boxDR: "", boxDl: "", boxDr: "", boxH: "", boxHD: "", boxHU: "", boxHd: "", boxHu: "", boxUL: "", boxUR: "", boxUl: "", boxUr: "", boxV: "", boxVH: "", boxVL: "", boxVR: "", boxVh: "", boxVl: "", boxVr: "", boxbox: "", boxdL: "", boxdR: "", boxdl: "", boxdr: "", boxhD: "", boxhU: "", boxhd: "", boxhu: "", boxminus: "", minusb: "", boxplus: "", plusb: "", boxtimes: "", timesb: "", boxuL: "", boxuR: "", boxul: "", boxur: "", boxv: "", boxvH: "", boxvL: "", boxvR: "", boxvh: "", boxvl: "", boxvr: "", brvbar: "", bscr: "", bsemi: "", bsol: "\\", bsolb: "", bsolhsub: "", bull: "", bullet: "", bumpE: "", cacute: "", cap: "", capand: "", capbrcup: "", capcap: "", capcup: "", capdot: "", caps: "", caret: "", ccaps: "", ccaron: "", ccedil: "", ccirc: "", ccups: "", ccupssm: "", cdot: "", cemptyv: "", cent: "", cfr: "", chcy: "", check: "", checkmark: "", chi: "", cir: "", cirE: "", circ: "", circeq: "", cire: "", circlearrowleft: "", olarr: "", circlearrowright: "", orarr: "", circledS: "", oS: "", circledast: "", oast: "", circledcirc: "", ocir: "", circleddash: "", odash: "", cirfnint: "", cirmid: "", cirscir: "", clubs: "", clubsuit: "", colon: ":", comma: ",", commat: "@", comp: "", complement: "", congdot: "", copf: "", copysr: "", crarr: "", cross: "", cscr: "", csub: "", csube: "", csup: "", csupe: "", ctdot: "", cudarrl: "", cudarrr: "", cuepr: "", curlyeqprec: "", cuesc: "", curlyeqsucc: "", cularr: "", curvearrowleft: "", cularrp: "", cup: "", cupbrcap: "", cupcap: "", cupcup: "", cupdot: "", cupor: "", cups: "", curarr: "", curvearrowright: "", curarrm: "", curlyvee: "", cuvee: "", curlywedge: "", cuwed: "", curren: "", cwint: "", cylcty: "", dHar: "", dagger: "", daleth: "", dash: "", hyphen: "", dbkarow: "", rBarr: "", dcaron: "", dcy: "", ddarr: "", downdownarrows: "", ddotseq: "", eDDot: "", deg: "", delta: "", demptyv: "", dfisht: "", dfr: "", diamondsuit: "", diams: "", digamma: "", gammad: "", disin: "", div: "", divide: "", divideontimes: "", divonx: "", djcy: "", dlcorn: "", llcorner: "", dlcrop: "", dollar: "$", dopf: "", doteqdot: "", eDot: "", dotminus: "", minusd: "", dotplus: "", plusdo: "", dotsquare: "", sdotb: "", drcorn: "", lrcorner: "", drcrop: "", dscr: "", dscy: "", dsol: "", dstrok: "", dtdot: "", dtri: "", triangledown: "", dwangle: "", dzcy: "", dzigrarr: "", eacute: "", easter: "", ecaron: "", ecir: "", eqcirc: "", ecirc: "", ecolon: "", eqcolon: "", ecy: "", edot: "", efDot: "", fallingdotseq: "", efr: "", eg: "", egrave: "", egs: "", eqslantgtr: "", egsdot: "", el: "", elinters: "", ell: "", els: "", eqslantless: "", elsdot: "", emacr: "", empty: "", emptyset: "", emptyv: "", varnothing: "", emsp13: "", emsp14: "", emsp: "", eng: "", ensp: "", eogon: "", eopf: "", epar: "", eparsl: "", eplus: "", epsi: "", epsilon: "", epsiv: "", straightepsilon: "", varepsilon: "", equals: "=", equest: "", questeq: "", equivDD: "", eqvparsl: "", erDot: "", risingdotseq: "", erarr: "", escr: "", eta: "", eth: "", euml: "", euro: "", excl: "!", fcy: "", female: "", ffilig: "", fflig: "", ffllig: "", ffr: "", filig: "", fjlig: "fj", flat: "", fllig: "", fltns: "", fnof: "", fopf: "", fork: "", pitchfork: "", forkv: "", fpartint: "", frac12: "", half: "", frac13: "", frac14: "", frac15: "", frac16: "", frac18: "", frac23: "", frac25: "", frac34: "", frac35: "", frac38: "", frac45: "", frac56: "", frac58: "", frac78: "", frasl: "", frown: "", sfrown: "", fscr: "", gEl: "", gtreqqless: "", gacute: "", gamma: "", gap: "", gtrapprox: "", gbreve: "", gcirc: "", gcy: "", gdot: "", gescc: "", gesdot: "", gesdoto: "", gesdotol: "", gesl: "", gesles: "", gfr: "", gimel: "", gjcy: "", glE: "", gla: "", glj: "", gnE: "", gneqq: "", gnap: "", gnapprox: "", gne: "", gneq: "", gnsim: "", gopf: "", gscr: "", gsime: "", gsiml: "", gtcc: "", gtcir: "", gtdot: "", gtrdot: "", gtlPar: "", gtquest: "", gtrarr: "", gvertneqq: "", gvnE: "", hardcy: "", harrcir: "", harrw: "", leftrightsquigarrow: "", hbar: "", hslash: "", planck: "", plankv: "", hcirc: "", hearts: "", heartsuit: "", hellip: "", mldr: "", hercon: "", hfr: "", hksearow: "", searhk: "", hkswarow: "", swarhk: "", hoarr: "", homtht: "", hookleftarrow: "", larrhk: "", hookrightarrow: "", rarrhk: "", hopf: "", horbar: "", hscr: "", hstrok: "", hybull: "", iacute: "", icirc: "", icy: "", iecy: "", iexcl: "", ifr: "", igrave: "", iiiint: "", qint: "", iiint: "", tint: "", iinfin: "", iiota: "", ijlig: "", imacr: "", imath: "", inodot: "", imof: "", imped: "", incare: "", infin: "", infintie: "", intcal: "", intercal: "", intlarhk: "", intprod: "", iprod: "", iocy: "", iogon: "", iopf: "", iota: "", iquest: "", iscr: "", isinE: "", isindot: "", isins: "", isinsv: "", itilde: "", iukcy: "", iuml: "", jcirc: "", jcy: "", jfr: "", jmath: "", jopf: "", jscr: "", jsercy: "", jukcy: "", kappa: "", kappav: "", varkappa: "", kcedil: "", kcy: "", kfr: "", kgreen: "", khcy: "", kjcy: "", kopf: "", kscr: "", lAtail: "", lBarr: "", lEg: "", lesseqqgtr: "", lHar: "", lacute: "", laemptyv: "", lambda: "", langd: "", lap: "", lessapprox: "", laquo: "", larrbfs: "", larrfs: "", larrlp: "", looparrowleft: "", larrpl: "", larrsim: "", larrtl: "", leftarrowtail: "", lat: "", latail: "", late: "", lates: "", lbarr: "", lbbrk: "", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "", lbrksld: "", lbrkslu: "", lcaron: "", lcedil: "", lcy: "", ldca: "", ldrdhar: "", ldrushar: "", ldsh: "", le: "", leq: "", leftleftarrows: "", llarr: "", leftthreetimes: "", lthree: "", lescc: "", lesdot: "", lesdoto: "", lesdotor: "", lesg: "", lesges: "", lessdot: "", ltdot: "", lfisht: "", lfr: "", lgE: "", lharul: "", lhblk: "", ljcy: "", llhard: "", lltri: "", lmidot: "", lmoust: "", lmoustache: "", lnE: "", lneqq: "", lnap: "", lnapprox: "", lne: "", lneq: "", lnsim: "", loang: "", loarr: "", longmapsto: "", xmap: "", looparrowright: "", rarrlp: "", lopar: "", lopf: "", loplus: "", lotimes: "", lowast: "", loz: "", lozenge: "", lpar: "(", lparlt: "", lrhard: "", lrm: "", lrtri: "", lsaquo: "", lscr: "", lsime: "", lsimg: "", lsquor: "", sbquo: "", lstrok: "", ltcc: "", ltcir: "", ltimes: "", ltlarr: "", ltquest: "", ltrPar: "", ltri: "", triangleleft: "", lurdshar: "", luruhar: "", lvertneqq: "", lvnE: "", mDDot: "", macr: "", strns: "", male: "", malt: "", maltese: "", marker: "", mcomma: "", mcy: "", mdash: "", mfr: "", mho: "", micro: "", midcir: "", minus: "", minusdu: "", mlcp: "", models: "", mopf: "", mscr: "", mu: "", multimap: "", mumap: "", nGg: "", nGt: "", nLeftarrow: "", nlArr: "", nLeftrightarrow: "", nhArr: "", nLl: "", nLt: "", nRightarrow: "", nrArr: "", nVDash: "", nVdash: "", nacute: "", nang: "", napE: "", napid: "", napos: "", natur: "", natural: "", ncap: "", ncaron: "", ncedil: "", ncongdot: "", ncup: "", ncy: "", ndash: "", neArr: "", nearhk: "", nedot: "", nesear: "", toea: "", nfr: "", nharr: "", nleftrightarrow: "", nhpar: "", nis: "", nisd: "", njcy: "", nlE: "", nleqq: "", nlarr: "", nleftarrow: "", nldr: "", nopf: "", not: "", notinE: "", notindot: "", notinvb: "", notinvc: "", notnivb: "", notnivc: "", nparsl: "", npart: "", npolint: "", nrarr: "", nrightarrow: "", nrarrc: "", nrarrw: "", nscr: "", nsub: "", nsubE: "", nsubseteqq: "", nsup: "", nsupE: "", nsupseteqq: "", ntilde: "", nu: "", num: "#", numero: "", numsp: "", nvDash: "", nvHarr: "", nvap: "", nvdash: "", nvge: "", nvgt: ">", nvinfin: "", nvlArr: "", nvle: "", nvlt: "<", nvltrie: "", nvrArr: "", nvrtrie: "", nvsim: "", nwArr: "", nwarhk: "", nwnear: "", oacute: "", ocirc: "", ocy: "", odblac: "", odiv: "", odsold: "", oelig: "", ofcir: "", ofr: "", ogon: "", ograve: "", ogt: "", ohbar: "", olcir: "", olcross: "", olt: "", omacr: "", omega: "", omicron: "", omid: "", oopf: "", opar: "", operp: "", or: "", vee: "", ord: "", order: "", orderof: "", oscr: "", ordf: "", ordm: "", origof: "", oror: "", orslope: "", orv: "", oslash: "", osol: "", otilde: "", otimesas: "", ouml: "", ovbar: "", para: "", parsim: "", parsl: "", pcy: "", percnt: "%", period: ".", permil: "", pertenk: "", pfr: "", phi: "", phiv: "", straightphi: "", varphi: "", phone: "", pi: "", piv: "", varpi: "", planckh: "", plus: "+", plusacir: "", pluscir: "", plusdu: "", pluse: "", plussim: "", plustwo: "", pointint: "", popf: "", pound: "", prE: "", prap: "", precapprox: "", precnapprox: "", prnap: "", precneqq: "", prnE: "", precnsim: "", prnsim: "", prime: "", profalar: "", profline: "", profsurf: "", prurel: "", pscr: "", psi: "", puncsp: "", qfr: "", qopf: "", qprime: "", qscr: "", quatint: "", quest: "?", rAtail: "", rHar: "", race: "", racute: "", raemptyv: "", rangd: "", range: "", raquo: "", rarrap: "", rarrbfs: "", rarrc: "", rarrfs: "", rarrpl: "", rarrsim: "", rarrtl: "", rightarrowtail: "", rarrw: "", rightsquigarrow: "", ratail: "", ratio: "", rbbrk: "", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "", rbrksld: "", rbrkslu: "", rcaron: "", rcedil: "", rcy: "", rdca: "", rdldhar: "", rdsh: "", rect: "", rfisht: "", rfr: "", rharul: "", rho: "", rhov: "", varrho: "", rightrightarrows: "", rrarr: "", rightthreetimes: "", rthree: "", ring: "", rlm: "", rmoust: "", rmoustache: "", rnmid: "", roang: "", roarr: "", ropar: "", ropf: "", roplus: "", rotimes: "", rpar: ")", rpargt: "", rppolint: "", rsaquo: "", rscr: "", rtimes: "", rtri: "", triangleright: "", rtriltri: "", ruluhar: "", rx: "", sacute: "", scE: "", scap: "", succapprox: "", scaron: "", scedil: "", scirc: "", scnE: "", succneqq: "", scnap: "", succnapprox: "", scnsim: "", succnsim: "", scpolint: "", scy: "", sdot: "", sdote: "", seArr: "", sect: "", semi: ";", seswar: "", tosa: "", sext: "", sfr: "", sharp: "", shchcy: "", shcy: "", shy: "", sigma: "", sigmaf: "", sigmav: "", varsigma: "", simdot: "", simg: "", simgE: "", siml: "", simlE: "", simne: "", simplus: "", simrarr: "", smashp: "", smeparsl: "", smile: "", ssmile: "", smt: "", smte: "", smtes: "", softcy: "", sol: "/", solb: "", solbar: "", sopf: "", spades: "", spadesuit: "", sqcaps: "", sqcups: "", sscr: "", star: "", sub: "", subset: "", subE: "", subseteqq: "", subdot: "", subedot: "", submult: "", subnE: "", subsetneqq: "", subne: "", subsetneq: "", subplus: "", subrarr: "", subsim: "", subsub: "", subsup: "", sung: "", sup1: "", sup2: "", sup3: "", supE: "", supseteqq: "", supdot: "", supdsub: "", supedot: "", suphsol: "", suphsub: "", suplarr: "", supmult: "", supnE: "", supsetneqq: "", supne: "", supsetneq: "", supplus: "", supsim: "", supsub: "", supsup: "", swArr: "", swnwar: "", szlig: "", target: "", tau: "", tcaron: "", tcedil: "", tcy: "", telrec: "", tfr: "", theta: "", thetasym: "", thetav: "", vartheta: "", thorn: "", times: "", timesbar: "", timesd: "", topbot: "", topcir: "", topf: "", topfork: "", tprime: "", triangle: "", utri: "", triangleq: "", trie: "", tridot: "", triminus: "", triplus: "", trisb: "", tritime: "", trpezium: "", tscr: "", tscy: "", tshcy: "", tstrok: "", uHar: "", uacute: "", ubrcy: "", ubreve: "", ucirc: "", ucy: "", udblac: "", ufisht: "", ufr: "", ugrave: "", uhblk: "", ulcorn: "", ulcorner: "", ulcrop: "", ultri: "", umacr: "", uogon: "", uopf: "", upsi: "", upsilon: "", upuparrows: "", uuarr: "", urcorn: "", urcorner: "", urcrop: "", uring: "", urtri: "", uscr: "", utdot: "", utilde: "", uuml: "", uwangle: "", vBar: "", vBarv: "", vangrt: "", varsubsetneq: "", vsubne: "", varsubsetneqq: "", vsubnE: "", varsupsetneq: "", vsupne: "", varsupsetneqq: "", vsupnE: "", vcy: "", veebar: "", veeeq: "", vellip: "", vfr: "", vopf: "", vscr: "", vzigzag: "", wcirc: "", wedbar: "", wedgeq: "", weierp: "", wp: "", wfr: "", wopf: "", wscr: "", xfr: "", xi: "", xnis: "", xopf: "", xscr: "", yacute: "", yacy: "", ycirc: "", ycy: "", yen: "", yfr: "", yicy: "", yopf: "", yscr: "", yucy: "", yuml: "", zacute: "", zcaron: "", zcy: "", zdot: "", zeta: "", zfr: "", zhcy: "", zigrarr: "", zopf: "", zscr: "", zwj: "", zwnj: "" }, LI = "";
Xu.ngsp = LI;
var _I = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
function $I(t, e) {
  if (e != null && !(Array.isArray(e) && e.length == 2))
    throw new Error(`Expected '${t}' to be an array, [start, end].`);
  if (e != null) {
    let r = e[0], n = e[1];
    _I.forEach((i) => {
      if (i.test(r) || i.test(n))
        throw new Error(`['${r}', '${n}'] contains unusable interpolation symbol.`);
    });
  }
}
var RI = class g2 {
  static fromArray(e) {
    return e ? ($I("interpolation", e), new g2(e[0], e[1])) : y2;
  }
  constructor(e, r) {
    this.start = e, this.end = r;
  }
}, y2 = new RI("{{", "}}"), Qh = class extends p2 {
  constructor(e, r, n) {
    super(n, e), this.tokenType = r;
  }
}, jI = class {
  constructor(e, r, n) {
    this.tokens = e, this.errors = r, this.nonNormalizedIcuExpressions = n;
  }
};
function qI(t, e, r, n = {}) {
  let i = new HI(new h2(t, e), r, n);
  return i.tokenize(), new jI(XI(i.tokens), i.errors, i.nonNormalizedIcuExpressions);
}
var WI = /\r\n?/g;
function Ws(t) {
  return `Unexpected character "${t === 0 ? "EOF" : String.fromCharCode(t)}"`;
}
function Yy(t) {
  return `Unknown entity "${t}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
}
function UI(t, e) {
  return `Unable to parse entity "${e}" - ${t} character reference entities must end with ";"`;
}
var Yu;
(function(t) {
  t.HEX = "hexadecimal", t.DEC = "decimal";
})(Yu || (Yu = {}));
var Zh = class {
  constructor(e) {
    this.error = e;
  }
}, HI = class {
  constructor(e, r, n) {
    this._getTagContentType = r, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = !1, this._fullNameStack = [], this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = n.tokenizeExpansionForms || !1, this._interpolationConfig = n.interpolationConfig || y2, this._leadingTriviaCodePoints = n.leadingTriviaChars && n.leadingTriviaChars.map((s) => s.codePointAt(0) || 0), this._canSelfClose = n.canSelfClose || !1, this._allowHtmComponentClosingTags = n.allowHtmComponentClosingTags || !1;
    let i = n.range || { endPos: e.content.length, startPos: 0, startLine: 0, startCol: 0 };
    this._cursor = n.escapedString ? new YI(e, i) : new D2(e, i), this._preserveLineEndings = n.preserveLineEndings || !1, this._i18nNormalizeLineEndingsInICUs = n.i18nNormalizeLineEndingsInICUs || !1, this._tokenizeBlocks = n.tokenizeBlocks ?? !0;
    try {
      this._cursor.init();
    } catch (s) {
      this.handleError(s);
    }
  }
  _processCarriageReturns(e) {
    return this._preserveLineEndings ? e : e.replace(WI, `
`);
  }
  tokenize() {
    for (; this._cursor.peek() !== 0; ) {
      let e = this._cursor.clone();
      try {
        if (this._attemptCharCode(60))
          if (this._attemptCharCode(33))
            this._attemptStr("[CDATA[") ? this._consumeCdata(e) : this._attemptStr("--") ? this._consumeComment(e) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e) : this._consumeBogusComment(e);
          else if (this._attemptCharCode(47))
            this._consumeTagClose(e);
          else {
            let r = this._cursor.clone();
            this._attemptCharCode(63) ? (this._cursor = r, this._consumeBogusComment(e)) : this._consumeTagOpen(e);
          }
        else
          this._tokenizeBlocks && this._attemptCharCode(64) ? this._consumeBlockStart(e) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(125) ? this._consumeBlockEnd(e) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
      } catch (r) {
        this.handleError(r);
      }
    }
    this._beginToken(30), this._endToken([]);
  }
  _getBlockName() {
    let e = !1, r = this._cursor.clone();
    return this._attemptCharCodeUntilFn((n) => sm(n) ? !e : e0(n) ? (e = !0, !1) : !0), this._cursor.getChars(r).trim();
  }
  _consumeBlockStart(e) {
    this._beginToken(25, e);
    let r = this._endToken([this._getBlockName()]);
    if (this._cursor.peek() === 40)
      if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(bt), this._attemptCharCode(41))
        this._attemptCharCodeUntilFn(bt);
      else {
        r.type = 29;
        return;
      }
    this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : r.type = 29;
  }
  _consumeBlockEnd(e) {
    this._beginToken(27, e), this._endToken([]);
  }
  _consumeBlockParameters() {
    for (this._attemptCharCodeUntilFn(t0); this._cursor.peek() !== 41 && this._cursor.peek() !== 0; ) {
      this._beginToken(28);
      let e = this._cursor.clone(), r = null, n = 0;
      for (; this._cursor.peek() !== 59 && this._cursor.peek() !== 0 || r !== null; ) {
        let i = this._cursor.peek();
        if (i === 92)
          this._cursor.advance();
        else if (i === r)
          r = null;
        else if (r === null && $y(i))
          r = i;
        else if (i === 40 && r === null)
          n++;
        else if (i === 41 && r === null) {
          if (n === 0)
            break;
          n > 0 && n--;
        }
        this._cursor.advance();
      }
      this._endToken([this._cursor.getChars(e)]), this._attemptCharCodeUntilFn(t0);
    }
  }
  _tokenizeExpansionForm() {
    if (this.isExpansionFormStart())
      return this._consumeExpansionFormStart(), !0;
    if (KI(this._cursor.peek()) && this._isInExpansionForm())
      return this._consumeExpansionCaseStart(), !0;
    if (this._cursor.peek() === 125) {
      if (this._isInExpansionCase())
        return this._consumeExpansionCaseEnd(), !0;
      if (this._isInExpansionForm())
        return this._consumeExpansionFormEnd(), !0;
    }
    return !1;
  }
  _beginToken(e, r = this._cursor.clone()) {
    this._currentTokenStart = r, this._currentTokenType = e;
  }
  _endToken(e, r) {
    if (this._currentTokenStart === null)
      throw new Qh("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(r));
    if (this._currentTokenType === null)
      throw new Qh("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
    let n = { type: this._currentTokenType, parts: e, sourceSpan: (r ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
    return this.tokens.push(n), this._currentTokenStart = null, this._currentTokenType = null, n;
  }
  _createError(e, r) {
    this._isInExpansionForm() && (e += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
    let n = new Qh(e, this._currentTokenType, r);
    return this._currentTokenStart = null, this._currentTokenType = null, new Zh(n);
  }
  handleError(e) {
    if (e instanceof am && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), e instanceof Zh)
      this.errors.push(e.error);
    else
      throw e;
  }
  _attemptCharCode(e) {
    return this._cursor.peek() === e ? (this._cursor.advance(), !0) : !1;
  }
  _attemptCharCodeCaseInsensitive(e) {
    return GI(this._cursor.peek(), e) ? (this._cursor.advance(), !0) : !1;
  }
  _requireCharCode(e) {
    let r = this._cursor.clone();
    if (!this._attemptCharCode(e))
      throw this._createError(Ws(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptStr(e) {
    let r = e.length;
    if (this._cursor.charsLeft() < r)
      return !1;
    let n = this._cursor.clone();
    for (let i = 0; i < r; i++)
      if (!this._attemptCharCode(e.charCodeAt(i)))
        return this._cursor = n, !1;
    return !0;
  }
  _attemptStrCaseInsensitive(e) {
    for (let r = 0; r < e.length; r++)
      if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(r)))
        return !1;
    return !0;
  }
  _requireStr(e) {
    let r = this._cursor.clone();
    if (!this._attemptStr(e))
      throw this._createError(Ws(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _requireStrCaseInsensitive(e) {
    let r = this._cursor.clone();
    if (!this._attemptStrCaseInsensitive(e))
      throw this._createError(Ws(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptCharCodeUntilFn(e) {
    for (; !e(this._cursor.peek()); )
      this._cursor.advance();
  }
  _requireCharCodeUntilFn(e, r) {
    let n = this._cursor.clone();
    if (this._attemptCharCodeUntilFn(e), this._cursor.diff(n) < r)
      throw this._createError(Ws(this._cursor.peek()), this._cursor.getSpan(n));
  }
  _attemptUntilChar(e) {
    for (; this._cursor.peek() !== e; )
      this._cursor.advance();
  }
  _readChar() {
    let e = String.fromCodePoint(this._cursor.peek());
    return this._cursor.advance(), e;
  }
  _consumeEntity(e) {
    this._beginToken(9);
    let r = this._cursor.clone();
    if (this._cursor.advance(), this._attemptCharCode(35)) {
      let n = this._attemptCharCode(120) || this._attemptCharCode(88), i = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(zI), this._cursor.peek() != 59) {
        this._cursor.advance();
        let o = n ? Yu.HEX : Yu.DEC;
        throw this._createError(UI(o, this._cursor.getChars(r)), this._cursor.getSpan());
      }
      let s = this._cursor.getChars(i);
      this._cursor.advance();
      try {
        let o = parseInt(s, n ? 16 : 10);
        this._endToken([String.fromCharCode(o), this._cursor.getChars(r)]);
      } catch {
        throw this._createError(Yy(this._cursor.getChars(r)), this._cursor.getSpan());
      }
    } else {
      let n = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(JI), this._cursor.peek() != 59)
        this._beginToken(e, r), this._cursor = n, this._endToken(["&"]);
      else {
        let i = this._cursor.getChars(n);
        this._cursor.advance();
        let s = Xu[i];
        if (!s)
          throw this._createError(Yy(i), this._cursor.getSpan(r));
        this._endToken([s, `&${i};`]);
      }
    }
  }
  _consumeRawText(e, r) {
    this._beginToken(e ? 6 : 7);
    let n = [];
    for (; ; ) {
      let i = this._cursor.clone(), s = r();
      if (this._cursor = i, s)
        break;
      e && this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(n.join(""))]), n.length = 0, this._consumeEntity(6), this._beginToken(6)) : n.push(this._readChar());
    }
    this._endToken([this._processCarriageReturns(n.join(""))]);
  }
  _consumeComment(e) {
    this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("-->")), this._beginToken(11), this._requireStr("-->"), this._endToken([]);
  }
  _consumeBogusComment(e) {
    this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._cursor.peek() === 62), this._beginToken(11), this._cursor.advance(), this._endToken([]);
  }
  _consumeCdata(e) {
    this._beginToken(12, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]);
  }
  _consumeDocType(e) {
    this._beginToken(18, e), this._endToken([]), this._consumeRawText(!1, () => this._cursor.peek() === 62), this._beginToken(19), this._cursor.advance(), this._endToken([]);
  }
  _consumePrefixAndName() {
    let e = this._cursor.clone(), r = "";
    for (; this._cursor.peek() !== 58 && !VI(this._cursor.peek()); )
      this._cursor.advance();
    let n;
    this._cursor.peek() === 58 ? (r = this._cursor.getChars(e), this._cursor.advance(), n = this._cursor.clone()) : n = e, this._requireCharCodeUntilFn(Qy, r === "" ? 0 : 1);
    let i = this._cursor.getChars(n);
    return [r, i];
  }
  _consumeTagOpen(e) {
    let r, n, i, s = [];
    try {
      if (!om(this._cursor.peek()))
        throw this._createError(Ws(this._cursor.peek()), this._cursor.getSpan(e));
      for (i = this._consumeTagOpenStart(e), n = i.parts[0], r = i.parts[1], this._attemptCharCodeUntilFn(bt); this._cursor.peek() !== 47 && this._cursor.peek() !== 62 && this._cursor.peek() !== 60 && this._cursor.peek() !== 0; ) {
        let [l, u] = this._consumeAttributeName();
        if (this._attemptCharCodeUntilFn(bt), this._attemptCharCode(61)) {
          this._attemptCharCodeUntilFn(bt);
          let h = this._consumeAttributeValue();
          s.push({ prefix: l, name: u, value: h });
        } else
          s.push({ prefix: l, name: u });
        this._attemptCharCodeUntilFn(bt);
      }
      this._consumeTagOpenEnd();
    } catch (l) {
      if (l instanceof Zh) {
        i ? i.type = 4 : (this._beginToken(5, e), this._endToken(["<"]));
        return;
      }
      throw l;
    }
    if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === 2)
      return;
    let o = this._getTagContentType(r, n, this._fullNameStack.length > 0, s);
    this._handleFullNameStackForTagOpen(n, r), o === Qr.RAW_TEXT ? this._consumeRawTextWithTagClose(n, r, !1) : o === Qr.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(n, r, !0);
  }
  _consumeRawTextWithTagClose(e, r, n) {
    this._consumeRawText(n, () => !this._attemptCharCode(60) || !this._attemptCharCode(47) || (this._attemptCharCodeUntilFn(bt), !this._attemptStrCaseInsensitive(e ? `${e}:${r}` : r)) ? !1 : (this._attemptCharCodeUntilFn(bt), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((i) => i === 62, 3), this._cursor.advance(), this._endToken([e, r]), this._handleFullNameStackForTagClose(e, r);
  }
  _consumeTagOpenStart(e) {
    this._beginToken(0, e);
    let r = this._consumePrefixAndName();
    return this._endToken(r);
  }
  _consumeAttributeName() {
    let e = this._cursor.peek();
    if (e === 39 || e === 34)
      throw this._createError(Ws(e), this._cursor.getSpan());
    this._beginToken(14);
    let r = this._consumePrefixAndName();
    return this._endToken(r), r;
  }
  _consumeAttributeValue() {
    let e;
    if (this._cursor.peek() === 39 || this._cursor.peek() === 34) {
      let r = this._cursor.peek();
      this._consumeQuote(r);
      let n = () => this._cursor.peek() === r;
      e = this._consumeWithInterpolation(16, 17, n, n), this._consumeQuote(r);
    } else {
      let r = () => Qy(this._cursor.peek());
      e = this._consumeWithInterpolation(16, 17, r, r);
    }
    return e;
  }
  _consumeQuote(e) {
    this._beginToken(15), this._requireCharCode(e), this._endToken([String.fromCodePoint(e)]);
  }
  _consumeTagOpenEnd() {
    let e = this._attemptCharCode(47) ? 2 : 1;
    this._beginToken(e), this._requireCharCode(62), this._endToken([]);
  }
  _consumeTagClose(e) {
    if (this._beginToken(3, e), this._attemptCharCodeUntilFn(bt), this._allowHtmComponentClosingTags && this._attemptCharCode(47))
      this._attemptCharCodeUntilFn(bt), this._requireCharCode(62), this._endToken([]);
    else {
      let [r, n] = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(bt), this._requireCharCode(62), this._endToken([r, n]), this._handleFullNameStackForTagClose(r, n);
    }
  }
  _consumeExpansionFormStart() {
    this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
    let e = this._readUntil(44), r = this._processCarriageReturns(e);
    if (this._i18nNormalizeLineEndingsInICUs)
      this._endToken([r]);
    else {
      let i = this._endToken([e]);
      r !== e && this.nonNormalizedIcuExpressions.push(i);
    }
    this._requireCharCode(44), this._attemptCharCodeUntilFn(bt), this._beginToken(7);
    let n = this._readUntil(44);
    this._endToken([n]), this._requireCharCode(44), this._attemptCharCodeUntilFn(bt);
  }
  _consumeExpansionCaseStart() {
    this._beginToken(21);
    let e = this._readUntil(123).trim();
    this._endToken([e]), this._attemptCharCodeUntilFn(bt), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(bt), this._expansionCaseStack.push(22);
  }
  _consumeExpansionCaseEnd() {
    this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(bt), this._expansionCaseStack.pop();
  }
  _consumeExpansionFormEnd() {
    this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
  }
  _consumeWithInterpolation(e, r, n, i) {
    this._beginToken(e);
    let s = [];
    for (; !n(); ) {
      let l = this._cursor.clone();
      this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(s.join(""))], l), s.length = 0, this._consumeInterpolation(r, l, i), this._beginToken(e)) : this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(s.join(""))]), s.length = 0, this._consumeEntity(e), this._beginToken(e)) : s.push(this._readChar());
    }
    this._inInterpolation = !1;
    let o = this._processCarriageReturns(s.join(""));
    return this._endToken([o]), o;
  }
  _consumeInterpolation(e, r, n) {
    let i = [];
    this._beginToken(e, r), i.push(this._interpolationConfig.start);
    let s = this._cursor.clone(), o = null, l = !1;
    for (; this._cursor.peek() !== 0 && (n === null || !n()); ) {
      let u = this._cursor.clone();
      if (this._isTagStart()) {
        this._cursor = u, i.push(this._getProcessedChars(s, u)), this._endToken(i);
        return;
      }
      if (o === null)
        if (this._attemptStr(this._interpolationConfig.end)) {
          i.push(this._getProcessedChars(s, u)), i.push(this._interpolationConfig.end), this._endToken(i);
          return;
        } else
          this._attemptStr("//") && (l = !0);
      let h = this._cursor.peek();
      this._cursor.advance(), h === 92 ? this._cursor.advance() : h === o ? o = null : !l && o === null && $y(h) && (o = h);
    }
    i.push(this._getProcessedChars(s, this._cursor)), this._endToken(i);
  }
  _getProcessedChars(e, r) {
    return this._processCarriageReturns(r.getChars(e));
  }
  _isTextEnd() {
    return !!(this._isTagStart() || this._cursor.peek() === 0 || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === 125 && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._cursor.peek() === 125));
  }
  _isTagStart() {
    if (this._cursor.peek() === 60) {
      let e = this._cursor.clone();
      e.advance();
      let r = e.peek();
      if (97 <= r && r <= 122 || 65 <= r && r <= 90 || r === 47 || r === 33)
        return !0;
    }
    return !1;
  }
  _isBlockStart() {
    if (this._tokenizeBlocks && this._cursor.peek() === 64) {
      let e = this._cursor.clone();
      if (e.advance(), e0(e.peek()))
        return !0;
    }
    return !1;
  }
  _readUntil(e) {
    let r = this._cursor.clone();
    return this._attemptUntilChar(e), this._cursor.getChars(r);
  }
  _isInExpansion() {
    return this._isInExpansionCase() || this._isInExpansionForm();
  }
  _isInExpansionCase() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 22;
  }
  _isInExpansionForm() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 20;
  }
  isExpansionFormStart() {
    if (this._cursor.peek() !== 123)
      return !1;
    if (this._interpolationConfig) {
      let e = this._cursor.clone(), r = this._attemptStr(this._interpolationConfig.start);
      return this._cursor = e, !r;
    }
    return !0;
  }
  _handleFullNameStackForTagOpen(e, r) {
    let n = Gu(e, r);
    (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === n) && this._fullNameStack.push(n);
  }
  _handleFullNameStackForTagClose(e, r) {
    let n = Gu(e, r);
    this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === n && this._fullNameStack.pop();
  }
};
function bt(t) {
  return !sm(t) || t === 0;
}
function Qy(t) {
  return sm(t) || t === 62 || t === 60 || t === 47 || t === 39 || t === 34 || t === 61 || t === 0;
}
function VI(t) {
  return (t < 97 || 122 < t) && (t < 65 || 90 < t) && (t < 48 || t > 57);
}
function zI(t) {
  return t === 59 || t === 0 || !XB(t);
}
function JI(t) {
  return t === 59 || t === 0 || !om(t);
}
function KI(t) {
  return t !== 125;
}
function GI(t, e) {
  return Zy(t) === Zy(e);
}
function Zy(t) {
  return t >= 97 && t <= 122 ? t - 97 + 65 : t;
}
function e0(t) {
  return om(t) || l2(t) || t === 95;
}
function t0(t) {
  return t !== 59 && bt(t);
}
function XI(t) {
  let e = [], r;
  for (let n = 0; n < t.length; n++) {
    let i = t[n];
    r && r.type === 5 && i.type === 5 || r && r.type === 16 && i.type === 16 ? (r.parts[0] += i.parts[0], r.sourceSpan.end = i.sourceSpan.end) : (r = i, e.push(r));
  }
  return e;
}
var D2 = class nd {
  constructor(e, r) {
    if (e instanceof nd) {
      this.file = e.file, this.input = e.input, this.end = e.end;
      let n = e.state;
      this.state = { peek: n.peek, offset: n.offset, line: n.line, column: n.column };
    } else {
      if (!r)
        throw new Error("Programming error: the range argument must be provided with a file argument.");
      this.file = e, this.input = e.content, this.end = r.endPos, this.state = { peek: -1, offset: r.startPos, line: r.startLine, column: r.startCol };
    }
  }
  clone() {
    return new nd(this);
  }
  peek() {
    return this.state.peek;
  }
  charsLeft() {
    return this.end - this.state.offset;
  }
  diff(e) {
    return this.state.offset - e.state.offset;
  }
  advance() {
    this.advanceState(this.state);
  }
  init() {
    this.updatePeek(this.state);
  }
  getSpan(e, r) {
    e = e || this;
    let n = e;
    if (r)
      for (; this.diff(e) > 0 && r.indexOf(e.peek()) !== -1; )
        n === e && (e = e.clone()), e.advance();
    let i = this.locationFromCursor(e), s = this.locationFromCursor(this), o = n !== e ? this.locationFromCursor(n) : i;
    return new Le(i, s, o);
  }
  getChars(e) {
    return this.input.substring(e.state.offset, this.state.offset);
  }
  charAt(e) {
    return this.input.charCodeAt(e);
  }
  advanceState(e) {
    if (e.offset >= this.end)
      throw this.state = e, new am('Unexpected character "EOF"', this);
    let r = this.charAt(e.offset);
    r === 10 ? (e.line++, e.column = 0) : u2(r) || e.column++, e.offset++, this.updatePeek(e);
  }
  updatePeek(e) {
    e.peek = e.offset >= this.end ? 0 : this.charAt(e.offset);
  }
  locationFromCursor(e) {
    return new td(e.file, e.state.offset, e.state.line, e.state.column);
  }
}, YI = class id extends D2 {
  constructor(e, r) {
    e instanceof id ? (super(e), this.internalState = { ...e.internalState }) : (super(e, r), this.internalState = this.state);
  }
  advance() {
    this.state = this.internalState, super.advance(), this.processEscapeSequence();
  }
  init() {
    super.init(), this.processEscapeSequence();
  }
  clone() {
    return new id(this);
  }
  getChars(e) {
    let r = e.clone(), n = "";
    for (; r.internalState.offset < this.internalState.offset; )
      n += String.fromCodePoint(r.peek()), r.advance();
    return n;
  }
  processEscapeSequence() {
    let e = () => this.internalState.peek;
    if (e() === 92)
      if (this.internalState = { ...this.state }, this.advanceState(this.internalState), e() === 110)
        this.state.peek = 10;
      else if (e() === 114)
        this.state.peek = 13;
      else if (e() === 118)
        this.state.peek = 11;
      else if (e() === 116)
        this.state.peek = 9;
      else if (e() === 98)
        this.state.peek = 8;
      else if (e() === 102)
        this.state.peek = 12;
      else if (e() === 117)
        if (this.advanceState(this.internalState), e() === 123) {
          this.advanceState(this.internalState);
          let r = this.clone(), n = 0;
          for (; e() !== 125; )
            this.advanceState(this.internalState), n++;
          this.state.peek = this.decodeHexDigits(r, n);
        } else {
          let r = this.clone();
          this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 4);
        }
      else if (e() === 120) {
        this.advanceState(this.internalState);
        let r = this.clone();
        this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 2);
      } else if (_y(e())) {
        let r = "", n = 0, i = this.clone();
        for (; _y(e()) && n < 3; )
          i = this.clone(), r += String.fromCodePoint(e()), this.advanceState(this.internalState), n++;
        this.state.peek = parseInt(r, 8), this.internalState = i.internalState;
      } else
        u2(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
  }
  decodeHexDigits(e, r) {
    let n = this.input.slice(e.internalState.offset, e.internalState.offset + r), i = parseInt(n, 16);
    if (isNaN(i))
      throw e.state = e.internalState, new am("Invalid hexadecimal escape sequence", e);
    return i;
  }
}, am = class {
  constructor(e, r) {
    this.msg = e, this.cursor = r;
  }
}, Sr = class x2 extends p2 {
  static create(e, r, n) {
    return new x2(e, r, n);
  }
  constructor(e, r, n) {
    super(r, n), this.elementName = e;
  }
}, QI = class {
  constructor(e, r) {
    this.rootNodes = e, this.errors = r;
  }
}, ZI = class {
  constructor(e) {
    this.getTagDefinition = e;
  }
  parse(e, r, n, i = !1, s) {
    let o = (D) => (b, ...C) => D(b.toLowerCase(), ...C), l = i ? this.getTagDefinition : o(this.getTagDefinition), u = (D) => l(D).getContentType(), h = i ? s : o(s), p = qI(e, r, s ? (D, b, C, A) => {
      let x = h(D, b, C, A);
      return x !== void 0 ? x : u(D);
    } : u, n), d = n && n.canSelfClose || !1, m = n && n.allowHtmComponentClosingTags || !1, y = new eN(p.tokens, l, d, m, i);
    return y.build(), new QI(y.rootNodes, p.errors.concat(y.errors));
  }
}, eN = class b2 {
  constructor(e, r, n, i, s) {
    this.tokens = e, this.getTagDefinition = r, this.canSelfClose = n, this.allowHtmComponentClosingTags = i, this.isTagNameCaseSensitive = s, this._index = -1, this._containerStack = [], this.rootNodes = [], this.errors = [], this._advance();
  }
  build() {
    for (; this._peek.type !== 30; )
      this._peek.type === 0 || this._peek.type === 4 ? this._consumeStartTag(this._advance()) : this._peek.type === 3 ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === 12 ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === 10 ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6 ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === 20 ? this._consumeExpansion(this._advance()) : this._peek.type === 25 ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === 27 ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === 29 ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === 18 ? this._consumeDocType(this._advance()) : this._advance();
    for (let e of this._containerStack)
      e instanceof qs && this.errors.push(Sr.create(e.name, e.sourceSpan, `Unclosed block "${e.name}"`));
  }
  _advance() {
    let e = this._peek;
    return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e;
  }
  _advanceIf(e) {
    return this._peek.type === e ? this._advance() : null;
  }
  _consumeCdata(e) {
    let r = this._advance(), n = this._getText(r), i = this._advanceIf(13);
    this._addToParent(new FI(n, new Le(e.sourceSpan.start, (i || r).sourceSpan.end), [r]));
  }
  _consumeComment(e) {
    let r = this._advanceIf(7), n = this._advanceIf(11), i = r != null ? r.parts[0].trim() : null, s = new Le(e.sourceSpan.start, (n || r || e).sourceSpan.end);
    this._addToParent(new NI(i, s));
  }
  _consumeDocType(e) {
    let r = this._advanceIf(7), n = this._advanceIf(19), i = r != null ? r.parts[0].trim() : null, s = new Le(e.sourceSpan.start, (n || r || e).sourceSpan.end);
    this._addToParent(new MI(i, s));
  }
  _consumeExpansion(e) {
    let r = this._advance(), n = this._advance(), i = [];
    for (; this._peek.type === 21; ) {
      let o = this._parseExpansionCase();
      if (!o)
        return;
      i.push(o);
    }
    if (this._peek.type !== 24) {
      this.errors.push(Sr.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      return;
    }
    let s = new Le(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart);
    this._addToParent(new PI(r.parts[0], n.parts[0], i, s, r.sourceSpan)), this._advance();
  }
  _parseExpansionCase() {
    let e = this._advance();
    if (this._peek.type !== 22)
      return this.errors.push(Sr.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
    let r = this._advance(), n = this._collectExpansionExpTokens(r);
    if (!n)
      return null;
    let i = this._advance();
    n.push({ type: 30, parts: [], sourceSpan: i.sourceSpan });
    let s = new b2(n, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
    if (s.build(), s.errors.length > 0)
      return this.errors = this.errors.concat(s.errors), null;
    let o = new Le(e.sourceSpan.start, i.sourceSpan.end, e.sourceSpan.fullStart), l = new Le(r.sourceSpan.start, i.sourceSpan.end, r.sourceSpan.fullStart);
    return new BI(e.parts[0], s.rootNodes, o, e.sourceSpan, l);
  }
  _collectExpansionExpTokens(e) {
    let r = [], n = [22];
    for (; ; ) {
      if ((this._peek.type === 20 || this._peek.type === 22) && n.push(this._peek.type), this._peek.type === 23)
        if (r0(n, 22)) {
          if (n.pop(), n.length === 0)
            return r;
        } else
          return this.errors.push(Sr.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 24)
        if (r0(n, 20))
          n.pop();
        else
          return this.errors.push(Sr.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 30)
        return this.errors.push(Sr.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      r.push(this._advance());
    }
  }
  _getText(e) {
    let r = e.parts[0];
    if (r.length > 0 && r[0] == `
`) {
      let n = this._getClosestParentElement();
      n != null && n.children.length == 0 && this.getTagDefinition(n.name).ignoreFirstLf && (r = r.substring(1));
    }
    return r;
  }
  _consumeText(e) {
    let r = [e], n = e.sourceSpan, i = e.parts[0];
    if (i.length > 0 && i[0] === `
`) {
      let s = this._getContainer();
      s != null && s.children.length === 0 && this.getTagDefinition(s.name).ignoreFirstLf && (i = i.substring(1), r[0] = { type: e.type, sourceSpan: e.sourceSpan, parts: [i] });
    }
    for (; this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9; )
      e = this._advance(), r.push(e), e.type === 8 ? i += e.parts.join("").replace(/&([^;]+);/g, n0) : e.type === 9 ? i += e.parts[0] : i += e.parts.join("");
    if (i.length > 0) {
      let s = e.sourceSpan;
      this._addToParent(new kI(i, new Le(n.start, s.end, n.fullStart, n.details), r));
    }
  }
  _closeVoidElement() {
    let e = this._getContainer();
    e instanceof ci && this.getTagDefinition(e.name).isVoid && this._containerStack.pop();
  }
  _consumeStartTag(e) {
    let [r, n] = e.parts, i = [];
    for (; this._peek.type === 14; )
      i.push(this._consumeAttr(this._advance()));
    let s = this._getElementFullName(r, n, this._getClosestParentElement()), o = !1;
    if (this._peek.type === 2) {
      this._advance(), o = !0;
      let y = this.getTagDefinition(s);
      this.canSelfClose || y.canSelfClose || Fu(s) !== null || y.isVoid || this.errors.push(Sr.create(s, e.sourceSpan, `Only void, custom and foreign elements can be self closed "${e.parts[1]}"`));
    } else
      this._peek.type === 1 && (this._advance(), o = !1);
    let l = this._peek.sourceSpan.fullStart, u = new Le(e.sourceSpan.start, l, e.sourceSpan.fullStart), h = new Le(e.sourceSpan.start, l, e.sourceSpan.fullStart), p = new Le(e.sourceSpan.start.moveBy(1), e.sourceSpan.end), d = new ci(s, i, [], u, h, void 0, p), m = this._getContainer();
    this._pushContainer(d, m instanceof ci && this.getTagDefinition(m.name).isClosedByChild(d.name)), o ? this._popContainer(s, ci, u) : e.type === 4 && (this._popContainer(s, ci, null), this.errors.push(Sr.create(s, u, `Opening tag "${s}" not terminated.`)));
  }
  _pushContainer(e, r) {
    r && this._containerStack.pop(), this._addToParent(e), this._containerStack.push(e);
  }
  _consumeEndTag(e) {
    let r = this.allowHtmComponentClosingTags && e.parts.length === 0 ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getClosestParentElement());
    if (r && this.getTagDefinition(r).isVoid)
      this.errors.push(Sr.create(r, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
    else if (!this._popContainer(r, ci, e.sourceSpan)) {
      let n = `Unexpected closing tag "${r}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
      this.errors.push(Sr.create(r, e.sourceSpan, n));
    }
  }
  _popContainer(e, r, n) {
    let i = !1;
    for (let s = this._containerStack.length - 1; s >= 0; s--) {
      let o = this._containerStack[s];
      if (Fu(o.name) ? o.name === e : (e == null || o.name.toLowerCase() === e.toLowerCase()) && o instanceof r)
        return o.endSourceSpan = n, o.sourceSpan.end = n !== null ? n.end : o.sourceSpan.end, this._containerStack.splice(s, this._containerStack.length - s), !i;
      (o instanceof qs || o instanceof ci && !this.getTagDefinition(o.name).closedByParent) && (i = !0);
    }
    return !1;
  }
  _consumeAttr(e) {
    let r = Gu(e.parts[0], e.parts[1]), n = e.sourceSpan.end, i;
    this._peek.type === 15 && (i = this._advance());
    let s = "", o = [], l, u;
    if (this._peek.type === 16)
      for (l = this._peek.sourceSpan, u = this._peek.sourceSpan.end; this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9; ) {
        let p = this._advance();
        o.push(p), p.type === 17 ? s += p.parts.join("").replace(/&([^;]+);/g, n0) : p.type === 9 ? s += p.parts[0] : s += p.parts.join(""), u = n = p.sourceSpan.end;
      }
    this._peek.type === 15 && (u = n = this._advance().sourceSpan.end);
    let h = l && u && new Le((i == null ? void 0 : i.sourceSpan.start) ?? l.start, u, (i == null ? void 0 : i.sourceSpan.fullStart) ?? l.fullStart);
    return new II(r, s, new Le(e.sourceSpan.start, n, e.sourceSpan.fullStart), e.sourceSpan, h, o.length > 0 ? o : void 0, void 0);
  }
  _consumeBlockOpen(e) {
    let r = [];
    for (; this._peek.type === 28; ) {
      let l = this._advance();
      r.push(new Xy(l.parts[0], l.sourceSpan));
    }
    this._peek.type === 26 && this._advance();
    let n = this._peek.sourceSpan.fullStart, i = new Le(e.sourceSpan.start, n, e.sourceSpan.fullStart), s = new Le(e.sourceSpan.start, n, e.sourceSpan.fullStart), o = new qs(e.parts[0], r, [], i, s);
    this._pushContainer(o, !1);
  }
  _consumeBlockClose(e) {
    this._popContainer(null, qs, e.sourceSpan) || this.errors.push(Sr.create(null, e.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
  }
  _consumeIncompleteBlock(e) {
    let r = [];
    for (; this._peek.type === 28; ) {
      let l = this._advance();
      r.push(new Xy(l.parts[0], l.sourceSpan));
    }
    let n = this._peek.sourceSpan.fullStart, i = new Le(e.sourceSpan.start, n, e.sourceSpan.fullStart), s = new Le(e.sourceSpan.start, n, e.sourceSpan.fullStart), o = new qs(e.parts[0], r, [], i, s);
    this._pushContainer(o, !1), this._popContainer(null, qs, null), this.errors.push(Sr.create(e.parts[0], i, `Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
  }
  _getContainer() {
    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
  }
  _getClosestParentElement() {
    for (let e = this._containerStack.length - 1; e > -1; e--)
      if (this._containerStack[e] instanceof ci)
        return this._containerStack[e];
    return null;
  }
  _addToParent(e) {
    let r = this._getContainer();
    r === null ? this.rootNodes.push(e) : r.children.push(e);
  }
  _getElementFullName(e, r, n) {
    if (e === "" && (e = this.getTagDefinition(r).implicitNamespacePrefix || "", e === "" && n != null)) {
      let i = Zc(n.name)[1];
      this.getTagDefinition(i).preventNamespaceInheritance || (e = Fu(n.name));
    }
    return Gu(e, r);
  }
};
function r0(t, e) {
  return t.length > 0 && t[t.length - 1] === e;
}
function n0(t, e) {
  return Xu[e] !== void 0 ? Xu[e] || t : /^#x[a-f0-9]+$/i.test(e) ? String.fromCodePoint(parseInt(e.slice(2), 16)) : /^#\d+$/.test(e) ? String.fromCodePoint(parseInt(e.slice(1), 10)) : t;
}
var tN = class extends ZI {
  constructor() {
    super(rd);
  }
  parse(e, r, n, i = !1, s) {
    return super.parse(e, r, n, i, s);
  }
}, ep = null, rN = () => (ep || (ep = new tN()), ep);
function i0(t, e = {}) {
  let { canSelfClose: r = !1, allowHtmComponentClosingTags: n = !1, isTagNameCaseSensitive: i = !1, getTagContentType: s, tokenizeAngularBlocks: o = !1 } = e;
  return rN().parse(t, "angular-html-parser", { tokenizeExpansionForms: o, interpolationConfig: void 0, canSelfClose: r, allowHtmComponentClosingTags: n, tokenizeBlocks: o }, i, s);
}
function nN(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var iN = nN, sN = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
function oN(t) {
  let e = t.match(sN);
  if (!e)
    return { content: t };
  let { startDelimiter: r, language: n, value: i = "", endDelimiter: s } = e.groups, o = n.trim() || "yaml";
  if (r === "+++" && (o = "toml"), o !== "yaml" && r !== s)
    return { content: t };
  let [l] = e;
  return { frontMatter: { type: "front-matter", lang: o, value: i, startDelimiter: r, endDelimiter: s, raw: l.replace(/\n$/, "") }, content: Dr(!1, l, /[^\n]/g, " ") + t.slice(l.length) };
}
var aN = oN, Jl = { attrs: !0, children: !0, cases: !0, expression: !0 }, s0 = /* @__PURE__ */ new Set(["parent"]), lN = class pa {
  constructor(e = {}) {
    for (let r of /* @__PURE__ */ new Set([...s0, ...Object.keys(e)]))
      this.setProperty(r, e[r]);
  }
  setProperty(e, r) {
    if (this[e] !== r) {
      if (e in Jl && (r = r.map((n) => this.createChild(n))), !s0.has(e)) {
        this[e] = r;
        return;
      }
      Object.defineProperty(this, e, { value: r, enumerable: !1, configurable: !0 });
    }
  }
  map(e) {
    let r;
    for (let n in Jl) {
      let i = this[n];
      if (i) {
        let s = uN(i, (o) => o.map(e));
        r !== i && (r || (r = new pa({ parent: this.parent })), r.setProperty(n, s));
      }
    }
    if (r)
      for (let n in this)
        n in Jl || (r[n] = this[n]);
    return e(r || this);
  }
  walk(e) {
    for (let r in Jl) {
      let n = this[r];
      if (n)
        for (let i = 0; i < n.length; i++)
          n[i].walk(e);
    }
    e(this);
  }
  createChild(e) {
    let r = e instanceof pa ? e.clone() : new pa(e);
    return r.setProperty("parent", this), r;
  }
  insertChildBefore(e, r) {
    this.children.splice(this.children.indexOf(e), 0, this.createChild(r));
  }
  removeChild(e) {
    this.children.splice(this.children.indexOf(e), 1);
  }
  replaceChild(e, r) {
    this.children[this.children.indexOf(e)] = this.createChild(r);
  }
  clone() {
    return new pa(this);
  }
  get firstChild() {
    var e;
    return (e = this.children) == null ? void 0 : e[0];
  }
  get lastChild() {
    var e;
    return (e = this.children) == null ? void 0 : e[this.children.length - 1];
  }
  get prev() {
    var e, r;
    return (r = (e = this.parent) == null ? void 0 : e.children) == null ? void 0 : r[this.parent.children.indexOf(this) - 1];
  }
  get next() {
    var e, r;
    return (r = (e = this.parent) == null ? void 0 : e.children) == null ? void 0 : r[this.parent.children.indexOf(this) + 1];
  }
  get rawName() {
    return this.hasExplicitNamespace ? this.fullName : this.name;
  }
  get fullName() {
    return this.namespace ? this.namespace + ":" + this.name : this.name;
  }
  get attrMap() {
    return Object.fromEntries(this.attrs.map((e) => [e.fullName, e.value]));
  }
};
function uN(t, e) {
  let r = t.map(e);
  return r.some((n, i) => n !== t[i]) ? r : t;
}
var cN = [{ regex: /^(\[if([^\]]*)]>)(.*?)<!\s*\[endif]$/s, parse: pN }, { regex: /^\[if([^\]]*)]><!$/, parse: dN }, { regex: /^<!\s*\[endif]$/, parse: fN }];
function hN(t, e) {
  if (t.value)
    for (let { regex: r, parse: n } of cN) {
      let i = t.value.match(r);
      if (i)
        return n(t, e, i);
    }
  return null;
}
function pN(t, e, r) {
  let [, n, i, s] = r, o = 4 + n.length, l = t.sourceSpan.start.moveBy(o), u = l.moveBy(s.length), [h, p] = (() => {
    try {
      return [!0, e(s, l).children];
    } catch {
      return [!1, [{ type: "text", value: s, sourceSpan: new Le(l, u) }]];
    }
  })();
  return { type: "ieConditionalComment", complete: h, children: p, condition: Dr(!1, i.trim(), /\s+/g, " "), sourceSpan: t.sourceSpan, startSourceSpan: new Le(t.sourceSpan.start, l), endSourceSpan: new Le(u, t.sourceSpan.end) };
}
function dN(t, e, r) {
  let [, n] = r;
  return { type: "ieConditionalStartComment", condition: Dr(!1, n.trim(), /\s+/g, " "), sourceSpan: t.sourceSpan };
}
function fN(t) {
  return { type: "ieConditionalEndComment", sourceSpan: t.sourceSpan };
}
var tp = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set(["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "slot", "spellcheck", "style", "tabindex", "title", "translate"])], ["a", /* @__PURE__ */ new Set(["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"])], ["applet", /* @__PURE__ */ new Set(["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"])], ["area", /* @__PURE__ */ new Set(["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"])], ["audio", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"])], ["base", /* @__PURE__ */ new Set(["href", "target"])], ["basefont", /* @__PURE__ */ new Set(["color", "face", "size"])], ["blockquote", /* @__PURE__ */ new Set(["cite"])], ["body", /* @__PURE__ */ new Set(["alink", "background", "bgcolor", "link", "text", "vlink"])], ["br", /* @__PURE__ */ new Set(["clear"])], ["button", /* @__PURE__ */ new Set(["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "popovertarget", "popovertargetaction", "type", "value"])], ["canvas", /* @__PURE__ */ new Set(["height", "width"])], ["caption", /* @__PURE__ */ new Set(["align"])], ["col", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["colgroup", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["data", /* @__PURE__ */ new Set(["value"])], ["del", /* @__PURE__ */ new Set(["cite", "datetime"])], ["details", /* @__PURE__ */ new Set(["name", "open"])], ["dialog", /* @__PURE__ */ new Set(["open"])], ["dir", /* @__PURE__ */ new Set(["compact"])], ["div", /* @__PURE__ */ new Set(["align"])], ["dl", /* @__PURE__ */ new Set(["compact"])], ["embed", /* @__PURE__ */ new Set(["height", "src", "type", "width"])], ["fieldset", /* @__PURE__ */ new Set(["disabled", "form", "name"])], ["font", /* @__PURE__ */ new Set(["color", "face", "size"])], ["form", /* @__PURE__ */ new Set(["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"])], ["frame", /* @__PURE__ */ new Set(["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"])], ["frameset", /* @__PURE__ */ new Set(["cols", "rows"])], ["h1", /* @__PURE__ */ new Set(["align"])], ["h2", /* @__PURE__ */ new Set(["align"])], ["h3", /* @__PURE__ */ new Set(["align"])], ["h4", /* @__PURE__ */ new Set(["align"])], ["h5", /* @__PURE__ */ new Set(["align"])], ["h6", /* @__PURE__ */ new Set(["align"])], ["head", /* @__PURE__ */ new Set(["profile"])], ["hr", /* @__PURE__ */ new Set(["align", "noshade", "size", "width"])], ["html", /* @__PURE__ */ new Set(["manifest", "version"])], ["iframe", /* @__PURE__ */ new Set(["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"])], ["img", /* @__PURE__ */ new Set(["align", "alt", "border", "crossorigin", "decoding", "fetchpriority", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"])], ["input", /* @__PURE__ */ new Set(["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "popovertarget", "popovertargetaction", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"])], ["ins", /* @__PURE__ */ new Set(["cite", "datetime"])], ["isindex", /* @__PURE__ */ new Set(["prompt"])], ["label", /* @__PURE__ */ new Set(["for", "form"])], ["legend", /* @__PURE__ */ new Set(["align"])], ["li", /* @__PURE__ */ new Set(["type", "value"])], ["link", /* @__PURE__ */ new Set(["as", "blocking", "charset", "color", "crossorigin", "disabled", "fetchpriority", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"])], ["map", /* @__PURE__ */ new Set(["name"])], ["menu", /* @__PURE__ */ new Set(["compact"])], ["meta", /* @__PURE__ */ new Set(["charset", "content", "http-equiv", "media", "name", "scheme"])], ["meter", /* @__PURE__ */ new Set(["high", "low", "max", "min", "optimum", "value"])], ["object", /* @__PURE__ */ new Set(["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"])], ["ol", /* @__PURE__ */ new Set(["compact", "reversed", "start", "type"])], ["optgroup", /* @__PURE__ */ new Set(["disabled", "label"])], ["option", /* @__PURE__ */ new Set(["disabled", "label", "selected", "value"])], ["output", /* @__PURE__ */ new Set(["for", "form", "name"])], ["p", /* @__PURE__ */ new Set(["align"])], ["param", /* @__PURE__ */ new Set(["name", "type", "value", "valuetype"])], ["pre", /* @__PURE__ */ new Set(["width"])], ["progress", /* @__PURE__ */ new Set(["max", "value"])], ["q", /* @__PURE__ */ new Set(["cite"])], ["script", /* @__PURE__ */ new Set(["async", "blocking", "charset", "crossorigin", "defer", "fetchpriority", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"])], ["select", /* @__PURE__ */ new Set(["autocomplete", "disabled", "form", "multiple", "name", "required", "size"])], ["slot", /* @__PURE__ */ new Set(["name"])], ["source", /* @__PURE__ */ new Set(["height", "media", "sizes", "src", "srcset", "type", "width"])], ["style", /* @__PURE__ */ new Set(["blocking", "media", "type"])], ["table", /* @__PURE__ */ new Set(["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"])], ["tbody", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["td", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["template", /* @__PURE__ */ new Set(["shadowrootdelegatesfocus", "shadowrootmode"])], ["textarea", /* @__PURE__ */ new Set(["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"])], ["tfoot", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["th", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["thead", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["time", /* @__PURE__ */ new Set(["datetime"])], ["tr", /* @__PURE__ */ new Set(["align", "bgcolor", "char", "charoff", "valign"])], ["track", /* @__PURE__ */ new Set(["default", "kind", "label", "src", "srclang"])], ["ul", /* @__PURE__ */ new Set(["compact", "type"])], ["video", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"])]]), mN = /* @__PURE__ */ new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
function gN(t) {
  if (t.type === "block") {
    if (t.name = Dr(!1, t.name.toLowerCase(), /\s+/g, " ").trim(), t.type = "angularControlFlowBlock", !em(t.parameters)) {
      delete t.parameters;
      return;
    }
    for (let e of t.parameters)
      e.type = "angularControlFlowBlockParameter";
    t.parameters = { type: "angularControlFlowBlockParameters", children: t.parameters, sourceSpan: new Le(t.parameters[0].sourceSpan.start, cl(!1, t.parameters, -1).sourceSpan.end) };
  }
}
function yN(t) {
  (t.type === "plural" || t.type === "select") && (t.clause = t.type, t.type = "angularIcuExpression"), t.type === "expansionCase" && (t.type = "angularIcuCase");
}
function v2(t, e, r) {
  let { name: n, canSelfClose: i = !0, normalizeTagName: s = !1, normalizeAttributeName: o = !1, allowHtmComponentClosingTags: l = !1, isTagNameCaseSensitive: u = !1, shouldParseAsRawText: h } = e, { rootNodes: p, errors: d } = i0(t, { canSelfClose: i, allowHtmComponentClosingTags: l, isTagNameCaseSensitive: u, getTagContentType: h ? (...x) => h(...x) ? Qr.RAW_TEXT : void 0 : void 0, tokenizeAngularBlocks: n === "angular" ? !0 : void 0 });
  if (n === "vue") {
    if (p.some((w) => w.type === "docType" && w.value === "html" || w.type === "element" && w.name.toLowerCase() === "html"))
      return v2(t, A2, r);
    let x, E = () => x ?? (x = i0(t, { canSelfClose: i, allowHtmComponentClosingTags: l, isTagNameCaseSensitive: u })), k = (w) => E().rootNodes.find(({ startSourceSpan: T }) => T && T.start.offset === w.startSourceSpan.start.offset) ?? w;
    for (let [w, T] of p.entries()) {
      let { endSourceSpan: P, startSourceSpan: M } = T;
      if (P === null)
        d = E().errors, p[w] = k(T);
      else if (DN(T, r)) {
        let N = E().errors.find((L) => L.span.start.offset > M.start.offset && L.span.start.offset < P.end.offset);
        N && o0(N), p[w] = k(T);
      }
    }
  }
  d.length > 0 && o0(d[0]);
  let m = (x) => {
    let E = x.name.startsWith(":") ? x.name.slice(1).split(":")[0] : null, k = x.nameSpan.toString(), w = E !== null && k.startsWith(`${E}:`), T = w ? k.slice(E.length + 1) : k;
    x.name = T, x.namespace = E, x.hasExplicitNamespace = w;
  }, y = (x) => {
    switch (x.type) {
      case "element":
        m(x);
        for (let E of x.attrs)
          m(E), E.valueSpan ? (E.value = E.valueSpan.toString(), /["']/.test(E.value[0]) && (E.value = E.value.slice(1, -1))) : E.value = null;
        break;
      case "comment":
        x.value = x.sourceSpan.toString().slice(4, -3);
        break;
      case "text":
        x.value = x.sourceSpan.toString();
        break;
    }
  }, D = (x, E) => {
    let k = x.toLowerCase();
    return E(k) ? k : x;
  }, b = (x) => {
    if (x.type === "element" && (s && (!x.namespace || x.namespace === x.tagDefinition.implicitNamespacePrefix || $a(x)) && (x.name = D(x.name, (E) => mN.has(E))), o))
      for (let E of x.attrs)
        E.namespace || (E.name = D(E.name, (k) => tp.has(x.name) && (tp.get("*").has(k) || tp.get(x.name).has(k))));
  }, C = (x) => {
    x.sourceSpan && x.endSourceSpan && (x.sourceSpan = new Le(x.sourceSpan.start, x.endSourceSpan.end));
  }, A = (x) => {
    if (x.type === "element") {
      let E = rd(u ? x.name : x.name.toLowerCase());
      !x.namespace || x.namespace === E.implicitNamespacePrefix || $a(x) ? x.tagDefinition = E : x.tagDefinition = rd("");
    }
  };
  return m2(new class extends OI {
    visitExpansionCase(x, E) {
      n === "angular" && this.visitChildren(E, (k) => {
        k(x.expression);
      });
    }
    visit(x) {
      y(x), A(x), b(x), C(x);
    }
  }(), p), p;
}
function DN(t, e) {
  var r;
  if (t.type !== "element" || t.name !== "template")
    return !1;
  let n = (r = t.attrs.find((i) => i.name === "lang")) == null ? void 0 : r.value;
  return !n || zc(e, { language: n }) === "html";
}
function o0(t) {
  let { msg: e, span: { start: r, end: n } } = t;
  throw iN(e, { loc: { start: { line: r.line + 1, column: r.col + 1 }, end: { line: n.line + 1, column: n.col + 1 } }, cause: t });
}
function C2(t, e, r = {}, n = !0) {
  let { frontMatter: i, content: s } = n ? aN(t) : { frontMatter: null, content: t }, o = new h2(t, r.filepath), l = new td(o, 0, 0, 0), u = l.moveBy(t.length), h = { type: "root", sourceSpan: new Le(l, u), children: v2(s, e, r) };
  if (i) {
    let m = new td(o, 0, 0, 0), y = m.moveBy(i.raw.length);
    i.sourceSpan = new Le(m, y), h.children.unshift(i);
  }
  let p = new lN(h), d = (m, y) => {
    let { offset: D } = y, b = Dr(!1, t.slice(0, D), /[^\n\r]/g, " "), C = C2(b + m, e, r, !1);
    C.sourceSpan = new Le(y, cl(!1, C.children, -1).sourceSpan.end);
    let A = C.children[0];
    return A.length === D ? C.children.shift() : (A.sourceSpan = new Le(A.sourceSpan.start.moveBy(D), A.sourceSpan.end), A.value = A.value.slice(D)), C;
  };
  return p.walk((m) => {
    if (m.type === "comment") {
      let y = hN(m, d);
      y && m.parent.replaceChild(m, y);
    }
    gN(m), yN(m);
  }), p;
}
function eh(t) {
  return { parse: (e, r) => C2(e, t, r), hasPragma: qB, astFormat: "html", locStart: Gc, locEnd: Xc };
}
var A2 = { name: "html", normalizeTagName: !0, normalizeAttributeName: !0, allowHtmComponentClosingTags: !0 }, xN = eh(A2), bN = eh({ name: "angular" }), vN = eh({ name: "vue", isTagNameCaseSensitive: !0, shouldParseAsRawText(t, e, r, n) {
  return t.toLowerCase() !== "html" && !r && (t !== "template" || n.some(({ name: i, value: s }) => i === "lang" && s !== "html" && s !== "" && s !== void 0));
} }), CN = eh({ name: "lwc", canSelfClose: !1 }), AN = { html: mI }, EN = Nx, wN = Object.create, lm = Object.defineProperty, SN = Object.getOwnPropertyDescriptor, TN = Object.getOwnPropertyNames, kN = Object.getPrototypeOf, FN = Object.prototype.hasOwnProperty, re = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), E2 = (t, e) => {
  for (var r in e)
    lm(t, r, { get: e[r], enumerable: !0 });
}, PN = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of TN(e))
      !FN.call(t, i) && i !== r && lm(t, i, { get: () => e[i], enumerable: !(n = SN(e, i)) || n.enumerable });
  return t;
}, Ts = (t, e, r) => (r = t != null ? wN(kN(t)) : {}, PN(e || !t || !t.__esModule ? lm(r, "default", { value: t, enumerable: !0 }) : r, t)), BN = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = p, t.parse = m, t.parseWithComments = y, t.print = D, t.strip = d;
  var e = /\*\/$/, r = /^\/\*\*?/, n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, s = /^(\r?\n)+/, o = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, l = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, u = /(\r?\n|^) *\* ?/g, h = [];
  function p(C) {
    let A = C.match(n);
    return A ? A[0].trimLeft() : "";
  }
  function d(C) {
    let A = C.match(n);
    return A && A[0] ? C.substring(A[0].length) : C;
  }
  function m(C) {
    return y(C).pragmas;
  }
  function y(C) {
    let A = `
`;
    C = C.replace(r, "").replace(e, "").replace(u, "$1");
    let x = "";
    for (; x !== C; )
      x = C, C = C.replace(o, `${A}$1 $2${A}`);
    C = C.replace(s, "").trimRight();
    let E = /* @__PURE__ */ Object.create(null), k = C.replace(l, "").replace(s, "").trimRight(), w;
    for (; w = l.exec(C); ) {
      let T = w[2].replace(i, "");
      typeof E[w[1]] == "string" || Array.isArray(E[w[1]]) ? E[w[1]] = h.concat(E[w[1]], T) : E[w[1]] = T;
    }
    return { comments: k, pragmas: E };
  }
  function D({ comments: C = "", pragmas: A = {} }) {
    let x = `
`, E = "/**", k = " *", w = " */", T = Object.keys(A), P = T.flatMap((N) => b(N, A[N])).map((N) => `${k} ${N}${x}`).join("");
    if (!C) {
      if (T.length === 0)
        return "";
      if (T.length === 1 && !Array.isArray(A[T[0]])) {
        let N = A[T[0]];
        return `${E} ${b(T[0], N)[0]}${w}`;
      }
    }
    let M = C.split(x).map((N) => `${k} ${N}`).join(x) + x;
    return E + x + (C ? M : "") + (C && T.length ? k + x : "") + P + w;
  }
  function b(C, A) {
    return h.concat(A).map((x) => `@${C} ${x}`.trim());
  }
}), um = re((t, e) => {
  e.exports.isClean = Symbol("isClean"), e.exports.my = Symbol("my");
}), IN = re((t, e) => {
  var r = String, n = function() {
    return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r };
  };
  e.exports = n(), e.exports.createColors = n;
}), w2 = re(() => {
}), cm = re((t, e) => {
  var r = IN(), n = w2(), i = class S2 extends Error {
    constructor(o, l, u, h, p, d) {
      super(o), this.name = "CssSyntaxError", this.reason = o, p && (this.file = p), h && (this.source = h), d && (this.plugin = d), typeof l < "u" && typeof u < "u" && (typeof l == "number" ? (this.line = l, this.column = u) : (this.line = l.line, this.column = l.column, this.endLine = u.line, this.endColumn = u.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, S2);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(o) {
      if (!this.source)
        return "";
      let l = this.source;
      o == null && (o = r.isColorSupported), n && o && (l = n(l));
      let u = l.split(/\r?\n/), h = Math.max(this.line - 3, 0), p = Math.min(this.line + 2, u.length), d = String(p).length, m, y;
      if (o) {
        let { bold: D, gray: b, red: C } = r.createColors(!0);
        m = (A) => D(C(A)), y = (A) => b(A);
      } else
        m = y = (D) => D;
      return u.slice(h, p).map((D, b) => {
        let C = h + 1 + b, A = " " + (" " + C).slice(-d) + " | ";
        if (C === this.line) {
          let x = y(A.replace(/\d/g, " ")) + D.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return m(">") + y(A) + D + `
 ` + x + m("^");
        }
        return " " + y(A) + D;
      }).join(`
`);
    }
    toString() {
      let o = this.showSourceCode();
      return o && (o = `

` + o + `
`), this.name + ": " + this.message + o;
    }
  };
  e.exports = i, i.default = i;
}), hm = re((t, e) => {
  var r = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: !1 };
  function n(s) {
    return s[0].toUpperCase() + s.slice(1);
  }
  var i = class {
    constructor(s) {
      this.builder = s;
    }
    atrule(s, o) {
      let l = "@" + s.name, u = s.params ? this.rawValue(s, "params") : "";
      if (typeof s.raws.afterName < "u" ? l += s.raws.afterName : u && (l += " "), s.nodes)
        this.block(s, l + u);
      else {
        let h = (s.raws.between || "") + (o ? ";" : "");
        this.builder(l + u + h, s);
      }
    }
    beforeAfter(s, o) {
      let l;
      s.type === "decl" ? l = this.raw(s, null, "beforeDecl") : s.type === "comment" ? l = this.raw(s, null, "beforeComment") : o === "before" ? l = this.raw(s, null, "beforeRule") : l = this.raw(s, null, "beforeClose");
      let u = s.parent, h = 0;
      for (; u && u.type !== "root"; )
        h += 1, u = u.parent;
      if (l.includes(`
`)) {
        let p = this.raw(s, null, "indent");
        if (p.length)
          for (let d = 0; d < h; d++)
            l += p;
      }
      return l;
    }
    block(s, o) {
      let l = this.raw(s, "between", "beforeOpen");
      this.builder(o + l + "{", s, "start");
      let u;
      s.nodes && s.nodes.length ? (this.body(s), u = this.raw(s, "after")) : u = this.raw(s, "after", "emptyBody"), u && this.builder(u), this.builder("}", s, "end");
    }
    body(s) {
      let o = s.nodes.length - 1;
      for (; o > 0 && s.nodes[o].type === "comment"; )
        o -= 1;
      let l = this.raw(s, "semicolon");
      for (let u = 0; u < s.nodes.length; u++) {
        let h = s.nodes[u], p = this.raw(h, "before");
        p && this.builder(p), this.stringify(h, o !== u || l);
      }
    }
    comment(s) {
      let o = this.raw(s, "left", "commentLeft"), l = this.raw(s, "right", "commentRight");
      this.builder("/*" + o + s.text + l + "*/", s);
    }
    decl(s, o) {
      let l = this.raw(s, "between", "colon"), u = s.prop + l + this.rawValue(s, "value");
      s.important && (u += s.raws.important || " !important"), o && (u += ";"), this.builder(u, s);
    }
    document(s) {
      this.body(s);
    }
    raw(s, o, l) {
      let u;
      if (l || (l = o), o && (u = s.raws[o], typeof u < "u"))
        return u;
      let h = s.parent;
      if (l === "before" && (!h || h.type === "root" && h.first === s || h && h.type === "document"))
        return "";
      if (!h)
        return r[l];
      let p = s.root();
      if (p.rawCache || (p.rawCache = {}), typeof p.rawCache[l] < "u")
        return p.rawCache[l];
      if (l === "before" || l === "after")
        return this.beforeAfter(s, l);
      {
        let d = "raw" + n(l);
        this[d] ? u = this[d](p, s) : p.walk((m) => {
          if (u = m.raws[o], typeof u < "u")
            return !1;
        });
      }
      return typeof u > "u" && (u = r[l]), p.rawCache[l] = u, u;
    }
    rawBeforeClose(s) {
      let o;
      return s.walk((l) => {
        if (l.nodes && l.nodes.length > 0 && typeof l.raws.after < "u")
          return o = l.raws.after, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), !1;
      }), o && (o = o.replace(/\S/g, "")), o;
    }
    rawBeforeComment(s, o) {
      let l;
      return s.walkComments((u) => {
        if (typeof u.raws.before < "u")
          return l = u.raws.before, l.includes(`
`) && (l = l.replace(/[^\n]+$/, "")), !1;
      }), typeof l > "u" ? l = this.raw(o, null, "beforeDecl") : l && (l = l.replace(/\S/g, "")), l;
    }
    rawBeforeDecl(s, o) {
      let l;
      return s.walkDecls((u) => {
        if (typeof u.raws.before < "u")
          return l = u.raws.before, l.includes(`
`) && (l = l.replace(/[^\n]+$/, "")), !1;
      }), typeof l > "u" ? l = this.raw(o, null, "beforeRule") : l && (l = l.replace(/\S/g, "")), l;
    }
    rawBeforeOpen(s) {
      let o;
      return s.walk((l) => {
        if (l.type !== "decl" && (o = l.raws.between, typeof o < "u"))
          return !1;
      }), o;
    }
    rawBeforeRule(s) {
      let o;
      return s.walk((l) => {
        if (l.nodes && (l.parent !== s || s.first !== l) && typeof l.raws.before < "u")
          return o = l.raws.before, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), !1;
      }), o && (o = o.replace(/\S/g, "")), o;
    }
    rawColon(s) {
      let o;
      return s.walkDecls((l) => {
        if (typeof l.raws.between < "u")
          return o = l.raws.between.replace(/[^\s:]/g, ""), !1;
      }), o;
    }
    rawEmptyBody(s) {
      let o;
      return s.walk((l) => {
        if (l.nodes && l.nodes.length === 0 && (o = l.raws.after, typeof o < "u"))
          return !1;
      }), o;
    }
    rawIndent(s) {
      if (s.raws.indent)
        return s.raws.indent;
      let o;
      return s.walk((l) => {
        let u = l.parent;
        if (u && u !== s && u.parent && u.parent === s && typeof l.raws.before < "u") {
          let h = l.raws.before.split(`
`);
          return o = h[h.length - 1], o = o.replace(/\S/g, ""), !1;
        }
      }), o;
    }
    rawSemicolon(s) {
      let o;
      return s.walk((l) => {
        if (l.nodes && l.nodes.length && l.last.type === "decl" && (o = l.raws.semicolon, typeof o < "u"))
          return !1;
      }), o;
    }
    rawValue(s, o) {
      let l = s[o], u = s.raws[o];
      return u && u.value === l ? u.raw : l;
    }
    root(s) {
      this.body(s), s.raws.after && this.builder(s.raws.after);
    }
    rule(s) {
      this.block(s, this.rawValue(s, "selector")), s.raws.ownSemicolon && this.builder(s.raws.ownSemicolon, s, "end");
    }
    stringify(s, o) {
      if (!this[s.type])
        throw new Error("Unknown AST node type " + s.type + ". Maybe you need to change PostCSS stringifier.");
      this[s.type](s, o);
    }
  };
  e.exports = i, i.default = i;
}), th = re((t, e) => {
  var r = hm();
  function n(i, s) {
    new r(s).stringify(i);
  }
  e.exports = n, n.default = n;
}), rh = re((t, e) => {
  var { isClean: r, my: n } = um(), i = cm(), s = hm(), o = th();
  function l(h, p) {
    let d = new h.constructor();
    for (let m in h) {
      if (!Object.prototype.hasOwnProperty.call(h, m) || m === "proxyCache")
        continue;
      let y = h[m], D = typeof y;
      m === "parent" && D === "object" ? p && (d[m] = p) : m === "source" ? d[m] = y : Array.isArray(y) ? d[m] = y.map((b) => l(b, d)) : (D === "object" && y !== null && (y = l(y)), d[m] = y);
    }
    return d;
  }
  var u = class {
    constructor(h = {}) {
      this.raws = {}, this[r] = !1, this[n] = !0;
      for (let p in h)
        if (p === "nodes") {
          this.nodes = [];
          for (let d of h[p])
            typeof d.clone == "function" ? this.append(d.clone()) : this.append(d);
        } else
          this[p] = h[p];
    }
    addToError(h) {
      if (h.postcssNode = this, h.stack && this.source && /\n\s{4}at /.test(h.stack)) {
        let p = this.source;
        h.stack = h.stack.replace(/\n\s{4}at /, `$&${p.input.from}:${p.start.line}:${p.start.column}$&`);
      }
      return h;
    }
    after(h) {
      return this.parent.insertAfter(this, h), this;
    }
    assign(h = {}) {
      for (let p in h)
        this[p] = h[p];
      return this;
    }
    before(h) {
      return this.parent.insertBefore(this, h), this;
    }
    cleanRaws(h) {
      delete this.raws.before, delete this.raws.after, h || delete this.raws.between;
    }
    clone(h = {}) {
      let p = l(this);
      for (let d in h)
        p[d] = h[d];
      return p;
    }
    cloneAfter(h = {}) {
      let p = this.clone(h);
      return this.parent.insertAfter(this, p), p;
    }
    cloneBefore(h = {}) {
      let p = this.clone(h);
      return this.parent.insertBefore(this, p), p;
    }
    error(h, p = {}) {
      if (this.source) {
        let { end: d, start: m } = this.rangeBy(p);
        return this.source.input.error(h, { column: m.column, line: m.line }, { column: d.column, line: d.line }, p);
      }
      return new i(h);
    }
    getProxyProcessor() {
      return { get(h, p) {
        return p === "proxyOf" ? h : p === "root" ? () => h.root().toProxy() : h[p];
      }, set(h, p, d) {
        return h[p] === d || (h[p] = d, (p === "prop" || p === "value" || p === "name" || p === "params" || p === "important" || p === "text") && h.markDirty()), !0;
      } };
    }
    markDirty() {
      if (this[r]) {
        this[r] = !1;
        let h = this;
        for (; h = h.parent; )
          h[r] = !1;
      }
    }
    next() {
      if (!this.parent)
        return;
      let h = this.parent.index(this);
      return this.parent.nodes[h + 1];
    }
    positionBy(h, p) {
      let d = this.source.start;
      if (h.index)
        d = this.positionInside(h.index, p);
      else if (h.word) {
        p = this.toString();
        let m = p.indexOf(h.word);
        m !== -1 && (d = this.positionInside(m, p));
      }
      return d;
    }
    positionInside(h, p) {
      let d = p || this.toString(), m = this.source.start.column, y = this.source.start.line;
      for (let D = 0; D < h; D++)
        d[D] === `
` ? (m = 1, y += 1) : m += 1;
      return { column: m, line: y };
    }
    prev() {
      if (!this.parent)
        return;
      let h = this.parent.index(this);
      return this.parent.nodes[h - 1];
    }
    rangeBy(h) {
      let p = { column: this.source.start.column, line: this.source.start.line }, d = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: p.column + 1, line: p.line };
      if (h.word) {
        let m = this.toString(), y = m.indexOf(h.word);
        y !== -1 && (p = this.positionInside(y, m), d = this.positionInside(y + h.word.length, m));
      } else
        h.start ? p = { column: h.start.column, line: h.start.line } : h.index && (p = this.positionInside(h.index)), h.end ? d = { column: h.end.column, line: h.end.line } : h.endIndex ? d = this.positionInside(h.endIndex) : h.index && (d = this.positionInside(h.index + 1));
      return (d.line < p.line || d.line === p.line && d.column <= p.column) && (d = { column: p.column + 1, line: p.line }), { end: d, start: p };
    }
    raw(h, p) {
      return new s().raw(this, h, p);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith(...h) {
      if (this.parent) {
        let p = this, d = !1;
        for (let m of h)
          m === this ? d = !0 : d ? (this.parent.insertAfter(p, m), p = m) : this.parent.insertBefore(p, m);
        d || this.remove();
      }
      return this;
    }
    root() {
      let h = this;
      for (; h.parent && h.parent.type !== "document"; )
        h = h.parent;
      return h;
    }
    toJSON(h, p) {
      let d = {}, m = p == null;
      p = p || /* @__PURE__ */ new Map();
      let y = 0;
      for (let D in this) {
        if (!Object.prototype.hasOwnProperty.call(this, D) || D === "parent" || D === "proxyCache")
          continue;
        let b = this[D];
        if (Array.isArray(b))
          d[D] = b.map((C) => typeof C == "object" && C.toJSON ? C.toJSON(null, p) : C);
        else if (typeof b == "object" && b.toJSON)
          d[D] = b.toJSON(null, p);
        else if (D === "source") {
          let C = p.get(b.input);
          C == null && (C = y, p.set(b.input, y), y++), d[D] = { end: b.end, inputId: C, start: b.start };
        } else
          d[D] = b;
      }
      return m && (d.inputs = [...p.keys()].map((D) => D.toJSON())), d;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(h = o) {
      h.stringify && (h = h.stringify);
      let p = "";
      return h(this, (d) => {
        p += d;
      }), p;
    }
    warn(h, p, d) {
      let m = { node: this };
      for (let y in d)
        m[y] = d[y];
      return h.warn(p, m);
    }
    get proxyOf() {
      return this;
    }
  };
  e.exports = u, u.default = u;
}), nh = re((t, e) => {
  var r = rh(), n = class extends r {
    constructor(i) {
      i && typeof i.value < "u" && typeof i.value != "string" && (i = { ...i, value: String(i.value) }), super(i), this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
  };
  e.exports = n, n.default = n;
}), ml = re((t, e) => {
  var r = rh(), n = class extends r {
    constructor(i) {
      super(i), this.type = "comment";
    }
  };
  e.exports = n, n.default = n;
}), ks = re((t, e) => {
  var { isClean: r, my: n } = um(), i = nh(), s = ml(), o = rh(), l, u, h, p;
  function d(D) {
    return D.map((b) => (b.nodes && (b.nodes = d(b.nodes)), delete b.source, b));
  }
  function m(D) {
    if (D[r] = !1, D.proxyOf.nodes)
      for (let b of D.proxyOf.nodes)
        m(b);
  }
  var y = class T2 extends o {
    append(...b) {
      for (let C of b) {
        let A = this.normalize(C, this.last);
        for (let x of A)
          this.proxyOf.nodes.push(x);
      }
      return this.markDirty(), this;
    }
    cleanRaws(b) {
      if (super.cleanRaws(b), this.nodes)
        for (let C of this.nodes)
          C.cleanRaws(b);
    }
    each(b) {
      if (!this.proxyOf.nodes)
        return;
      let C = this.getIterator(), A, x;
      for (; this.indexes[C] < this.proxyOf.nodes.length && (A = this.indexes[C], x = b(this.proxyOf.nodes[A], A), x !== !1); )
        this.indexes[C] += 1;
      return delete this.indexes[C], x;
    }
    every(b) {
      return this.nodes.every(b);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let b = this.lastEach;
      return this.indexes[b] = 0, b;
    }
    getProxyProcessor() {
      return { get(b, C) {
        return C === "proxyOf" ? b : b[C] ? C === "each" || typeof C == "string" && C.startsWith("walk") ? (...A) => b[C](...A.map((x) => typeof x == "function" ? (E, k) => x(E.toProxy(), k) : x)) : C === "every" || C === "some" ? (A) => b[C]((x, ...E) => A(x.toProxy(), ...E)) : C === "root" ? () => b.root().toProxy() : C === "nodes" ? b.nodes.map((A) => A.toProxy()) : C === "first" || C === "last" ? b[C].toProxy() : b[C] : b[C];
      }, set(b, C, A) {
        return b[C] === A || (b[C] = A, (C === "name" || C === "params" || C === "selector") && b.markDirty()), !0;
      } };
    }
    index(b) {
      return typeof b == "number" ? b : (b.proxyOf && (b = b.proxyOf), this.proxyOf.nodes.indexOf(b));
    }
    insertAfter(b, C) {
      let A = this.index(b), x = this.normalize(C, this.proxyOf.nodes[A]).reverse();
      A = this.index(b);
      for (let k of x)
        this.proxyOf.nodes.splice(A + 1, 0, k);
      let E;
      for (let k in this.indexes)
        E = this.indexes[k], A < E && (this.indexes[k] = E + x.length);
      return this.markDirty(), this;
    }
    insertBefore(b, C) {
      let A = this.index(b), x = A === 0 ? "prepend" : !1, E = this.normalize(C, this.proxyOf.nodes[A], x).reverse();
      A = this.index(b);
      for (let w of E)
        this.proxyOf.nodes.splice(A, 0, w);
      let k;
      for (let w in this.indexes)
        k = this.indexes[w], A <= k && (this.indexes[w] = k + E.length);
      return this.markDirty(), this;
    }
    normalize(b, C) {
      if (typeof b == "string")
        b = d(l(b).nodes);
      else if (Array.isArray(b)) {
        b = b.slice(0);
        for (let A of b)
          A.parent && A.parent.removeChild(A, "ignore");
      } else if (b.type === "root" && this.type !== "document") {
        b = b.nodes.slice(0);
        for (let A of b)
          A.parent && A.parent.removeChild(A, "ignore");
      } else if (b.type)
        b = [b];
      else if (b.prop) {
        if (typeof b.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof b.value != "string" && (b.value = String(b.value)), b = [new i(b)];
      } else if (b.selector)
        b = [new u(b)];
      else if (b.name)
        b = [new h(b)];
      else if (b.text)
        b = [new s(b)];
      else
        throw new Error("Unknown node type in node creation");
      return b.map((A) => (A[n] || T2.rebuild(A), A = A.proxyOf, A.parent && A.parent.removeChild(A), A[r] && m(A), typeof A.raws.before > "u" && C && typeof C.raws.before < "u" && (A.raws.before = C.raws.before.replace(/\S/g, "")), A.parent = this.proxyOf, A));
    }
    prepend(...b) {
      b = b.reverse();
      for (let C of b) {
        let A = this.normalize(C, this.first, "prepend").reverse();
        for (let x of A)
          this.proxyOf.nodes.unshift(x);
        for (let x in this.indexes)
          this.indexes[x] = this.indexes[x] + A.length;
      }
      return this.markDirty(), this;
    }
    push(b) {
      return b.parent = this, this.proxyOf.nodes.push(b), this;
    }
    removeAll() {
      for (let b of this.proxyOf.nodes)
        b.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(b) {
      b = this.index(b), this.proxyOf.nodes[b].parent = void 0, this.proxyOf.nodes.splice(b, 1);
      let C;
      for (let A in this.indexes)
        C = this.indexes[A], C >= b && (this.indexes[A] = C - 1);
      return this.markDirty(), this;
    }
    replaceValues(b, C, A) {
      return A || (A = C, C = {}), this.walkDecls((x) => {
        C.props && !C.props.includes(x.prop) || C.fast && !x.value.includes(C.fast) || (x.value = x.value.replace(b, A));
      }), this.markDirty(), this;
    }
    some(b) {
      return this.nodes.some(b);
    }
    walk(b) {
      return this.each((C, A) => {
        let x;
        try {
          x = b(C, A);
        } catch (E) {
          throw C.addToError(E);
        }
        return x !== !1 && C.walk && (x = C.walk(b)), x;
      });
    }
    walkAtRules(b, C) {
      return C ? b instanceof RegExp ? this.walk((A, x) => {
        if (A.type === "atrule" && b.test(A.name))
          return C(A, x);
      }) : this.walk((A, x) => {
        if (A.type === "atrule" && A.name === b)
          return C(A, x);
      }) : (C = b, this.walk((A, x) => {
        if (A.type === "atrule")
          return C(A, x);
      }));
    }
    walkComments(b) {
      return this.walk((C, A) => {
        if (C.type === "comment")
          return b(C, A);
      });
    }
    walkDecls(b, C) {
      return C ? b instanceof RegExp ? this.walk((A, x) => {
        if (A.type === "decl" && b.test(A.prop))
          return C(A, x);
      }) : this.walk((A, x) => {
        if (A.type === "decl" && A.prop === b)
          return C(A, x);
      }) : (C = b, this.walk((A, x) => {
        if (A.type === "decl")
          return C(A, x);
      }));
    }
    walkRules(b, C) {
      return C ? b instanceof RegExp ? this.walk((A, x) => {
        if (A.type === "rule" && b.test(A.selector))
          return C(A, x);
      }) : this.walk((A, x) => {
        if (A.type === "rule" && A.selector === b)
          return C(A, x);
      }) : (C = b, this.walk((A, x) => {
        if (A.type === "rule")
          return C(A, x);
      }));
    }
    get first() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
  };
  y.registerParse = (D) => {
    l = D;
  }, y.registerRule = (D) => {
    u = D;
  }, y.registerAtRule = (D) => {
    h = D;
  }, y.registerRoot = (D) => {
    p = D;
  }, e.exports = y, y.default = y, y.rebuild = (D) => {
    D.type === "atrule" ? Object.setPrototypeOf(D, h.prototype) : D.type === "rule" ? Object.setPrototypeOf(D, u.prototype) : D.type === "decl" ? Object.setPrototypeOf(D, i.prototype) : D.type === "comment" ? Object.setPrototypeOf(D, s.prototype) : D.type === "root" && Object.setPrototypeOf(D, p.prototype), D[n] = !0, D.nodes && D.nodes.forEach((b) => {
      y.rebuild(b);
    });
  };
}), pm = re((t, e) => {
  var r = /[\t\n\f\r "#'()/;[\\\]{}]/g, n = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, i = /.[\r\n"'(/\\]/, s = /[\da-f]/i;
  e.exports = function(o, l = {}) {
    let u = o.css.valueOf(), h = l.ignoreErrors, p, d, m, y, D, b, C, A, x, E, k = u.length, w = 0, T = [], P = [];
    function M() {
      return w;
    }
    function N(Q) {
      throw o.error("Unclosed " + Q, w);
    }
    function L() {
      return P.length === 0 && w >= k;
    }
    function j(Q) {
      if (P.length)
        return P.pop();
      if (w >= k)
        return;
      let $ = Q ? Q.ignoreUnclosed : !1;
      switch (p = u.charCodeAt(w), p) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12: {
          d = w;
          do
            d += 1, p = u.charCodeAt(d);
          while (p === 32 || p === 10 || p === 9 || p === 13 || p === 12);
          E = ["space", u.slice(w, d)], w = d - 1;
          break;
        }
        case 91:
        case 93:
        case 123:
        case 125:
        case 58:
        case 59:
        case 41: {
          let U = String.fromCharCode(p);
          E = [U, U, w];
          break;
        }
        case 40: {
          if (A = T.length ? T.pop()[1] : "", x = u.charCodeAt(w + 1), A === "url" && x !== 39 && x !== 34 && x !== 32 && x !== 10 && x !== 9 && x !== 12 && x !== 13) {
            d = w;
            do {
              if (b = !1, d = u.indexOf(")", d + 1), d === -1)
                if (h || $) {
                  d = w;
                  break;
                } else
                  N("bracket");
              for (C = d; u.charCodeAt(C - 1) === 92; )
                C -= 1, b = !b;
            } while (b);
            E = ["brackets", u.slice(w, d + 1), w, d], w = d;
          } else
            d = u.indexOf(")", w + 1), y = u.slice(w, d + 1), d === -1 || i.test(y) ? E = ["(", "(", w] : (E = ["brackets", y, w, d], w = d);
          break;
        }
        case 39:
        case 34: {
          m = p === 39 ? "'" : '"', d = w;
          do {
            if (b = !1, d = u.indexOf(m, d + 1), d === -1)
              if (h || $) {
                d = w + 1;
                break;
              } else
                N("string");
            for (C = d; u.charCodeAt(C - 1) === 92; )
              C -= 1, b = !b;
          } while (b);
          E = ["string", u.slice(w, d + 1), w, d], w = d;
          break;
        }
        case 64: {
          r.lastIndex = w + 1, r.test(u), r.lastIndex === 0 ? d = u.length - 1 : d = r.lastIndex - 2, E = ["at-word", u.slice(w, d + 1), w, d], w = d;
          break;
        }
        case 92: {
          for (d = w, D = !0; u.charCodeAt(d + 1) === 92; )
            d += 1, D = !D;
          if (p = u.charCodeAt(d + 1), D && p !== 47 && p !== 32 && p !== 10 && p !== 9 && p !== 13 && p !== 12 && (d += 1, s.test(u.charAt(d)))) {
            for (; s.test(u.charAt(d + 1)); )
              d += 1;
            u.charCodeAt(d + 1) === 32 && (d += 1);
          }
          E = ["word", u.slice(w, d + 1), w, d], w = d;
          break;
        }
        default: {
          p === 47 && u.charCodeAt(w + 1) === 42 ? (d = u.indexOf("*/", w + 2) + 1, d === 0 && (h || $ ? d = u.length : N("comment")), E = ["comment", u.slice(w, d + 1), w, d], w = d) : (n.lastIndex = w + 1, n.test(u), n.lastIndex === 0 ? d = u.length - 1 : d = n.lastIndex - 2, E = ["word", u.slice(w, d + 1), w, d], T.push(E), w = d);
          break;
        }
      }
      return w++, E;
    }
    function X(Q) {
      P.push(Q);
    }
    return { back: X, endOfFile: L, nextToken: j, position: M };
  };
}), dm = re((t, e) => {
  var r = ks(), n = class extends r {
    constructor(i) {
      super(i), this.type = "atrule";
    }
    append(...i) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...i);
    }
    prepend(...i) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...i);
    }
  };
  e.exports = n, n.default = n, r.registerAtRule(n);
}), gl = re((t, e) => {
  var r = ks(), n, i, s = class extends r {
    constructor(o) {
      super(o), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(o, l, u) {
      let h = super.normalize(o);
      if (l) {
        if (u === "prepend")
          this.nodes.length > 1 ? l.raws.before = this.nodes[1].raws.before : delete l.raws.before;
        else if (this.first !== l)
          for (let p of h)
            p.raws.before = l.raws.before;
      }
      return h;
    }
    removeChild(o, l) {
      let u = this.index(o);
      return !l && u === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[u].raws.before), super.removeChild(o);
    }
    toResult(o = {}) {
      return new n(new i(), this, o).stringify();
    }
  };
  s.registerLazyResult = (o) => {
    n = o;
  }, s.registerProcessor = (o) => {
    i = o;
  }, e.exports = s, s.default = s, r.registerRoot(s);
}), k2 = re((t, e) => {
  var r = { comma(n) {
    return r.split(n, [","], !0);
  }, space(n) {
    let i = [" ", `
`, "	"];
    return r.split(n, i);
  }, split(n, i, s) {
    let o = [], l = "", u = !1, h = 0, p = !1, d = "", m = !1;
    for (let y of n)
      m ? m = !1 : y === "\\" ? m = !0 : p ? y === d && (p = !1) : y === '"' || y === "'" ? (p = !0, d = y) : y === "(" ? h += 1 : y === ")" ? h > 0 && (h -= 1) : h === 0 && i.includes(y) && (u = !0), u ? (l !== "" && o.push(l.trim()), l = "", u = !1) : l += y;
    return (s || l !== "") && o.push(l.trim()), o;
  } };
  e.exports = r, r.default = r;
}), fm = re((t, e) => {
  var r = ks(), n = k2(), i = class extends r {
    constructor(s) {
      super(s), this.type = "rule", this.nodes || (this.nodes = []);
    }
    get selectors() {
      return n.comma(this.selector);
    }
    set selectors(s) {
      let o = this.selector ? this.selector.match(/,\s*/) : null, l = o ? o[0] : "," + this.raw("between", "beforeOpen");
      this.selector = s.join(l);
    }
  };
  e.exports = i, i.default = i, r.registerRule(i);
}), mm = re((t, e) => {
  var r = nh(), n = pm(), i = ml(), s = dm(), o = gl(), l = fm(), u = { empty: !0, space: !0 };
  function h(d) {
    for (let m = d.length - 1; m >= 0; m--) {
      let y = d[m], D = y[3] || y[2];
      if (D)
        return D;
    }
  }
  var p = class {
    constructor(d) {
      this.input = d, this.root = new o(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.customProperty = !1, this.createTokenizer(), this.root.source = { input: d, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(d) {
      let m = new s();
      m.name = d[1].slice(1), m.name === "" && this.unnamedAtrule(m, d), this.init(m, d[2]);
      let y, D, b, C = !1, A = !1, x = [], E = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (d = this.tokenizer.nextToken(), y = d[0], y === "(" || y === "[" ? E.push(y === "(" ? ")" : "]") : y === "{" && E.length > 0 ? E.push("}") : y === E[E.length - 1] && E.pop(), E.length === 0)
          if (y === ";") {
            m.source.end = this.getPosition(d[2]), m.source.end.offset++, this.semicolon = !0;
            break;
          } else if (y === "{") {
            A = !0;
            break;
          } else if (y === "}") {
            if (x.length > 0) {
              for (b = x.length - 1, D = x[b]; D && D[0] === "space"; )
                D = x[--b];
              D && (m.source.end = this.getPosition(D[3] || D[2]), m.source.end.offset++);
            }
            this.end(d);
            break;
          } else
            x.push(d);
        else
          x.push(d);
        if (this.tokenizer.endOfFile()) {
          C = !0;
          break;
        }
      }
      m.raws.between = this.spacesAndCommentsFromEnd(x), x.length ? (m.raws.afterName = this.spacesAndCommentsFromStart(x), this.raw(m, "params", x), C && (d = x[x.length - 1], m.source.end = this.getPosition(d[3] || d[2]), m.source.end.offset++, this.spaces = m.raws.between, m.raws.between = "")) : (m.raws.afterName = "", m.params = ""), A && (m.nodes = [], this.current = m);
    }
    checkMissedSemicolon(d) {
      let m = this.colon(d);
      if (m === !1)
        return;
      let y = 0, D;
      for (let b = m - 1; b >= 0 && (D = d[b], !(D[0] !== "space" && (y += 1, y === 2))); b--)
        ;
      throw this.input.error("Missed semicolon", D[0] === "word" ? D[3] + 1 : D[2]);
    }
    colon(d) {
      let m = 0, y, D, b;
      for (let [C, A] of d.entries()) {
        if (y = A, D = y[0], D === "(" && (m += 1), D === ")" && (m -= 1), m === 0 && D === ":")
          if (!b)
            this.doubleColon(y);
          else {
            if (b[0] === "word" && b[1] === "progid")
              continue;
            return C;
          }
        b = y;
      }
      return !1;
    }
    comment(d) {
      let m = new i();
      this.init(m, d[2]), m.source.end = this.getPosition(d[3] || d[2]), m.source.end.offset++;
      let y = d[1].slice(2, -2);
      if (/^\s*$/.test(y))
        m.text = "", m.raws.left = y, m.raws.right = "";
      else {
        let D = y.match(/^(\s*)([^]*\S)(\s*)$/);
        m.text = D[2], m.raws.left = D[1], m.raws.right = D[3];
      }
    }
    createTokenizer() {
      this.tokenizer = n(this.input);
    }
    decl(d, m) {
      let y = new r();
      this.init(y, d[0][2]);
      let D = d[d.length - 1];
      for (D[0] === ";" && (this.semicolon = !0, d.pop()), y.source.end = this.getPosition(D[3] || D[2] || h(d)), y.source.end.offset++; d[0][0] !== "word"; )
        d.length === 1 && this.unknownWord(d), y.raws.before += d.shift()[1];
      for (y.source.start = this.getPosition(d[0][2]), y.prop = ""; d.length; ) {
        let x = d[0][0];
        if (x === ":" || x === "space" || x === "comment")
          break;
        y.prop += d.shift()[1];
      }
      y.raws.between = "";
      let b;
      for (; d.length; )
        if (b = d.shift(), b[0] === ":") {
          y.raws.between += b[1];
          break;
        } else
          b[0] === "word" && /\w/.test(b[1]) && this.unknownWord([b]), y.raws.between += b[1];
      (y.prop[0] === "_" || y.prop[0] === "*") && (y.raws.before += y.prop[0], y.prop = y.prop.slice(1));
      let C = [], A;
      for (; d.length && (A = d[0][0], !(A !== "space" && A !== "comment")); )
        C.push(d.shift());
      this.precheckMissedSemicolon(d);
      for (let x = d.length - 1; x >= 0; x--) {
        if (b = d[x], b[1].toLowerCase() === "!important") {
          y.important = !0;
          let E = this.stringFrom(d, x);
          E = this.spacesFromEnd(d) + E, E !== " !important" && (y.raws.important = E);
          break;
        } else if (b[1].toLowerCase() === "important") {
          let E = d.slice(0), k = "";
          for (let w = x; w > 0; w--) {
            let T = E[w][0];
            if (k.trim().indexOf("!") === 0 && T !== "space")
              break;
            k = E.pop()[1] + k;
          }
          k.trim().indexOf("!") === 0 && (y.important = !0, y.raws.important = k, d = E);
        }
        if (b[0] !== "space" && b[0] !== "comment")
          break;
      }
      d.some((x) => x[0] !== "space" && x[0] !== "comment") && (y.raws.between += C.map((x) => x[1]).join(""), C = []), this.raw(y, "value", C.concat(d), m), y.value.includes(":") && !m && this.checkMissedSemicolon(d);
    }
    doubleColon(d) {
      throw this.input.error("Double colon", { offset: d[2] }, { offset: d[2] + d[1].length });
    }
    emptyRule(d) {
      let m = new l();
      this.init(m, d[2]), m.selector = "", m.raws.between = "", this.current = m;
    }
    end(d) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(d[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(d);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(d) {
      if (this.spaces += d[1], this.current.nodes) {
        let m = this.current.nodes[this.current.nodes.length - 1];
        m && m.type === "rule" && !m.raws.ownSemicolon && (m.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }
    getPosition(d) {
      let m = this.input.fromOffset(d);
      return { column: m.col, line: m.line, offset: d };
    }
    init(d, m) {
      this.current.push(d), d.source = { input: this.input, start: this.getPosition(m) }, d.raws.before = this.spaces, this.spaces = "", d.type !== "comment" && (this.semicolon = !1);
    }
    other(d) {
      let m = !1, y = null, D = !1, b = null, C = [], A = d[1].startsWith("--"), x = [], E = d;
      for (; E; ) {
        if (y = E[0], x.push(E), y === "(" || y === "[")
          b || (b = E), C.push(y === "(" ? ")" : "]");
        else if (A && D && y === "{")
          b || (b = E), C.push("}");
        else if (C.length === 0)
          if (y === ";")
            if (D) {
              this.decl(x, A);
              return;
            } else
              break;
          else if (y === "{") {
            this.rule(x);
            return;
          } else if (y === "}") {
            this.tokenizer.back(x.pop()), m = !0;
            break;
          } else
            y === ":" && (D = !0);
        else
          y === C[C.length - 1] && (C.pop(), C.length === 0 && (b = null));
        E = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (m = !0), C.length > 0 && this.unclosedBracket(b), m && D) {
        if (!A)
          for (; x.length && (E = x[x.length - 1][0], !(E !== "space" && E !== "comment")); )
            this.tokenizer.back(x.pop());
        this.decl(x, A);
      } else
        this.unknownWord(x);
    }
    parse() {
      let d;
      for (; !this.tokenizer.endOfFile(); )
        switch (d = this.tokenizer.nextToken(), d[0]) {
          case "space":
            this.spaces += d[1];
            break;
          case ";":
            this.freeSemicolon(d);
            break;
          case "}":
            this.end(d);
            break;
          case "comment":
            this.comment(d);
            break;
          case "at-word":
            this.atrule(d);
            break;
          case "{":
            this.emptyRule(d);
            break;
          default:
            this.other(d);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(d, m, y, D) {
      let b, C, A = y.length, x = "", E = !0, k, w;
      for (let T = 0; T < A; T += 1)
        b = y[T], C = b[0], C === "space" && T === A - 1 && !D ? E = !1 : C === "comment" ? (w = y[T - 1] ? y[T - 1][0] : "empty", k = y[T + 1] ? y[T + 1][0] : "empty", !u[w] && !u[k] ? x.slice(-1) === "," ? E = !1 : x += b[1] : E = !1) : x += b[1];
      if (!E) {
        let T = y.reduce((P, M) => P + M[1], "");
        d.raws[m] = { raw: T, value: x };
      }
      d[m] = x;
    }
    rule(d) {
      d.pop();
      let m = new l();
      this.init(m, d[0][2]), m.raws.between = this.spacesAndCommentsFromEnd(d), this.raw(m, "selector", d), this.current = m;
    }
    spacesAndCommentsFromEnd(d) {
      let m, y = "";
      for (; d.length && (m = d[d.length - 1][0], !(m !== "space" && m !== "comment")); )
        y = d.pop()[1] + y;
      return y;
    }
    spacesAndCommentsFromStart(d) {
      let m, y = "";
      for (; d.length && (m = d[0][0], !(m !== "space" && m !== "comment")); )
        y += d.shift()[1];
      return y;
    }
    spacesFromEnd(d) {
      let m, y = "";
      for (; d.length && (m = d[d.length - 1][0], m === "space"); )
        y = d.pop()[1] + y;
      return y;
    }
    stringFrom(d, m) {
      let y = "";
      for (let D = m; D < d.length; D++)
        y += d[D][1];
      return d.splice(m, d.length - m), y;
    }
    unclosedBlock() {
      let d = this.current.source.start;
      throw this.input.error("Unclosed block", d.line, d.column);
    }
    unclosedBracket(d) {
      throw this.input.error("Unclosed bracket", { offset: d[2] }, { offset: d[2] + 1 });
    }
    unexpectedClose(d) {
      throw this.input.error("Unexpected }", { offset: d[2] }, { offset: d[2] + 1 });
    }
    unknownWord(d) {
      throw this.input.error("Unknown word", { offset: d[0][2] }, { offset: d[0][2] + d[0][1].length });
    }
    unnamedAtrule(d, m) {
      throw this.input.error("At-rule without name", { offset: m[2] }, { offset: m[2] + m[1].length });
    }
  };
  e.exports = p;
}), NN = re(() => {
}), MN = re((t, e) => {
  var r = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", n = (s, o = 21) => (l = o) => {
    let u = "", h = l;
    for (; h--; )
      u += s[Math.random() * s.length | 0];
    return u;
  }, i = (s = 21) => {
    let o = "", l = s;
    for (; l--; )
      o += r[Math.random() * 64 | 0];
    return o;
  };
  e.exports = { nanoid: i, customAlphabet: n };
}), F2 = re((t, e) => {
  e.exports = class {
  };
}), yl = re((t, e) => {
  var { SourceMapConsumer: r, SourceMapGenerator: n } = NN(), { fileURLToPath: i, pathToFileURL: s } = {}, { isAbsolute: o, resolve: l } = {}, { nanoid: u } = MN(), h = w2(), p = cm(), d = F2(), m = Symbol("fromOffsetCache"), y = !!(r && n), D = !!(l && o), b = class {
    constructor(C, A = {}) {
      if (C === null || typeof C > "u" || typeof C == "object" && !C.toString)
        throw new Error(`PostCSS received ${C} instead of CSS string`);
      if (this.css = C.toString(), this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, A.from && (!D || /^\w+:\/\//.test(A.from) || o(A.from) ? this.file = A.from : this.file = l(A.from)), D && y) {
        let x = new d(this.css, A);
        if (x.text) {
          this.map = x;
          let E = x.consumer().file;
          !this.file && E && (this.file = this.mapResolve(E));
        }
      }
      this.file || (this.id = "<input css " + u(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(C, A, x, E = {}) {
      let k, w, T;
      if (A && typeof A == "object") {
        let M = A, N = x;
        if (typeof M.offset == "number") {
          let L = this.fromOffset(M.offset);
          A = L.line, x = L.col;
        } else
          A = M.line, x = M.column;
        if (typeof N.offset == "number") {
          let L = this.fromOffset(N.offset);
          w = L.line, T = L.col;
        } else
          w = N.line, T = N.column;
      } else if (!x) {
        let M = this.fromOffset(A);
        A = M.line, x = M.col;
      }
      let P = this.origin(A, x, w, T);
      return P ? k = new p(C, P.endLine === void 0 ? P.line : { column: P.column, line: P.line }, P.endLine === void 0 ? P.column : { column: P.endColumn, line: P.endLine }, P.source, P.file, E.plugin) : k = new p(C, w === void 0 ? A : { column: x, line: A }, w === void 0 ? x : { column: T, line: w }, this.css, this.file, E.plugin), k.input = { column: x, endColumn: T, endLine: w, line: A, source: this.css }, this.file && (s && (k.input.url = s(this.file).toString()), k.input.file = this.file), k;
    }
    fromOffset(C) {
      let A, x;
      if (this[m])
        x = this[m];
      else {
        let k = this.css.split(`
`);
        x = new Array(k.length);
        let w = 0;
        for (let T = 0, P = k.length; T < P; T++)
          x[T] = w, w += k[T].length + 1;
        this[m] = x;
      }
      A = x[x.length - 1];
      let E = 0;
      if (C >= A)
        E = x.length - 1;
      else {
        let k = x.length - 2, w;
        for (; E < k; )
          if (w = E + (k - E >> 1), C < x[w])
            k = w - 1;
          else if (C >= x[w + 1])
            E = w + 1;
          else {
            E = w;
            break;
          }
      }
      return { col: C - x[E] + 1, line: E + 1 };
    }
    mapResolve(C) {
      return /^\w+:\/\//.test(C) ? C : l(this.map.consumer().sourceRoot || this.map.root || ".", C);
    }
    origin(C, A, x, E) {
      if (!this.map)
        return !1;
      let k = this.map.consumer(), w = k.originalPositionFor({ column: A, line: C });
      if (!w.source)
        return !1;
      let T;
      typeof x == "number" && (T = k.originalPositionFor({ column: E, line: x }));
      let P;
      o(w.source) ? P = s(w.source) : P = new URL(w.source, this.map.consumer().sourceRoot || s(this.map.mapFile));
      let M = { column: w.column, endColumn: T && T.column, endLine: T && T.line, line: w.line, url: P.toString() };
      if (P.protocol === "file:")
        if (i)
          M.file = i(P);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let N = k.sourceContentFor(w.source);
      return N && (M.source = N), M;
    }
    toJSON() {
      let C = {};
      for (let A of ["hasBOM", "css", "file", "id"])
        this[A] != null && (C[A] = this[A]);
      return this.map && (C.map = { ...this.map }, C.map.consumerCache && (C.map.consumerCache = void 0)), C;
    }
    get from() {
      return this.file || this.id;
    }
  };
  e.exports = b, b.default = b, h && h.registerInput && h.registerInput(b);
}), ih = re((t, e) => {
  var r = ks(), n = mm(), i = yl();
  function s(o, l) {
    let u = new i(o, l), h = new n(u);
    try {
      h.parse();
    } catch (p) {
      throw p;
    }
    return h.root;
  }
  e.exports = s, s.default = s, r.registerParse(s);
}), ON = re((t, e) => {
  var r = pm(), n = yl();
  e.exports = { isInlineComment(i) {
    if (i[0] === "word" && i[1].slice(0, 2) === "//") {
      let s = i, o = [], l, u;
      for (; i; ) {
        if (/\r?\n/.test(i[1])) {
          if (/['"].*\r?\n/.test(i[1])) {
            o.push(i[1].substring(0, i[1].indexOf(`
`))), u = i[1].substring(i[1].indexOf(`
`));
            let p = this.input.css.valueOf().substring(this.tokenizer.position());
            u += p, l = i[3] + p.length - u.length;
          } else
            this.tokenizer.back(i);
          break;
        }
        o.push(i[1]), l = i[2], i = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
      }
      let h = ["comment", o.join(""), s[2], l];
      return this.inlineComment(h), u && (this.input = new n(u), this.tokenizer = r(this.input)), !0;
    } else if (i[1] === "/") {
      let s = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
      if (s[0] === "comment" && /^\/\*/.test(s[1]))
        return s[0] = "word", s[1] = s[1].slice(1), i[1] = "//", this.tokenizer.back(s), e.exports.isInlineComment.bind(this)(i);
    }
    return !1;
  } };
}), LN = re((t, e) => {
  e.exports = { interpolation(r) {
    let n = [r, this.tokenizer.nextToken()], i = ["word", "}"];
    if (n[0][1].length > 1 || n[1][0] !== "{")
      return this.tokenizer.back(n[1]), !1;
    for (r = this.tokenizer.nextToken(); r && i.includes(r[0]); )
      n.push(r), r = this.tokenizer.nextToken();
    let s = n.map((h) => h[1]), [o] = n, l = n.pop(), u = ["word", s.join(""), o[2], l[2]];
    return this.tokenizer.back(r), this.tokenizer.back(u), !0;
  } };
}), _N = re((t, e) => {
  var r = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, n = /\.[0-9]/, i = (s) => {
    let [, o] = s, [l] = o;
    return (l === "." || l === "#") && r.test(o) === !1 && n.test(o) === !1;
  };
  e.exports = { isMixinToken: i };
}), $N = re((t, e) => {
  var r = pm(), n = /^url\((.+)\)/;
  e.exports = (i) => {
    let { name: s, params: o = "" } = i;
    if (s === "import" && o.length) {
      i.import = !0;
      let l = r({ css: o });
      for (i.filename = o.replace(n, "$1"); !l.endOfFile(); ) {
        let [u, h] = l.nextToken();
        if (u === "word" && h === "url")
          return;
        if (u === "brackets") {
          i.options = h, i.filename = o.replace(h, "").trim();
          break;
        }
      }
    }
  };
}), RN = re((t, e) => {
  var r = /:$/, n = /^:(\s+)?/;
  e.exports = (i) => {
    let { name: s, params: o = "" } = i;
    if (i.name.slice(-1) === ":") {
      if (r.test(s)) {
        let [l] = s.match(r);
        i.name = s.replace(l, ""), i.raws.afterName = l + (i.raws.afterName || ""), i.variable = !0, i.value = i.params;
      }
      if (n.test(o)) {
        let [l] = o.match(n);
        i.value = o.replace(l, ""), i.raws.afterName = (i.raws.afterName || "") + l, i.variable = !0;
      }
    }
  };
}), jN = re((t, e) => {
  var r = ml(), n = mm(), { isInlineComment: i } = ON(), { interpolation: s } = LN(), { isMixinToken: o } = _N(), l = $N(), u = RN(), h = /(!\s*important)$/i;
  e.exports = class extends n {
    constructor(...p) {
      super(...p), this.lastNode = null;
    }
    atrule(p) {
      s.bind(this)(p) || (super.atrule(p), l(this.lastNode), u(this.lastNode));
    }
    decl(...p) {
      super.decl(...p), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = !0);
    }
    each(p) {
      p[0][1] = ` ${p[0][1]}`;
      let d = p.findIndex((b) => b[0] === "("), m = p.reverse().find((b) => b[0] === ")"), y = p.reverse().indexOf(m), D = p.splice(d, y).map((b) => b[1]).join("");
      for (let b of p.reverse())
        this.tokenizer.back(b);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.function = !0, this.lastNode.params = D;
    }
    init(p, d, m) {
      super.init(p, d, m), this.lastNode = p;
    }
    inlineComment(p) {
      let d = new r(), m = p[1].slice(2);
      if (this.init(d, p[2]), d.source.end = this.getPosition(p[3] || p[2]), d.inline = !0, d.raws.begin = "//", /^\s*$/.test(m))
        d.text = "", d.raws.left = m, d.raws.right = "";
      else {
        let y = m.match(/^(\s*)([^]*[^\s])(\s*)$/);
        [, d.raws.left, d.text, d.raws.right] = y;
      }
    }
    mixin(p) {
      let [d] = p, m = d[1].slice(0, 1), y = p.findIndex((x) => x[0] === "brackets"), D = p.findIndex((x) => x[0] === "("), b = "";
      if ((y < 0 || y > 3) && D > 0) {
        let x = p.reduce((j, X, Q) => X[0] === ")" ? Q : j), E = p.slice(D, x + D).map((j) => j[1]).join(""), [k] = p.slice(D), w = [k[2], k[3]], [T] = p.slice(x, x + 1), P = [T[2], T[3]], M = ["brackets", E].concat(w, P), N = p.slice(0, D), L = p.slice(x + 1);
        p = N, p.push(M), p = p.concat(L);
      }
      let C = [];
      for (let x of p)
        if ((x[1] === "!" || C.length) && C.push(x), x[1] === "important")
          break;
      if (C.length) {
        let [x] = C, E = p.indexOf(x), k = C[C.length - 1], w = [x[2], x[3]], T = [k[4], k[5]], P = ["word", C.map((M) => M[1]).join("")].concat(w, T);
        p.splice(E, C.length, P);
      }
      let A = p.findIndex((x) => h.test(x[1]));
      A > 0 && ([, b] = p[A], p.splice(A, 1));
      for (let x of p.reverse())
        this.tokenizer.back(x);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = !0, this.lastNode.raws.identifier = m, b && (this.lastNode.important = !0, this.lastNode.raws.important = b);
    }
    other(p) {
      i.bind(this)(p) || super.other(p);
    }
    rule(p) {
      let d = p[p.length - 1], m = p[p.length - 2];
      if (m[0] === "at-word" && d[0] === "{" && (this.tokenizer.back(d), s.bind(this)(m))) {
        let y = this.tokenizer.nextToken();
        p = p.slice(0, p.length - 2).concat([y]);
        for (let D of p.reverse())
          this.tokenizer.back(D);
        return;
      }
      super.rule(p), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = !0);
    }
    unknownWord(p) {
      let [d] = p;
      if (p[0][1] === "each" && p[1][0] === "(") {
        this.each(p);
        return;
      }
      if (o(d)) {
        this.mixin(p);
        return;
      }
      super.unknownWord(p);
    }
  };
}), qN = re((t, e) => {
  var r = hm();
  e.exports = class extends r {
    atrule(n, i) {
      if (!n.mixin && !n.variable && !n.function) {
        super.atrule(n, i);
        return;
      }
      let s = `${n.function ? "" : n.raws.identifier || "@"}${n.name}`, o = n.params ? this.rawValue(n, "params") : "", l = n.raws.important || "";
      if (n.variable && (o = n.value), typeof n.raws.afterName < "u" ? s += n.raws.afterName : o && (s += " "), n.nodes)
        this.block(n, s + o + l);
      else {
        let u = (n.raws.between || "") + l + (i ? ";" : "");
        this.builder(s + o + u, n);
      }
    }
    comment(n) {
      if (n.inline) {
        let i = this.raw(n, "left", "commentLeft"), s = this.raw(n, "right", "commentRight");
        this.builder(`//${i}${n.text}${s}`, n);
      } else
        super.comment(n);
    }
  };
}), WN = re((t, e) => {
  var r = yl(), n = jN(), i = qN();
  e.exports = { parse(s, o) {
    let l = new r(s, o), u = new n(l);
    return u.parse(), u.root.walk((h) => {
      let p = l.css.lastIndexOf(h.source.input.css);
      if (p === 0)
        return;
      if (p + h.source.input.css.length !== l.css.length)
        throw new Error("Invalid state detected in postcss-less");
      let d = p + h.source.start.offset, m = l.fromOffset(p + h.source.start.offset);
      if (h.source.start = { offset: d, line: m.line, column: m.col }, h.source.end) {
        let y = p + h.source.end.offset, D = l.fromOffset(p + h.source.end.offset);
        h.source.end = { offset: y, line: D.line, column: D.col };
      }
    }), u.root;
  }, stringify(s, o) {
    new i(o).stringify(s);
  }, nodeToString(s) {
    let o = "";
    return e.exports.stringify(s, (l) => {
      o += l;
    }), o;
  } };
}), P2 = re((t, e) => {
  e.exports = class {
    generate() {
    }
  };
}), gm = re((t, e) => {
  var r = ks(), n, i, s = class extends r {
    constructor(o) {
      super({ type: "document", ...o }), this.nodes || (this.nodes = []);
    }
    toResult(o = {}) {
      return new n(new i(), this, o).stringify();
    }
  };
  s.registerLazyResult = (o) => {
    n = o;
  }, s.registerProcessor = (o) => {
    i = o;
  }, e.exports = s, s.default = s;
}), B2 = re((t, e) => {
  var r = {};
  e.exports = function(n) {
    r[n] || (r[n] = !0, typeof console < "u" && console.warn && console.warn(n));
  };
}), I2 = re((t, e) => {
  var r = class {
    constructor(n, i = {}) {
      if (this.type = "warning", this.text = n, i.node && i.node.source) {
        let s = i.node.rangeBy(i);
        this.line = s.start.line, this.column = s.start.column, this.endLine = s.end.line, this.endColumn = s.end.column;
      }
      for (let s in i)
        this[s] = i[s];
    }
    toString() {
      return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  };
  e.exports = r, r.default = r;
}), ym = re((t, e) => {
  var r = I2(), n = class {
    constructor(i, s, o) {
      this.processor = i, this.messages = [], this.root = s, this.opts = o, this.css = void 0, this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(i, s = {}) {
      s.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (s.plugin = this.lastPlugin.postcssPlugin);
      let o = new r(i, s);
      return this.messages.push(o), o;
    }
    warnings() {
      return this.messages.filter((i) => i.type === "warning");
    }
    get content() {
      return this.css;
    }
  };
  e.exports = n, n.default = n;
}), N2 = re((t, e) => {
  var { isClean: r, my: n } = um(), i = P2(), s = th(), o = ks(), l = gm();
  B2();
  var u = ym(), h = ih(), p = gl(), d = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, m = { AtRule: !0, AtRuleExit: !0, Comment: !0, CommentExit: !0, Declaration: !0, DeclarationExit: !0, Document: !0, DocumentExit: !0, Once: !0, OnceExit: !0, postcssPlugin: !0, prepare: !0, Root: !0, RootExit: !0, Rule: !0, RuleExit: !0 }, y = { Once: !0, postcssPlugin: !0, prepare: !0 }, D = 0;
  function b(w) {
    return typeof w == "object" && typeof w.then == "function";
  }
  function C(w) {
    let T = !1, P = d[w.type];
    return w.type === "decl" ? T = w.prop.toLowerCase() : w.type === "atrule" && (T = w.name.toLowerCase()), T && w.append ? [P, P + "-" + T, D, P + "Exit", P + "Exit-" + T] : T ? [P, P + "-" + T, P + "Exit", P + "Exit-" + T] : w.append ? [P, D, P + "Exit"] : [P, P + "Exit"];
  }
  function A(w) {
    let T;
    return w.type === "document" ? T = ["Document", D, "DocumentExit"] : w.type === "root" ? T = ["Root", D, "RootExit"] : T = C(w), { eventIndex: 0, events: T, iterator: 0, node: w, visitorIndex: 0, visitors: [] };
  }
  function x(w) {
    return w[r] = !1, w.nodes && w.nodes.forEach((T) => x(T)), w;
  }
  var E = {}, k = class M2 {
    constructor(T, P, M) {
      this.stringified = !1, this.processed = !1;
      let N;
      if (typeof P == "object" && P !== null && (P.type === "root" || P.type === "document"))
        N = x(P);
      else if (P instanceof M2 || P instanceof u)
        N = x(P.root), P.map && (typeof M.map > "u" && (M.map = {}), M.map.inline || (M.map.inline = !1), M.map.prev = P.map);
      else {
        let L = h;
        M.syntax && (L = M.syntax.parse), M.parser && (L = M.parser), L.parse && (L = L.parse);
        try {
          N = L(P, M);
        } catch (j) {
          this.processed = !0, this.error = j;
        }
        N && !N[n] && o.rebuild(N);
      }
      this.result = new u(T, N, M), this.helpers = { ...E, postcss: E, result: this.result }, this.plugins = this.processor.plugins.map((L) => typeof L == "object" && L.prepare ? { ...L, ...L.prepare(this.result) } : L);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(T) {
      return this.async().catch(T);
    }
    finally(T) {
      return this.async().then(T, T);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(T, P) {
      let M = this.result.lastPlugin;
      try {
        P && P.addToError(T), this.error = T, T.name === "CssSyntaxError" && !T.plugin ? (T.plugin = M.postcssPlugin, T.setMessage()) : M.postcssVersion;
      } catch (N) {
        console && console.error && console.error(N);
      }
      return T;
    }
    prepareVisitors() {
      this.listeners = {};
      let T = (P, M, N) => {
        this.listeners[M] || (this.listeners[M] = []), this.listeners[M].push([P, N]);
      };
      for (let P of this.plugins)
        if (typeof P == "object")
          for (let M in P) {
            if (!m[M] && /^[A-Z]/.test(M))
              throw new Error(`Unknown event ${M} in ${P.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
            if (!y[M])
              if (typeof P[M] == "object")
                for (let N in P[M])
                  N === "*" ? T(P, M, P[M][N]) : T(P, M + "-" + N.toLowerCase(), P[M][N]);
              else
                typeof P[M] == "function" && T(P, M, P[M]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let T = 0; T < this.plugins.length; T++) {
        let P = this.plugins[T], M = this.runOnRoot(P);
        if (b(M))
          try {
            await M;
          } catch (N) {
            throw this.handleError(N);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let T = this.result.root;
        for (; !T[r]; ) {
          T[r] = !0;
          let P = [A(T)];
          for (; P.length > 0; ) {
            let M = this.visitTick(P);
            if (b(M))
              try {
                await M;
              } catch (N) {
                let L = P[P.length - 1].node;
                throw this.handleError(N, L);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [P, M] of this.listeners.OnceExit) {
            this.result.lastPlugin = P;
            try {
              if (T.type === "document") {
                let N = T.nodes.map((L) => M(L, this.helpers));
                await Promise.all(N);
              } else
                await M(T, this.helpers);
            } catch (N) {
              throw this.handleError(N);
            }
          }
      }
      return this.processed = !0, this.stringify();
    }
    runOnRoot(T) {
      this.result.lastPlugin = T;
      try {
        if (typeof T == "object" && T.Once) {
          if (this.result.root.type === "document") {
            let P = this.result.root.nodes.map((M) => T.Once(M, this.helpers));
            return b(P[0]) ? Promise.all(P) : P;
          }
          return T.Once(this.result.root, this.helpers);
        } else if (typeof T == "function")
          return T(this.result.root, this.result);
      } catch (P) {
        throw this.handleError(P);
      }
    }
    stringify() {
      if (this.error)
        throw this.error;
      if (this.stringified)
        return this.result;
      this.stringified = !0, this.sync();
      let T = this.result.opts, P = s;
      T.syntax && (P = T.syntax.stringify), T.stringifier && (P = T.stringifier), P.stringify && (P = P.stringify);
      let M = new i(P, this.result.root, this.result.opts).generate();
      return this.result.css = M[0], this.result.map = M[1], this.result;
    }
    sync() {
      if (this.error)
        throw this.error;
      if (this.processed)
        return this.result;
      if (this.processed = !0, this.processing)
        throw this.getAsyncError();
      for (let T of this.plugins) {
        let P = this.runOnRoot(T);
        if (b(P))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let T = this.result.root;
        for (; !T[r]; )
          T[r] = !0, this.walkSync(T);
        if (this.listeners.OnceExit)
          if (T.type === "document")
            for (let P of T.nodes)
              this.visitSync(this.listeners.OnceExit, P);
          else
            this.visitSync(this.listeners.OnceExit, T);
      }
      return this.result;
    }
    then(T, P) {
      return this.async().then(T, P);
    }
    toString() {
      return this.css;
    }
    visitSync(T, P) {
      for (let [M, N] of T) {
        this.result.lastPlugin = M;
        let L;
        try {
          L = N(P, this.helpers);
        } catch (j) {
          throw this.handleError(j, P.proxyOf);
        }
        if (P.type !== "root" && P.type !== "document" && !P.parent)
          return !0;
        if (b(L))
          throw this.getAsyncError();
      }
    }
    visitTick(T) {
      let P = T[T.length - 1], { node: M, visitors: N } = P;
      if (M.type !== "root" && M.type !== "document" && !M.parent) {
        T.pop();
        return;
      }
      if (N.length > 0 && P.visitorIndex < N.length) {
        let [j, X] = N[P.visitorIndex];
        P.visitorIndex += 1, P.visitorIndex === N.length && (P.visitors = [], P.visitorIndex = 0), this.result.lastPlugin = j;
        try {
          return X(M.toProxy(), this.helpers);
        } catch (Q) {
          throw this.handleError(Q, M);
        }
      }
      if (P.iterator !== 0) {
        let j = P.iterator, X;
        for (; X = M.nodes[M.indexes[j]]; )
          if (M.indexes[j] += 1, !X[r]) {
            X[r] = !0, T.push(A(X));
            return;
          }
        P.iterator = 0, delete M.indexes[j];
      }
      let L = P.events;
      for (; P.eventIndex < L.length; ) {
        let j = L[P.eventIndex];
        if (P.eventIndex += 1, j === D) {
          M.nodes && M.nodes.length && (M[r] = !0, P.iterator = M.getIterator());
          return;
        } else if (this.listeners[j]) {
          P.visitors = this.listeners[j];
          return;
        }
      }
      T.pop();
    }
    walkSync(T) {
      T[r] = !0;
      let P = C(T);
      for (let M of P)
        if (M === D)
          T.nodes && T.each((N) => {
            N[r] || this.walkSync(N);
          });
        else {
          let N = this.listeners[M];
          if (N && this.visitSync(N, T.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
  };
  k.registerPostcss = (w) => {
    E = w;
  }, e.exports = k, k.default = k, p.registerLazyResult(k), l.registerLazyResult(k);
}), UN = re((t, e) => {
  var r = P2(), n = th();
  B2();
  var i = ih(), s = ym(), o = class {
    constructor(l, u, h) {
      u = u.toString(), this.stringified = !1, this._processor = l, this._css = u, this._opts = h, this._map = void 0;
      let p, d = n;
      this.result = new s(this._processor, p, this._opts), this.result.css = u;
      let m = this;
      Object.defineProperty(this.result, "root", { get() {
        return m.root;
      } });
      let y = new r(d, p, this._opts, u);
      if (y.isMap()) {
        let [D, b] = y.generate();
        D && (this.result.css = D), b && (this.result.map = b);
      } else
        y.clearAnnotation(), this.result.css = y.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(l) {
      return this.async().catch(l);
    }
    finally(l) {
      return this.async().then(l, l);
    }
    sync() {
      if (this.error)
        throw this.error;
      return this.result;
    }
    then(l, u) {
      return this.async().then(l, u);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let l, u = i;
      try {
        l = u(this._css, this._opts);
      } catch (h) {
        this.error = h;
      }
      if (this.error)
        throw this.error;
      return this._root = l, l;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
  };
  e.exports = o, o.default = o;
}), HN = re((t, e) => {
  var r = UN(), n = N2(), i = gm(), s = gl(), o = class {
    constructor(l = []) {
      this.version = "8.4.33", this.plugins = this.normalize(l);
    }
    normalize(l) {
      let u = [];
      for (let h of l)
        if (h.postcss === !0 ? h = h() : h.postcss && (h = h.postcss), typeof h == "object" && Array.isArray(h.plugins))
          u = u.concat(h.plugins);
        else if (typeof h == "object" && h.postcssPlugin)
          u.push(h);
        else if (typeof h == "function")
          u.push(h);
        else if (!(typeof h == "object" && (h.parse || h.stringify)))
          throw new Error(h + " is not a PostCSS plugin");
      return u;
    }
    process(l, u = {}) {
      return !this.plugins.length && !u.parser && !u.stringifier && !u.syntax ? new r(this, l, u) : new n(this, l, u);
    }
    use(l) {
      return this.plugins = this.plugins.concat(this.normalize([l])), this;
    }
  };
  e.exports = o, o.default = o, s.registerProcessor(o), i.registerProcessor(o);
}), VN = re((t, e) => {
  var r = nh(), n = F2(), i = ml(), s = dm(), o = yl(), l = gl(), u = fm();
  function h(p, d) {
    if (Array.isArray(p))
      return p.map((D) => h(D));
    let { inputs: m, ...y } = p;
    if (m) {
      d = [];
      for (let D of m) {
        let b = { ...D, __proto__: o.prototype };
        b.map && (b.map = { ...b.map, __proto__: n.prototype }), d.push(b);
      }
    }
    if (y.nodes && (y.nodes = p.nodes.map((D) => h(D, d))), y.source) {
      let { inputId: D, ...b } = y.source;
      y.source = b, D != null && (y.source.input = d[D]);
    }
    if (y.type === "root")
      return new l(y);
    if (y.type === "decl")
      return new r(y);
    if (y.type === "rule")
      return new u(y);
    if (y.type === "comment")
      return new i(y);
    if (y.type === "atrule")
      return new s(y);
    throw new Error("Unknown node type: " + p.type);
  }
  e.exports = h, h.default = h;
}), Dm = re((t, e) => {
  var r = cm(), n = nh(), i = N2(), s = ks(), o = HN(), l = th(), u = VN(), h = gm(), p = I2(), d = ml(), m = dm(), y = ym(), D = yl(), b = ih(), C = k2(), A = fm(), x = gl(), E = rh();
  function k(...w) {
    return w.length === 1 && Array.isArray(w[0]) && (w = w[0]), new o(w);
  }
  k.plugin = function(w, T) {
    let P = !1;
    function M(...L) {
      console && console.warn && !P && (P = !0, console.warn(w + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`));
      let j = T(...L);
      return j.postcssPlugin = w, j.postcssVersion = new o().version, j;
    }
    let N;
    return Object.defineProperty(M, "postcss", { get() {
      return N || (N = M()), N;
    } }), M.process = function(L, j, X) {
      return k([M(X)]).process(L, j);
    }, M;
  }, k.stringify = l, k.parse = b, k.fromJSON = u, k.list = C, k.comment = (w) => new d(w), k.atRule = (w) => new m(w), k.decl = (w) => new n(w), k.rule = (w) => new A(w), k.root = (w) => new x(w), k.document = (w) => new h(w), k.CssSyntaxError = r, k.Declaration = n, k.Container = s, k.Processor = o, k.Document = h, k.Comment = d, k.Warning = p, k.AtRule = m, k.Result = y, k.Input = D, k.Rule = A, k.Root = x, k.Node = E, i.registerPostcss(k), e.exports = k, k.default = k;
}), zN = re((t, e) => {
  var { Container: r } = Dm(), n = class extends r {
    constructor(i) {
      super(i), this.type = "decl", this.isNested = !0, this.nodes || (this.nodes = []);
    }
  };
  e.exports = n;
}), JN = re((t, e) => {
  var r = /[\t\n\f\r "#'()/;[\\\]{}]/g, n = /[,\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, i = /.[\r\n"'(/\\]/, s = /[\da-f]/i, o = /[\n\f\r]/g;
  e.exports = function(l, u = {}) {
    let h = l.css.valueOf(), p = u.ignoreErrors, d, m, y, D, b, C, A, x, E, k = h.length, w = 0, T = [], P = [], M;
    function N() {
      return w;
    }
    function L(U) {
      throw l.error("Unclosed " + U, w);
    }
    function j() {
      return P.length === 0 && w >= k;
    }
    function X() {
      let U = 1, H = !1, Z = !1;
      for (; U > 0; )
        m += 1, h.length <= m && L("interpolation"), d = h.charCodeAt(m), x = h.charCodeAt(m + 1), H ? !Z && d === H ? (H = !1, Z = !1) : d === 92 ? Z = !Z : Z && (Z = !1) : d === 39 || d === 34 ? H = d : d === 125 ? U -= 1 : d === 35 && x === 123 && (U += 1);
    }
    function Q(U) {
      if (P.length)
        return P.pop();
      if (w >= k)
        return;
      let H = U ? U.ignoreUnclosed : !1;
      switch (d = h.charCodeAt(w), d) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12: {
          m = w;
          do
            m += 1, d = h.charCodeAt(m);
          while (d === 32 || d === 10 || d === 9 || d === 13 || d === 12);
          E = ["space", h.slice(w, m)], w = m - 1;
          break;
        }
        case 91:
        case 93:
        case 123:
        case 125:
        case 58:
        case 59:
        case 41: {
          let Z = String.fromCharCode(d);
          E = [Z, Z, w];
          break;
        }
        case 44: {
          E = ["word", ",", w, w + 1];
          break;
        }
        case 40: {
          if (A = T.length ? T.pop()[1] : "", x = h.charCodeAt(w + 1), A === "url" && x !== 39 && x !== 34) {
            for (M = 1, C = !1, m = w + 1; m <= h.length - 1; ) {
              if (x = h.charCodeAt(m), x === 92)
                C = !C;
              else if (x === 40)
                M += 1;
              else if (x === 41 && (M -= 1, M === 0))
                break;
              m += 1;
            }
            D = h.slice(w, m + 1), E = ["brackets", D, w, m], w = m;
          } else
            m = h.indexOf(")", w + 1), D = h.slice(w, m + 1), m === -1 || i.test(D) ? E = ["(", "(", w] : (E = ["brackets", D, w, m], w = m);
          break;
        }
        case 39:
        case 34: {
          for (y = d, m = w, C = !1; m < k && (m++, m === k && L("string"), d = h.charCodeAt(m), x = h.charCodeAt(m + 1), !(!C && d === y)); )
            d === 92 ? C = !C : C ? C = !1 : d === 35 && x === 123 && X();
          E = ["string", h.slice(w, m + 1), w, m], w = m;
          break;
        }
        case 64: {
          r.lastIndex = w + 1, r.test(h), r.lastIndex === 0 ? m = h.length - 1 : m = r.lastIndex - 2, E = ["at-word", h.slice(w, m + 1), w, m], w = m;
          break;
        }
        case 92: {
          for (m = w, b = !0; h.charCodeAt(m + 1) === 92; )
            m += 1, b = !b;
          if (d = h.charCodeAt(m + 1), b && d !== 47 && d !== 32 && d !== 10 && d !== 9 && d !== 13 && d !== 12 && (m += 1, s.test(h.charAt(m)))) {
            for (; s.test(h.charAt(m + 1)); )
              m += 1;
            h.charCodeAt(m + 1) === 32 && (m += 1);
          }
          E = ["word", h.slice(w, m + 1), w, m], w = m;
          break;
        }
        default:
          x = h.charCodeAt(w + 1), d === 35 && x === 123 ? (m = w, X(), D = h.slice(w, m + 1), E = ["word", D, w, m], w = m) : d === 47 && x === 42 ? (m = h.indexOf("*/", w + 2) + 1, m === 0 && (p || H ? m = h.length : L("comment")), E = ["comment", h.slice(w, m + 1), w, m], w = m) : d === 47 && x === 47 ? (o.lastIndex = w + 1, o.test(h), o.lastIndex === 0 ? m = h.length - 1 : m = o.lastIndex - 2, D = h.slice(w, m + 1), E = ["comment", D, w, m, "inline"], w = m) : (n.lastIndex = w + 1, n.test(h), n.lastIndex === 0 ? m = h.length - 1 : m = n.lastIndex - 2, E = ["word", h.slice(w, m + 1), w, m], T.push(E), w = m);
          break;
      }
      return w++, E;
    }
    function $(U) {
      P.push(U);
    }
    return { back: $, endOfFile: j, nextToken: Q, position: N };
  };
}), KN = re((t, e) => {
  var { Comment: r } = Dm(), n = mm(), i = zN(), s = JN(), o = class extends n {
    atrule(l) {
      let u = l[1], h = l;
      for (; !this.tokenizer.endOfFile(); ) {
        let p = this.tokenizer.nextToken();
        if (p[0] === "word" && p[2] === h[3] + 1)
          u += p[1], h = p;
        else {
          this.tokenizer.back(p);
          break;
        }
      }
      super.atrule(["at-word", u, l[2], h[3]]);
    }
    comment(l) {
      if (l[4] === "inline") {
        let u = new r();
        this.init(u, l[2]), u.raws.inline = !0;
        let h = this.input.fromOffset(l[3]);
        u.source.end = { column: h.col, line: h.line, offset: l[3] + 1 };
        let p = l[1].slice(2);
        if (/^\s*$/.test(p))
          u.text = "", u.raws.left = p, u.raws.right = "";
        else {
          let d = p.match(/^(\s*)([^]*\S)(\s*)$/), m = d[2].replace(/(\*\/|\/\*)/g, "*//*");
          u.text = m, u.raws.left = d[1], u.raws.right = d[3], u.raws.text = d[2];
        }
      } else
        super.comment(l);
    }
    createTokenizer() {
      this.tokenizer = s(this.input);
    }
    raw(l, u, h, p) {
      if (super.raw(l, u, h, p), l.raws[u]) {
        let d = l.raws[u].raw;
        l.raws[u].raw = h.reduce((m, y) => {
          if (y[0] === "comment" && y[4] === "inline") {
            let D = y[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*");
            return m + "/*" + D + "*/";
          } else
            return m + y[1];
        }, ""), d !== l.raws[u].raw && (l.raws[u].scss = d);
      }
    }
    rule(l) {
      let u = !1, h = 0, p = "";
      for (let d of l)
        if (u)
          d[0] !== "comment" && d[0] !== "{" && (p += d[1]);
        else {
          if (d[0] === "space" && d[1].includes(`
`))
            break;
          d[0] === "(" ? h += 1 : d[0] === ")" ? h -= 1 : h === 0 && d[0] === ":" && (u = !0);
        }
      if (!u || p.trim() === "" || /^[#:A-Za-z-]/.test(p))
        super.rule(l);
      else {
        l.pop();
        let d = new i();
        this.init(d, l[0][2]);
        let m;
        for (let D = l.length - 1; D >= 0; D--)
          if (l[D][0] !== "space") {
            m = l[D];
            break;
          }
        if (m[3]) {
          let D = this.input.fromOffset(m[3]);
          d.source.end = { column: D.col, line: D.line, offset: m[3] + 1 };
        } else {
          let D = this.input.fromOffset(m[2]);
          d.source.end = { column: D.col, line: D.line, offset: m[2] + 1 };
        }
        for (; l[0][0] !== "word"; )
          d.raws.before += l.shift()[1];
        if (l[0][2]) {
          let D = this.input.fromOffset(l[0][2]);
          d.source.start = { column: D.col, line: D.line, offset: l[0][2] };
        }
        for (d.prop = ""; l.length; ) {
          let D = l[0][0];
          if (D === ":" || D === "space" || D === "comment")
            break;
          d.prop += l.shift()[1];
        }
        d.raws.between = "";
        let y;
        for (; l.length; )
          if (y = l.shift(), y[0] === ":") {
            d.raws.between += y[1];
            break;
          } else
            d.raws.between += y[1];
        (d.prop[0] === "_" || d.prop[0] === "*") && (d.raws.before += d.prop[0], d.prop = d.prop.slice(1)), d.raws.between += this.spacesAndCommentsFromStart(l), this.precheckMissedSemicolon(l);
        for (let D = l.length - 1; D > 0; D--) {
          if (y = l[D], y[1] === "!important") {
            d.important = !0;
            let b = this.stringFrom(l, D);
            b = this.spacesFromEnd(l) + b, b !== " !important" && (d.raws.important = b);
            break;
          } else if (y[1] === "important") {
            let b = l.slice(0), C = "";
            for (let A = D; A > 0; A--) {
              let x = b[A][0];
              if (C.trim().indexOf("!") === 0 && x !== "space")
                break;
              C = b.pop()[1] + C;
            }
            C.trim().indexOf("!") === 0 && (d.important = !0, d.raws.important = C, l = b);
          }
          if (y[0] !== "space" && y[0] !== "comment")
            break;
        }
        this.raw(d, "value", l), d.value.includes(":") && this.checkMissedSemicolon(l), this.current = d;
      }
    }
  };
  e.exports = o;
}), GN = re((t, e) => {
  var { Input: r } = Dm(), n = KN();
  e.exports = function(i, s) {
    let o = new r(i, s), l = new n(o);
    return l.parse(), l.root;
  };
}), O2 = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(r) {
    this.after = r.after, this.before = r.before, this.type = r.type, this.value = r.value, this.sourceIndex = r.sourceIndex;
  }
  t.default = e;
}), L2 = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = O2(), r = n(e);
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i(s) {
    var o = this;
    this.constructor(s), this.nodes = s.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(l) {
      l.parent = o;
    });
  }
  i.prototype = Object.create(r.default.prototype), i.constructor = r.default, i.prototype.walk = function(s, o) {
    for (var l = typeof s == "string" || s instanceof RegExp, u = l ? o : s, h = typeof s == "string" ? new RegExp(s) : s, p = 0; p < this.nodes.length; p++) {
      var d = this.nodes[p], m = l ? h.test(d.type) : !0;
      if (m && u && u(d, p, this.nodes) === !1 || d.nodes && d.walk(s, o) === !1)
        return !1;
    }
    return !0;
  }, i.prototype.each = function() {
    for (var s = arguments.length <= 0 || arguments[0] === void 0 ? function() {
    } : arguments[0], o = 0; o < this.nodes.length; o++) {
      var l = this.nodes[o];
      if (s(l, o, this.nodes) === !1)
        return !1;
    }
    return !0;
  }, t.default = i;
}), XN = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.parseMediaFeature = o, t.parseMediaQuery = l, t.parseMediaList = u;
  var e = O2(), r = s(e), n = L2(), i = s(n);
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function o(h) {
    var p = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], d = [{ mode: "normal", character: null }], m = [], y = 0, D = "", b = null, C = null, A = p, x = h;
    h[0] === "(" && h[h.length - 1] === ")" && (x = h.substring(1, h.length - 1), A++);
    for (var E = 0; E < x.length; E++) {
      var k = x[E];
      if ((k === "'" || k === '"') && (d[y].isCalculationEnabled === !0 ? (d.push({ mode: "string", isCalculationEnabled: !1, character: k }), y++) : d[y].mode === "string" && d[y].character === k && x[E - 1] !== "\\" && (d.pop(), y--)), k === "{" ? (d.push({ mode: "interpolation", isCalculationEnabled: !0 }), y++) : k === "}" && (d.pop(), y--), d[y].mode === "normal" && k === ":") {
        var w = x.substring(E + 1);
        C = { type: "value", before: /^(\s*)/.exec(w)[1], after: /(\s*)$/.exec(w)[1], value: w.trim() }, C.sourceIndex = C.before.length + E + 1 + A, b = { type: "colon", sourceIndex: E + A, after: C.before, value: ":" };
        break;
      }
      D += k;
    }
    return D = { type: "media-feature", before: /^(\s*)/.exec(D)[1], after: /(\s*)$/.exec(D)[1], value: D.trim() }, D.sourceIndex = D.before.length + A, m.push(D), b !== null && (b.before = D.after, m.push(b)), C !== null && m.push(C), m;
  }
  function l(h) {
    var p = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], d = [], m = 0, y = !1, D = void 0;
    function b() {
      return { before: "", after: "", value: "" };
    }
    D = b();
    for (var C = 0; C < h.length; C++) {
      var A = h[C];
      y ? (D.value += A, (A === "{" || A === "(") && m++, (A === ")" || A === "}") && m--) : A.search(/\s/) !== -1 ? D.before += A : (A === "(" && (D.type = "media-feature-expression", m++), D.value = A, D.sourceIndex = p + C, y = !0), y && m === 0 && (A === ")" || C === h.length - 1 || h[C + 1].search(/\s/) !== -1) && (["not", "only", "and"].indexOf(D.value) !== -1 && (D.type = "keyword"), D.type === "media-feature-expression" && (D.nodes = o(D.value, D.sourceIndex)), d.push(Array.isArray(D.nodes) ? new i.default(D) : new r.default(D)), D = b(), y = !1);
    }
    for (var x = 0; x < d.length; x++)
      if (D = d[x], x > 0 && (d[x - 1].after = D.before), D.type === void 0) {
        if (x > 0) {
          if (d[x - 1].type === "media-feature-expression") {
            D.type = "keyword";
            continue;
          }
          if (d[x - 1].value === "not" || d[x - 1].value === "only") {
            D.type = "media-type";
            continue;
          }
          if (d[x - 1].value === "and") {
            D.type = "media-feature-expression";
            continue;
          }
          d[x - 1].type === "media-type" && (d[x + 1] ? D.type = d[x + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : D.type = "media-feature-expression");
        }
        if (x === 0) {
          if (!d[x + 1]) {
            D.type = "media-type";
            continue;
          }
          if (d[x + 1] && (d[x + 1].type === "media-feature-expression" || d[x + 1].type === "keyword")) {
            D.type = "media-type";
            continue;
          }
          if (d[x + 2]) {
            if (d[x + 2].type === "media-feature-expression") {
              D.type = "media-type", d[x + 1].type = "keyword";
              continue;
            }
            if (d[x + 2].type === "keyword") {
              D.type = "keyword", d[x + 1].type = "media-type";
              continue;
            }
          }
          if (d[x + 3] && d[x + 3].type === "media-feature-expression") {
            D.type = "keyword", d[x + 1].type = "media-type", d[x + 2].type = "keyword";
            continue;
          }
        }
      }
    return d;
  }
  function u(h) {
    var p = [], d = 0, m = 0, y = /^(\s*)url\s*\(/.exec(h);
    if (y !== null) {
      for (var D = y[0].length, b = 1; b > 0; ) {
        var C = h[D];
        C === "(" && b++, C === ")" && b--, D++;
      }
      p.unshift(new r.default({ type: "url", value: h.substring(0, D).trim(), sourceIndex: y[1].length, before: y[1], after: /^(\s*)/.exec(h.substring(D))[1] })), d = D;
    }
    for (var A = d; A < h.length; A++) {
      var x = h[A];
      if (x === "(" && m++, x === ")" && m--, m === 0 && x === ",") {
        var E = h.substring(d, A), k = /^(\s*)/.exec(E)[1];
        p.push(new i.default({ type: "media-query", value: E.trim(), sourceIndex: d + k.length, nodes: l(E, d), before: k, after: /(\s*)$/.exec(E)[1] })), d = A + 1;
      }
    }
    var w = h.substring(d), T = /^(\s*)/.exec(w)[1];
    return p.push(new i.default({ type: "media-query", value: w.trim(), sourceIndex: d + T.length, nodes: l(w, d), before: T, after: /(\s*)$/.exec(w)[1] })), p;
  }
}), YN = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = s;
  var e = L2(), r = i(e), n = XN();
  function i(o) {
    return o && o.__esModule ? o : { default: o };
  }
  function s(o) {
    return new r.default({ nodes: (0, n.parseMediaList)(o), type: "media-query-list", value: o.trim() });
  }
}), _2 = re((t, e) => {
  e.exports = function(r, n) {
    if (n = typeof n == "number" ? n : 1 / 0, !n)
      return Array.isArray(r) ? r.map(function(s) {
        return s;
      }) : r;
    return i(r, 1);
    function i(s, o) {
      return s.reduce(function(l, u) {
        return Array.isArray(u) && o < n ? l.concat(i(u, o + 1)) : l.concat(u);
      }, []);
    }
  };
}), $2 = re((t, e) => {
  e.exports = function(r, n) {
    for (var i = -1, s = []; (i = r.indexOf(n, i + 1)) !== -1; )
      s.push(i);
    return s;
  };
}), R2 = re((t, e) => {
  function r(s, o) {
    for (var l = 1, u = s.length, h = s[0], p = s[0], d = 1; d < u; ++d)
      if (p = h, h = s[d], o(h, p)) {
        if (d === l) {
          l++;
          continue;
        }
        s[l++] = h;
      }
    return s.length = l, s;
  }
  function n(s) {
    for (var o = 1, l = s.length, u = s[0], h = s[0], p = 1; p < l; ++p, h = u)
      if (h = u, u = s[p], u !== h) {
        if (p === o) {
          o++;
          continue;
        }
        s[o++] = u;
      }
    return s.length = o, s;
  }
  function i(s, o, l) {
    return s.length === 0 ? s : o ? (l || s.sort(o), r(s, o)) : (l || s.sort(), n(s));
  }
  e.exports = i;
}), Bo = re((t, e) => {
  t.__esModule = !0;
  var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
    return typeof o;
  } : function(o) {
    return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  };
  function n(o, l) {
    if (!(o instanceof l))
      throw new TypeError("Cannot call a class as a function");
  }
  var i = function o(l, u) {
    if ((typeof l > "u" ? "undefined" : r(l)) !== "object")
      return l;
    var h = new l.constructor();
    for (var p in l)
      if (l.hasOwnProperty(p)) {
        var d = l[p], m = typeof d > "u" ? "undefined" : r(d);
        p === "parent" && m === "object" ? u && (h[p] = u) : d instanceof Array ? h[p] = d.map(function(y) {
          return o(y, h);
        }) : h[p] = o(d, h);
      }
    return h;
  }, s = function() {
    function o() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      n(this, o);
      for (var u in l)
        this[u] = l[u];
      var h = l.spaces;
      h = h === void 0 ? {} : h;
      var p = h.before, d = p === void 0 ? "" : p, m = h.after, y = m === void 0 ? "" : m;
      this.spaces = { before: d, after: y };
    }
    return o.prototype.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, o.prototype.replaceWith = function() {
      if (this.parent) {
        for (var l in arguments)
          this.parent.insertBefore(this, arguments[l]);
        this.remove();
      }
      return this;
    }, o.prototype.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, o.prototype.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, o.prototype.clone = function() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = i(this);
      for (var h in l)
        u[h] = l[h];
      return u;
    }, o.prototype.toString = function() {
      return [this.spaces.before, String(this.value), this.spaces.after].join("");
    }, o;
  }();
  t.default = s, e.exports = t.default;
}), sr = re((t) => {
  t.__esModule = !0, t.TAG = "tag", t.STRING = "string", t.SELECTOR = "selector", t.ROOT = "root", t.PSEUDO = "pseudo", t.NESTING = "nesting", t.ID = "id", t.COMMENT = "comment", t.COMBINATOR = "combinator", t.CLASS = "class", t.ATTRIBUTE = "attribute", t.UNIVERSAL = "universal";
}), xm = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function y(D, b) {
      for (var C = 0; C < b.length; C++) {
        var A = b[C];
        A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(D, A.key, A);
      }
    }
    return function(D, b, C) {
      return b && y(D.prototype, b), C && y(D, C), D;
    };
  }(), n = Bo(), i = u(n), s = sr(), o = l(s);
  function l(y) {
    if (y && y.__esModule)
      return y;
    var D = {};
    if (y != null)
      for (var b in y)
        Object.prototype.hasOwnProperty.call(y, b) && (D[b] = y[b]);
    return D.default = y, D;
  }
  function u(y) {
    return y && y.__esModule ? y : { default: y };
  }
  function h(y, D) {
    if (!(y instanceof D))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(y, D) {
    if (!y)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return D && (typeof D == "object" || typeof D == "function") ? D : y;
  }
  function d(y, D) {
    if (typeof D != "function" && D !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof D);
    y.prototype = Object.create(D && D.prototype, { constructor: { value: y, enumerable: !1, writable: !0, configurable: !0 } }), D && (Object.setPrototypeOf ? Object.setPrototypeOf(y, D) : y.__proto__ = D);
  }
  var m = function(y) {
    d(D, y);
    function D(b) {
      h(this, D);
      var C = p(this, y.call(this, b));
      return C.nodes || (C.nodes = []), C;
    }
    return D.prototype.append = function(b) {
      return b.parent = this, this.nodes.push(b), this;
    }, D.prototype.prepend = function(b) {
      return b.parent = this, this.nodes.unshift(b), this;
    }, D.prototype.at = function(b) {
      return this.nodes[b];
    }, D.prototype.index = function(b) {
      return typeof b == "number" ? b : this.nodes.indexOf(b);
    }, D.prototype.removeChild = function(b) {
      b = this.index(b), this.at(b).parent = void 0, this.nodes.splice(b, 1);
      var C = void 0;
      for (var A in this.indexes)
        C = this.indexes[A], C >= b && (this.indexes[A] = C - 1);
      return this;
    }, D.prototype.removeAll = function() {
      for (var A = this.nodes, b = Array.isArray(A), C = 0, A = b ? A : A[Symbol.iterator](); ; ) {
        var x;
        if (b) {
          if (C >= A.length)
            break;
          x = A[C++];
        } else {
          if (C = A.next(), C.done)
            break;
          x = C.value;
        }
        var E = x;
        E.parent = void 0;
      }
      return this.nodes = [], this;
    }, D.prototype.empty = function() {
      return this.removeAll();
    }, D.prototype.insertAfter = function(b, C) {
      var A = this.index(b);
      this.nodes.splice(A + 1, 0, C);
      var x = void 0;
      for (var E in this.indexes)
        x = this.indexes[E], A <= x && (this.indexes[E] = x + this.nodes.length);
      return this;
    }, D.prototype.insertBefore = function(b, C) {
      var A = this.index(b);
      this.nodes.splice(A, 0, C);
      var x = void 0;
      for (var E in this.indexes)
        x = this.indexes[E], A <= x && (this.indexes[E] = x + this.nodes.length);
      return this;
    }, D.prototype.each = function(b) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var C = this.lastEach;
      if (this.indexes[C] = 0, !!this.length) {
        for (var A = void 0, x = void 0; this.indexes[C] < this.length && (A = this.indexes[C], x = b(this.at(A), A), x !== !1); )
          this.indexes[C] += 1;
        if (delete this.indexes[C], x === !1)
          return !1;
      }
    }, D.prototype.walk = function(b) {
      return this.each(function(C, A) {
        var x = b(C, A);
        if (x !== !1 && C.length && (x = C.walk(b)), x === !1)
          return !1;
      });
    }, D.prototype.walkAttributes = function(b) {
      var C = this;
      return this.walk(function(A) {
        if (A.type === o.ATTRIBUTE)
          return b.call(C, A);
      });
    }, D.prototype.walkClasses = function(b) {
      var C = this;
      return this.walk(function(A) {
        if (A.type === o.CLASS)
          return b.call(C, A);
      });
    }, D.prototype.walkCombinators = function(b) {
      var C = this;
      return this.walk(function(A) {
        if (A.type === o.COMBINATOR)
          return b.call(C, A);
      });
    }, D.prototype.walkComments = function(b) {
      var C = this;
      return this.walk(function(A) {
        if (A.type === o.COMMENT)
          return b.call(C, A);
      });
    }, D.prototype.walkIds = function(b) {
      var C = this;
      return this.walk(function(A) {
        if (A.type === o.ID)
          return b.call(C, A);
      });
    }, D.prototype.walkNesting = function(b) {
      var C = this;
      return this.walk(function(A) {
        if (A.type === o.NESTING)
          return b.call(C, A);
      });
    }, D.prototype.walkPseudos = function(b) {
      var C = this;
      return this.walk(function(A) {
        if (A.type === o.PSEUDO)
          return b.call(C, A);
      });
    }, D.prototype.walkTags = function(b) {
      var C = this;
      return this.walk(function(A) {
        if (A.type === o.TAG)
          return b.call(C, A);
      });
    }, D.prototype.walkUniversals = function(b) {
      var C = this;
      return this.walk(function(A) {
        if (A.type === o.UNIVERSAL)
          return b.call(C, A);
      });
    }, D.prototype.split = function(b) {
      var C = this, A = [];
      return this.reduce(function(x, E, k) {
        var w = b.call(C, E);
        return A.push(E), w ? (x.push(A), A = []) : k === C.length - 1 && x.push(A), x;
      }, []);
    }, D.prototype.map = function(b) {
      return this.nodes.map(b);
    }, D.prototype.reduce = function(b, C) {
      return this.nodes.reduce(b, C);
    }, D.prototype.every = function(b) {
      return this.nodes.every(b);
    }, D.prototype.some = function(b) {
      return this.nodes.some(b);
    }, D.prototype.filter = function(b) {
      return this.nodes.filter(b);
    }, D.prototype.sort = function(b) {
      return this.nodes.sort(b);
    }, D.prototype.toString = function() {
      return this.map(String).join("");
    }, r(D, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), D;
  }(i.default);
  t.default = m, e.exports = t.default;
}), QN = re((t, e) => {
  t.__esModule = !0;
  var r = xm(), n = s(r), i = sr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      o(this, d);
      var y = l(this, p.call(this, m));
      return y.type = i.ROOT, y;
    }
    return d.prototype.toString = function() {
      var m = this.reduce(function(y, D) {
        var b = String(D);
        return b ? y + b + "," : "";
      }, "").slice(0, -1);
      return this.trailingComma ? m + "," : m;
    }, d;
  }(n.default);
  t.default = h, e.exports = t.default;
}), ZN = re((t, e) => {
  t.__esModule = !0;
  var r = xm(), n = s(r), i = sr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      o(this, d);
      var y = l(this, p.call(this, m));
      return y.type = i.SELECTOR, y;
    }
    return d;
  }(n.default);
  t.default = h, e.exports = t.default;
}), Dl = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function p(d, m) {
      for (var y = 0; y < m.length; y++) {
        var D = m[y];
        D.enumerable = D.enumerable || !1, D.configurable = !0, "value" in D && (D.writable = !0), Object.defineProperty(d, D.key, D);
      }
    }
    return function(d, m, y) {
      return m && p(d.prototype, m), y && p(d, y), d;
    };
  }(), n = Bo(), i = s(n);
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d() {
      return o(this, d), l(this, p.apply(this, arguments));
    }
    return d.prototype.toString = function() {
      return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
    }, r(d, [{ key: "ns", get: function() {
      var m = this.namespace;
      return m ? (typeof m == "string" ? m : "") + "|" : "";
    } }]), d;
  }(i.default);
  t.default = h, e.exports = t.default;
}), e8 = re((t, e) => {
  t.__esModule = !0;
  var r = Dl(), n = s(r), i = sr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      o(this, d);
      var y = l(this, p.call(this, m));
      return y.type = i.CLASS, y;
    }
    return d.prototype.toString = function() {
      return [this.spaces.before, this.ns, "." + this.value, this.spaces.after].join("");
    }, d;
  }(n.default);
  t.default = h, e.exports = t.default;
}), t8 = re((t, e) => {
  t.__esModule = !0;
  var r = Bo(), n = s(r), i = sr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      o(this, d);
      var y = l(this, p.call(this, m));
      return y.type = i.COMMENT, y;
    }
    return d;
  }(n.default);
  t.default = h, e.exports = t.default;
}), r8 = re((t, e) => {
  t.__esModule = !0;
  var r = Dl(), n = s(r), i = sr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      o(this, d);
      var y = l(this, p.call(this, m));
      return y.type = i.ID, y;
    }
    return d.prototype.toString = function() {
      return [this.spaces.before, this.ns, "#" + this.value, this.spaces.after].join("");
    }, d;
  }(n.default);
  t.default = h, e.exports = t.default;
}), n8 = re((t, e) => {
  t.__esModule = !0;
  var r = Dl(), n = s(r), i = sr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      o(this, d);
      var y = l(this, p.call(this, m));
      return y.type = i.TAG, y;
    }
    return d;
  }(n.default);
  t.default = h, e.exports = t.default;
}), i8 = re((t, e) => {
  t.__esModule = !0;
  var r = Bo(), n = s(r), i = sr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      o(this, d);
      var y = l(this, p.call(this, m));
      return y.type = i.STRING, y;
    }
    return d;
  }(n.default);
  t.default = h, e.exports = t.default;
}), s8 = re((t, e) => {
  t.__esModule = !0;
  var r = xm(), n = s(r), i = sr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      o(this, d);
      var y = l(this, p.call(this, m));
      return y.type = i.PSEUDO, y;
    }
    return d.prototype.toString = function() {
      var m = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.spaces.before, String(this.value), m, this.spaces.after].join("");
    }, d;
  }(n.default);
  t.default = h, e.exports = t.default;
}), o8 = re((t, e) => {
  t.__esModule = !0;
  var r = Dl(), n = s(r), i = sr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      o(this, d);
      var y = l(this, p.call(this, m));
      return y.type = i.ATTRIBUTE, y.raws = {}, y;
    }
    return d.prototype.toString = function() {
      var m = [this.spaces.before, "[", this.ns, this.attribute];
      return this.operator && m.push(this.operator), this.value && m.push(this.value), this.raws.insensitive ? m.push(this.raws.insensitive) : this.insensitive && m.push(" i"), m.push("]"), m.concat(this.spaces.after).join("");
    }, d;
  }(n.default);
  t.default = h, e.exports = t.default;
}), a8 = re((t, e) => {
  t.__esModule = !0;
  var r = Dl(), n = s(r), i = sr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      o(this, d);
      var y = l(this, p.call(this, m));
      return y.type = i.UNIVERSAL, y.value = "*", y;
    }
    return d;
  }(n.default);
  t.default = h, e.exports = t.default;
}), l8 = re((t, e) => {
  t.__esModule = !0;
  var r = Bo(), n = s(r), i = sr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      o(this, d);
      var y = l(this, p.call(this, m));
      return y.type = i.COMBINATOR, y;
    }
    return d;
  }(n.default);
  t.default = h, e.exports = t.default;
}), u8 = re((t, e) => {
  t.__esModule = !0;
  var r = Bo(), n = s(r), i = sr();
  function s(p) {
    return p && p.__esModule ? p : { default: p };
  }
  function o(p, d) {
    if (!(p instanceof d))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(p, d) {
    if (!p)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return d && (typeof d == "object" || typeof d == "function") ? d : p;
  }
  function u(p, d) {
    if (typeof d != "function" && d !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof d);
    p.prototype = Object.create(d && d.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(p, d) : p.__proto__ = d);
  }
  var h = function(p) {
    u(d, p);
    function d(m) {
      o(this, d);
      var y = l(this, p.call(this, m));
      return y.type = i.NESTING, y.value = "&", y;
    }
    return d;
  }(n.default);
  t.default = h, e.exports = t.default;
}), c8 = re((t, e) => {
  t.__esModule = !0, t.default = r;
  function r(n) {
    return n.sort(function(i, s) {
      return i - s;
    });
  }
  e.exports = t.default;
}), h8 = re((t, e) => {
  t.__esModule = !0, t.default = j;
  var r = 39, n = 34, i = 92, s = 47, o = 10, l = 32, u = 12, h = 9, p = 13, d = 43, m = 62, y = 126, D = 124, b = 44, C = 40, A = 41, x = 91, E = 93, k = 59, w = 42, T = 58, P = 38, M = 64, N = /[ \n\t\r\{\(\)'"\\;/]/g, L = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
  function j(X) {
    for (var Q = [], $ = X.css.valueOf(), U = void 0, H = void 0, Z = void 0, ye = void 0, Ee = void 0, ve = void 0, $e = void 0, Ke = void 0, Qe = void 0, Fe = void 0, ht = void 0, le = $.length, z = -1, W = 1, R = 0, Ce = function(be, Te) {
      if (X.safe)
        $ += Te, H = $.length - 1;
      else
        throw X.error("Unclosed " + be, W, R - z, R);
    }; R < le; ) {
      switch (U = $.charCodeAt(R), U === o && (z = R, W += 1), U) {
        case o:
        case l:
        case h:
        case p:
        case u:
          H = R;
          do
            H += 1, U = $.charCodeAt(H), U === o && (z = H, W += 1);
          while (U === l || U === o || U === h || U === p || U === u);
          Q.push(["space", $.slice(R, H), W, R - z, R]), R = H - 1;
          break;
        case d:
        case m:
        case y:
        case D:
          H = R;
          do
            H += 1, U = $.charCodeAt(H);
          while (U === d || U === m || U === y || U === D);
          Q.push(["combinator", $.slice(R, H), W, R - z, R]), R = H - 1;
          break;
        case w:
          Q.push(["*", "*", W, R - z, R]);
          break;
        case P:
          Q.push(["&", "&", W, R - z, R]);
          break;
        case b:
          Q.push([",", ",", W, R - z, R]);
          break;
        case x:
          Q.push(["[", "[", W, R - z, R]);
          break;
        case E:
          Q.push(["]", "]", W, R - z, R]);
          break;
        case T:
          Q.push([":", ":", W, R - z, R]);
          break;
        case k:
          Q.push([";", ";", W, R - z, R]);
          break;
        case C:
          Q.push(["(", "(", W, R - z, R]);
          break;
        case A:
          Q.push([")", ")", W, R - z, R]);
          break;
        case r:
        case n:
          Z = U === r ? "'" : '"', H = R;
          do
            for (Fe = !1, H = $.indexOf(Z, H + 1), H === -1 && Ce("quote", Z), ht = H; $.charCodeAt(ht - 1) === i; )
              ht -= 1, Fe = !Fe;
          while (Fe);
          Q.push(["string", $.slice(R, H + 1), W, R - z, W, H - z, R]), R = H;
          break;
        case M:
          N.lastIndex = R + 1, N.test($), N.lastIndex === 0 ? H = $.length - 1 : H = N.lastIndex - 2, Q.push(["at-word", $.slice(R, H + 1), W, R - z, W, H - z, R]), R = H;
          break;
        case i:
          for (H = R, $e = !0; $.charCodeAt(H + 1) === i; )
            H += 1, $e = !$e;
          U = $.charCodeAt(H + 1), $e && U !== s && U !== l && U !== o && U !== h && U !== p && U !== u && (H += 1), Q.push(["word", $.slice(R, H + 1), W, R - z, W, H - z, R]), R = H;
          break;
        default:
          U === s && $.charCodeAt(R + 1) === w ? (H = $.indexOf("*/", R + 2) + 1, H === 0 && Ce("comment", "*/"), ve = $.slice(R, H + 1), ye = ve.split(`
`), Ee = ye.length - 1, Ee > 0 ? (Ke = W + Ee, Qe = H - ye[Ee].length) : (Ke = W, Qe = z), Q.push(["comment", ve, W, R - z, Ke, H - Qe, R]), z = Qe, W = Ke, R = H) : (L.lastIndex = R + 1, L.test($), L.lastIndex === 0 ? H = $.length - 1 : H = L.lastIndex - 2, Q.push(["word", $.slice(R, H + 1), W, R - z, W, H - z, R]), R = H);
          break;
      }
      R++;
    }
    return Q;
  }
  e.exports = t.default;
}), p8 = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function z(W, R) {
      for (var Ce = 0; Ce < R.length; Ce++) {
        var be = R[Ce];
        be.enumerable = be.enumerable || !1, be.configurable = !0, "value" in be && (be.writable = !0), Object.defineProperty(W, be.key, be);
      }
    }
    return function(W, R, Ce) {
      return R && z(W.prototype, R), Ce && z(W, Ce), W;
    };
  }(), n = _2(), i = Fe(n), s = $2(), o = Fe(s), l = R2(), u = Fe(l), h = QN(), p = Fe(h), d = ZN(), m = Fe(d), y = e8(), D = Fe(y), b = t8(), C = Fe(b), A = r8(), x = Fe(A), E = n8(), k = Fe(E), w = i8(), T = Fe(w), P = s8(), M = Fe(P), N = o8(), L = Fe(N), j = a8(), X = Fe(j), Q = l8(), $ = Fe(Q), U = u8(), H = Fe(U), Z = c8(), ye = Fe(Z), Ee = h8(), ve = Fe(Ee), $e = sr(), Ke = Qe($e);
  function Qe(z) {
    if (z && z.__esModule)
      return z;
    var W = {};
    if (z != null)
      for (var R in z)
        Object.prototype.hasOwnProperty.call(z, R) && (W[R] = z[R]);
    return W.default = z, W;
  }
  function Fe(z) {
    return z && z.__esModule ? z : { default: z };
  }
  function ht(z, W) {
    if (!(z instanceof W))
      throw new TypeError("Cannot call a class as a function");
  }
  var le = function() {
    function z(W) {
      ht(this, z), this.input = W, this.lossy = W.options.lossless === !1, this.position = 0, this.root = new p.default();
      var R = new m.default();
      return this.root.append(R), this.current = R, this.lossy ? this.tokens = (0, ve.default)({ safe: W.safe, css: W.css.trim() }) : this.tokens = (0, ve.default)(W), this.loop();
    }
    return z.prototype.attribute = function() {
      var W = "", R = void 0, Ce = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; )
        W += this.tokens[this.position][1], this.position++;
      this.position === this.tokens.length && !~W.indexOf("]") && this.error("Expected a closing square bracket.");
      var be = W.split(/((?:[*~^$|]?=))([^]*)/), Te = be[0].split(/(\|)/g), Qt = { operator: be[1], value: be[2], source: { start: { line: Ce[2], column: Ce[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: Ce[4] };
      if (Te.length > 1 ? (Te[0] === "" && (Te[0] = !0), Qt.attribute = this.parseValue(Te[2]), Qt.namespace = this.parseNamespace(Te[0])) : Qt.attribute = this.parseValue(be[0]), R = new L.default(Qt), be[2]) {
        var Mt = be[2].split(/(\s+i\s*?)$/), xt = Mt[0].trim();
        R.value = this.lossy ? xt : Mt[0], Mt[1] && (R.insensitive = !0, this.lossy || (R.raws.insensitive = Mt[1])), R.quoted = xt[0] === "'" || xt[0] === '"', R.raws.unquoted = R.quoted ? xt.slice(1, -1) : xt;
      }
      this.newNode(R), this.position++;
    }, z.prototype.combinator = function() {
      if (this.currToken[1] === "|")
        return this.namespace();
      for (var W = new $.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); )
        this.nextToken && this.nextToken[0] === "combinator" ? (W.spaces.before = this.parseSpace(this.currToken[1]), W.source.start.line = this.nextToken[2], W.source.start.column = this.nextToken[3], W.source.end.column = this.nextToken[3], W.source.end.line = this.nextToken[2], W.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? W.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? W.value = this.currToken[1] : this.currToken[0] === "space" && (W.value = this.parseSpace(this.currToken[1], " ")), this.position++;
      return this.newNode(W);
    }, z.prototype.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = !0, this.position++;
        return;
      }
      var W = new m.default();
      this.current.parent.append(W), this.current = W, this.position++;
    }, z.prototype.comment = function() {
      var W = new C.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
      this.newNode(W), this.position++;
    }, z.prototype.error = function(W) {
      throw new this.input.error(W);
    }, z.prototype.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.");
    }, z.prototype.missingParenthesis = function() {
      return this.error("Expected opening parenthesis.");
    }, z.prototype.missingSquareBracket = function() {
      return this.error("Expected opening square bracket.");
    }, z.prototype.namespace = function() {
      var W = this.prevToken && this.prevToken[1] || !0;
      if (this.nextToken[0] === "word")
        return this.position++, this.word(W);
      if (this.nextToken[0] === "*")
        return this.position++, this.universal(W);
    }, z.prototype.nesting = function() {
      this.newNode(new H.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
    }, z.prototype.parentheses = function() {
      var W = this.current.last;
      if (W && W.type === Ke.PSEUDO) {
        var R = new m.default(), Ce = this.current;
        W.append(R), this.current = R;
        var be = 1;
        for (this.position++; this.position < this.tokens.length && be; )
          this.currToken[0] === "(" && be++, this.currToken[0] === ")" && be--, be ? this.parse() : (R.parent.source.end.line = this.currToken[2], R.parent.source.end.column = this.currToken[3], this.position++);
        be && this.error("Expected closing parenthesis."), this.current = Ce;
      } else {
        var Te = 1;
        for (this.position++, W.value += "("; this.position < this.tokens.length && Te; )
          this.currToken[0] === "(" && Te++, this.currToken[0] === ")" && Te--, W.value += this.parseParenthesisToken(this.currToken), this.position++;
        Te && this.error("Expected closing parenthesis.");
      }
    }, z.prototype.pseudo = function() {
      for (var W = this, R = "", Ce = this.currToken; this.currToken && this.currToken[0] === ":"; )
        R += this.currToken[1], this.position++;
      if (!this.currToken)
        return this.error("Expected pseudo-class or pseudo-element");
      if (this.currToken[0] === "word") {
        var be = void 0;
        this.splitWord(!1, function(Te, Qt) {
          R += Te, be = new M.default({ value: R, source: { start: { line: Ce[2], column: Ce[3] }, end: { line: W.currToken[4], column: W.currToken[5] } }, sourceIndex: Ce[4] }), W.newNode(be), Qt > 1 && W.nextToken && W.nextToken[0] === "(" && W.error("Misplaced parenthesis.");
        });
      } else
        this.error('Unexpected "' + this.currToken[0] + '" found.');
    }, z.prototype.space = function() {
      var W = this.currToken;
      this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(W[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(W[1]), this.position++) : this.combinator();
    }, z.prototype.string = function() {
      var W = this.currToken;
      this.newNode(new T.default({ value: this.currToken[1], source: { start: { line: W[2], column: W[3] }, end: { line: W[4], column: W[5] } }, sourceIndex: W[6] })), this.position++;
    }, z.prototype.universal = function(W) {
      var R = this.nextToken;
      if (R && R[1] === "|")
        return this.position++, this.namespace();
      this.newNode(new X.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), W), this.position++;
    }, z.prototype.splitWord = function(W, R) {
      for (var Ce = this, be = this.nextToken, Te = this.currToken[1]; be && be[0] === "word"; ) {
        this.position++;
        var Qt = this.currToken[1];
        if (Te += Qt, Qt.lastIndexOf("\\") === Qt.length - 1) {
          var Mt = this.nextToken;
          Mt && Mt[0] === "space" && (Te += this.parseSpace(Mt[1], " "), this.position++);
        }
        be = this.nextToken;
      }
      var xt = (0, o.default)(Te, "."), Ur = (0, o.default)(Te, "#"), ii = (0, o.default)(Te, "#{");
      ii.length && (Ur = Ur.filter(function(Er) {
        return !~ii.indexOf(Er);
      }));
      var or = (0, ye.default)((0, u.default)((0, i.default)([[0], xt, Ur])));
      or.forEach(function(Er, on) {
        var si = or[on + 1] || Te.length, Ln = Te.slice(Er, si);
        if (on === 0 && R)
          return R.call(Ce, Ln, or.length);
        var _n = void 0;
        ~xt.indexOf(Er) ? _n = new D.default({ value: Ln.slice(1), source: { start: { line: Ce.currToken[2], column: Ce.currToken[3] + Er }, end: { line: Ce.currToken[4], column: Ce.currToken[3] + (si - 1) } }, sourceIndex: Ce.currToken[6] + or[on] }) : ~Ur.indexOf(Er) ? _n = new x.default({ value: Ln.slice(1), source: { start: { line: Ce.currToken[2], column: Ce.currToken[3] + Er }, end: { line: Ce.currToken[4], column: Ce.currToken[3] + (si - 1) } }, sourceIndex: Ce.currToken[6] + or[on] }) : _n = new k.default({ value: Ln, source: { start: { line: Ce.currToken[2], column: Ce.currToken[3] + Er }, end: { line: Ce.currToken[4], column: Ce.currToken[3] + (si - 1) } }, sourceIndex: Ce.currToken[6] + or[on] }), Ce.newNode(_n, W);
      }), this.position++;
    }, z.prototype.word = function(W) {
      var R = this.nextToken;
      return R && R[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(W);
    }, z.prototype.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(!0);
      return this.root;
    }, z.prototype.parse = function(W) {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parentheses();
          break;
        case ")":
          W && this.missingParenthesis();
          break;
        case "[":
          this.attribute();
          break;
        case "]":
          this.missingSquareBracket();
          break;
        case "at-word":
        case "word":
          this.word();
          break;
        case ":":
          this.pseudo();
          break;
        case ";":
          this.missingBackslash();
          break;
        case ",":
          this.comma();
          break;
        case "*":
          this.universal();
          break;
        case "&":
          this.nesting();
          break;
        case "combinator":
          this.combinator();
          break;
        case "string":
          this.string();
          break;
      }
    }, z.prototype.parseNamespace = function(W) {
      if (this.lossy && typeof W == "string") {
        var R = W.trim();
        return R.length ? R : !0;
      }
      return W;
    }, z.prototype.parseSpace = function(W, R) {
      return this.lossy ? R || "" : W;
    }, z.prototype.parseValue = function(W) {
      return this.lossy && W && typeof W == "string" ? W.trim() : W;
    }, z.prototype.parseParenthesisToken = function(W) {
      return this.lossy ? W[0] === "space" ? this.parseSpace(W[1], " ") : this.parseValue(W[1]) : W[1];
    }, z.prototype.newNode = function(W, R) {
      return R && (W.namespace = this.parseNamespace(R)), this.spaces && (W.spaces.before = this.spaces, this.spaces = ""), this.current.append(W);
    }, r(z, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), z;
  }();
  t.default = le, e.exports = t.default;
}), d8 = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function u(h, p) {
      for (var d = 0; d < p.length; d++) {
        var m = p[d];
        m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(h, m.key, m);
      }
    }
    return function(h, p, d) {
      return p && u(h.prototype, p), d && u(h, d), h;
    };
  }(), n = p8(), i = s(n);
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  var l = function() {
    function u(h) {
      return o(this, u), this.func = h || function() {
      }, this;
    }
    return u.prototype.process = function(h) {
      var p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, d = new i.default({ css: h, error: function(m) {
        throw new Error(m);
      }, options: p });
      return this.res = d, this.func(d), this;
    }, r(u, [{ key: "result", get: function() {
      return String(this.res);
    } }]), u;
  }();
  t.default = l, e.exports = t.default;
}), In = re((t, e) => {
  var r = function(n, i) {
    let s = new n.constructor();
    for (let o in n) {
      if (!n.hasOwnProperty(o))
        continue;
      let l = n[o], u = typeof l;
      o === "parent" && u === "object" ? i && (s[o] = i) : o === "source" ? s[o] = l : l instanceof Array ? s[o] = l.map((h) => r(h, s)) : o !== "before" && o !== "after" && o !== "between" && o !== "semicolon" && (u === "object" && l !== null && (l = r(l)), s[o] = l);
    }
    return s;
  };
  e.exports = class {
    constructor(n) {
      n = n || {}, this.raws = { before: "", after: "" };
      for (let i in n)
        this[i] = n[i];
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    toString() {
      return [this.raws.before, String(this.value), this.raws.after].join("");
    }
    clone(n) {
      n = n || {};
      let i = r(this);
      for (let s in n)
        i[s] = n[s];
      return i;
    }
    cloneBefore(n) {
      n = n || {};
      let i = this.clone(n);
      return this.parent.insertBefore(this, i), i;
    }
    cloneAfter(n) {
      n = n || {};
      let i = this.clone(n);
      return this.parent.insertAfter(this, i), i;
    }
    replaceWith() {
      let n = Array.prototype.slice.call(arguments);
      if (this.parent) {
        for (let i of n)
          this.parent.insertBefore(this, i);
        this.remove();
      }
      return this;
    }
    moveTo(n) {
      return this.cleanRaws(this.root() === n.root()), this.remove(), n.append(this), this;
    }
    moveBefore(n) {
      return this.cleanRaws(this.root() === n.root()), this.remove(), n.parent.insertBefore(n, this), this;
    }
    moveAfter(n) {
      return this.cleanRaws(this.root() === n.root()), this.remove(), n.parent.insertAfter(n, this), this;
    }
    next() {
      let n = this.parent.index(this);
      return this.parent.nodes[n + 1];
    }
    prev() {
      let n = this.parent.index(this);
      return this.parent.nodes[n - 1];
    }
    toJSON() {
      let n = {};
      for (let i in this) {
        if (!this.hasOwnProperty(i) || i === "parent")
          continue;
        let s = this[i];
        s instanceof Array ? n[i] = s.map((o) => typeof o == "object" && o.toJSON ? o.toJSON() : o) : typeof s == "object" && s.toJSON ? n[i] = s.toJSON() : n[i] = s;
      }
      return n;
    }
    root() {
      let n = this;
      for (; n.parent; )
        n = n.parent;
      return n;
    }
    cleanRaws(n) {
      delete this.raws.before, delete this.raws.after, n || delete this.raws.between;
    }
    positionInside(n) {
      let i = this.toString(), s = this.source.start.column, o = this.source.start.line;
      for (let l = 0; l < n; l++)
        i[l] === `
` ? (s = 1, o += 1) : s += 1;
      return { line: o, column: s };
    }
    positionBy(n) {
      let i = this.source.start;
      if (Object(n).index)
        i = this.positionInside(n.index);
      else if (Object(n).word) {
        let s = this.toString().indexOf(n.word);
        s !== -1 && (i = this.positionInside(s));
      }
      return i;
    }
  };
}), Cr = re((t, e) => {
  var r = In(), n = class extends r {
    constructor(i) {
      super(i), this.nodes || (this.nodes = []);
    }
    push(i) {
      return i.parent = this, this.nodes.push(i), this;
    }
    each(i) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let s = this.lastEach, o, l;
      if (this.indexes[s] = 0, !!this.nodes) {
        for (; this.indexes[s] < this.nodes.length && (o = this.indexes[s], l = i(this.nodes[o], o), l !== !1); )
          this.indexes[s] += 1;
        return delete this.indexes[s], l;
      }
    }
    walk(i) {
      return this.each((s, o) => {
        let l = i(s, o);
        return l !== !1 && s.walk && (l = s.walk(i)), l;
      });
    }
    walkType(i, s) {
      if (!i || !s)
        throw new Error("Parameters {type} and {callback} are required.");
      let o = typeof i == "function";
      return this.walk((l, u) => {
        if (o && l instanceof i || !o && l.type === i)
          return s.call(this, l, u);
      });
    }
    append(i) {
      return i.parent = this, this.nodes.push(i), this;
    }
    prepend(i) {
      return i.parent = this, this.nodes.unshift(i), this;
    }
    cleanRaws(i) {
      if (super.cleanRaws(i), this.nodes)
        for (let s of this.nodes)
          s.cleanRaws(i);
    }
    insertAfter(i, s) {
      let o = this.index(i), l;
      this.nodes.splice(o + 1, 0, s);
      for (let u in this.indexes)
        l = this.indexes[u], o <= l && (this.indexes[u] = l + this.nodes.length);
      return this;
    }
    insertBefore(i, s) {
      let o = this.index(i), l;
      this.nodes.splice(o, 0, s);
      for (let u in this.indexes)
        l = this.indexes[u], o <= l && (this.indexes[u] = l + this.nodes.length);
      return this;
    }
    removeChild(i) {
      i = this.index(i), this.nodes[i].parent = void 0, this.nodes.splice(i, 1);
      let s;
      for (let o in this.indexes)
        s = this.indexes[o], s >= i && (this.indexes[o] = s - 1);
      return this;
    }
    removeAll() {
      for (let i of this.nodes)
        i.parent = void 0;
      return this.nodes = [], this;
    }
    every(i) {
      return this.nodes.every(i);
    }
    some(i) {
      return this.nodes.some(i);
    }
    index(i) {
      return typeof i == "number" ? i : this.nodes.indexOf(i);
    }
    get first() {
      if (this.nodes)
        return this.nodes[0];
    }
    get last() {
      if (this.nodes)
        return this.nodes[this.nodes.length - 1];
    }
    toString() {
      let i = this.nodes.map(String).join("");
      return this.value && (i = this.value + i), this.raws.before && (i = this.raws.before + i), this.raws.after && (i += this.raws.after), i;
    }
  };
  n.registerWalker = (i) => {
    let s = "walk" + i.name;
    s.lastIndexOf("s") !== s.length - 1 && (s += "s"), !n.prototype[s] && (n.prototype[s] = function(o) {
      return this.walkType(i, o);
    });
  }, e.exports = n;
}), f8 = re((t, e) => {
  var r = Cr();
  e.exports = class extends r {
    constructor(n) {
      super(n), this.type = "root";
    }
  };
}), m8 = re((t, e) => {
  var r = Cr();
  e.exports = class extends r {
    constructor(n) {
      super(n), this.type = "value", this.unbalanced = 0;
    }
  };
}), g8 = re((t, e) => {
  var r = Cr(), n = class extends r {
    constructor(i) {
      super(i), this.type = "atword";
    }
    toString() {
      return this.quoted && this.raws.quote, [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
    }
  };
  r.registerWalker(n), e.exports = n;
}), y8 = re((t, e) => {
  var r = Cr(), n = In(), i = class extends n {
    constructor(s) {
      super(s), this.type = "colon";
    }
  };
  r.registerWalker(i), e.exports = i;
}), D8 = re((t, e) => {
  var r = Cr(), n = In(), i = class extends n {
    constructor(s) {
      super(s), this.type = "comma";
    }
  };
  r.registerWalker(i), e.exports = i;
}), x8 = re((t, e) => {
  var r = Cr(), n = In(), i = class extends n {
    constructor(s) {
      super(s), this.type = "comment", this.inline = Object(s).inline || !1;
    }
    toString() {
      return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
    }
  };
  r.registerWalker(i), e.exports = i;
}), b8 = re((t, e) => {
  var r = Cr(), n = class extends r {
    constructor(i) {
      super(i), this.type = "func", this.unbalanced = -1;
    }
  };
  r.registerWalker(n), e.exports = n;
}), v8 = re((t, e) => {
  var r = Cr(), n = In(), i = class extends n {
    constructor(s) {
      super(s), this.type = "number", this.unit = Object(s).unit || "";
    }
    toString() {
      return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
    }
  };
  r.registerWalker(i), e.exports = i;
}), C8 = re((t, e) => {
  var r = Cr(), n = In(), i = class extends n {
    constructor(s) {
      super(s), this.type = "operator";
    }
  };
  r.registerWalker(i), e.exports = i;
}), A8 = re((t, e) => {
  var r = Cr(), n = In(), i = class extends n {
    constructor(s) {
      super(s), this.type = "paren", this.parenType = "";
    }
  };
  r.registerWalker(i), e.exports = i;
}), E8 = re((t, e) => {
  var r = Cr(), n = In(), i = class extends n {
    constructor(s) {
      super(s), this.type = "string";
    }
    toString() {
      let s = this.quoted ? this.raws.quote : "";
      return [this.raws.before, s, this.value + "", s, this.raws.after].join("");
    }
  };
  r.registerWalker(i), e.exports = i;
}), w8 = re((t, e) => {
  var r = Cr(), n = In(), i = class extends n {
    constructor(s) {
      super(s), this.type = "word";
    }
  };
  r.registerWalker(i), e.exports = i;
}), S8 = re((t, e) => {
  var r = Cr(), n = In(), i = class extends n {
    constructor(s) {
      super(s), this.type = "unicode-range";
    }
  };
  r.registerWalker(i), e.exports = i;
}), T8 = re((t, e) => {
  var r = class extends Error {
    constructor(n) {
      super(n), this.name = this.constructor.name, this.message = n || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(n).stack;
    }
  };
  e.exports = r;
}), k8 = re((t, e) => {
  var r = /[ \n\t\r\{\(\)'"\\;,/]/g, n = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, i = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, s = /^[a-z0-9]/i, o = /^[a-f0-9?\-]/i, l = T8();
  e.exports = function(u, h) {
    h = h || {};
    let p = [], d = u.valueOf(), m = d.length, y = -1, D = 1, b = 0, C = 0, A = null, x, E, k, w, T, P, M, N, L, j, X;
    function Q($) {
      let U = `Unclosed ${$} at line: ${D}, column: ${b - y}, token: ${b}`;
      throw new l(U);
    }
    for (; b < m; ) {
      switch (x = d.charCodeAt(b), x === 10 && (y = b, D += 1), x) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12:
          E = b;
          do
            E += 1, x = d.charCodeAt(E), x === 10 && (y = E, D += 1);
          while (x === 32 || x === 10 || x === 9 || x === 13 || x === 12);
          p.push(["space", d.slice(b, E), D, b - y, D, E - y, b]), b = E - 1;
          break;
        case 58:
          E = b + 1, p.push(["colon", d.slice(b, E), D, b - y, D, E - y, b]), b = E - 1;
          break;
        case 44:
          E = b + 1, p.push(["comma", d.slice(b, E), D, b - y, D, E - y, b]), b = E - 1;
          break;
        case 123:
          p.push(["{", "{", D, b - y, D, E - y, b]);
          break;
        case 125:
          p.push(["}", "}", D, b - y, D, E - y, b]);
          break;
        case 40:
          C++, A = !A && C === 1 && p.length > 0 && p[p.length - 1][0] === "word" && p[p.length - 1][1] === "url", p.push(["(", "(", D, b - y, D, E - y, b]);
          break;
        case 41:
          C--, A = A && C > 0, p.push([")", ")", D, b - y, D, E - y, b]);
          break;
        case 39:
        case 34:
          k = x === 39 ? "'" : '"', E = b;
          do
            for (L = !1, E = d.indexOf(k, E + 1), E === -1 && Q("quote"), j = E; d.charCodeAt(j - 1) === 92; )
              j -= 1, L = !L;
          while (L);
          p.push(["string", d.slice(b, E + 1), D, b - y, D, E - y, b]), b = E;
          break;
        case 64:
          r.lastIndex = b + 1, r.test(d), r.lastIndex === 0 ? E = d.length - 1 : E = r.lastIndex - 2, p.push(["atword", d.slice(b, E + 1), D, b - y, D, E - y, b]), b = E;
          break;
        case 92:
          E = b, x = d.charCodeAt(E + 1), p.push(["word", d.slice(b, E + 1), D, b - y, D, E - y, b]), b = E;
          break;
        case 43:
        case 45:
        case 42:
          if (E = b + 1, X = d.slice(b + 1, E + 1), d.slice(b - 1, b), x === 45 && X.charCodeAt(0) === 45) {
            E++, p.push(["word", d.slice(b, E), D, b - y, D, E - y, b]), b = E - 1;
            break;
          }
          p.push(["operator", d.slice(b, E), D, b - y, D, E - y, b]), b = E - 1;
          break;
        default:
          if (x === 47 && (d.charCodeAt(b + 1) === 42 || h.loose && !A && d.charCodeAt(b + 1) === 47)) {
            if (d.charCodeAt(b + 1) === 42)
              E = d.indexOf("*/", b + 2) + 1, E === 0 && Q("comment");
            else {
              let $ = d.indexOf(`
`, b + 2);
              E = $ !== -1 ? $ - 1 : m;
            }
            P = d.slice(b, E + 1), w = P.split(`
`), T = w.length - 1, T > 0 ? (M = D + T, N = E - w[T].length) : (M = D, N = y), p.push(["comment", P, D, b - y, M, E - N, b]), y = N, D = M, b = E;
          } else if (x === 35 && !s.test(d.slice(b + 1, b + 2)))
            E = b + 1, p.push(["#", d.slice(b, E), D, b - y, D, E - y, b]), b = E - 1;
          else if ((x === 117 || x === 85) && d.charCodeAt(b + 1) === 43) {
            E = b + 2;
            do
              E += 1, x = d.charCodeAt(E);
            while (E < m && o.test(d.slice(E, E + 1)));
            p.push(["unicoderange", d.slice(b, E), D, b - y, D, E - y, b]), b = E - 1;
          } else if (x === 47)
            E = b + 1, p.push(["operator", d.slice(b, E), D, b - y, D, E - y, b]), b = E - 1;
          else {
            let $ = n;
            if (x >= 48 && x <= 57 && ($ = i), $.lastIndex = b + 1, $.test(d), $.lastIndex === 0 ? E = d.length - 1 : E = $.lastIndex - 2, $ === i || x === 46) {
              let U = d.charCodeAt(E), H = d.charCodeAt(E + 1), Z = d.charCodeAt(E + 2);
              (U === 101 || U === 69) && (H === 45 || H === 43) && Z >= 48 && Z <= 57 && (i.lastIndex = E + 2, i.test(d), i.lastIndex === 0 ? E = d.length - 1 : E = i.lastIndex - 2);
            }
            p.push(["word", d.slice(b, E + 1), D, b - y, D, E - y, b]), b = E;
          }
          break;
      }
      b++;
    }
    return p;
  };
}), F8 = re((t, e) => {
  var r = class extends Error {
    constructor(n) {
      super(n), this.name = this.constructor.name, this.message = n || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(n).stack;
    }
  };
  e.exports = r;
}), P8 = re((t, e) => {
  var r = f8(), n = m8(), i = g8(), s = y8(), o = D8(), l = x8(), u = b8(), h = v8(), p = C8(), d = A8(), m = E8(), y = w8(), D = S8(), b = k8(), C = _2(), A = $2(), x = R2(), E = F8();
  function k(w) {
    return w.sort((T, P) => T - P);
  }
  e.exports = class {
    constructor(w, T) {
      let P = { loose: !1 };
      this.cache = [], this.input = w, this.options = Object.assign({}, P, T), this.position = 0, this.unbalanced = 0, this.root = new r();
      let M = new n();
      this.root.append(M), this.current = M, this.tokens = b(w, this.options);
    }
    parse() {
      return this.loop();
    }
    colon() {
      let w = this.currToken;
      this.newNode(new s({ value: w[1], source: { start: { line: w[2], column: w[3] }, end: { line: w[4], column: w[5] } }, sourceIndex: w[6] })), this.position++;
    }
    comma() {
      let w = this.currToken;
      this.newNode(new o({ value: w[1], source: { start: { line: w[2], column: w[3] }, end: { line: w[4], column: w[5] } }, sourceIndex: w[6] })), this.position++;
    }
    comment() {
      let w = !1, T = this.currToken[1].replace(/\/\*|\*\//g, ""), P;
      this.options.loose && T.startsWith("//") && (T = T.substring(2), w = !0), P = new l({ value: T, inline: w, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] }), this.newNode(P), this.position++;
    }
    error(w, T) {
      throw new E(w + ` at line: ${T[2]}, column ${T[3]}`);
    }
    loop() {
      for (; this.position < this.tokens.length; )
        this.parseTokens();
      return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
    }
    operator() {
      let w = this.currToken[1], T;
      if (w === "+" || w === "-") {
        if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? this.prevToken[0] !== "space" && this.prevToken[0] !== "(" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "word" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(" && this.error("Syntax Error", this.currToken) : (this.nextToken[0] === "space" || this.nextToken[0] === "operator" || this.prevToken[0] === "operator") && this.error("Syntax Error", this.currToken)), this.options.loose) {
          if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word")
            return this.word();
        } else if (this.nextToken[0] === "word")
          return this.word();
      }
      return T = new p({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), this.position++, this.newNode(T);
    }
    parseTokens() {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "colon":
          this.colon();
          break;
        case "comma":
          this.comma();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parenOpen();
          break;
        case ")":
          this.parenClose();
          break;
        case "atword":
        case "word":
          this.word();
          break;
        case "operator":
          this.operator();
          break;
        case "string":
          this.string();
          break;
        case "unicoderange":
          this.unicodeRange();
          break;
        default:
          this.word();
          break;
      }
    }
    parenOpen() {
      let w = 1, T = this.position + 1, P = this.currToken, M;
      for (; T < this.tokens.length && w; ) {
        let N = this.tokens[T];
        N[0] === "(" && w++, N[0] === ")" && w--, T++;
      }
      if (w && this.error("Expected closing parenthesis", P), M = this.current.last, M && M.type === "func" && M.unbalanced < 0 && (M.unbalanced = 0, this.current = M), this.current.unbalanced++, this.newNode(new d({ value: P[1], source: { start: { line: P[2], column: P[3] }, end: { line: P[4], column: P[5] } }, sourceIndex: P[6] })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
        let N = this.nextToken, L = this.currToken[1], j = { line: this.currToken[2], column: this.currToken[3] };
        for (; N && N[0] !== ")" && this.current.unbalanced; )
          this.position++, L += this.currToken[1], N = this.nextToken;
        this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new y({ value: L, source: { start: j, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
      }
    }
    parenClose() {
      let w = this.currToken;
      this.newNode(new d({ value: w[1], source: { start: { line: w[2], column: w[3] }, end: { line: w[4], column: w[5] } }, sourceIndex: w[6] })), this.position++, !(this.position >= this.tokens.length - 1 && !this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", w), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
    }
    space() {
      let w = this.currToken;
      this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += w[1], this.position++) : (this.spaces = w[1], this.position++);
    }
    unicodeRange() {
      let w = this.currToken;
      this.newNode(new D({ value: w[1], source: { start: { line: w[2], column: w[3] }, end: { line: w[4], column: w[5] } }, sourceIndex: w[6] })), this.position++;
    }
    splitWord() {
      let w = this.nextToken, T = this.currToken[1], P = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/, M = /^(?!\#([a-z0-9]+))[\#\{\}]/gi, N, L;
      if (!M.test(T))
        for (; w && w[0] === "word"; ) {
          this.position++;
          let j = this.currToken[1];
          T += j, w = this.nextToken;
        }
      N = A(T, "@"), L = k(x(C([[0], N]))), L.forEach((j, X) => {
        let Q = L[X + 1] || T.length, $ = T.slice(j, Q), U;
        if (~N.indexOf(j))
          U = new i({ value: $.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + j }, end: { line: this.currToken[4], column: this.currToken[3] + (Q - 1) } }, sourceIndex: this.currToken[6] + L[X] });
        else if (P.test(this.currToken[1])) {
          let H = $.replace(P, "");
          U = new h({ value: $.replace(H, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + j }, end: { line: this.currToken[4], column: this.currToken[3] + (Q - 1) } }, sourceIndex: this.currToken[6] + L[X], unit: H });
        } else
          U = new (w && w[0] === "(" ? u : y)({ value: $, source: { start: { line: this.currToken[2], column: this.currToken[3] + j }, end: { line: this.currToken[4], column: this.currToken[3] + (Q - 1) } }, sourceIndex: this.currToken[6] + L[X] }), U.type === "word" ? (U.isHex = /^#(.+)/.test($), U.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test($)) : this.cache.push(this.current);
        this.newNode(U);
      }), this.position++;
    }
    string() {
      let w = this.currToken, T = this.currToken[1], P = /^(\"|\')/, M = P.test(T), N = "", L;
      M && (N = T.match(P)[0], T = T.slice(1, T.length - 1)), L = new m({ value: T, source: { start: { line: w[2], column: w[3] }, end: { line: w[4], column: w[5] } }, sourceIndex: w[6], quoted: M }), L.raws.quote = N, this.newNode(L), this.position++;
    }
    word() {
      return this.splitWord();
    }
    newNode(w) {
      return this.spaces && (w.raws.before += this.spaces, this.spaces = ""), this.current.append(w);
    }
    get currToken() {
      return this.tokens[this.position];
    }
    get nextToken() {
      return this.tokens[this.position + 1];
    }
    get prevToken() {
      return this.tokens[this.position - 1];
    }
  };
}), j2 = {};
E2(j2, { languages: () => CO, options: () => wO, parsers: () => gb, printers: () => sL });
var B8 = (t, e, r, n) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
}, wt = B8, q2 = "string", W2 = "array", U2 = "cursor", bm = "indent", vm = "align", H2 = "trim", Cm = "group", ja = "fill", sh = "if-break", V2 = "indent-if-break", z2 = "line-suffix", J2 = "line-suffix-boundary", Io = "line", K2 = "label", Am = "break-parent", G2 = /* @__PURE__ */ new Set([U2, bm, vm, H2, Cm, ja, sh, V2, z2, J2, Io, K2, Am]);
function I8(t) {
  if (typeof t == "string")
    return q2;
  if (Array.isArray(t))
    return W2;
  if (!t)
    return;
  let { type: e } = t;
  if (G2.has(e))
    return e;
}
var X2 = I8, N8 = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function M8(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (X2(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = N8([...G2].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`;
}
var O8 = class extends Error {
  constructor(r) {
    super(M8(r));
    Vr(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, L8 = O8, _8 = () => {
}, $8 = _8;
function ur(t) {
  return { type: bm, contents: t };
}
function Y2(t, e) {
  return { type: vm, contents: e, n: t };
}
function kr(t, e = {}) {
  return $8(e.expandedStates), { type: Cm, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function R8(t) {
  return Y2({ type: "root" }, t);
}
function Qu(t) {
  return Y2(-1, t);
}
function sd(t) {
  return { type: ja, parts: t };
}
function Q2(t, e = "", r = {}) {
  return { type: sh, breakContents: t, flatContents: e, groupId: r.groupId };
}
var Em = { type: Am }, j8 = { type: Io, hard: !0 }, Vt = { type: Io }, Kr = { type: Io, soft: !0 }, at = [j8, Em];
function ns(t, e) {
  let r = [];
  for (let n = 0; n < e.length; n++)
    n !== 0 && r.push(t), r.push(e[n]);
  return r;
}
var q8 = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, qa = q8, W8 = (t) => {
  if (Array.isArray(t))
    return t;
  if (t.type !== ja)
    throw new Error(`Expect doc to be 'array' or '${ja}'.`);
  return t.parts;
};
function U8(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return n(t);
  function n(s) {
    if (r.has(s))
      return r.get(s);
    let o = i(s);
    return r.set(s, o), o;
  }
  function i(s) {
    switch (X2(s)) {
      case W2:
        return e(s.map(n));
      case ja:
        return e({ ...s, parts: s.parts.map(n) });
      case sh:
        return e({ ...s, breakContents: n(s.breakContents), flatContents: n(s.flatContents) });
      case Cm: {
        let { expandedStates: o, contents: l } = s;
        return o ? (o = o.map(n), l = o[0]) : l = n(l), e({ ...s, contents: l, expandedStates: o });
      }
      case vm:
      case bm:
      case V2:
      case K2:
      case z2:
        return e({ ...s, contents: n(s.contents) });
      case q2:
      case U2:
      case H2:
      case J2:
      case Io:
      case Am:
        return e(s);
      default:
        throw new L8(s);
    }
  }
}
function H8(t) {
  return t.type === Io && !t.hard ? t.soft ? "" : " " : t.type === sh ? t.flatContents : t;
}
function V8(t) {
  return U8(t, H8);
}
function z8(t) {
  return Array.isArray(t) && t.length > 0;
}
var oh = z8, Kl = "'", a0 = '"';
function J8(t, e) {
  let r = e === !0 || e === Kl ? Kl : a0, n = r === Kl ? a0 : Kl, i = 0, s = 0;
  for (let o of t)
    o === r ? i++ : o === n && s++;
  return i > s ? n : r;
}
var K8 = J8;
function G8(t, e, r) {
  let n = e === '"' ? "'" : '"', i = wt(!1, t, /\\(.)|(["'])/gs, (s, o, l) => o === n ? o : l === e ? "\\" + l : l || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o) ? o : "\\" + o));
  return e + i + e;
}
var X8 = G8;
function Y8(t, e) {
  let r = t.slice(1, -1), n = e.parser === "json" || e.parser === "jsonc" || e.parser === "json5" && e.quoteProps === "preserve" && !e.singleQuote ? '"' : e.__isInHtmlAttribute ? "'" : K8(r, e.singleQuote);
  return X8(r, n, !(e.parser === "css" || e.parser === "less" || e.parser === "scss" || e.__embeddedInHtml));
}
var Z2 = Y8, Q8 = class extends Error {
  constructor(r, n, i = "type") {
    super(`Unexpected ${n} node ${i}: ${JSON.stringify(r[i])}.`);
    Vr(this, "name", "UnexpectedNodeError");
    this.node = r;
  }
}, Z8 = Q8;
function eM(t) {
  return (t == null ? void 0 : t.type) === "front-matter";
}
var Zu = eM, tM = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma", "spaces"]);
function eb(t, e, r) {
  if (Zu(t) && t.lang === "yaml" && delete e.value, t.type === "css-comment" && r.type === "css-root" && r.nodes.length > 0 && ((r.nodes[0] === t || Zu(r.nodes[0]) && r.nodes[1] === t) && (delete e.text, /^\*\s*@(?:format|prettier)\s*$/.test(t.text)) || r.type === "css-root" && qa(!1, r.nodes, -1) === t))
    return null;
  if (t.type === "value-root" && delete e.text, (t.type === "media-query" || t.type === "media-query-list" || t.type === "media-feature-expression") && delete e.value, t.type === "css-rule" && delete e.params, t.type === "selector-combinator" && (e.value = wt(!1, e.value, /\s+/g, " ")), t.type === "media-feature" && (e.value = wt(!1, e.value, " ", "")), (t.type === "value-word" && (t.isColor && t.isHex || ["initial", "inherit", "unset", "revert"].includes(e.value.toLowerCase())) || t.type === "media-feature" || t.type === "selector-root-invalid" || t.type === "selector-pseudo") && (e.value = e.value.toLowerCase()), t.type === "css-decl" && (e.prop = e.prop.toLowerCase()), (t.type === "css-atrule" || t.type === "css-import") && (e.name = e.name.toLowerCase()), t.type === "value-number" && (e.unit = e.unit.toLowerCase()), t.type === "value-unknown" && (e.value = wt(!1, e.value, /;$/g, "")), (t.type === "media-feature" || t.type === "media-keyword" || t.type === "media-type" || t.type === "media-unknown" || t.type === "media-url" || t.type === "media-value" || t.type === "selector-attribute" || t.type === "selector-string" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "value-string") && e.value && (e.value = rM(e.value)), t.type === "selector-attribute" && (e.attribute = e.attribute.trim(), e.namespace && typeof e.namespace == "string" && (e.namespace = e.namespace.trim(), e.namespace.length === 0 && (e.namespace = !0)), e.value && (e.value = wt(!1, e.value.trim(), /^["']|["']$/g, ""), delete e.quoted)), (t.type === "media-value" || t.type === "media-type" || t.type === "value-number" || t.type === "selector-root-invalid" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "selector-tag") && e.value && (e.value = wt(!1, e.value, /([\d+.e-]+)([a-z]*)/gi, (n, i, s) => {
    let o = Number(i);
    return Number.isNaN(o) ? n : o + s.toLowerCase();
  })), t.type === "selector-tag") {
    let n = t.value.toLowerCase();
    ["from", "to"].includes(n) && (e.value = n);
  }
  if (t.type === "css-atrule" && t.name.toLowerCase() === "supports" && delete e.value, t.type === "selector-unknown" && delete e.value, t.type === "value-comma_group") {
    let n = t.groups.findIndex((i) => i.type === "value-number" && i.unit === "...");
    n !== -1 && (e.groups[n].unit = "", e.groups.splice(n + 1, 0, { type: "value-word", value: "...", isColor: !1, isHex: !1 }));
  }
  if (t.type === "value-comma_group" && t.groups.some((n) => n.type === "value-atword" && n.value.endsWith("[") || n.type === "value-word" && n.value.startsWith("]")))
    return { type: "value-atword", value: t.groups.map((n) => n.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
}
eb.ignoredProperties = tM;
function rM(t) {
  return wt(!1, wt(!1, t, "'", '"'), /\\([^\da-f])/gi, "$1");
}
var nM = eb;
async function iM(t, e) {
  if (t.lang === "yaml") {
    let r = t.value.trim(), n = r ? await e(r, { parser: "yaml" }) : "";
    return R8([t.startDelimiter, at, n, n ? at : "", t.endDelimiter]);
  }
}
var sM = iM;
function tb(t) {
  let { node: e } = t;
  if (e.type === "front-matter")
    return async (r) => {
      let n = await sM(e, r);
      return n ? [n, at] : void 0;
    };
}
tb.getVisitorKeys = (t) => t.type === "css-root" ? ["frontMatter"] : [];
var oM = tb, ea = null;
function Sa(t) {
  if (ea !== null && typeof ea.property) {
    let e = ea;
    return ea = Sa.prototype = null, e;
  }
  return ea = Sa.prototype = t ?? /* @__PURE__ */ Object.create(null), new Sa();
}
var aM = 10;
for (let t = 0; t <= aM; t++)
  Sa();
function lM(t) {
  return Sa(t);
}
function uM(t, e = "type") {
  lM(t);
  function r(n) {
    let i = n[e], s = t[i];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: n });
    return s;
  }
  return r;
}
var cM = uM, hM = { "front-matter": [], "css-root": ["frontMatter", "nodes"], "css-comment": [], "css-rule": ["selector", "nodes"], "css-decl": ["value", "selector", "nodes"], "css-atrule": ["selector", "params", "value", "nodes"], "media-query-list": ["nodes"], "media-query": ["nodes"], "media-type": [], "media-feature-expression": ["nodes"], "media-feature": [], "media-colon": [], "media-value": [], "media-keyword": [], "media-url": [], "media-unknown": [], "selector-root": ["nodes"], "selector-selector": ["nodes"], "selector-comment": [], "selector-string": [], "selector-tag": [], "selector-id": [], "selector-class": [], "selector-attribute": [], "selector-combinator": ["nodes"], "selector-universal": [], "selector-pseudo": ["nodes"], "selector-nesting": [], "selector-unknown": [], "value-value": ["group"], "value-root": ["group"], "value-comment": [], "value-comma_group": ["groups"], "value-paren_group": ["open", "groups", "close"], "value-func": ["group"], "value-paren": [], "value-number": [], "value-operator": [], "value-word": [], "value-colon": [], "value-comma": [], "value-string": [], "value-atword": [], "value-unicode-range": [], "value-unknown": [] }, pM = hM, dM = cM(pM), fM = dM;
function mM(t, e) {
  let r = 0;
  for (let n = 0; n < t.line - 1; ++n)
    r = e.indexOf(`
`, r) + 1;
  return r + t.column;
}
var rb = mM;
function wm(t) {
  return (e, r, n) => {
    let i = !!(n != null && n.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, o = r;
    for (; o >= 0 && o < s; ) {
      let l = e.charAt(o);
      if (t instanceof RegExp) {
        if (!t.test(l))
          return o;
      } else if (!t.includes(l))
        return o;
      i ? o-- : o++;
    }
    return o === -1 || o === s ? o : !1;
  };
}
var nb = wm(" 	"), gM = wm(",; 	"), ib = wm(/[^\n\r]/);
function sb(t, e) {
  var r, n, i;
  if (typeof ((n = (r = t.source) == null ? void 0 : r.start) == null ? void 0 : n.offset) == "number")
    return t.source.start.offset;
  if (typeof t.sourceIndex == "number")
    return t.sourceIndex;
  if ((i = t.source) != null && i.start)
    return rb(t.source.start, e);
  throw Object.assign(new Error("Can not locate node."), { node: t });
}
function Sm(t, e) {
  var r, n;
  if (t.type === "css-comment" && t.inline)
    return ib(e, t.source.startOffset);
  if (typeof ((n = (r = t.source) == null ? void 0 : r.end) == null ? void 0 : n.offset) == "number")
    return t.source.end.offset;
  if (t.source) {
    if (t.source.end)
      return rb(t.source.end, e);
    if (oh(t.nodes))
      return Sm(qa(!1, t.nodes, -1), e);
  }
  return null;
}
function ob(t, e) {
  t.source && (t.source.startOffset = sb(t, e), t.source.endOffset = Sm(t, e));
  for (let r in t) {
    let n = t[r];
    r === "source" || !n || typeof n != "object" || (n.type === "value-root" || n.type === "value-unknown" ? ab(n, yM(t), n.text || n.value) : ob(n, e));
  }
}
function ab(t, e, r) {
  t.source && (t.source.startOffset = sb(t, r) + e, t.source.endOffset = Sm(t, r) + e);
  for (let n in t) {
    let i = t[n];
    n === "source" || !i || typeof i != "object" || ab(i, e, r);
  }
}
function yM(t) {
  var e;
  let r = t.source.startOffset;
  return typeof t.prop == "string" && (r += t.prop.length), t.type === "css-atrule" && typeof t.name == "string" && (r += 1 + t.name.length + t.raws.afterName.match(/^\s*:?\s*/)[0].length), t.type !== "css-atrule" && typeof ((e = t.raws) == null ? void 0 : e.between) == "string" && (r += t.raws.between.length), r;
}
function DM(t) {
  let e = "initial", r = "initial", n, i = !1, s = [];
  for (let o = 0; o < t.length; o++) {
    let l = t[o];
    switch (e) {
      case "initial":
        if (l === "'") {
          e = "single-quotes";
          continue;
        }
        if (l === '"') {
          e = "double-quotes";
          continue;
        }
        if ((l === "u" || l === "U") && t.slice(o, o + 4).toLowerCase() === "url(") {
          e = "url", o += 3;
          continue;
        }
        if (l === "*" && t[o - 1] === "/") {
          e = "comment-block";
          continue;
        }
        if (l === "/" && t[o - 1] === "/") {
          e = "comment-inline", n = o - 1;
          continue;
        }
        continue;
      case "single-quotes":
        if (l === "'" && t[o - 1] !== "\\" && (e = r, r = "initial"), l === `
` || l === "\r")
          return t;
        continue;
      case "double-quotes":
        if (l === '"' && t[o - 1] !== "\\" && (e = r, r = "initial"), l === `
` || l === "\r")
          return t;
        continue;
      case "url":
        if (l === ")" && (e = "initial"), l === `
` || l === "\r")
          return t;
        if (l === "'") {
          e = "single-quotes", r = "url";
          continue;
        }
        if (l === '"') {
          e = "double-quotes", r = "url";
          continue;
        }
        continue;
      case "comment-block":
        l === "/" && t[o - 1] === "*" && (e = "initial");
        continue;
      case "comment-inline":
        (l === '"' || l === "'" || l === "*") && (i = !0), (l === `
` || l === "\r") && (i && s.push([n, o]), e = "initial", i = !1);
        continue;
    }
  }
  for (let [o, l] of s)
    t = t.slice(0, o) + wt(!1, t.slice(o, l), /["'*]/g, " ") + t.slice(l);
  return t;
}
function fr(t) {
  var e;
  return (e = t.source) == null ? void 0 : e.startOffset;
}
function pr(t) {
  var e;
  return (e = t.source) == null ? void 0 : e.endOffset;
}
var ec = Ts(BN(), 1);
function xM(t) {
  if (!t.startsWith("#!"))
    return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var bM = xM;
function lb(t) {
  let e = bM(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, ec.extract)(t), { pragmas: n, comments: i } = (0, ec.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: n, comments: i };
}
function vM(t) {
  let { pragmas: e } = lb(t);
  return Object.prototype.hasOwnProperty.call(e, "prettier") || Object.prototype.hasOwnProperty.call(e, "format");
}
function CM(t) {
  let { shebang: e, text: r, pragmas: n, comments: i } = lb(t), s = (0, ec.strip)(r), o = (0, ec.print)({ pragmas: { format: "", ...n }, comments: i.trimStart() });
  return (e ? `${e}
` : "") + o + (s.startsWith(`
`) ? `
` : `

`) + s;
}
var AM = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
function EM(t) {
  let e = t.match(AM);
  if (!e)
    return { content: t };
  let { startDelimiter: r, language: n, value: i = "", endDelimiter: s } = e.groups, o = n.trim() || "yaml";
  if (r === "+++" && (o = "toml"), o !== "yaml" && r !== s)
    return { content: t };
  let [l] = e;
  return { frontMatter: { type: "front-matter", lang: o, value: i, startDelimiter: r, endDelimiter: s, raw: l.replace(/\n$/, "") }, content: wt(!1, l, /[^\n]/g, " ") + t.slice(l.length) };
}
var Tm = EM;
function wM(t) {
  return vM(Tm(t).content);
}
function SM(t) {
  let { frontMatter: e, content: r } = Tm(t);
  return (e ? e.raw + `

` : "") + CM(r);
}
var TM = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
function kM(t) {
  var e, r;
  return (r = (e = t.findAncestor((n) => n.type === "css-decl")) == null ? void 0 : e.prop) == null ? void 0 : r.toLowerCase();
}
var FM = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
function PM(t) {
  return FM.has(t.toLowerCase());
}
function BM(t, e) {
  var r;
  let n = t.findAncestor((i) => i.type === "css-atrule");
  return ((r = n == null ? void 0 : n.name) == null ? void 0 : r.toLowerCase().endsWith("keyframes")) && ["from", "to"].includes(e.toLowerCase());
}
function Ks(t) {
  return t.includes("$") || t.includes("@") || t.includes("#") || t.startsWith("%") || t.startsWith("--") || t.startsWith(":--") || t.includes("(") && t.includes(")") ? t : t.toLowerCase();
}
function Bu(t, e) {
  var r;
  let n = t.findAncestor((i) => i.type === "value-func");
  return ((r = n == null ? void 0 : n.value) == null ? void 0 : r.toLowerCase()) === e;
}
function IM(t) {
  var e;
  let r = t.findAncestor((i) => i.type === "css-rule"), n = (e = r == null ? void 0 : r.raws) == null ? void 0 : e.selector;
  return n && (n.startsWith(":import") || n.startsWith(":export"));
}
function Iu(t, e) {
  let r = Array.isArray(e) ? e : [e], n = t.findAncestor((i) => i.type === "css-atrule");
  return n && r.includes(n.name.toLowerCase());
}
function NM(t) {
  var e;
  let { node: r } = t;
  return r.groups[0].value === "url" && r.groups.length === 2 && ((e = t.findAncestor((n) => n.type === "css-atrule")) == null ? void 0 : e.name) === "import";
}
function MM(t) {
  return t.type === "value-func" && t.value.toLowerCase() === "url";
}
function OM(t) {
  return t.type === "value-func" && t.value.toLowerCase() === "var";
}
function rp(t, e) {
  var r;
  let n = (r = t.parent) == null ? void 0 : r.nodes;
  return n && n.indexOf(e) === n.length - 1;
}
function LM(t) {
  let { selector: e } = t;
  return e ? typeof e == "string" && /^@.+:.*$/.test(e) || e.value && /^@.+:.*$/.test(e.value) : !1;
}
function _M(t) {
  return t.type === "value-word" && ["from", "through", "end"].includes(t.value);
}
function $M(t) {
  return t.type === "value-word" && ["and", "or", "not"].includes(t.value);
}
function RM(t) {
  return t.type === "value-word" && t.value === "in";
}
function od(t) {
  return t.type === "value-operator" && t.value === "*";
}
function Nu(t) {
  return t.type === "value-operator" && t.value === "/";
}
function di(t) {
  return t.type === "value-operator" && t.value === "+";
}
function Gs(t) {
  return t.type === "value-operator" && t.value === "-";
}
function jM(t) {
  return t.type === "value-operator" && t.value === "%";
}
function np(t) {
  return od(t) || Nu(t) || di(t) || Gs(t) || jM(t);
}
function qM(t) {
  return t.type === "value-word" && ["==", "!="].includes(t.value);
}
function WM(t) {
  return t.type === "value-word" && ["<", ">", "<=", ">="].includes(t.value);
}
function ad(t, e) {
  return e.parser === "scss" && t.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(t.name);
}
function l0(t) {
  var e;
  return ((e = t.raws) == null ? void 0 : e.params) && /^\(\s*\)$/.test(t.raws.params);
}
function ip(t) {
  return t.name.startsWith("prettier-placeholder");
}
function UM(t) {
  return t.prop.startsWith("@prettier-placeholder");
}
function HM(t, e) {
  return t.value === "$$" && t.type === "value-func" && (e == null ? void 0 : e.type) === "value-word" && !e.raws.before;
}
function VM(t) {
  var e, r;
  return ((e = t.value) == null ? void 0 : e.type) === "value-root" && ((r = t.value.group) == null ? void 0 : r.type) === "value-value" && t.prop.toLowerCase() === "composes";
}
function zM(t) {
  var e, r, n;
  return ((n = (r = (e = t.value) == null ? void 0 : e.group) == null ? void 0 : r.group) == null ? void 0 : n.type) === "value-paren_group" && t.value.group.group.open !== null && t.value.group.group.close !== null;
}
function Us(t) {
  var e;
  return ((e = t.raws) == null ? void 0 : e.before) === "";
}
function km(t) {
  var e, r;
  return t.type === "value-comma_group" && ((r = (e = t.groups) == null ? void 0 : e[1]) == null ? void 0 : r.type) === "value-colon";
}
function sp(t) {
  var e;
  return t.type === "value-paren_group" && ((e = t.groups) == null ? void 0 : e[0]) && km(t.groups[0]);
}
function ub(t, e) {
  var r;
  if (e.parser !== "scss")
    return !1;
  let { node: n } = t;
  if (n.groups.length === 0)
    return !1;
  let i = t.grandparent;
  if (!sp(n) && !(i && sp(i)))
    return !1;
  let s = t.findAncestor((o) => o.type === "css-decl");
  return !!((r = s == null ? void 0 : s.prop) != null && r.startsWith("$") || sp(i) || i.type === "value-func");
}
function u0(t) {
  return t.type === "value-comment" && t.inline;
}
function op(t) {
  return t.type === "value-word" && t.value === "#";
}
function c0(t) {
  return t.type === "value-word" && t.value === "{";
}
function ap(t) {
  return t.type === "value-word" && t.value === "}";
}
function Gl(t) {
  return ["value-word", "value-atword"].includes(t.type);
}
function ld(t) {
  return (t == null ? void 0 : t.type) === "value-colon";
}
function JM(t, e) {
  if (!km(e))
    return !1;
  let { groups: r } = e, n = r.indexOf(t);
  return n === -1 ? !1 : ld(r[n + 1]);
}
function KM(t) {
  return t.value && ["not", "and", "or"].includes(t.value.toLowerCase());
}
function GM(t) {
  return t.type !== "value-func" ? !1 : TM.has(t.value.toLowerCase());
}
function ta(t) {
  return /\/\//.test(t.split(/[\n\r]/).pop());
}
function Xl(t) {
  return (t == null ? void 0 : t.type) === "value-atword" && t.value.startsWith("prettier-placeholder-");
}
function XM(t, e) {
  var r, n;
  if (((r = t.open) == null ? void 0 : r.value) !== "(" || ((n = t.close) == null ? void 0 : n.value) !== ")" || t.groups.some((i) => i.type !== "value-comma_group"))
    return !1;
  if (e.type === "value-comma_group") {
    let i = e.groups.indexOf(t) - 1, s = e.groups[i];
    if ((s == null ? void 0 : s.type) === "value-word" && s.value === "with")
      return !0;
  }
  return !1;
}
function Yl(t) {
  var e, r;
  return t.type === "value-paren_group" && ((e = t.open) == null ? void 0 : e.value) === "(" && ((r = t.close) == null ? void 0 : r.value) === ")";
}
function YM(t, e, r) {
  var n;
  let { node: i } = t, s = t.parent, o = t.grandparent, l = kM(t), u = l && s.type === "value-value" && (l === "grid" || l.startsWith("grid-template")), h = t.findAncestor((A) => A.type === "css-atrule"), p = h && ad(h, e), d = i.groups.some((A) => u0(A)), m = t.map(r, "groups"), y = [], D = Bu(t, "url"), b = !1, C = !1;
  for (let A = 0; A < i.groups.length; ++A) {
    y.push(m[A]);
    let x = i.groups[A - 1], E = i.groups[A], k = i.groups[A + 1], w = i.groups[A + 2];
    if (D) {
      (k && di(k) || di(E)) && y.push(" ");
      continue;
    }
    if (Iu(t, "forward") && E.type === "value-word" && E.value && x !== void 0 && x.type === "value-word" && x.value === "as" && k.type === "value-operator" && k.value === "*" || !k || E.type === "value-word" && E.value.endsWith("-") && Xl(k))
      continue;
    if (E.type === "value-string" && E.quoted) {
      let j = E.value.lastIndexOf("#{"), X = E.value.lastIndexOf("}");
      j !== -1 && X !== -1 ? b = j > X : j !== -1 ? b = !0 : X !== -1 && (b = !1);
    }
    if (b || ld(E) || ld(k) || E.type === "value-atword" && (E.value === "" || E.value.endsWith("[")) || k.type === "value-word" && k.value.startsWith("]") || E.value === "~" || E.type !== "value-string" && E.value && E.value.includes("\\") && k && k.type !== "value-comment" || x != null && x.value && x.value.indexOf("\\") === x.value.length - 1 && E.type === "value-operator" && E.value === "/" || E.value === "\\" || HM(E, k) || op(E) || c0(E) || ap(k) || c0(k) && Us(k) || ap(E) && Us(k) || E.value === "--" && op(k))
      continue;
    let T = np(E), P = np(k);
    if ((T && op(k) || P && ap(E)) && Us(k) || !x && Nu(E) || Bu(t, "calc") && (di(E) || di(k) || Gs(E) || Gs(k)) && Us(k))
      continue;
    let M = (di(E) || Gs(E)) && A === 0 && (k.type === "value-number" || k.isHex) && o && GM(o) && !Us(k), N = (w == null ? void 0 : w.type) === "value-func" || w && Gl(w) || E.type === "value-func" || Gl(E), L = k.type === "value-func" || Gl(k) || (x == null ? void 0 : x.type) === "value-func" || x && Gl(x);
    if (e.parser === "scss" && T && E.value === "-" && k.type === "value-func" && pr(E) !== fr(k)) {
      y.push(" ");
      continue;
    }
    if (!(!(od(k) || od(E)) && !Bu(t, "calc") && !M && (Nu(k) && !N || Nu(E) && !L || di(k) && !N || di(E) && !L || Gs(k) || Gs(E)) && (Us(k) || T && (!x || x && np(x)))) && !((e.parser === "scss" || e.parser === "less") && T && E.value === "-" && Yl(k) && pr(E) === fr(k.open) && k.open.value === "(")) {
      if (u0(E)) {
        if (s.type === "value-paren_group") {
          y.push(Qu(at));
          continue;
        }
        y.push(at);
        continue;
      }
      if (p && (qM(k) || WM(k) || $M(k) || RM(E) || _M(E))) {
        y.push(" ");
        continue;
      }
      if (h && h.name.toLowerCase() === "namespace") {
        y.push(" ");
        continue;
      }
      if (u) {
        E.source && k.source && E.source.start.line !== k.source.start.line ? (y.push(at), C = !0) : y.push(" ");
        continue;
      }
      if (P) {
        y.push(" ");
        continue;
      }
      if ((k == null ? void 0 : k.value) !== "..." && !(Xl(E) && Xl(k) && pr(E) === fr(k))) {
        if (Xl(E) && Yl(k) && pr(E) === fr(k.open)) {
          y.push(Kr);
          continue;
        }
        if (E.value === "with" && Yl(k)) {
          y.push(" ");
          continue;
        }
        (n = E.value) != null && n.endsWith("#") && k.value === "{" && Yl(k.group) || y.push(Vt);
      }
    }
  }
  return d && y.push(Em), C && y.unshift(at), p ? kr(ur(y)) : NM(t) ? kr(sd(y)) : kr(ur(sd(y)));
}
var QM = YM;
function ZM(t) {
  return t.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
}
var eO = ZM, h0 = /* @__PURE__ */ new Map([["em", "em"], ["rem", "rem"], ["ex", "ex"], ["rex", "rex"], ["cap", "cap"], ["rcap", "rcap"], ["ch", "ch"], ["rch", "rch"], ["ic", "ic"], ["ric", "ric"], ["lh", "lh"], ["rlh", "rlh"], ["vw", "vw"], ["svw", "svw"], ["lvw", "lvw"], ["dvw", "dvw"], ["vh", "vh"], ["svh", "svh"], ["lvh", "lvh"], ["dvh", "dvh"], ["vi", "vi"], ["svi", "svi"], ["lvi", "lvi"], ["dvi", "dvi"], ["vb", "vb"], ["svb", "svb"], ["lvb", "lvb"], ["dvb", "dvb"], ["vmin", "vmin"], ["svmin", "svmin"], ["lvmin", "lvmin"], ["dvmin", "dvmin"], ["vmax", "vmax"], ["svmax", "svmax"], ["lvmax", "lvmax"], ["dvmax", "dvmax"], ["cm", "cm"], ["mm", "mm"], ["q", "Q"], ["in", "in"], ["pt", "pt"], ["pc", "pc"], ["px", "px"], ["deg", "deg"], ["grad", "grad"], ["rad", "rad"], ["turn", "turn"], ["s", "s"], ["ms", "ms"], ["hz", "Hz"], ["khz", "kHz"], ["dpi", "dpi"], ["dpcm", "dpcm"], ["dppx", "dppx"], ["x", "x"], ["cqw", "cqw"], ["cqh", "cqh"], ["cqi", "cqi"], ["cqb", "cqb"], ["cqmin", "cqmin"], ["cqmax", "cqmax"]]);
function tO(t) {
  let e = t.toLowerCase();
  return h0.has(e) ? h0.get(e) : t;
}
var cb = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, rO = /(?:\d*\.\d+|\d+\.?)(?:e[+-]?\d+)?/gi, nO = /[a-z]+/gi, iO = /[$@]?[_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/gi, sO = new RegExp(cb.source + `|(${iO.source})?(${rO.source})(${nO.source})?`, "gi");
function un(t, e) {
  return wt(!1, t, cb, (r) => Z2(r, e));
}
function oO(t, e) {
  let r = e.singleQuote ? "'" : '"';
  return t.includes('"') || t.includes("'") ? t : r + t + r;
}
function Hs(t) {
  return wt(!1, t, sO, (e, r, n, i, s) => !n && i ? hb(i) + Ks(s || "") : e);
}
function hb(t) {
  return eO(t).replace(/\.0(?=$|e)/, "");
}
function aO(t) {
  return t.trailingComma === "es5" || t.trailingComma === "all";
}
function lO(t, e, r) {
  let n = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let i = t.charAt(e);
  if (n) {
    if (t.charAt(e - 1) === "\r" && i === `
`)
      return e - 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e - 1;
  } else {
    if (i === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e + 1;
  }
  return e;
}
var pb = lO;
function uO(t, e, r = {}) {
  let n = nb(t, r.backwards ? e - 1 : e, r), i = pb(t, n, r);
  return n !== i;
}
var db = uO;
function cO(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var hO = cO;
function pO(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? ib(t, e) : e;
}
var dO = pO;
function fO(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = gM(t, n), n = hO(t, n), n = nb(t, n);
  return n = dO(t, n), n = pb(t, n), n !== !1 && db(t, n);
}
var fb = fO;
function mO({ node: t, parent: e }, r) {
  return !!(t.source && r.originalText.slice(fr(t), fr(e.close)).trimEnd().endsWith(","));
}
function gO(t, e) {
  return OM(t.grandparent) && mO(t, e) ? "," : t.node.type !== "value-comment" && !(t.node.type === "value-comma_group" && t.node.groups.every((r) => r.type === "value-comment")) && aO(e) && t.callParent(() => ub(t, e)) ? Q2(",") : "";
}
function yO(t, e, r) {
  let { node: n, parent: i } = t, s = t.map(({ node: y }) => typeof y == "string" ? y : r(), "groups");
  if (i && MM(i) && (n.groups.length === 1 || n.groups.length > 0 && n.groups[0].type === "value-comma_group" && n.groups[0].groups.length > 0 && n.groups[0].groups[0].type === "value-word" && n.groups[0].groups[0].value.startsWith("data:")))
    return [n.open ? r("open") : "", ns(",", s), n.close ? r("close") : ""];
  if (!n.open) {
    let y = mb(t), D = ns([",", y ? at : Vt], s);
    return ur(y ? [at, D] : kr(sd(D)));
  }
  let o = t.map(({ node: y, isLast: D, index: b }) => {
    var C;
    let A = s[b];
    if (km(y) && y.type === "value-comma_group" && y.groups && y.groups[0].type !== "value-paren_group" && ((C = y.groups[2]) == null ? void 0 : C.type) === "value-paren_group") {
      let E = W8(A.contents.contents);
      E[1] = kr(E[1]), A = kr(Qu(A));
    }
    let x = [A, D ? gO(t, e) : ","];
    if (!D && y.type === "value-comma_group" && oh(y.groups)) {
      let E = qa(!1, y.groups, -1);
      !E.source && E.close && (E = E.close), E.source && fb(e.originalText, pr(E)) && x.push(at);
    }
    return x;
  }, "groups"), l = JM(n, i), u = XM(n, i), h = ub(t, e), p = u || h && !l, d = u || l, m = kr([n.open ? r("open") : "", ur([Kr, ns(Vt, o)]), Kr, n.close ? r("close") : ""], { shouldBreak: p });
  return d ? Qu(m) : m;
}
function mb(t) {
  return t.match((e) => e.type === "value-paren_group" && !e.open && e.groups.some((r) => r.type === "value-comma_group"), (e, r) => r === "group" && e.type === "value-value", (e, r) => r === "group" && e.type === "value-root", (e, r) => r === "value" && (e.type === "css-decl" && !e.prop.startsWith("--") || e.type === "css-atrule" && e.variable));
}
function DO(t, e, r) {
  let n = [];
  return t.each(() => {
    let { node: i, previous: s } = t;
    if ((s == null ? void 0 : s.type) === "css-comment" && s.text.trim() === "prettier-ignore" ? n.push(e.originalText.slice(fr(i), pr(i))) : n.push(r()), t.isLast)
      return;
    let { next: o } = t;
    o.type === "css-comment" && !db(e.originalText, fr(o), { backwards: !0 }) && !Zu(i) || o.type === "css-atrule" && o.name === "else" && i.type !== "css-comment" ? n.push(" ") : (n.push(e.__isHTMLStyleAttribute ? Vt : at), fb(e.originalText, pr(i)) && !Zu(i) && n.push(at));
  }, "nodes"), n;
}
var ra = DO;
function xO(t, e, r) {
  var n, i, s, o, l, u;
  let { node: h } = t;
  switch (h.type) {
    case "front-matter":
      return [h.raw, at];
    case "css-root": {
      let p = ra(t, e, r), d = h.raws.after.trim();
      return d.startsWith(";") && (d = d.slice(1).trim()), [h.frontMatter ? [r("frontMatter"), at] : "", p, d ? ` ${d}` : "", h.nodes.length > 0 ? at : ""];
    }
    case "css-comment": {
      let p = h.inline || h.raws.inline, d = e.originalText.slice(fr(h), pr(h));
      return p ? d.trimEnd() : d;
    }
    case "css-rule":
      return [r("selector"), h.important ? " !important" : "", h.nodes ? [((n = h.selector) == null ? void 0 : n.type) === "selector-unknown" && ta(h.selector.value) ? Vt : h.selector ? " " : "", "{", h.nodes.length > 0 ? ur([at, ra(t, e, r)]) : "", at, "}", LM(h) ? ";" : ""] : ";"];
    case "css-decl": {
      let p = t.parent, { between: d } = h.raws, m = d.trim(), y = m === ":", D = typeof h.value == "string" && /^ *$/.test(h.value), b = typeof h.value == "string" ? h.value : r("value");
      return b = VM(h) ? V8(b) : b, !y && ta(m) && !((s = (i = h.value) == null ? void 0 : i.group) != null && s.group && t.call(() => mb(t), "value", "group", "group")) && (b = ur([at, Qu(b)])), [wt(!1, h.raws.before, /[\s;]/g, ""), p.type === "css-atrule" && p.variable || IM(t) ? h.prop : Ks(h.prop), m.startsWith("//") ? " " : "", m, h.extend || D ? "" : " ", e.parser === "less" && h.extend && h.selector ? ["extend(", r("selector"), ")"] : "", b, h.raws.important ? h.raws.important.replace(/\s*!\s*important/i, " !important") : h.important ? " !important" : "", h.raws.scssDefault ? h.raws.scssDefault.replace(/\s*!default/i, " !default") : h.scssDefault ? " !default" : "", h.raws.scssGlobal ? h.raws.scssGlobal.replace(/\s*!global/i, " !global") : h.scssGlobal ? " !global" : "", h.nodes ? [" {", ur([Kr, ra(t, e, r)]), Kr, "}"] : UM(h) && !p.raws.semicolon && e.originalText[pr(h) - 1] !== ";" ? "" : e.__isHTMLStyleAttribute && rp(t, h) ? Q2(";") : ";"];
    }
    case "css-atrule": {
      let p = t.parent, d = ip(h) && !p.raws.semicolon && e.originalText[pr(h) - 1] !== ";";
      if (e.parser === "less") {
        if (h.mixin)
          return [r("selector"), h.important ? " !important" : "", d ? "" : ";"];
        if (h.function)
          return [h.name, typeof h.params == "string" ? h.params : r("params"), d ? "" : ";"];
        if (h.variable)
          return ["@", h.name, ": ", h.value ? r("value") : "", h.raws.between.trim() ? h.raws.between.trim() + " " : "", h.nodes ? ["{", ur([h.nodes.length > 0 ? Kr : "", ra(t, e, r)]), Kr, "}"] : "", d ? "" : ";"];
      }
      let m = h.name === "import" && ((o = h.params) == null ? void 0 : o.type) === "value-unknown" && h.params.value.endsWith(";");
      return ["@", l0(h) || h.name.endsWith(":") || ip(h) ? h.name : Ks(h.name), h.params ? [l0(h) ? "" : ip(h) ? h.raws.afterName === "" ? "" : h.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(h.raws.afterName) ? [at, at] : /^\s*\n/.test(h.raws.afterName) ? at : " " : " ", typeof h.params == "string" ? h.params : r("params")] : "", h.selector ? ur([" ", r("selector")]) : "", h.value ? kr([" ", r("value"), ad(h, e) ? zM(h) ? " " : Vt : ""]) : h.name === "else" ? " " : "", h.nodes ? [ad(h, e) ? "" : h.selector && !h.selector.nodes && typeof h.selector.value == "string" && ta(h.selector.value) || !h.selector && typeof h.params == "string" && ta(h.params) ? Vt : " ", "{", ur([h.nodes.length > 0 ? Kr : "", ra(t, e, r)]), Kr, "}"] : d || m ? "" : ";"];
    }
    case "media-query-list": {
      let p = [];
      return t.each(({ node: d }) => {
        d.type === "media-query" && d.value === "" || p.push(r());
      }, "nodes"), kr(ur(ns(Vt, p)));
    }
    case "media-query":
      return [ns(" ", t.map(r, "nodes")), rp(t, h) ? "" : ","];
    case "media-type":
      return Hs(un(h.value, e));
    case "media-feature-expression":
      return h.nodes ? ["(", ...t.map(r, "nodes"), ")"] : h.value;
    case "media-feature":
      return Ks(un(wt(!1, h.value, / +/g, " "), e));
    case "media-colon":
      return [h.value, " "];
    case "media-value":
      return Hs(un(h.value, e));
    case "media-keyword":
      return un(h.value, e);
    case "media-url":
      return un(wt(!1, wt(!1, h.value, /^url\(\s+/gi, "url("), /\s+\)$/g, ")"), e);
    case "media-unknown":
      return h.value;
    case "selector-root":
      return kr([Iu(t, "custom-selector") ? [t.findAncestor((p) => p.type === "css-atrule").customSelector, Vt] : "", ns([",", Iu(t, ["extend", "custom-selector", "nest"]) ? Vt : at], t.map(r, "nodes"))]);
    case "selector-selector":
      return kr(ur(t.map(r, "nodes")));
    case "selector-comment":
      return h.value;
    case "selector-string":
      return un(h.value, e);
    case "selector-tag":
      return [h.namespace ? [h.namespace === !0 ? "" : h.namespace.trim(), "|"] : "", ((l = t.previous) == null ? void 0 : l.type) === "selector-nesting" ? h.value : Hs(BM(t, h.value) ? h.value.toLowerCase() : h.value)];
    case "selector-id":
      return ["#", h.value];
    case "selector-class":
      return [".", Hs(un(h.value, e))];
    case "selector-attribute":
      return ["[", h.namespace ? [h.namespace === !0 ? "" : h.namespace.trim(), "|"] : "", h.attribute.trim(), h.operator ?? "", h.value ? oO(un(h.value.trim(), e), e) : "", h.insensitive ? " i" : "", "]"];
    case "selector-combinator": {
      if (h.value === "+" || h.value === ">" || h.value === "~" || h.value === ">>>") {
        let m = t.parent;
        return [m.type === "selector-selector" && m.nodes[0] === h ? "" : Vt, h.value, rp(t, h) ? "" : " "];
      }
      let p = h.value.trim().startsWith("(") ? Vt : "", d = Hs(un(h.value.trim(), e)) || Vt;
      return [p, d];
    }
    case "selector-universal":
      return [h.namespace ? [h.namespace === !0 ? "" : h.namespace.trim(), "|"] : "", h.value];
    case "selector-pseudo":
      return [Ks(h.value), oh(h.nodes) ? kr(["(", ur([Kr, ns([",", Vt], t.map(r, "nodes"))]), Kr, ")"]) : ""];
    case "selector-nesting":
      return h.value;
    case "selector-unknown": {
      let p = t.findAncestor((y) => y.type === "css-rule");
      if (p != null && p.isSCSSNesterProperty)
        return Hs(un(Ks(h.value), e));
      let d = t.parent;
      if ((u = d.raws) != null && u.selector) {
        let y = fr(d), D = y + d.raws.selector.length;
        return e.originalText.slice(y, D).trim();
      }
      let m = t.grandparent;
      if (d.type === "value-paren_group" && (m == null ? void 0 : m.type) === "value-func" && m.value === "selector") {
        let y = pr(d.open) + 1, D = fr(d.close), b = e.originalText.slice(y, D).trim();
        return ta(b) ? [Em, b] : b;
      }
      return h.value;
    }
    case "value-value":
    case "value-root":
      return r("group");
    case "value-comment":
      return e.originalText.slice(fr(h), pr(h));
    case "value-comma_group":
      return QM(t, e, r);
    case "value-paren_group":
      return yO(t, e, r);
    case "value-func":
      return [h.value, Iu(t, "supports") && KM(h) ? " " : "", r("group")];
    case "value-paren":
      return h.value;
    case "value-number":
      return [hb(h.value), tO(h.unit)];
    case "value-operator":
      return h.value;
    case "value-word":
      return h.isColor && h.isHex || PM(h.value) ? h.value.toLowerCase() : h.value;
    case "value-colon": {
      let { previous: p } = t;
      return [h.value, typeof (p == null ? void 0 : p.value) == "string" && p.value.endsWith("\\") || Bu(t, "url") ? "" : Vt];
    }
    case "value-string":
      return Z2(h.raws.quote + h.value + h.raws.quote, e);
    case "value-atword":
      return ["@", h.value];
    case "value-unicode-range":
      return h.value;
    case "value-unknown":
      return h.value;
    case "value-comma":
    default:
      throw new Z8(h, "PostCSS");
  }
}
var bO = { print: xO, embed: oM, insertPragma: SM, massageAstNode: nM, getVisitorKeys: fM }, vO = bO, CO = [{ linguistLanguageId: 50, name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css", ".wxss"], parsers: ["css"], vscodeLanguageIds: ["css"] }, { linguistLanguageId: 262764437, name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", parsers: ["css"], vscodeLanguageIds: ["postcss"] }, { linguistLanguageId: 198, name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", parsers: ["less"], vscodeLanguageIds: ["less"] }, { linguistLanguageId: 329, name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], parsers: ["scss"], vscodeLanguageIds: ["scss"] }], AO = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, EO = { singleQuote: AO.singleQuote }, wO = EO, gb = {};
E2(gb, { css: () => rL, less: () => nL, scss: () => iL });
var SO = Ts(ih(), 1), TO = Ts(WN(), 1), kO = Ts(GN(), 1);
function FO(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var PO = FO, BO = Ts(YN(), 1);
function xl(t, e, r) {
  if (t && typeof t == "object") {
    delete t.parent;
    for (let n in t)
      xl(t[n], e, r), n === "type" && typeof t[n] == "string" && !t[n].startsWith(e) && (!r || !r.test(t[n])) && (t[n] = e + t[n]);
  }
  return t;
}
function yb(t) {
  if (t && typeof t == "object") {
    delete t.parent;
    for (let e in t)
      yb(t[e]);
    !Array.isArray(t) && t.value && !t.type && (t.type = "unknown");
  }
  return t;
}
var IO = BO.default.default;
function NO(t) {
  let e;
  try {
    e = IO(t);
  } catch {
    return { type: "selector-unknown", value: t };
  }
  return xl(yb(e), "media-");
}
var MO = NO, OO = Ts(d8(), 1);
function LO(t) {
  if (/\/\/|\/\*/.test(t))
    return { type: "selector-unknown", value: t.trim() };
  let e;
  try {
    new OO.default((r) => {
      e = r;
    }).process(t);
  } catch {
    return { type: "selector-unknown", value: t };
  }
  return xl(e, "selector-");
}
var Qi = LO, _O = Ts(P8(), 1), $O = (t) => {
  for (; t.parent; )
    t = t.parent;
  return t;
}, Db = $O;
function RO(t) {
  return Db(t).text.slice(t.group.open.sourceIndex + 1, t.group.close.sourceIndex).trim();
}
var jO = RO;
function qO(t) {
  if (oh(t)) {
    for (let e = t.length - 1; e > 0; e--)
      if (t[e].type === "word" && t[e].value === "{" && t[e - 1].type === "word" && t[e - 1].value.endsWith("#"))
        return !0;
  }
  return !1;
}
var WO = qO;
function UO(t) {
  return t.some((e) => e.type === "string" || e.type === "func" && !e.value.endsWith("\\"));
}
var HO = UO;
function VO(t, e) {
  return !!(e.parser === "scss" && (t == null ? void 0 : t.type) === "word" && t.value.startsWith("$"));
}
var zO = VO;
function JO(t, e) {
  var r;
  let { nodes: n } = t, i = { open: null, close: null, groups: [], type: "paren_group" }, s = [i], o = i, l = { groups: [], type: "comma_group" }, u = [l];
  for (let h = 0; h < n.length; ++h) {
    let p = n[h];
    if (e.parser === "scss" && p.type === "number" && p.unit === ".." && p.value.endsWith(".") && (p.value = p.value.slice(0, -1), p.unit = "..."), p.type === "func" && p.value === "selector" && (p.group.groups = [Qi(Db(t).text.slice(p.group.open.sourceIndex + 1, p.group.close.sourceIndex))]), p.type === "func" && p.value === "url") {
      let d = ((r = p.group) == null ? void 0 : r.groups) ?? [], m = [];
      for (let y = 0; y < d.length; y++) {
        let D = d[y];
        D.type === "comma_group" ? m = [...m, ...D.groups] : m.push(D);
      }
      (WO(m) || !HO(m) && !zO(m[0], e)) && (p.group.groups = [jO(p)]);
    }
    if (p.type === "paren" && p.value === "(")
      i = { open: p, close: null, groups: [], type: "paren_group" }, s.push(i), l = { groups: [], type: "comma_group" }, u.push(l);
    else if (p.type === "paren" && p.value === ")") {
      if (l.groups.length > 0 && i.groups.push(l), i.close = p, u.length === 1)
        throw new Error("Unbalanced parenthesis");
      u.pop(), l = qa(!1, u, -1), l.groups.push(i), s.pop(), i = qa(!1, s, -1);
    } else
      p.type === "comma" ? (i.groups.push(l), l = { groups: [], type: "comma_group" }, u[u.length - 1] = l) : l.groups.push(p);
  }
  return l.groups.length > 0 && i.groups.push(l), o;
}
function ud(t) {
  return t.type === "paren_group" && !t.open && !t.close && t.groups.length === 1 || t.type === "comma_group" && t.groups.length === 1 ? ud(t.groups[0]) : t.type === "paren_group" || t.type === "comma_group" ? { ...t, groups: t.groups.map(ud) } : t;
}
function xb(t, e) {
  if (t && typeof t == "object")
    for (let r in t)
      r !== "parent" && (xb(t[r], e), r === "nodes" && (t.group = ud(JO(t, e)), delete t[r]));
  return t;
}
function KO(t, e) {
  if (e.parser === "less" && t.startsWith("~`"))
    return { type: "value-unknown", value: t };
  let r = null;
  try {
    r = new _O.default(t, { loose: !0 }).parse();
  } catch {
    return { type: "value-unknown", value: t };
  }
  r.text = t;
  let n = xb(r, e);
  return xl(n, "value-", /^selector-/);
}
var Ki = KO, GO = /* @__PURE__ */ new Set(["import", "use", "forward"]);
function XO(t) {
  return GO.has(t);
}
var YO = XO;
function QO(t, e) {
  return e.parser !== "scss" || !t.selector ? !1 : t.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*\n/, "").trim().endsWith(":");
}
var ZO = QO, eL = /(\s*)(!default).*$/, tL = /(\s*)(!global).*$/;
function bb(t, e) {
  var r, n;
  if (t && typeof t == "object") {
    delete t.parent;
    for (let l in t)
      bb(t[l], e);
    if (!t.type)
      return t;
    if (t.raws ?? (t.raws = {}), t.type === "css-decl" && typeof t.prop == "string" && t.prop.startsWith("--") && typeof t.value == "string" && t.value.startsWith("{")) {
      let l;
      if (t.value.trimEnd().endsWith("}")) {
        let u = e.originalText.slice(0, t.source.start.offset), h = "a".repeat(t.prop.length) + e.originalText.slice(t.source.start.offset + t.prop.length, t.source.end.offset), p = wt(!1, u, /[^\n]/g, " ") + h, d;
        e.parser === "scss" ? d = Ab : e.parser === "less" ? d = Cb : d = vb;
        let m;
        try {
          m = d(p, { ...e });
        } catch {
        }
        ((r = m == null ? void 0 : m.nodes) == null ? void 0 : r.length) === 1 && m.nodes[0].type === "css-rule" && (l = m.nodes[0].nodes);
      }
      return l ? t.value = { type: "css-rule", nodes: l } : t.value = { type: "value-unknown", value: t.raws.value.raw }, t;
    }
    let i = "";
    typeof t.selector == "string" && (i = t.raws.selector ? t.raws.selector.scss ?? t.raws.selector.raw : t.selector, t.raws.between && t.raws.between.trim().length > 0 && (i += t.raws.between), t.raws.selector = i);
    let s = "";
    typeof t.value == "string" && (s = t.raws.value ? t.raws.value.scss ?? t.raws.value.raw : t.value, s = s.trim(), t.raws.value = s);
    let o = "";
    if (typeof t.params == "string" && (o = t.raws.params ? t.raws.params.scss ?? t.raws.params.raw : t.params, t.raws.afterName && t.raws.afterName.trim().length > 0 && (o = t.raws.afterName + o), t.raws.between && t.raws.between.trim().length > 0 && (o = o + t.raws.between), o = o.trim(), t.raws.params = o), i.trim().length > 0)
      return i.startsWith("@") && i.endsWith(":") ? t : t.mixin ? (t.selector = Ki(i, e), t) : (ZO(t, e) && (t.isSCSSNesterProperty = !0), t.selector = Qi(i), t);
    if (s.length > 0) {
      let l = s.match(eL);
      l && (s = s.slice(0, l.index), t.scssDefault = !0, l[0].trim() !== "!default" && (t.raws.scssDefault = l[0]));
      let u = s.match(tL);
      if (u && (s = s.slice(0, u.index), t.scssGlobal = !0, u[0].trim() !== "!global" && (t.raws.scssGlobal = u[0])), s.startsWith("progid:"))
        return { type: "value-unknown", value: s };
      t.value = Ki(s, e);
    }
    if (e.parser === "less" && t.type === "css-decl" && s.startsWith("extend(") && (t.extend || (t.extend = t.raws.between === ":"), t.extend && !t.selector && (delete t.value, t.selector = Qi(s.slice(7, -1)))), t.type === "css-atrule") {
      if (e.parser === "less") {
        if (t.mixin) {
          let l = t.raws.identifier + t.name + t.raws.afterName + t.raws.params;
          return t.selector = Qi(l), delete t.params, t;
        }
        if (t.function)
          return t;
      }
      if (e.parser === "css" && t.name === "custom-selector") {
        let l = t.params.match(/:--\S+\s+/)[0].trim();
        return t.customSelector = l, t.selector = Qi(t.params.slice(l.length).trim()), delete t.params, t;
      }
      if (e.parser === "less") {
        if (t.name.includes(":") && !t.params) {
          t.variable = !0;
          let l = t.name.split(":");
          t.name = l[0], t.value = Ki(l.slice(1).join(":"), e);
        }
        if (!["page", "nest", "keyframes"].includes(t.name) && ((n = t.params) == null ? void 0 : n[0]) === ":") {
          t.variable = !0;
          let l = t.params.slice(1);
          l && (t.value = Ki(l, e)), t.raws.afterName += ":";
        }
        if (t.variable)
          return delete t.params, t.value || delete t.value, t;
      }
    }
    if (t.type === "css-atrule" && o.length > 0) {
      let { name: l } = t, u = t.name.toLowerCase();
      return l === "warn" || l === "error" ? (t.params = { type: "media-unknown", value: o }, t) : l === "extend" || l === "nest" ? (t.selector = Qi(o), delete t.params, t) : l === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(o) ? t.params = Ki(o, e) : (t.selector = Qi(o), delete t.params), t) : YO(u) ? (t.import = !0, delete t.filename, t.params = Ki(o, e), t) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(l) ? (o = o.replace(/(\$\S+?)(\s+)?\.{3}/, "$1...$2"), o = o.replace(/^(?!if)(\S+)(\s+)\(/, "$1($2"), t.value = Ki(o, e), delete t.params, t) : ["media", "custom-media"].includes(u) ? o.includes("#{") ? { type: "media-unknown", value: o } : (t.params = MO(o), t) : (t.params = o, t);
    }
  }
  return t;
}
function Fm(t, e, r) {
  let n = Tm(e), { frontMatter: i } = n;
  e = n.content;
  let s;
  try {
    s = t(e, { map: !1 });
  } catch (o) {
    let { name: l, reason: u, line: h, column: p } = o;
    throw typeof h != "number" ? o : PO(`${l}: ${u}`, { loc: { start: { line: h, column: p } }, cause: o });
  }
  return r.originalText = e, s = bb(xl(s, "css-"), r), ob(s, e), i && (i.source = { startOffset: 0, endOffset: i.raw.length }, s.frontMatter = i), s;
}
function vb(t, e = {}) {
  return Fm(SO.default.default, t, e);
}
function Cb(t, e = {}) {
  return Fm((r) => TO.default.parse(DM(r)), t, e);
}
function Ab(t, e = {}) {
  return Fm(kO.default, t, e);
}
var Pm = { astFormat: "postcss", hasPragma: wM, locStart: fr, locEnd: pr }, rL = { ...Pm, parse: vb }, nL = { ...Pm, parse: Cb }, iL = { ...Pm, parse: Ab }, sL = { postcss: vO }, oL = j2, aL = Object.create, Bm = Object.defineProperty, lL = Object.getOwnPropertyDescriptor, uL = Object.getOwnPropertyNames, cL = Object.getPrototypeOf, hL = Object.prototype.hasOwnProperty, pL = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), ah = (t, e) => {
  for (var r in e)
    Bm(t, r, { get: e[r], enumerable: !0 });
}, dL = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of uL(e))
      !hL.call(t, i) && i !== r && Bm(t, i, { get: () => e[i], enumerable: !(n = lL(e, i)) || n.enumerable });
  return t;
}, fL = (t, e, r) => (r = t != null ? aL(cL(t)) : {}, dL(e || !t || !t.__esModule ? Bm(r, "default", { value: t, enumerable: !0 }) : r, t)), Eb = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, hi = (t, e, r) => (Eb(t, e, "read from private field"), r ? r.call(t) : e.get(t)), mL = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, gL = (t, e, r, n) => (Eb(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r), yL = pL((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = p, t.parse = m, t.parseWithComments = y, t.print = D, t.strip = d;
  var e = /\*\/$/, r = /^\/\*\*?/, n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, s = /^(\r?\n)+/, o = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, l = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, u = /(\r?\n|^) *\* ?/g, h = [];
  function p(C) {
    let A = C.match(n);
    return A ? A[0].trimLeft() : "";
  }
  function d(C) {
    let A = C.match(n);
    return A && A[0] ? C.substring(A[0].length) : C;
  }
  function m(C) {
    return y(C).pragmas;
  }
  function y(C) {
    let A = `
`;
    C = C.replace(r, "").replace(e, "").replace(u, "$1");
    let x = "";
    for (; x !== C; )
      x = C, C = C.replace(o, `${A}$1 $2${A}`);
    C = C.replace(s, "").trimRight();
    let E = /* @__PURE__ */ Object.create(null), k = C.replace(l, "").replace(s, "").trimRight(), w;
    for (; w = l.exec(C); ) {
      let T = w[2].replace(i, "");
      typeof E[w[1]] == "string" || Array.isArray(E[w[1]]) ? E[w[1]] = h.concat(E[w[1]], T) : E[w[1]] = T;
    }
    return { comments: k, pragmas: E };
  }
  function D({ comments: C = "", pragmas: A = {} }) {
    let x = `
`, E = "/**", k = " *", w = " */", T = Object.keys(A), P = T.flatMap((N) => b(N, A[N])).map((N) => `${k} ${N}${x}`).join("");
    if (!C) {
      if (T.length === 0)
        return "";
      if (T.length === 1 && !Array.isArray(A[T[0]])) {
        let N = A[T[0]];
        return `${E} ${b(T[0], N)[0]}${w}`;
      }
    }
    let M = C.split(x).map((N) => `${k} ${N}`).join(x) + x;
    return E + x + (C ? M : "") + (C && T.length ? k + x : "") + P + w;
  }
  function b(C, A) {
    return h.concat(A).map((x) => `@${C} ${x}`.trim());
  }
}), wb = {};
ah(wb, { languages: () => e7, options: () => Q5, printers: () => Z5 });
var DL = [{ linguistLanguageId: 183, name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib", ".wxs"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell", "zx"], parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"] }, { linguistLanguageId: 183, name: "Flow", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: [], extensions: [".js.flow"], filenames: [], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"] }, { linguistLanguageId: 183, name: "JSX", type: "programming", tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0, aliases: void 0, extensions: [".jsx"], filenames: void 0, interpreters: void 0, parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], group: "JavaScript" }, { linguistLanguageId: 378, name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] }, { linguistLanguageId: 94901924, name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] }], Sb = {};
ah(Sb, { canAttachComment: () => w4, embed: () => p6, experimentalFeatures: () => U5, getCommentChildNodes: () => S4, getVisitorKeys: () => Fb, handleComments: () => ev, insertPragma: () => g6, isBlockComment: () => qr, isGap: () => T4, massageAstNode: () => w9, print: () => W5, printComment: () => H9, willPrintOwnComments: () => cv });
var xL = (t, e, r, n) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
}, mr = xL, bL = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, We = bL, vL = /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/, CL = (t) => vL.test(t), AL = CL;
function EL(t) {
  return t !== null && typeof t == "object";
}
var wL = EL;
function* SL(t, e) {
  let { getVisitorKeys: r, filter: n = () => !0 } = e, i = (s) => wL(s) && n(s);
  for (let s of r(t)) {
    let o = t[s];
    if (Array.isArray(o))
      for (let l of o)
        i(l) && (yield l);
    else
      i(o) && (yield o);
  }
}
function* TL(t, e) {
  let r = [t];
  for (let n = 0; n < r.length; n++) {
    let i = r[n];
    for (let s of SL(i, e))
      yield s, r.push(s);
  }
}
function kL(t, { getVisitorKeys: e, predicate: r }) {
  for (let n of TL(t, { getVisitorKeys: e }))
    if (r(n))
      return !0;
  return !1;
}
var FL = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function PL(t) {
  return t === 12288 || t >= 65281 && t <= 65376 || t >= 65504 && t <= 65510;
}
function BL(t) {
  return t >= 4352 && t <= 4447 || t === 8986 || t === 8987 || t === 9001 || t === 9002 || t >= 9193 && t <= 9196 || t === 9200 || t === 9203 || t === 9725 || t === 9726 || t === 9748 || t === 9749 || t >= 9800 && t <= 9811 || t === 9855 || t === 9875 || t === 9889 || t === 9898 || t === 9899 || t === 9917 || t === 9918 || t === 9924 || t === 9925 || t === 9934 || t === 9940 || t === 9962 || t === 9970 || t === 9971 || t === 9973 || t === 9978 || t === 9981 || t === 9989 || t === 9994 || t === 9995 || t === 10024 || t === 10060 || t === 10062 || t >= 10067 && t <= 10069 || t === 10071 || t >= 10133 && t <= 10135 || t === 10160 || t === 10175 || t === 11035 || t === 11036 || t === 11088 || t === 11093 || t >= 11904 && t <= 11929 || t >= 11931 && t <= 12019 || t >= 12032 && t <= 12245 || t >= 12272 && t <= 12287 || t >= 12289 && t <= 12350 || t >= 12353 && t <= 12438 || t >= 12441 && t <= 12543 || t >= 12549 && t <= 12591 || t >= 12593 && t <= 12686 || t >= 12688 && t <= 12771 || t >= 12783 && t <= 12830 || t >= 12832 && t <= 12871 || t >= 12880 && t <= 19903 || t >= 19968 && t <= 42124 || t >= 42128 && t <= 42182 || t >= 43360 && t <= 43388 || t >= 44032 && t <= 55203 || t >= 63744 && t <= 64255 || t >= 65040 && t <= 65049 || t >= 65072 && t <= 65106 || t >= 65108 && t <= 65126 || t >= 65128 && t <= 65131 || t >= 94176 && t <= 94180 || t === 94192 || t === 94193 || t >= 94208 && t <= 100343 || t >= 100352 && t <= 101589 || t >= 101632 && t <= 101640 || t >= 110576 && t <= 110579 || t >= 110581 && t <= 110587 || t === 110589 || t === 110590 || t >= 110592 && t <= 110882 || t === 110898 || t >= 110928 && t <= 110930 || t === 110933 || t >= 110948 && t <= 110951 || t >= 110960 && t <= 111355 || t === 126980 || t === 127183 || t === 127374 || t >= 127377 && t <= 127386 || t >= 127488 && t <= 127490 || t >= 127504 && t <= 127547 || t >= 127552 && t <= 127560 || t === 127568 || t === 127569 || t >= 127584 && t <= 127589 || t >= 127744 && t <= 127776 || t >= 127789 && t <= 127797 || t >= 127799 && t <= 127868 || t >= 127870 && t <= 127891 || t >= 127904 && t <= 127946 || t >= 127951 && t <= 127955 || t >= 127968 && t <= 127984 || t === 127988 || t >= 127992 && t <= 128062 || t === 128064 || t >= 128066 && t <= 128252 || t >= 128255 && t <= 128317 || t >= 128331 && t <= 128334 || t >= 128336 && t <= 128359 || t === 128378 || t === 128405 || t === 128406 || t === 128420 || t >= 128507 && t <= 128591 || t >= 128640 && t <= 128709 || t === 128716 || t >= 128720 && t <= 128722 || t >= 128725 && t <= 128727 || t >= 128732 && t <= 128735 || t === 128747 || t === 128748 || t >= 128756 && t <= 128764 || t >= 128992 && t <= 129003 || t === 129008 || t >= 129292 && t <= 129338 || t >= 129340 && t <= 129349 || t >= 129351 && t <= 129535 || t >= 129648 && t <= 129660 || t >= 129664 && t <= 129672 || t >= 129680 && t <= 129725 || t >= 129727 && t <= 129733 || t >= 129742 && t <= 129755 || t >= 129760 && t <= 129768 || t >= 129776 && t <= 129784 || t >= 131072 && t <= 196605 || t >= 196608 && t <= 262141;
}
var IL = (t) => !(PL(t) || BL(t)), NL = /[^\x20-\x7F]/;
function ML(t) {
  if (!t)
    return 0;
  if (!NL.test(t))
    return t.length;
  t = t.replace(FL(), "  ");
  let e = 0;
  for (let r of t) {
    let n = r.codePointAt(0);
    n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (e += IL(n) ? 1 : 2);
  }
  return e;
}
var yo = ML;
function Im(t) {
  return (e, r, n) => {
    let i = !!(n != null && n.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, o = r;
    for (; o >= 0 && o < s; ) {
      let l = e.charAt(o);
      if (t instanceof RegExp) {
        if (!t.test(l))
          return o;
      } else if (!t.includes(l))
        return o;
      i ? o-- : o++;
    }
    return o === -1 || o === s ? o : !1;
  };
}
var Do = Im(" 	"), OL = Im(",; 	"), LL = Im(/[^\n\r]/);
function _L(t, e, r) {
  let n = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let i = t.charAt(e);
  if (n) {
    if (t.charAt(e - 1) === "\r" && i === `
`)
      return e - 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e - 1;
  } else {
    if (i === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e + 1;
  }
  return e;
}
var xo = _L;
function $L(t, e, r = {}) {
  let n = Do(t, r.backwards ? e - 1 : e, r), i = xo(t, n, r);
  return n !== i;
}
var xr = $L;
function RL(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var Nm = RL;
function jL(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? LL(t, e) : e;
}
var Mm = jL;
function qL(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = OL(t, n), n = Nm(t, n), n = Do(t, n);
  return n = Mm(t, n), n = xo(t, n), n !== !1 && xr(t, n);
}
var Om = qL;
function WL(t) {
  return Array.isArray(t) && t.length > 0;
}
var je = WL, Ql = "'", p0 = '"';
function UL(t, e) {
  let r = e === !0 || e === Ql ? Ql : p0, n = r === Ql ? p0 : Ql, i = 0, s = 0;
  for (let o of t)
    o === r ? i++ : o === n && s++;
  return i > s ? n : r;
}
var Tb = UL;
function HL(t, e, r) {
  let n = e === '"' ? "'" : '"', i = mr(!1, t, /\\(.)|(["'])/gs, (s, o, l) => o === n ? o : l === e ? "\\" + l : l || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o) ? o : "\\" + o));
  return e + i + e;
}
var VL = HL;
function zL(t, e) {
  let r = t.slice(1, -1), n = e.parser === "json" || e.parser === "jsonc" || e.parser === "json5" && e.quoteProps === "preserve" && !e.singleQuote ? '"' : e.__isInHtmlAttribute ? "'" : Tb(r, e.singleQuote);
  return VL(r, n, !(e.parser === "css" || e.parser === "less" || e.parser === "scss" || e.__embeddedInHtml));
}
var Wa = zL;
function st(t) {
  var e, r, n;
  let i = ((e = t.range) == null ? void 0 : e[0]) ?? t.start, s = (n = ((r = t.declaration) == null ? void 0 : r.decorators) ?? t.decorators) == null ? void 0 : n[0];
  return s ? Math.min(st(s), i) : i;
}
function qe(t) {
  var e;
  return ((e = t.range) == null ? void 0 : e[1]) ?? t.end;
}
function lh(t, e) {
  let r = st(t);
  return Number.isInteger(r) && r === st(e);
}
function JL(t, e) {
  let r = qe(t);
  return Number.isInteger(r) && r === qe(e);
}
function KL(t, e) {
  return lh(t, e) && JL(t, e);
}
var na = null;
function Ta(t) {
  if (na !== null && typeof na.property) {
    let e = na;
    return na = Ta.prototype = null, e;
  }
  return na = Ta.prototype = t ?? /* @__PURE__ */ Object.create(null), new Ta();
}
var GL = 10;
for (let t = 0; t <= GL; t++)
  Ta();
function XL(t) {
  return Ta(t);
}
function YL(t, e = "type") {
  XL(t);
  function r(n) {
    let i = n[e], s = t[i];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: n });
    return s;
  }
  return r;
}
var kb = YL, QL = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value", "optional", "static", "method"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareEnum: ["id", "body"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], AsConstExpression: ["expression"], SatisfiesExpression: ["expression", "typeAnnotation"] }, ZL = kb(QL), Fb = ZL;
function e9(t) {
  let e = new Set(t);
  return (r) => e.has(r == null ? void 0 : r.type);
}
var Je = e9, t9 = Je(["Block", "CommentBlock", "MultiLine"]), qr = t9, r9 = Je(["AnyTypeAnnotation", "ThisTypeAnnotation", "NumberTypeAnnotation", "VoidTypeAnnotation", "BooleanTypeAnnotation", "BigIntTypeAnnotation", "SymbolTypeAnnotation", "StringTypeAnnotation", "NeverTypeAnnotation", "UndefinedTypeAnnotation", "UnknownTypeAnnotation", "EmptyTypeAnnotation", "MixedTypeAnnotation"]), Pb = r9;
function n9(t, e) {
  let r = e.split(".");
  for (let n = r.length - 1; n >= 0; n--) {
    let i = r[n];
    if (n === 0)
      return t.type === "Identifier" && t.name === i;
    if (t.type !== "MemberExpression" || t.optional || t.computed || t.property.type !== "Identifier" || t.property.name !== i)
      return !1;
    t = t.object;
  }
}
function i9(t, e) {
  return e.some((r) => n9(t, r));
}
var s9 = i9;
function o9({ type: t }) {
  return t.startsWith("TS") && t.endsWith("Keyword");
}
var Bb = o9;
function cd(t, e) {
  return e(t) || kL(t, { getVisitorKeys: Fb, predicate: e });
}
function Lm(t) {
  return t.type === "AssignmentExpression" || t.type === "BinaryExpression" || t.type === "LogicalExpression" || t.type === "NGPipeExpression" || t.type === "ConditionalExpression" || Re(t) || it(t) || t.type === "SequenceExpression" || t.type === "TaggedTemplateExpression" || t.type === "BindExpression" || t.type === "UpdateExpression" && !t.prefix || xn(t) || t.type === "TSNonNullExpression" || t.type === "ChainExpression";
}
function a9(t) {
  return t.expressions ? t.expressions[0] : t.left ?? t.test ?? t.callee ?? t.object ?? t.tag ?? t.argument ?? t.expression;
}
function Ib(t) {
  if (t.expressions)
    return ["expressions", 0];
  if (t.left)
    return ["left"];
  if (t.test)
    return ["test"];
  if (t.object)
    return ["object"];
  if (t.callee)
    return ["callee"];
  if (t.tag)
    return ["tag"];
  if (t.argument)
    return ["argument"];
  if (t.expression)
    return ["expression"];
  throw new Error("Unexpected node has no left side.");
}
var uh = Je(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose", "Hashbang", "InterpreterDirective"]), l9 = Je(["ExportDefaultDeclaration", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "DeclareExportAllDeclaration"]), Bt = Je(["ArrayExpression", "TupleExpression"]), tn = Je(["ObjectExpression", "RecordExpression"]);
function Bi(t) {
  return t.type === "NumericLiteral" || t.type === "Literal" && typeof t.value == "number";
}
function Nb(t) {
  return t.type === "UnaryExpression" && (t.operator === "+" || t.operator === "-") && Bi(t.argument);
}
function ir(t) {
  return t.type === "StringLiteral" || t.type === "Literal" && typeof t.value == "string";
}
function Mb(t) {
  return t.type === "RegExpLiteral" || t.type === "Literal" && !!t.regex;
}
var ch = Je(["Literal", "BooleanLiteral", "BigIntLiteral", "DecimalLiteral", "DirectiveLiteral", "NullLiteral", "NumericLiteral", "RegExpLiteral", "StringLiteral"]), Ob = Je(["Identifier", "ThisExpression", "Super", "PrivateName", "PrivateIdentifier", "Import"]), Ii = Je(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), Ua = Je(["FunctionExpression", "ArrowFunctionExpression"]);
function u9(t) {
  return t.type === "FunctionExpression" || t.type === "ArrowFunctionExpression" && t.body.type === "BlockStatement";
}
function lp(t) {
  return Re(t) && t.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(t.callee.name);
}
var Dt = Je(["JSXElement", "JSXFragment"]);
function hh(t) {
  return t.method && t.kind === "init" || t.kind === "get" || t.kind === "set";
}
function Lb(t) {
  return (t.type === "ObjectTypeProperty" || t.type === "ObjectTypeInternalSlot") && !t.static && !t.method && t.kind !== "get" && t.kind !== "set" && t.value.type === "FunctionTypeAnnotation";
}
function c9(t) {
  return (t.type === "TypeAnnotation" || t.type === "TSTypeAnnotation") && t.typeAnnotation.type === "FunctionTypeAnnotation" && !t.static && !lh(t, t.typeAnnotation);
}
var Wn = Je(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
function Xs(t) {
  return it(t) || t.type === "BindExpression" && !!t.object;
}
var h9 = Je(["TSThisType", "NullLiteralTypeAnnotation", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType"]);
function _m(t) {
  return Bb(t) || Pb(t) || h9(t) || (t.type === "GenericTypeAnnotation" || t.type === "TSTypeReference") && !t.typeParameters;
}
function p9(t) {
  let e = /^(?:before|after)(?:Each|All)$/;
  return t.callee.type === "Identifier" && t.arguments.length === 1 && e.test(t.callee.name);
}
var d9 = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
function f9(t) {
  return s9(t, d9);
}
function ph(t, e) {
  if (t.type !== "CallExpression")
    return !1;
  if (t.arguments.length === 1) {
    if (lp(t) && e && ph(e))
      return Ua(t.arguments[0]);
    if (p9(t))
      return lp(t.arguments[0]);
  } else if ((t.arguments.length === 2 || t.arguments.length === 3) && (t.arguments[0].type === "TemplateLiteral" || ir(t.arguments[0])) && f9(t.callee))
    return t.arguments[2] && !Bi(t.arguments[2]) ? !1 : (t.arguments.length === 2 ? Ua(t.arguments[1]) : u9(t.arguments[1]) && Wt(t.arguments[1]).length <= 1) || lp(t.arguments[1]);
  return !1;
}
var _b = (t) => (e) => ((e == null ? void 0 : e.type) === "ChainExpression" && (e = e.expression), t(e)), Re = _b(Je(["CallExpression", "OptionalCallExpression"])), it = _b(Je(["MemberExpression", "OptionalMemberExpression"]));
function m9(t) {
  let e = "expressions";
  t.type === "TSTemplateLiteralType" && (e = "types");
  let r = t[e];
  return r.length === 0 ? !1 : r.every((n) => {
    if (hd(n) || $b(n))
      return !0;
  });
}
function $b(t, { maxDepth: e = Number.POSITIVE_INFINITY } = {}) {
  if (se(t))
    return !1;
  if (t.type === "ChainExpression")
    return $b(t.expression, { maxDepth: e });
  if (!it(t))
    return !1;
  let r = t, n = 0;
  for (; it(r) && n++ <= e; )
    if (!hd(r.property) || (r = r.object, se(r)))
      return !1;
  return hd(r);
}
function hd(t) {
  return se(t) ? !1 : ch(t) || Ob(t);
}
function d0(t, e = 5) {
  return Rb(t, e) <= e;
}
function Rb(t, e) {
  let r = 0;
  for (let n in t) {
    let i = t[n];
    if (i && typeof i == "object" && typeof i.type == "string" && (r++, r += Rb(i, e - r)), r > e)
      return r;
  }
  return r;
}
var g9 = 0.25;
function $m(t, e) {
  let { printWidth: r } = e;
  if (se(t))
    return !1;
  let n = r * g9;
  if (t.type === "ThisExpression" || t.type === "Identifier" && t.name.length <= n || Nb(t) && !se(t.argument))
    return !0;
  let i = t.type === "Literal" && "regex" in t && t.regex.pattern || t.type === "RegExpLiteral" && t.pattern;
  return i ? i.length <= n : ir(t) ? Wa(Lr(t), e).length <= n : t.type === "TemplateLiteral" ? t.expressions.length === 0 && t.quasis[0].value.raw.length <= n && !t.quasis[0].value.raw.includes(`
`) : t.type === "UnaryExpression" ? $m(t.argument, { printWidth: r }) : t.type === "CallExpression" && t.arguments.length === 0 && t.callee.type === "Identifier" ? t.callee.name.length <= n - 2 : ch(t);
}
function fs(t, e) {
  return Dt(e) ? dh(e) : se(e, de.Leading, (r) => xr(t, qe(r)));
}
function f0(t, e) {
  return e.parser !== "json" && e.parser !== "jsonc" && ir(t.key) && Lr(t.key).slice(1, -1) === t.key.value && (AL(t.key.value) && !(e.parser === "babel-ts" && t.type === "ClassProperty" || e.parser === "typescript" && t.type === "PropertyDefinition") || jb(t.key.value) && String(Number(t.key.value)) === t.key.value && (e.parser === "babel" || e.parser === "acorn" || e.parser === "espree" || e.parser === "meriyah" || e.parser === "__babel_estree"));
}
function jb(t) {
  return /^(?:\d+|\d+\.\d+)$/.test(t);
}
function m0(t) {
  return t.quasis.some((e) => e.value.raw.includes(`
`));
}
function qb(t, e) {
  return (t.type === "TemplateLiteral" && m0(t) || t.type === "TaggedTemplateExpression" && m0(t.quasi)) && !xr(e, st(t), { backwards: !0 });
}
function Wb(t) {
  if (!se(t))
    return !1;
  let e = We(!1, oo(t, de.Dangling), -1);
  return e && !qr(e);
}
function y9(t) {
  if (t.length <= 1)
    return !1;
  let e = 0;
  for (let r of t)
    if (Ua(r)) {
      if (e += 1, e > 1)
        return !0;
    } else if (Re(r)) {
      for (let n of _r(r))
        if (Ua(n))
          return !0;
    }
  return !1;
}
function Ub(t) {
  let { node: e, parent: r, key: n } = t;
  return n === "callee" && Re(e) && Re(r) && r.arguments.length > 0 && e.arguments.length > r.arguments.length;
}
var D9 = /* @__PURE__ */ new Set(["!", "-", "+", "~"]);
function Yr(t, e = 2) {
  if (e <= 0)
    return !1;
  if (t.type === "ChainExpression" || t.type === "TSNonNullExpression")
    return Yr(t.expression, e);
  let r = (n) => Yr(n, e - 1);
  if (Mb(t))
    return yo(t.pattern ?? t.regex.pattern) <= 5;
  if (ch(t) || Ob(t) || t.type === "ArgumentPlaceholder")
    return !0;
  if (t.type === "TemplateLiteral")
    return t.quasis.every((n) => !n.value.raw.includes(`
`)) && t.expressions.every(r);
  if (tn(t))
    return t.properties.every((n) => !n.computed && (n.shorthand || n.value && r(n.value)));
  if (Bt(t))
    return t.elements.every((n) => n === null || r(n));
  if (bo(t)) {
    if (t.type === "ImportExpression" || Yr(t.callee, e)) {
      let n = _r(t);
      return n.length <= e && n.every(r);
    }
    return !1;
  }
  return it(t) ? Yr(t.object, e) && Yr(t.property, e) : t.type === "UnaryExpression" && D9.has(t.operator) || t.type === "UpdateExpression" ? Yr(t.argument, e) : !1;
}
function Lr(t) {
  var e;
  return ((e = t.extra) == null ? void 0 : e.raw) ?? t.raw;
}
function x9(t) {
  return t;
}
function Wi(t, e = "es5") {
  return t.trailingComma === "es5" && e === "es5" || t.trailingComma === "all" && (e === "all" || e === "es5");
}
function zt(t, e) {
  switch (t.type) {
    case "BinaryExpression":
    case "LogicalExpression":
    case "AssignmentExpression":
    case "NGPipeExpression":
      return zt(t.left, e);
    case "MemberExpression":
    case "OptionalMemberExpression":
      return zt(t.object, e);
    case "TaggedTemplateExpression":
      return t.tag.type === "FunctionExpression" ? !1 : zt(t.tag, e);
    case "CallExpression":
    case "OptionalCallExpression":
      return t.callee.type === "FunctionExpression" ? !1 : zt(t.callee, e);
    case "ConditionalExpression":
      return zt(t.test, e);
    case "UpdateExpression":
      return !t.prefix && zt(t.argument, e);
    case "BindExpression":
      return t.object && zt(t.object, e);
    case "SequenceExpression":
      return zt(t.expressions[0], e);
    case "ChainExpression":
    case "TSSatisfiesExpression":
    case "TSAsExpression":
    case "TSNonNullExpression":
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
      return zt(t.expression, e);
    default:
      return e(t);
  }
}
var g0 = { "==": !0, "!=": !0, "===": !0, "!==": !0 }, Zl = { "*": !0, "/": !0, "%": !0 }, pd = { ">>": !0, ">>>": !0, "<<": !0 };
function Rm(t, e) {
  return !(tc(e) !== tc(t) || t === "**" || g0[t] && g0[e] || e === "%" && Zl[t] || t === "%" && Zl[e] || e !== t && Zl[e] && Zl[t] || pd[t] && pd[e]);
}
var b9 = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((t, e) => t.map((r) => [r, e])));
function tc(t) {
  return b9.get(t);
}
function v9(t) {
  return !!pd[t] || t === "|" || t === "^" || t === "&";
}
function C9(t) {
  var e;
  if (t.rest)
    return !0;
  let r = Wt(t);
  return ((e = We(!1, r, -1)) == null ? void 0 : e.type) === "RestElement";
}
var up = /* @__PURE__ */ new WeakMap();
function Wt(t) {
  if (up.has(t))
    return up.get(t);
  let e = [];
  return t.this && e.push(t.this), Array.isArray(t.parameters) ? e.push(...t.parameters) : Array.isArray(t.params) && e.push(...t.params), t.rest && e.push(t.rest), up.set(t, e), e;
}
function A9(t, e) {
  let { node: r } = t, n = 0, i = (s) => e(s, n++);
  r.this && t.call(i, "this"), Array.isArray(r.parameters) ? t.each(i, "parameters") : Array.isArray(r.params) && t.each(i, "params"), r.rest && t.call(i, "rest");
}
var cp = /* @__PURE__ */ new WeakMap();
function _r(t) {
  if (cp.has(t))
    return cp.get(t);
  if (t.type === "ChainExpression")
    return _r(t.expression);
  let e = t.arguments;
  return t.type === "ImportExpression" && (e = [t.source], t.attributes && e.push(t.attributes), t.options && e.push(t.options)), cp.set(t, e), e;
}
function jm(t, e) {
  let { node: r } = t;
  if (r.type === "ChainExpression")
    return t.call(() => jm(t, e), "expression");
  r.type === "ImportExpression" ? (t.call((n) => e(n, 0), "source"), r.attributes && t.call((n) => e(n, 1), "attributes"), r.options && t.call((n) => e(n, 1), "options")) : t.each(e, "arguments");
}
function y0(t, e) {
  let r = [];
  if (t.type === "ChainExpression" && r.push("expression"), t.type === "ImportExpression") {
    if (e === 0 || e === (t.attributes || t.options ? -2 : -1))
      return [...r, "source"];
    if (t.attributes && (e === 1 || e === -1))
      return [...r, "attributes"];
    if (t.options && (e === 1 || e === -1))
      return [...r, "options"];
    throw new RangeError("Invalid argument index");
  }
  if (e < 0 && (e = t.arguments.length + e), e < 0 || e >= t.arguments.length)
    throw new RangeError("Invalid argument index");
  return [...r, "arguments", e];
}
function rc(t) {
  return t.value.trim() === "prettier-ignore" && !t.unignore;
}
function dh(t) {
  return (t == null ? void 0 : t.prettierIgnore) || se(t, de.PrettierIgnore);
}
var de = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, Hb = (t, e) => {
  if (typeof t == "function" && (e = t, t = 0), t || e)
    return (r, n, i) => !(t & de.Leading && !r.leading || t & de.Trailing && !r.trailing || t & de.Dangling && (r.leading || r.trailing) || t & de.Block && !qr(r) || t & de.Line && !uh(r) || t & de.First && n !== 0 || t & de.Last && n !== i.length - 1 || t & de.PrettierIgnore && !rc(r) || e && !e(r));
};
function se(t, e, r) {
  if (!je(t == null ? void 0 : t.comments))
    return !1;
  let n = Hb(e, r);
  return n ? t.comments.some(n) : !0;
}
function oo(t, e, r) {
  if (!Array.isArray(t == null ? void 0 : t.comments))
    return [];
  let n = Hb(e, r);
  return n ? t.comments.filter(n) : t.comments;
}
var Ui = (t, { originalText: e }) => Om(e, qe(t));
function bo(t) {
  return Re(t) || t.type === "NewExpression" || t.type === "ImportExpression";
}
function ri(t) {
  return t && (t.type === "ObjectProperty" || t.type === "Property" && !hh(t));
}
var xn = Je(["TSAsExpression", "TSSatisfiesExpression", "AsExpression", "AsConstExpression", "SatisfiesExpression"]), ms = Je(["UnionTypeAnnotation", "TSUnionType"]), Vb = Je(["IntersectionTypeAnnotation", "TSIntersectionType"]), E9 = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), Vs = (t) => {
  for (let e of t.quasis)
    delete e.value;
};
function zb(t, e, r) {
  var n, i;
  if (t.type === "Program" && delete e.sourceType, (t.type === "BigIntLiteral" || t.type === "BigIntLiteralTypeAnnotation") && e.value && (e.value = e.value.toLowerCase()), (t.type === "BigIntLiteral" || t.type === "Literal") && e.bigint && (e.bigint = e.bigint.toLowerCase()), t.type === "DecimalLiteral" && (e.value = Number(e.value)), t.type === "Literal" && e.decimal && (e.decimal = Number(e.decimal)), t.type === "EmptyStatement" || t.type === "JSXText" || t.type === "JSXExpressionContainer" && (t.expression.type === "Literal" || t.expression.type === "StringLiteral") && t.expression.value === " ")
    return null;
  if ((t.type === "Property" || t.type === "ObjectProperty" || t.type === "MethodDefinition" || t.type === "ClassProperty" || t.type === "ClassMethod" || t.type === "PropertyDefinition" || t.type === "TSDeclareMethod" || t.type === "TSPropertySignature" || t.type === "ObjectTypeProperty") && typeof t.key == "object" && t.key && (t.key.type === "Literal" || t.key.type === "NumericLiteral" || t.key.type === "StringLiteral" || t.key.type === "Identifier") && delete e.key, t.type === "JSXElement" && t.openingElement.name.name === "style" && t.openingElement.attributes.some((o) => o.type === "JSXAttribute" && o.name.name === "jsx"))
    for (let { type: o, expression: l } of e.children)
      o === "JSXExpressionContainer" && l.type === "TemplateLiteral" && Vs(l);
  t.type === "JSXAttribute" && t.name.name === "css" && t.value.type === "JSXExpressionContainer" && t.value.expression.type === "TemplateLiteral" && Vs(e.value.expression), t.type === "JSXAttribute" && ((n = t.value) == null ? void 0 : n.type) === "Literal" && /["']|&quot;|&apos;/.test(t.value.value) && (e.value.value = mr(!1, e.value.value, /["']|&quot;|&apos;/g, '"'));
  let s = t.expression || t.callee;
  if (t.type === "Decorator" && s.type === "CallExpression" && s.callee.name === "Component" && s.arguments.length === 1) {
    let o = t.expression.arguments[0].properties;
    for (let [l, u] of e.expression.arguments[0].properties.entries())
      switch (o[l].key.name) {
        case "styles":
          Bt(u.value) && Vs(u.value.elements[0]);
          break;
        case "template":
          u.value.type === "TemplateLiteral" && Vs(u.value);
          break;
      }
  }
  if (t.type === "TaggedTemplateExpression" && (t.tag.type === "MemberExpression" || t.tag.type === "Identifier" && (t.tag.name === "gql" || t.tag.name === "graphql" || t.tag.name === "css" || t.tag.name === "md" || t.tag.name === "markdown" || t.tag.name === "html") || t.tag.type === "CallExpression") && Vs(e.quasi), t.type === "TemplateLiteral" && ((i = t.leadingComments) != null && i.some((o) => qr(o) && ["GraphQL", "HTML"].some((l) => o.value === ` ${l} `)) || r.type === "CallExpression" && r.callee.name === "graphql" || !t.leadingComments) && Vs(e), (t.type === "TSIntersectionType" || t.type === "TSUnionType") && t.types.length === 1)
    return e.types[0];
  t.type === "ChainExpression" && t.expression.type === "TSNonNullExpression" && ([e.type, e.expression.type] = [e.expression.type, e.type]);
}
zb.ignoredProperties = E9;
var w9 = zb, No = "string", gs = "array", Mo = "cursor", Fs = "indent", Ps = "align", Oo = "trim", $r = "group", kn = "fill", An = "if-break", Bs = "indent-if-break", Is = "line-suffix", Ns = "line-suffix-boundary", Ar = "line", Hi = "label", Vi = "break-parent", Jb = /* @__PURE__ */ new Set([Mo, Fs, Ps, Oo, $r, kn, An, Bs, Is, Ns, Ar, Hi, Vi]);
function S9(t) {
  if (typeof t == "string")
    return No;
  if (Array.isArray(t))
    return gs;
  if (!t)
    return;
  let { type: e } = t;
  if (Jb.has(e))
    return e;
}
var Lo = S9, T9 = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function k9(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (Lo(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = T9([...Jb].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`;
}
var F9 = class extends Error {
  constructor(e) {
    super(k9(e));
    Vr(this, "name", "InvalidDocError");
    this.doc = e;
  }
}, Ha = F9, D0 = {};
function P9(t, e, r, n) {
  let i = [t];
  for (; i.length > 0; ) {
    let s = i.pop();
    if (s === D0) {
      r(i.pop());
      continue;
    }
    r && i.push(s, D0);
    let o = Lo(s);
    if (!o)
      throw new Ha(s);
    if ((e == null ? void 0 : e(s)) !== !1)
      switch (o) {
        case gs:
        case kn: {
          let l = o === gs ? s : s.parts;
          for (let u = l.length, h = u - 1; h >= 0; --h)
            i.push(l[h]);
          break;
        }
        case An:
          i.push(s.flatContents, s.breakContents);
          break;
        case $r:
          if (n && s.expandedStates)
            for (let l = s.expandedStates.length, u = l - 1; u >= 0; --u)
              i.push(s.expandedStates[u]);
          else
            i.push(s.contents);
          break;
        case Ps:
        case Fs:
        case Bs:
        case Hi:
        case Is:
          i.push(s.contents);
          break;
        case No:
        case Mo:
        case Oo:
        case Ns:
        case Ar:
        case Vi:
          break;
        default:
          throw new Ha(s);
      }
  }
}
var Kb = P9, B9 = () => {
}, I9 = B9;
function te(t) {
  return { type: Fs, contents: t };
}
function Fn(t, e) {
  return { type: Ps, contents: e, n: t };
}
function q(t, e = {}) {
  return I9(e.expandedStates), { type: $r, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function N9(t) {
  return Fn(Number.NEGATIVE_INFINITY, t);
}
function Gb(t) {
  return Fn(-1, t);
}
function is(t, e) {
  return q(t[0], { ...e, expandedStates: t });
}
function qm(t) {
  return { type: kn, parts: t };
}
function we(t, e = "", r = {}) {
  return { type: An, breakContents: t, flatContents: e, groupId: r.groupId };
}
function fh(t, e) {
  return { type: Bs, contents: t, groupId: e.groupId, negate: e.negate };
}
function x0(t) {
  return { type: Is, contents: t };
}
var Un = { type: Ns }, Pn = { type: Vi }, Xb = { type: Ar, hard: !0 }, M9 = { type: Ar, hard: !0, literal: !0 }, he = { type: Ar }, Y = { type: Ar, soft: !0 }, ee = [Xb, Pn], Yb = [M9, Pn], b0 = { type: Mo };
function Ne(t, e) {
  let r = [];
  for (let n = 0; n < e.length; n++)
    n !== 0 && r.push(t), r.push(e[n]);
  return r;
}
function O9(t, e, r) {
  let n = t;
  if (e > 0) {
    for (let i = 0; i < Math.floor(e / r); ++i)
      n = te(n);
    n = Fn(e % r, n), n = Fn(Number.NEGATIVE_INFINITY, n);
  }
  return n;
}
function bl(t, e) {
  return t ? { type: Hi, label: t, contents: e } : e;
}
var Qb = (t) => {
  if (Array.isArray(t))
    return t;
  if (t.type !== kn)
    throw new Error(`Expect doc to be 'array' or '${kn}'.`);
  return t.parts;
};
function _o(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return n(t);
  function n(s) {
    if (r.has(s))
      return r.get(s);
    let o = i(s);
    return r.set(s, o), o;
  }
  function i(s) {
    switch (Lo(s)) {
      case gs:
        return e(s.map(n));
      case kn:
        return e({ ...s, parts: s.parts.map(n) });
      case An:
        return e({ ...s, breakContents: n(s.breakContents), flatContents: n(s.flatContents) });
      case $r: {
        let { expandedStates: o, contents: l } = s;
        return o ? (o = o.map(n), l = o[0]) : l = n(l), e({ ...s, contents: l, expandedStates: o });
      }
      case Ps:
      case Fs:
      case Bs:
      case Hi:
      case Is:
        return e({ ...s, contents: n(s.contents) });
      case No:
      case Mo:
      case Oo:
      case Ns:
      case Ar:
      case Vi:
        return e(s);
      default:
        throw new Ha(s);
    }
  }
}
function Zb(t, e, r) {
  let n = r, i = !1;
  function s(o) {
    if (i)
      return !1;
    let l = e(o);
    l !== void 0 && (i = !0, n = l);
  }
  return Kb(t, s), n;
}
function L9(t) {
  if (t.type === $r && t.break || t.type === Ar && t.hard || t.type === Vi)
    return !0;
}
function Jt(t) {
  return Zb(t, L9, !1);
}
function v0(t) {
  if (t.length > 0) {
    let e = We(!1, t, -1);
    !e.expandedStates && !e.break && (e.break = "propagated");
  }
  return null;
}
function _9(t) {
  let e = /* @__PURE__ */ new Set(), r = [];
  function n(s) {
    if (s.type === Vi && v0(r), s.type === $r) {
      if (r.push(s), e.has(s))
        return !1;
      e.add(s);
    }
  }
  function i(s) {
    s.type === $r && r.pop().break && v0(r);
  }
  Kb(t, n, i, !0);
}
function $9(t) {
  return t.type === Ar && !t.hard ? t.soft ? "" : " " : t.type === An ? t.flatContents : t;
}
function dd(t) {
  return _o(t, $9);
}
function R9(t) {
  switch (Lo(t)) {
    case kn:
      if (t.parts.every((e) => e === ""))
        return "";
      break;
    case $r:
      if (!t.contents && !t.id && !t.break && !t.expandedStates)
        return "";
      if (t.contents.type === $r && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates)
        return t.contents;
      break;
    case Ps:
    case Fs:
    case Bs:
    case Is:
      if (!t.contents)
        return "";
      break;
    case An:
      if (!t.flatContents && !t.breakContents)
        return "";
      break;
    case gs: {
      let e = [];
      for (let r of t) {
        if (!r)
          continue;
        let [n, ...i] = Array.isArray(r) ? r : [r];
        typeof n == "string" && typeof We(!1, e, -1) == "string" ? e[e.length - 1] += n : e.push(n), e.push(...i);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case No:
    case Mo:
    case Oo:
    case Ns:
    case Ar:
    case Hi:
    case Vi:
      break;
    default:
      throw new Ha(t);
  }
  return t;
}
function Wm(t) {
  return _o(t, (e) => R9(e));
}
function ys(t, e = Yb) {
  return _o(t, (r) => typeof r == "string" ? Ne(e, r.split(`
`)) : r);
}
function j9(t) {
  if (t.type === Ar)
    return !0;
}
function q9(t) {
  return Zb(t, j9, !1);
}
function fd(t, e) {
  return t.type === Hi ? { ...t, contents: e(t.contents) } : e(t);
}
function W9(t) {
  let e = `*${t.value}*`.split(`
`);
  return e.length > 1 && e.every((r) => r.trimStart()[0] === "*");
}
var U9 = W9;
function H9(t, e) {
  let r = t.node;
  if (uh(r))
    return e.originalText.slice(st(r), qe(r)).trimEnd();
  if (qr(r))
    return U9(r) ? V9(r) : ["/*", ys(r.value), "*/"];
  throw new Error("Not a comment: " + JSON.stringify(r));
}
function V9(t) {
  let e = t.value.split(`
`);
  return ["/*", Ne(ee, e.map((r, n) => n === 0 ? r.trimEnd() : " " + (n < e.length - 1 ? r.trim() : r.trimStart()))), "*/"];
}
var ev = {};
ah(ev, { endOfLine: () => Z9, ownLine: () => Q9, remaining: () => e4 });
function z9(t) {
  let e = t.type || t.kind || "(unknown type)", r = String(t.name || t.id && (typeof t.id == "object" ? t.id.name : t.id) || t.key && (typeof t.key == "object" ? t.key.name : t.key) || t.value && (typeof t.value == "object" ? "" : String(t.value)) || t.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + ""), e + (r ? " " + r : "");
}
function Um(t, e) {
  (t.comments ?? (t.comments = [])).push(e), e.printed = !1, e.nodeDescription = z9(t);
}
function It(t, e) {
  e.leading = !0, e.trailing = !1, Um(t, e);
}
function br(t, e, r) {
  e.leading = !1, e.trailing = !1, r && (e.marker = r), Um(t, e);
}
function ut(t, e) {
  e.leading = !1, e.trailing = !0, Um(t, e);
}
function J9(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = Do(t, n), n = Nm(t, n), n = Mm(t, n), n = xo(t, n);
  return n;
}
var vl = J9;
function K9(t, e) {
  let r = vl(t, e);
  return r === !1 ? "" : t.charAt(r);
}
var Hn = K9;
function G9(t, e, r) {
  for (let n = e; n < r; ++n)
    if (t.charAt(n) === `
`)
      return !0;
  return !1;
}
var Ni = G9;
function X9(t) {
  return qr(t) && t.value[0] === "*" && /@(?:type|satisfies)\b/.test(t.value);
}
var Y9 = X9;
function Q9(t) {
  return [lv, rv, sv, r4, Hm, Vm, tv, nv, f4, p4, Jm, av, m4, iv, ov, zm, n4, A4].some((e) => e(t));
}
function Z9(t) {
  return [t4, sv, rv, av, Hm, Vm, tv, nv, ov, h4, d4, Jm, D4, zm, v4, C4].some((e) => e(t));
}
function e4(t) {
  return [lv, Hm, Vm, i4, c4, iv, Jm, u4, l4, b4, zm, x4].some((e) => e(t));
}
function Ms(t, e) {
  let r = (t.body || t.properties).find(({ type: n }) => n !== "EmptyStatement");
  r ? It(r, e) : br(t, e);
}
function md(t, e) {
  t.type === "BlockStatement" ? Ms(t, e) : It(t, e);
}
function t4({ comment: t, followingNode: e }) {
  return e && Y9(t) ? (It(e, t), !0) : !1;
}
function Hm({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n, text: i }) {
  if ((r == null ? void 0 : r.type) !== "IfStatement" || !n)
    return !1;
  if (Hn(i, qe(t)) === ")")
    return ut(e, t), !0;
  if (e === r.consequent && n === r.alternate) {
    if (e.type === "BlockStatement")
      ut(e, t);
    else {
      let s = uh(t) || t.loc.start.line === t.loc.end.line, o = t.loc.start.line === e.loc.start.line;
      s && o ? ut(e, t) : br(r, t);
    }
    return !0;
  }
  return n.type === "BlockStatement" ? (Ms(n, t), !0) : n.type === "IfStatement" ? (md(n.consequent, t), !0) : r.consequent === n ? (It(n, t), !0) : !1;
}
function Vm({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n, text: i }) {
  return (r == null ? void 0 : r.type) !== "WhileStatement" || !n ? !1 : Hn(i, qe(t)) === ")" ? (ut(e, t), !0) : n.type === "BlockStatement" ? (Ms(n, t), !0) : r.body === n ? (It(n, t), !0) : !1;
}
function tv({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n }) {
  return (r == null ? void 0 : r.type) !== "TryStatement" && (r == null ? void 0 : r.type) !== "CatchClause" || !n ? !1 : r.type === "CatchClause" && e ? (ut(e, t), !0) : n.type === "BlockStatement" ? (Ms(n, t), !0) : n.type === "TryStatement" ? (md(n.finalizer, t), !0) : n.type === "CatchClause" ? (md(n.body, t), !0) : !1;
}
function r4({ comment: t, enclosingNode: e, followingNode: r }) {
  return it(e) && (r == null ? void 0 : r.type) === "Identifier" ? (It(e, t), !0) : !1;
}
function n4({ comment: t, enclosingNode: e, followingNode: r, options: n }) {
  return !n.experimentalTernaries || !((e == null ? void 0 : e.type) === "ConditionalExpression" || (e == null ? void 0 : e.type) === "ConditionalTypeAnnotation" || (e == null ? void 0 : e.type) === "TSConditionalType") ? !1 : (r == null ? void 0 : r.type) === "ConditionalExpression" || (r == null ? void 0 : r.type) === "ConditionalTypeAnnotation" || (r == null ? void 0 : r.type) === "TSConditionalType" ? (br(e, t), !0) : !1;
}
function rv({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n, text: i, options: s }) {
  let o = e && !Ni(i, qe(e), st(t));
  return (!e || !o) && ((r == null ? void 0 : r.type) === "ConditionalExpression" || (r == null ? void 0 : r.type) === "ConditionalTypeAnnotation" || (r == null ? void 0 : r.type) === "TSConditionalType") && n ? s.experimentalTernaries && r.alternate === n && !(qr(t) && !Ni(s.originalText, st(t), qe(t))) ? (br(r, t), !0) : (It(n, t), !0) : !1;
}
function i4({ comment: t, precedingNode: e, enclosingNode: r }) {
  return ri(r) && r.shorthand && r.key === e && r.value.type === "AssignmentPattern" ? (ut(r.value.left, t), !0) : !1;
}
var s4 = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
function nv({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n }) {
  if (s4.has(r == null ? void 0 : r.type)) {
    if (je(r.decorators) && (n == null ? void 0 : n.type) !== "Decorator")
      return ut(We(!1, r.decorators, -1), t), !0;
    if (r.body && n === r.body)
      return Ms(r.body, t), !0;
    if (n) {
      if (r.superClass && n === r.superClass && e && (e === r.id || e === r.typeParameters))
        return ut(e, t), !0;
      for (let i of ["implements", "extends", "mixins"])
        if (r[i] && n === r[i][0])
          return e && (e === r.id || e === r.typeParameters || e === r.superClass) ? ut(e, t) : br(r, t, i), !0;
    }
  }
  return !1;
}
var o4 = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
function iv({ comment: t, precedingNode: e, enclosingNode: r, text: n }) {
  return r && e && Hn(n, qe(t)) === "(" && (r.type === "Property" || r.type === "TSDeclareMethod" || r.type === "TSAbstractMethodDefinition") && e.type === "Identifier" && r.key === e && Hn(n, qe(e)) !== ":" || (e == null ? void 0 : e.type) === "Decorator" && o4.has(r == null ? void 0 : r.type) ? (ut(e, t), !0) : !1;
}
var a4 = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
function l4({ comment: t, precedingNode: e, enclosingNode: r, text: n }) {
  return Hn(n, qe(t)) !== "(" ? !1 : e && a4.has(r == null ? void 0 : r.type) ? (ut(e, t), !0) : !1;
}
function u4({ comment: t, enclosingNode: e, text: r }) {
  if ((e == null ? void 0 : e.type) !== "ArrowFunctionExpression")
    return !1;
  let n = vl(r, qe(t));
  return n !== !1 && r.slice(n, n + 2) === "=>" ? (br(e, t), !0) : !1;
}
function c4({ comment: t, enclosingNode: e, text: r }) {
  return Hn(r, qe(t)) !== ")" ? !1 : e && (uv(e) && Wt(e).length === 0 || bo(e) && _r(e).length === 0) ? (br(e, t), !0) : ((e == null ? void 0 : e.type) === "MethodDefinition" || (e == null ? void 0 : e.type) === "TSAbstractMethodDefinition") && Wt(e.value).length === 0 ? (br(e.value, t), !0) : !1;
}
function sv({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n, text: i }) {
  return (e == null ? void 0 : e.type) === "FunctionTypeParam" && (r == null ? void 0 : r.type) === "FunctionTypeAnnotation" && (n == null ? void 0 : n.type) !== "FunctionTypeParam" || ((e == null ? void 0 : e.type) === "Identifier" || (e == null ? void 0 : e.type) === "AssignmentPattern" || (e == null ? void 0 : e.type) === "ObjectPattern" || (e == null ? void 0 : e.type) === "ArrayPattern" || (e == null ? void 0 : e.type) === "RestElement" || (e == null ? void 0 : e.type) === "TSParameterProperty") && uv(r) && Hn(i, qe(t)) === ")" ? (ut(e, t), !0) : !qr(t) && ((r == null ? void 0 : r.type) === "FunctionDeclaration" || (r == null ? void 0 : r.type) === "FunctionExpression" || (r == null ? void 0 : r.type) === "ObjectMethod") && (n == null ? void 0 : n.type) === "BlockStatement" && r.body === n && vl(i, qe(t)) === st(n) ? (Ms(n, t), !0) : !1;
}
function ov({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "LabeledStatement" ? (It(e, t), !0) : !1;
}
function zm({ comment: t, enclosingNode: e }) {
  return ((e == null ? void 0 : e.type) === "ContinueStatement" || (e == null ? void 0 : e.type) === "BreakStatement") && !e.label ? (ut(e, t), !0) : !1;
}
function h4({ comment: t, precedingNode: e, enclosingNode: r }) {
  return Re(r) && e && r.callee === e && r.arguments.length > 0 ? (It(r.arguments[0], t), !0) : !1;
}
function p4({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n }) {
  return ms(r) ? (rc(t) && (n.prettierIgnore = !0, t.unignore = !0), e ? (ut(e, t), !0) : !1) : (ms(n) && rc(t) && (n.types[0].prettierIgnore = !0, t.unignore = !0), !1);
}
function d4({ comment: t, enclosingNode: e }) {
  return ri(e) ? (It(e, t), !0) : !1;
}
function Jm({ comment: t, enclosingNode: e, followingNode: r, ast: n, isLastComment: i }) {
  var s;
  return ((s = n == null ? void 0 : n.body) == null ? void 0 : s.length) === 0 ? (i ? br(n, t) : It(n, t), !0) : (e == null ? void 0 : e.type) === "Program" && e.body.length === 0 && !je(e.directives) ? (i ? br(e, t) : It(e, t), !0) : (r == null ? void 0 : r.type) === "Program" && r.body.length === 0 && (e == null ? void 0 : e.type) === "ModuleExpression" ? (br(r, t), !0) : !1;
}
function f4({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "ForInStatement" || (e == null ? void 0 : e.type) === "ForOfStatement" ? (It(e, t), !0) : !1;
}
function av({ comment: t, precedingNode: e, enclosingNode: r, text: n }) {
  if ((r == null ? void 0 : r.type) === "ImportSpecifier" || (r == null ? void 0 : r.type) === "ExportSpecifier")
    return It(r, t), !0;
  let i = (e == null ? void 0 : e.type) === "ImportSpecifier" && (r == null ? void 0 : r.type) === "ImportDeclaration", s = (e == null ? void 0 : e.type) === "ExportSpecifier" && (r == null ? void 0 : r.type) === "ExportNamedDeclaration";
  return (i || s) && xr(n, qe(t)) ? (ut(e, t), !0) : !1;
}
function m4({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "AssignmentPattern" ? (It(e, t), !0) : !1;
}
var g4 = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), y4 = /* @__PURE__ */ new Set(["ObjectExpression", "RecordExpression", "ArrayExpression", "TupleExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
function D4({ comment: t, enclosingNode: e, followingNode: r }) {
  return g4.has(e == null ? void 0 : e.type) && r && (y4.has(r.type) || qr(t)) ? (It(r, t), !0) : !1;
}
function x4({ comment: t, enclosingNode: e, followingNode: r, text: n }) {
  return !r && ((e == null ? void 0 : e.type) === "TSMethodSignature" || (e == null ? void 0 : e.type) === "TSDeclareFunction" || (e == null ? void 0 : e.type) === "TSAbstractMethodDefinition") && Hn(n, qe(t)) === ";" ? (ut(e, t), !0) : !1;
}
function lv({ comment: t, enclosingNode: e, followingNode: r }) {
  if (rc(t) && (e == null ? void 0 : e.type) === "TSMappedType" && (r == null ? void 0 : r.type) === "TSTypeParameter" && r.constraint)
    return e.prettierIgnore = !0, t.unignore = !0, !0;
}
function b4({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n }) {
  return (r == null ? void 0 : r.type) !== "TSMappedType" ? !1 : (n == null ? void 0 : n.type) === "TSTypeParameter" && n.name ? (It(n.name, t), !0) : (e == null ? void 0 : e.type) === "TSTypeParameter" && e.constraint ? (ut(e.constraint, t), !0) : !1;
}
function v4({ comment: t, enclosingNode: e, followingNode: r }) {
  return !e || e.type !== "SwitchCase" || e.test || !r || r !== e.consequent[0] ? !1 : (r.type === "BlockStatement" && uh(t) ? Ms(r, t) : br(e, t), !0);
}
function C4({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n }) {
  return ms(e) && ((r.type === "TSArrayType" || r.type === "ArrayTypeAnnotation") && !n || Vb(r)) ? (ut(We(!1, e.types, -1), t), !0) : !1;
}
function A4({ comment: t, enclosingNode: e, precedingNode: r, followingNode: n }) {
  if (((e == null ? void 0 : e.type) === "ObjectPattern" || (e == null ? void 0 : e.type) === "ArrayPattern") && (n == null ? void 0 : n.type) === "TSTypeAnnotation")
    return r ? ut(r, t) : br(e, t), !0;
}
var uv = Je(["ArrowFunctionExpression", "FunctionExpression", "FunctionDeclaration", "ObjectMethod", "ClassMethod", "TSDeclareFunction", "TSCallSignatureDeclaration", "TSConstructSignatureDeclaration", "TSMethodSignature", "TSConstructorType", "TSFunctionType", "TSDeclareMethod"]), E4 = /* @__PURE__ */ new Set(["EmptyStatement", "TemplateElement", "Import", "TSEmptyBodyFunctionExpression", "ChainExpression"]);
function w4(t) {
  return !E4.has(t.type);
}
function S4(t, e) {
  var r;
  if ((e.parser === "typescript" || e.parser === "flow" || e.parser === "acorn" || e.parser === "espree" || e.parser === "meriyah" || e.parser === "__babel_estree") && t.type === "MethodDefinition" && ((r = t.value) == null ? void 0 : r.type) === "FunctionExpression" && Wt(t.value).length === 0 && !t.value.returnType && !je(t.value.typeParameters) && t.value.body)
    return [...t.decorators || [], t.key, t.value.body];
}
function cv(t) {
  let { node: e, parent: r } = t;
  return (Dt(e) || r && (r.type === "JSXSpreadAttribute" || r.type === "JSXSpreadChild" || ms(r) || (r.type === "ClassDeclaration" || r.type === "ClassExpression") && r.superClass === e)) && (!dh(e) || ms(r));
}
function T4(t, { parser: e }) {
  if (e === "flow" || e === "babel-flow")
    return t = mr(!1, t, /[\s(]/g, ""), t === "" || t === "/*" || t === "/*::";
}
function k4(t) {
  switch (t) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
var er = Symbol("MODE_BREAK"), fn = Symbol("MODE_FLAT"), ka = Symbol("cursor");
function hv() {
  return { value: "", length: 0, queue: [] };
}
function F4(t, e) {
  return gd(t, { type: "indent" }, e);
}
function P4(t, e, r) {
  return e === Number.NEGATIVE_INFINITY ? t.root || hv() : e < 0 ? gd(t, { type: "dedent" }, r) : e ? e.type === "root" ? { ...t, root: t } : gd(t, { type: typeof e == "string" ? "stringAlign" : "numberAlign", n: e }, r) : t;
}
function gd(t, e, r) {
  let n = e.type === "dedent" ? t.queue.slice(0, -1) : [...t.queue, e], i = "", s = 0, o = 0, l = 0;
  for (let D of n)
    switch (D.type) {
      case "indent":
        p(), r.useTabs ? u(1) : h(r.tabWidth);
        break;
      case "stringAlign":
        p(), i += D.n, s += D.n.length;
        break;
      case "numberAlign":
        o += 1, l += D.n;
        break;
      default:
        throw new Error(`Unexpected type '${D.type}'`);
    }
  return m(), { ...t, value: i, length: s, queue: n };
  function u(D) {
    i += "	".repeat(D), s += r.tabWidth * D;
  }
  function h(D) {
    i += " ".repeat(D), s += D;
  }
  function p() {
    r.useTabs ? d() : m();
  }
  function d() {
    o > 0 && u(o), y();
  }
  function m() {
    l > 0 && h(l), y();
  }
  function y() {
    o = 0, l = 0;
  }
}
function yd(t) {
  let e = 0, r = 0, n = t.length;
  e:
    for (; n--; ) {
      let i = t[n];
      if (i === ka) {
        r++;
        continue;
      }
      for (let s = i.length - 1; s >= 0; s--) {
        let o = i[s];
        if (o === " " || o === "	")
          e++;
        else {
          t[n] = i.slice(0, s + 1);
          break e;
        }
      }
    }
  if (e > 0 || r > 0)
    for (t.length = n + 1; r-- > 0; )
      t.push(ka);
  return e;
}
function eu(t, e, r, n, i, s) {
  if (r === Number.POSITIVE_INFINITY)
    return !0;
  let o = e.length, l = [t], u = [];
  for (; r >= 0; ) {
    if (l.length === 0) {
      if (o === 0)
        return !0;
      l.push(e[--o]);
      continue;
    }
    let { mode: h, doc: p } = l.pop();
    switch (Lo(p)) {
      case No:
        u.push(p), r -= yo(p);
        break;
      case gs:
      case kn: {
        let d = Qb(p);
        for (let m = d.length - 1; m >= 0; m--)
          l.push({ mode: h, doc: d[m] });
        break;
      }
      case Fs:
      case Ps:
      case Bs:
      case Hi:
        l.push({ mode: h, doc: p.contents });
        break;
      case Oo:
        r += yd(u);
        break;
      case $r: {
        if (s && p.break)
          return !1;
        let d = p.break ? er : h, m = p.expandedStates && d === er ? We(!1, p.expandedStates, -1) : p.contents;
        l.push({ mode: d, doc: m });
        break;
      }
      case An: {
        let d = (p.groupId ? i[p.groupId] || fn : h) === er ? p.breakContents : p.flatContents;
        d && l.push({ mode: h, doc: d });
        break;
      }
      case Ar:
        if (h === er || p.hard)
          return !0;
        p.soft || (u.push(" "), r--);
        break;
      case Is:
        n = !0;
        break;
      case Ns:
        if (n)
          return !1;
        break;
    }
  }
  return !1;
}
function Dd(t, e) {
  let r = {}, n = e.printWidth, i = k4(e.endOfLine), s = 0, o = [{ ind: hv(), mode: er, doc: t }], l = [], u = !1, h = [], p = 0;
  for (_9(t); o.length > 0; ) {
    let { ind: m, mode: y, doc: D } = o.pop();
    switch (Lo(D)) {
      case No: {
        let b = i !== `
` ? mr(!1, D, `
`, i) : D;
        l.push(b), o.length > 0 && (s += yo(b));
        break;
      }
      case gs:
        for (let b = D.length - 1; b >= 0; b--)
          o.push({ ind: m, mode: y, doc: D[b] });
        break;
      case Mo:
        if (p >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        l.push(ka), p++;
        break;
      case Fs:
        o.push({ ind: F4(m, e), mode: y, doc: D.contents });
        break;
      case Ps:
        o.push({ ind: P4(m, D.n, e), mode: y, doc: D.contents });
        break;
      case Oo:
        s -= yd(l);
        break;
      case $r:
        switch (y) {
          case fn:
            if (!u) {
              o.push({ ind: m, mode: D.break ? er : fn, doc: D.contents });
              break;
            }
          case er: {
            u = !1;
            let b = { ind: m, mode: fn, doc: D.contents }, C = n - s, A = h.length > 0;
            if (!D.break && eu(b, o, C, A, r))
              o.push(b);
            else if (D.expandedStates) {
              let x = We(!1, D.expandedStates, -1);
              if (D.break) {
                o.push({ ind: m, mode: er, doc: x });
                break;
              } else
                for (let E = 1; E < D.expandedStates.length + 1; E++)
                  if (E >= D.expandedStates.length) {
                    o.push({ ind: m, mode: er, doc: x });
                    break;
                  } else {
                    let k = D.expandedStates[E], w = { ind: m, mode: fn, doc: k };
                    if (eu(w, o, C, A, r)) {
                      o.push(w);
                      break;
                    }
                  }
            } else
              o.push({ ind: m, mode: er, doc: D.contents });
            break;
          }
        }
        D.id && (r[D.id] = We(!1, o, -1).mode);
        break;
      case kn: {
        let b = n - s, { parts: C } = D;
        if (C.length === 0)
          break;
        let [A, x] = C, E = { ind: m, mode: fn, doc: A }, k = { ind: m, mode: er, doc: A }, w = eu(E, [], b, h.length > 0, r, !0);
        if (C.length === 1) {
          w ? o.push(E) : o.push(k);
          break;
        }
        let T = { ind: m, mode: fn, doc: x }, P = { ind: m, mode: er, doc: x };
        if (C.length === 2) {
          w ? o.push(T, E) : o.push(P, k);
          break;
        }
        C.splice(0, 2);
        let M = { ind: m, mode: y, doc: qm(C) }, N = C[0];
        eu({ ind: m, mode: fn, doc: [A, x, N] }, [], b, h.length > 0, r, !0) ? o.push(M, T, E) : w ? o.push(M, P, E) : o.push(M, P, k);
        break;
      }
      case An:
      case Bs: {
        let b = D.groupId ? r[D.groupId] : y;
        if (b === er) {
          let C = D.type === An ? D.breakContents : D.negate ? D.contents : te(D.contents);
          C && o.push({ ind: m, mode: y, doc: C });
        }
        if (b === fn) {
          let C = D.type === An ? D.flatContents : D.negate ? te(D.contents) : D.contents;
          C && o.push({ ind: m, mode: y, doc: C });
        }
        break;
      }
      case Is:
        h.push({ ind: m, mode: y, doc: D.contents });
        break;
      case Ns:
        h.length > 0 && o.push({ ind: m, mode: y, doc: Xb });
        break;
      case Ar:
        switch (y) {
          case fn:
            if (D.hard)
              u = !0;
            else {
              D.soft || (l.push(" "), s += 1);
              break;
            }
          case er:
            if (h.length > 0) {
              o.push({ ind: m, mode: y, doc: D }, ...h.reverse()), h.length = 0;
              break;
            }
            D.literal ? m.root ? (l.push(i, m.root.value), s = m.root.length) : (l.push(i), s = 0) : (s -= yd(l), l.push(i + m.value), s = m.length);
            break;
        }
        break;
      case Hi:
        o.push({ ind: m, mode: y, doc: D.contents });
        break;
      case Vi:
        break;
      default:
        throw new Ha(D);
    }
    o.length === 0 && h.length > 0 && (o.push(...h.reverse()), h.length = 0);
  }
  let d = l.indexOf(ka);
  if (d !== -1) {
    let m = l.indexOf(ka, d + 1), y = l.slice(0, d).join(""), D = l.slice(d + 1, m).join(""), b = l.slice(m + 1).join("");
    return { formatted: y + D + b, cursorNodeStart: y.length, cursorNodeText: D };
  }
  return { formatted: l.join("") };
}
function B4(t, e, r = 0) {
  let n = 0;
  for (let i = r; i < t.length; ++i)
    t[i] === "	" ? n = n + e - n % e : n++;
  return n;
}
var I4 = B4;
function N4(t, e) {
  let r = t.lastIndexOf(`
`);
  return r === -1 ? 0 : I4(t.slice(r + 1).match(/^[\t ]*/)[0], e);
}
var M4 = N4;
function pv(t, e, r) {
  let { node: n } = t;
  if (n.type === "TemplateLiteral" && $4(t)) {
    let h = L4(t, r, e);
    if (h)
      return h;
  }
  let i = "expressions";
  n.type === "TSTemplateLiteralType" && (i = "types");
  let s = [], o = t.map(e, i), l = m9(n);
  l && (o = o.map((h) => Dd(h, { ...r, printWidth: Number.POSITIVE_INFINITY }).formatted)), s.push(Un, "`");
  let u = 0;
  return t.each(({ index: h, node: p }) => {
    if (s.push(e()), p.tail)
      return;
    let { tabWidth: d } = r, m = p.value.raw, y = m.includes(`
`) ? M4(m, d) : u;
    u = y;
    let D = o[h];
    if (!l) {
      let C = n[i][h], A = Ni(r.originalText, qe(p), st(n.quasis[h + 1]));
      if (!A) {
        let x = Dd(D, { ...r, printWidth: Number.POSITIVE_INFINITY }).formatted;
        x.includes(`
`) ? A = !0 : D = x;
      }
      A && (se(C) || it(C) || C.type === "ConditionalExpression" || C.type === "SequenceExpression" || xn(C) || Wn(C)) && (D = [te([Y, D]), Y]);
    }
    let b = y === 0 && m.endsWith(`
`) ? Fn(Number.NEGATIVE_INFINITY, D) : O9(D, y, d);
    s.push(q(["${", b, Un, "}"]));
  }, "quasis"), s.push("`"), s;
}
function O4(t) {
  let e = t("quasi");
  return bl(e.label && { tagged: !0, ...e.label }, [t("tag"), t("typeParameters"), Un, e]);
}
function L4(t, e, r) {
  let { node: n } = t, i = n.quasis[0].value.raw.trim().split(/\s*\|\s*/);
  if (i.length > 1 || i.some((s) => s.length > 0)) {
    e.__inJestEach = !0;
    let s = t.map(r, "expressions");
    e.__inJestEach = !1;
    let o = [], l = s.map((m) => "${" + Dd(m, { ...e, printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" }).formatted + "}"), u = [{ hasLineBreak: !1, cells: [] }];
    for (let m = 1; m < n.quasis.length; m++) {
      let y = We(!1, u, -1), D = l[m - 1];
      y.cells.push(D), D.includes(`
`) && (y.hasLineBreak = !0), n.quasis[m].value.raw.includes(`
`) && u.push({ hasLineBreak: !1, cells: [] });
    }
    let h = Math.max(i.length, ...u.map((m) => m.cells.length)), p = Array.from({ length: h }).fill(0), d = [{ cells: i }, ...u.filter((m) => m.cells.length > 0)];
    for (let { cells: m } of d.filter((y) => !y.hasLineBreak))
      for (let [y, D] of m.entries())
        p[y] = Math.max(p[y], yo(D));
    return o.push(Un, "`", te([ee, Ne(ee, d.map((m) => Ne(" | ", m.cells.map((y, D) => m.hasLineBreak ? y : y + " ".repeat(p[D] - yo(y))))))]), ee, "`"), o;
  }
}
function _4(t, e) {
  let { node: r } = t, n = e();
  return se(r) && (n = q([te([Y, n]), Y])), ["${", n, Un, "}"];
}
function Km(t, e) {
  return t.map((r) => _4(r, e), "expressions");
}
function dv(t, e) {
  return _o(t, (r) => typeof r == "string" ? e ? mr(!1, r, /(\\*)`/g, "$1$1\\`") : fv(r) : r);
}
function fv(t) {
  return mr(!1, t, /([\\`]|\${)/g, "\\$1");
}
function $4({ node: t, parent: e }) {
  let r = /^[fx]?(?:describe|it|test)$/;
  return e.type === "TaggedTemplateExpression" && e.quasi === t && e.tag.type === "MemberExpression" && e.tag.property.type === "Identifier" && e.tag.property.name === "each" && (e.tag.object.type === "Identifier" && r.test(e.tag.object.name) || e.tag.object.type === "MemberExpression" && e.tag.object.property.type === "Identifier" && (e.tag.object.property.name === "only" || e.tag.object.property.name === "skip") && e.tag.object.object.type === "Identifier" && r.test(e.tag.object.object.name));
}
var xd = [(t, e) => t.type === "ObjectExpression" && e === "properties", (t, e) => t.type === "CallExpression" && t.callee.type === "Identifier" && t.callee.name === "Component" && e === "arguments", (t, e) => t.type === "Decorator" && e === "expression"];
function R4(t) {
  let e = (n) => n.type === "TemplateLiteral", r = (n, i) => ri(n) && !n.computed && n.key.type === "Identifier" && n.key.name === "styles" && i === "value";
  return t.match(e, (n, i) => Bt(n) && i === "elements", r, ...xd) || t.match(e, r, ...xd);
}
function j4(t) {
  return t.match((e) => e.type === "TemplateLiteral", (e, r) => ri(e) && !e.computed && e.key.type === "Identifier" && e.key.name === "template" && r === "value", ...xd);
}
function C0(t, e) {
  return se(t, de.Block | de.Leading, ({ value: r }) => r === ` ${e} `);
}
function mv({ node: t, parent: e }, r) {
  return C0(t, r) || q4(e) && C0(e, r);
}
function q4(t) {
  return t.type === "AsConstExpression" || t.type === "TSAsExpression" && t.typeAnnotation.type === "TSTypeReference" && t.typeAnnotation.typeName.type === "Identifier" && t.typeAnnotation.typeName.name === "const";
}
async function W4(t, e, r) {
  let { node: n } = r, i = n.quasis.map((p) => p.value.raw), s = 0, o = i.reduce((p, d, m) => m === 0 ? d : p + "@prettier-placeholder-" + s++ + "-id" + d, ""), l = await t(o, { parser: "scss" }), u = Km(r, e), h = U4(l, u);
  if (!h)
    throw new Error("Couldn't insert all the expressions");
  return ["`", te([ee, h]), Y, "`"];
}
function U4(t, e) {
  if (!je(e))
    return t;
  let r = 0, n = _o(Wm(t), (i) => typeof i != "string" || !i.includes("@prettier-placeholder") ? i : i.split(/@prettier-placeholder-(\d+)-id/).map((s, o) => o % 2 === 0 ? ys(s) : (r++, e[s])));
  return e.length === r ? n : null;
}
function H4({ node: t, parent: e, grandparent: r }) {
  return r && t.quasis && e.type === "JSXExpressionContainer" && r.type === "JSXElement" && r.openingElement.name.name === "style" && r.openingElement.attributes.some((n) => n.type === "JSXAttribute" && n.name.name === "jsx") || (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && e.tag.type === "Identifier" && e.tag.name === "css" || (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && e.tag.type === "MemberExpression" && e.tag.object.name === "css" && (e.tag.property.name === "global" || e.tag.property.name === "resolve");
}
function tu(t) {
  return t.type === "Identifier" && t.name === "styled";
}
function A0(t) {
  return /^[A-Z]/.test(t.object.name) && t.property.name === "extend";
}
function V4({ parent: t }) {
  if (!t || t.type !== "TaggedTemplateExpression")
    return !1;
  let e = t.tag.type === "ParenthesizedExpression" ? t.tag.expression : t.tag;
  switch (e.type) {
    case "MemberExpression":
      return tu(e.object) || A0(e);
    case "CallExpression":
      return tu(e.callee) || e.callee.type === "MemberExpression" && (e.callee.object.type === "MemberExpression" && (tu(e.callee.object.object) || A0(e.callee.object)) || e.callee.object.type === "CallExpression" && tu(e.callee.object.callee));
    case "Identifier":
      return e.name === "css";
    default:
      return !1;
  }
}
function z4({ parent: t, grandparent: e }) {
  return (e == null ? void 0 : e.type) === "JSXAttribute" && t.type === "JSXExpressionContainer" && e.name.type === "JSXIdentifier" && e.name.name === "css";
}
function J4(t) {
  if (H4(t) || V4(t) || z4(t) || R4(t))
    return W4;
}
var K4 = J4;
async function G4(t, e, r) {
  let { node: n } = r, i = n.quasis.length, s = Km(r, e), o = [];
  for (let l = 0; l < i; l++) {
    let u = n.quasis[l], h = l === 0, p = l === i - 1, d = u.value.cooked, m = d.split(`
`), y = m.length, D = s[l], b = y > 2 && m[0].trim() === "" && m[1].trim() === "", C = y > 2 && m[y - 1].trim() === "" && m[y - 2].trim() === "", A = m.every((E) => /^\s*(?:#[^\n\r]*)?$/.test(E));
    if (!p && /#[^\n\r]*$/.test(m[y - 1]))
      return null;
    let x = null;
    A ? x = X4(m) : x = await t(d, { parser: "graphql" }), x ? (x = dv(x, !1), !h && b && o.push(""), o.push(x), !p && C && o.push("")) : !h && !p && b && o.push(""), D && o.push(D);
  }
  return ["`", te([ee, Ne(ee, o)]), ee, "`"];
}
function X4(t) {
  let e = [], r = !1, n = t.map((i) => i.trim());
  for (let [i, s] of n.entries())
    s !== "" && (n[i - 1] === "" && r ? e.push([ee, s]) : e.push(s), r = !0);
  return e.length === 0 ? null : Ne(ee, e);
}
function Y4({ node: t, parent: e }) {
  return mv({ node: t, parent: e }, "GraphQL") || e && (e.type === "TaggedTemplateExpression" && (e.tag.type === "MemberExpression" && e.tag.object.name === "graphql" && e.tag.property.name === "experimental" || e.tag.type === "Identifier" && (e.tag.name === "gql" || e.tag.name === "graphql")) || e.type === "CallExpression" && e.callee.type === "Identifier" && e.callee.name === "graphql");
}
function Q4(t) {
  if (Y4(t))
    return G4;
}
var Z4 = Q4, hp = 0;
async function gv(t, e, r, n, i) {
  let { node: s } = n, o = hp;
  hp = hp + 1 >>> 0;
  let l = (A) => `PRETTIER_HTML_PLACEHOLDER_${A}_${o}_IN_JS`, u = s.quasis.map((A, x, E) => x === E.length - 1 ? A.value.cooked : A.value.cooked + l(x)).join(""), h = Km(n, r), p = new RegExp(l("(\\d+)"), "g"), d = 0, m = await e(u, { parser: t, __onHtmlRoot(A) {
    d = A.children.length;
  } }), y = _o(m, (A) => {
    if (typeof A != "string")
      return A;
    let x = [], E = A.split(p);
    for (let k = 0; k < E.length; k++) {
      let w = E[k];
      if (k % 2 === 0) {
        w && (w = fv(w), i.__embeddedInHtml && (w = mr(!1, w, /<\/(?=script\b)/gi, "<\\/")), x.push(w));
        continue;
      }
      let T = Number(w);
      x.push(h[T]);
    }
    return x;
  }), D = /^\s/.test(u) ? " " : "", b = /\s$/.test(u) ? " " : "", C = i.htmlWhitespaceSensitivity === "ignore" ? ee : D && b ? he : null;
  return C ? q(["`", te([C, q(y)]), C, "`"]) : bl({ hug: !1 }, q(["`", D, d > 1 ? te(q(y)) : q(y), b, "`"]));
}
function e6(t) {
  return mv(t, "HTML") || t.match((e) => e.type === "TemplateLiteral", (e, r) => e.type === "TaggedTemplateExpression" && e.tag.type === "Identifier" && e.tag.name === "html" && r === "quasi");
}
var t6 = gv.bind(void 0, "html"), r6 = gv.bind(void 0, "angular");
function n6(t) {
  if (e6(t))
    return t6;
  if (j4(t))
    return r6;
}
var i6 = n6;
async function s6(t, e, r) {
  let { node: n } = r, i = mr(!1, n.quasis[0].value.raw, /((?:\\\\)*)\\`/g, (u, h) => "\\".repeat(h.length / 2) + "`"), s = o6(i), o = s !== "";
  o && (i = mr(!1, i, new RegExp(`^${s}`, "gm"), ""));
  let l = dv(await t(i, { parser: "markdown", __inJsTemplate: !0 }), !0);
  return ["`", o ? te([Y, l]) : [Yb, N9(l)], Y, "`"];
}
function o6(t) {
  let e = t.match(/^([^\S\n]*)\S/m);
  return e === null ? "" : e[1];
}
function a6(t) {
  if (l6(t))
    return s6;
}
function l6({ node: t, parent: e }) {
  return (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && t.quasis.length === 1 && e.tag.type === "Identifier" && (e.tag.name === "md" || e.tag.name === "markdown");
}
var u6 = a6;
function c6(t) {
  let { node: e } = t;
  if (e.type !== "TemplateLiteral" || h6(e))
    return;
  let r;
  for (let n of [K4, Z4, i6, u6])
    if (r = n(t), !!r)
      return e.quasis.length === 1 && e.quasis[0].value.raw.trim() === "" ? "``" : async (...i) => {
        let s = await r(...i);
        return s && bl({ embed: !0, ...s.label }, s);
      };
}
function h6({ quasis: t }) {
  return t.some(({ value: { cooked: e } }) => e === null);
}
var p6 = c6, nc = fL(yL(), 1);
function d6(t) {
  if (!t.startsWith("#!"))
    return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var f6 = d6;
function m6(t) {
  let e = f6(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, nc.extract)(t), { pragmas: n, comments: i } = (0, nc.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: n, comments: i };
}
function g6(t) {
  let { shebang: e, text: r, pragmas: n, comments: i } = m6(t), s = (0, nc.strip)(r), o = (0, nc.print)({ pragmas: { format: "", ...n }, comments: i.trimStart() });
  return (e ? `${e}
` : "") + o + (s.startsWith(`
`) ? `
` : `

`) + s;
}
function y6(t, e) {
  let { originalText: r, [Symbol.for("comments")]: n, locStart: i, locEnd: s, [Symbol.for("printedComments")]: o } = e, { node: l } = t, u = i(l), h = s(l);
  for (let p of n)
    i(p) >= u && s(p) <= h && o.add(p);
  return r.slice(u, h);
}
var D6 = y6;
function bd(t, e) {
  var r, n, i, s, o, l, u;
  if (t.isRoot)
    return !1;
  let { node: h, key: p, parent: d } = t;
  if (e.__isInHtmlInterpolation && !e.bracketSpacing && C6(h) && da(t))
    return !0;
  if (x6(h))
    return !1;
  if (h.type === "Identifier") {
    if ((r = h.extra) != null && r.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(h.name) || p === "left" && (h.name === "async" && !d.await || h.name === "let") && d.type === "ForOfStatement")
      return !0;
    if (h.name === "let") {
      let m = (n = t.findAncestor((y) => y.type === "ForOfStatement")) == null ? void 0 : n.left;
      if (m && zt(m, (y) => y === h))
        return !0;
    }
    if (p === "object" && h.name === "let" && d.type === "MemberExpression" && d.computed && !d.optional) {
      let m = t.findAncestor((D) => D.type === "ExpressionStatement" || D.type === "ForStatement" || D.type === "ForInStatement"), y = m ? m.type === "ExpressionStatement" ? m.expression : m.type === "ForStatement" ? m.init : m.left : void 0;
      if (y && zt(y, (D) => D === h))
        return !0;
    }
    if (p === "expression")
      switch (h.name) {
        case "await":
        case "interface":
        case "module":
        case "using":
        case "yield":
        case "let":
        case "type": {
          let m = t.findAncestor((y) => !xn(y));
          if (m !== d && m.type === "ExpressionStatement")
            return !0;
        }
      }
    return !1;
  }
  if (h.type === "ObjectExpression" || h.type === "FunctionExpression" || h.type === "ClassExpression" || h.type === "DoExpression") {
    let m = (i = t.findAncestor((y) => y.type === "ExpressionStatement")) == null ? void 0 : i.expression;
    if (m && zt(m, (y) => y === h))
      return !0;
  }
  if (h.type === "ObjectExpression") {
    let m = (s = t.findAncestor((y) => y.type === "ArrowFunctionExpression")) == null ? void 0 : s.body;
    if (m && m.type !== "SequenceExpression" && m.type !== "AssignmentExpression" && zt(m, (y) => y === h))
      return !0;
  }
  switch (d.type) {
    case "ParenthesizedExpression":
      return !1;
    case "ClassDeclaration":
    case "ClassExpression":
      if (p === "superClass" && (h.type === "ArrowFunctionExpression" || h.type === "AssignmentExpression" || h.type === "AwaitExpression" || h.type === "BinaryExpression" || h.type === "ConditionalExpression" || h.type === "LogicalExpression" || h.type === "NewExpression" || h.type === "ObjectExpression" || h.type === "SequenceExpression" || h.type === "TaggedTemplateExpression" || h.type === "UnaryExpression" || h.type === "UpdateExpression" || h.type === "YieldExpression" || h.type === "TSNonNullExpression" || h.type === "ClassExpression" && je(h.decorators)))
        return !0;
      break;
    case "ExportDefaultDeclaration":
      return yv(t, e) || h.type === "SequenceExpression";
    case "Decorator":
      if (p === "expression") {
        if (it(h) && h.computed)
          return !0;
        let m = !1, y = !1, D = h;
        for (; D; )
          switch (D.type) {
            case "MemberExpression":
              y = !0, D = D.object;
              break;
            case "CallExpression":
              if (y || m)
                return e.parser !== "typescript";
              m = !0, D = D.callee;
              break;
            case "Identifier":
              return !1;
            case "TaggedTemplateExpression":
              return e.parser !== "typescript";
            default:
              return !0;
          }
        return !0;
      }
      break;
    case "TypeAnnotation":
      if (t.match(void 0, void 0, (m, y) => y === "returnType" && m.type === "ArrowFunctionExpression") && v6(h))
        return !0;
      break;
    case "BinaryExpression":
      if (p === "left" && (d.operator === "in" || d.operator === "instanceof") && h.type === "UnaryExpression")
        return !0;
      break;
  }
  switch (h.type) {
    case "UpdateExpression":
      if (d.type === "UnaryExpression")
        return h.prefix && (h.operator === "++" && d.operator === "+" || h.operator === "--" && d.operator === "-");
    case "UnaryExpression":
      switch (d.type) {
        case "UnaryExpression":
          return h.operator === d.operator && (h.operator === "+" || h.operator === "-");
        case "BindExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return p === "object";
        case "TaggedTemplateExpression":
          return !0;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return p === "callee";
        case "BinaryExpression":
          return p === "left" && d.operator === "**";
        case "TSNonNullExpression":
          return !0;
        default:
          return !1;
      }
    case "BinaryExpression":
      if (d.type === "UpdateExpression" || h.operator === "in" && b6(t))
        return !0;
      if (h.operator === "|>" && (o = h.extra) != null && o.parenthesized) {
        let m = t.grandparent;
        if (m.type === "BinaryExpression" && m.operator === "|>")
          return !0;
      }
    case "TSTypeAssertion":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
    case "LogicalExpression":
      switch (d.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
          return !xn(h);
        case "ConditionalExpression":
          return xn(h);
        case "CallExpression":
        case "NewExpression":
        case "OptionalCallExpression":
          return p === "callee";
        case "ClassExpression":
        case "ClassDeclaration":
          return p === "superClass";
        case "TSTypeAssertion":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "JSXSpreadAttribute":
        case "SpreadElement":
        case "BindExpression":
        case "AwaitExpression":
        case "TSNonNullExpression":
        case "UpdateExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return p === "object";
        case "AssignmentExpression":
        case "AssignmentPattern":
          return p === "left" && (h.type === "TSTypeAssertion" || xn(h));
        case "LogicalExpression":
          if (h.type === "LogicalExpression")
            return d.operator !== h.operator;
        case "BinaryExpression": {
          let { operator: m, type: y } = h;
          if (!m && y !== "TSTypeAssertion")
            return !0;
          let D = tc(m), b = d.operator, C = tc(b);
          return C > D || p === "right" && C === D || C === D && !Rm(b, m) ? !0 : C < D && m === "%" ? b === "+" || b === "-" : !!v9(b);
        }
        default:
          return !1;
      }
    case "SequenceExpression":
      switch (d.type) {
        case "ReturnStatement":
          return !1;
        case "ForStatement":
          return !1;
        case "ExpressionStatement":
          return p !== "expression";
        case "ArrowFunctionExpression":
          return p !== "body";
        default:
          return !0;
      }
    case "YieldExpression":
      if (d.type === "AwaitExpression")
        return !0;
    case "AwaitExpression":
      switch (d.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "SpreadElement":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "BindExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return p === "object";
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return p === "callee";
        case "ConditionalExpression":
          return p === "test";
        case "BinaryExpression":
          return !(!h.argument && d.operator === "|>");
        default:
          return !1;
      }
    case "TSFunctionType":
      if (t.match((m) => m.type === "TSFunctionType", (m, y) => y === "typeAnnotation" && m.type === "TSTypeAnnotation", (m, y) => y === "returnType" && m.type === "ArrowFunctionExpression"))
        return !0;
    case "TSConditionalType":
    case "TSConstructorType":
      if (p === "extendsType" && d.type === "TSConditionalType") {
        if (h.type === "TSConditionalType")
          return !0;
        let { typeAnnotation: m } = h.returnType || h.typeAnnotation;
        if (m.type === "TSTypePredicate" && m.typeAnnotation && (m = m.typeAnnotation.typeAnnotation), m.type === "TSInferType" && m.typeParameter.constraint)
          return !0;
      }
      if (p === "checkType" && d.type === "TSConditionalType")
        return !0;
    case "TSUnionType":
    case "TSIntersectionType":
      if ((d.type === "TSUnionType" || d.type === "TSIntersectionType") && d.types.length > 1 && (!h.types || h.types.length > 1))
        return !0;
    case "TSInferType":
      if (h.type === "TSInferType" && d.type === "TSRestType")
        return !1;
    case "TSTypeOperator":
      return d.type === "TSArrayType" || d.type === "TSOptionalType" || d.type === "TSRestType" || p === "objectType" && d.type === "TSIndexedAccessType" || d.type === "TSTypeOperator" || d.type === "TSTypeAnnotation" && t.grandparent.type.startsWith("TSJSDoc");
    case "TSTypeQuery":
      return p === "objectType" && d.type === "TSIndexedAccessType" || p === "elementType" && d.type === "TSArrayType";
    case "TypeofTypeAnnotation":
      return p === "objectType" && (d.type === "IndexedAccessType" || d.type === "OptionalIndexedAccessType") || p === "elementType" && d.type === "ArrayTypeAnnotation";
    case "ArrayTypeAnnotation":
      return d.type === "NullableTypeAnnotation";
    case "IntersectionTypeAnnotation":
    case "UnionTypeAnnotation":
      return d.type === "ArrayTypeAnnotation" || d.type === "NullableTypeAnnotation" || d.type === "IntersectionTypeAnnotation" || d.type === "UnionTypeAnnotation" || p === "objectType" && (d.type === "IndexedAccessType" || d.type === "OptionalIndexedAccessType");
    case "InferTypeAnnotation":
    case "NullableTypeAnnotation":
      return d.type === "ArrayTypeAnnotation" || p === "objectType" && (d.type === "IndexedAccessType" || d.type === "OptionalIndexedAccessType");
    case "FunctionTypeAnnotation": {
      if (t.match(void 0, (y, D) => D === "typeAnnotation" && y.type === "TypeAnnotation", (y, D) => D === "returnType" && y.type === "ArrowFunctionExpression") || t.match(void 0, (y, D) => D === "typeAnnotation" && y.type === "TypePredicate", (y, D) => D === "typeAnnotation" && y.type === "TypeAnnotation", (y, D) => D === "returnType" && y.type === "ArrowFunctionExpression"))
        return !0;
      let m = d.type === "NullableTypeAnnotation" ? t.grandparent : d;
      return m.type === "UnionTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "ArrayTypeAnnotation" || p === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType") || p === "checkType" && d.type === "ConditionalTypeAnnotation" || p === "extendsType" && d.type === "ConditionalTypeAnnotation" && h.returnType.type === "InferTypeAnnotation" && h.returnType.typeParameter.bound || m.type === "NullableTypeAnnotation" || d.type === "FunctionTypeParam" && d.name === null && Wt(h).some((y) => {
        var D;
        return ((D = y.typeAnnotation) == null ? void 0 : D.type) === "NullableTypeAnnotation";
      });
    }
    case "ConditionalTypeAnnotation":
      if (p === "extendsType" && d.type === "ConditionalTypeAnnotation" && h.type === "ConditionalTypeAnnotation" || p === "checkType" && d.type === "ConditionalTypeAnnotation")
        return !0;
    case "OptionalIndexedAccessType":
      return p === "objectType" && d.type === "IndexedAccessType";
    case "StringLiteral":
    case "NumericLiteral":
    case "Literal":
      if (typeof h.value == "string" && d.type === "ExpressionStatement" && !d.directive) {
        let m = t.grandparent;
        return m.type === "Program" || m.type === "BlockStatement";
      }
      return p === "object" && d.type === "MemberExpression" && typeof h.value == "number";
    case "AssignmentExpression": {
      let m = t.grandparent;
      return p === "body" && d.type === "ArrowFunctionExpression" ? !0 : p === "key" && (d.type === "ClassProperty" || d.type === "PropertyDefinition") && d.computed || (p === "init" || p === "update") && d.type === "ForStatement" ? !1 : d.type === "ExpressionStatement" ? h.left.type === "ObjectPattern" : !(p === "key" && d.type === "TSPropertySignature" || d.type === "AssignmentExpression" || d.type === "SequenceExpression" && m.type === "ForStatement" && (m.init === d || m.update === d) || p === "value" && d.type === "Property" && m.type === "ObjectPattern" && m.properties.includes(d) || d.type === "NGChainedExpression");
    }
    case "ConditionalExpression":
      switch (d.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "BinaryExpression":
        case "LogicalExpression":
        case "NGPipeExpression":
        case "ExportDefaultDeclaration":
        case "AwaitExpression":
        case "JSXSpreadAttribute":
        case "TSTypeAssertion":
        case "TypeCastExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "TSNonNullExpression":
          return !0;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return p === "callee";
        case "ConditionalExpression":
          return e.experimentalTernaries ? !1 : p === "test";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return p === "object";
        default:
          return !1;
      }
    case "FunctionExpression":
      switch (d.type) {
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return p === "callee";
        case "TaggedTemplateExpression":
          return !0;
        default:
          return !1;
      }
    case "ArrowFunctionExpression":
      switch (d.type) {
        case "BinaryExpression":
          return d.operator !== "|>" || ((l = h.extra) == null ? void 0 : l.parenthesized);
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return p === "callee";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return p === "object";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "TSNonNullExpression":
        case "BindExpression":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "AwaitExpression":
        case "TSTypeAssertion":
          return !0;
        case "ConditionalExpression":
          return p === "test";
        default:
          return !1;
      }
    case "ClassExpression":
      switch (d.type) {
        case "NewExpression":
          return p === "callee";
        default:
          return !1;
      }
    case "OptionalMemberExpression":
    case "OptionalCallExpression":
    case "CallExpression":
    case "MemberExpression":
      if (A6(t))
        return !0;
    case "TaggedTemplateExpression":
    case "TSNonNullExpression":
      if (p === "callee" && (d.type === "BindExpression" || d.type === "NewExpression")) {
        let m = h;
        for (; m; )
          switch (m.type) {
            case "CallExpression":
            case "OptionalCallExpression":
              return !0;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "BindExpression":
              m = m.object;
              break;
            case "TaggedTemplateExpression":
              m = m.tag;
              break;
            case "TSNonNullExpression":
              m = m.expression;
              break;
            default:
              return !1;
          }
      }
      return !1;
    case "BindExpression":
      return p === "callee" && (d.type === "BindExpression" || d.type === "NewExpression") || p === "object" && it(d);
    case "NGPipeExpression":
      return !(d.type === "NGRoot" || d.type === "NGMicrosyntaxExpression" || d.type === "ObjectProperty" && !((u = h.extra) != null && u.parenthesized) || Bt(d) || p === "arguments" && Re(d) || p === "right" && d.type === "NGPipeExpression" || p === "property" && d.type === "MemberExpression" || d.type === "AssignmentExpression");
    case "JSXFragment":
    case "JSXElement":
      return p === "callee" || p === "left" && d.type === "BinaryExpression" && d.operator === "<" || !Bt(d) && d.type !== "ArrowFunctionExpression" && d.type !== "AssignmentExpression" && d.type !== "AssignmentPattern" && d.type !== "BinaryExpression" && d.type !== "NewExpression" && d.type !== "ConditionalExpression" && d.type !== "ExpressionStatement" && d.type !== "JsExpressionRoot" && d.type !== "JSXAttribute" && d.type !== "JSXElement" && d.type !== "JSXExpressionContainer" && d.type !== "JSXFragment" && d.type !== "LogicalExpression" && !Re(d) && !ri(d) && d.type !== "ReturnStatement" && d.type !== "ThrowStatement" && d.type !== "TypeCastExpression" && d.type !== "VariableDeclarator" && d.type !== "YieldExpression";
    case "TSInstantiationExpression":
      return p === "object" && it(d);
  }
  return !1;
}
var x6 = Je(["BlockStatement", "BreakStatement", "ClassBody", "ClassDeclaration", "ClassMethod", "ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ContinueStatement", "DebuggerStatement", "DeclareClass", "DeclareExportAllDeclaration", "DeclareExportDeclaration", "DeclareFunction", "DeclareInterface", "DeclareModule", "DeclareModuleExports", "DeclareVariable", "DeclareEnum", "DoWhileStatement", "EnumDeclaration", "ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FunctionDeclaration", "IfStatement", "ImportDeclaration", "InterfaceDeclaration", "LabeledStatement", "MethodDefinition", "ReturnStatement", "SwitchStatement", "ThrowStatement", "TryStatement", "TSDeclareFunction", "TSEnumDeclaration", "TSImportEqualsDeclaration", "TSInterfaceDeclaration", "TSModuleDeclaration", "TSNamespaceExportDeclaration", "TypeAlias", "VariableDeclaration", "WhileStatement", "WithStatement"]);
function b6(t) {
  let e = 0, { node: r } = t;
  for (; r; ) {
    let n = t.getParentNode(e++);
    if ((n == null ? void 0 : n.type) === "ForStatement" && n.init === r)
      return !0;
    r = n;
  }
  return !1;
}
function v6(t) {
  return cd(t, (e) => e.type === "ObjectTypeAnnotation" && cd(e, (r) => r.type === "FunctionTypeAnnotation"));
}
function C6(t) {
  return tn(t);
}
function da(t) {
  let { parent: e, key: r } = t;
  switch (e.type) {
    case "NGPipeExpression":
      if (r === "arguments" && t.isLast)
        return t.callParent(da);
      break;
    case "ObjectProperty":
      if (r === "value")
        return t.callParent(() => t.key === "properties" && t.isLast);
      break;
    case "BinaryExpression":
    case "LogicalExpression":
      if (r === "right")
        return t.callParent(da);
      break;
    case "ConditionalExpression":
      if (r === "alternate")
        return t.callParent(da);
      break;
    case "UnaryExpression":
      if (e.prefix)
        return t.callParent(da);
      break;
  }
  return !1;
}
function yv(t, e) {
  let { node: r, parent: n } = t;
  return r.type === "FunctionExpression" || r.type === "ClassExpression" ? n.type === "ExportDefaultDeclaration" || !bd(t, e) : !Lm(r) || n.type !== "ExportDefaultDeclaration" && bd(t, e) ? !1 : t.call(() => yv(t, e), ...Ib(r));
}
function A6(t) {
  let { node: e, parent: r, grandparent: n, key: i } = t;
  return !!((e.type === "OptionalMemberExpression" || e.type === "OptionalCallExpression") && (i === "object" && r.type === "MemberExpression" || i === "callee" && (r.type === "CallExpression" || r.type === "NewExpression") || r.type === "TSNonNullExpression" && n.type === "MemberExpression" && n.object === r) || t.match(() => e.type === "CallExpression" || e.type === "MemberExpression", (s, o) => o === "expression" && s.type === "ChainExpression") && (t.match(void 0, void 0, (s, o) => o === "callee" && (s.type === "CallExpression" && !s.optional || s.type === "NewExpression") || o === "object" && s.type === "MemberExpression" && !s.optional) || t.match(void 0, void 0, (s, o) => o === "expression" && s.type === "TSNonNullExpression", (s, o) => o === "object" && s.type === "MemberExpression")) || t.match(() => e.type === "CallExpression" || e.type === "MemberExpression", (s, o) => o === "expression" && s.type === "TSNonNullExpression", (s, o) => o === "expression" && s.type === "ChainExpression", (s, o) => o === "object" && s.type === "MemberExpression"));
}
var Os = bd;
function E6(t, e) {
  let r = e - 1;
  r = Do(t, r, { backwards: !0 }), r = xo(t, r, { backwards: !0 }), r = Do(t, r, { backwards: !0 });
  let n = xo(t, r, { backwards: !0 });
  return r !== n;
}
var w6 = E6, S6 = () => !0;
function Gm(t, e) {
  let r = t.node;
  return r.printed = !0, e.printer.printComment(t, e);
}
function T6(t, e) {
  var r;
  let n = t.node, i = [Gm(t, e)], { printer: s, originalText: o, locStart: l, locEnd: u } = e;
  if ((r = s.isBlockComment) != null && r.call(s, n)) {
    let p = xr(o, u(n)) ? xr(o, l(n), { backwards: !0 }) ? ee : he : " ";
    i.push(p);
  } else
    i.push(ee);
  let h = xo(o, Do(o, u(n)));
  return h !== !1 && xr(o, h) && i.push(ee), i;
}
function k6(t, e, r) {
  var n;
  let i = t.node, s = Gm(t, e), { printer: o, originalText: l, locStart: u } = e, h = (n = o.isBlockComment) == null ? void 0 : n.call(o, i);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || xr(l, u(i), { backwards: !0 })) {
    let p = w6(l, u(i));
    return { doc: x0([ee, p ? ee : "", s]), isBlock: h, hasLineSuffix: !0 };
  }
  return !h || r != null && r.hasLineSuffix ? { doc: [x0([" ", s]), Pn], isBlock: h, hasLineSuffix: !0 } : { doc: [" ", s], isBlock: h, hasLineSuffix: !1 };
}
function ot(t, e, r = {}) {
  let { node: n } = t;
  if (!je(n == null ? void 0 : n.comments))
    return "";
  let { indent: i = !1, marker: s, filter: o = S6 } = r, l = [];
  if (t.each(({ node: h }) => {
    h.leading || h.trailing || h.marker !== s || !o(h) || l.push(Gm(t, e));
  }, "comments"), l.length === 0)
    return "";
  let u = Ne(ee, l);
  return i ? te([ee, u]) : u;
}
function Dv(t, e) {
  let r = t.node;
  if (!r)
    return {};
  let n = e[Symbol.for("printedComments")];
  if ((r.comments || []).filter((l) => !n.has(l)).length === 0)
    return { leading: "", trailing: "" };
  let i = [], s = [], o;
  return t.each(() => {
    let l = t.node;
    if (n != null && n.has(l))
      return;
    let { leading: u, trailing: h } = l;
    u ? i.push(T6(t, e)) : h && (o = k6(t, e, o), s.push(o.doc));
  }, "comments"), { leading: i, trailing: s };
}
function en(t, e, r) {
  let { leading: n, trailing: i } = Dv(t, r);
  return !n && !i ? e : fd(e, (s) => [n, s, i]);
}
var F6 = class extends Error {
  constructor(r, n, i = "type") {
    super(`Unexpected ${n} node ${i}: ${JSON.stringify(r[i])}.`);
    Vr(this, "name", "UnexpectedNodeError");
    this.node = r;
  }
}, $o = F6;
function P6(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var Jr, B6 = class {
  constructor(e) {
    mL(this, Jr, void 0), gL(this, Jr, new Set(e));
  }
  getLeadingWhitespaceCount(e) {
    let r = hi(this, Jr), n = 0;
    for (let i = 0; i < e.length && r.has(e.charAt(i)); i++)
      n++;
    return n;
  }
  getTrailingWhitespaceCount(e) {
    let r = hi(this, Jr), n = 0;
    for (let i = e.length - 1; i >= 0 && r.has(e.charAt(i)); i--)
      n++;
    return n;
  }
  getLeadingWhitespace(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(0, r);
  }
  getTrailingWhitespace(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(e.length - r);
  }
  hasLeadingWhitespace(e) {
    return hi(this, Jr).has(e.charAt(0));
  }
  hasTrailingWhitespace(e) {
    return hi(this, Jr).has(We(!1, e, -1));
  }
  trimStart(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(r);
  }
  trimEnd(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(0, e.length - r);
  }
  trim(e) {
    return this.trimEnd(this.trimStart(e));
  }
  split(e, r = !1) {
    let n = `[${P6([...hi(this, Jr)].join(""))}]+`, i = new RegExp(r ? `(${n})` : n);
    return e.split(i);
  }
  hasWhitespaceCharacter(e) {
    let r = hi(this, Jr);
    return Array.prototype.some.call(e, (n) => r.has(n));
  }
  hasNonWhitespaceCharacter(e) {
    let r = hi(this, Jr);
    return Array.prototype.some.call(e, (n) => !r.has(n));
  }
  isWhitespaceOnly(e) {
    let r = hi(this, Jr);
    return Array.prototype.every.call(e, (n) => r.has(n));
  }
};
Jr = /* @__PURE__ */ new WeakMap();
var I6 = B6, Mu = new I6(` 
\r	`), pp = (t) => t === "" || t === he || t === ee || t === Y;
function N6(t, e, r) {
  var n, i, s;
  let { node: o } = t;
  if (o.type === "JSXElement" && K6(o))
    return [r("openingElement"), r("closingElement")];
  let l = o.type === "JSXElement" ? r("openingElement") : r("openingFragment"), u = o.type === "JSXElement" ? r("closingElement") : r("closingFragment");
  if (o.children.length === 1 && o.children[0].type === "JSXExpressionContainer" && (o.children[0].expression.type === "TemplateLiteral" || o.children[0].expression.type === "TaggedTemplateExpression"))
    return [l, ...t.map(r, "children"), u];
  o.children = o.children.map((T) => G6(T) ? { type: "JSXText", value: " ", raw: " " } : T);
  let h = o.children.some(Dt), p = o.children.filter((T) => T.type === "JSXExpressionContainer").length > 1, d = o.type === "JSXElement" && o.openingElement.attributes.length > 1, m = Jt(l) || h || d || p, y = t.parent.rootMarker === "mdx", D = e.singleQuote ? "{' '}" : '{" "}', b = y ? " " : we([D, Y], " "), C = ((i = (n = o.openingElement) == null ? void 0 : n.name) == null ? void 0 : i.name) === "fbt", A = M6(t, e, r, b, C), x = o.children.some((T) => Va(T));
  for (let T = A.length - 2; T >= 0; T--) {
    let P = A[T] === "" && A[T + 1] === "", M = A[T] === ee && A[T + 1] === "" && A[T + 2] === ee, N = (A[T] === Y || A[T] === ee) && A[T + 1] === "" && A[T + 2] === b, L = A[T] === b && A[T + 1] === "" && (A[T + 2] === Y || A[T + 2] === ee), j = A[T] === b && A[T + 1] === "" && A[T + 2] === b, X = A[T] === Y && A[T + 1] === "" && A[T + 2] === ee || A[T] === ee && A[T + 1] === "" && A[T + 2] === Y;
    M && x || P || N || j || X ? A.splice(T, 2) : L && A.splice(T + 1, 2);
  }
  for (; A.length > 0 && pp(We(!1, A, -1)); )
    A.pop();
  for (; A.length > 1 && pp(A[0]) && pp(A[1]); )
    A.shift(), A.shift();
  let E = [];
  for (let [T, P] of A.entries()) {
    if (P === b) {
      if (T === 1 && A[T - 1] === "") {
        if (A.length === 2) {
          E.push(D);
          continue;
        }
        E.push([D, ee]);
        continue;
      } else if (T === A.length - 1) {
        E.push(D);
        continue;
      } else if (A[T - 1] === "" && A[T - 2] === ee) {
        E.push(D);
        continue;
      }
    }
    E.push(P), Jt(P) && (m = !0);
  }
  let k = x ? qm(E) : q(E, { shouldBreak: !0 });
  if (((s = e.cursorNode) == null ? void 0 : s.type) === "JSXText" && o.children.includes(e.cursorNode) && (k = [b0, k, b0]), y)
    return k;
  let w = q([l, te([ee, k]), ee, u]);
  return m ? w : is([q([l, ...A, u]), w]);
}
function M6(t, e, r, n, i) {
  let s = [];
  return t.each(({ node: o, next: l }) => {
    if (o.type === "JSXText") {
      let u = Lr(o);
      if (Va(o)) {
        let h = Mu.split(u, !0);
        h[0] === "" && (s.push(""), h.shift(), /\n/.test(h[0]) ? s.push(w0(i, h[1], o, l)) : s.push(n), h.shift());
        let p;
        if (We(!1, h, -1) === "" && (h.pop(), p = h.pop()), h.length === 0)
          return;
        for (let [d, m] of h.entries())
          d % 2 === 1 ? s.push(he) : s.push(m);
        p !== void 0 ? /\n/.test(p) ? s.push(w0(i, We(!1, s, -1), o, l)) : s.push(n) : s.push(E0(i, We(!1, s, -1), o, l));
      } else
        /\n/.test(u) ? u.match(/\n/g).length > 1 && s.push("", ee) : s.push("", n);
    } else {
      let u = r();
      if (s.push(u), l && Va(l)) {
        let h = Mu.trim(Lr(l)), [p] = Mu.split(h);
        s.push(E0(i, p, o, l));
      } else
        s.push(ee);
    }
  }, "children"), s;
}
function E0(t, e, r, n) {
  return t ? "" : r.type === "JSXElement" && !r.closingElement || (n == null ? void 0 : n.type) === "JSXElement" && !n.closingElement ? e.length === 1 ? Y : ee : Y;
}
function w0(t, e, r, n) {
  return t ? ee : e.length === 1 ? r.type === "JSXElement" && !r.closingElement || (n == null ? void 0 : n.type) === "JSXElement" && !n.closingElement ? ee : Y : ee;
}
var O6 = /* @__PURE__ */ new Set(["ArrayExpression", "TupleExpression", "JSXAttribute", "JSXElement", "JSXExpressionContainer", "JSXFragment", "ExpressionStatement", "CallExpression", "OptionalCallExpression", "ConditionalExpression", "JsExpressionRoot"]);
function L6(t, e, r) {
  let { parent: n } = t;
  if (O6.has(n.type))
    return e;
  let i = t.match(void 0, (o) => o.type === "ArrowFunctionExpression", Re, (o) => o.type === "JSXExpressionContainer"), s = Os(t, r);
  return q([s ? "" : we("("), te([Y, e]), Y, s ? "" : we(")")], { shouldBreak: i });
}
function _6(t, e, r) {
  let { node: n } = t, i = [];
  if (i.push(r("name")), n.value) {
    let s;
    if (ir(n.value)) {
      let o = Lr(n.value), l = mr(!1, mr(!1, o.slice(1, -1), "&apos;", "'"), "&quot;", '"'), u = Tb(l, e.jsxSingleQuote);
      l = u === '"' ? mr(!1, l, '"', "&quot;") : mr(!1, l, "'", "&apos;"), s = t.call(() => en(t, ys(u + l + u), e), "value");
    } else
      s = r("value");
    i.push("=", s);
  }
  return i;
}
function $6(t, e, r) {
  let { node: n } = t, i = (s, o) => s.type === "JSXEmptyExpression" || !se(s) && (Bt(s) || tn(s) || s.type === "ArrowFunctionExpression" || s.type === "AwaitExpression" && (i(s.argument, s) || s.argument.type === "JSXElement") || Re(s) || s.type === "ChainExpression" && Re(s.expression) || s.type === "FunctionExpression" || s.type === "TemplateLiteral" || s.type === "TaggedTemplateExpression" || s.type === "DoExpression" || Dt(o) && (s.type === "ConditionalExpression" || Wn(s)));
  return i(n.expression, t.parent) ? q(["{", r("expression"), Un, "}"]) : q(["{", te([Y, r("expression")]), Y, Un, "}"]);
}
function R6(t, e, r) {
  var n, i;
  let { node: s } = t, o = se(s.name) || se(s.typeParameters) || se(s.typeArguments);
  if (s.selfClosing && s.attributes.length === 0 && !o)
    return ["<", r("name"), s.typeArguments ? r("typeArguments") : r("typeParameters"), " />"];
  if (((n = s.attributes) == null ? void 0 : n.length) === 1 && s.attributes[0].value && ir(s.attributes[0].value) && !s.attributes[0].value.value.includes(`
`) && !o && !se(s.attributes[0]))
    return q(["<", r("name"), s.typeArguments ? r("typeArguments") : r("typeParameters"), " ", ...t.map(r, "attributes"), s.selfClosing ? " />" : ">"]);
  let l = (i = s.attributes) == null ? void 0 : i.some((h) => h.value && ir(h.value) && h.value.value.includes(`
`)), u = e.singleAttributePerLine && s.attributes.length > 1 ? ee : he;
  return q(["<", r("name"), s.typeArguments ? r("typeArguments") : r("typeParameters"), te(t.map(() => [u, r()], "attributes")), ...j6(s, e, o)], { shouldBreak: l });
}
function j6(t, e, r) {
  return t.selfClosing ? [he, "/>"] : q6(t, e, r) ? [">"] : [Y, ">"];
}
function q6(t, e, r) {
  let n = t.attributes.length > 0 && se(We(!1, t.attributes, -1), de.Trailing);
  return t.attributes.length === 0 && !r || (e.bracketSameLine || e.jsxBracketSameLine) && (!r || t.attributes.length > 0) && !n;
}
function W6(t, e, r) {
  let { node: n } = t, i = [];
  i.push("</");
  let s = r("name");
  return se(n.name, de.Leading | de.Line) ? i.push(te([ee, s]), ee) : se(n.name, de.Leading | de.Block) ? i.push(" ", s) : i.push(s), i.push(">"), i;
}
function U6(t, e) {
  let { node: r } = t, n = se(r), i = se(r, de.Line), s = r.type === "JSXOpeningFragment";
  return [s ? "<" : "</", te([i ? ee : n && !s ? " " : "", ot(t, e)]), i ? ee : "", ">"];
}
function H6(t, e, r) {
  let n = en(t, N6(t, e, r), e);
  return L6(t, n, e);
}
function V6(t, e) {
  let { node: r } = t, n = se(r, de.Line);
  return [ot(t, e, { indent: n }), n ? ee : ""];
}
function z6(t, e, r) {
  let { node: n } = t;
  return ["{", t.call(({ node: i }) => {
    let s = ["...", r()];
    return !se(i) || !cv(t) ? s : [te([Y, en(t, s, e)]), Y];
  }, n.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
}
function J6(t, e, r) {
  let { node: n } = t;
  if (n.type.startsWith("JSX"))
    switch (n.type) {
      case "JSXAttribute":
        return _6(t, e, r);
      case "JSXIdentifier":
        return n.name;
      case "JSXNamespacedName":
        return Ne(":", [r("namespace"), r("name")]);
      case "JSXMemberExpression":
        return Ne(".", [r("object"), r("property")]);
      case "JSXSpreadAttribute":
      case "JSXSpreadChild":
        return z6(t, e, r);
      case "JSXExpressionContainer":
        return $6(t, e, r);
      case "JSXFragment":
      case "JSXElement":
        return H6(t, e, r);
      case "JSXOpeningElement":
        return R6(t, e, r);
      case "JSXClosingElement":
        return W6(t, e, r);
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        return U6(t, e);
      case "JSXEmptyExpression":
        return V6(t, e);
      case "JSXText":
        throw new Error("JSXText should be handled by JSXElement");
      default:
        throw new $o(n, "JSX");
    }
}
function K6(t) {
  if (t.children.length === 0)
    return !0;
  if (t.children.length > 1)
    return !1;
  let e = t.children[0];
  return e.type === "JSXText" && !Va(e);
}
function Va(t) {
  return t.type === "JSXText" && (Mu.hasNonWhitespaceCharacter(Lr(t)) || !/\n/.test(Lr(t)));
}
function G6(t) {
  return t.type === "JSXExpressionContainer" && ir(t.expression) && t.expression.value === " " && !se(t.expression);
}
function X6(t) {
  let { node: e, parent: r } = t;
  if (!Dt(e) || !Dt(r))
    return !1;
  let { index: n, siblings: i } = t, s;
  for (let o = n; o > 0; o--) {
    let l = i[o - 1];
    if (!(l.type === "JSXText" && !Va(l))) {
      s = l;
      break;
    }
  }
  return (s == null ? void 0 : s.type) === "JSXExpressionContainer" && s.expression.type === "JSXEmptyExpression" && dh(s.expression);
}
function Y6(t) {
  return dh(t.node) || X6(t);
}
var xv = Y6, Q6 = 0;
function bv(t, e, r) {
  var n;
  let { node: i, parent: s, grandparent: o, key: l } = t, u = l !== "body" && (s.type === "IfStatement" || s.type === "WhileStatement" || s.type === "SwitchStatement" || s.type === "DoWhileStatement"), h = i.operator === "|>" && ((n = t.root.extra) == null ? void 0 : n.__isUsingHackPipeline), p = vd(t, r, e, !1, u);
  if (u)
    return p;
  if (h)
    return q(p);
  if (Re(s) && s.callee === i || s.type === "UnaryExpression" || it(s) && !s.computed)
    return q([te([Y, ...p]), Y]);
  let d = s.type === "ReturnStatement" || s.type === "ThrowStatement" || s.type === "JSXExpressionContainer" && o.type === "JSXAttribute" || i.operator !== "|" && s.type === "JsExpressionRoot" || i.type !== "NGPipeExpression" && (s.type === "NGRoot" && e.parser === "__ng_binding" || s.type === "NGMicrosyntaxExpression" && o.type === "NGMicrosyntax" && o.body.length === 1) || i === s.body && s.type === "ArrowFunctionExpression" || i !== s.body && s.type === "ForStatement" || s.type === "ConditionalExpression" && o.type !== "ReturnStatement" && o.type !== "ThrowStatement" && !Re(o) || s.type === "TemplateLiteral", m = s.type === "AssignmentExpression" || s.type === "VariableDeclarator" || s.type === "ClassProperty" || s.type === "PropertyDefinition" || s.type === "TSAbstractPropertyDefinition" || s.type === "ClassPrivateProperty" || ri(s), y = Wn(i.left) && Rm(i.operator, i.left.operator);
  if (d || za(i) && !y || !za(i) && m)
    return q(p);
  if (p.length === 0)
    return "";
  let D = Dt(i.right), b = p.findIndex((w) => typeof w != "string" && !Array.isArray(w) && w.type === $r), C = p.slice(0, b === -1 ? 1 : b + 1), A = p.slice(C.length, D ? -1 : void 0), x = Symbol("logicalChain-" + ++Q6), E = q([...C, te(A)], { id: x });
  if (!D)
    return E;
  let k = We(!1, p, -1);
  return q([E, fh(k, { groupId: x })]);
}
function vd(t, e, r, n, i) {
  var s;
  let { node: o } = t;
  if (!Wn(o))
    return [q(e())];
  let l = [];
  Rm(o.operator, o.left.operator) ? l = t.call((C) => vd(C, e, r, !0, i), "left") : l.push(q(e("left")));
  let u = za(o), h = (o.operator === "|>" || o.type === "NGPipeExpression" || Z6(t, r)) && !fs(r.originalText, o.right), p = o.type === "NGPipeExpression" ? "|" : o.operator, d = o.type === "NGPipeExpression" && o.arguments.length > 0 ? q(te([Y, ": ", Ne([he, ": "], t.map(() => Fn(2, q(e())), "arguments"))])) : "", m;
  if (u)
    m = [p, " ", e("right"), d];
  else {
    let C = p === "|>" && ((s = t.root.extra) != null && s.__isUsingHackPipeline) ? t.call((A) => vd(A, e, r, !0, i), "right") : e("right");
    m = [h ? he : "", p, h ? " " : he, C, d];
  }
  let { parent: y } = t, D = se(o.left, de.Trailing | de.Line), b = D || !(i && o.type === "LogicalExpression") && y.type !== o.type && o.left.type !== o.type && o.right.type !== o.type;
  if (l.push(h ? "" : " ", b ? q(m, { shouldBreak: D }) : m), n && se(o)) {
    let C = Wm(en(t, l, r));
    return Array.isArray(C) || C.type === kn ? Qb(C) : [C];
  }
  return l;
}
function za(t) {
  return t.type !== "LogicalExpression" ? !1 : !!(tn(t.right) && t.right.properties.length > 0 || Bt(t.right) && t.right.elements.length > 0 || Dt(t.right));
}
var S0 = (t) => t.type === "BinaryExpression" && t.operator === "|";
function Z6(t, e) {
  return (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && S0(t.node) && !t.hasAncestor((r) => !S0(r) && r.type !== "JsExpressionRoot");
}
function e_(t, e, r) {
  let { node: n } = t;
  if (n.type.startsWith("NG"))
    switch (n.type) {
      case "NGRoot":
        return [r("node"), se(n.node) ? " //" + oo(n.node)[0].value.trimEnd() : ""];
      case "NGPipeExpression":
        return bv(t, e, r);
      case "NGChainedExpression":
        return q(Ne([";", he], t.map(() => r_(t) ? r() : ["(", r(), ")"], "expressions")));
      case "NGEmptyExpression":
        return "";
      case "NGMicrosyntax":
        return t.map(() => [t.isFirst ? "" : T0(t) ? " " : [";", he], r()], "body");
      case "NGMicrosyntaxKey":
        return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);
      case "NGMicrosyntaxExpression":
        return [r("expression"), n.alias === null ? "" : [" as ", r("alias")]];
      case "NGMicrosyntaxKeyedExpression": {
        let { index: i, parent: s } = t, o = T0(t) || (i === 1 && (n.key.name === "then" || n.key.name === "else" || n.key.name === "as") || (i === 2 || i === 3) && (n.key.name === "else" && s.body[i - 1].type === "NGMicrosyntaxKeyedExpression" && s.body[i - 1].key.name === "then" || n.key.name === "track")) && s.body[0].type === "NGMicrosyntaxExpression";
        return [r("key"), o ? " " : ": ", r("expression")];
      }
      case "NGMicrosyntaxLet":
        return ["let ", r("key"), n.value === null ? "" : [" = ", r("value")]];
      case "NGMicrosyntaxAs":
        return [r("key"), " as ", r("alias")];
      default:
        throw new $o(n, "Angular");
    }
}
function T0({ node: t, index: e }) {
  return t.type === "NGMicrosyntaxKeyedExpression" && t.key.name === "of" && e === 1;
}
var t_ = Je(["CallExpression", "OptionalCallExpression", "AssignmentExpression"]);
function r_({ node: t }) {
  return cd(t, t_);
}
function vv(t, e, r) {
  let { node: n } = t;
  return q([Ne(he, t.map(r, "decorators")), Cv(n, e) ? ee : he]);
}
function n_(t, e, r) {
  return Av(t.node) ? [Ne(ee, t.map(r, "declaration", "decorators")), ee] : "";
}
function i_(t, e, r) {
  let { node: n, parent: i } = t, { decorators: s } = n;
  if (!je(s) || Av(i) || xv(t))
    return "";
  let o = n.type === "ClassExpression" || n.type === "ClassDeclaration" || Cv(n, e);
  return [t.key === "declaration" && l9(i) ? ee : o ? Pn : "", Ne(he, t.map(r, "decorators")), he];
}
function Cv(t, e) {
  return t.decorators.some((r) => xr(e.originalText, qe(r)));
}
function Av(t) {
  var e;
  if (t.type !== "ExportDefaultDeclaration" && t.type !== "ExportNamedDeclaration" && t.type !== "DeclareExportDeclaration")
    return !1;
  let r = (e = t.declaration) == null ? void 0 : e.decorators;
  return je(r) && lh(t, r[0]);
}
var ic = class extends Error {
  constructor() {
    super(...arguments);
    Vr(this, "name", "ArgExpansionBailout");
  }
};
function s_(t, e, r) {
  let { node: n } = t, i = _r(n);
  if (i.length === 0)
    return ["(", ot(t, e), ")"];
  if (l_(i))
    return ["(", r(["arguments", 0]), ", ", r(["arguments", 1]), ")"];
  let s = !1, o = i.length - 1, l = [];
  jm(t, ({ node: d }, m) => {
    let y = r();
    m === o || (Ui(d, e) ? (s = !0, y = [y, ",", ee, ee]) : y = [y, ",", he]), l.push(y);
  });
  let u = !(n.type === "ImportExpression" || n.callee.type === "Import") && Wi(e, "all") ? "," : "";
  function h() {
    return q(["(", te([he, ...l]), u, he, ")"], { shouldBreak: !0 });
  }
  if (s || t.parent.type !== "Decorator" && y9(i))
    return h();
  if (a_(i)) {
    let d = l.slice(1);
    if (d.some(Jt))
      return h();
    let m;
    try {
      m = r(y0(n, 0), { expandFirstArg: !0 });
    } catch (y) {
      if (y instanceof ic)
        return h();
      throw y;
    }
    return Jt(m) ? [Pn, is([["(", q(m, { shouldBreak: !0 }), ", ", ...d, ")"], h()])] : is([["(", m, ", ", ...d, ")"], ["(", q(m, { shouldBreak: !0 }), ", ", ...d, ")"], h()]);
  }
  if (o_(i, l, e)) {
    let d = l.slice(0, -1);
    if (d.some(Jt))
      return h();
    let m;
    try {
      m = r(y0(n, -1), { expandLastArg: !0 });
    } catch (y) {
      if (y instanceof ic)
        return h();
      throw y;
    }
    return Jt(m) ? [Pn, is([["(", ...d, q(m, { shouldBreak: !0 }), ")"], h()])] : is([["(", ...d, m, ")"], ["(", ...d, q(m, { shouldBreak: !0 }), ")"], h()]);
  }
  let p = ["(", te([Y, ...l]), we(u), Y, ")"];
  return Ub(t) ? p : q(p, { shouldBreak: l.some(Jt) || s });
}
function Fa(t, e = !1) {
  return tn(t) && (t.properties.length > 0 || se(t)) || Bt(t) && (t.elements.length > 0 || se(t)) || t.type === "TSTypeAssertion" && Fa(t.expression) || xn(t) && Fa(t.expression) || t.type === "FunctionExpression" || t.type === "ArrowFunctionExpression" && (!t.returnType || !t.returnType.typeAnnotation || t.returnType.typeAnnotation.type !== "TSTypeReference" || u_(t.body)) && (t.body.type === "BlockStatement" || t.body.type === "ArrowFunctionExpression" && Fa(t.body, !0) || tn(t.body) || Bt(t.body) || !e && (Re(t.body) || t.body.type === "ConditionalExpression") || Dt(t.body)) || t.type === "DoExpression" || t.type === "ModuleExpression";
}
function o_(t, e, r) {
  var n, i;
  let s = We(!1, t, -1);
  if (t.length === 1) {
    let l = We(!1, e, -1);
    if ((n = l.label) != null && n.embed && ((i = l.label) == null ? void 0 : i.hug) !== !1)
      return !0;
  }
  let o = We(!1, t, -2);
  return !se(s, de.Leading) && !se(s, de.Trailing) && Fa(s) && (!o || o.type !== s.type) && (t.length !== 2 || o.type !== "ArrowFunctionExpression" || !Bt(s)) && !(t.length > 1 && Gv(s, r));
}
function a_(t) {
  if (t.length !== 2)
    return !1;
  let [e, r] = t;
  return e.type === "ModuleExpression" && c_(r) ? !0 : !se(e) && (e.type === "FunctionExpression" || e.type === "ArrowFunctionExpression" && e.body.type === "BlockStatement") && r.type !== "FunctionExpression" && r.type !== "ArrowFunctionExpression" && r.type !== "ConditionalExpression" && Ev(r) && !Fa(r);
}
function Ev(t) {
  var e;
  if (t.type === "ParenthesizedExpression")
    return Ev(t.expression);
  if (xn(t) || t.type === "TypeCastExpression") {
    let { typeAnnotation: r } = t;
    return r.type === "TypeAnnotation" && (r = r.typeAnnotation), r.type === "TSArrayType" && (r = r.elementType, r.type === "TSArrayType" && (r = r.elementType)), (r.type === "GenericTypeAnnotation" || r.type === "TSTypeReference") && ((e = r.typeParameters) == null ? void 0 : e.params.length) === 1 && (r = r.typeParameters.params[0]), _m(r) && Yr(t.expression, 1);
  }
  return bo(t) && _r(t).length > 1 ? !1 : Wn(t) ? Yr(t.left, 1) && Yr(t.right, 1) : Mb(t) || Yr(t);
}
function l_(t) {
  return t.length === 2 && t[0].type === "ArrowFunctionExpression" && Wt(t[0]).length === 0 && t[0].body.type === "BlockStatement" && t[1].type === "ArrayExpression" && !t.some((e) => se(e));
}
function u_(t) {
  return t.type === "BlockStatement" && (t.body.some((e) => e.type !== "EmptyStatement") || se(t, de.Dangling));
}
function c_(t) {
  return t.type === "ObjectExpression" && t.properties.length === 1 && ri(t.properties[0]) && t.properties[0].key.type === "Identifier" && t.properties[0].key.name === "type" && ir(t.properties[0].value) && t.properties[0].value.value === "module";
}
var Cd = s_, h_ = (t) => ((t.type === "ChainExpression" || t.type === "TSNonNullExpression") && (t = t.expression), Re(t) && _r(t).length > 0);
function p_(t, e, r) {
  var n;
  let i = r("object"), s = wv(t, e, r), { node: o } = t, l = t.findAncestor((p) => !(it(p) || p.type === "TSNonNullExpression")), u = t.findAncestor((p) => !(p.type === "ChainExpression" || p.type === "TSNonNullExpression")), h = l && (l.type === "NewExpression" || l.type === "BindExpression" || l.type === "AssignmentExpression" && l.left.type !== "Identifier") || o.computed || o.object.type === "Identifier" && o.property.type === "Identifier" && !it(u) || (u.type === "AssignmentExpression" || u.type === "VariableDeclarator") && (h_(o.object) || ((n = i.label) == null ? void 0 : n.memberChain));
  return bl(i.label, [i, h ? s : q(te([Y, s]))]);
}
function wv(t, e, r) {
  let n = r("property"), { node: i } = t, s = Gt(t);
  return i.computed ? !i.property || Bi(i.property) ? [s, "[", n, "]"] : q([s, "[", te([Y, n]), Y, "]"]) : [s, ".", n];
}
function Sv(t, e, r) {
  if (t.node.type === "ChainExpression")
    return t.call(() => Sv(t, e, r), "expression");
  let { parent: n } = t, i = !n || n.type === "ExpressionStatement", s = [];
  function o($) {
    let { originalText: U } = e, H = vl(U, qe($));
    return U.charAt(H) === ")" ? H !== !1 && Om(U, H + 1) : Ui($, e);
  }
  function l($) {
    let { node: U } = $;
    if (U.type === "ChainExpression")
      return $.call(() => l($), "expression");
    if (Re(U) && (Xs(U.callee) || Re(U.callee))) {
      let H = o(U);
      s.unshift({ node: U, hasTrailingEmptyLine: H, printed: [en($, [Gt($), Ds($, e, r), Cd($, e, r)], e), H ? ee : ""] }), $.call((Z) => l(Z), "callee");
    } else
      Xs(U) ? (s.unshift({ node: U, needsParens: Os($, e), printed: en($, it(U) ? wv($, e, r) : Jv($, e, r), e) }), $.call((H) => l(H), "object")) : U.type === "TSNonNullExpression" ? (s.unshift({ node: U, printed: en($, "!", e) }), $.call((H) => l(H), "expression")) : s.unshift({ node: U, printed: r() });
  }
  let { node: u } = t;
  s.unshift({ node: u, printed: [Gt(t), Ds(t, e, r), Cd(t, e, r)] }), u.callee && t.call(($) => l($), "callee");
  let h = [], p = [s[0]], d = 1;
  for (; d < s.length && (s[d].node.type === "TSNonNullExpression" || Re(s[d].node) || it(s[d].node) && s[d].node.computed && Bi(s[d].node.property)); ++d)
    p.push(s[d]);
  if (!Re(s[0].node))
    for (; d + 1 < s.length && Xs(s[d].node) && Xs(s[d + 1].node); ++d)
      p.push(s[d]);
  h.push(p), p = [];
  let m = !1;
  for (; d < s.length; ++d) {
    if (m && Xs(s[d].node)) {
      if (s[d].node.computed && Bi(s[d].node.property)) {
        p.push(s[d]);
        continue;
      }
      h.push(p), p = [], m = !1;
    }
    (Re(s[d].node) || s[d].node.type === "ImportExpression") && (m = !0), p.push(s[d]), se(s[d].node, de.Trailing) && (h.push(p), p = [], m = !1);
  }
  p.length > 0 && h.push(p);
  function y($) {
    return /^[A-Z]|^[$_]+$/.test($);
  }
  function D($) {
    return $.length <= e.tabWidth;
  }
  function b($) {
    var U;
    let H = (U = $[1][0]) == null ? void 0 : U.node.computed;
    if ($[0].length === 1) {
      let ye = $[0][0].node;
      return ye.type === "ThisExpression" || ye.type === "Identifier" && (y(ye.name) || i && D(ye.name) || H);
    }
    let Z = We(!1, $[0], -1).node;
    return it(Z) && Z.property.type === "Identifier" && (y(Z.property.name) || H);
  }
  let C = h.length >= 2 && !se(h[1][0].node) && b(h);
  function A($) {
    let U = $.map((H) => H.printed);
    return $.length > 0 && We(!1, $, -1).needsParens ? ["(", ...U, ")"] : U;
  }
  function x($) {
    return $.length === 0 ? "" : te([ee, Ne(ee, $.map(A))]);
  }
  let E = h.map(A), k = E, w = C ? 3 : 2, T = h.flat(), P = T.slice(1, -1).some(($) => se($.node, de.Leading)) || T.slice(0, -1).some(($) => se($.node, de.Trailing)) || h[w] && se(h[w][0].node, de.Leading);
  if (h.length <= w && !P && !h.some(($) => We(!1, $, -1).hasTrailingEmptyLine))
    return Ub(t) ? k : q(k);
  let M = We(!1, h[C ? 1 : 0], -1).node, N = !Re(M) && o(M), L = [A(h[0]), C ? h.slice(1, 2).map(A) : "", N ? ee : "", x(h.slice(C ? 2 : 1))], j = s.map(({ node: $ }) => $).filter(Re);
  function X() {
    let $ = We(!1, We(!1, h, -1), -1).node, U = We(!1, E, -1);
    return Re($) && Jt(U) && j.slice(0, -1).some((H) => H.arguments.some(Ua));
  }
  let Q;
  return P || j.length > 2 && j.some(($) => !$.arguments.every((U) => Yr(U))) || E.slice(0, -1).some(Jt) || X() ? Q = q(L) : Q = [Jt(k) || N ? Pn : "", is([k, L])], bl({ memberChain: !0 }, Q);
}
var d_ = Sv;
function Tv(t, e, r) {
  var n;
  let { node: i, parent: s } = t, o = i.type === "NewExpression", l = i.type === "ImportExpression", u = Gt(t), h = _r(i), p = h.length === 1 && qb(h[0], e.originalText);
  if (p || h.length > 0 && !o && !l && (m_(i, s) || ph(i, s))) {
    let m = [];
    if (jm(t, () => {
      m.push(r());
    }), !(p && (n = m[0].label) != null && n.embed))
      return [o ? "new " : "", r("callee"), u, Ds(t, e, r), "(", Ne(", ", m), ")"];
  }
  if (!l && !o && Xs(i.callee) && !t.call((m) => Os(m, e), "callee", ...i.callee.type === "ChainExpression" ? ["expression"] : []))
    return d_(t, e, r);
  let d = [o ? "new " : "", l ? f_(i) : r("callee"), u, Ds(t, e, r), Cd(t, e, r)];
  return l || Re(i.callee) ? q(d) : d;
}
function f_(t) {
  return t.phase ? `import.${t.phase}` : "import";
}
function m_(t, e) {
  if (t.callee.type !== "Identifier")
    return !1;
  if (t.callee.name === "require") {
    let r = _r(t);
    return r.length === 1 && ir(r[0]) || r.length > 1;
  }
  if (t.callee.name === "define") {
    let r = _r(t);
    return e.type === "ExpressionStatement" && (r.length === 1 || r.length === 2 && r[0].type === "ArrayExpression" || r.length === 3 && ir(r[0]) && r[1].type === "ArrayExpression");
  }
  return !1;
}
function Cl(t, e, r, n, i, s) {
  let o = D_(t, e, r, n, s), l = s ? r(s, { assignmentLayout: o }) : "";
  switch (o) {
    case "break-after-operator":
      return q([q(n), i, q(te([he, l]))]);
    case "never-break-after-operator":
      return q([q(n), i, " ", l]);
    case "fluid": {
      let u = Symbol("assignment");
      return q([q(n), i, q(te(he), { id: u }), Un, fh(l, { groupId: u })]);
    }
    case "break-lhs":
      return q([n, i, " ", q(l)]);
    case "chain":
      return [q(n), i, he, l];
    case "chain-tail":
      return [q(n), i, te([he, l])];
    case "chain-tail-arrow-chain":
      return [q(n), i, l];
    case "only-left":
      return n;
  }
}
function g_(t, e, r) {
  let { node: n } = t;
  return Cl(t, e, r, r("left"), [" ", n.operator], "right");
}
function y_(t, e, r) {
  return Cl(t, e, r, r("id"), " =", "init");
}
function D_(t, e, r, n, i) {
  let { node: s } = t, o = s[i];
  if (!o)
    return "only-left";
  let l = !Ou(o);
  if (t.match(Ou, kv, (p) => !l || p.type !== "ExpressionStatement" && p.type !== "VariableDeclaration"))
    return l ? o.type === "ArrowFunctionExpression" && o.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
  if (!l && Ou(o.right) || fs(e.originalText, o))
    return "break-after-operator";
  if (o.type === "CallExpression" && o.callee.name === "require" || e.parser === "json5" || e.parser === "jsonc" || e.parser === "json")
    return "never-break-after-operator";
  let u = q9(n);
  if (b_(s) || E_(s) || Fv(s) && u)
    return "break-lhs";
  let h = S_(s, n, e);
  return t.call(() => x_(t, e, r, h), i) ? "break-after-operator" : v_(s) ? "break-lhs" : !u && (h || o.type === "TemplateLiteral" || o.type === "TaggedTemplateExpression" || o.type === "BooleanLiteral" || Bi(o) || o.type === "ClassExpression") ? "never-break-after-operator" : "fluid";
}
function x_(t, e, r, n) {
  let i = t.node;
  if (Wn(i) && !za(i))
    return !0;
  switch (i.type) {
    case "StringLiteralTypeAnnotation":
    case "SequenceExpression":
      return !0;
    case "TSConditionalType":
    case "ConditionalTypeAnnotation":
      if (!e.experimentalTernaries && !F_(i))
        break;
      return !0;
    case "ConditionalExpression": {
      if (!e.experimentalTernaries) {
        let { test: h } = i;
        return Wn(h) && !za(h);
      }
      let { consequent: l, alternate: u } = i;
      return l.type === "ConditionalExpression" || u.type === "ConditionalExpression";
    }
    case "ClassExpression":
      return je(i.decorators);
  }
  if (n)
    return !1;
  let s = i, o = [];
  for (; ; )
    if (s.type === "UnaryExpression" || s.type === "AwaitExpression" || s.type === "YieldExpression" && s.argument !== null)
      s = s.argument, o.push("argument");
    else if (s.type === "TSNonNullExpression")
      s = s.expression, o.push("expression");
    else
      break;
  return !!(ir(s) || t.call(() => Pv(t, e, r), ...o));
}
function b_(t) {
  if (kv(t)) {
    let e = t.left || t.id;
    return e.type === "ObjectPattern" && e.properties.length > 2 && e.properties.some((r) => {
      var n;
      return ri(r) && (!r.shorthand || ((n = r.value) == null ? void 0 : n.type) === "AssignmentPattern");
    });
  }
  return !1;
}
function Ou(t) {
  return t.type === "AssignmentExpression";
}
function kv(t) {
  return Ou(t) || t.type === "VariableDeclarator";
}
function v_(t) {
  let e = A_(t);
  if (je(e)) {
    let r = t.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
    if (e.length > 1 && e.some((n) => n[r] || n.default))
      return !0;
  }
  return !1;
}
var C_ = Je(["TSTypeAliasDeclaration", "TypeAlias"]);
function A_(t) {
  var e;
  if (C_(t))
    return (e = t.typeParameters) == null ? void 0 : e.params;
}
function E_(t) {
  if (t.type !== "VariableDeclarator")
    return !1;
  let { typeAnnotation: e } = t.id;
  if (!e || !e.typeAnnotation)
    return !1;
  let r = k0(e.typeAnnotation);
  return je(r) && r.length > 1 && r.some((n) => je(k0(n)) || n.type === "TSConditionalType");
}
function Fv(t) {
  var e;
  return t.type === "VariableDeclarator" && ((e = t.init) == null ? void 0 : e.type) === "ArrowFunctionExpression";
}
var w_ = Je(["TSTypeReference", "GenericTypeAnnotation"]);
function k0(t) {
  var e;
  if (w_(t))
    return (e = t.typeParameters) == null ? void 0 : e.params;
}
function Pv(t, e, r, n = !1) {
  var i;
  let { node: s } = t, o = () => Pv(t, e, r, !0);
  if (s.type === "ChainExpression" || s.type === "TSNonNullExpression")
    return t.call(o, "expression");
  if (Re(s)) {
    if ((i = Tv(t, e, r).label) != null && i.memberChain)
      return !1;
    let l = _r(s);
    return !(l.length === 0 || l.length === 1 && $m(l[0], e)) || T_(s, r) ? !1 : t.call(o, "callee");
  }
  return it(s) ? t.call(o, "object") : n && (s.type === "Identifier" || s.type === "ThisExpression");
}
function S_(t, e, r) {
  return ri(t) ? (e = Wm(e), typeof e == "string" && yo(e) < r.tabWidth + 3) : !1;
}
function T_(t, e) {
  let r = k_(t);
  if (je(r)) {
    if (r.length > 1)
      return !0;
    if (r.length === 1) {
      let i = r[0];
      if (ms(i) || Vb(i) || i.type === "TSTypeLiteral" || i.type === "ObjectTypeAnnotation")
        return !0;
    }
    let n = t.typeParameters ? "typeParameters" : "typeArguments";
    if (Jt(e(n)))
      return !0;
  }
  return !1;
}
function k_(t) {
  var e;
  return (e = t.typeParameters ?? t.typeArguments) == null ? void 0 : e.params;
}
function F_(t) {
  function e(r) {
    switch (r.type) {
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "TSFunctionType":
      case "TSTypeReference":
        return !!r.typeParameters;
      default:
        return !1;
    }
  }
  return e(t.checkType) || e(t.extendsType);
}
function Al(t, e, r, n, i) {
  let s = t.node, o = Wt(s), l = i ? Ds(t, r, e) : "";
  if (o.length === 0)
    return [l, "(", ot(t, r, { filter: (y) => Hn(r.originalText, qe(y)) === ")" }), ")"];
  let { parent: u } = t, h = ph(u), p = Bv(s), d = [];
  if (A9(t, (y, D) => {
    let b = D === o.length - 1;
    b && s.rest && d.push("..."), d.push(e()), !b && (d.push(","), h || p ? d.push(" ") : Ui(o[D], r) ? d.push(ee, ee) : d.push(he));
  }), n && !B_(t)) {
    if (Jt(l) || Jt(d))
      throw new ic();
    return q([dd(l), "(", dd(d), ")"]);
  }
  let m = o.every((y) => !je(y.decorators));
  return p && m ? [l, "(", ...d, ")"] : h ? [l, "(", ...d, ")"] : (Lb(u) || c9(u) || u.type === "TypeAlias" || u.type === "UnionTypeAnnotation" || u.type === "IntersectionTypeAnnotation" || u.type === "FunctionTypeAnnotation" && u.returnType === s) && o.length === 1 && o[0].name === null && s.this !== o[0] && o[0].typeAnnotation && s.typeParameters === null && _m(o[0].typeAnnotation) && !s.rest ? r.arrowParens === "always" ? ["(", ...d, ")"] : d : [l, "(", te([Y, ...d]), we(!C9(s) && Wi(r, "all") ? "," : ""), Y, ")"];
}
function Bv(t) {
  if (!t)
    return !1;
  let e = Wt(t);
  if (e.length !== 1)
    return !1;
  let [r] = e;
  return !se(r) && (r.type === "ObjectPattern" || r.type === "ArrayPattern" || r.type === "Identifier" && r.typeAnnotation && (r.typeAnnotation.type === "TypeAnnotation" || r.typeAnnotation.type === "TSTypeAnnotation") && Ii(r.typeAnnotation.typeAnnotation) || r.type === "FunctionTypeParam" && Ii(r.typeAnnotation) && r !== t.rest || r.type === "AssignmentPattern" && (r.left.type === "ObjectPattern" || r.left.type === "ArrayPattern") && (r.right.type === "Identifier" || tn(r.right) && r.right.properties.length === 0 || Bt(r.right) && r.right.elements.length === 0));
}
function P_(t) {
  let e;
  return t.returnType ? (e = t.returnType, e.typeAnnotation && (e = e.typeAnnotation)) : t.typeAnnotation && (e = t.typeAnnotation), e;
}
function mh(t, e) {
  var r;
  let n = P_(t);
  if (!n)
    return !1;
  let i = (r = t.typeParameters) == null ? void 0 : r.params;
  if (i) {
    if (i.length > 1)
      return !1;
    if (i.length === 1) {
      let s = i[0];
      if (s.constraint || s.default)
        return !1;
    }
  }
  return Wt(t).length === 1 && (Ii(n) || Jt(e));
}
function B_(t) {
  return t.match((e) => e.type === "ArrowFunctionExpression" && e.body.type === "BlockStatement", (e, r) => {
    if (e.type === "CallExpression" && r === "arguments" && e.arguments.length === 1 && e.callee.type === "CallExpression") {
      let n = e.callee.callee;
      return n.type === "Identifier" || n.type === "MemberExpression" && !n.computed && n.object.type === "Identifier" && n.property.type === "Identifier";
    }
    return !1;
  }, (e, r) => e.type === "VariableDeclarator" && r === "init" || e.type === "ExportDefaultDeclaration" && r === "declaration" || e.type === "TSExportAssignment" && r === "expression" || e.type === "AssignmentExpression" && r === "right" && e.left.type === "MemberExpression" && e.left.object.type === "Identifier" && e.left.object.name === "module" && e.left.property.type === "Identifier" && e.left.property.name === "exports", (e) => e.type !== "VariableDeclaration" || e.kind === "const" && e.declarations.length === 1);
}
function I_(t) {
  let e = Wt(t);
  return e.length > 1 && e.some((r) => r.type === "TSParameterProperty");
}
var N_ = Je(["VoidTypeAnnotation", "TSVoidKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword"]), M_ = Je(["ObjectTypeAnnotation", "TSTypeLiteral", "GenericTypeAnnotation", "TSTypeReference"]);
function O_(t) {
  let { types: e } = t;
  if (e.some((n) => se(n)))
    return !1;
  let r = e.find((n) => M_(n));
  return r ? e.every((n) => n === r || N_(n)) : !1;
}
function Iv(t) {
  return _m(t) || Ii(t) ? !0 : ms(t) ? O_(t) : !1;
}
function L_(t, e, r) {
  let n = e.semi ? ";" : "", { node: i } = t, s = [Rr(t), "opaque type ", r("id"), r("typeParameters")];
  return i.supertype && s.push(": ", r("supertype")), i.impltype && s.push(" = ", r("impltype")), s.push(n), s;
}
function Nv(t, e, r) {
  let n = e.semi ? ";" : "", { node: i } = t, s = [Rr(t)];
  s.push("type ", r("id"), r("typeParameters"));
  let o = i.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
  return [Cl(t, e, r, s, " =", o), n];
}
function Mv(t, e, r) {
  let n = !1;
  return q(t.map(({ isFirst: i, previous: s, node: o, index: l }) => {
    let u = r();
    if (i)
      return u;
    let h = Ii(o), p = Ii(s);
    return p && h ? [" & ", n ? te(u) : u] : !p && !h ? te([" &", he, u]) : (l > 1 && (n = !0), [" & ", l > 1 ? te(u) : u]);
  }, "types"));
}
function Ov(t, e, r) {
  let { node: n } = t, { parent: i } = t, s = i.type !== "TypeParameterInstantiation" && (i.type !== "TSConditionalType" || !e.experimentalTernaries) && (i.type !== "ConditionalTypeAnnotation" || !e.experimentalTernaries) && i.type !== "TSTypeParameterInstantiation" && i.type !== "GenericTypeAnnotation" && i.type !== "TSTypeReference" && i.type !== "TSTypeAssertion" && i.type !== "TupleTypeAnnotation" && i.type !== "TSTupleType" && !(i.type === "FunctionTypeParam" && !i.name && t.grandparent.this !== i) && !((i.type === "TypeAlias" || i.type === "VariableDeclarator" || i.type === "TSTypeAliasDeclaration") && fs(e.originalText, n)), o = Iv(n), l = t.map((p) => {
    let d = r();
    return o || (d = Fn(2, d)), en(p, d, e);
  }, "types");
  if (o)
    return Ne(" | ", l);
  let u = s && !fs(e.originalText, n), h = [we([u ? he : "", "| "]), Ne([he, "| "], l)];
  return Os(t, e) ? q([te(h), Y]) : (i.type === "TupleTypeAnnotation" || i.type === "TSTupleType") && i[i.type === "TupleTypeAnnotation" && i.types ? "types" : "elementTypes"].length > 1 ? q([te([we(["(", Y]), h]), Y, we(")")]) : q(s ? te(h) : h);
}
function __(t) {
  var e;
  let { node: r, parent: n } = t;
  return r.type === "FunctionTypeAnnotation" && (Lb(n) || !((n.type === "ObjectTypeProperty" || n.type === "ObjectTypeInternalSlot") && !n.variance && !n.optional && lh(n, r) || n.type === "ObjectTypeCallProperty" || ((e = t.getParentNode(2)) == null ? void 0 : e.type) === "DeclareFunction"));
}
function Lv(t, e, r) {
  let { node: n } = t, i = [gh(t)];
  (n.type === "TSConstructorType" || n.type === "TSConstructSignatureDeclaration") && i.push("new ");
  let s = Al(t, r, e, !1, !0), o = [];
  return n.type === "FunctionTypeAnnotation" ? o.push(__(t) ? " => " : ": ", r("returnType")) : o.push(Ft(t, r, n.returnType ? "returnType" : "typeAnnotation")), mh(n, o) && (s = q(s)), i.push(s, o), q(i);
}
function _v(t, e, r) {
  return [r("objectType"), Gt(t), "[", r("indexType"), "]"];
}
function $v(t, e, r) {
  return ["infer ", r("typeParameter")];
}
function F0(t, e, r) {
  let { node: n } = t;
  return [n.postfix ? "" : r, Ft(t, e), n.postfix ? r : ""];
}
function Rv(t, e, r) {
  let { node: n } = t;
  return ["...", ...n.type === "TupleTypeSpreadElement" && n.label ? [r("label"), ": "] : [], r("typeAnnotation")];
}
function jv(t, e, r) {
  let { node: n } = t;
  return [n.variance ? r("variance") : "", r("label"), n.optional ? "?" : "", ": ", r("elementType")];
}
var $_ = /* @__PURE__ */ new WeakSet();
function Ft(t, e, r = "typeAnnotation") {
  let { node: { [r]: n } } = t;
  if (!n)
    return "";
  let i = !1;
  if (n.type === "TSTypeAnnotation" || n.type === "TypeAnnotation") {
    let s = t.call(qv, r);
    (s === "=>" || s === ":" && se(n, de.Leading)) && (i = !0), $_.add(n);
  }
  return i ? [" ", e(r)] : e(r);
}
var qv = (t) => t.match((e) => e.type === "TSTypeAnnotation", (e, r) => (r === "returnType" || r === "typeAnnotation") && (e.type === "TSFunctionType" || e.type === "TSConstructorType")) ? "=>" : t.match((e) => e.type === "TSTypeAnnotation", (e, r) => r === "typeAnnotation" && (e.type === "TSJSDocNullableType" || e.type === "TSJSDocNonNullableType" || e.type === "TSTypePredicate")) || t.match((e) => e.type === "TypeAnnotation", (e, r) => r === "typeAnnotation" && e.type === "Identifier", (e, r) => r === "id" && e.type === "DeclareFunction") || t.match((e) => e.type === "TypeAnnotation", (e, r) => r === "bound" && e.type === "TypeParameter" && e.usesExtendsBound) ? "" : ":";
function Wv(t, e, r) {
  let n = qv(t);
  return n ? [n, " ", r("typeAnnotation")] : r("typeAnnotation");
}
function Uv(t) {
  return [t("elementType"), "[]"];
}
function Hv({ node: t }, e) {
  let r = t.type === "TSTypeQuery" ? "exprName" : "argument", n = t.type === "TSTypeQuery" ? "typeParameters" : "typeArguments";
  return ["typeof ", e(r), e(n)];
}
function Vv(t, e) {
  let { node: r } = t;
  return [r.asserts ? "asserts " : "", e("parameterName"), r.typeAnnotation ? [" is ", Ft(t, e)] : ""];
}
function Gt(t) {
  let { node: e } = t;
  return !e.optional || e.type === "Identifier" && e === t.parent.key ? "" : Re(e) || it(e) && e.computed || e.type === "OptionalIndexedAccessType" ? "?." : "?";
}
function zv(t) {
  return t.node.definite || t.match(void 0, (e, r) => r === "id" && e.type === "VariableDeclarator" && e.definite) ? "!" : "";
}
var R_ = /* @__PURE__ */ new Set(["DeclareClass", "DeclareFunction", "DeclareVariable", "DeclareExportDeclaration", "DeclareExportAllDeclaration", "DeclareOpaqueType", "DeclareTypeAlias", "DeclareEnum", "DeclareInterface"]);
function Rr(t) {
  let { node: e } = t;
  return e.declare || R_.has(e.type) && t.parent.type !== "DeclareExportDeclaration" ? "declare " : "";
}
var j_ = /* @__PURE__ */ new Set(["TSAbstractMethodDefinition", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
function gh({ node: t }) {
  return t.abstract || j_.has(t.type) ? "abstract " : "";
}
function Ds(t, e, r) {
  let n = t.node;
  return n.typeArguments ? r("typeArguments") : n.typeParameters ? r("typeParameters") : "";
}
function Jv(t, e, r) {
  return ["::", r("callee")];
}
function pi(t, e, r) {
  return t.type === "EmptyStatement" ? ";" : t.type === "BlockStatement" || r ? [" ", e] : te([he, e]);
}
function Kv(t, e) {
  return ["...", e("argument"), Ft(t, e)];
}
function sc(t) {
  return t.accessibility ? t.accessibility + " " : "";
}
function q_(t, e, r, n) {
  let { node: i } = t;
  return se(i, de.Dangling) ? q([r, ot(t, e, { indent: !0 }), Y, n]) : [r, n];
}
function Xm(t, e, r) {
  let { node: n } = t, i = [], s = n.type === "TupleExpression" ? "#[" : "[", o = "]", l = n.type === "TupleTypeAnnotation" && n.types ? "types" : n.type === "TSTupleType" || n.type === "TupleTypeAnnotation" ? "elementTypes" : "elements", u = n[l];
  if (u.length === 0)
    i.push(q_(t, e, s, o));
  else {
    let h = We(!1, u, -1), p = (h == null ? void 0 : h.type) !== "RestElement", d = h === null, m = Symbol("array"), y = !e.__inJestEach && u.length > 1 && u.every((C, A, x) => {
      let E = C == null ? void 0 : C.type;
      if (!Bt(C) && !tn(C))
        return !1;
      let k = x[A + 1];
      if (k && E !== k.type)
        return !1;
      let w = Bt(C) ? "elements" : "properties";
      return C[w] && C[w].length > 1;
    }), D = Gv(n, e), b = p ? d ? "," : Wi(e) ? D ? we(",", "", { groupId: m }) : we(",") : "" : "";
    i.push(q([s, te([Y, D ? U_(t, e, r, b) : [W_(t, e, l, r), b], ot(t, e)]), Y, o], { shouldBreak: y, id: m }));
  }
  return i.push(Gt(t), Ft(t, r)), i;
}
function Gv(t, e) {
  return Bt(t) && t.elements.length > 1 && t.elements.every((r) => r && (Bi(r) || Nb(r) && !se(r.argument)) && !se(r, de.Trailing | de.Line, (n) => !xr(e.originalText, st(n), { backwards: !0 })));
}
function Xv({ node: t }, { originalText: e }) {
  let r = (i) => Nm(e, Mm(e, i)), n = (i) => e[i] === "," ? i : n(r(i + 1));
  return Om(e, n(qe(t)));
}
function W_(t, e, r, n) {
  let i = [];
  return t.each(({ node: s, isLast: o }) => {
    i.push(s ? q(n()) : ""), o || i.push([",", he, s && Xv(t, e) ? Y : ""]);
  }, r), i;
}
function U_(t, e, r, n) {
  let i = [];
  return t.each(({ isLast: s, next: o }) => {
    i.push([r(), s ? n : ","]), s || i.push(Xv(t, e) ? [ee, ee] : se(o, de.Leading | de.Line) ? ee : he);
  }, "elements"), qm(i);
}
var Yv = new Proxy(() => {
}, { get: () => Yv }), Qv = Yv;
function H_(t) {
  return t.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
}
var xi = H_, ru = /* @__PURE__ */ new WeakMap();
function El(t, e, r) {
  let { node: n } = t;
  if (n.computed)
    return ["[", r("key"), "]"];
  let { parent: i } = t, { key: s } = n;
  if (e.quoteProps === "consistent" && !ru.has(i)) {
    let o = (i.properties || i.body || i.members).some((l) => !l.computed && l.key && ir(l.key) && !f0(l, e));
    ru.set(i, o);
  }
  if ((s.type === "Identifier" || Bi(s) && jb(xi(Lr(s))) && String(s.value) === xi(Lr(s)) && !(e.parser === "typescript" || e.parser === "babel-ts")) && (e.parser === "json" || e.parser === "jsonc" || e.quoteProps === "consistent" && ru.get(i))) {
    let o = Wa(JSON.stringify(s.type === "Identifier" ? s.name : s.value.toString()), e);
    return t.call((l) => en(l, o, e), "key");
  }
  return f0(n, e) && (e.quoteProps === "as-needed" || e.quoteProps === "consistent" && !ru.get(i)) ? t.call((o) => en(o, /^\d/.test(s.value) ? xi(s.value) : s.value, e), "key") : r("key");
}
function P0(t, e, r) {
  let { node: n } = t;
  return n.shorthand ? r("value") : Cl(t, e, r, El(t, e, r), ":", "value");
}
var V_ = ({ node: t, key: e, parent: r }) => e === "value" && t.type === "FunctionExpression" && (r.type === "ObjectMethod" || r.type === "ClassMethod" || r.type === "ClassPrivateMethod" || r.type === "MethodDefinition" || r.type === "TSAbstractMethodDefinition" || r.type === "TSDeclareMethod" || r.type === "Property" && hh(r));
function Zv(t, e, r, n) {
  if (V_(t))
    return Ym(t, r, e);
  let { node: i } = t, s = !1;
  if ((i.type === "FunctionDeclaration" || i.type === "FunctionExpression") && n != null && n.expandLastArg) {
    let { parent: p } = t;
    Re(p) && (_r(p).length > 1 || Wt(i).every((d) => d.type === "Identifier" && !d.typeAnnotation)) && (s = !0);
  }
  let o = [Rr(t), i.async ? "async " : "", `function${i.generator ? "*" : ""} `, i.id ? e("id") : ""], l = Al(t, e, r, s), u = Qm(t, e), h = mh(i, u);
  return o.push(Ds(t, r, e), q([h ? q(l) : l, u]), i.body ? " " : "", e("body")), r.semi && (i.declare || !i.body) && o.push(";"), o;
}
function Ad(t, e, r) {
  let { node: n } = t, { kind: i } = n, s = n.value || n, o = [];
  return !i || i === "init" || i === "method" || i === "constructor" ? s.async && o.push("async ") : (Qv.ok(i === "get" || i === "set"), o.push(i, " ")), s.generator && o.push("*"), o.push(El(t, e, r), n.optional || n.key.optional ? "?" : "", n === s ? Ym(t, e, r) : r("value")), o;
}
function Ym(t, e, r) {
  let { node: n } = t, i = Al(t, r, e), s = Qm(t, r), o = I_(n), l = mh(n, s), u = [Ds(t, e, r), q([o ? q(i, { shouldBreak: !0 }) : l ? q(i) : i, s])];
  return n.body ? u.push(" ", r("body")) : u.push(e.semi ? ";" : ""), u;
}
function z_(t) {
  let e = Wt(t);
  return e.length === 1 && !t.typeParameters && !se(t, de.Dangling) && e[0].type === "Identifier" && !e[0].typeAnnotation && !se(e[0]) && !e[0].optional && !t.predicate && !t.returnType;
}
function eC(t, e) {
  if (e.arrowParens === "always")
    return !1;
  if (e.arrowParens === "avoid") {
    let { node: r } = t;
    return z_(r);
  }
  return !1;
}
function Qm(t, e) {
  let { node: r } = t, n = [Ft(t, e, "returnType")];
  return r.predicate && n.push(e("predicate")), n;
}
function tC(t, e, r) {
  let { node: n } = t, i = e.semi ? ";" : "", s = [];
  if (n.argument) {
    let u = r("argument");
    G_(e, n.argument) ? u = ["(", te([ee, u]), ee, ")"] : (Wn(n.argument) || n.argument.type === "SequenceExpression" || e.experimentalTernaries && n.argument.type === "ConditionalExpression" && (n.argument.consequent.type === "ConditionalExpression" || n.argument.alternate.type === "ConditionalExpression")) && (u = q([we("("), te([Y, u]), Y, we(")")])), s.push(" ", u);
  }
  let o = se(n, de.Dangling), l = i && o && se(n, de.Last | de.Line);
  return l && s.push(i), o && s.push(" ", ot(t, e)), l || s.push(i), s;
}
function J_(t, e, r) {
  return ["return", tC(t, e, r)];
}
function K_(t, e, r) {
  return ["throw", tC(t, e, r)];
}
function G_(t, e) {
  if (fs(t.originalText, e) || se(e, de.Leading, (r) => Ni(t.originalText, st(r), qe(r))) && !Dt(e))
    return !0;
  if (Lm(e)) {
    let r = e, n;
    for (; n = a9(r); )
      if (r = n, fs(t.originalText, r))
        return !0;
  }
  return !1;
}
var dp = /* @__PURE__ */ new WeakMap();
function rC(t) {
  return dp.has(t) || dp.set(t, t.type === "ConditionalExpression" && !zt(t, (e) => e.type === "ObjectExpression")), dp.get(t);
}
var nC = (t) => t.type === "SequenceExpression";
function X_(t, e, r, n = {}) {
  let i = [], s, o = [], l = !1, u = !n.expandLastArg && t.node.body.type === "ArrowFunctionExpression", h;
  (function C() {
    let { node: A } = t, x = Y_(t, e, r, n);
    if (i.length === 0)
      i.push(x);
    else {
      let { leading: E, trailing: k } = Dv(t, e);
      i.push([E, x]), o.unshift(k);
    }
    u && (l || (l = A.returnType && Wt(A).length > 0 || A.typeParameters || Wt(A).some((E) => E.type !== "Identifier"))), !u || A.body.type !== "ArrowFunctionExpression" ? (s = r("body", n), h = A.body) : t.call(C, "body");
  })();
  let p = !fs(e.originalText, h) && (nC(h) || Q_(h, s, e) || !l && rC(h)), d = t.key === "callee" && bo(t.parent), m = Symbol("arrow-chain"), y = Z_(t, n, { signatureDocs: i, shouldBreak: l }), D, b = !1;
  return u && (d || n.assignmentLayout) && (b = !0, D = n.assignmentLayout === "chain-tail-arrow-chain" || d && !p), s = e5(t, e, n, { bodyDoc: s, bodyComments: o, functionBody: h, shouldPutBodyOnSameLine: p }), q([q(b ? te([Y, y]) : y, { shouldBreak: D, id: m }), " =>", u ? fh(s, { groupId: m }) : q(s), u && d ? we(Y, "", { groupId: m }) : ""]);
}
function Y_(t, e, r, n) {
  let { node: i } = t, s = [];
  if (i.async && s.push("async "), eC(t, e))
    s.push(r(["params", 0]));
  else {
    let l = n.expandLastArg || n.expandFirstArg, u = Qm(t, r);
    if (l) {
      if (Jt(u))
        throw new ic();
      u = q(dd(u));
    }
    s.push(q([Al(t, r, e, l, !0), u]));
  }
  let o = ot(t, e, { filter(l) {
    let u = vl(e.originalText, qe(l));
    return u !== !1 && e.originalText.slice(u, u + 2) === "=>";
  } });
  return o && s.push(" ", o), s;
}
function Q_(t, e, r) {
  var n, i;
  return Bt(t) || tn(t) || t.type === "ArrowFunctionExpression" || t.type === "DoExpression" || t.type === "BlockStatement" || Dt(t) || ((n = e.label) == null ? void 0 : n.hug) !== !1 && (((i = e.label) == null ? void 0 : i.embed) || qb(t, r.originalText));
}
function Z_(t, e, { signatureDocs: r, shouldBreak: n }) {
  if (r.length === 1)
    return r[0];
  let { parent: i, key: s } = t;
  return s !== "callee" && bo(i) || Wn(i) ? q([r[0], " =>", te([he, Ne([" =>", he], r.slice(1))])], { shouldBreak: n }) : s === "callee" && bo(i) || e.assignmentLayout ? q(Ne([" =>", he], r), { shouldBreak: n }) : q(te(Ne([" =>", he], r)), { shouldBreak: n });
}
function e5(t, e, r, { bodyDoc: n, bodyComments: i, functionBody: s, shouldPutBodyOnSameLine: o }) {
  let { node: l, parent: u } = t, h = r.expandLastArg && Wi(e, "all") ? we(",") : "", p = (r.expandLastArg || u.type === "JSXExpressionContainer") && !se(l) ? Y : "";
  return o && rC(s) ? [" ", q([we("", "("), te([Y, n]), we("", ")"), h, p]), i] : (nC(s) && (n = q(["(", te([Y, n]), Y, ")"])), o ? [" ", n, i] : [te([he, n, i]), h, p]);
}
var t5 = (t, e, r) => {
  if (!(t && e == null)) {
    if (e.findLast)
      return e.findLast(r);
    for (let n = e.length - 1; n >= 0; n--) {
      let i = e[n];
      if (r(i, n, e))
        return i;
    }
  }
}, r5 = t5;
function Ed(t, e, r, n) {
  let { node: i } = t, s = [], o = r5(!1, i[n], (l) => l.type !== "EmptyStatement");
  return t.each(({ node: l }) => {
    l.type !== "EmptyStatement" && (s.push(r()), l !== o && (s.push(ee), Ui(l, e) && s.push(ee)));
  }, n), s;
}
function iC(t, e, r) {
  let { node: n } = t, i = [];
  n.type === "StaticBlock" && i.push("static "), i.push("{");
  let s = sC(t, e, r);
  if (s)
    i.push(te([ee, s]), ee);
  else {
    let { parent: o } = t, l = t.grandparent;
    o.type === "ArrowFunctionExpression" || o.type === "FunctionExpression" || o.type === "FunctionDeclaration" || o.type === "ObjectMethod" || o.type === "ClassMethod" || o.type === "ClassPrivateMethod" || o.type === "ForStatement" || o.type === "WhileStatement" || o.type === "DoWhileStatement" || o.type === "DoExpression" || o.type === "CatchClause" && !l.finalizer || o.type === "TSModuleDeclaration" || o.type === "TSDeclareFunction" || n.type === "StaticBlock" || i.push(ee);
  }
  return i.push("}"), i;
}
function sC(t, e, r) {
  var n;
  let { node: i } = t, s = je(i.directives), o = i.body.some((h) => h.type !== "EmptyStatement"), l = se(i, de.Dangling);
  if (!s && !o && !l)
    return "";
  let u = [];
  return s && (u.push(Ed(t, e, r, "directives")), (o || l) && (u.push(ee), Ui(We(!1, i.directives, -1), e) && u.push(ee))), o && u.push(Ed(t, e, r, "body")), l && u.push(ot(t, e)), i.type === "Program" && ((n = t.parent) == null ? void 0 : n.type) !== "ModuleExpression" && u.push(ee), u;
}
function n5(t) {
  let e = /* @__PURE__ */ new WeakMap();
  return function(r) {
    return e.has(r) || e.set(r, Symbol(t)), e.get(r);
  };
}
var oC = n5;
function i5(t) {
  switch (t) {
    case null:
      return "";
    case "PlusOptional":
      return "+?";
    case "MinusOptional":
      return "-?";
    case "Optional":
      return "?";
  }
}
function s5(t, e, r) {
  let { node: n } = t;
  return q([n.variance ? r("variance") : "", "[", te([r("keyTparam"), " in ", r("sourceType")]), "]", i5(n.optional), ": ", r("propType")]);
}
function aC(t, e) {
  return t === "+" || t === "-" ? t + e : e;
}
function o5(t, e, r) {
  let { node: n } = t, i = Ni(e.originalText, st(n), st(n.typeParameter));
  return q(["{", te([e.bracketSpacing ? he : Y, q([r("typeParameter"), n.optional ? aC(n.optional, "?") : "", n.typeAnnotation ? ": " : "", r("typeAnnotation")]), e.semi ? we(";") : ""]), ot(t, e), e.bracketSpacing ? he : Y, "}"], { shouldBreak: i });
}
var Zm = oC("typeParameters");
function a5(t, e, r) {
  let { node: n } = t;
  return Wt(n).length === 1 && n.type.startsWith("TS") && !n[r][0].constraint && t.parent.type === "ArrowFunctionExpression" && !(e.filepath && /\.ts$/.test(e.filepath));
}
function Pa(t, e, r, n) {
  let { node: i } = t;
  if (!i[n])
    return "";
  if (!Array.isArray(i[n]))
    return r(n);
  let s = t.getNode(2), o = s && ph(s), l = t.match((h) => !(h[n].length === 1 && Ii(h[n][0])), void 0, (h, p) => p === "typeAnnotation", (h) => h.type === "Identifier", Fv);
  if (i[n].length === 0 || !l && (o || i[n].length === 1 && (i[n][0].type === "NullableTypeAnnotation" || Iv(i[n][0]))))
    return ["<", Ne(", ", t.map(r, n)), l5(t, e), ">"];
  let u = i.type === "TSTypeParameterInstantiation" ? "" : a5(t, e, n) ? "," : Wi(e) ? we(",") : "";
  return q(["<", te([Y, Ne([",", he], t.map(r, n))]), u, Y, ">"], { id: Zm(i) });
}
function l5(t, e) {
  let { node: r } = t;
  if (!se(r, de.Dangling))
    return "";
  let n = !se(r, de.Line), i = ot(t, e, { indent: !n });
  return n ? i : [i, ee];
}
function lC(t, e, r) {
  let { node: n, parent: i } = t, s = [n.type === "TSTypeParameter" && n.const ? "const " : ""], o = n.type === "TSTypeParameter" ? r("name") : n.name;
  if (i.type === "TSMappedType")
    return i.readonly && s.push(aC(i.readonly, "readonly"), " "), s.push("[", o), n.constraint && s.push(" in ", r("constraint")), i.nameType && s.push(" as ", t.callParent(() => r("nameType"))), s.push("]"), s;
  if (n.variance && s.push(r("variance")), n.in && s.push("in "), n.out && s.push("out "), s.push(o), n.bound && (n.usesExtendsBound && s.push(" extends "), s.push(Ft(t, r, "bound"))), n.constraint) {
    let l = Symbol("constraint");
    s.push(" extends", q(te(he), { id: l }), Un, fh(r("constraint"), { groupId: l }));
  }
  return n.default && s.push(" = ", r("default")), q(s);
}
var uC = Je(["ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
function cC(t, e, r) {
  let { node: n } = t, i = [Rr(t), gh(t), "class"], s = se(n.id, de.Trailing) || se(n.typeParameters, de.Trailing) || se(n.superClass) || je(n.extends) || je(n.mixins) || je(n.implements), o = [], l = [];
  if (n.id && o.push(" ", r("id")), o.push(r("typeParameters")), n.superClass) {
    let u = [c5(t, e, r), r("superTypeParameters")], h = t.call((p) => ["extends ", en(p, u, e)], "superClass");
    s ? l.push(he, q(h)) : l.push(" ", h);
  } else
    l.push(fp(t, e, r, "extends"));
  if (l.push(fp(t, e, r, "mixins"), fp(t, e, r, "implements")), s) {
    let u;
    dC(n) ? u = [...o, te(l)] : u = te([...o, l]), i.push(q(u, { id: hC(n) }));
  } else
    i.push(...o, ...l);
  return i.push(" ", r("body")), i;
}
var hC = oC("heritageGroup");
function pC(t) {
  return we(ee, "", { groupId: hC(t) });
}
function u5(t) {
  return ["extends", "mixins", "implements"].reduce((e, r) => e + (Array.isArray(t[r]) ? t[r].length : 0), t.superClass ? 1 : 0) > 1;
}
function dC(t) {
  return t.typeParameters && !se(t.typeParameters, de.Trailing | de.Line) && !u5(t);
}
function fp(t, e, r, n) {
  let { node: i } = t;
  if (!je(i[n]))
    return "";
  let s = ot(t, e, { marker: n });
  return [dC(i) ? we(" ", he, { groupId: Zm(i.typeParameters) }) : he, s, s && ee, n, q(te([he, Ne([",", he], t.map(r, n))]))];
}
function c5(t, e, r) {
  let n = r("superClass"), { parent: i } = t;
  return i.type === "AssignmentExpression" ? q(we(["(", te([Y, n]), Y, ")"], n)) : n;
}
function fC(t, e, r) {
  let { node: n } = t, i = [];
  return je(n.decorators) && i.push(vv(t, e, r)), i.push(sc(n)), n.static && i.push("static "), i.push(gh(t)), n.override && i.push("override "), i.push(Ad(t, e, r)), i;
}
function mC(t, e, r) {
  let { node: n } = t, i = [], s = e.semi ? ";" : "";
  je(n.decorators) && i.push(vv(t, e, r)), i.push(sc(n), Rr(t)), n.static && i.push("static "), i.push(gh(t)), n.override && i.push("override "), n.readonly && i.push("readonly "), n.variance && i.push(r("variance")), (n.type === "ClassAccessorProperty" || n.type === "AccessorProperty" || n.type === "TSAbstractAccessorProperty") && i.push("accessor "), i.push(El(t, e, r), Gt(t), zv(t), Ft(t, r));
  let o = n.type === "TSAbstractPropertyDefinition" || n.type === "TSAbstractAccessorProperty";
  return [Cl(t, e, r, i, " =", o ? void 0 : "value"), s];
}
function h5(t, e, r) {
  let { node: n } = t, i = [];
  return t.each(({ node: s, next: o, isLast: l }) => {
    i.push(r()), !e.semi && uC(s) && p5(s, o) && i.push(";"), l || (i.push(ee), Ui(s, e) && i.push(ee));
  }, "body"), se(n, de.Dangling) && i.push(ot(t, e)), [je(n.body) ? pC(t.parent) : "", "{", i.length > 0 ? [te([ee, i]), ee] : "", "}"];
}
function p5(t, e) {
  var r;
  let { type: n, name: i } = t.key;
  if (!t.computed && n === "Identifier" && (i === "static" || i === "get" || i === "set") && !t.value && !t.typeAnnotation)
    return !0;
  if (!e || e.static || e.accessibility)
    return !1;
  if (!e.computed) {
    let s = (r = e.key) == null ? void 0 : r.name;
    if (s === "in" || s === "instanceof")
      return !0;
  }
  if (uC(e) && e.variance && !e.static && !e.declare)
    return !0;
  switch (e.type) {
    case "ClassProperty":
    case "PropertyDefinition":
    case "TSAbstractPropertyDefinition":
      return e.computed;
    case "MethodDefinition":
    case "TSAbstractMethodDefinition":
    case "ClassMethod":
    case "ClassPrivateMethod": {
      if ((e.value ? e.value.async : e.async) || e.kind === "get" || e.kind === "set")
        return !1;
      let s = e.value ? e.value.generator : e.generator;
      return !!(e.computed || s);
    }
    case "TSIndexSignature":
      return !0;
  }
  return !1;
}
function d5(t, e) {
  if (e.semi || yC(t, e) || xC(t, e))
    return !1;
  let { node: r, key: n, parent: i } = t;
  return !!(r.type === "ExpressionStatement" && (n === "body" && (i.type === "Program" || i.type === "BlockStatement" || i.type === "StaticBlock" || i.type === "TSModuleBlock") || n === "consequent" && i.type === "SwitchCase") && t.call(() => gC(t, e), "expression"));
}
function gC(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "ParenthesizedExpression":
    case "TypeCastExpression":
    case "ArrayExpression":
    case "ArrayPattern":
    case "TemplateLiteral":
    case "TemplateElement":
    case "RegExpLiteral":
      return !0;
    case "ArrowFunctionExpression":
      if (!eC(t, e))
        return !0;
      break;
    case "UnaryExpression": {
      let { prefix: n, operator: i } = r;
      if (n && (i === "+" || i === "-"))
        return !0;
      break;
    }
    case "BindExpression":
      if (!r.object)
        return !0;
      break;
    case "Literal":
      if (r.regex)
        return !0;
      break;
    default:
      if (Dt(r))
        return !0;
  }
  return Os(t, e) ? !0 : Lm(r) ? t.call(() => gC(t, e), ...Ib(r)) : !1;
}
function yC({ node: t, parent: e }, r) {
  return (r.parentParser === "markdown" || r.parentParser === "mdx") && t.type === "ExpressionStatement" && Dt(t.expression) && e.type === "Program" && e.body.length === 1;
}
function DC(t) {
  switch (t.type) {
    case "MemberExpression":
      switch (t.property.type) {
        case "Identifier":
        case "NumericLiteral":
        case "StringLiteral":
          return DC(t.object);
      }
      return !1;
    case "Identifier":
      return !0;
    default:
      return !1;
  }
}
function xC({ node: t, parent: e }, r) {
  return (r.parser === "__vue_event_binding" || r.parser === "__vue_ts_event_binding") && t.type === "ExpressionStatement" && e.type === "Program" && e.body.length === 1;
}
function f5(t, e, r) {
  let n = [r("expression")];
  return xC(t, e) ? DC(t.node.expression) && n.push(";") : yC(t, e) || e.semi && n.push(";"), n;
}
function m5(t, e, r) {
  if (e.__isVueBindings || e.__isVueForBindingLeft) {
    let n = t.map(r, "program", "body", 0, "params");
    if (n.length === 1)
      return n[0];
    let i = Ne([",", he], n);
    return e.__isVueForBindingLeft ? ["(", te([Y, q(i)]), Y, ")"] : i;
  }
  if (e.__isEmbeddedTypescriptGenericParameters) {
    let n = t.map(r, "program", "body", 0, "typeParameters", "params");
    return Ne([",", he], n);
  }
}
function g5(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "RegExpLiteral":
      return B0(r);
    case "BigIntLiteral":
      return wd(r.extra.raw);
    case "NumericLiteral":
      return xi(r.extra.raw);
    case "StringLiteral":
      return ys(Wa(r.extra.raw, e));
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return String(r.value);
    case "DecimalLiteral":
      return xi(r.value) + "m";
    case "DirectiveLiteral":
      return I0(r.extra.raw, e);
    case "Literal": {
      if (r.regex)
        return B0(r.regex);
      if (r.bigint)
        return wd(r.raw);
      if (r.decimal)
        return xi(r.decimal) + "m";
      let { value: n } = r;
      return typeof n == "number" ? xi(r.raw) : typeof n == "string" ? y5(t) ? I0(r.raw, e) : ys(Wa(r.raw, e)) : String(n);
    }
  }
}
function y5(t) {
  if (t.key !== "expression")
    return;
  let { parent: e } = t;
  return e.type === "ExpressionStatement" && e.directive;
}
function wd(t) {
  return t.toLowerCase();
}
function B0({ pattern: t, flags: e }) {
  return e = [...e].sort().join(""), `/${t}/${e}`;
}
function I0(t, e) {
  let r = t.slice(1, -1);
  if (r.includes('"') || r.includes("'"))
    return t;
  let n = e.singleQuote ? "'" : '"';
  return n + r + n;
}
function D5(t, e, r) {
  let n = t.originalText.slice(e, r);
  for (let i of t[Symbol.for("comments")]) {
    let s = st(i);
    if (s > r)
      break;
    let o = qe(i);
    if (o < e)
      continue;
    let l = o - s;
    n = n.slice(0, s - e) + " ".repeat(l) + n.slice(o - e);
  }
  return n;
}
var eg = D5;
function x5(t, e, r) {
  let { node: n } = t;
  return ["import", n.module ? " module" : "", n.phase ? ` ${n.phase}` : "", CC(n), EC(t, e, r), AC(t, e, r), SC(t, e, r), e.semi ? ";" : ""];
}
var bC = (t) => t.type === "ExportDefaultDeclaration" || t.type === "DeclareExportDeclaration" && t.default;
function vC(t, e, r) {
  let { node: n } = t, i = [n_(t, e, r), Rr(t), "export", bC(n) ? " default" : ""], { declaration: s, exported: o } = n;
  return se(n, de.Dangling) && (i.push(" ", ot(t, e)), Wb(n) && i.push(ee)), s ? i.push(" ", r("declaration")) : (i.push(C5(n)), n.type === "ExportAllDeclaration" || n.type === "DeclareExportAllDeclaration" ? (i.push(" *"), o && i.push(" as ", r("exported"))) : i.push(EC(t, e, r)), i.push(AC(t, e, r), SC(t, e, r))), i.push(v5(n, e)), i;
}
var b5 = Je(["ClassDeclaration", "FunctionDeclaration", "TSInterfaceDeclaration", "DeclareClass", "DeclareFunction", "TSDeclareFunction", "EnumDeclaration"]);
function v5(t, e) {
  return e.semi && (!t.declaration || bC(t) && !b5(t.declaration)) ? ";" : "";
}
function tg(t, e = !0) {
  return t && t !== "value" ? `${e ? " " : ""}${t}${e ? "" : " "}` : "";
}
function CC(t, e) {
  return tg(t.importKind, e);
}
function C5(t) {
  return tg(t.exportKind);
}
function AC(t, e, r) {
  let { node: n } = t;
  if (!n.source)
    return "";
  let i = [];
  return wC(n, e) && i.push(" from"), i.push(" ", r("source")), i;
}
function EC(t, e, r) {
  let { node: n } = t;
  if (!wC(n, e))
    return "";
  let i = [" "];
  if (je(n.specifiers)) {
    let s = [], o = [];
    t.each(() => {
      let l = t.node.type;
      if (l === "ExportNamespaceSpecifier" || l === "ExportDefaultSpecifier" || l === "ImportNamespaceSpecifier" || l === "ImportDefaultSpecifier")
        s.push(r());
      else if (l === "ExportSpecifier" || l === "ImportSpecifier")
        o.push(r());
      else
        throw new $o(n, "specifier");
    }, "specifiers"), i.push(Ne(", ", s)), o.length > 0 && (s.length > 0 && i.push(", "), o.length > 1 || s.length > 0 || n.specifiers.some((l) => se(l)) ? i.push(q(["{", te([e.bracketSpacing ? he : Y, Ne([",", he], o)]), we(Wi(e) ? "," : ""), e.bracketSpacing ? he : Y, "}"])) : i.push(["{", e.bracketSpacing ? " " : "", ...o, e.bracketSpacing ? " " : "", "}"]));
  } else
    i.push("{}");
  return i;
}
function wC(t, e) {
  return t.type !== "ImportDeclaration" || je(t.specifiers) || t.importKind === "type" ? !0 : eg(e, st(t), st(t.source)).trimEnd().endsWith("from");
}
function A5(t, e) {
  var r, n;
  if ((r = t.extra) != null && r.deprecatedAssertSyntax)
    return "assert";
  let i = eg(e, qe(t.source), (n = t.attributes) != null && n[0] ? st(t.attributes[0]) : qe(t)).trimStart();
  return i.startsWith("assert") ? "assert" : i.startsWith("with") || je(t.attributes) ? "with" : void 0;
}
function SC(t, e, r) {
  let { node: n } = t;
  if (!n.source)
    return "";
  let i = A5(n, e);
  if (!i)
    return "";
  let s = [` ${i} {`];
  return je(n.attributes) && (e.bracketSpacing && s.push(" "), s.push(Ne(", ", t.map(r, "attributes"))), e.bracketSpacing && s.push(" ")), s.push("}"), s;
}
function E5(t, e, r) {
  let { node: n } = t, { type: i } = n, s = i.startsWith("Import"), o = s ? "imported" : "local", l = s ? "local" : "exported", u = n[o], h = n[l], p = "", d = "";
  return i === "ExportNamespaceSpecifier" || i === "ImportNamespaceSpecifier" ? p = "*" : u && (p = r(o)), h && !w5(n) && (d = r(l)), [tg(i === "ImportSpecifier" ? n.importKind : n.exportKind, !1), p, p && d ? " as " : "", d];
}
function w5(t) {
  if (t.type !== "ImportSpecifier" && t.type !== "ExportSpecifier")
    return !1;
  let { local: e, [t.type === "ImportSpecifier" ? "imported" : "exported"]: r } = t;
  if (e.type !== r.type || !KL(e, r))
    return !1;
  if (ir(e))
    return e.value === r.value && Lr(e) === Lr(r);
  switch (e.type) {
    case "Identifier":
      return e.name === r.name;
    default:
      return !1;
  }
}
function yh(t, e, r) {
  var n;
  let i = e.semi ? ";" : "", { node: s } = t, o = s.type === "ObjectTypeAnnotation", l = s.type === "TSEnumDeclaration" || s.type === "EnumBooleanBody" || s.type === "EnumNumberBody" || s.type === "EnumStringBody" || s.type === "EnumSymbolBody", u = [s.type === "TSTypeLiteral" || l ? "members" : s.type === "TSInterfaceBody" ? "body" : "properties"];
  o && u.push("indexers", "callProperties", "internalSlots");
  let h = u.flatMap((T) => t.map(({ node: P }) => ({ node: P, printed: r(), loc: st(P) }), T));
  u.length > 1 && h.sort((T, P) => T.loc - P.loc);
  let { parent: p, key: d } = t, m = o && d === "body" && (p.type === "InterfaceDeclaration" || p.type === "DeclareInterface" || p.type === "DeclareClass"), y = s.type === "TSInterfaceBody" || l || m || s.type === "ObjectPattern" && p.type !== "FunctionDeclaration" && p.type !== "FunctionExpression" && p.type !== "ArrowFunctionExpression" && p.type !== "ObjectMethod" && p.type !== "ClassMethod" && p.type !== "ClassPrivateMethod" && p.type !== "AssignmentPattern" && p.type !== "CatchClause" && s.properties.some((T) => T.value && (T.value.type === "ObjectPattern" || T.value.type === "ArrayPattern")) || s.type !== "ObjectPattern" && h.length > 0 && Ni(e.originalText, st(s), h[0].loc), D = m ? ";" : s.type === "TSInterfaceBody" || s.type === "TSTypeLiteral" ? we(i, ";") : ",", b = s.type === "RecordExpression" ? "#{" : s.exact ? "{|" : "{", C = s.exact ? "|}" : "}", A = [], x = h.map((T) => {
    let P = [...A, q(T.printed)];
    return A = [D, he], (T.node.type === "TSPropertySignature" || T.node.type === "TSMethodSignature" || T.node.type === "TSConstructSignatureDeclaration" || T.node.type === "TSCallSignatureDeclaration") && se(T.node, de.PrettierIgnore) && A.shift(), Ui(T.node, e) && A.push(ee), P;
  });
  if (s.inexact || s.hasUnknownMembers) {
    let T;
    if (se(s, de.Dangling)) {
      let P = se(s, de.Line);
      T = [ot(t, e), P || xr(e.originalText, qe(We(!1, oo(s), -1))) ? ee : he, "..."];
    } else
      T = ["..."];
    x.push([...A, ...T]);
  }
  let E = (n = We(!1, h, -1)) == null ? void 0 : n.node, k = !(s.inexact || s.hasUnknownMembers || E && (E.type === "RestElement" || (E.type === "TSPropertySignature" || E.type === "TSCallSignatureDeclaration" || E.type === "TSMethodSignature" || E.type === "TSConstructSignatureDeclaration") && se(E, de.PrettierIgnore))), w;
  if (x.length === 0) {
    if (!se(s, de.Dangling))
      return [b, C, Ft(t, r)];
    w = q([b, ot(t, e, { indent: !0 }), Y, C, Gt(t), Ft(t, r)]);
  } else
    w = [m && je(s.properties) ? pC(p) : "", b, te([e.bracketSpacing ? he : Y, ...x]), we(k && (D !== "," || Wi(e)) ? D : ""), e.bracketSpacing ? he : Y, C, Gt(t), Ft(t, r)];
  return t.match((T) => T.type === "ObjectPattern" && !je(T.decorators), mp) || Ii(s) && (t.match(void 0, (T, P) => P === "typeAnnotation", (T, P) => P === "typeAnnotation", mp) || t.match(void 0, (T, P) => T.type === "FunctionTypeParam" && P === "typeAnnotation", mp)) || !y && t.match((T) => T.type === "ObjectPattern", (T) => T.type === "AssignmentExpression" || T.type === "VariableDeclarator") ? w : q(w, { shouldBreak: y });
}
function mp(t, e) {
  return (e === "params" || e === "parameters" || e === "this" || e === "rest") && Bv(t);
}
function S5(t) {
  let e = [t];
  for (let r = 0; r < e.length; r++) {
    let n = e[r];
    for (let i of ["test", "consequent", "alternate"]) {
      let s = n[i];
      if (Dt(s))
        return !0;
      s.type === "ConditionalExpression" && e.push(s);
    }
  }
  return !1;
}
function T5(t, e, r) {
  let { node: n } = t, i = n.type === "ConditionalExpression", s = i ? "alternate" : "falseType", { parent: o } = t, l = i ? r("test") : [r("checkType"), " ", "extends", " ", r("extendsType")];
  return o.type === n.type && o[s] === n ? Fn(2, l) : l;
}
var k5 = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
function F5(t) {
  let { node: e } = t;
  if (e.type !== "ConditionalExpression")
    return !1;
  let r, n = e;
  for (let i = 0; !r; i++) {
    let s = t.getParentNode(i);
    if (s.type === "ChainExpression" && s.expression === n || Re(s) && s.callee === n || it(s) && s.object === n || s.type === "TSNonNullExpression" && s.expression === n) {
      n = s;
      continue;
    }
    s.type === "NewExpression" && s.callee === n || xn(s) && s.expression === n ? (r = t.getParentNode(i + 1), n = s) : r = s;
  }
  return n === e ? !1 : r[k5.get(r.type)] === n;
}
function P5(t, e, r) {
  let { node: n } = t, i = n.type === "ConditionalExpression", s = i ? "consequent" : "trueType", o = i ? "alternate" : "falseType", l = i ? ["test"] : ["checkType", "extendsType"], u = n[s], h = n[o], p = [], d = !1, { parent: m } = t, y = m.type === n.type && l.some((N) => m[N] === n), D = m.type === n.type && !y, b, C, A = 0;
  do
    C = b || n, b = t.getParentNode(A), A++;
  while (b && b.type === n.type && l.every((N) => b[N] !== C));
  let x = b || m, E = C;
  if (i && (Dt(n[l[0]]) || Dt(u) || Dt(h) || S5(E))) {
    d = !0, D = !0;
    let N = (j) => [we("("), te([Y, j]), Y, we(")")], L = (j) => j.type === "NullLiteral" || j.type === "Literal" && j.value === null || j.type === "Identifier" && j.name === "undefined";
    p.push(" ? ", L(u) ? r(s) : N(r(s)), " : ", h.type === n.type || L(h) ? r(o) : N(r(o)));
  } else {
    let N = (j) => e.useTabs ? te(r(j)) : Fn(2, r(j)), L = [he, "? ", u.type === n.type ? we("", "(") : "", N(s), u.type === n.type ? we("", ")") : "", he, ": ", N(o)];
    p.push(m.type !== n.type || m[o] === n || y ? L : e.useTabs ? Gb(te(L)) : Fn(Math.max(0, e.tabWidth - 2), L));
  }
  let k = [s, o, ...l].some((N) => se(n[N], (L) => qr(L) && Ni(e.originalText, st(L), qe(L)))), w = (N) => m === x ? q(N, { shouldBreak: k }) : k ? [N, Pn] : N, T = !d && (it(m) || m.type === "NGPipeExpression" && m.left === n) && !m.computed, P = F5(t), M = w([T5(t, e, r), D ? p : te(p), i && T && !P ? Y : ""]);
  return y || P ? q([te([Y, M]), Y]) : M;
}
function B5(t, e) {
  return (it(e) || e.type === "NGPipeExpression" && e.left === t) && !e.computed;
}
function I5(t, e, r, n) {
  return [...t.map((i) => oo(i)), oo(e), oo(r)].flat().some((i) => qr(i) && Ni(n.originalText, st(i), qe(i)));
}
var N5 = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
function M5(t) {
  let { node: e } = t;
  if (e.type !== "ConditionalExpression")
    return !1;
  let r, n = e;
  for (let i = 0; !r; i++) {
    let s = t.getParentNode(i);
    if (s.type === "ChainExpression" && s.expression === n || Re(s) && s.callee === n || it(s) && s.object === n || s.type === "TSNonNullExpression" && s.expression === n) {
      n = s;
      continue;
    }
    s.type === "NewExpression" && s.callee === n || xn(s) && s.expression === n ? (r = t.getParentNode(i + 1), n = s) : r = s;
  }
  return n === e ? !1 : r[N5.get(r.type)] === n;
}
var gp = (t) => [we("("), te([Y, t]), Y, we(")")];
function rg(t, e, r, n) {
  if (!e.experimentalTernaries)
    return P5(t, e, r);
  let { node: i } = t, s = i.type === "ConditionalExpression", o = i.type === "TSConditionalType" || i.type === "ConditionalTypeAnnotation", l = s ? "consequent" : "trueType", u = s ? "alternate" : "falseType", h = s ? ["test"] : ["checkType", "extendsType"], p = i[l], d = i[u], m = h.map((Te) => i[Te]), { parent: y } = t, D = y.type === i.type, b = D && h.some((Te) => y[Te] === i), C = D && y[u] === i, A = p.type === i.type, x = d.type === i.type, E = x || C, k = e.tabWidth > 2 || e.useTabs, w, T, P = 0;
  do
    T = w || i, w = t.getParentNode(P), P++;
  while (w && w.type === i.type && h.every((Te) => w[Te] !== T));
  let M = w || y, N = n && n.assignmentLayout && n.assignmentLayout !== "break-after-operator" && (y.type === "AssignmentExpression" || y.type === "VariableDeclarator" || y.type === "ClassProperty" || y.type === "PropertyDefinition" || y.type === "ClassPrivateProperty" || y.type === "ObjectProperty" || y.type === "Property"), L = (y.type === "ReturnStatement" || y.type === "ThrowStatement") && !(A || x), j = s && M.type === "JSXExpressionContainer" && t.grandparent.type !== "JSXAttribute", X = M5(t), Q = B5(i, y), $ = o && Os(t, e), U = k ? e.useTabs ? "	" : " ".repeat(e.tabWidth - 1) : "", H = I5(m, p, d, e) || A || x, Z = !E && !D && !o && (j ? p.type === "NullLiteral" || p.type === "Literal" && p.value === null : $m(p, e) && d0(i.test, 3)), ye = E || C || o && !D || D && s && d0(i.test, 1) || Z, Ee = [];
  !A && se(p, de.Dangling) && t.call((Te) => {
    Ee.push(ot(Te, e), ee);
  }, "consequent");
  let ve = [];
  se(i.test, de.Dangling) && t.call((Te) => {
    ve.push(ot(Te, e));
  }, "test"), !x && se(d, de.Dangling) && t.call((Te) => {
    ve.push(ot(Te, e));
  }, "alternate"), se(i, de.Dangling) && ve.push(ot(t, e));
  let $e = Symbol("test"), Ke = Symbol("consequent"), Qe = Symbol("test-and-consequent"), Fe = s ? [gp(r("test")), i.test.type === "ConditionalExpression" ? Pn : ""] : [r("checkType"), " ", "extends", " ", i.extendsType.type === "TSConditionalType" || i.extendsType.type === "ConditionalTypeAnnotation" || i.extendsType.type === "TSMappedType" ? r("extendsType") : q(gp(r("extendsType")))], ht = q([Fe, " ?"], { id: $e }), le = r(l), z = te([A || j && (Dt(p) || D || E) ? ee : he, Ee, le]), W = ye ? q([ht, E ? z : we(z, q(z, { id: Ke }), { groupId: $e })], { id: Qe }) : [ht, z], R = r(u), Ce = Z ? we(R, Gb(gp(R)), { groupId: Qe }) : R, be = [W, ve.length > 0 ? [te([ee, ve]), ee] : x ? ee : Z ? we(he, " ", { groupId: Qe }) : he, ":", x ? " " : k ? ye ? we(U, we(E || Z ? " " : U, " "), { groupId: Qe }) : we(U, " ") : " ", x ? Ce : q([te(Ce), j && !Z ? Y : ""]), Q && !X ? Y : "", H ? Pn : ""];
  return N && !H ? q(te([Y, q(be)])) : N || L ? q(te(be)) : X || o && b ? q([te([Y, be]), $ ? Y : ""]) : y === M ? q(be) : be;
}
function O5(t, e, r, n) {
  let { node: i } = t;
  if (ch(i))
    return g5(t, e);
  let s = e.semi ? ";" : "", o = [];
  switch (i.type) {
    case "JsExpressionRoot":
      return r("node");
    case "JsonRoot":
      return [r("node"), ee];
    case "File":
      return m5(t, e, r) ?? r("program");
    case "Program":
      return sC(t, e, r);
    case "EmptyStatement":
      return "";
    case "ExpressionStatement":
      return f5(t, e, r);
    case "ChainExpression":
      return r("expression");
    case "ParenthesizedExpression":
      return !se(i.expression) && (tn(i.expression) || Bt(i.expression)) ? ["(", r("expression"), ")"] : q(["(", te([Y, r("expression")]), Y, ")"]);
    case "AssignmentExpression":
      return g_(t, e, r);
    case "VariableDeclarator":
      return y_(t, e, r);
    case "BinaryExpression":
    case "LogicalExpression":
      return bv(t, e, r);
    case "AssignmentPattern":
      return [r("left"), " = ", r("right")];
    case "OptionalMemberExpression":
    case "MemberExpression":
      return p_(t, e, r);
    case "MetaProperty":
      return [r("meta"), ".", r("property")];
    case "BindExpression":
      return i.object && o.push(r("object")), o.push(q(te([Y, Jv(t, e, r)]))), o;
    case "Identifier":
      return [i.name, Gt(t), zv(t), Ft(t, r)];
    case "V8IntrinsicIdentifier":
      return ["%", i.name];
    case "SpreadElement":
    case "SpreadElementPattern":
    case "SpreadPropertyPattern":
    case "RestElement":
      return Kv(t, r);
    case "FunctionDeclaration":
    case "FunctionExpression":
      return Zv(t, r, e, n);
    case "ArrowFunctionExpression":
      return X_(t, e, r, n);
    case "YieldExpression":
      return o.push("yield"), i.delegate && o.push("*"), i.argument && o.push(" ", r("argument")), o;
    case "AwaitExpression":
      if (o.push("await"), i.argument) {
        o.push(" ", r("argument"));
        let { parent: l } = t;
        if (Re(l) && l.callee === i || it(l) && l.object === i) {
          o = [te([Y, ...o]), Y];
          let u = t.findAncestor((h) => h.type === "AwaitExpression" || h.type === "BlockStatement");
          if ((u == null ? void 0 : u.type) !== "AwaitExpression" || !zt(u.argument, (h) => h === i))
            return q(o);
        }
      }
      return o;
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ExportAllDeclaration":
      return vC(t, e, r);
    case "ImportDeclaration":
      return x5(t, e, r);
    case "ImportSpecifier":
    case "ExportSpecifier":
    case "ImportNamespaceSpecifier":
    case "ExportNamespaceSpecifier":
    case "ImportDefaultSpecifier":
    case "ExportDefaultSpecifier":
      return E5(t, e, r);
    case "ImportAttribute":
      return [r("key"), ": ", r("value")];
    case "Import":
      return "import";
    case "BlockStatement":
    case "StaticBlock":
      return iC(t, e, r);
    case "ClassBody":
      return h5(t, e, r);
    case "ThrowStatement":
      return K_(t, e, r);
    case "ReturnStatement":
      return J_(t, e, r);
    case "NewExpression":
    case "ImportExpression":
    case "OptionalCallExpression":
    case "CallExpression":
      return Tv(t, e, r);
    case "ObjectExpression":
    case "ObjectPattern":
    case "RecordExpression":
      return yh(t, e, r);
    case "Property":
      return hh(i) ? Ad(t, e, r) : P0(t, e, r);
    case "ObjectProperty":
      return P0(t, e, r);
    case "ObjectMethod":
      return Ad(t, e, r);
    case "Decorator":
      return ["@", r("expression")];
    case "ArrayExpression":
    case "ArrayPattern":
    case "TupleExpression":
      return Xm(t, e, r);
    case "SequenceExpression": {
      let { parent: l } = t;
      if (l.type === "ExpressionStatement" || l.type === "ForStatement") {
        let u = [];
        return t.each(({ isFirst: h }) => {
          h ? u.push(r()) : u.push(",", te([he, r()]));
        }, "expressions"), q(u);
      }
      return q(Ne([",", he], t.map(r, "expressions")));
    }
    case "ThisExpression":
      return "this";
    case "Super":
      return "super";
    case "Directive":
      return [r("value"), s];
    case "UnaryExpression":
      return o.push(i.operator), /[a-z]$/.test(i.operator) && o.push(" "), se(i.argument) ? o.push(q(["(", te([Y, r("argument")]), Y, ")"])) : o.push(r("argument")), o;
    case "UpdateExpression":
      return o.push(r("argument"), i.operator), i.prefix && o.reverse(), o;
    case "ConditionalExpression":
      return rg(t, e, r, n);
    case "VariableDeclaration": {
      let l = t.map(r, "declarations"), u = t.parent, h = u.type === "ForStatement" || u.type === "ForInStatement" || u.type === "ForOfStatement", p = i.declarations.some((m) => m.init), d;
      return l.length === 1 && !se(i.declarations[0]) ? d = l[0] : l.length > 0 && (d = te(l[0])), o = [Rr(t), i.kind, d ? [" ", d] : "", te(l.slice(1).map((m) => [",", p && !h ? ee : he, m]))], h && u.body !== i || o.push(s), q(o);
    }
    case "WithStatement":
      return q(["with (", r("object"), ")", pi(i.body, r("body"))]);
    case "IfStatement": {
      let l = pi(i.consequent, r("consequent")), u = q(["if (", q([te([Y, r("test")]), Y]), ")", l]);
      if (o.push(u), i.alternate) {
        let h = se(i.consequent, de.Trailing | de.Line) || Wb(i), p = i.consequent.type === "BlockStatement" && !h;
        o.push(p ? " " : ee), se(i, de.Dangling) && o.push(ot(t, e), h ? ee : " "), o.push("else", q(pi(i.alternate, r("alternate"), i.alternate.type === "IfStatement")));
      }
      return o;
    }
    case "ForStatement": {
      let l = pi(i.body, r("body")), u = ot(t, e), h = u ? [u, Y] : "";
      return !i.init && !i.test && !i.update ? [h, q(["for (;;)", l])] : [h, q(["for (", q([te([Y, r("init"), ";", he, r("test"), ";", he, r("update")]), Y]), ")", l])];
    }
    case "WhileStatement":
      return q(["while (", q([te([Y, r("test")]), Y]), ")", pi(i.body, r("body"))]);
    case "ForInStatement":
      return q(["for (", r("left"), " in ", r("right"), ")", pi(i.body, r("body"))]);
    case "ForOfStatement":
      return q(["for", i.await ? " await" : "", " (", r("left"), " of ", r("right"), ")", pi(i.body, r("body"))]);
    case "DoWhileStatement": {
      let l = pi(i.body, r("body"));
      return o = [q(["do", l])], i.body.type === "BlockStatement" ? o.push(" ") : o.push(ee), o.push("while (", q([te([Y, r("test")]), Y]), ")", s), o;
    }
    case "DoExpression":
      return [i.async ? "async " : "", "do ", r("body")];
    case "BreakStatement":
    case "ContinueStatement":
      return o.push(i.type === "BreakStatement" ? "break" : "continue"), i.label && o.push(" ", r("label")), o.push(s), o;
    case "LabeledStatement":
      return i.body.type === "EmptyStatement" ? [r("label"), ":;"] : [r("label"), ": ", r("body")];
    case "TryStatement":
      return ["try ", r("block"), i.handler ? [" ", r("handler")] : "", i.finalizer ? [" finally ", r("finalizer")] : ""];
    case "CatchClause":
      if (i.param) {
        let l = se(i.param, (h) => !qr(h) || h.leading && xr(e.originalText, qe(h)) || h.trailing && xr(e.originalText, st(h), { backwards: !0 })), u = r("param");
        return ["catch ", l ? ["(", te([Y, u]), Y, ") "] : ["(", u, ") "], r("body")];
      }
      return ["catch ", r("body")];
    case "SwitchStatement":
      return [q(["switch (", te([Y, r("discriminant")]), Y, ")"]), " {", i.cases.length > 0 ? te([ee, Ne(ee, t.map(({ node: l, isLast: u }) => [r(), !u && Ui(l, e) ? ee : ""], "cases"))]) : "", ee, "}"];
    case "SwitchCase": {
      i.test ? o.push("case ", r("test"), ":") : o.push("default:"), se(i, de.Dangling) && o.push(" ", ot(t, e));
      let l = i.consequent.filter((u) => u.type !== "EmptyStatement");
      if (l.length > 0) {
        let u = Ed(t, e, r, "consequent");
        o.push(l.length === 1 && l[0].type === "BlockStatement" ? [" ", u] : te([ee, u]));
      }
      return o;
    }
    case "DebuggerStatement":
      return ["debugger", s];
    case "ClassDeclaration":
    case "ClassExpression":
      return cC(t, e, r);
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "MethodDefinition":
      return fC(t, e, r);
    case "ClassProperty":
    case "PropertyDefinition":
    case "ClassPrivateProperty":
    case "ClassAccessorProperty":
    case "AccessorProperty":
      return mC(t, e, r);
    case "TemplateElement":
      return ys(i.value.raw);
    case "TemplateLiteral":
      return pv(t, r, e);
    case "TaggedTemplateExpression":
      return O4(r);
    case "PrivateIdentifier":
      return ["#", i.name];
    case "PrivateName":
      return ["#", r("id")];
    case "TopicReference":
      return "%";
    case "ArgumentPlaceholder":
      return "?";
    case "ModuleExpression": {
      o.push("module {");
      let l = r("body");
      return l && o.push(te([ee, l]), ee), o.push("}"), o;
    }
    case "InterpreterDirective":
    default:
      throw new $o(i, "ESTree");
  }
}
function TC(t, e, r) {
  let { parent: n, node: i, key: s } = t, o = [r("expression")];
  switch (i.type) {
    case "AsConstExpression":
      o.push(" as const");
      break;
    case "AsExpression":
    case "TSAsExpression":
      o.push(" as ", r("typeAnnotation"));
      break;
    case "SatisfiesExpression":
    case "TSSatisfiesExpression":
      o.push(" satisfies ", r("typeAnnotation"));
      break;
  }
  return s === "callee" && Re(n) || s === "object" && it(n) ? q([te([Y, ...o]), Y]) : o;
}
function kC(t, e, r) {
  return yh(t, r, e);
}
function FC(t, e) {
  let { node: r } = t, n = e("id");
  r.computed && (n = ["[", n, "]"]);
  let i = "";
  return r.initializer && (i = e("initializer")), r.init && (i = e("init")), i ? [n, " = ", i] : n;
}
function L5(t, e, r) {
  let { node: n } = t, i;
  if (n.type === "EnumSymbolBody" || n.explicitType)
    switch (n.type) {
      case "EnumBooleanBody":
        i = "boolean";
        break;
      case "EnumNumberBody":
        i = "number";
        break;
      case "EnumStringBody":
        i = "string";
        break;
      case "EnumSymbolBody":
        i = "symbol";
        break;
    }
  return [i ? `of ${i} ` : "", kC(t, e, r)];
}
function PC(t, e, r) {
  let { node: n } = t;
  return [Rr(t), n.const ? "const " : "", "enum ", e("id"), " ", n.type === "TSEnumDeclaration" ? kC(t, e, r) : e("body")];
}
function BC(t, e, r) {
  let { node: n } = t, i = [Rr(t), "interface"], s = [], o = [];
  n.type !== "InterfaceTypeAnnotation" && s.push(" ", r("id"), r("typeParameters"));
  let l = n.typeParameters && !se(n.typeParameters, de.Trailing | de.Line);
  return je(n.extends) && o.push(l ? we(" ", he, { groupId: Zm(n.typeParameters) }) : he, "extends ", (n.extends.length === 1 ? x9 : te)(Ne([",", he], t.map(r, "extends")))), se(n.id, de.Trailing) || je(n.extends) ? l ? i.push(q([...s, te(o)])) : i.push(q(te([...s, ...o]))) : i.push(...s, ...o), i.push(" ", r("body")), q(i);
}
function _5(t, e, r) {
  let { node: n } = t;
  if (Pb(n))
    return n.type.slice(0, -14).toLowerCase();
  let i = e.semi ? ";" : "";
  switch (n.type) {
    case "DeclareClass":
      return cC(t, e, r);
    case "DeclareFunction":
      return [Rr(t), "function ", r("id"), r("predicate"), i];
    case "DeclareModule":
      return ["declare module ", r("id"), " ", r("body")];
    case "DeclareModuleExports":
      return ["declare module.exports", Ft(t, r), i];
    case "DeclareVariable":
      return [Rr(t), n.kind ?? "var", " ", r("id"), i];
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
      return vC(t, e, r);
    case "DeclareOpaqueType":
    case "OpaqueType":
      return L_(t, e, r);
    case "DeclareTypeAlias":
    case "TypeAlias":
      return Nv(t, e, r);
    case "IntersectionTypeAnnotation":
      return Mv(t, e, r);
    case "UnionTypeAnnotation":
      return Ov(t, e, r);
    case "ConditionalTypeAnnotation":
      return rg(t, e, r);
    case "InferTypeAnnotation":
      return $v(t, e, r);
    case "FunctionTypeAnnotation":
      return Lv(t, e, r);
    case "TupleTypeAnnotation":
      return Xm(t, e, r);
    case "TupleTypeLabeledElement":
      return jv(t, e, r);
    case "TupleTypeSpreadElement":
      return Rv(t, e, r);
    case "GenericTypeAnnotation":
      return [r("id"), Pa(t, e, r, "typeParameters")];
    case "IndexedAccessType":
    case "OptionalIndexedAccessType":
      return _v(t, e, r);
    case "TypeAnnotation":
      return Wv(t, e, r);
    case "TypeParameter":
      return lC(t, e, r);
    case "TypeofTypeAnnotation":
      return Hv(t, r);
    case "ExistsTypeAnnotation":
      return "*";
    case "ArrayTypeAnnotation":
      return Uv(r);
    case "DeclareEnum":
    case "EnumDeclaration":
      return PC(t, r, e);
    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
      return L5(t, r, e);
    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumStringMember":
    case "EnumDefaultedMember":
      return FC(t, r);
    case "FunctionTypeParam": {
      let s = n.name ? r("name") : t.parent.this === n ? "this" : "";
      return [s, Gt(t), s ? ": " : "", r("typeAnnotation")];
    }
    case "DeclareInterface":
    case "InterfaceDeclaration":
    case "InterfaceTypeAnnotation":
      return BC(t, e, r);
    case "ClassImplements":
    case "InterfaceExtends":
      return [r("id"), r("typeParameters")];
    case "NullableTypeAnnotation":
      return ["?", r("typeAnnotation")];
    case "Variance": {
      let { kind: s } = n;
      return Qv.ok(s === "plus" || s === "minus"), s === "plus" ? "+" : "-";
    }
    case "KeyofTypeAnnotation":
      return ["keyof ", r("argument")];
    case "ObjectTypeCallProperty":
      return [n.static ? "static " : "", r("value")];
    case "ObjectTypeMappedTypeProperty":
      return s5(t, e, r);
    case "ObjectTypeIndexer":
      return [n.static ? "static " : "", n.variance ? r("variance") : "", "[", r("id"), n.id ? ": " : "", r("key"), "]: ", r("value")];
    case "ObjectTypeProperty": {
      let s = "";
      return n.proto ? s = "proto " : n.static && (s = "static "), [s, n.kind !== "init" ? n.kind + " " : "", n.variance ? r("variance") : "", El(t, e, r), Gt(t), hh(n) ? "" : ": ", r("value")];
    }
    case "ObjectTypeAnnotation":
      return yh(t, e, r);
    case "ObjectTypeInternalSlot":
      return [n.static ? "static " : "", "[[", r("id"), "]]", Gt(t), n.method ? "" : ": ", r("value")];
    case "ObjectTypeSpreadProperty":
      return Kv(t, r);
    case "QualifiedTypeofIdentifier":
    case "QualifiedTypeIdentifier":
      return [r("qualification"), ".", r("id")];
    case "NullLiteralTypeAnnotation":
      return "null";
    case "BooleanLiteralTypeAnnotation":
      return String(n.value);
    case "StringLiteralTypeAnnotation":
      return ys(Wa(Lr(n), e));
    case "NumberLiteralTypeAnnotation":
      return xi(n.raw ?? n.extra.raw);
    case "BigIntLiteralTypeAnnotation":
      return wd(n.raw ?? n.extra.raw);
    case "TypeCastExpression":
      return ["(", r("expression"), Ft(t, r), ")"];
    case "TypePredicate":
      return Vv(t, r);
    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation":
      return Pa(t, e, r, "params");
    case "InferredPredicate":
    case "DeclaredPredicate":
      return [t.key === "predicate" && t.parent.type !== "DeclareFunction" && !t.parent.returnType ? ": " : " ", "%checks", ...n.type === "DeclaredPredicate" ? ["(", r("value"), ")"] : []];
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
      return TC(t, e, r);
  }
}
function $5(t, e, r) {
  var n;
  let { node: i } = t;
  if (!i.type.startsWith("TS"))
    return;
  if (Bb(i))
    return i.type.slice(2, -7).toLowerCase();
  let s = e.semi ? ";" : "", o = [];
  switch (i.type) {
    case "TSThisType":
      return "this";
    case "TSTypeAssertion": {
      let l = !(Bt(i.expression) || tn(i.expression)), u = q(["<", te([Y, r("typeAnnotation")]), Y, ">"]), h = [we("("), te([Y, r("expression")]), Y, we(")")];
      return l ? is([[u, r("expression")], [u, q(h, { shouldBreak: !0 })], [u, r("expression")]]) : q([u, r("expression")]);
    }
    case "TSDeclareFunction":
      return Zv(t, r, e);
    case "TSExportAssignment":
      return ["export = ", r("expression"), s];
    case "TSModuleBlock":
      return iC(t, e, r);
    case "TSInterfaceBody":
    case "TSTypeLiteral":
      return yh(t, e, r);
    case "TSTypeAliasDeclaration":
      return Nv(t, e, r);
    case "TSQualifiedName":
      return [r("left"), ".", r("right")];
    case "TSAbstractMethodDefinition":
    case "TSDeclareMethod":
      return fC(t, e, r);
    case "TSAbstractAccessorProperty":
    case "TSAbstractPropertyDefinition":
      return mC(t, e, r);
    case "TSInterfaceHeritage":
    case "TSClassImplements":
    case "TSExpressionWithTypeArguments":
    case "TSInstantiationExpression":
      return [r("expression"), r("typeParameters")];
    case "TSTemplateLiteralType":
      return pv(t, r, e);
    case "TSNamedTupleMember":
      return jv(t, e, r);
    case "TSRestType":
      return Rv(t, e, r);
    case "TSOptionalType":
      return [r("typeAnnotation"), "?"];
    case "TSInterfaceDeclaration":
      return BC(t, e, r);
    case "TSTypeParameterDeclaration":
    case "TSTypeParameterInstantiation":
      return Pa(t, e, r, "params");
    case "TSTypeParameter":
      return lC(t, e, r);
    case "TSAsExpression":
    case "TSSatisfiesExpression":
      return TC(t, e, r);
    case "TSArrayType":
      return Uv(r);
    case "TSPropertySignature":
      return [i.readonly ? "readonly " : "", El(t, e, r), Gt(t), Ft(t, r)];
    case "TSParameterProperty":
      return [sc(i), i.static ? "static " : "", i.override ? "override " : "", i.readonly ? "readonly " : "", r("parameter")];
    case "TSTypeQuery":
      return Hv(t, r);
    case "TSIndexSignature": {
      let l = i.parameters.length > 1 ? we(Wi(e) ? "," : "") : "", u = q([te([Y, Ne([", ", Y], t.map(r, "parameters"))]), l, Y]), h = t.parent.type === "ClassBody" && t.key === "body";
      return [h && i.static ? "static " : "", i.readonly ? "readonly " : "", "[", i.parameters ? u : "", "]", Ft(t, r), h ? s : ""];
    }
    case "TSTypePredicate":
      return Vv(t, r);
    case "TSNonNullExpression":
      return [r("expression"), "!"];
    case "TSImportType":
      return [i.isTypeOf ? "typeof " : "", "import(", r("argument"), ")", i.qualifier ? [".", r("qualifier")] : "", Pa(t, e, r, i.typeArguments ? "typeArguments" : "typeParameters")];
    case "TSLiteralType":
      return r("literal");
    case "TSIndexedAccessType":
      return _v(t, e, r);
    case "TSTypeOperator":
      return [i.operator, " ", r("typeAnnotation")];
    case "TSMappedType":
      return o5(t, e, r);
    case "TSMethodSignature": {
      let l = i.kind && i.kind !== "method" ? `${i.kind} ` : "";
      o.push(sc(i), l, i.computed ? "[" : "", r("key"), i.computed ? "]" : "", Gt(t));
      let u = Al(t, r, e, !1, !0), h = i.returnType ? "returnType" : "typeAnnotation", p = i[h], d = p ? Ft(t, r, h) : "", m = mh(i, d);
      return o.push(m ? q(u) : u), p && o.push(q(d)), q(o);
    }
    case "TSNamespaceExportDeclaration":
      return ["export as namespace ", r("id"), e.semi ? ";" : ""];
    case "TSEnumDeclaration":
      return PC(t, r, e);
    case "TSEnumMember":
      return FC(t, r);
    case "TSImportEqualsDeclaration":
      return [i.isExport ? "export " : "", "import ", CC(i, !1), r("id"), " = ", r("moduleReference"), e.semi ? ";" : ""];
    case "TSExternalModuleReference":
      return ["require(", r("expression"), ")"];
    case "TSModuleDeclaration": {
      let { parent: l } = t, u = l.type === "TSModuleDeclaration", h = ((n = i.body) == null ? void 0 : n.type) === "TSModuleDeclaration";
      if (u)
        o.push(".");
      else if (o.push(Rr(t)), !(i.kind === "global" || i.global)) {
        let p = i.kind ?? (ir(i.id) || eg(e, st(i), st(i.id)).trim().endsWith("module") ? "module" : "namespace");
        o.push(p, " ");
      }
      return o.push(r("id")), h ? o.push(r("body")) : i.body ? o.push(" ", q(r("body"))) : o.push(s), o;
    }
    case "TSConditionalType":
      return rg(t, e, r);
    case "TSInferType":
      return $v(t, e, r);
    case "TSIntersectionType":
      return Mv(t, e, r);
    case "TSUnionType":
      return Ov(t, e, r);
    case "TSFunctionType":
    case "TSCallSignatureDeclaration":
    case "TSConstructorType":
    case "TSConstructSignatureDeclaration":
      return Lv(t, e, r);
    case "TSTupleType":
      return Xm(t, e, r);
    case "TSTypeReference":
      return [r("typeName"), Pa(t, e, r, "typeParameters")];
    case "TSTypeAnnotation":
      return Wv(t, e, r);
    case "TSEmptyBodyFunctionExpression":
      return Ym(t, e, r);
    case "TSJSDocAllType":
      return "*";
    case "TSJSDocUnknownType":
      return "?";
    case "TSJSDocNullableType":
      return F0(t, r, "?");
    case "TSJSDocNonNullableType":
      return F0(t, r, "!");
    case "TSParenthesizedType":
    default:
      throw new $o(i, "TypeScript");
  }
}
function R5(t, e, r, n) {
  if (xv(t))
    return D6(t, e);
  for (let i of [e_, J6, _5, $5, O5]) {
    let s = i(t, e, r, n);
    if (s !== void 0)
      return s;
  }
}
var j5 = Je(["ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "ClassPrivateProperty", "MethodDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod"]);
function q5(t, e, r, n) {
  var i;
  t.isRoot && ((i = e.__onHtmlBindingRoot) == null || i.call(e, t.node, e));
  let s = R5(t, e, r, n);
  if (!s)
    return "";
  let { node: o } = t;
  if (j5(o))
    return s;
  let l = je(o.decorators), u = i_(t, e, r), h = o.type === "ClassExpression";
  if (l && !h)
    return fd(s, (m) => q([u, m]));
  let p = Os(t, e), d = d5(t, e);
  return !u && !p && !d ? s : fd(s, (m) => [d ? ";" : "", p ? "(" : "", p && h && l ? [te([he, u, m]), he] : [u, m], p ? ")" : ""]);
}
var W5 = q5, U5 = { avoidAstMutation: !0 }, H5 = [{ linguistLanguageId: 174, name: "JSON.stringify", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"], parsers: ["json-stringify"], vscodeLanguageIds: ["json"] }, { linguistLanguageId: 174, name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".all-contributorsrc", ".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "flake.lock", "mcmod.info", ".babelrc", ".jscsrc", ".jshintrc", ".jslintrc", ".swcrc"], parsers: ["json"], vscodeLanguageIds: ["json"] }, { linguistLanguageId: 423, name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".code-workspace", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [], parsers: ["jsonc"], vscodeLanguageIds: ["jsonc"] }, { linguistLanguageId: 175, name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", parsers: ["json5"], vscodeLanguageIds: ["json5"] }], IC = {};
ah(IC, { getVisitorKeys: () => K5, massageAstNode: () => NC, print: () => G5 });
var V5 = { JsonRoot: ["node"], ArrayExpression: ["elements"], ObjectExpression: ["properties"], ObjectProperty: ["key", "value"], UnaryExpression: ["argument"], NullLiteral: [], BooleanLiteral: [], StringLiteral: [], NumericLiteral: [], Identifier: [], TemplateLiteral: ["quasis"], TemplateElement: [] }, z5 = V5, J5 = kb(z5), K5 = J5;
function G5(t, e, r) {
  let { node: n } = t;
  switch (n.type) {
    case "JsonRoot":
      return [r("node"), ee];
    case "ArrayExpression": {
      if (n.elements.length === 0)
        return "[]";
      let i = t.map(() => t.node === null ? "null" : r(), "elements");
      return ["[", te([ee, Ne([",", ee], i)]), ee, "]"];
    }
    case "ObjectExpression":
      return n.properties.length === 0 ? "{}" : ["{", te([ee, Ne([",", ee], t.map(r, "properties"))]), ee, "}"];
    case "ObjectProperty":
      return [r("key"), ": ", r("value")];
    case "UnaryExpression":
      return [n.operator === "+" ? "" : n.operator, r("argument")];
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return n.value ? "true" : "false";
    case "StringLiteral":
      return JSON.stringify(n.value);
    case "NumericLiteral":
      return N0(t) ? JSON.stringify(String(n.value)) : JSON.stringify(n.value);
    case "Identifier":
      return N0(t) ? JSON.stringify(n.name) : n.name;
    case "TemplateLiteral":
      return r(["quasis", 0]);
    case "TemplateElement":
      return JSON.stringify(n.value.cooked);
    default:
      throw new $o(n, "JSON");
  }
}
function N0(t) {
  return t.key === "key" && t.parent.type === "ObjectProperty";
}
var X5 = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
function NC(t, e) {
  let { type: r } = t;
  if (r === "ObjectProperty") {
    let { key: n } = t;
    n.type === "Identifier" ? e.key = { type: "StringLiteral", value: n.name } : n.type === "NumericLiteral" && (e.key = { type: "StringLiteral", value: String(n.value) });
    return;
  }
  if (r === "UnaryExpression" && t.operator === "+")
    return e.argument;
  if (r === "ArrayExpression") {
    for (let [n, i] of t.elements.entries())
      i === null && e.elements.splice(n, 0, { type: "NullLiteral" });
    return;
  }
  if (r === "TemplateLiteral")
    return { type: "StringLiteral", value: t.quasis[0].value.cooked };
}
NC.ignoredProperties = X5;
var nu = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, Gi = "JavaScript", Y5 = { arrowParens: { category: Gi, type: "choice", default: "always", description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: nu.bracketSameLine, bracketSpacing: nu.bracketSpacing, jsxBracketSameLine: { category: Gi, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { category: Gi, type: "boolean", default: !0, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, experimentalTernaries: { category: Gi, type: "boolean", default: !1, description: "Use curious ternaries, with the question mark after the condition.", oppositeDescription: "Default behavior of ternaries; keep question marks on the same line as the consequent." }, singleQuote: nu.singleQuote, jsxSingleQuote: { category: Gi, type: "boolean", default: !1, description: "Use single quotes in JSX." }, quoteProps: { category: Gi, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { category: Gi, type: "choice", default: "all", description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "all", description: "Trailing commas wherever possible (including function arguments)." }, { value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }] }, singleAttributePerLine: nu.singleAttributePerLine }, Q5 = Y5, Z5 = { estree: Sb, "estree-json": IC }, e7 = [...DL, ...H5], t7 = wb, r7 = Object.create, ng = Object.defineProperty, n7 = Object.getOwnPropertyDescriptor, i7 = Object.getOwnPropertyNames, s7 = Object.getPrototypeOf, o7 = Object.prototype.hasOwnProperty, MC = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), a7 = (t, e) => {
  for (var r in e)
    ng(t, r, { get: e[r], enumerable: !0 });
}, l7 = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of i7(e))
      !o7.call(t, i) && i !== r && ng(t, i, { get: () => e[i], enumerable: !(n = n7(e, i)) || n.enumerable });
  return t;
}, ig = (t, e, r) => (r = t != null ? r7(s7(t)) : {}, l7(e || !t || !t.__esModule ? ng(r, "default", { value: t, enumerable: !0 }) : r, t)), OC = MC((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(c, a) {
    if (c == null)
      return {};
    var f = {}, g = Object.keys(c), v, S;
    for (S = 0; S < g.length; S++)
      v = g[S], !(a.indexOf(v) >= 0) && (f[v] = c[v]);
    return f;
  }
  var r = class {
    constructor(c, a, f) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = c, this.column = a, this.index = f;
    }
  }, n = class {
    constructor(c, a) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = c, this.end = a;
    }
  };
  function i(c, a) {
    let { line: f, column: g, index: v } = c;
    return new r(f, g + a, v + a);
  }
  var s = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", o = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: s }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: s } }, l = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, u = ({ type: c, prefix: a }) => c === "UpdateExpression" ? l.UpdateExpression[String(a)] : l[c], h = { AccessorIsGenerator: ({ kind: c }) => `A ${c}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: c }) => `Missing initializer in ${c} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: c }) => `\`${c}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", DynamicImportPhaseRequiresImportExpressions: ({ phase: c }) => `'import.${c}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: c, exportName: a }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${c}' as '${a}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: c }) => `'${c === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: c }) => `Unsyntactic ${c === "BreakStatement" ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: ({ importName: c }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${c}" as foo }\`?`, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: ({ maxArgumentCount: c }) => `\`import()\` requires exactly ${c === 1 ? "one argument" : "one or two arguments"}.`, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: c }) => `Expected number in radix ${c}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: c }) => `Escape sequence in keyword ${c}.`, InvalidIdentifier: ({ identifierName: c }) => `Invalid identifier ${c}.`, InvalidLhs: ({ ancestor: c }) => `Invalid left-hand side in ${u(c)}.`, InvalidLhsBinding: ({ ancestor: c }) => `Binding invalid left-hand side in ${u(c)}.`, InvalidLhsOptionalChaining: ({ ancestor: c }) => `Invalid optional chaining in the left-hand side of ${u(c)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: c }) => `Unexpected character '${c}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: c }) => `Private name #${c} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: c }) => `Label '${c}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: c }) => `This experimental syntax requires enabling the parser plugin: ${c.map((a) => JSON.stringify(a)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: c }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${c.map((a) => JSON.stringify(a)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: c }) => `Duplicate key "${c}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: c }) => `An export name cannot include a lone surrogate, found '\\u${c.toString(16)}'.`, ModuleExportUndefined: ({ localName: c }) => `Export '${c}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: c }) => `Private names are only allowed in property accesses (\`obj.#${c}\`) or in \`in\` expressions (\`#${c} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: c }) => `Duplicate private name #${c}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: c }) => `Unexpected keyword '${c}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: c }) => `Unexpected reserved word '${c}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: c, unexpected: a }) => `Unexpected token${a ? ` '${a}'.` : ""}${c ? `, expected "${c}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: c, onlyValidPropertyName: a }) => `The only valid meta property for ${c} is ${c}.${a}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: c }) => `Identifier '${c}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, p = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: c }) => `Assigning to '${c}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: c }) => `Binding '${c}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, d = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), m = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: c }) => `Invalid topic token ${c}. In order to use ${c} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${c}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: c }) => `Hack-style pipe body cannot be an unparenthesized ${u({ type: c })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }, y = ["toMessage"], D = ["message"];
  function b(c, a, f) {
    Object.defineProperty(c, a, { enumerable: !1, configurable: !0, value: f });
  }
  function C(c) {
    let { toMessage: a } = c, f = e(c, y);
    return function g(v, S) {
      let F = new SyntaxError();
      return Object.assign(F, f, { loc: v, pos: v.index }), "missingPlugin" in S && Object.assign(F, { missingPlugin: S.missingPlugin }), b(F, "clone", function(B = {}) {
        var O;
        let { line: I, column: J, index: ne } = (O = B.loc) != null ? O : v;
        return g(new r(I, J, ne), Object.assign({}, S, B.details));
      }), b(F, "details", S), Object.defineProperty(F, "message", { configurable: !0, get() {
        let B = `${a(S)} (${v.line}:${v.column})`;
        return this.message = B, B;
      }, set(B) {
        Object.defineProperty(this, "message", { value: B, writable: !0 });
      } }), F;
    };
  }
  function A(c, a) {
    if (Array.isArray(c))
      return (g) => A(g, c[0]);
    let f = {};
    for (let g of Object.keys(c)) {
      let v = c[g], S = typeof v == "string" ? { message: () => v } : typeof v == "function" ? { message: v } : v, { message: F } = S, B = e(S, D), O = typeof F == "string" ? () => F : F;
      f[g] = C(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: g, toMessage: O }, a ? { syntaxPlugin: a } : {}, B));
    }
    return f;
  }
  var x = Object.assign({}, A(o), A(h), A(p), A`pipelineOperator`(m)), { defineProperty: E } = Object, k = (c, a) => E(c, a, { enumerable: !1, value: c[a] });
  function w(c) {
    return c.loc.start && k(c.loc.start, "index"), c.loc.end && k(c.loc.end, "index"), c;
  }
  var T = (c) => class extends c {
    parse() {
      let a = w(super.parse());
      return this.options.tokens && (a.tokens = a.tokens.map(w)), a;
    }
    parseRegExpLiteral({ pattern: a, flags: f }) {
      let g = null;
      try {
        g = new RegExp(a, f);
      } catch {
      }
      let v = this.estreeParseLiteral(g);
      return v.regex = { pattern: a, flags: f }, v;
    }
    parseBigIntLiteral(a) {
      let f;
      try {
        f = BigInt(a);
      } catch {
        f = null;
      }
      let g = this.estreeParseLiteral(f);
      return g.bigint = String(g.value || a), g;
    }
    parseDecimalLiteral(a) {
      let f = this.estreeParseLiteral(null);
      return f.decimal = String(f.value || a), f;
    }
    estreeParseLiteral(a) {
      return this.parseLiteral(a, "Literal");
    }
    parseStringLiteral(a) {
      return this.estreeParseLiteral(a);
    }
    parseNumericLiteral(a) {
      return this.estreeParseLiteral(a);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(a) {
      return this.estreeParseLiteral(a);
    }
    directiveToStmt(a) {
      let f = a.value;
      delete a.value, f.type = "Literal", f.raw = f.extra.raw, f.value = f.extra.expressionValue;
      let g = a;
      return g.type = "ExpressionStatement", g.expression = f, g.directive = f.extra.rawValue, delete f.extra, g;
    }
    initFunction(a, f) {
      super.initFunction(a, f), a.expression = !1;
    }
    checkDeclaration(a) {
      a != null && this.isObjectProperty(a) ? this.checkDeclaration(a.value) : super.checkDeclaration(a);
    }
    getObjectOrClassMethodParams(a) {
      return a.value.params;
    }
    isValidDirective(a) {
      var f;
      return a.type === "ExpressionStatement" && a.expression.type === "Literal" && typeof a.expression.value == "string" && !((f = a.expression.extra) != null && f.parenthesized);
    }
    parseBlockBody(a, f, g, v, S) {
      super.parseBlockBody(a, f, g, v, S);
      let F = a.directives.map((B) => this.directiveToStmt(B));
      a.body = F.concat(a.body), delete a.directives;
    }
    pushClassMethod(a, f, g, v, S, F) {
      this.parseMethod(f, g, v, S, F, "ClassMethod", !0), f.typeParameters && (f.value.typeParameters = f.typeParameters, delete f.typeParameters), a.body.push(f);
    }
    parsePrivateName() {
      let a = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(a) : a;
    }
    convertPrivateNameToPrivateIdentifier(a) {
      let f = super.getPrivateNameSV(a);
      return a = a, delete a.id, a.name = f, a.type = "PrivateIdentifier", a;
    }
    isPrivateName(a) {
      return this.getPluginOption("estree", "classFeatures") ? a.type === "PrivateIdentifier" : super.isPrivateName(a);
    }
    getPrivateNameSV(a) {
      return this.getPluginOption("estree", "classFeatures") ? a.name : super.getPrivateNameSV(a);
    }
    parseLiteral(a, f) {
      let g = super.parseLiteral(a, f);
      return g.raw = g.extra.raw, delete g.extra, g;
    }
    parseFunctionBody(a, f, g = !1) {
      super.parseFunctionBody(a, f, g), a.expression = a.body.type !== "BlockStatement";
    }
    parseMethod(a, f, g, v, S, F, B = !1) {
      let O = this.startNode();
      return O.kind = a.kind, O = super.parseMethod(O, f, g, v, S, F, B), O.type = "FunctionExpression", delete O.kind, a.value = O, F === "ClassPrivateMethod" && (a.computed = !1), this.finishNode(a, "MethodDefinition");
    }
    parseClassProperty(...a) {
      let f = super.parseClassProperty(...a);
      return this.getPluginOption("estree", "classFeatures") && (f.type = "PropertyDefinition"), f;
    }
    parseClassPrivateProperty(...a) {
      let f = super.parseClassPrivateProperty(...a);
      return this.getPluginOption("estree", "classFeatures") && (f.type = "PropertyDefinition", f.computed = !1), f;
    }
    parseObjectMethod(a, f, g, v, S) {
      let F = super.parseObjectMethod(a, f, g, v, S);
      return F && (F.type = "Property", F.kind === "method" && (F.kind = "init"), F.shorthand = !1), F;
    }
    parseObjectProperty(a, f, g, v) {
      let S = super.parseObjectProperty(a, f, g, v);
      return S && (S.kind = "init", S.type = "Property"), S;
    }
    isValidLVal(a, f, g) {
      return a === "Property" ? "value" : super.isValidLVal(a, f, g);
    }
    isAssignable(a, f) {
      return a != null && this.isObjectProperty(a) ? this.isAssignable(a.value, f) : super.isAssignable(a, f);
    }
    toAssignable(a, f = !1) {
      if (a != null && this.isObjectProperty(a)) {
        let { key: g, value: v } = a;
        this.isPrivateName(g) && this.classScope.usePrivateName(this.getPrivateNameSV(g), g.loc.start), this.toAssignable(v, f);
      } else
        super.toAssignable(a, f);
    }
    toAssignableObjectExpressionProp(a, f, g) {
      a.kind === "get" || a.kind === "set" ? this.raise(x.PatternHasAccessor, a.key) : a.method ? this.raise(x.PatternHasMethod, a.key) : super.toAssignableObjectExpressionProp(a, f, g);
    }
    finishCallExpression(a, f) {
      let g = super.finishCallExpression(a, f);
      if (g.callee.type === "Import") {
        if (g.type = "ImportExpression", g.source = g.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var v, S;
          g.options = (v = g.arguments[1]) != null ? v : null, g.attributes = (S = g.arguments[1]) != null ? S : null;
        }
        delete g.arguments, delete g.callee;
      }
      return g;
    }
    toReferencedArguments(a) {
      a.type !== "ImportExpression" && super.toReferencedArguments(a);
    }
    parseExport(a, f) {
      let g = this.state.lastTokStartLoc, v = super.parseExport(a, f);
      switch (v.type) {
        case "ExportAllDeclaration":
          v.exported = null;
          break;
        case "ExportNamedDeclaration":
          v.specifiers.length === 1 && v.specifiers[0].type === "ExportNamespaceSpecifier" && (v.type = "ExportAllDeclaration", v.exported = v.specifiers[0].exported, delete v.specifiers);
        case "ExportDefaultDeclaration":
          {
            var S;
            let { declaration: F } = v;
            (F == null ? void 0 : F.type) === "ClassDeclaration" && ((S = F.decorators) == null ? void 0 : S.length) > 0 && F.start === v.start && this.resetStartLocation(v, g);
          }
          break;
      }
      return v;
    }
    parseSubscript(a, f, g, v) {
      let S = super.parseSubscript(a, f, g, v);
      if (v.optionalChainMember) {
        if ((S.type === "OptionalMemberExpression" || S.type === "OptionalCallExpression") && (S.type = S.type.substring(8)), v.stop) {
          let F = this.startNodeAtNode(S);
          return F.expression = S, this.finishNode(F, "ChainExpression");
        }
      } else
        (S.type === "MemberExpression" || S.type === "CallExpression") && (S.optional = !1);
      return S;
    }
    isOptionalMemberExpression(a) {
      return a.type === "ChainExpression" ? a.expression.type === "MemberExpression" : super.isOptionalMemberExpression(a);
    }
    hasPropertyAsPrivateName(a) {
      return a.type === "ChainExpression" && (a = a.expression), super.hasPropertyAsPrivateName(a);
    }
    isObjectProperty(a) {
      return a.type === "Property" && a.kind === "init" && !a.method;
    }
    isObjectMethod(a) {
      return a.method || a.kind === "get" || a.kind === "set";
    }
    finishNodeAt(a, f, g) {
      return w(super.finishNodeAt(a, f, g));
    }
    resetStartLocation(a, f) {
      super.resetStartLocation(a, f), w(a);
    }
    resetEndLocation(a, f = this.state.lastTokEndLoc) {
      super.resetEndLocation(a, f), w(a);
    }
  }, P = class {
    constructor(c, a) {
      this.token = void 0, this.preserveSpace = void 0, this.token = c, this.preserveSpace = !!a;
    }
  }, M = { brace: new P("{"), j_oTag: new P("<tag"), j_cTag: new P("</tag"), j_expr: new P("<tag>...</tag>", !0) };
  M.template = new P("`", !0);
  var N = !0, L = !0, j = !0, X = !0, Q = !0, $ = !0, U = class {
    constructor(c, a = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = c, this.keyword = a.keyword, this.beforeExpr = !!a.beforeExpr, this.startsExpr = !!a.startsExpr, this.rightAssociative = !!a.rightAssociative, this.isLoop = !!a.isLoop, this.isAssign = !!a.isAssign, this.prefix = !!a.prefix, this.postfix = !!a.postfix, this.binop = a.binop != null ? a.binop : null, this.updateContext = null;
    }
  }, H = /* @__PURE__ */ new Map();
  function Z(c, a = {}) {
    a.keyword = c;
    let f = le(c, a);
    return H.set(c, f), f;
  }
  function ye(c, a) {
    return le(c, { beforeExpr: N, binop: a });
  }
  var Ee = -1, ve = [], $e = [], Ke = [], Qe = [], Fe = [], ht = [];
  function le(c, a = {}) {
    var f, g, v, S;
    return ++Ee, $e.push(c), Ke.push((f = a.binop) != null ? f : -1), Qe.push((g = a.beforeExpr) != null ? g : !1), Fe.push((v = a.startsExpr) != null ? v : !1), ht.push((S = a.prefix) != null ? S : !1), ve.push(new U(c, a)), Ee;
  }
  function z(c, a = {}) {
    var f, g, v, S;
    return ++Ee, H.set(c, Ee), $e.push(c), Ke.push((f = a.binop) != null ? f : -1), Qe.push((g = a.beforeExpr) != null ? g : !1), Fe.push((v = a.startsExpr) != null ? v : !1), ht.push((S = a.prefix) != null ? S : !1), ve.push(new U("name", a)), Ee;
  }
  var W = { bracketL: le("[", { beforeExpr: N, startsExpr: L }), bracketHashL: le("#[", { beforeExpr: N, startsExpr: L }), bracketBarL: le("[|", { beforeExpr: N, startsExpr: L }), bracketR: le("]"), bracketBarR: le("|]"), braceL: le("{", { beforeExpr: N, startsExpr: L }), braceBarL: le("{|", { beforeExpr: N, startsExpr: L }), braceHashL: le("#{", { beforeExpr: N, startsExpr: L }), braceR: le("}"), braceBarR: le("|}"), parenL: le("(", { beforeExpr: N, startsExpr: L }), parenR: le(")"), comma: le(",", { beforeExpr: N }), semi: le(";", { beforeExpr: N }), colon: le(":", { beforeExpr: N }), doubleColon: le("::", { beforeExpr: N }), dot: le("."), question: le("?", { beforeExpr: N }), questionDot: le("?."), arrow: le("=>", { beforeExpr: N }), template: le("template"), ellipsis: le("...", { beforeExpr: N }), backQuote: le("`", { startsExpr: L }), dollarBraceL: le("${", { beforeExpr: N, startsExpr: L }), templateTail: le("...`", { startsExpr: L }), templateNonTail: le("...${", { beforeExpr: N, startsExpr: L }), at: le("@"), hash: le("#", { startsExpr: L }), interpreterDirective: le("#!..."), eq: le("=", { beforeExpr: N, isAssign: X }), assign: le("_=", { beforeExpr: N, isAssign: X }), slashAssign: le("_=", { beforeExpr: N, isAssign: X }), xorAssign: le("_=", { beforeExpr: N, isAssign: X }), moduloAssign: le("_=", { beforeExpr: N, isAssign: X }), incDec: le("++/--", { prefix: Q, postfix: $, startsExpr: L }), bang: le("!", { beforeExpr: N, prefix: Q, startsExpr: L }), tilde: le("~", { beforeExpr: N, prefix: Q, startsExpr: L }), doubleCaret: le("^^", { startsExpr: L }), doubleAt: le("@@", { startsExpr: L }), pipeline: ye("|>", 0), nullishCoalescing: ye("??", 1), logicalOR: ye("||", 1), logicalAND: ye("&&", 2), bitwiseOR: ye("|", 3), bitwiseXOR: ye("^", 4), bitwiseAND: ye("&", 5), equality: ye("==/!=/===/!==", 6), lt: ye("</>/<=/>=", 7), gt: ye("</>/<=/>=", 7), relational: ye("</>/<=/>=", 7), bitShift: ye("<</>>/>>>", 8), bitShiftL: ye("<</>>/>>>", 8), bitShiftR: ye("<</>>/>>>", 8), plusMin: le("+/-", { beforeExpr: N, binop: 9, prefix: Q, startsExpr: L }), modulo: le("%", { binop: 10, startsExpr: L }), star: le("*", { binop: 10 }), slash: ye("/", 10), exponent: le("**", { beforeExpr: N, binop: 11, rightAssociative: !0 }), _in: Z("in", { beforeExpr: N, binop: 7 }), _instanceof: Z("instanceof", { beforeExpr: N, binop: 7 }), _break: Z("break"), _case: Z("case", { beforeExpr: N }), _catch: Z("catch"), _continue: Z("continue"), _debugger: Z("debugger"), _default: Z("default", { beforeExpr: N }), _else: Z("else", { beforeExpr: N }), _finally: Z("finally"), _function: Z("function", { startsExpr: L }), _if: Z("if"), _return: Z("return", { beforeExpr: N }), _switch: Z("switch"), _throw: Z("throw", { beforeExpr: N, prefix: Q, startsExpr: L }), _try: Z("try"), _var: Z("var"), _const: Z("const"), _with: Z("with"), _new: Z("new", { beforeExpr: N, startsExpr: L }), _this: Z("this", { startsExpr: L }), _super: Z("super", { startsExpr: L }), _class: Z("class", { startsExpr: L }), _extends: Z("extends", { beforeExpr: N }), _export: Z("export"), _import: Z("import", { startsExpr: L }), _null: Z("null", { startsExpr: L }), _true: Z("true", { startsExpr: L }), _false: Z("false", { startsExpr: L }), _typeof: Z("typeof", { beforeExpr: N, prefix: Q, startsExpr: L }), _void: Z("void", { beforeExpr: N, prefix: Q, startsExpr: L }), _delete: Z("delete", { beforeExpr: N, prefix: Q, startsExpr: L }), _do: Z("do", { isLoop: j, beforeExpr: N }), _for: Z("for", { isLoop: j }), _while: Z("while", { isLoop: j }), _as: z("as", { startsExpr: L }), _assert: z("assert", { startsExpr: L }), _async: z("async", { startsExpr: L }), _await: z("await", { startsExpr: L }), _defer: z("defer", { startsExpr: L }), _from: z("from", { startsExpr: L }), _get: z("get", { startsExpr: L }), _let: z("let", { startsExpr: L }), _meta: z("meta", { startsExpr: L }), _of: z("of", { startsExpr: L }), _sent: z("sent", { startsExpr: L }), _set: z("set", { startsExpr: L }), _source: z("source", { startsExpr: L }), _static: z("static", { startsExpr: L }), _using: z("using", { startsExpr: L }), _yield: z("yield", { startsExpr: L }), _asserts: z("asserts", { startsExpr: L }), _checks: z("checks", { startsExpr: L }), _exports: z("exports", { startsExpr: L }), _global: z("global", { startsExpr: L }), _implements: z("implements", { startsExpr: L }), _intrinsic: z("intrinsic", { startsExpr: L }), _infer: z("infer", { startsExpr: L }), _is: z("is", { startsExpr: L }), _mixins: z("mixins", { startsExpr: L }), _proto: z("proto", { startsExpr: L }), _require: z("require", { startsExpr: L }), _satisfies: z("satisfies", { startsExpr: L }), _keyof: z("keyof", { startsExpr: L }), _readonly: z("readonly", { startsExpr: L }), _unique: z("unique", { startsExpr: L }), _abstract: z("abstract", { startsExpr: L }), _declare: z("declare", { startsExpr: L }), _enum: z("enum", { startsExpr: L }), _module: z("module", { startsExpr: L }), _namespace: z("namespace", { startsExpr: L }), _interface: z("interface", { startsExpr: L }), _type: z("type", { startsExpr: L }), _opaque: z("opaque", { startsExpr: L }), name: le("name", { startsExpr: L }), string: le("string", { startsExpr: L }), num: le("num", { startsExpr: L }), bigint: le("bigint", { startsExpr: L }), decimal: le("decimal", { startsExpr: L }), regexp: le("regexp", { startsExpr: L }), privateName: le("#name", { startsExpr: L }), eof: le("eof"), jsxName: le("jsxName"), jsxText: le("jsxText", { beforeExpr: !0 }), jsxTagStart: le("jsxTagStart", { startsExpr: !0 }), jsxTagEnd: le("jsxTagEnd"), placeholder: le("%%", { startsExpr: !0 }) };
  function R(c) {
    return c >= 93 && c <= 132;
  }
  function Ce(c) {
    return c <= 92;
  }
  function be(c) {
    return c >= 58 && c <= 132;
  }
  function Te(c) {
    return c >= 58 && c <= 136;
  }
  function Qt(c) {
    return Qe[c];
  }
  function Mt(c) {
    return Fe[c];
  }
  function xt(c) {
    return c >= 29 && c <= 33;
  }
  function Ur(c) {
    return c >= 129 && c <= 131;
  }
  function ii(c) {
    return c >= 90 && c <= 92;
  }
  function or(c) {
    return c >= 58 && c <= 92;
  }
  function Er(c) {
    return c >= 39 && c <= 59;
  }
  function on(c) {
    return c === 34;
  }
  function si(c) {
    return ht[c];
  }
  function Ln(c) {
    return c >= 121 && c <= 123;
  }
  function _n(c) {
    return c >= 124 && c <= 130;
  }
  function an(c) {
    return $e[c];
  }
  function Ls(c) {
    return Ke[c];
  }
  function Il(c) {
    return c === 57;
  }
  function _s(c) {
    return c >= 24 && c <= 25;
  }
  function Hr(c) {
    return ve[c];
  }
  ve[8].updateContext = (c) => {
    c.pop();
  }, ve[5].updateContext = ve[7].updateContext = ve[23].updateContext = (c) => {
    c.push(M.brace);
  }, ve[22].updateContext = (c) => {
    c[c.length - 1] === M.template ? c.pop() : c.push(M.template);
  }, ve[142].updateContext = (c) => {
    c.push(M.j_expr, M.j_oTag);
  };
  var Ho = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", Nl = "-----------------------------------------------------------------------------------------------------------------------------------------------------", _ = new RegExp("[" + Ho + "]"), ie = new RegExp("[" + Ho + Nl + "]");
  Ho = Nl = null;
  var pe = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], Pe = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function ze(c, a) {
    let f = 65536;
    for (let g = 0, v = a.length; g < v; g += 2) {
      if (f += a[g], f > c)
        return !1;
      if (f += a[g + 1], f >= c)
        return !0;
    }
    return !1;
  }
  function Oe(c) {
    return c < 65 ? c === 36 : c <= 90 ? !0 : c < 97 ? c === 95 : c <= 122 ? !0 : c <= 65535 ? c >= 170 && _.test(String.fromCharCode(c)) : ze(c, pe);
  }
  function Be(c) {
    return c < 48 ? c === 36 : c < 58 ? !0 : c < 65 ? !1 : c <= 90 ? !0 : c < 97 ? c === 95 : c <= 122 ? !0 : c <= 65535 ? c >= 170 && ie.test(String.fromCharCode(c)) : ze(c, pe) || ze(c, Pe);
  }
  var ke = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, Ot = new Set(ke.keyword), wr = new Set(ke.strict), ln = new Set(ke.strictBind);
  function $n(c, a) {
    return a && c === "await" || c === "enum";
  }
  function $s(c, a) {
    return $n(c, a) || wr.has(c);
  }
  function Mg(c) {
    return ln.has(c);
  }
  function Og(c, a) {
    return $s(c, a) || Mg(c);
  }
  function Uw(c) {
    return Ot.has(c);
  }
  function Hw(c, a, f) {
    return c === 64 && a === 64 && Oe(f);
  }
  var Vw = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function zw(c) {
    return Vw.has(c);
  }
  var Nh = class {
    constructor(c) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = c;
    }
  }, Mh = class {
    constructor(c, a) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = c, this.inModule = a;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let c = this.currentThisScopeFlags();
      return (c & 64) > 0 && (c & 2) === 0;
    }
    get inStaticBlock() {
      for (let c = this.scopeStack.length - 1; ; c--) {
        let { flags: a } = this.scopeStack[c];
        if (a & 128)
          return !0;
        if (a & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(c) {
      return new Nh(c);
    }
    enter(c) {
      this.scopeStack.push(this.createScope(c));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(c) {
      return !!(c.flags & 130 || !this.parser.inModule && c.flags & 1);
    }
    declareName(c, a, f) {
      let g = this.currentScope();
      if (a & 8 || a & 16) {
        this.checkRedeclarationInScope(g, c, a, f);
        let v = g.names.get(c) || 0;
        a & 16 ? v = v | 4 : (g.firstLexicalName || (g.firstLexicalName = c), v = v | 2), g.names.set(c, v), a & 8 && this.maybeExportDefined(g, c);
      } else if (a & 4)
        for (let v = this.scopeStack.length - 1; v >= 0 && (g = this.scopeStack[v], this.checkRedeclarationInScope(g, c, a, f), g.names.set(c, (g.names.get(c) || 0) | 1), this.maybeExportDefined(g, c), !(g.flags & 387)); --v)
          ;
      this.parser.inModule && g.flags & 1 && this.undefinedExports.delete(c);
    }
    maybeExportDefined(c, a) {
      this.parser.inModule && c.flags & 1 && this.undefinedExports.delete(a);
    }
    checkRedeclarationInScope(c, a, f, g) {
      this.isRedeclaredInScope(c, a, f) && this.parser.raise(x.VarRedeclaration, g, { identifierName: a });
    }
    isRedeclaredInScope(c, a, f) {
      if (!(f & 1))
        return !1;
      if (f & 8)
        return c.names.has(a);
      let g = c.names.get(a);
      return f & 16 ? (g & 2) > 0 || !this.treatFunctionsAsVarInScope(c) && (g & 1) > 0 : (g & 2) > 0 && !(c.flags & 8 && c.firstLexicalName === a) || !this.treatFunctionsAsVarInScope(c) && (g & 4) > 0;
    }
    checkLocalExport(c) {
      let { name: a } = c;
      this.scopeStack[0].names.has(a) || this.undefinedExports.set(a, c.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let c = this.scopeStack.length - 1; ; c--) {
        let { flags: a } = this.scopeStack[c];
        if (a & 387)
          return a;
      }
    }
    currentThisScopeFlags() {
      for (let c = this.scopeStack.length - 1; ; c--) {
        let { flags: a } = this.scopeStack[c];
        if (a & 451 && !(a & 4))
          return a;
      }
    }
  }, Jw = class extends Nh {
    constructor(...c) {
      super(...c), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, Kw = class extends Mh {
    createScope(c) {
      return new Jw(c);
    }
    declareName(c, a, f) {
      let g = this.currentScope();
      if (a & 2048) {
        this.checkRedeclarationInScope(g, c, a, f), this.maybeExportDefined(g, c), g.declareFunctions.add(c);
        return;
      }
      super.declareName(c, a, f);
    }
    isRedeclaredInScope(c, a, f) {
      if (super.isRedeclaredInScope(c, a, f))
        return !0;
      if (f & 2048 && !c.declareFunctions.has(a)) {
        let g = c.names.get(a);
        return (g & 4) > 0 || (g & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(c) {
      this.scopeStack[0].declareFunctions.has(c.name) || super.checkLocalExport(c);
    }
  }, Gw = class {
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(c) {
      if (typeof c == "string")
        return this.plugins.has(c);
      {
        let [a, f] = c;
        if (!this.hasPlugin(a))
          return !1;
        let g = this.plugins.get(a);
        for (let v of Object.keys(f))
          if ((g == null ? void 0 : g[v]) !== f[v])
            return !1;
        return !0;
      }
    }
    getPluginOption(c, a) {
      var f;
      return (f = this.plugins.get(c)) == null ? void 0 : f[a];
    }
  };
  function Lg(c, a) {
    c.trailingComments === void 0 ? c.trailingComments = a : c.trailingComments.unshift(...a);
  }
  function Xw(c, a) {
    c.leadingComments === void 0 ? c.leadingComments = a : c.leadingComments.unshift(...a);
  }
  function Vo(c, a) {
    c.innerComments === void 0 ? c.innerComments = a : c.innerComments.unshift(...a);
  }
  function zo(c, a, f) {
    let g = null, v = a.length;
    for (; g === null && v > 0; )
      g = a[--v];
    g === null || g.start > f.start ? Vo(c, f.comments) : Lg(g, f.comments);
  }
  var Yw = class extends Gw {
    addComment(c) {
      this.filename && (c.loc.filename = this.filename);
      let { commentsLen: a } = this.state;
      this.comments.length != a && (this.comments.length = a), this.comments.push(c), this.state.commentsLen++;
    }
    processComment(c) {
      let { commentStack: a } = this.state, f = a.length;
      if (f === 0)
        return;
      let g = f - 1, v = a[g];
      v.start === c.end && (v.leadingNode = c, g--);
      let { start: S } = c;
      for (; g >= 0; g--) {
        let F = a[g], B = F.end;
        if (B > S)
          F.containingNode = c, this.finalizeComment(F), a.splice(g, 1);
        else {
          B === S && (F.trailingNode = c);
          break;
        }
      }
    }
    finalizeComment(c) {
      let { comments: a } = c;
      if (c.leadingNode !== null || c.trailingNode !== null)
        c.leadingNode !== null && Lg(c.leadingNode, a), c.trailingNode !== null && Xw(c.trailingNode, a);
      else {
        let { containingNode: f, start: g } = c;
        if (this.input.charCodeAt(g - 1) === 44)
          switch (f.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              zo(f, f.properties, c);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              zo(f, f.arguments, c);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              zo(f, f.params, c);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              zo(f, f.elements, c);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              zo(f, f.specifiers, c);
              break;
            default:
              Vo(f, a);
          }
        else
          Vo(f, a);
      }
    }
    finalizeRemainingComments() {
      let { commentStack: c } = this.state;
      for (let a = c.length - 1; a >= 0; a--)
        this.finalizeComment(c[a]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(c) {
      let { commentStack: a } = this.state, { length: f } = a;
      if (f === 0)
        return;
      let g = a[f - 1];
      g.leadingNode === c && (g.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(c) {
      let { commentStack: a } = this.state, { length: f } = a;
      f !== 0 && (a[f - 1].trailingNode === c ? a[f - 1].trailingNode = null : f >= 2 && a[f - 2].trailingNode === c && (a[f - 2].trailingNode = null));
    }
    takeSurroundingComments(c, a, f) {
      let { commentStack: g } = this.state, v = g.length;
      if (v === 0)
        return;
      let S = v - 1;
      for (; S >= 0; S--) {
        let F = g[S], B = F.end;
        if (F.start === f)
          F.leadingNode = c;
        else if (B === a)
          F.trailingNode = c;
        else if (B < a)
          break;
      }
    }
  }, _g = /\r\n?|[\n\u2028\u2029]/, Ml = new RegExp(_g.source, "g");
  function Jo(c) {
    switch (c) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  var Oh = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Ol = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, $g = new RegExp("(?=(" + Ol.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function Qw(c) {
    switch (c) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  var Zw = class LC {
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [M.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(a) {
      a ? this.flags |= 1 : this.flags &= -2;
    }
    init({ strictMode: a, sourceType: f, startLine: g, startColumn: v }) {
      this.strict = a === !1 ? !1 : a === !0 ? !0 : f === "module", this.curLine = g, this.lineStart = -v, this.startLoc = this.endLoc = new r(g, v, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(a) {
      a ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(a) {
      a ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(a) {
      a ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(a) {
      a ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(a) {
      a ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(a) {
      a ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(a) {
      a ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(a) {
      a ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(a) {
      a ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(a) {
      a ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(a) {
      a ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new r(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      let a = new LC();
      return a.flags = this.flags, a.curLine = this.curLine, a.lineStart = this.lineStart, a.startLoc = this.startLoc, a.endLoc = this.endLoc, a.errors = this.errors.slice(), a.potentialArrowAt = this.potentialArrowAt, a.noArrowAt = this.noArrowAt.slice(), a.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), a.topicContext = this.topicContext, a.labels = this.labels.slice(), a.commentsLen = this.commentsLen, a.commentStack = this.commentStack.slice(), a.pos = this.pos, a.type = this.type, a.value = this.value, a.start = this.start, a.end = this.end, a.lastTokEndLoc = this.lastTokEndLoc, a.lastTokStartLoc = this.lastTokStartLoc, a.context = this.context.slice(), a.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, a.strictErrors = this.strictErrors, a.tokensLength = this.tokensLength, a;
    }
  }, eS = function(c) {
    return c >= 48 && c <= 57;
  }, Rg = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Ll = { bin: (c) => c === 48 || c === 49, oct: (c) => c >= 48 && c <= 55, dec: (c) => c >= 48 && c <= 57, hex: (c) => c >= 48 && c <= 57 || c >= 65 && c <= 70 || c >= 97 && c <= 102 };
  function jg(c, a, f, g, v, S) {
    let F = f, B = g, O = v, I = "", J = null, ne = f, { length: ue } = a;
    for (; ; ) {
      if (f >= ue) {
        S.unterminated(F, B, O), I += a.slice(ne, f);
        break;
      }
      let ae = a.charCodeAt(f);
      if (tS(c, ae, a, f)) {
        I += a.slice(ne, f);
        break;
      }
      if (ae === 92) {
        I += a.slice(ne, f);
        let Ve = rS(a, f, g, v, c === "template", S);
        Ve.ch === null && !J ? J = { pos: f, lineStart: g, curLine: v } : I += Ve.ch, { pos: f, lineStart: g, curLine: v } = Ve, ne = f;
      } else
        ae === 8232 || ae === 8233 ? (++f, ++v, g = f) : ae === 10 || ae === 13 ? c === "template" ? (I += a.slice(ne, f) + `
`, ++f, ae === 13 && a.charCodeAt(f) === 10 && ++f, ++v, ne = g = f) : S.unterminated(F, B, O) : ++f;
    }
    return { pos: f, str: I, firstInvalidLoc: J, lineStart: g, curLine: v, containsInvalid: !!J };
  }
  function tS(c, a, f, g) {
    return c === "template" ? a === 96 || a === 36 && f.charCodeAt(g + 1) === 123 : a === (c === "double" ? 34 : 39);
  }
  function rS(c, a, f, g, v, S) {
    let F = !v;
    a++;
    let B = (I) => ({ pos: a, ch: I, lineStart: f, curLine: g }), O = c.charCodeAt(a++);
    switch (O) {
      case 110:
        return B(`
`);
      case 114:
        return B("\r");
      case 120: {
        let I;
        return { code: I, pos: a } = Lh(c, a, f, g, 2, !1, F, S), B(I === null ? null : String.fromCharCode(I));
      }
      case 117: {
        let I;
        return { code: I, pos: a } = Wg(c, a, f, g, F, S), B(I === null ? null : String.fromCodePoint(I));
      }
      case 116:
        return B("	");
      case 98:
        return B("\b");
      case 118:
        return B("\v");
      case 102:
        return B("\f");
      case 13:
        c.charCodeAt(a) === 10 && ++a;
      case 10:
        f = a, ++g;
      case 8232:
      case 8233:
        return B("");
      case 56:
      case 57:
        if (v)
          return B(null);
        S.strictNumericEscape(a - 1, f, g);
      default:
        if (O >= 48 && O <= 55) {
          let I = a - 1, J = c.slice(I, a + 2).match(/^[0-7]+/)[0], ne = parseInt(J, 8);
          ne > 255 && (J = J.slice(0, -1), ne = parseInt(J, 8)), a += J.length - 1;
          let ue = c.charCodeAt(a);
          if (J !== "0" || ue === 56 || ue === 57) {
            if (v)
              return B(null);
            S.strictNumericEscape(I, f, g);
          }
          return B(String.fromCharCode(ne));
        }
        return B(String.fromCharCode(O));
    }
  }
  function Lh(c, a, f, g, v, S, F, B) {
    let O = a, I;
    return { n: I, pos: a } = qg(c, a, f, g, 16, v, S, !1, B, !F), I === null && (F ? B.invalidEscapeSequence(O, f, g) : a = O - 1), { code: I, pos: a };
  }
  function qg(c, a, f, g, v, S, F, B, O, I) {
    let J = a, ne = v === 16 ? Rg.hex : Rg.decBinOct, ue = v === 16 ? Ll.hex : v === 10 ? Ll.dec : v === 8 ? Ll.oct : Ll.bin, ae = !1, Ve = 0;
    for (let He = 0, dt = S ?? 1 / 0; He < dt; ++He) {
      let Lt = c.charCodeAt(a), ar;
      if (Lt === 95 && B !== "bail") {
        let qh = c.charCodeAt(a - 1), Wh = c.charCodeAt(a + 1);
        if (B) {
          if (Number.isNaN(Wh) || !ue(Wh) || ne.has(qh) || ne.has(Wh)) {
            if (I)
              return { n: null, pos: a };
            O.unexpectedNumericSeparator(a, f, g);
          }
        } else {
          if (I)
            return { n: null, pos: a };
          O.numericSeparatorInEscapeSequence(a, f, g);
        }
        ++a;
        continue;
      }
      if (Lt >= 97 ? ar = Lt - 97 + 10 : Lt >= 65 ? ar = Lt - 65 + 10 : eS(Lt) ? ar = Lt - 48 : ar = 1 / 0, ar >= v) {
        if (ar <= 9 && I)
          return { n: null, pos: a };
        if (ar <= 9 && O.invalidDigit(a, f, g, v))
          ar = 0;
        else if (F)
          ar = 0, ae = !0;
        else
          break;
      }
      ++a, Ve = Ve * v + ar;
    }
    return a === J || S != null && a - J !== S || ae ? { n: null, pos: a } : { n: Ve, pos: a };
  }
  function Wg(c, a, f, g, v, S) {
    let F = c.charCodeAt(a), B;
    if (F === 123) {
      if (++a, { code: B, pos: a } = Lh(c, a, f, g, c.indexOf("}", a) - a, !0, v, S), ++a, B !== null && B > 1114111)
        if (v)
          S.invalidCodePoint(a, f, g);
        else
          return { code: null, pos: a };
    } else
      ({ code: B, pos: a } = Lh(c, a, f, g, 4, !1, v, S));
    return { code: B, pos: a };
  }
  function Ko(c, a, f) {
    return new r(f, c - a, c);
  }
  var nS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), oi = class {
    constructor(c) {
      this.type = c.type, this.value = c.value, this.start = c.start, this.end = c.end, this.loc = new n(c.startLoc, c.endLoc);
    }
  }, iS = class extends Yw {
    constructor(c, a) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (f, g, v, S) => this.options.errorRecovery ? (this.raise(x.InvalidDigit, Ko(f, g, v), { radix: S }), !0) : !1, numericSeparatorInEscapeSequence: this.errorBuilder(x.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(x.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(x.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(x.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (f, g, v) => {
        this.recordStrictModeErrors(x.StrictNumericEscape, Ko(f, g, v));
      }, unterminated: (f, g, v) => {
        throw this.raise(x.UnterminatedString, Ko(f - 1, g, v));
      } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(x.StrictNumericEscape), unterminated: (f, g, v) => {
        throw this.raise(x.UnterminatedTemplate, Ko(f, g, v));
      } }), this.state = new Zw(), this.state.init(c), this.input = a, this.length = a.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(c) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(c), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new oi(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(c) {
      return this.match(c) ? (this.next(), !0) : !1;
    }
    match(c) {
      return this.state.type === c;
    }
    createLookaheadState(c) {
      return { pos: c.pos, value: null, type: c.type, start: c.start, end: c.end, context: [this.curContext()], inType: c.inType, startLoc: c.startLoc, lastTokEndLoc: c.lastTokEndLoc, curLine: c.curLine, lineStart: c.lineStart, curPosition: c.curPosition };
    }
    lookahead() {
      let c = this.state;
      this.state = this.createLookaheadState(c), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let a = this.state;
      return this.state = c, a;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(c) {
      return Oh.lastIndex = c, Oh.test(this.input) ? Oh.lastIndex : c;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(c) {
      return Ol.lastIndex = c, Ol.test(this.input) ? Ol.lastIndex : c;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(c) {
      let a = this.input.charCodeAt(c);
      if ((a & 64512) === 55296 && ++c < this.input.length) {
        let f = this.input.charCodeAt(c);
        (f & 64512) === 56320 && (a = 65536 + ((a & 1023) << 10) + (f & 1023));
      }
      return a;
    }
    setStrict(c) {
      this.state.strict = c, c && (this.state.strictErrors.forEach(([a, f]) => this.raise(a, f)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(c) {
      let a;
      this.isLookahead || (a = this.state.curPosition());
      let f = this.state.pos, g = this.input.indexOf(c, f + 2);
      if (g === -1)
        throw this.raise(x.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = g + c.length, Ml.lastIndex = f + 2; Ml.test(this.input) && Ml.lastIndex <= g; )
        ++this.state.curLine, this.state.lineStart = Ml.lastIndex;
      if (this.isLookahead)
        return;
      let v = { type: "CommentBlock", value: this.input.slice(f + 2, g), start: f, end: g + c.length, loc: new n(a, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(v), v;
    }
    skipLineComment(c) {
      let a = this.state.pos, f;
      this.isLookahead || (f = this.state.curPosition());
      let g = this.input.charCodeAt(this.state.pos += c);
      if (this.state.pos < this.length)
        for (; !Jo(g) && ++this.state.pos < this.length; )
          g = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead)
        return;
      let v = this.state.pos, S = { type: "CommentLine", value: this.input.slice(a + c, v), start: a, end: v, loc: new n(f, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(S), S;
    }
    skipSpace() {
      let c = this.state.pos, a = [];
      e:
        for (; this.state.pos < this.length; ) {
          let f = this.input.charCodeAt(this.state.pos);
          switch (f) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  let g = this.skipBlockComment("*/");
                  g !== void 0 && (this.addComment(g), this.options.attachComment && a.push(g));
                  break;
                }
                case 47: {
                  let g = this.skipLineComment(2);
                  g !== void 0 && (this.addComment(g), this.options.attachComment && a.push(g));
                  break;
                }
                default:
                  break e;
              }
              break;
            default:
              if (Qw(f))
                ++this.state.pos;
              else if (f === 45 && !this.inModule && this.options.annexB) {
                let g = this.state.pos;
                if (this.input.charCodeAt(g + 1) === 45 && this.input.charCodeAt(g + 2) === 62 && (c === 0 || this.state.lineStart > c)) {
                  let v = this.skipLineComment(3);
                  v !== void 0 && (this.addComment(v), this.options.attachComment && a.push(v));
                } else
                  break e;
              } else if (f === 60 && !this.inModule && this.options.annexB) {
                let g = this.state.pos;
                if (this.input.charCodeAt(g + 1) === 33 && this.input.charCodeAt(g + 2) === 45 && this.input.charCodeAt(g + 3) === 45) {
                  let v = this.skipLineComment(4);
                  v !== void 0 && (this.addComment(v), this.options.attachComment && a.push(v));
                } else
                  break e;
              } else
                break e;
          }
        }
      if (a.length > 0) {
        let f = this.state.pos, g = { start: c, end: f, comments: a, leadingNode: null, trailingNode: null, containingNode: null };
        this.state.commentStack.push(g);
      }
    }
    finishToken(c, a) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let f = this.state.type;
      this.state.type = c, this.state.value = a, this.isLookahead || this.updateContext(f);
    }
    replaceToken(c) {
      this.state.type = c, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let c = this.state.pos + 1, a = this.codePointAtPos(c);
      if (a >= 48 && a <= 57)
        throw this.raise(x.UnexpectedDigitAfterHash, this.state.curPosition());
      if (a === 123 || a === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(a === 123 ? x.RecordExpressionHashIncorrectStartSyntaxType : x.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        this.state.pos += 2, a === 123 ? this.finishToken(7) : this.finishToken(1);
      } else
        Oe(a) ? (++this.state.pos, this.finishToken(138, this.readWord1(a))) : a === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let c = this.input.charCodeAt(this.state.pos + 1);
      if (c >= 48 && c <= 57) {
        this.readNumber(!0);
        return;
      }
      c === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return !1;
      let c = this.input.charCodeAt(this.state.pos + 1);
      if (c !== 33)
        return !1;
      let a = this.state.pos;
      for (this.state.pos += 1; !Jo(c) && ++this.state.pos < this.length; )
        c = this.input.charCodeAt(this.state.pos);
      let f = this.input.slice(a + 2, this.state.pos);
      return this.finishToken(28, f), !0;
    }
    readToken_mult_modulo(c) {
      let a = c === 42 ? 55 : 54, f = 1, g = this.input.charCodeAt(this.state.pos + 1);
      c === 42 && g === 42 && (f++, g = this.input.charCodeAt(this.state.pos + 2), a = 57), g === 61 && !this.state.inType && (f++, a = c === 37 ? 33 : 30), this.finishOp(a, f);
    }
    readToken_pipe_amp(c) {
      let a = this.input.charCodeAt(this.state.pos + 1);
      if (a === c) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(c === 124 ? 41 : 42, 2);
        return;
      }
      if (c === 124) {
        if (a === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && a === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(x.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && a === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(x.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (a === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(c === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let c = this.input.charCodeAt(this.state.pos + 1);
      c === 61 && !this.state.inType ? this.finishOp(32, 2) : c === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(c) {
      let a = this.input.charCodeAt(this.state.pos + 1);
      if (a === c) {
        this.finishOp(34, 2);
        return;
      }
      a === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let { pos: c } = this.state, a = this.input.charCodeAt(c + 1);
      if (a === 60) {
        if (this.input.charCodeAt(c + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (a === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let { pos: c } = this.state, a = this.input.charCodeAt(c + 1);
      if (a === 62) {
        let f = this.input.charCodeAt(c + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(c + f) === 61) {
          this.finishOp(30, f + 1);
          return;
        }
        this.finishOp(52, f);
        return;
      }
      if (a === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(c) {
      let a = this.input.charCodeAt(this.state.pos + 1);
      if (a === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (c === 61 && a === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(c === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let c = this.input.charCodeAt(this.state.pos + 1), a = this.input.charCodeAt(this.state.pos + 2);
      c === 63 ? a === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : c === 46 && !(a >= 48 && a <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(c) {
      switch (c) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(x.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(x.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let a = this.input.charCodeAt(this.state.pos + 1);
          if (a === 120 || a === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (a === 111 || a === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (a === 98 || a === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(c);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(c);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(c);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(c);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(c);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (Oe(c)) {
            this.readWord(c);
            return;
          }
      }
      throw this.raise(x.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(c) });
    }
    finishOp(c, a) {
      let f = this.input.slice(this.state.pos, this.state.pos + a);
      this.state.pos += a, this.finishToken(c, f);
    }
    readRegexp() {
      let c = this.state.startLoc, a = this.state.start + 1, f, g, { pos: v } = this.state;
      for (; ; ++v) {
        if (v >= this.length)
          throw this.raise(x.UnterminatedRegExp, i(c, 1));
        let O = this.input.charCodeAt(v);
        if (Jo(O))
          throw this.raise(x.UnterminatedRegExp, i(c, 1));
        if (f)
          f = !1;
        else {
          if (O === 91)
            g = !0;
          else if (O === 93 && g)
            g = !1;
          else if (O === 47 && !g)
            break;
          f = O === 92;
        }
      }
      let S = this.input.slice(a, v);
      ++v;
      let F = "", B = () => i(c, v + 2 - a);
      for (; v < this.length; ) {
        let O = this.codePointAtPos(v), I = String.fromCharCode(O);
        if (nS.has(O))
          O === 118 ? F.includes("u") && this.raise(x.IncompatibleRegExpUVFlags, B()) : O === 117 && F.includes("v") && this.raise(x.IncompatibleRegExpUVFlags, B()), F.includes(I) && this.raise(x.DuplicateRegExpFlags, B());
        else if (Be(O) || O === 92)
          this.raise(x.MalformedRegExpFlags, B());
        else
          break;
        ++v, F += I;
      }
      this.state.pos = v, this.finishToken(137, { pattern: S, flags: F });
    }
    readInt(c, a, f = !1, g = !0) {
      let { n: v, pos: S } = qg(this.input, this.state.pos, this.state.lineStart, this.state.curLine, c, a, f, g, this.errorHandlers_readInt, !1);
      return this.state.pos = S, v;
    }
    readRadixNumber(c) {
      let a = this.state.curPosition(), f = !1;
      this.state.pos += 2;
      let g = this.readInt(c);
      g == null && this.raise(x.InvalidDigit, i(a, 2), { radix: c });
      let v = this.input.charCodeAt(this.state.pos);
      if (v === 110)
        ++this.state.pos, f = !0;
      else if (v === 109)
        throw this.raise(x.InvalidDecimal, a);
      if (Oe(this.codePointAtPos(this.state.pos)))
        throw this.raise(x.NumberIdentifier, this.state.curPosition());
      if (f) {
        let S = this.input.slice(a.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, S);
        return;
      }
      this.finishToken(134, g);
    }
    readNumber(c) {
      let a = this.state.pos, f = this.state.curPosition(), g = !1, v = !1, S = !1, F = !1, B = !1;
      !c && this.readInt(10) === null && this.raise(x.InvalidNumber, this.state.curPosition());
      let O = this.state.pos - a >= 2 && this.input.charCodeAt(a) === 48;
      if (O) {
        let ue = this.input.slice(a, this.state.pos);
        if (this.recordStrictModeErrors(x.StrictOctalLiteral, f), !this.state.strict) {
          let ae = ue.indexOf("_");
          ae > 0 && this.raise(x.ZeroDigitNumericSeparator, i(f, ae));
        }
        B = O && !/[89]/.test(ue);
      }
      let I = this.input.charCodeAt(this.state.pos);
      if (I === 46 && !B && (++this.state.pos, this.readInt(10), g = !0, I = this.input.charCodeAt(this.state.pos)), (I === 69 || I === 101) && !B && (I = this.input.charCodeAt(++this.state.pos), (I === 43 || I === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(x.InvalidOrMissingExponent, f), g = !0, F = !0, I = this.input.charCodeAt(this.state.pos)), I === 110 && ((g || O) && this.raise(x.InvalidBigIntLiteral, f), ++this.state.pos, v = !0), I === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (F || O) && this.raise(x.InvalidDecimal, f), ++this.state.pos, S = !0), Oe(this.codePointAtPos(this.state.pos)))
        throw this.raise(x.NumberIdentifier, this.state.curPosition());
      let J = this.input.slice(a, this.state.pos).replace(/[_mn]/g, "");
      if (v) {
        this.finishToken(135, J);
        return;
      }
      if (S) {
        this.finishToken(136, J);
        return;
      }
      let ne = B ? parseInt(J, 8) : parseFloat(J);
      this.finishToken(134, ne);
    }
    readCodePoint(c) {
      let { code: a, pos: f } = Wg(this.input, this.state.pos, this.state.lineStart, this.state.curLine, c, this.errorHandlers_readCodePoint);
      return this.state.pos = f, a;
    }
    readString(c) {
      let { str: a, pos: f, curLine: g, lineStart: v } = jg(c === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = f + 1, this.state.lineStart = v, this.state.curLine = g, this.finishToken(133, a);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let c = this.input[this.state.pos], { str: a, firstInvalidLoc: f, pos: g, curLine: v, lineStart: S } = jg("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = g + 1, this.state.lineStart = S, this.state.curLine = v, f && (this.state.firstInvalidTemplateEscapePos = new r(f.curLine, f.pos - f.lineStart, f.pos)), this.input.codePointAt(g) === 96 ? this.finishToken(24, f ? null : c + a + "`") : (this.state.pos++, this.finishToken(25, f ? null : c + a + "${"));
    }
    recordStrictModeErrors(c, a) {
      let f = a.index;
      this.state.strict && !this.state.strictErrors.has(f) ? this.raise(c, a) : this.state.strictErrors.set(f, [c, a]);
    }
    readWord1(c) {
      this.state.containsEsc = !1;
      let a = "", f = this.state.pos, g = this.state.pos;
      for (c !== void 0 && (this.state.pos += c <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let v = this.codePointAtPos(this.state.pos);
        if (Be(v))
          this.state.pos += v <= 65535 ? 1 : 2;
        else if (v === 92) {
          this.state.containsEsc = !0, a += this.input.slice(g, this.state.pos);
          let S = this.state.curPosition(), F = this.state.pos === f ? Oe : Be;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(x.MissingUnicodeEscape, this.state.curPosition()), g = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let B = this.readCodePoint(!0);
          B !== null && (F(B) || this.raise(x.EscapedCharNotAnIdentifier, S), a += String.fromCodePoint(B)), g = this.state.pos;
        } else
          break;
      }
      return a + this.input.slice(g, this.state.pos);
    }
    readWord(c) {
      let a = this.readWord1(c), f = H.get(a);
      f !== void 0 ? this.finishToken(f, an(f)) : this.finishToken(132, a);
    }
    checkKeywordEscapes() {
      let { type: c } = this.state;
      or(c) && this.state.containsEsc && this.raise(x.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: an(c) });
    }
    raise(c, a, f = {}) {
      let g = a instanceof r ? a : a.loc.start, v = c(g, f);
      if (!this.options.errorRecovery)
        throw v;
      return this.isLookahead || this.state.errors.push(v), v;
    }
    raiseOverwrite(c, a, f = {}) {
      let g = a instanceof r ? a : a.loc.start, v = g.index, S = this.state.errors;
      for (let F = S.length - 1; F >= 0; F--) {
        let B = S[F];
        if (B.loc.index === v)
          return S[F] = c(g, f);
        if (B.loc.index < v)
          break;
      }
      return this.raise(c, a, f);
    }
    updateContext(c) {
    }
    unexpected(c, a) {
      throw this.raise(x.UnexpectedToken, c ?? this.state.startLoc, { expected: a ? an(a) : null });
    }
    expectPlugin(c, a) {
      if (this.hasPlugin(c))
        return !0;
      throw this.raise(x.MissingPlugin, a ?? this.state.startLoc, { missingPlugin: [c] });
    }
    expectOnePlugin(c) {
      if (!c.some((a) => this.hasPlugin(a)))
        throw this.raise(x.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: c });
    }
    errorBuilder(c) {
      return (a, f, g) => {
        this.raise(c, Ko(a, f, g));
      };
    }
  }, sS = class {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, oS = class {
    constructor(c) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = c;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new sS());
    }
    exit() {
      let c = this.stack.pop(), a = this.current();
      for (let [f, g] of Array.from(c.undefinedPrivateNames))
        a ? a.undefinedPrivateNames.has(f) || a.undefinedPrivateNames.set(f, g) : this.parser.raise(x.InvalidPrivateFieldResolution, g, { identifierName: f });
    }
    declarePrivateName(c, a, f) {
      let { privateNames: g, loneAccessors: v, undefinedPrivateNames: S } = this.current(), F = g.has(c);
      if (a & 3) {
        let B = F && v.get(c);
        if (B) {
          let O = B & 4, I = a & 4, J = B & 3, ne = a & 3;
          F = J === ne || O !== I, F || v.delete(c);
        } else
          F || v.set(c, a);
      }
      F && this.parser.raise(x.PrivateNameRedeclaration, f, { identifierName: c }), g.add(c), S.delete(c);
    }
    usePrivateName(c, a) {
      let f;
      for (f of this.stack)
        if (f.privateNames.has(c))
          return;
      f ? f.undefinedPrivateNames.set(c, a) : this.parser.raise(x.InvalidPrivateFieldResolution, a, { identifierName: c });
    }
  }, _l = class {
    constructor(c = 0) {
      this.type = c;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, Ug = class extends _l {
    constructor(c) {
      super(c), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(c, a) {
      let f = a.index;
      this.declarationErrors.set(f, [c, a]);
    }
    clearDeclarationError(c) {
      this.declarationErrors.delete(c);
    }
    iterateErrors(c) {
      this.declarationErrors.forEach(c);
    }
  }, aS = class {
    constructor(c) {
      this.parser = void 0, this.stack = [new _l()], this.parser = c;
    }
    enter(c) {
      this.stack.push(c);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(c, a) {
      let f = a.loc.start, { stack: g } = this, v = g.length - 1, S = g[v];
      for (; !S.isCertainlyParameterDeclaration(); ) {
        if (S.canBeArrowParameterDeclaration())
          S.recordDeclarationError(c, f);
        else
          return;
        S = g[--v];
      }
      this.parser.raise(c, f);
    }
    recordArrowParameterBindingError(c, a) {
      let { stack: f } = this, g = f[f.length - 1], v = a.loc.start;
      if (g.isCertainlyParameterDeclaration())
        this.parser.raise(c, v);
      else if (g.canBeArrowParameterDeclaration())
        g.recordDeclarationError(c, v);
      else
        return;
    }
    recordAsyncArrowParametersError(c) {
      let { stack: a } = this, f = a.length - 1, g = a[f];
      for (; g.canBeArrowParameterDeclaration(); )
        g.type === 2 && g.recordDeclarationError(x.AwaitBindingIdentifier, c), g = a[--f];
    }
    validateAsPattern() {
      let { stack: c } = this, a = c[c.length - 1];
      a.canBeArrowParameterDeclaration() && a.iterateErrors(([f, g]) => {
        this.parser.raise(f, g);
        let v = c.length - 2, S = c[v];
        for (; S.canBeArrowParameterDeclaration(); )
          S.clearDeclarationError(g.index), S = c[--v];
      });
    }
  };
  function lS() {
    return new _l(3);
  }
  function uS() {
    return new Ug(1);
  }
  function cS() {
    return new Ug(2);
  }
  function Hg() {
    return new _l();
  }
  var hS = class {
    constructor() {
      this.stacks = [];
    }
    enter(c) {
      this.stacks.push(c);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function $l(c, a) {
    return (c ? 2 : 0) | (a ? 1 : 0);
  }
  var pS = class extends iS {
    addExtra(c, a, f, g = !0) {
      if (!c)
        return;
      let v = c.extra = c.extra || {};
      g ? v[a] = f : Object.defineProperty(v, a, { enumerable: g, value: f });
    }
    isContextual(c) {
      return this.state.type === c && !this.state.containsEsc;
    }
    isUnparsedContextual(c, a) {
      let f = c + a.length;
      if (this.input.slice(c, f) === a) {
        let g = this.input.charCodeAt(f);
        return !(Be(g) || (g & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(c) {
      let a = this.nextTokenStart();
      return this.isUnparsedContextual(a, c);
    }
    eatContextual(c) {
      return this.isContextual(c) ? (this.next(), !0) : !1;
    }
    expectContextual(c, a) {
      if (!this.eatContextual(c)) {
        if (a != null)
          throw this.raise(a, this.state.startLoc);
        this.unexpected(null, c);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return _g.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return $g.lastIndex = this.state.end, $g.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(c = !0) {
      (c ? this.isLineTerminator() : this.eat(13)) || this.raise(x.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(c, a) {
      this.eat(c) || this.unexpected(a, c);
    }
    tryParse(c, a = this.state.clone()) {
      let f = { node: null };
      try {
        let g = c((v = null) => {
          throw f.node = v, f;
        });
        if (this.state.errors.length > a.errors.length) {
          let v = this.state;
          return this.state = a, this.state.tokensLength = v.tokensLength, { node: g, error: v.errors[a.errors.length], thrown: !1, aborted: !1, failState: v };
        }
        return { node: g, error: null, thrown: !1, aborted: !1, failState: null };
      } catch (g) {
        let v = this.state;
        if (this.state = a, g instanceof SyntaxError)
          return { node: null, error: g, thrown: !0, aborted: !1, failState: v };
        if (g === f)
          return { node: f.node, error: null, thrown: !1, aborted: !0, failState: v };
        throw g;
      }
    }
    checkExpressionErrors(c, a) {
      if (!c)
        return !1;
      let { shorthandAssignLoc: f, doubleProtoLoc: g, privateKeyLoc: v, optionalParametersLoc: S } = c, F = !!f || !!g || !!S || !!v;
      if (!a)
        return F;
      f != null && this.raise(x.InvalidCoverInitializedName, f), g != null && this.raise(x.DuplicateProto, g), v != null && this.raise(x.UnexpectedPrivateField, v), S != null && this.unexpected(S);
    }
    isLiteralPropertyName() {
      return Te(this.state.type);
    }
    isPrivateName(c) {
      return c.type === "PrivateName";
    }
    getPrivateNameSV(c) {
      return c.id.name;
    }
    hasPropertyAsPrivateName(c) {
      return (c.type === "MemberExpression" || c.type === "OptionalMemberExpression") && this.isPrivateName(c.property);
    }
    isObjectProperty(c) {
      return c.type === "ObjectProperty";
    }
    isObjectMethod(c) {
      return c.type === "ObjectMethod";
    }
    initializeScopes(c = this.options.sourceType === "module") {
      let a = this.state.labels;
      this.state.labels = [];
      let f = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let g = this.inModule;
      this.inModule = c;
      let v = this.scope, S = this.getScopeHandler();
      this.scope = new S(this, c);
      let F = this.prodParam;
      this.prodParam = new hS();
      let B = this.classScope;
      this.classScope = new oS(this);
      let O = this.expressionScope;
      return this.expressionScope = new aS(this), () => {
        this.state.labels = a, this.exportedIdentifiers = f, this.inModule = g, this.scope = v, this.prodParam = F, this.classScope = B, this.expressionScope = O;
      };
    }
    enterInitialScopes() {
      let c = 0;
      this.inModule && (c |= 2), this.scope.enter(1), this.prodParam.enter(c);
    }
    checkDestructuringPrivate(c) {
      let { privateKeyLoc: a } = c;
      a !== null && this.expectPlugin("destructuringPrivate", a);
    }
  }, Rl = class {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, jl = class {
    constructor(c, a, f) {
      this.type = "", this.start = a, this.end = 0, this.loc = new n(f), c != null && c.options.ranges && (this.range = [a, 0]), c != null && c.filename && (this.loc.filename = c.filename);
    }
  }, _h = jl.prototype;
  _h.__clone = function() {
    let c = new jl(void 0, this.start, this.loc.start), a = Object.keys(this);
    for (let f = 0, g = a.length; f < g; f++) {
      let v = a[f];
      v !== "leadingComments" && v !== "trailingComments" && v !== "innerComments" && (c[v] = this[v]);
    }
    return c;
  };
  function dS(c) {
    return Rn(c);
  }
  function Rn(c) {
    let { type: a, start: f, end: g, loc: v, range: S, extra: F, name: B } = c, O = Object.create(_h);
    return O.type = a, O.start = f, O.end = g, O.loc = v, O.range = S, O.extra = F, O.name = B, a === "Placeholder" && (O.expectedNode = c.expectedNode), O;
  }
  function fS(c) {
    let { type: a, start: f, end: g, loc: v, range: S, extra: F } = c;
    if (a === "Placeholder")
      return dS(c);
    let B = Object.create(_h);
    return B.type = a, B.start = f, B.end = g, B.loc = v, B.range = S, c.raw !== void 0 ? B.raw = c.raw : B.extra = F, B.value = c.value, B;
  }
  var mS = class extends pS {
    startNode() {
      let c = this.state.startLoc;
      return new jl(this, c.index, c);
    }
    startNodeAt(c) {
      return new jl(this, c.index, c);
    }
    startNodeAtNode(c) {
      return this.startNodeAt(c.loc.start);
    }
    finishNode(c, a) {
      return this.finishNodeAt(c, a, this.state.lastTokEndLoc);
    }
    finishNodeAt(c, a, f) {
      return c.type = a, c.end = f.index, c.loc.end = f, this.options.ranges && (c.range[1] = f.index), this.options.attachComment && this.processComment(c), c;
    }
    resetStartLocation(c, a) {
      c.start = a.index, c.loc.start = a, this.options.ranges && (c.range[0] = a.index);
    }
    resetEndLocation(c, a = this.state.lastTokEndLoc) {
      c.end = a.index, c.loc.end = a, this.options.ranges && (c.range[1] = a.index);
    }
    resetStartLocationFromNode(c, a) {
      this.resetStartLocation(c, a.loc.start);
    }
  }, gS = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), De = A`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: c }) => `Cannot overwrite reserved type ${c}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: c, enumName: a }) => `Boolean enum members need to be initialized. Use either \`${c} = true,\` or \`${c} = false,\` in enum \`${a}\`.`, EnumDuplicateMemberName: ({ memberName: c, enumName: a }) => `Enum member names need to be unique, but the name \`${c}\` has already been used before in enum \`${a}\`.`, EnumInconsistentMemberValues: ({ enumName: c }) => `Enum \`${c}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: c, enumName: a }) => `Enum type \`${c}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${a}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: c }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${c}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: c, memberName: a, explicitType: f }) => `Enum \`${c}\` has type \`${f}\`, so the initializer of \`${a}\` needs to be a ${f} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: c, memberName: a }) => `Symbol enum members cannot be initialized. Use \`${a},\` in enum \`${c}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: c, memberName: a }) => `The enum member initializer for \`${a}\` needs to be a literal (either a boolean, number, or string) in enum \`${c}\`.`, EnumInvalidMemberName: ({ enumName: c, memberName: a, suggestion: f }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${a}\`, consider using \`${f}\`, in enum \`${c}\`.`, EnumNumberMemberNotInitialized: ({ enumName: c, memberName: a }) => `Number enum members need to be initialized, e.g. \`${a} = 1\` in enum \`${c}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: c }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${c}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: c }) => `Unexpected reserved type ${c}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: c, suggestion: a }) => `\`declare export ${c}\` is not supported. Use \`${a}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
  function yS(c) {
    return c.type === "DeclareExportAllDeclaration" || c.type === "DeclareExportDeclaration" && (!c.declaration || c.declaration.type !== "TypeAlias" && c.declaration.type !== "InterfaceDeclaration");
  }
  function Vg(c) {
    return c.importKind === "type" || c.importKind === "typeof";
  }
  var DS = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
  function xS(c, a) {
    let f = [], g = [];
    for (let v = 0; v < c.length; v++)
      (a(c[v], v, c) ? f : g).push(c[v]);
    return [f, g];
  }
  var bS = /\*?\s*@((?:no)?flow)\b/, vS = (c) => class extends c {
    constructor(...a) {
      super(...a), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return Kw;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(a, f) {
      a !== 133 && a !== 13 && a !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(a, f);
    }
    addComment(a) {
      if (this.flowPragma === void 0) {
        let f = bS.exec(a.value);
        if (f)
          if (f[1] === "flow")
            this.flowPragma = "flow";
          else if (f[1] === "noflow")
            this.flowPragma = "noflow";
          else
            throw new Error("Unexpected flow pragma");
      }
      super.addComment(a);
    }
    flowParseTypeInitialiser(a) {
      let f = this.state.inType;
      this.state.inType = !0, this.expect(a || 14);
      let g = this.flowParseType();
      return this.state.inType = f, g;
    }
    flowParsePredicate() {
      let a = this.startNode(), f = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > f.index + 1 && this.raise(De.UnexpectedSpaceBetweenModuloChecks, f), this.eat(10) ? (a.value = super.parseExpression(), this.expect(11), this.finishNode(a, "DeclaredPredicate")) : this.finishNode(a, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let a = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let f = null, g = null;
      return this.match(54) ? (this.state.inType = a, g = this.flowParsePredicate()) : (f = this.flowParseType(), this.state.inType = a, this.match(54) && (g = this.flowParsePredicate())), [f, g];
    }
    flowParseDeclareClass(a) {
      return this.next(), this.flowParseInterfaceish(a, !0), this.finishNode(a, "DeclareClass");
    }
    flowParseDeclareFunction(a) {
      this.next();
      let f = a.id = this.parseIdentifier(), g = this.startNode(), v = this.startNode();
      this.match(47) ? g.typeParameters = this.flowParseTypeParameterDeclaration() : g.typeParameters = null, this.expect(10);
      let S = this.flowParseFunctionTypeParams();
      return g.params = S.params, g.rest = S.rest, g.this = S._this, this.expect(11), [g.returnType, a.predicate] = this.flowParseTypeAndPredicateInitialiser(), v.typeAnnotation = this.finishNode(g, "FunctionTypeAnnotation"), f.typeAnnotation = this.finishNode(v, "TypeAnnotation"), this.resetEndLocation(f), this.semicolon(), this.scope.declareName(a.id.name, 2048, a.id.loc.start), this.finishNode(a, "DeclareFunction");
    }
    flowParseDeclare(a, f) {
      if (this.match(80))
        return this.flowParseDeclareClass(a);
      if (this.match(68))
        return this.flowParseDeclareFunction(a);
      if (this.match(74))
        return this.flowParseDeclareVariable(a);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(a) : (f && this.raise(De.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(a));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(a);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(a);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(a);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(a, f);
      this.unexpected();
    }
    flowParseDeclareVariable(a) {
      return this.next(), a.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(a.id.name, 5, a.id.loc.start), this.semicolon(), this.finishNode(a, "DeclareVariable");
    }
    flowParseDeclareModule(a) {
      this.scope.enter(0), this.match(133) ? a.id = super.parseExprAtom() : a.id = this.parseIdentifier();
      let f = a.body = this.startNode(), g = f.body = [];
      for (this.expect(5); !this.match(8); ) {
        let F = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(De.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(F)) : (this.expectContextual(125, De.UnsupportedStatementInDeclareModule), F = this.flowParseDeclare(F, !0)), g.push(F);
      }
      this.scope.exit(), this.expect(8), this.finishNode(f, "BlockStatement");
      let v = null, S = !1;
      return g.forEach((F) => {
        yS(F) ? (v === "CommonJS" && this.raise(De.AmbiguousDeclareModuleKind, F), v = "ES") : F.type === "DeclareModuleExports" && (S && this.raise(De.DuplicateDeclareModuleExports, F), v === "ES" && this.raise(De.AmbiguousDeclareModuleKind, F), v = "CommonJS", S = !0);
      }), a.kind = v || "CommonJS", this.finishNode(a, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(a, f) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? a.declaration = this.flowParseDeclare(this.startNode()) : (a.declaration = this.flowParseType(), this.semicolon()), a.default = !0, this.finishNode(a, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !f) {
        let g = this.state.value;
        throw this.raise(De.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: g, suggestion: DS[g] });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return a.declaration = this.flowParseDeclare(this.startNode()), a.default = !1, this.finishNode(a, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return a = this.parseExport(a, null), a.type === "ExportNamedDeclaration" && (a.type = "ExportDeclaration", a.default = !1, delete a.exportKind), a.type = "Declare" + a.type, a;
      this.unexpected();
    }
    flowParseDeclareModuleExports(a) {
      return this.next(), this.expectContextual(111), a.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(a, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(a) {
      this.next();
      let f = this.flowParseTypeAlias(a);
      return f.type = "DeclareTypeAlias", f;
    }
    flowParseDeclareOpaqueType(a) {
      this.next();
      let f = this.flowParseOpaqueType(a, !0);
      return f.type = "DeclareOpaqueType", f;
    }
    flowParseDeclareInterface(a) {
      return this.next(), this.flowParseInterfaceish(a, !1), this.finishNode(a, "DeclareInterface");
    }
    flowParseInterfaceish(a, f) {
      if (a.id = this.flowParseRestrictedIdentifier(!f, !0), this.scope.declareName(a.id.name, f ? 17 : 8201, a.id.loc.start), this.match(47) ? a.typeParameters = this.flowParseTypeParameterDeclaration() : a.typeParameters = null, a.extends = [], this.eat(81))
        do
          a.extends.push(this.flowParseInterfaceExtends());
        while (!f && this.eat(12));
      if (f) {
        if (a.implements = [], a.mixins = [], this.eatContextual(117))
          do
            a.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            a.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      a.body = this.flowParseObjectType({ allowStatic: f, allowExact: !1, allowSpread: !1, allowProto: f, allowInexact: !1 });
    }
    flowParseInterfaceExtends() {
      let a = this.startNode();
      return a.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? a.typeParameters = this.flowParseTypeParameterInstantiation() : a.typeParameters = null, this.finishNode(a, "InterfaceExtends");
    }
    flowParseInterface(a) {
      return this.flowParseInterfaceish(a, !1), this.finishNode(a, "InterfaceDeclaration");
    }
    checkNotUnderscore(a) {
      a === "_" && this.raise(De.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(a, f, g) {
      gS.has(a) && this.raise(g ? De.AssignReservedType : De.UnexpectedReservedType, f, { reservedType: a });
    }
    flowParseRestrictedIdentifier(a, f) {
      return this.checkReservedType(this.state.value, this.state.startLoc, f), this.parseIdentifier(a);
    }
    flowParseTypeAlias(a) {
      return a.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(a.id.name, 8201, a.id.loc.start), this.match(47) ? a.typeParameters = this.flowParseTypeParameterDeclaration() : a.typeParameters = null, a.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(a, "TypeAlias");
    }
    flowParseOpaqueType(a, f) {
      return this.expectContextual(130), a.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(a.id.name, 8201, a.id.loc.start), this.match(47) ? a.typeParameters = this.flowParseTypeParameterDeclaration() : a.typeParameters = null, a.supertype = null, this.match(14) && (a.supertype = this.flowParseTypeInitialiser(14)), a.impltype = null, f || (a.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(a, "OpaqueType");
    }
    flowParseTypeParameter(a = !1) {
      let f = this.state.startLoc, g = this.startNode(), v = this.flowParseVariance(), S = this.flowParseTypeAnnotatableIdentifier();
      return g.name = S.name, g.variance = v, g.bound = S.typeAnnotation, this.match(29) ? (this.eat(29), g.default = this.flowParseType()) : a && this.raise(De.MissingTypeParamDefault, f), this.finishNode(g, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let a = this.state.inType, f = this.startNode();
      f.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let g = !1;
      do {
        let v = this.flowParseTypeParameter(g);
        f.params.push(v), v.default && (g = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = a, this.finishNode(f, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let a = this.startNode(), f = this.state.inType;
      a.params = [], this.state.inType = !0, this.expect(47);
      let g = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        a.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = g, this.expect(48), this.state.inType = f, this.finishNode(a, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let a = this.startNode(), f = this.state.inType;
      for (a.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        a.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = f, this.finishNode(a, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let a = this.startNode();
      if (this.expectContextual(129), a.extends = [], this.eat(81))
        do
          a.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return a.body = this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !1, allowProto: !1, allowInexact: !1 }), this.finishNode(a, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(a, f, g) {
      return a.static = f, this.lookahead().type === 14 ? (a.id = this.flowParseObjectPropertyKey(), a.key = this.flowParseTypeInitialiser()) : (a.id = null, a.key = this.flowParseType()), this.expect(3), a.value = this.flowParseTypeInitialiser(), a.variance = g, this.finishNode(a, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(a, f) {
      return a.static = f, a.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (a.method = !0, a.optional = !1, a.value = this.flowParseObjectTypeMethodish(this.startNodeAt(a.loc.start))) : (a.method = !1, this.eat(17) && (a.optional = !0), a.value = this.flowParseTypeInitialiser()), this.finishNode(a, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(a) {
      for (a.params = [], a.rest = null, a.typeParameters = null, a.this = null, this.match(47) && (a.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (a.this = this.flowParseFunctionTypeParam(!0), a.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        a.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (a.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), a.returnType = this.flowParseTypeInitialiser(), this.finishNode(a, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(a, f) {
      let g = this.startNode();
      return a.static = f, a.value = this.flowParseObjectTypeMethodish(g), this.finishNode(a, "ObjectTypeCallProperty");
    }
    flowParseObjectType({ allowStatic: a, allowExact: f, allowSpread: g, allowProto: v, allowInexact: S }) {
      let F = this.state.inType;
      this.state.inType = !0;
      let B = this.startNode();
      B.callProperties = [], B.properties = [], B.indexers = [], B.internalSlots = [];
      let O, I, J = !1;
      for (f && this.match(6) ? (this.expect(6), O = 9, I = !0) : (this.expect(5), O = 8, I = !1), B.exact = I; !this.match(O); ) {
        let ue = !1, ae = null, Ve = null, He = this.startNode();
        if (v && this.isContextual(118)) {
          let Lt = this.lookahead();
          Lt.type !== 14 && Lt.type !== 17 && (this.next(), ae = this.state.startLoc, a = !1);
        }
        if (a && this.isContextual(106)) {
          let Lt = this.lookahead();
          Lt.type !== 14 && Lt.type !== 17 && (this.next(), ue = !0);
        }
        let dt = this.flowParseVariance();
        if (this.eat(0))
          ae != null && this.unexpected(ae), this.eat(0) ? (dt && this.unexpected(dt.loc.start), B.internalSlots.push(this.flowParseObjectTypeInternalSlot(He, ue))) : B.indexers.push(this.flowParseObjectTypeIndexer(He, ue, dt));
        else if (this.match(10) || this.match(47))
          ae != null && this.unexpected(ae), dt && this.unexpected(dt.loc.start), B.callProperties.push(this.flowParseObjectTypeCallProperty(He, ue));
        else {
          let Lt = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let qh = this.lookahead();
            Te(qh.type) && (Lt = this.state.value, this.next());
          }
          let ar = this.flowParseObjectTypeProperty(He, ue, ae, dt, Lt, g, S ?? !I);
          ar === null ? (J = !0, Ve = this.state.lastTokStartLoc) : B.properties.push(ar);
        }
        this.flowObjectTypeSemicolon(), Ve && !this.match(8) && !this.match(9) && this.raise(De.UnexpectedExplicitInexactInObject, Ve);
      }
      this.expect(O), g && (B.inexact = J);
      let ne = this.finishNode(B, "ObjectTypeAnnotation");
      return this.state.inType = F, ne;
    }
    flowParseObjectTypeProperty(a, f, g, v, S, F, B) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (F ? B || this.raise(De.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(De.InexactInsideNonObject, this.state.lastTokStartLoc), v && this.raise(De.InexactVariance, v), null) : (F || this.raise(De.UnexpectedSpreadType, this.state.lastTokStartLoc), g != null && this.unexpected(g), v && this.raise(De.SpreadVariance, v), a.argument = this.flowParseType(), this.finishNode(a, "ObjectTypeSpreadProperty"));
      {
        a.key = this.flowParseObjectPropertyKey(), a.static = f, a.proto = g != null, a.kind = S;
        let O = !1;
        return this.match(47) || this.match(10) ? (a.method = !0, g != null && this.unexpected(g), v && this.unexpected(v.loc.start), a.value = this.flowParseObjectTypeMethodish(this.startNodeAt(a.loc.start)), (S === "get" || S === "set") && this.flowCheckGetterSetterParams(a), !F && a.key.name === "constructor" && a.value.this && this.raise(De.ThisParamBannedInConstructor, a.value.this)) : (S !== "init" && this.unexpected(), a.method = !1, this.eat(17) && (O = !0), a.value = this.flowParseTypeInitialiser(), a.variance = v), a.optional = O, this.finishNode(a, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(a) {
      let f = a.kind === "get" ? 0 : 1, g = a.value.params.length + (a.value.rest ? 1 : 0);
      a.value.this && this.raise(a.kind === "get" ? De.GetterMayNotHaveThisParam : De.SetterMayNotHaveThisParam, a.value.this), g !== f && this.raise(a.kind === "get" ? x.BadGetterArity : x.BadSetterArity, a), a.kind === "set" && a.value.rest && this.raise(x.BadSetterRestParameter, a);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(a, f) {
      a != null || (a = this.state.startLoc);
      let g = f || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let v = this.startNodeAt(a);
        v.qualification = g, v.id = this.flowParseRestrictedIdentifier(!0), g = this.finishNode(v, "QualifiedTypeIdentifier");
      }
      return g;
    }
    flowParseGenericType(a, f) {
      let g = this.startNodeAt(a);
      return g.typeParameters = null, g.id = this.flowParseQualifiedTypeIdentifier(a, f), this.match(47) && (g.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(g, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let a = this.startNode();
      return this.expect(87), a.argument = this.flowParsePrimaryType(), this.finishNode(a, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let a = this.startNode();
      for (a.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (a.types.push(this.flowParseType()), !this.match(3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(a, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(a) {
      let f = null, g = !1, v = null, S = this.startNode(), F = this.lookahead(), B = this.state.type === 78;
      return F.type === 14 || F.type === 17 ? (B && !a && this.raise(De.ThisParamMustBeFirst, S), f = this.parseIdentifier(B), this.eat(17) && (g = !0, B && this.raise(De.ThisParamMayNotBeOptional, S)), v = this.flowParseTypeInitialiser()) : v = this.flowParseType(), S.name = f, S.optional = g, S.typeAnnotation = v, this.finishNode(S, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(a) {
      let f = this.startNodeAt(a.loc.start);
      return f.name = null, f.optional = !1, f.typeAnnotation = a, this.finishNode(f, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(a = []) {
      let f = null, g = null;
      for (this.match(78) && (g = this.flowParseFunctionTypeParam(!0), g.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        a.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (f = this.flowParseFunctionTypeParam(!1)), { params: a, rest: f, _this: g };
    }
    flowIdentToTypeAnnotation(a, f, g) {
      switch (g.name) {
        case "any":
          return this.finishNode(f, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(f, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(f, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(f, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(f, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(f, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(f, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(g.name), this.flowParseGenericType(a, g);
      }
    }
    flowParsePrimaryType() {
      let a = this.state.startLoc, f = this.startNode(), g, v, S = !1, F = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !0, allowProto: !1, allowInexact: !0 });
        case 6:
          return this.flowParseObjectType({ allowStatic: !1, allowExact: !0, allowSpread: !0, allowProto: !1, allowInexact: !1 });
        case 0:
          return this.state.noAnonFunctionType = !1, v = this.flowParseTupleType(), this.state.noAnonFunctionType = F, v;
        case 47:
          return f.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), g = this.flowParseFunctionTypeParams(), f.params = g.params, f.rest = g.rest, f.this = g._this, this.expect(11), this.expect(19), f.returnType = this.flowParseType(), this.finishNode(f, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (R(this.state.type) || this.match(78)) {
              let B = this.lookahead().type;
              S = B !== 17 && B !== 14;
            } else
              S = !0;
          if (S) {
            if (this.state.noAnonFunctionType = !1, v = this.flowParseType(), this.state.noAnonFunctionType = F, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), v;
            this.eat(12);
          }
          return v ? g = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(v)]) : g = this.flowParseFunctionTypeParams(), f.params = g.params, f.rest = g.rest, f.this = g._this, this.expect(11), this.expect(19), f.returnType = this.flowParseType(), f.typeParameters = null, this.finishNode(f, "FunctionTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return f.value = this.match(85), this.next(), this.finishNode(f, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", f);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", f);
            throw this.raise(De.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(f, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(f, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(f, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(f, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (or(this.state.type)) {
            let B = an(this.state.type);
            return this.next(), super.createIdentifier(f, B);
          } else if (R(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(a, f, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let a = this.state.startLoc, f = this.flowParsePrimaryType(), g = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let v = this.startNodeAt(a), S = this.eat(18);
        g = g || S, this.expect(0), !S && this.match(3) ? (v.elementType = f, this.next(), f = this.finishNode(v, "ArrayTypeAnnotation")) : (v.objectType = f, v.indexType = this.flowParseType(), this.expect(3), g ? (v.optional = S, f = this.finishNode(v, "OptionalIndexedAccessType")) : f = this.finishNode(v, "IndexedAccessType"));
      }
      return f;
    }
    flowParsePrefixType() {
      let a = this.startNode();
      return this.eat(17) ? (a.typeAnnotation = this.flowParsePrefixType(), this.finishNode(a, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let a = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let f = this.startNodeAt(a.loc.start);
        return f.params = [this.reinterpretTypeAsFunctionTypeParam(a)], f.rest = null, f.this = null, f.returnType = this.flowParseType(), f.typeParameters = null, this.finishNode(f, "FunctionTypeAnnotation");
      }
      return a;
    }
    flowParseIntersectionType() {
      let a = this.startNode();
      this.eat(45);
      let f = this.flowParseAnonFunctionWithoutParens();
      for (a.types = [f]; this.eat(45); )
        a.types.push(this.flowParseAnonFunctionWithoutParens());
      return a.types.length === 1 ? f : this.finishNode(a, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let a = this.startNode();
      this.eat(43);
      let f = this.flowParseIntersectionType();
      for (a.types = [f]; this.eat(43); )
        a.types.push(this.flowParseIntersectionType());
      return a.types.length === 1 ? f : this.finishNode(a, "UnionTypeAnnotation");
    }
    flowParseType() {
      let a = this.state.inType;
      this.state.inType = !0;
      let f = this.flowParseUnionType();
      return this.state.inType = a, f;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let a = this.state.startLoc, f = this.parseIdentifier();
        return this.flowParseGenericType(a, f);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let a = this.startNode();
      return a.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(a, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(a) {
      let f = a ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (f.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(f)), f;
    }
    typeCastToParameter(a) {
      return a.expression.typeAnnotation = a.typeAnnotation, this.resetEndLocation(a.expression, a.typeAnnotation.loc.end), a.expression;
    }
    flowParseVariance() {
      let a = null;
      return this.match(53) ? (a = this.startNode(), this.state.value === "+" ? a.kind = "plus" : a.kind = "minus", this.next(), this.finishNode(a, "Variance")) : a;
    }
    parseFunctionBody(a, f, g = !1) {
      if (f) {
        this.forwardNoArrowParamsConversionAt(a, () => super.parseFunctionBody(a, !0, g));
        return;
      }
      super.parseFunctionBody(a, !1, g);
    }
    parseFunctionBodyAndFinish(a, f, g = !1) {
      if (this.match(14)) {
        let v = this.startNode();
        [v.typeAnnotation, a.predicate] = this.flowParseTypeAndPredicateInitialiser(), a.returnType = v.typeAnnotation ? this.finishNode(v, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(a, f, g);
    }
    parseStatementLike(a) {
      if (this.state.strict && this.isContextual(129)) {
        let g = this.lookahead();
        if (be(g.type)) {
          let v = this.startNode();
          return this.next(), this.flowParseInterface(v);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        let g = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(g);
      }
      let f = super.parseStatementLike(a);
      return this.flowPragma === void 0 && !this.isValidDirective(f) && (this.flowPragma = null), f;
    }
    parseExpressionStatement(a, f, g) {
      if (f.type === "Identifier") {
        if (f.name === "declare") {
          if (this.match(80) || R(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(a);
        } else if (R(this.state.type)) {
          if (f.name === "interface")
            return this.flowParseInterface(a);
          if (f.name === "type")
            return this.flowParseTypeAlias(a);
          if (f.name === "opaque")
            return this.flowParseOpaqueType(a, !1);
        }
      }
      return super.parseExpressionStatement(a, f, g);
    }
    shouldParseExportDeclaration() {
      let { type: a } = this.state;
      return Ur(a) || this.shouldParseEnums() && a === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let { type: a } = this.state;
      return Ur(a) || this.shouldParseEnums() && a === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        let a = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(a);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(a, f, g) {
      if (!this.match(17))
        return a;
      if (this.state.maybeInArrowParameters) {
        let ne = this.lookaheadCharCode();
        if (ne === 44 || ne === 61 || ne === 58 || ne === 41)
          return this.setOptionalParametersError(g), a;
      }
      this.expect(17);
      let v = this.state.clone(), S = this.state.noArrowAt, F = this.startNodeAt(f), { consequent: B, failed: O } = this.tryParseConditionalConsequent(), [I, J] = this.getArrowLikeExpressions(B);
      if (O || J.length > 0) {
        let ne = [...S];
        if (J.length > 0) {
          this.state = v, this.state.noArrowAt = ne;
          for (let ue = 0; ue < J.length; ue++)
            ne.push(J[ue].start);
          ({ consequent: B, failed: O } = this.tryParseConditionalConsequent()), [I, J] = this.getArrowLikeExpressions(B);
        }
        O && I.length > 1 && this.raise(De.AmbiguousConditionalArrow, v.startLoc), O && I.length === 1 && (this.state = v, ne.push(I[0].start), this.state.noArrowAt = ne, { consequent: B, failed: O } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(B, !0), this.state.noArrowAt = S, this.expect(14), F.test = a, F.consequent = B, F.alternate = this.forwardNoArrowParamsConversionAt(F, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(F, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let a = this.parseMaybeAssignAllowIn(), f = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), { consequent: a, failed: f };
    }
    getArrowLikeExpressions(a, f) {
      let g = [a], v = [];
      for (; g.length !== 0; ) {
        let S = g.pop();
        S.type === "ArrowFunctionExpression" ? (S.typeParameters || !S.returnType ? this.finishArrowValidation(S) : v.push(S), g.push(S.body)) : S.type === "ConditionalExpression" && (g.push(S.consequent), g.push(S.alternate));
      }
      return f ? (v.forEach((S) => this.finishArrowValidation(S)), [v, []]) : xS(v, (S) => S.params.every((F) => this.isAssignable(F, !0)));
    }
    finishArrowValidation(a) {
      var f;
      this.toAssignableList(a.params, (f = a.extra) == null ? void 0 : f.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(a, !1, !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(a, f) {
      let g;
      return this.state.noArrowParamsConversionAt.indexOf(a.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), g = f(), this.state.noArrowParamsConversionAt.pop()) : g = f(), g;
    }
    parseParenItem(a, f) {
      if (a = super.parseParenItem(a, f), this.eat(17) && (a.optional = !0, this.resetEndLocation(a)), this.match(14)) {
        let g = this.startNodeAt(f);
        return g.expression = a, g.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(g, "TypeCastExpression");
      }
      return a;
    }
    assertModuleNodeAllowed(a) {
      a.type === "ImportDeclaration" && (a.importKind === "type" || a.importKind === "typeof") || a.type === "ExportNamedDeclaration" && a.exportKind === "type" || a.type === "ExportAllDeclaration" && a.exportKind === "type" || super.assertModuleNodeAllowed(a);
    }
    parseExportDeclaration(a) {
      if (this.isContextual(130)) {
        a.exportKind = "type";
        let f = this.startNode();
        return this.next(), this.match(5) ? (a.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(a), null) : this.flowParseTypeAlias(f);
      } else if (this.isContextual(131)) {
        a.exportKind = "type";
        let f = this.startNode();
        return this.next(), this.flowParseOpaqueType(f, !1);
      } else if (this.isContextual(129)) {
        a.exportKind = "type";
        let f = this.startNode();
        return this.next(), this.flowParseInterface(f);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        a.exportKind = "value";
        let f = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(f);
      } else
        return super.parseExportDeclaration(a);
    }
    eatExportStar(a) {
      return super.eatExportStar(a) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (a.exportKind = "type", this.next(), this.next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(a) {
      let { startLoc: f } = this.state, g = super.maybeParseExportNamespaceSpecifier(a);
      return g && a.exportKind === "type" && this.unexpected(f), g;
    }
    parseClassId(a, f, g) {
      super.parseClassId(a, f, g), this.match(47) && (a.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(a, f, g) {
      let { startLoc: v } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(a, f))
          return;
        f.declare = !0;
      }
      super.parseClassMember(a, f, g), f.declare && (f.type !== "ClassProperty" && f.type !== "ClassPrivateProperty" && f.type !== "PropertyDefinition" ? this.raise(De.DeclareClassElement, v) : f.value && this.raise(De.DeclareClassFieldInitializer, f.value));
    }
    isIterator(a) {
      return a === "iterator" || a === "asyncIterator";
    }
    readIterator() {
      let a = super.readWord1(), f = "@@" + a;
      (!this.isIterator(a) || !this.state.inType) && this.raise(x.InvalidIdentifier, this.state.curPosition(), { identifierName: f }), this.finishToken(132, f);
    }
    getTokenFromCode(a) {
      let f = this.input.charCodeAt(this.state.pos + 1);
      a === 123 && f === 124 ? this.finishOp(6, 2) : this.state.inType && (a === 62 || a === 60) ? this.finishOp(a === 62 ? 48 : 47, 1) : this.state.inType && a === 63 ? f === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : Hw(a, f, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(a);
    }
    isAssignable(a, f) {
      return a.type === "TypeCastExpression" ? this.isAssignable(a.expression, f) : super.isAssignable(a, f);
    }
    toAssignable(a, f = !1) {
      !f && a.type === "AssignmentExpression" && a.left.type === "TypeCastExpression" && (a.left = this.typeCastToParameter(a.left)), super.toAssignable(a, f);
    }
    toAssignableList(a, f, g) {
      for (let v = 0; v < a.length; v++) {
        let S = a[v];
        (S == null ? void 0 : S.type) === "TypeCastExpression" && (a[v] = this.typeCastToParameter(S));
      }
      super.toAssignableList(a, f, g);
    }
    toReferencedList(a, f) {
      for (let v = 0; v < a.length; v++) {
        var g;
        let S = a[v];
        S && S.type === "TypeCastExpression" && !((g = S.extra) != null && g.parenthesized) && (a.length > 1 || !f) && this.raise(De.TypeCastInPattern, S.typeAnnotation);
      }
      return a;
    }
    parseArrayLike(a, f, g, v) {
      let S = super.parseArrayLike(a, f, g, v);
      return f && !this.state.maybeInArrowParameters && this.toReferencedList(S.elements), S;
    }
    isValidLVal(a, f, g) {
      return a === "TypeCastExpression" || super.isValidLVal(a, f, g);
    }
    parseClassProperty(a) {
      return this.match(14) && (a.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(a);
    }
    parseClassPrivateProperty(a) {
      return this.match(14) && (a.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(a);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(a) {
      return !this.match(14) && super.isNonstaticConstructor(a);
    }
    pushClassMethod(a, f, g, v, S, F) {
      if (f.variance && this.unexpected(f.variance.loc.start), delete f.variance, this.match(47) && (f.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(a, f, g, v, S, F), f.params && S) {
        let B = f.params;
        B.length > 0 && this.isThisParam(B[0]) && this.raise(De.ThisParamBannedInConstructor, f);
      } else if (f.type === "MethodDefinition" && S && f.value.params) {
        let B = f.value.params;
        B.length > 0 && this.isThisParam(B[0]) && this.raise(De.ThisParamBannedInConstructor, f);
      }
    }
    pushClassPrivateMethod(a, f, g, v) {
      f.variance && this.unexpected(f.variance.loc.start), delete f.variance, this.match(47) && (f.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(a, f, g, v);
    }
    parseClassSuper(a) {
      if (super.parseClassSuper(a), a.superClass && this.match(47) && (a.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
        this.next();
        let f = a.implements = [];
        do {
          let g = this.startNode();
          g.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? g.typeParameters = this.flowParseTypeParameterInstantiation() : g.typeParameters = null, f.push(this.finishNode(g, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(a) {
      super.checkGetterSetterParams(a);
      let f = this.getObjectOrClassMethodParams(a);
      if (f.length > 0) {
        let g = f[0];
        this.isThisParam(g) && a.kind === "get" ? this.raise(De.GetterMayNotHaveThisParam, g) : this.isThisParam(g) && this.raise(De.SetterMayNotHaveThisParam, g);
      }
    }
    parsePropertyNamePrefixOperator(a) {
      a.variance = this.flowParseVariance();
    }
    parseObjPropValue(a, f, g, v, S, F, B) {
      a.variance && this.unexpected(a.variance.loc.start), delete a.variance;
      let O;
      this.match(47) && !F && (O = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let I = super.parseObjPropValue(a, f, g, v, S, F, B);
      return O && ((I.value || I).typeParameters = O), I;
    }
    parseAssignableListItemTypes(a) {
      return this.eat(17) && (a.type !== "Identifier" && this.raise(De.PatternIsOptional, a), this.isThisParam(a) && this.raise(De.ThisParamMayNotBeOptional, a), a.optional = !0), this.match(14) ? a.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(a) && this.raise(De.ThisParamAnnotationRequired, a), this.match(29) && this.isThisParam(a) && this.raise(De.ThisParamNoDefault, a), this.resetEndLocation(a), a;
    }
    parseMaybeDefault(a, f) {
      let g = super.parseMaybeDefault(a, f);
      return g.type === "AssignmentPattern" && g.typeAnnotation && g.right.start < g.typeAnnotation.start && this.raise(De.TypeBeforeInitializer, g.typeAnnotation), g;
    }
    checkImportReflection(a) {
      super.checkImportReflection(a), a.module && a.importKind !== "value" && this.raise(De.ImportReflectionHasImportType, a.specifiers[0].loc.start);
    }
    parseImportSpecifierLocal(a, f, g) {
      f.local = Vg(a) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), a.specifiers.push(this.finishImportSpecifier(f, g));
    }
    isPotentialImportPhase(a) {
      if (super.isPotentialImportPhase(a))
        return !0;
      if (this.isContextual(130)) {
        if (!a)
          return !0;
        let f = this.lookaheadCharCode();
        return f === 123 || f === 42;
      }
      return !a && this.isContextual(87);
    }
    applyImportPhase(a, f, g, v) {
      if (super.applyImportPhase(a, f, g, v), f) {
        if (!g && this.match(65))
          return;
        a.exportKind = g === "type" ? g : "value";
      } else
        g === "type" && this.match(55) && this.unexpected(), a.importKind = g === "type" || g === "typeof" ? g : "value";
    }
    parseImportSpecifier(a, f, g, v, S) {
      let F = a.imported, B = null;
      F.type === "Identifier" && (F.name === "type" ? B = "type" : F.name === "typeof" && (B = "typeof"));
      let O = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let J = this.parseIdentifier(!0);
        B !== null && !be(this.state.type) ? (a.imported = J, a.importKind = B, a.local = Rn(J)) : (a.imported = F, a.importKind = null, a.local = this.parseIdentifier());
      } else {
        if (B !== null && be(this.state.type))
          a.imported = this.parseIdentifier(!0), a.importKind = B;
        else {
          if (f)
            throw this.raise(x.ImportBindingIsString, a, { importName: F.value });
          a.imported = F, a.importKind = null;
        }
        this.eatContextual(93) ? a.local = this.parseIdentifier() : (O = !0, a.local = Rn(a.imported));
      }
      let I = Vg(a);
      return g && I && this.raise(De.ImportTypeShorthandOnlyInPureImport, a), (g || I) && this.checkReservedType(a.local.name, a.local.loc.start, !0), O && !g && !I && this.checkReservedWord(a.local.name, a.loc.start, !0, !0), this.finishImportSpecifier(a, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(a, f) {
      let g = a.kind;
      g !== "get" && g !== "set" && this.match(47) && (a.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(a, f);
    }
    parseVarId(a, f) {
      super.parseVarId(a, f), this.match(14) && (a.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(a.id));
    }
    parseAsyncArrowFromCallExpression(a, f) {
      if (this.match(14)) {
        let g = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, a.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = g;
      }
      return super.parseAsyncArrowFromCallExpression(a, f);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(a, f) {
      var g;
      let v = null, S;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (v = this.state.clone(), S = this.tryParse(() => super.parseMaybeAssign(a, f), v), !S.error)
          return S.node;
        let { context: O } = this.state, I = O[O.length - 1];
        (I === M.j_oTag || I === M.j_expr) && O.pop();
      }
      if ((g = S) != null && g.error || this.match(47)) {
        var F, B;
        v = v || this.state.clone();
        let O, I = this.tryParse((ne) => {
          var ue;
          O = this.flowParseTypeParameterDeclaration();
          let ae = this.forwardNoArrowParamsConversionAt(O, () => {
            let He = super.parseMaybeAssign(a, f);
            return this.resetStartLocationFromNode(He, O), He;
          });
          (ue = ae.extra) != null && ue.parenthesized && ne();
          let Ve = this.maybeUnwrapTypeCastExpression(ae);
          return Ve.type !== "ArrowFunctionExpression" && ne(), Ve.typeParameters = O, this.resetStartLocationFromNode(Ve, O), ae;
        }, v), J = null;
        if (I.node && this.maybeUnwrapTypeCastExpression(I.node).type === "ArrowFunctionExpression") {
          if (!I.error && !I.aborted)
            return I.node.async && this.raise(De.UnexpectedTypeParameterBeforeAsyncArrowFunction, O), I.node;
          J = I.node;
        }
        if ((F = S) != null && F.node)
          return this.state = S.failState, S.node;
        if (J)
          return this.state = I.failState, J;
        throw (B = S) != null && B.thrown ? S.error : I.thrown ? I.error : this.raise(De.UnexpectedTokenAfterTypeParameter, O);
      }
      return super.parseMaybeAssign(a, f);
    }
    parseArrow(a) {
      if (this.match(14)) {
        let f = this.tryParse(() => {
          let g = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let v = this.startNode();
          return [v.typeAnnotation, a.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = g, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), v;
        });
        if (f.thrown)
          return null;
        f.error && (this.state = f.failState), a.returnType = f.node.typeAnnotation ? this.finishNode(f.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(a);
    }
    shouldParseArrow(a) {
      return this.match(14) || super.shouldParseArrow(a);
    }
    setArrowFunctionParameters(a, f) {
      this.state.noArrowParamsConversionAt.indexOf(a.start) !== -1 ? a.params = f : super.setArrowFunctionParameters(a, f);
    }
    checkParams(a, f, g, v = !0) {
      if (!(g && this.state.noArrowParamsConversionAt.indexOf(a.start) !== -1)) {
        for (let S = 0; S < a.params.length; S++)
          this.isThisParam(a.params[S]) && S > 0 && this.raise(De.ThisParamMustBeFirst, a.params[S]);
        super.checkParams(a, f, g, v);
      }
    }
    parseParenAndDistinguishExpression(a) {
      return super.parseParenAndDistinguishExpression(a && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(a, f, g) {
      if (a.type === "Identifier" && a.name === "async" && this.state.noArrowAt.indexOf(f.index) !== -1) {
        this.next();
        let v = this.startNodeAt(f);
        v.callee = a, v.arguments = super.parseCallExpressionArguments(11, !1), a = this.finishNode(v, "CallExpression");
      } else if (a.type === "Identifier" && a.name === "async" && this.match(47)) {
        let v = this.state.clone(), S = this.tryParse((B) => this.parseAsyncArrowWithTypeParameters(f) || B(), v);
        if (!S.error && !S.aborted)
          return S.node;
        let F = this.tryParse(() => super.parseSubscripts(a, f, g), v);
        if (F.node && !F.error)
          return F.node;
        if (S.node)
          return this.state = S.failState, S.node;
        if (F.node)
          return this.state = F.failState, F.node;
        throw S.error || F.error;
      }
      return super.parseSubscripts(a, f, g);
    }
    parseSubscript(a, f, g, v) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (v.optionalChainMember = !0, g)
          return v.stop = !0, a;
        this.next();
        let S = this.startNodeAt(f);
        return S.callee = a, S.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), S.arguments = this.parseCallExpressionArguments(11, !1), S.optional = !0, this.finishCallExpression(S, !0);
      } else if (!g && this.shouldParseTypes() && this.match(47)) {
        let S = this.startNodeAt(f);
        S.callee = a;
        let F = this.tryParse(() => (S.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), S.arguments = super.parseCallExpressionArguments(11, !1), v.optionalChainMember && (S.optional = !1), this.finishCallExpression(S, v.optionalChainMember)));
        if (F.node)
          return F.error && (this.state = F.failState), F.node;
      }
      return super.parseSubscript(a, f, g, v);
    }
    parseNewCallee(a) {
      super.parseNewCallee(a);
      let f = null;
      this.shouldParseTypes() && this.match(47) && (f = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), a.typeArguments = f;
    }
    parseAsyncArrowWithTypeParameters(a) {
      let f = this.startNodeAt(a);
      if (this.parseFunctionParams(f, !1), !!this.parseArrow(f))
        return super.parseArrowExpression(f, void 0, !0);
    }
    readToken_mult_modulo(a) {
      let f = this.input.charCodeAt(this.state.pos + 1);
      if (a === 42 && f === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(a);
    }
    readToken_pipe_amp(a) {
      let f = this.input.charCodeAt(this.state.pos + 1);
      if (a === 124 && f === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(a);
    }
    parseTopLevel(a, f) {
      let g = super.parseTopLevel(a, f);
      return this.state.hasFlowComment && this.raise(De.UnterminatedFlowComment, this.state.curPosition()), g;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(De.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let a = this.skipFlowComment();
        a && (this.state.pos += a, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let { pos: a } = this.state, f = 2;
      for (; [32, 9].includes(this.input.charCodeAt(a + f)); )
        f++;
      let g = this.input.charCodeAt(f + a), v = this.input.charCodeAt(f + a + 1);
      return g === 58 && v === 58 ? f + 2 : this.input.slice(f + a, f + a + 12) === "flow-include" ? f + 12 : g === 58 && v !== 58 ? f : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(x.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(a, { enumName: f, memberName: g }) {
      this.raise(De.EnumBooleanMemberNotInitialized, a, { memberName: g, enumName: f });
    }
    flowEnumErrorInvalidMemberInitializer(a, f) {
      return this.raise(f.explicitType ? f.explicitType === "symbol" ? De.EnumInvalidMemberInitializerSymbolType : De.EnumInvalidMemberInitializerPrimaryType : De.EnumInvalidMemberInitializerUnknownType, a, f);
    }
    flowEnumErrorNumberMemberNotInitialized(a, f) {
      this.raise(De.EnumNumberMemberNotInitialized, a, f);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(a, f) {
      this.raise(De.EnumStringMemberInconsistentlyInitialized, a, f);
    }
    flowEnumMemberInit() {
      let a = this.state.startLoc, f = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 134: {
          let g = this.parseNumericLiteral(this.state.value);
          return f() ? { type: "number", loc: g.loc.start, value: g } : { type: "invalid", loc: a };
        }
        case 133: {
          let g = this.parseStringLiteral(this.state.value);
          return f() ? { type: "string", loc: g.loc.start, value: g } : { type: "invalid", loc: a };
        }
        case 85:
        case 86: {
          let g = this.parseBooleanLiteral(this.match(85));
          return f() ? { type: "boolean", loc: g.loc.start, value: g } : { type: "invalid", loc: a };
        }
        default:
          return { type: "invalid", loc: a };
      }
    }
    flowEnumMemberRaw() {
      let a = this.state.startLoc, f = this.parseIdentifier(!0), g = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: a };
      return { id: f, init: g };
    }
    flowEnumCheckExplicitTypeMismatch(a, f, g) {
      let { explicitType: v } = f;
      v !== null && v !== g && this.flowEnumErrorInvalidMemberInitializer(a, f);
    }
    flowEnumMembers({ enumName: a, explicitType: f }) {
      let g = /* @__PURE__ */ new Set(), v = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, S = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          S = !0;
          break;
        }
        let F = this.startNode(), { id: B, init: O } = this.flowEnumMemberRaw(), I = B.name;
        if (I === "")
          continue;
        /^[a-z]/.test(I) && this.raise(De.EnumInvalidMemberName, B, { memberName: I, suggestion: I[0].toUpperCase() + I.slice(1), enumName: a }), g.has(I) && this.raise(De.EnumDuplicateMemberName, B, { memberName: I, enumName: a }), g.add(I);
        let J = { enumName: a, explicitType: f, memberName: I };
        switch (F.id = B, O.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(O.loc, J, "boolean"), F.init = O.value, v.booleanMembers.push(this.finishNode(F, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(O.loc, J, "number"), F.init = O.value, v.numberMembers.push(this.finishNode(F, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(O.loc, J, "string"), F.init = O.value, v.stringMembers.push(this.finishNode(F, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(O.loc, J);
          case "none":
            switch (f) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(O.loc, J);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(O.loc, J);
                break;
              default:
                v.defaultedMembers.push(this.finishNode(F, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return { members: v, hasUnknownMembers: S };
    }
    flowEnumStringMembers(a, f, { enumName: g }) {
      if (a.length === 0)
        return f;
      if (f.length === 0)
        return a;
      if (f.length > a.length) {
        for (let v of a)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(v, { enumName: g });
        return f;
      } else {
        for (let v of f)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(v, { enumName: g });
        return a;
      }
    }
    flowEnumParseExplicitType({ enumName: a }) {
      if (!this.eatContextual(102))
        return null;
      if (!R(this.state.type))
        throw this.raise(De.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: a });
      let { value: f } = this.state;
      return this.next(), f !== "boolean" && f !== "number" && f !== "string" && f !== "symbol" && this.raise(De.EnumInvalidExplicitType, this.state.startLoc, { enumName: a, invalidEnumType: f }), f;
    }
    flowEnumBody(a, f) {
      let g = f.name, v = f.loc.start, S = this.flowEnumParseExplicitType({ enumName: g });
      this.expect(5);
      let { members: F, hasUnknownMembers: B } = this.flowEnumMembers({ enumName: g, explicitType: S });
      switch (a.hasUnknownMembers = B, S) {
        case "boolean":
          return a.explicitType = !0, a.members = F.booleanMembers, this.expect(8), this.finishNode(a, "EnumBooleanBody");
        case "number":
          return a.explicitType = !0, a.members = F.numberMembers, this.expect(8), this.finishNode(a, "EnumNumberBody");
        case "string":
          return a.explicitType = !0, a.members = this.flowEnumStringMembers(F.stringMembers, F.defaultedMembers, { enumName: g }), this.expect(8), this.finishNode(a, "EnumStringBody");
        case "symbol":
          return a.members = F.defaultedMembers, this.expect(8), this.finishNode(a, "EnumSymbolBody");
        default: {
          let O = () => (a.members = [], this.expect(8), this.finishNode(a, "EnumStringBody"));
          a.explicitType = !1;
          let I = F.booleanMembers.length, J = F.numberMembers.length, ne = F.stringMembers.length, ue = F.defaultedMembers.length;
          if (!I && !J && !ne && !ue)
            return O();
          if (!I && !J)
            return a.members = this.flowEnumStringMembers(F.stringMembers, F.defaultedMembers, { enumName: g }), this.expect(8), this.finishNode(a, "EnumStringBody");
          if (!J && !ne && I >= ue) {
            for (let ae of F.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(ae.loc.start, { enumName: g, memberName: ae.id.name });
            return a.members = F.booleanMembers, this.expect(8), this.finishNode(a, "EnumBooleanBody");
          } else if (!I && !ne && J >= ue) {
            for (let ae of F.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(ae.loc.start, { enumName: g, memberName: ae.id.name });
            return a.members = F.numberMembers, this.expect(8), this.finishNode(a, "EnumNumberBody");
          } else
            return this.raise(De.EnumInconsistentMemberValues, v, { enumName: g }), O();
        }
      }
    }
    flowParseEnumDeclaration(a) {
      let f = this.parseIdentifier();
      return a.id = f, a.body = this.flowEnumBody(this.startNode(), f), this.finishNode(a, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let a = this.nextTokenStart();
      if (this.input.charCodeAt(a) === 60) {
        let f = this.input.charCodeAt(a + 1);
        return f !== 60 && f !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(a) {
      return a.type === "TypeCastExpression" ? a.expression : a;
    }
  }, Ji = A`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: c }) => `Expected corresponding JSX closing tag for <${c}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: c, HTMLEntity: a }) => `Unexpected token \`${c}\`. Did you mean \`${a}\` or \`{'${c}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
  function ai(c) {
    return c ? c.type === "JSXOpeningFragment" || c.type === "JSXClosingFragment" : !1;
  }
  function Rs(c) {
    if (c.type === "JSXIdentifier")
      return c.name;
    if (c.type === "JSXNamespacedName")
      return c.namespace.name + ":" + c.name.name;
    if (c.type === "JSXMemberExpression")
      return Rs(c.object) + "." + Rs(c.property);
    throw new Error("Node had unexpected type: " + c.type);
  }
  var CS = (c) => class extends c {
    jsxReadToken() {
      let a = "", f = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(Ji.UnterminatedJsxContent, this.state.startLoc);
        let g = this.input.charCodeAt(this.state.pos);
        switch (g) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              g === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(g);
              return;
            }
            a += this.input.slice(f, this.state.pos), this.finishToken(141, a);
            return;
          case 38:
            a += this.input.slice(f, this.state.pos), a += this.jsxReadEntity(), f = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            Jo(g) ? (a += this.input.slice(f, this.state.pos), a += this.jsxReadNewLine(!0), f = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(a) {
      let f = this.input.charCodeAt(this.state.pos), g;
      return ++this.state.pos, f === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, g = a ? `
` : `\r
`) : g = String.fromCharCode(f), ++this.state.curLine, this.state.lineStart = this.state.pos, g;
    }
    jsxReadString(a) {
      let f = "", g = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(x.UnterminatedString, this.state.startLoc);
        let v = this.input.charCodeAt(this.state.pos);
        if (v === a)
          break;
        v === 38 ? (f += this.input.slice(g, this.state.pos), f += this.jsxReadEntity(), g = this.state.pos) : Jo(v) ? (f += this.input.slice(g, this.state.pos), f += this.jsxReadNewLine(!1), g = this.state.pos) : ++this.state.pos;
      }
      f += this.input.slice(g, this.state.pos++), this.finishToken(133, f);
    }
    jsxReadEntity() {
      let a = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let f = 10;
        this.codePointAtPos(this.state.pos) === 120 && (f = 16, ++this.state.pos);
        let g = this.readInt(f, void 0, !1, "bail");
        if (g !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(g);
      } else {
        let f = 0, g = !1;
        for (; f++ < 10 && this.state.pos < this.length && !(g = this.codePointAtPos(this.state.pos) == 59); )
          ++this.state.pos;
        if (g) {
          this.input.slice(a, this.state.pos);
          let v;
          ++this.state.pos;
        }
      }
      return this.state.pos = a, "&";
    }
    jsxReadWord() {
      let a, f = this.state.pos;
      do
        a = this.input.charCodeAt(++this.state.pos);
      while (Be(a) || a === 45);
      this.finishToken(140, this.input.slice(f, this.state.pos));
    }
    jsxParseIdentifier() {
      let a = this.startNode();
      return this.match(140) ? a.name = this.state.value : or(this.state.type) ? a.name = an(this.state.type) : this.unexpected(), this.next(), this.finishNode(a, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let a = this.state.startLoc, f = this.jsxParseIdentifier();
      if (!this.eat(14))
        return f;
      let g = this.startNodeAt(a);
      return g.namespace = f, g.name = this.jsxParseIdentifier(), this.finishNode(g, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let a = this.state.startLoc, f = this.jsxParseNamespacedName();
      if (f.type === "JSXNamespacedName")
        return f;
      for (; this.eat(16); ) {
        let g = this.startNodeAt(a);
        g.object = f, g.property = this.jsxParseIdentifier(), f = this.finishNode(g, "JSXMemberExpression");
      }
      return f;
    }
    jsxParseAttributeValue() {
      let a;
      switch (this.state.type) {
        case 5:
          return a = this.startNode(), this.setContext(M.brace), this.next(), a = this.jsxParseExpressionContainer(a, M.j_oTag), a.expression.type === "JSXEmptyExpression" && this.raise(Ji.AttributeIsEmpty, a), a;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise(Ji.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let a = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(a, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(a) {
      return this.next(), a.expression = this.parseExpression(), this.setContext(M.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(a, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(a, f) {
      if (this.match(8))
        a.expression = this.jsxParseEmptyExpression();
      else {
        let g = this.parseExpression();
        a.expression = g;
      }
      return this.setContext(f), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(a, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let a = this.startNode();
      return this.match(5) ? (this.setContext(M.brace), this.next(), this.expect(21), a.argument = this.parseMaybeAssignAllowIn(), this.setContext(M.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(a, "JSXSpreadAttribute")) : (a.name = this.jsxParseNamespacedName(), a.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(a, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(a) {
      let f = this.startNodeAt(a);
      return this.eat(143) ? this.finishNode(f, "JSXOpeningFragment") : (f.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(f));
    }
    jsxParseOpeningElementAfterName(a) {
      let f = [];
      for (; !this.match(56) && !this.match(143); )
        f.push(this.jsxParseAttribute());
      return a.attributes = f, a.selfClosing = this.eat(56), this.expect(143), this.finishNode(a, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(a) {
      let f = this.startNodeAt(a);
      return this.eat(143) ? this.finishNode(f, "JSXClosingFragment") : (f.name = this.jsxParseElementName(), this.expect(143), this.finishNode(f, "JSXClosingElement"));
    }
    jsxParseElementAt(a) {
      let f = this.startNodeAt(a), g = [], v = this.jsxParseOpeningElementAt(a), S = null;
      if (!v.selfClosing) {
        e:
          for (; ; )
            switch (this.state.type) {
              case 142:
                if (a = this.state.startLoc, this.next(), this.eat(56)) {
                  S = this.jsxParseClosingElementAt(a);
                  break e;
                }
                g.push(this.jsxParseElementAt(a));
                break;
              case 141:
                g.push(this.parseExprAtom());
                break;
              case 5: {
                let F = this.startNode();
                this.setContext(M.brace), this.next(), this.match(21) ? g.push(this.jsxParseSpreadChild(F)) : g.push(this.jsxParseExpressionContainer(F, M.j_expr));
                break;
              }
              default:
                this.unexpected();
            }
        ai(v) && !ai(S) && S !== null ? this.raise(Ji.MissingClosingTagFragment, S) : !ai(v) && ai(S) ? this.raise(Ji.MissingClosingTagElement, S, { openingTagName: Rs(v.name) }) : !ai(v) && !ai(S) && Rs(S.name) !== Rs(v.name) && this.raise(Ji.MissingClosingTagElement, S, { openingTagName: Rs(v.name) });
      }
      if (ai(v) ? (f.openingFragment = v, f.closingFragment = S) : (f.openingElement = v, f.closingElement = S), f.children = g, this.match(47))
        throw this.raise(Ji.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return ai(v) ? this.finishNode(f, "JSXFragment") : this.finishNode(f, "JSXElement");
    }
    jsxParseElement() {
      let a = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(a);
    }
    setContext(a) {
      let { context: f } = this.state;
      f[f.length - 1] = a;
    }
    parseExprAtom(a) {
      return this.match(141) ? this.parseLiteral(this.state.value, "JSXText") : this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(a);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(a) {
      let f = this.curContext();
      if (f === M.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (f === M.j_oTag || f === M.j_cTag) {
        if (Oe(a)) {
          this.jsxReadWord();
          return;
        }
        if (a === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((a === 34 || a === 39) && f === M.j_oTag) {
          this.jsxReadString(a);
          return;
        }
      }
      if (a === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(a);
    }
    updateContext(a) {
      let { context: f, type: g } = this.state;
      if (g === 56 && a === 142)
        f.splice(-2, 2, M.j_cTag), this.state.canStartJSXElement = !1;
      else if (g === 142)
        f.push(M.j_oTag);
      else if (g === 143) {
        let v = f[f.length - 1];
        v === M.j_oTag && a === 56 || v === M.j_cTag ? (f.pop(), this.state.canStartJSXElement = f[f.length - 1] === M.j_expr) : (this.setContext(M.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = Qt(g);
    }
  }, AS = class extends Nh {
    constructor(...c) {
      super(...c), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, ES = class extends Mh {
    constructor(...c) {
      super(...c), this.importsStack = [];
    }
    createScope(c) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new AS(c);
    }
    enter(c) {
      c == 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(c);
    }
    exit() {
      let c = super.exit();
      return c == 256 && this.importsStack.pop(), c;
    }
    hasImport(c, a) {
      let f = this.importsStack.length;
      if (this.importsStack[f - 1].has(c))
        return !0;
      if (!a && f > 1) {
        for (let g = 0; g < f - 1; g++)
          if (this.importsStack[g].has(c))
            return !0;
      }
      return !1;
    }
    declareName(c, a, f) {
      if (a & 4096) {
        this.hasImport(c, !0) && this.parser.raise(x.VarRedeclaration, f, { identifierName: c }), this.importsStack[this.importsStack.length - 1].add(c);
        return;
      }
      let g = this.currentScope(), v = g.tsNames.get(c) || 0;
      if (a & 1024) {
        this.maybeExportDefined(g, c), g.tsNames.set(c, v | 16);
        return;
      }
      super.declareName(c, a, f), a & 2 && (a & 1 || (this.checkRedeclarationInScope(g, c, a, f), this.maybeExportDefined(g, c)), v = v | 1), a & 256 && (v = v | 2), a & 512 && (v = v | 4), a & 128 && (v = v | 8), v && g.tsNames.set(c, v);
    }
    isRedeclaredInScope(c, a, f) {
      let g = c.tsNames.get(a);
      if ((g & 2) > 0) {
        if (f & 256) {
          let v = !!(f & 512), S = (g & 4) > 0;
          return v !== S;
        }
        return !0;
      }
      return f & 128 && (g & 8) > 0 ? c.names.get(a) & 2 ? !!(f & 1) : !1 : f & 2 && (g & 1) > 0 ? !0 : super.isRedeclaredInScope(c, a, f);
    }
    checkLocalExport(c) {
      let { name: a } = c;
      if (this.hasImport(a))
        return;
      let f = this.scopeStack.length;
      for (let g = f - 1; g >= 0; g--) {
        let v = this.scopeStack[g].tsNames.get(a);
        if ((v & 1) > 0 || (v & 16) > 0)
          return;
      }
      super.checkLocalExport(c);
    }
  }, wS = (c, a) => Object.hasOwnProperty.call(c, a) && c[a], zg = (c) => c.type === "ParenthesizedExpression" ? zg(c.expression) : c, SS = class extends mS {
    toAssignable(c, a = !1) {
      var f, g;
      let v;
      switch ((c.type === "ParenthesizedExpression" || (f = c.extra) != null && f.parenthesized) && (v = zg(c), a ? v.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(x.InvalidParenthesizedAssignment, c) : v.type !== "MemberExpression" && !this.isOptionalMemberExpression(v) && this.raise(x.InvalidParenthesizedAssignment, c) : this.raise(x.InvalidParenthesizedAssignment, c)), c.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          c.type = "ObjectPattern";
          for (let F = 0, B = c.properties.length, O = B - 1; F < B; F++) {
            var S;
            let I = c.properties[F], J = F === O;
            this.toAssignableObjectExpressionProp(I, J, a), J && I.type === "RestElement" && (S = c.extra) != null && S.trailingCommaLoc && this.raise(x.RestTrailingComma, c.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let { key: F, value: B } = c;
          this.isPrivateName(F) && this.classScope.usePrivateName(this.getPrivateNameSV(F), F.loc.start), this.toAssignable(B, a);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          c.type = "ArrayPattern", this.toAssignableList(c.elements, (g = c.extra) == null ? void 0 : g.trailingCommaLoc, a);
          break;
        case "AssignmentExpression":
          c.operator !== "=" && this.raise(x.MissingEqInAssignment, c.left.loc.end), c.type = "AssignmentPattern", delete c.operator, this.toAssignable(c.left, a);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(v, a);
          break;
      }
    }
    toAssignableObjectExpressionProp(c, a, f) {
      if (c.type === "ObjectMethod")
        this.raise(c.kind === "get" || c.kind === "set" ? x.PatternHasAccessor : x.PatternHasMethod, c.key);
      else if (c.type === "SpreadElement") {
        c.type = "RestElement";
        let g = c.argument;
        this.checkToRestConversion(g, !1), this.toAssignable(g, f), a || this.raise(x.RestTrailingComma, c);
      } else
        this.toAssignable(c, f);
    }
    toAssignableList(c, a, f) {
      let g = c.length - 1;
      for (let v = 0; v <= g; v++) {
        let S = c[v];
        if (S) {
          if (S.type === "SpreadElement") {
            S.type = "RestElement";
            let F = S.argument;
            this.checkToRestConversion(F, !0), this.toAssignable(F, f);
          } else
            this.toAssignable(S, f);
          S.type === "RestElement" && (v < g ? this.raise(x.RestTrailingComma, S) : a && this.raise(x.RestTrailingComma, a));
        }
      }
    }
    isAssignable(c, a) {
      switch (c.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let f = c.properties.length - 1;
          return c.properties.every((g, v) => g.type !== "ObjectMethod" && (v === f || g.type !== "SpreadElement") && this.isAssignable(g));
        }
        case "ObjectProperty":
          return this.isAssignable(c.value);
        case "SpreadElement":
          return this.isAssignable(c.argument);
        case "ArrayExpression":
          return c.elements.every((f) => f === null || this.isAssignable(f));
        case "AssignmentExpression":
          return c.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(c.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !a;
        default:
          return !1;
      }
    }
    toReferencedList(c, a) {
      return c;
    }
    toReferencedListDeep(c, a) {
      this.toReferencedList(c, a);
      for (let f of c)
        (f == null ? void 0 : f.type) === "ArrayExpression" && this.toReferencedListDeep(f.elements);
    }
    parseSpread(c) {
      let a = this.startNode();
      return this.next(), a.argument = this.parseMaybeAssignAllowIn(c, void 0), this.finishNode(a, "SpreadElement");
    }
    parseRestBinding() {
      let c = this.startNode();
      return this.next(), c.argument = this.parseBindingAtom(), this.finishNode(c, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let c = this.startNode();
          return this.next(), c.elements = this.parseBindingList(3, 93, 1), this.finishNode(c, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(c, a, f) {
      let g = f & 1, v = [], S = !0;
      for (; !this.eat(c); )
        if (S ? S = !1 : this.expect(12), g && this.match(12))
          v.push(null);
        else {
          if (this.eat(c))
            break;
          if (this.match(21)) {
            if (v.push(this.parseAssignableListItemTypes(this.parseRestBinding(), f)), !this.checkCommaAfterRest(a)) {
              this.expect(c);
              break;
            }
          } else {
            let F = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(x.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
              F.push(this.parseDecorator());
            v.push(this.parseAssignableListItem(f, F));
          }
        }
      return v;
    }
    parseBindingRestProperty(c) {
      return this.next(), c.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(c, "RestElement");
    }
    parseBindingProperty() {
      let c = this.startNode(), { type: a, startLoc: f } = this.state;
      return a === 21 ? this.parseBindingRestProperty(c) : (a === 138 ? (this.expectPlugin("destructuringPrivate", f), this.classScope.usePrivateName(this.state.value, f), c.key = this.parsePrivateName()) : this.parsePropertyName(c), c.method = !1, this.parseObjPropValue(c, f, !1, !1, !0, !1));
    }
    parseAssignableListItem(c, a) {
      let f = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(f, c);
      let g = this.parseMaybeDefault(f.loc.start, f);
      return a.length && (f.decorators = a), g;
    }
    parseAssignableListItemTypes(c, a) {
      return c;
    }
    parseMaybeDefault(c, a) {
      var f;
      if (c != null || (c = this.state.startLoc), a = (f = a) != null ? f : this.parseBindingAtom(), !this.eat(29))
        return a;
      let g = this.startNodeAt(c);
      return g.left = a, g.right = this.parseMaybeAssignAllowIn(), this.finishNode(g, "AssignmentPattern");
    }
    isValidLVal(c, a, f) {
      return wS({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, c);
    }
    isOptionalMemberExpression(c) {
      return c.type === "OptionalMemberExpression";
    }
    checkLVal(c, { in: a, binding: f = 64, checkClashes: g = !1, strictModeChanged: v = !1, hasParenthesizedAncestor: S = !1 }) {
      var F;
      let B = c.type;
      if (this.isObjectMethod(c))
        return;
      let O = this.isOptionalMemberExpression(c);
      if (O || B === "MemberExpression") {
        O && (this.expectPlugin("optionalChainingAssign", c.loc.start), a.type !== "AssignmentExpression" && this.raise(x.InvalidLhsOptionalChaining, c, { ancestor: a })), f !== 64 && this.raise(x.InvalidPropertyBindingPattern, c);
        return;
      }
      if (B === "Identifier") {
        this.checkIdentifier(c, f, v);
        let { name: ae } = c;
        g && (g.has(ae) ? this.raise(x.ParamDupe, c) : g.add(ae));
        return;
      }
      let I = this.isValidLVal(B, !(S || (F = c.extra) != null && F.parenthesized) && a.type === "AssignmentExpression", f);
      if (I === !0)
        return;
      if (I === !1) {
        let ae = f === 64 ? x.InvalidLhs : x.InvalidLhsBinding;
        this.raise(ae, c, { ancestor: a });
        return;
      }
      let [J, ne] = Array.isArray(I) ? I : [I, B === "ParenthesizedExpression"], ue = B === "ArrayPattern" || B === "ObjectPattern" ? { type: B } : a;
      for (let ae of [].concat(c[J]))
        ae && this.checkLVal(ae, { in: ue, binding: f, checkClashes: g, strictModeChanged: v, hasParenthesizedAncestor: ne });
    }
    checkIdentifier(c, a, f = !1) {
      this.state.strict && (f ? Og(c.name, this.inModule) : Mg(c.name)) && (a === 64 ? this.raise(x.StrictEvalArguments, c, { referenceName: c.name }) : this.raise(x.StrictEvalArgumentsBinding, c, { bindingName: c.name })), a & 8192 && c.name === "let" && this.raise(x.LetInLexicalBinding, c), a & 64 || this.declareNameFromIdentifier(c, a);
    }
    declareNameFromIdentifier(c, a) {
      this.scope.declareName(c.name, a, c.loc.start);
    }
    checkToRestConversion(c, a) {
      switch (c.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(c.expression, a);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (a)
            break;
        default:
          this.raise(x.InvalidRestAssignmentPattern, c);
      }
    }
    checkCommaAfterRest(c) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === c ? x.RestTrailingComma : x.ElementAfterRest, this.state.startLoc), !0) : !1;
    }
  }, TS = (c, a) => Object.hasOwnProperty.call(c, a) && c[a];
  function kS(c) {
    if (c == null)
      throw new Error(`Unexpected ${c} value.`);
    return c;
  }
  function Jg(c) {
    if (!c)
      throw new Error("Assert fail");
  }
  var fe = A`typescript`({ AbstractMethodHasImplementation: ({ methodName: c }) => `Method '${c}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: c }) => `Property '${c}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: c }) => `'declare' is not allowed in ${c}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: c }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier: c }) => `Duplicate modifier: '${c}'.`, EmptyHeritageClauseType: ({ token: c }) => `'${c}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: c }) => `'${c[0]}' modifier cannot be used with '${c[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: c }) => `Index signatures cannot have an accessibility modifier ('${c}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier: c }) => `'${c}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: c }) => `'${c}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: c }) => `'${c}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: c }) => `'${c[0]}' modifier must precede '${c[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: c }) => `Private elements cannot have an accessibility modifier ('${c}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: c }) => `Single type parameter ${c} should have a trailing comma. Example usage: <${c},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: c }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${c}.` });
  function FS(c) {
    switch (c) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  function Kg(c) {
    return c === "private" || c === "public" || c === "protected";
  }
  function PS(c) {
    return c === "in" || c === "out";
  }
  var BS = (c) => class extends c {
    constructor(...a) {
      super(...a), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: fe.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: fe.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: fe.InvalidModifierOnTypeParameter });
    }
    getScopeHandler() {
      return ES;
    }
    tsIsIdentifier() {
      return R(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(a, f) {
      if (!R(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let g = this.state.value;
      if (a.indexOf(g) !== -1) {
        if (f && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return g;
      }
    }
    tsParseModifiers({ allowedModifiers: a, disallowedModifiers: f, stopOnStartOfClassStaticBlock: g, errorTemplate: v = fe.InvalidModifierOnTypeMember }, S) {
      let F = (O, I, J, ne) => {
        I === J && S[ne] && this.raise(fe.InvalidModifiersOrder, O, { orderedModifiers: [J, ne] });
      }, B = (O, I, J, ne) => {
        (S[J] && I === ne || S[ne] && I === J) && this.raise(fe.IncompatibleModifiers, O, { modifiers: [J, ne] });
      };
      for (; ; ) {
        let { startLoc: O } = this.state, I = this.tsParseModifier(a.concat(f ?? []), g);
        if (!I)
          break;
        Kg(I) ? S.accessibility ? this.raise(fe.DuplicateAccessibilityModifier, O, { modifier: I }) : (F(O, I, I, "override"), F(O, I, I, "static"), F(O, I, I, "readonly"), S.accessibility = I) : PS(I) ? (S[I] && this.raise(fe.DuplicateModifier, O, { modifier: I }), S[I] = !0, F(O, I, "in", "out")) : (Object.hasOwnProperty.call(S, I) ? this.raise(fe.DuplicateModifier, O, { modifier: I }) : (F(O, I, "static", "readonly"), F(O, I, "static", "override"), F(O, I, "override", "readonly"), F(O, I, "abstract", "override"), B(O, I, "declare", "override"), B(O, I, "static", "abstract")), S[I] = !0), f != null && f.includes(I) && this.raise(v, O, { modifier: I });
      }
    }
    tsIsListTerminator(a) {
      switch (a) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(a, f) {
      let g = [];
      for (; !this.tsIsListTerminator(a); )
        g.push(f());
      return g;
    }
    tsParseDelimitedList(a, f, g) {
      return kS(this.tsParseDelimitedListWorker(a, f, !0, g));
    }
    tsParseDelimitedListWorker(a, f, g, v) {
      let S = [], F = -1;
      for (; !this.tsIsListTerminator(a); ) {
        F = -1;
        let B = f();
        if (B == null)
          return;
        if (S.push(B), this.eat(12)) {
          F = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(a))
          break;
        g && this.expect(12);
        return;
      }
      return v && (v.value = F), S;
    }
    tsParseBracketedList(a, f, g, v, S) {
      v || (g ? this.expect(0) : this.expect(47));
      let F = this.tsParseDelimitedList(a, f, S);
      return g ? this.expect(3) : this.expect(48), F;
    }
    tsParseImportType() {
      let a = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(fe.UnsupportedImportTypeArgument, this.state.startLoc), a.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (a.qualifier = this.tsParseEntityName()), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(a, "TSImportType");
    }
    tsParseEntityName(a = !0) {
      let f = this.parseIdentifier(a);
      for (; this.eat(16); ) {
        let g = this.startNodeAtNode(f);
        g.left = f, g.right = this.parseIdentifier(a), f = this.finishNode(g, "TSQualifiedName");
      }
      return f;
    }
    tsParseTypeReference() {
      let a = this.startNode();
      return a.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(a, "TSTypeReference");
    }
    tsParseThisTypePredicate(a) {
      this.next();
      let f = this.startNodeAtNode(a);
      return f.parameterName = a, f.typeAnnotation = this.tsParseTypeAnnotation(!1), f.asserts = !1, this.finishNode(f, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let a = this.startNode();
      return this.next(), this.finishNode(a, "TSThisType");
    }
    tsParseTypeQuery() {
      let a = this.startNode();
      return this.expect(87), this.match(83) ? a.exprName = this.tsParseImportType() : a.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(a, "TSTypeQuery");
    }
    tsParseTypeParameter(a) {
      let f = this.startNode();
      return a(f), f.name = this.tsParseTypeParameterName(), f.constraint = this.tsEatThenParseType(81), f.default = this.tsEatThenParseType(29), this.finishNode(f, "TSTypeParameter");
    }
    tsTryParseTypeParameters(a) {
      if (this.match(47))
        return this.tsParseTypeParameters(a);
    }
    tsParseTypeParameters(a) {
      let f = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let g = { value: -1 };
      return f.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, a), !1, !0, g), f.params.length === 0 && this.raise(fe.EmptyTypeParameters, f), g.value !== -1 && this.addExtra(f, "trailingComma", g.value), this.finishNode(f, "TSTypeParameterDeclaration");
    }
    tsFillSignature(a, f) {
      let g = a === 19, v = "parameters", S = "typeAnnotation";
      f.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), f[v] = this.tsParseBindingListForSignature(), g ? f[S] = this.tsParseTypeOrTypePredicateAnnotation(a) : this.match(a) && (f[S] = this.tsParseTypeOrTypePredicateAnnotation(a));
    }
    tsParseBindingListForSignature() {
      let a = super.parseBindingList(11, 41, 2);
      for (let f of a) {
        let { type: g } = f;
        (g === "AssignmentPattern" || g === "TSParameterProperty") && this.raise(fe.UnsupportedSignatureParameterKind, f, { type: g });
      }
      return a;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(a, f) {
      return this.tsFillSignature(14, f), this.tsParseTypeMemberSemicolon(), this.finishNode(f, a);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), R(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(a) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let f = this.parseIdentifier();
      f.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(f), this.expect(3), a.parameters = [f];
      let g = this.tsTryParseTypeAnnotation();
      return g && (a.typeAnnotation = g), this.tsParseTypeMemberSemicolon(), this.finishNode(a, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(a, f) {
      this.eat(17) && (a.optional = !0);
      let g = a;
      if (this.match(10) || this.match(47)) {
        f && this.raise(fe.ReadonlyForMethodSignature, a);
        let v = g;
        v.kind && this.match(47) && this.raise(fe.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, v), this.tsParseTypeMemberSemicolon();
        let S = "parameters", F = "typeAnnotation";
        if (v.kind === "get")
          v[S].length > 0 && (this.raise(x.BadGetterArity, this.state.curPosition()), this.isThisParam(v[S][0]) && this.raise(fe.AccesorCannotDeclareThisParameter, this.state.curPosition()));
        else if (v.kind === "set") {
          if (v[S].length !== 1)
            this.raise(x.BadSetterArity, this.state.curPosition());
          else {
            let B = v[S][0];
            this.isThisParam(B) && this.raise(fe.AccesorCannotDeclareThisParameter, this.state.curPosition()), B.type === "Identifier" && B.optional && this.raise(fe.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), B.type === "RestElement" && this.raise(fe.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          v[F] && this.raise(fe.SetAccesorCannotHaveReturnType, v[F]);
        } else
          v.kind = "method";
        return this.finishNode(v, "TSMethodSignature");
      } else {
        let v = g;
        f && (v.readonly = !0);
        let S = this.tsTryParseTypeAnnotation();
        return S && (v.typeAnnotation = S), this.tsParseTypeMemberSemicolon(), this.finishNode(v, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let a = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", a);
      if (this.match(77)) {
        let g = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", a) : (a.key = this.createIdentifier(g, "new"), this.tsParsePropertyOrMethodSignature(a, !1));
      }
      return this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, a), this.tsTryParseIndexSignature(a) || (super.parsePropertyName(a), !a.computed && a.key.type === "Identifier" && (a.key.name === "get" || a.key.name === "set") && this.tsTokenCanFollowModifier() && (a.kind = a.key.name, super.parsePropertyName(a)), this.tsParsePropertyOrMethodSignature(a, !!a.readonly));
    }
    tsParseTypeLiteral() {
      let a = this.startNode();
      return a.members = this.tsParseObjectTypeMembers(), this.finishNode(a, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let a = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), a;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let a = this.startNode();
      return a.name = this.tsParseTypeParameterName(), a.constraint = this.tsExpectThenParseType(58), this.finishNode(a, "TSTypeParameter");
    }
    tsParseMappedType() {
      let a = this.startNode();
      return this.expect(5), this.match(53) ? (a.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (a.readonly = !0), this.expect(0), a.typeParameter = this.tsParseMappedTypeParameter(), a.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (a.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (a.optional = !0), a.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(a, "TSMappedType");
    }
    tsParseTupleType() {
      let a = this.startNode();
      a.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let f = !1;
      return a.elementTypes.forEach((g) => {
        let { type: v } = g;
        f && v !== "TSRestType" && v !== "TSOptionalType" && !(v === "TSNamedTupleMember" && g.optional) && this.raise(fe.OptionalTypeBeforeRequired, g), f || (f = v === "TSNamedTupleMember" && g.optional || v === "TSOptionalType");
      }), this.finishNode(a, "TSTupleType");
    }
    tsParseTupleElementType() {
      let { startLoc: a } = this.state, f = this.eat(21), g, v, S, F, B = be(this.state.type) ? this.lookaheadCharCode() : null;
      if (B === 58)
        g = !0, S = !1, v = this.parseIdentifier(!0), this.expect(14), F = this.tsParseType();
      else if (B === 63) {
        S = !0;
        let O = this.state.startLoc, I = this.state.value, J = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (g = !0, v = this.createIdentifier(this.startNodeAt(O), I), this.expect(17), this.expect(14), F = this.tsParseType()) : (g = !1, F = J, this.expect(17));
      } else
        F = this.tsParseType(), S = this.eat(17), g = this.eat(14);
      if (g) {
        let O;
        v ? (O = this.startNodeAtNode(v), O.optional = S, O.label = v, O.elementType = F, this.eat(17) && (O.optional = !0, this.raise(fe.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (O = this.startNodeAtNode(F), O.optional = S, this.raise(fe.InvalidTupleMemberLabel, F), O.label = F, O.elementType = this.tsParseType()), F = this.finishNode(O, "TSNamedTupleMember");
      } else if (S) {
        let O = this.startNodeAtNode(F);
        O.typeAnnotation = F, F = this.finishNode(O, "TSOptionalType");
      }
      if (f) {
        let O = this.startNodeAt(a);
        O.typeAnnotation = F, F = this.finishNode(O, "TSRestType");
      }
      return F;
    }
    tsParseParenthesizedType() {
      let a = this.startNode();
      return this.expect(10), a.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(a, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(a, f) {
      let g = this.startNode();
      return a === "TSConstructorType" && (g.abstract = !!f, f && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, g)), this.finishNode(g, a);
    }
    tsParseLiteralTypeNode() {
      let a = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          a.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(a, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let a = this.startNode();
      return a.literal = super.parseTemplate(!1), this.finishNode(a, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let a = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(a) : a;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let a = this.startNode(), f = this.lookahead();
            return f.type !== 134 && f.type !== 135 && this.unexpected(), a.literal = this.parseMaybeUnary(), this.finishNode(a, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let { type: a } = this.state;
          if (R(a) || a === 88 || a === 84) {
            let f = a === 88 ? "TSVoidKeyword" : a === 84 ? "TSNullKeyword" : FS(this.state.value);
            if (f !== void 0 && this.lookaheadCharCode() !== 46) {
              let g = this.startNode();
              return this.next(), this.finishNode(g, f);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let a = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let f = this.startNodeAtNode(a);
          f.elementType = a, this.expect(3), a = this.finishNode(f, "TSArrayType");
        } else {
          let f = this.startNodeAtNode(a);
          f.objectType = a, f.indexType = this.tsParseType(), this.expect(3), a = this.finishNode(f, "TSIndexedAccessType");
        }
      return a;
    }
    tsParseTypeOperator() {
      let a = this.startNode(), f = this.state.value;
      return this.next(), a.operator = f, a.typeAnnotation = this.tsParseTypeOperatorOrHigher(), f === "readonly" && this.tsCheckTypeAnnotationForReadOnly(a), this.finishNode(a, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(a) {
      switch (a.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(fe.UnexpectedReadonly, a);
      }
    }
    tsParseInferType() {
      let a = this.startNode();
      this.expectContextual(115);
      let f = this.startNode();
      return f.name = this.tsParseTypeParameterName(), f.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), a.typeParameter = this.finishNode(f, "TSTypeParameter"), this.finishNode(a, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let a = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return a;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return Ln(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(a, f, g) {
      let v = this.startNode(), S = this.eat(g), F = [];
      do
        F.push(f());
      while (this.eat(g));
      return F.length === 1 && !S ? F[0] : (v.types = F, this.finishNode(v, a));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (R(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let { errors: a } = this.state, f = a.length;
        try {
          return this.parseObjectLike(8, !0), a.length === f;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let { errors: a } = this.state, f = a.length;
        try {
          return super.parseBindingList(3, 93, 1), a.length === f;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(a) {
      return this.tsInType(() => {
        let f = this.startNode();
        this.expect(a);
        let g = this.startNode(), v = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (v && this.match(78)) {
          let B = this.tsParseThisTypeOrThisTypePredicate();
          return B.type === "TSThisType" ? (g.parameterName = B, g.asserts = !0, g.typeAnnotation = null, B = this.finishNode(g, "TSTypePredicate")) : (this.resetStartLocationFromNode(B, g), B.asserts = !0), f.typeAnnotation = B, this.finishNode(f, "TSTypeAnnotation");
        }
        let S = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!S)
          return v ? (g.parameterName = this.parseIdentifier(), g.asserts = v, g.typeAnnotation = null, f.typeAnnotation = this.finishNode(g, "TSTypePredicate"), this.finishNode(f, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, f);
        let F = this.tsParseTypeAnnotation(!1);
        return g.parameterName = S, g.typeAnnotation = F, g.asserts = v, f.typeAnnotation = this.finishNode(g, "TSTypePredicate"), this.finishNode(f, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let a = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), a;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let a = this.state.containsEsc;
      return this.next(), !R(this.state.type) && !this.match(78) ? !1 : (a && this.raise(x.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), !0);
    }
    tsParseTypeAnnotation(a = !0, f = this.startNode()) {
      return this.tsInType(() => {
        a && this.expect(14), f.typeAnnotation = this.tsParseType();
      }), this.finishNode(f, "TSTypeAnnotation");
    }
    tsParseType() {
      Jg(this.state.inType);
      let a = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return a;
      let f = this.startNodeAtNode(a);
      return f.checkType = a, f.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), f.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), f.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(f, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(fe.ReservedTypeAssertion, this.state.startLoc);
      let a = this.startNode();
      return a.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), a.expression = this.parseMaybeUnary(), this.finishNode(a, "TSTypeAssertion");
    }
    tsParseHeritageClause(a) {
      let f = this.state.startLoc, g = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let v = this.startNode();
        return v.expression = this.tsParseEntityName(), this.match(47) && (v.typeParameters = this.tsParseTypeArguments()), this.finishNode(v, "TSExpressionWithTypeArguments");
      });
      return g.length || this.raise(fe.EmptyHeritageClauseType, f, { token: a }), g;
    }
    tsParseInterfaceDeclaration(a, f = {}) {
      if (this.hasFollowingLineBreak())
        return null;
      this.expectContextual(129), f.declare && (a.declare = !0), R(this.state.type) ? (a.id = this.parseIdentifier(), this.checkIdentifier(a.id, 130)) : (a.id = null, this.raise(fe.MissingInterfaceName, this.state.startLoc)), a.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (a.extends = this.tsParseHeritageClause("extends"));
      let g = this.startNode();
      return g.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), a.body = this.finishNode(g, "TSInterfaceBody"), this.finishNode(a, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(a) {
      return a.id = this.parseIdentifier(), this.checkIdentifier(a.id, 2), a.typeAnnotation = this.tsInType(() => {
        if (a.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
          let f = this.startNode();
          return this.next(), this.finishNode(f, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(a, "TSTypeAliasDeclaration");
    }
    tsInNoContext(a) {
      let f = this.state.context;
      this.state.context = [f[0]];
      try {
        return a();
      } finally {
        this.state.context = f;
      }
    }
    tsInType(a) {
      let f = this.state.inType;
      this.state.inType = !0;
      try {
        return a();
      } finally {
        this.state.inType = f;
      }
    }
    tsInDisallowConditionalTypesContext(a) {
      let f = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return a();
      } finally {
        this.state.inDisallowConditionalTypesContext = f;
      }
    }
    tsInAllowConditionalTypesContext(a) {
      let f = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return a();
      } finally {
        this.state.inDisallowConditionalTypesContext = f;
      }
    }
    tsEatThenParseType(a) {
      if (this.match(a))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(a) {
      return this.tsInType(() => (this.expect(a), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let a = this.startNode();
      return a.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (a.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(a, "TSEnumMember");
    }
    tsParseEnumDeclaration(a, f = {}) {
      return f.const && (a.const = !0), f.declare && (a.declare = !0), this.expectContextual(126), a.id = this.parseIdentifier(), this.checkIdentifier(a.id, a.const ? 8971 : 8459), this.expect(5), a.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(a, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let a = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(a.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(a, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(a, f = !1) {
      if (a.id = this.parseIdentifier(), f || this.checkIdentifier(a.id, 1024), this.eat(16)) {
        let g = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(g, !0), a.body = g;
      } else
        this.scope.enter(256), this.prodParam.enter(0), a.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(a, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(a) {
      return this.isContextual(112) ? (a.global = !0, a.id = this.parseIdentifier()) : this.match(133) ? a.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), a.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(a, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(a, f, g) {
      a.isExport = g || !1, a.id = f || this.parseIdentifier(), this.checkIdentifier(a.id, 4096), this.expect(29);
      let v = this.tsParseModuleReference();
      return a.importKind === "type" && v.type !== "TSExternalModuleReference" && this.raise(fe.ImportAliasHasImportType, v), a.moduleReference = v, this.semicolon(), this.finishNode(a, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      let a = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), a.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(a, "TSExternalModuleReference");
    }
    tsLookAhead(a) {
      let f = this.state.clone(), g = a();
      return this.state = f, g;
    }
    tsTryParseAndCatch(a) {
      let f = this.tryParse((g) => a() || g());
      if (!(f.aborted || !f.node))
        return f.error && (this.state = f.failState), f.node;
    }
    tsTryParse(a) {
      let f = this.state.clone(), g = a();
      if (g !== void 0 && g !== !1)
        return g;
      this.state = f;
    }
    tsTryParseDeclare(a) {
      if (this.isLineTerminator())
        return;
      let f = this.state.type, g;
      return this.isContextual(100) && (f = 74, g = "let"), this.tsInAmbientContext(() => {
        switch (f) {
          case 68:
            return a.declare = !0, super.parseFunctionStatement(a, !1, !1);
          case 80:
            return a.declare = !0, this.parseClass(a, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(a, { declare: !0 });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(a);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (a.declare = !0, this.parseVarStatement(a, g || this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(a, { const: !0, declare: !0 }));
          case 129: {
            let v = this.tsParseInterfaceDeclaration(a, { declare: !0 });
            if (v)
              return v;
          }
          default:
            if (R(f))
              return this.tsParseDeclaration(a, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(a, f, g) {
      switch (f.name) {
        case "declare": {
          let v = this.tsTryParseDeclare(a);
          return v && (v.declare = !0), v;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let v = a;
            return v.global = !0, v.id = f, v.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(v, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(a, f.name, !1, g);
      }
    }
    tsParseDeclaration(a, f, g, v) {
      switch (f) {
        case "abstract":
          if (this.tsCheckLineTerminator(g) && (this.match(80) || R(this.state.type)))
            return this.tsParseAbstractDeclaration(a, v);
          break;
        case "module":
          if (this.tsCheckLineTerminator(g)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(a);
            if (R(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(a);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(g) && R(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(a);
          break;
        case "type":
          if (this.tsCheckLineTerminator(g) && R(this.state.type))
            return this.tsParseTypeAliasDeclaration(a);
          break;
      }
    }
    tsCheckLineTerminator(a) {
      return a ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(a) {
      if (!this.match(47))
        return;
      let f = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let g = this.tsTryParseAndCatch(() => {
        let v = this.startNodeAt(a);
        return v.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(v), v.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), v;
      });
      if (this.state.maybeInArrowParameters = f, !!g)
        return super.parseArrowExpression(g, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let a = this.startNode();
      return a.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), a.params.length === 0 ? this.raise(fe.EmptyTypeArguments, a) : !this.state.inType && this.curContext() === M.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(a, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return _n(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(a, f) {
      let g = this.state.startLoc, v = {};
      this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, v);
      let S = v.accessibility, F = v.override, B = v.readonly;
      !(a & 4) && (S || B || F) && this.raise(fe.UnexpectedParameterModifier, g);
      let O = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(O, a);
      let I = this.parseMaybeDefault(O.loc.start, O);
      if (S || B || F) {
        let J = this.startNodeAt(g);
        return f.length && (J.decorators = f), S && (J.accessibility = S), B && (J.readonly = B), F && (J.override = F), I.type !== "Identifier" && I.type !== "AssignmentPattern" && this.raise(fe.UnsupportedParameterPropertyKind, J), J.parameter = I, this.finishNode(J, "TSParameterProperty");
      }
      return f.length && (O.decorators = f), I;
    }
    isSimpleParameter(a) {
      return a.type === "TSParameterProperty" && super.isSimpleParameter(a.parameter) || super.isSimpleParameter(a);
    }
    tsDisallowOptionalPattern(a) {
      for (let f of a.params)
        f.type !== "Identifier" && f.optional && !this.state.isAmbientContext && this.raise(fe.PatternIsOptional, f);
    }
    setArrowFunctionParameters(a, f, g) {
      super.setArrowFunctionParameters(a, f, g), this.tsDisallowOptionalPattern(a);
    }
    parseFunctionBodyAndFinish(a, f, g = !1) {
      this.match(14) && (a.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let v = f === "FunctionDeclaration" ? "TSDeclareFunction" : f === "ClassMethod" || f === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return v && !this.match(5) && this.isLineTerminator() ? this.finishNode(a, v) : v === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(fe.DeclareFunctionHasImplementation, a), a.declare) ? super.parseFunctionBodyAndFinish(a, v, g) : (this.tsDisallowOptionalPattern(a), super.parseFunctionBodyAndFinish(a, f, g));
    }
    registerFunctionStatementId(a) {
      !a.body && a.id ? this.checkIdentifier(a.id, 1024) : super.registerFunctionStatementId(a);
    }
    tsCheckForInvalidTypeCasts(a) {
      a.forEach((f) => {
        (f == null ? void 0 : f.type) === "TSTypeCastExpression" && this.raise(fe.UnexpectedTypeAnnotation, f.typeAnnotation);
      });
    }
    toReferencedList(a, f) {
      return this.tsCheckForInvalidTypeCasts(a), a;
    }
    parseArrayLike(a, f, g, v) {
      let S = super.parseArrayLike(a, f, g, v);
      return S.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(S.elements), S;
    }
    parseSubscript(a, f, g, v) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let F = this.startNodeAt(f);
        return F.expression = a, this.finishNode(F, "TSNonNullExpression");
      }
      let S = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (g)
          return v.stop = !0, a;
        v.optionalChainMember = S = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let F, B = this.tsTryParseAndCatch(() => {
          if (!g && this.atPossibleAsyncArrow(a)) {
            let ne = this.tsTryParseGenericAsyncArrowFunction(f);
            if (ne)
              return ne;
          }
          let O = this.tsParseTypeArgumentsInExpression();
          if (!O)
            return;
          if (S && !this.match(10)) {
            F = this.state.curPosition();
            return;
          }
          if (_s(this.state.type)) {
            let ne = super.parseTaggedTemplateExpression(a, f, v);
            return ne.typeParameters = O, ne;
          }
          if (!g && this.eat(10)) {
            let ne = this.startNodeAt(f);
            return ne.callee = a, ne.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(ne.arguments), ne.typeParameters = O, v.optionalChainMember && (ne.optional = S), this.finishCallExpression(ne, v.optionalChainMember);
          }
          let I = this.state.type;
          if (I === 48 || I === 52 || I !== 10 && Mt(I) && !this.hasPrecedingLineBreak())
            return;
          let J = this.startNodeAt(f);
          return J.expression = a, J.typeParameters = O, this.finishNode(J, "TSInstantiationExpression");
        });
        if (F && this.unexpected(F, 10), B)
          return B.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(fe.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), B;
      }
      return super.parseSubscript(a, f, g, v);
    }
    parseNewCallee(a) {
      var f;
      super.parseNewCallee(a);
      let { callee: g } = a;
      g.type === "TSInstantiationExpression" && !((f = g.extra) != null && f.parenthesized) && (a.typeParameters = g.typeParameters, a.callee = g.expression);
    }
    parseExprOp(a, f, g) {
      let v;
      if (Ls(58) > g && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (v = this.isContextual(120)))) {
        let S = this.startNodeAt(f);
        return S.expression = a, S.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (v && this.raise(x.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(S, v ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(S, f, g);
      }
      return super.parseExprOp(a, f, g);
    }
    checkReservedWord(a, f, g, v) {
      this.state.isAmbientContext || super.checkReservedWord(a, f, g, v);
    }
    checkImportReflection(a) {
      super.checkImportReflection(a), a.module && a.importKind !== "value" && this.raise(fe.ImportReflectionHasImportType, a.specifiers[0].loc.start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(a) {
      if (super.isPotentialImportPhase(a))
        return !0;
      if (this.isContextual(130)) {
        let f = this.lookaheadCharCode();
        return a ? f === 123 || f === 42 : f !== 61;
      }
      return !a && this.isContextual(87);
    }
    applyImportPhase(a, f, g, v) {
      super.applyImportPhase(a, f, g, v), f ? a.exportKind = g === "type" ? "type" : "value" : a.importKind = g === "type" || g === "typeof" ? g : "value";
    }
    parseImport(a) {
      if (this.match(133))
        return a.importKind = "value", super.parseImport(a);
      let f;
      if (R(this.state.type) && this.lookaheadCharCode() === 61)
        return a.importKind = "value", this.tsParseImportEqualsDeclaration(a);
      if (this.isContextual(130)) {
        let g = this.parseMaybeImportPhase(a, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(a, g);
        f = super.parseImportSpecifiersAndAfter(a, g);
      } else
        f = super.parseImport(a);
      return f.importKind === "type" && f.specifiers.length > 1 && f.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(fe.TypeImportCannotSpecifyDefaultAndNamed, f), f;
    }
    parseExport(a, f) {
      if (this.match(83)) {
        this.next();
        let g = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? g = this.parseMaybeImportPhase(a, !1) : a.importKind = "value", this.tsParseImportEqualsDeclaration(a, g, !0);
      } else if (this.eat(29)) {
        let g = a;
        return g.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(g, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let g = a;
        return this.expectContextual(128), g.id = this.parseIdentifier(), this.semicolon(), this.finishNode(g, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(a, f);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let a = this.startNode();
        return this.next(), a.abstract = !0, this.parseClass(a, !0, !0);
      }
      if (this.match(129)) {
        let a = this.tsParseInterfaceDeclaration(this.startNode());
        if (a)
          return a;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(a, f, g = !1) {
      let { isAmbientContext: v } = this.state, S = super.parseVarStatement(a, f, g || v);
      if (!v)
        return S;
      for (let { id: F, init: B } of S.declarations)
        B && (f !== "const" || F.typeAnnotation ? this.raise(fe.InitializerNotAllowedInAmbientContext, B) : NS(B, this.hasPlugin("estree")) || this.raise(fe.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, B));
      return S;
    }
    parseStatementContent(a, f) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let g = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(g, { const: !0 });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let g = this.tsParseInterfaceDeclaration(this.startNode());
        if (g)
          return g;
      }
      return super.parseStatementContent(a, f);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(a, f) {
      return f.some((g) => Kg(g) ? a.accessibility === g : !!a[g]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(a, f, g) {
      let v = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({ allowedModifiers: v, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: !0, errorTemplate: fe.InvalidModifierOnTypeParameterPositions }, f);
      let S = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(f, v) && this.raise(fe.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(a, f)) : this.parseClassMemberWithIsStatic(a, f, g, !!f.static);
      };
      f.declare ? this.tsInAmbientContext(S) : S();
    }
    parseClassMemberWithIsStatic(a, f, g, v) {
      let S = this.tsTryParseIndexSignature(f);
      if (S) {
        a.body.push(S), f.abstract && this.raise(fe.IndexSignatureHasAbstract, f), f.accessibility && this.raise(fe.IndexSignatureHasAccessibility, f, { modifier: f.accessibility }), f.declare && this.raise(fe.IndexSignatureHasDeclare, f), f.override && this.raise(fe.IndexSignatureHasOverride, f);
        return;
      }
      !this.state.inAbstractClass && f.abstract && this.raise(fe.NonAbstractClassHasAbstractMethod, f), f.override && (g.hadSuperClass || this.raise(fe.OverrideNotInSubClass, f)), super.parseClassMemberWithIsStatic(a, f, g, v);
    }
    parsePostMemberNameModifiers(a) {
      this.eat(17) && (a.optional = !0), a.readonly && this.match(10) && this.raise(fe.ClassMethodHasReadonly, a), a.declare && this.match(10) && this.raise(fe.ClassMethodHasDeclare, a);
    }
    parseExpressionStatement(a, f, g) {
      return (f.type === "Identifier" ? this.tsParseExpressionStatement(a, f, g) : void 0) || super.parseExpressionStatement(a, f, g);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(a, f, g) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(a, f, g);
      let v = this.tryParse(() => super.parseConditional(a, f));
      return v.node ? (v.error && (this.state = v.failState), v.node) : (v.error && super.setOptionalParametersError(g, v.error), a);
    }
    parseParenItem(a, f) {
      if (a = super.parseParenItem(a, f), this.eat(17) && (a.optional = !0, this.resetEndLocation(a)), this.match(14)) {
        let g = this.startNodeAt(f);
        return g.expression = a, g.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(g, "TSTypeCastExpression");
      }
      return a;
    }
    parseExportDeclaration(a) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(a));
      let f = this.state.startLoc, g = this.eatContextual(125);
      if (g && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(fe.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let v = R(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(a);
      return v ? ((v.type === "TSInterfaceDeclaration" || v.type === "TSTypeAliasDeclaration" || g) && (a.exportKind = "type"), g && (this.resetStartLocation(v, f), v.declare = !0), v) : null;
    }
    parseClassId(a, f, g, v) {
      if ((!f || g) && this.isContextual(113))
        return;
      super.parseClassId(a, f, g, a.declare ? 1024 : 8331);
      let S = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      S && (a.typeParameters = S);
    }
    parseClassPropertyAnnotation(a) {
      a.optional || (this.eat(35) ? a.definite = !0 : this.eat(17) && (a.optional = !0));
      let f = this.tsTryParseTypeAnnotation();
      f && (a.typeAnnotation = f);
    }
    parseClassProperty(a) {
      if (this.parseClassPropertyAnnotation(a), this.state.isAmbientContext && !(a.readonly && !a.typeAnnotation) && this.match(29) && this.raise(fe.DeclareClassFieldHasInitializer, this.state.startLoc), a.abstract && this.match(29)) {
        let { key: f } = a;
        this.raise(fe.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: f.type === "Identifier" && !a.computed ? f.name : `[${this.input.slice(f.start, f.end)}]` });
      }
      return super.parseClassProperty(a);
    }
    parseClassPrivateProperty(a) {
      return a.abstract && this.raise(fe.PrivateElementHasAbstract, a), a.accessibility && this.raise(fe.PrivateElementHasAccessibility, a, { modifier: a.accessibility }), this.parseClassPropertyAnnotation(a), super.parseClassPrivateProperty(a);
    }
    parseClassAccessorProperty(a) {
      return this.parseClassPropertyAnnotation(a), a.optional && this.raise(fe.AccessorCannotBeOptional, a), super.parseClassAccessorProperty(a);
    }
    pushClassMethod(a, f, g, v, S, F) {
      let B = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      B && S && this.raise(fe.ConstructorHasTypeParameters, B);
      let { declare: O = !1, kind: I } = f;
      O && (I === "get" || I === "set") && this.raise(fe.DeclareAccessor, f, { kind: I }), B && (f.typeParameters = B), super.pushClassMethod(a, f, g, v, S, F);
    }
    pushClassPrivateMethod(a, f, g, v) {
      let S = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      S && (f.typeParameters = S), super.pushClassPrivateMethod(a, f, g, v);
    }
    declareClassPrivateMethodInScope(a, f) {
      a.type !== "TSDeclareMethod" && (a.type === "MethodDefinition" && !a.value.body || super.declareClassPrivateMethodInScope(a, f));
    }
    parseClassSuper(a) {
      super.parseClassSuper(a), a.superClass && (this.match(47) || this.match(51)) && (a.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (a.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(a, f, g, v, S, F, B) {
      let O = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return O && (a.typeParameters = O), super.parseObjPropValue(a, f, g, v, S, F, B);
    }
    parseFunctionParams(a, f) {
      let g = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      g && (a.typeParameters = g), super.parseFunctionParams(a, f);
    }
    parseVarId(a, f) {
      super.parseVarId(a, f), a.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (a.definite = !0);
      let g = this.tsTryParseTypeAnnotation();
      g && (a.id.typeAnnotation = g, this.resetEndLocation(a.id));
    }
    parseAsyncArrowFromCallExpression(a, f) {
      return this.match(14) && (a.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(a, f);
    }
    parseMaybeAssign(a, f) {
      var g, v, S, F, B;
      let O, I, J;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (O = this.state.clone(), I = this.tryParse(() => super.parseMaybeAssign(a, f), O), !I.error)
          return I.node;
        let { context: ae } = this.state, Ve = ae[ae.length - 1];
        (Ve === M.j_oTag || Ve === M.j_expr) && ae.pop();
      }
      if (!((g = I) != null && g.error) && !this.match(47))
        return super.parseMaybeAssign(a, f);
      (!O || O === this.state) && (O = this.state.clone());
      let ne, ue = this.tryParse((ae) => {
        var Ve, He;
        ne = this.tsParseTypeParameters(this.tsParseConstModifier);
        let dt = super.parseMaybeAssign(a, f);
        return (dt.type !== "ArrowFunctionExpression" || (Ve = dt.extra) != null && Ve.parenthesized) && ae(), ((He = ne) == null ? void 0 : He.params.length) !== 0 && this.resetStartLocationFromNode(dt, ne), dt.typeParameters = ne, dt;
      }, O);
      if (!ue.error && !ue.aborted)
        return ne && this.reportReservedArrowTypeParam(ne), ue.node;
      if (!I && (Jg(!this.hasPlugin("jsx")), J = this.tryParse(() => super.parseMaybeAssign(a, f), O), !J.error))
        return J.node;
      if ((v = I) != null && v.node)
        return this.state = I.failState, I.node;
      if (ue.node)
        return this.state = ue.failState, ne && this.reportReservedArrowTypeParam(ne), ue.node;
      if ((S = J) != null && S.node)
        return this.state = J.failState, J.node;
      throw ((F = I) == null ? void 0 : F.error) || ue.error || ((B = J) == null ? void 0 : B.error);
    }
    reportReservedArrowTypeParam(a) {
      var f;
      a.params.length === 1 && !a.params[0].constraint && !((f = a.extra) != null && f.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(fe.ReservedArrowTypeParam, a);
    }
    parseMaybeUnary(a, f) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(a, f);
    }
    parseArrow(a) {
      if (this.match(14)) {
        let f = this.tryParse((g) => {
          let v = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && g(), v;
        });
        if (f.aborted)
          return;
        f.thrown || (f.error && (this.state = f.failState), a.returnType = f.node);
      }
      return super.parseArrow(a);
    }
    parseAssignableListItemTypes(a, f) {
      if (!(f & 2))
        return a;
      this.eat(17) && (a.optional = !0);
      let g = this.tsTryParseTypeAnnotation();
      return g && (a.typeAnnotation = g), this.resetEndLocation(a), a;
    }
    isAssignable(a, f) {
      switch (a.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(a.expression, f);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(a, f);
      }
    }
    toAssignable(a, f = !1) {
      switch (a.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(a, f);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          f ? this.expressionScope.recordArrowParameterBindingError(fe.UnexpectedTypeCastInParameter, a) : this.raise(fe.UnexpectedTypeCastInParameter, a), this.toAssignable(a.expression, f);
          break;
        case "AssignmentExpression":
          !f && a.left.type === "TSTypeCastExpression" && (a.left = this.typeCastToParameter(a.left));
        default:
          super.toAssignable(a, f);
      }
    }
    toAssignableParenthesizedExpression(a, f) {
      switch (a.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(a.expression, f);
          break;
        default:
          super.toAssignable(a, f);
      }
    }
    checkToRestConversion(a, f) {
      switch (a.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(a.expression, !1);
          break;
        default:
          super.checkToRestConversion(a, f);
      }
    }
    isValidLVal(a, f, g) {
      return TS({ TSTypeCastExpression: !0, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (g !== 64 || !f) && ["expression", !0], TSSatisfiesExpression: (g !== 64 || !f) && ["expression", !0], TSTypeAssertion: (g !== 64 || !f) && ["expression", !0] }, a) || super.isValidLVal(a, f, g);
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(a) {
      if (this.match(47) || this.match(51)) {
        let f = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let g = super.parseMaybeDecoratorArguments(a);
          return g.typeParameters = f, g;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(a);
    }
    checkCommaAfterRest(a) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === a ? (this.next(), !1) : super.checkCommaAfterRest(a);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(a, f) {
      let g = super.parseMaybeDefault(a, f);
      return g.type === "AssignmentPattern" && g.typeAnnotation && g.right.start < g.typeAnnotation.start && this.raise(fe.TypeAnnotationAfterAssign, g.typeAnnotation), g;
    }
    getTokenFromCode(a) {
      if (this.state.inType) {
        if (a === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (a === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(a);
    }
    reScan_lt_gt() {
      let { type: a } = this.state;
      a === 47 ? (this.state.pos -= 1, this.readToken_lt()) : a === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let { type: a } = this.state;
      return a === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : a;
    }
    toAssignableList(a, f, g) {
      for (let v = 0; v < a.length; v++) {
        let S = a[v];
        (S == null ? void 0 : S.type) === "TSTypeCastExpression" && (a[v] = this.typeCastToParameter(S));
      }
      super.toAssignableList(a, f, g);
    }
    typeCastToParameter(a) {
      return a.expression.typeAnnotation = a.typeAnnotation, this.resetEndLocation(a.expression, a.typeAnnotation.loc.end), a.expression;
    }
    shouldParseArrow(a) {
      return this.match(14) ? a.every((f) => this.isAssignable(f, !0)) : super.shouldParseArrow(a);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(a) {
      if (this.match(47) || this.match(51)) {
        let f = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        f && (a.typeParameters = f);
      }
      return super.jsxParseOpeningElementAfterName(a);
    }
    getGetterSetterExpectedParamCount(a) {
      let f = super.getGetterSetterExpectedParamCount(a), g = this.getObjectOrClassMethodParams(a)[0];
      return g && this.isThisParam(g) ? f + 1 : f;
    }
    parseCatchClauseParam() {
      let a = super.parseCatchClauseParam(), f = this.tsTryParseTypeAnnotation();
      return f && (a.typeAnnotation = f, this.resetEndLocation(a)), a;
    }
    tsInAmbientContext(a) {
      let f = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return a();
      } finally {
        this.state.isAmbientContext = f;
      }
    }
    parseClass(a, f, g) {
      let v = this.state.inAbstractClass;
      this.state.inAbstractClass = !!a.abstract;
      try {
        return super.parseClass(a, f, g);
      } finally {
        this.state.inAbstractClass = v;
      }
    }
    tsParseAbstractDeclaration(a, f) {
      if (this.match(80))
        return a.abstract = !0, this.maybeTakeDecorators(f, this.parseClass(a, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return a.abstract = !0, this.raise(fe.NonClassMethodPropertyHasAbstractModifer, a), this.tsParseInterfaceDeclaration(a);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(a, f, g, v, S, F, B) {
      let O = super.parseMethod(a, f, g, v, S, F, B);
      if (O.abstract && (this.hasPlugin("estree") ? O.value.body : O.body)) {
        let { key: I } = O;
        this.raise(fe.AbstractMethodHasImplementation, O, { methodName: I.type === "Identifier" && !O.computed ? I.name : `[${this.input.slice(I.start, I.end)}]` });
      }
      return O;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(a, f, g, v) {
      return !f && v ? (this.parseTypeOnlyImportExportSpecifier(a, !1, g), this.finishNode(a, "ExportSpecifier")) : (a.exportKind = "value", super.parseExportSpecifier(a, f, g, v));
    }
    parseImportSpecifier(a, f, g, v, S) {
      return !f && v ? (this.parseTypeOnlyImportExportSpecifier(a, !0, g), this.finishNode(a, "ImportSpecifier")) : (a.importKind = "value", super.parseImportSpecifier(a, f, g, v, g ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(a, f, g) {
      let v = f ? "imported" : "local", S = f ? "local" : "exported", F = a[v], B, O = !1, I = !0, J = F.loc.start;
      if (this.isContextual(93)) {
        let ue = this.parseIdentifier();
        if (this.isContextual(93)) {
          let ae = this.parseIdentifier();
          be(this.state.type) ? (O = !0, F = ue, B = f ? this.parseIdentifier() : this.parseModuleExportName(), I = !1) : (B = ae, I = !1);
        } else
          be(this.state.type) ? (I = !1, B = f ? this.parseIdentifier() : this.parseModuleExportName()) : (O = !0, F = ue);
      } else
        be(this.state.type) && (O = !0, f ? (F = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(F.name, F.loc.start, !0, !0)) : F = this.parseModuleExportName());
      O && g && this.raise(f ? fe.TypeModifierIsUsedInTypeImports : fe.TypeModifierIsUsedInTypeExports, J), a[v] = F, a[S] = B;
      let ne = f ? "importKind" : "exportKind";
      a[ne] = O ? "type" : "value", I && this.eatContextual(93) && (a[S] = f ? this.parseIdentifier() : this.parseModuleExportName()), a[S] || (a[S] = Rn(a[v])), f && this.checkIdentifier(a[S], O ? 4098 : 4096);
    }
  };
  function IS(c) {
    if (c.type !== "MemberExpression")
      return !1;
    let { computed: a, property: f } = c;
    return a && f.type !== "StringLiteral" && (f.type !== "TemplateLiteral" || f.expressions.length > 0) ? !1 : Xg(c.object);
  }
  function NS(c, a) {
    var f;
    let { type: g } = c;
    if ((f = c.extra) != null && f.parenthesized)
      return !1;
    if (a) {
      if (g === "Literal") {
        let { value: v } = c;
        if (typeof v == "string" || typeof v == "boolean")
          return !0;
      }
    } else if (g === "StringLiteral" || g === "BooleanLiteral")
      return !0;
    return !!(Gg(c, a) || MS(c, a) || g === "TemplateLiteral" && c.expressions.length === 0 || IS(c));
  }
  function Gg(c, a) {
    return a ? c.type === "Literal" && (typeof c.value == "number" || "bigint" in c) : c.type === "NumericLiteral" || c.type === "BigIntLiteral";
  }
  function MS(c, a) {
    if (c.type === "UnaryExpression") {
      let { operator: f, argument: g } = c;
      if (f === "-" && Gg(g, a))
        return !0;
    }
    return !1;
  }
  function Xg(c) {
    return c.type === "Identifier" ? !0 : c.type !== "MemberExpression" || c.computed ? !1 : Xg(c.object);
  }
  var Yg = A`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), OS = (c) => class extends c {
    parsePlaceholder(a) {
      if (this.match(144)) {
        let f = this.startNode();
        return this.next(), this.assertNoSpace(), f.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(f, a);
      }
    }
    finishPlaceholder(a, f) {
      let g = !!(a.expectedNode && a.type === "Placeholder");
      return a.expectedNode = f, g ? a : this.finishNode(a, "Placeholder");
    }
    getTokenFromCode(a) {
      a === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(a);
    }
    parseExprAtom(a) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(a);
    }
    parseIdentifier(a) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(a);
    }
    checkReservedWord(a, f, g, v) {
      a !== void 0 && super.checkReservedWord(a, f, g, v);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(a, f, g) {
      return a === "Placeholder" || super.isValidLVal(a, f, g);
    }
    toAssignable(a, f) {
      a && a.type === "Placeholder" && a.expectedNode === "Expression" ? a.expectedNode = "Pattern" : super.toAssignable(a, f);
    }
    chStartsBindingIdentifier(a, f) {
      return !!(super.chStartsBindingIdentifier(a, f) || this.lookahead().type === 144);
    }
    verifyBreakContinue(a, f) {
      a.label && a.label.type === "Placeholder" || super.verifyBreakContinue(a, f);
    }
    parseExpressionStatement(a, f) {
      var g;
      if (f.type !== "Placeholder" || (g = f.extra) != null && g.parenthesized)
        return super.parseExpressionStatement(a, f);
      if (this.match(14)) {
        let v = a;
        return v.label = this.finishPlaceholder(f, "Identifier"), this.next(), v.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(v, "LabeledStatement");
      }
      return this.semicolon(), a.name = f.name, this.finishPlaceholder(a, "Statement");
    }
    parseBlock(a, f, g) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(a, f, g);
    }
    parseFunctionId(a) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(a);
    }
    parseClass(a, f, g) {
      let v = f ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let S = this.state.strict, F = this.parsePlaceholder("Identifier");
      if (F)
        if (this.match(81) || this.match(144) || this.match(5))
          a.id = F;
        else {
          if (g || !f)
            return a.id = null, a.body = this.finishPlaceholder(F, "ClassBody"), this.finishNode(a, v);
          throw this.raise(Yg.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(a, f, g);
      return super.parseClassSuper(a), a.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!a.superClass, S), this.finishNode(a, v);
    }
    parseExport(a, f) {
      let g = this.parsePlaceholder("Identifier");
      if (!g)
        return super.parseExport(a, f);
      if (!this.isContextual(98) && !this.match(12))
        return a.specifiers = [], a.source = null, a.declaration = this.finishPlaceholder(g, "Declaration"), this.finishNode(a, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      let v = this.startNode();
      return v.exported = g, a.specifiers = [this.finishNode(v, "ExportDefaultSpecifier")], super.parseExport(a, f);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let a = this.nextTokenStart();
        if (this.isUnparsedContextual(a, "from") && this.input.startsWith(an(144), this.nextTokenStartSince(a + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(a, f) {
      var g;
      return (g = a.specifiers) != null && g.length ? !0 : super.maybeParseExportDefaultSpecifier(a, f);
    }
    checkExport(a) {
      let { specifiers: f } = a;
      f != null && f.length && (a.specifiers = f.filter((g) => g.exported.type === "Placeholder")), super.checkExport(a), a.specifiers = f;
    }
    parseImport(a) {
      let f = this.parsePlaceholder("Identifier");
      if (!f)
        return super.parseImport(a);
      if (a.specifiers = [], !this.isContextual(98) && !this.match(12))
        return a.source = this.finishPlaceholder(f, "StringLiteral"), this.semicolon(), this.finishNode(a, "ImportDeclaration");
      let g = this.startNodeAtNode(f);
      return g.local = f, a.specifiers.push(this.finishNode(g, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(a) || this.parseNamedImportSpecifiers(a)), this.expectContextual(98), a.source = this.parseImportSource(), this.semicolon(), this.finishNode(a, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(Yg.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, LS = (c) => class extends c {
    parseV8Intrinsic() {
      if (this.match(54)) {
        let a = this.state.startLoc, f = this.startNode();
        if (this.next(), R(this.state.type)) {
          let g = this.parseIdentifierName(), v = this.createIdentifier(f, g);
          if (v.type = "V8IntrinsicIdentifier", this.match(10))
            return v;
        }
        this.unexpected(a);
      }
    }
    parseExprAtom(a) {
      return this.parseV8Intrinsic() || super.parseExprAtom(a);
    }
  };
  function pt(c, a) {
    let [f, g] = typeof a == "string" ? [a, {}] : a, v = Object.keys(g), S = v.length === 0;
    return c.some((F) => {
      if (typeof F == "string")
        return S && F === f;
      {
        let [B, O] = F;
        if (B !== f)
          return !1;
        for (let I of v)
          if (O[I] !== g[I])
            return !1;
        return !0;
      }
    });
  }
  function li(c, a, f) {
    let g = c.find((v) => Array.isArray(v) ? v[0] === a : v === a);
    return g && Array.isArray(g) && g.length > 1 ? g[1][f] : null;
  }
  var Qg = ["minimal", "fsharp", "hack", "smart"], Zg = ["^^", "@@", "^", "%", "#"], ey = ["hash", "bar"];
  function _S(c) {
    if (pt(c, "decorators")) {
      if (pt(c, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let a = li(c, "decorators", "decoratorsBeforeExport");
      if (a != null && typeof a != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let f = li(c, "decorators", "allowCallParenthesized");
      if (f != null && typeof f != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (pt(c, "flow") && pt(c, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (pt(c, "placeholders") && pt(c, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (pt(c, "pipelineOperator")) {
      let a = li(c, "pipelineOperator", "proposal");
      if (!Qg.includes(a)) {
        let g = Qg.map((v) => `"${v}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${g}.`);
      }
      let f = pt(c, ["recordAndTuple", { syntaxType: "hash" }]);
      if (a === "hack") {
        if (pt(c, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (pt(c, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let g = li(c, "pipelineOperator", "topicToken");
        if (!Zg.includes(g)) {
          let v = Zg.map((S) => `"${S}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${v}.`);
        }
        if (g === "#" && f)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      } else if (a === "smart" && f)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (pt(c, "moduleAttributes")) {
      if (pt(c, "importAssertions") || pt(c, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (li(c, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (pt(c, "importAssertions") && pt(c, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (pt(c, "recordAndTuple") && li(c, "recordAndTuple", "syntaxType") != null && !ey.includes(li(c, "recordAndTuple", "syntaxType")))
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + ey.map((a) => `'${a}'`).join(", "));
    if (pt(c, "asyncDoExpressions") && !pt(c, "doExpressions")) {
      let a = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw a.missingPlugins = "doExpressions", a;
    }
    if (pt(c, "optionalChainingAssign") && li(c, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
  }
  var ty = { estree: T, jsx: CS, flow: vS, typescript: BS, v8intrinsic: LS, placeholders: OS }, $S = Object.keys(ty), $h = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: !1, allowReturnOutsideFunction: !1, allowNewTargetOutsideFunction: !1, allowImportExportEverywhere: !1, allowSuperOutsideMethod: !1, allowUndeclaredExports: !1, plugins: [], strictMode: null, ranges: !1, tokens: !1, createImportExpressions: !1, createParenthesizedExpressions: !1, errorRecovery: !1, attachComment: !0, annexB: !0 };
  function RS(c) {
    if (c == null)
      return Object.assign({}, $h);
    if (c.annexB != null && c.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    let a = {};
    for (let g of Object.keys($h)) {
      var f;
      a[g] = (f = c[g]) != null ? f : $h[g];
    }
    return a;
  }
  var jS = class extends SS {
    checkProto(c, a, f, g) {
      if (c.type === "SpreadElement" || this.isObjectMethod(c) || c.computed || c.shorthand)
        return;
      let v = c.key;
      if ((v.type === "Identifier" ? v.name : v.value) === "__proto__") {
        if (a) {
          this.raise(x.RecordNoProto, v);
          return;
        }
        f.used && (g ? g.doubleProtoLoc === null && (g.doubleProtoLoc = v.loc.start) : this.raise(x.DuplicateProto, v)), f.used = !0;
      }
    }
    shouldExitDescending(c, a) {
      return c.type === "ArrowFunctionExpression" && c.start === a;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let c = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), c.comments = this.comments, c.errors = this.state.errors, this.options.tokens && (c.tokens = this.tokens), c;
    }
    parseExpression(c, a) {
      return c ? this.disallowInAnd(() => this.parseExpressionBase(a)) : this.allowInAnd(() => this.parseExpressionBase(a));
    }
    parseExpressionBase(c) {
      let a = this.state.startLoc, f = this.parseMaybeAssign(c);
      if (this.match(12)) {
        let g = this.startNodeAt(a);
        for (g.expressions = [f]; this.eat(12); )
          g.expressions.push(this.parseMaybeAssign(c));
        return this.toReferencedList(g.expressions), this.finishNode(g, "SequenceExpression");
      }
      return f;
    }
    parseMaybeAssignDisallowIn(c, a) {
      return this.disallowInAnd(() => this.parseMaybeAssign(c, a));
    }
    parseMaybeAssignAllowIn(c, a) {
      return this.allowInAnd(() => this.parseMaybeAssign(c, a));
    }
    setOptionalParametersError(c, a) {
      var f;
      c.optionalParametersLoc = (f = a == null ? void 0 : a.loc) != null ? f : this.state.startLoc;
    }
    parseMaybeAssign(c, a) {
      let f = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let F = this.parseYield();
        return a && (F = a.call(this, F, f)), F;
      }
      let g;
      c ? g = !1 : (c = new Rl(), g = !0);
      let { type: v } = this.state;
      (v === 10 || R(v)) && (this.state.potentialArrowAt = this.state.start);
      let S = this.parseMaybeConditional(c);
      if (a && (S = a.call(this, S, f)), xt(this.state.type)) {
        let F = this.startNodeAt(f), B = this.state.value;
        if (F.operator = B, this.match(29)) {
          this.toAssignable(S, !0), F.left = S;
          let O = f.index;
          c.doubleProtoLoc != null && c.doubleProtoLoc.index >= O && (c.doubleProtoLoc = null), c.shorthandAssignLoc != null && c.shorthandAssignLoc.index >= O && (c.shorthandAssignLoc = null), c.privateKeyLoc != null && c.privateKeyLoc.index >= O && (this.checkDestructuringPrivate(c), c.privateKeyLoc = null);
        } else
          F.left = S;
        return this.next(), F.right = this.parseMaybeAssign(), this.checkLVal(S, { in: this.finishNode(F, "AssignmentExpression") }), F;
      } else
        g && this.checkExpressionErrors(c, !0);
      return S;
    }
    parseMaybeConditional(c) {
      let a = this.state.startLoc, f = this.state.potentialArrowAt, g = this.parseExprOps(c);
      return this.shouldExitDescending(g, f) ? g : this.parseConditional(g, a, c);
    }
    parseConditional(c, a, f) {
      if (this.eat(17)) {
        let g = this.startNodeAt(a);
        return g.test = c, g.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), g.alternate = this.parseMaybeAssign(), this.finishNode(g, "ConditionalExpression");
      }
      return c;
    }
    parseMaybeUnaryOrPrivate(c) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(c);
    }
    parseExprOps(c) {
      let a = this.state.startLoc, f = this.state.potentialArrowAt, g = this.parseMaybeUnaryOrPrivate(c);
      return this.shouldExitDescending(g, f) ? g : this.parseExprOp(g, a, -1);
    }
    parseExprOp(c, a, f) {
      if (this.isPrivateName(c)) {
        let v = this.getPrivateNameSV(c);
        (f >= Ls(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(x.PrivateInExpectedIn, c, { identifierName: v }), this.classScope.usePrivateName(v, c.loc.start);
      }
      let g = this.state.type;
      if (Er(g) && (this.prodParam.hasIn || !this.match(58))) {
        let v = Ls(g);
        if (v > f) {
          if (g === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return c;
            this.checkPipelineAtInfixOperator(c, a);
          }
          let S = this.startNodeAt(a);
          S.left = c, S.operator = this.state.value;
          let F = g === 41 || g === 42, B = g === 40;
          if (B && (v = Ls(42)), this.next(), g === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(x.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          S.right = this.parseExprOpRightExpr(g, v);
          let O = this.finishNode(S, F || B ? "LogicalExpression" : "BinaryExpression"), I = this.state.type;
          if (B && (I === 41 || I === 42) || F && I === 40)
            throw this.raise(x.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(O, a, f);
        }
      }
      return c;
    }
    parseExprOpRightExpr(c, a) {
      let f = this.state.startLoc;
      switch (c) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(x.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(c, a), f);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(a));
          }
        default:
          return this.parseExprOpBaseRightExpr(c, a);
      }
    }
    parseExprOpBaseRightExpr(c, a) {
      let f = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), f, Il(c) ? a - 1 : a);
    }
    parseHackPipeBody() {
      var c;
      let { startLoc: a } = this.state, f = this.parseMaybeAssign();
      return d.has(f.type) && !((c = f.extra) != null && c.parenthesized) && this.raise(x.PipeUnparenthesizedBody, a, { type: f.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(x.PipeTopicUnused, a), f;
    }
    checkExponentialAfterUnary(c) {
      this.match(57) && this.raise(x.UnexpectedTokenUnaryExponentiation, c.argument);
    }
    parseMaybeUnary(c, a) {
      let f = this.state.startLoc, g = this.isContextual(96);
      if (g && this.isAwaitAllowed()) {
        this.next();
        let B = this.parseAwait(f);
        return a || this.checkExponentialAfterUnary(B), B;
      }
      let v = this.match(34), S = this.startNode();
      if (si(this.state.type)) {
        S.operator = this.state.value, S.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let B = this.match(89);
        if (this.next(), S.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(c, !0), this.state.strict && B) {
          let O = S.argument;
          O.type === "Identifier" ? this.raise(x.StrictDelete, S) : this.hasPropertyAsPrivateName(O) && this.raise(x.DeletePrivateField, S);
        }
        if (!v)
          return a || this.checkExponentialAfterUnary(S), this.finishNode(S, "UnaryExpression");
      }
      let F = this.parseUpdate(S, v, c);
      if (g) {
        let { type: B } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Mt(B) : Mt(B) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(x.AwaitNotInAsyncContext, f), this.parseAwait(f);
      }
      return F;
    }
    parseUpdate(c, a, f) {
      if (a) {
        let S = c;
        return this.checkLVal(S.argument, { in: this.finishNode(S, "UpdateExpression") }), c;
      }
      let g = this.state.startLoc, v = this.parseExprSubscripts(f);
      if (this.checkExpressionErrors(f, !1))
        return v;
      for (; on(this.state.type) && !this.canInsertSemicolon(); ) {
        let S = this.startNodeAt(g);
        S.operator = this.state.value, S.prefix = !1, S.argument = v, this.next(), this.checkLVal(v, { in: v = this.finishNode(S, "UpdateExpression") });
      }
      return v;
    }
    parseExprSubscripts(c) {
      let a = this.state.startLoc, f = this.state.potentialArrowAt, g = this.parseExprAtom(c);
      return this.shouldExitDescending(g, f) ? g : this.parseSubscripts(g, a);
    }
    parseSubscripts(c, a, f) {
      let g = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(c), stop: !1 };
      do
        c = this.parseSubscript(c, a, f, g), g.maybeAsyncArrow = !1;
      while (!g.stop);
      return c;
    }
    parseSubscript(c, a, f, g) {
      let { type: v } = this.state;
      if (!f && v === 15)
        return this.parseBind(c, a, f, g);
      if (_s(v))
        return this.parseTaggedTemplateExpression(c, a, g);
      let S = !1;
      if (v === 18) {
        if (f && (this.raise(x.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return g.stop = !0, c;
        g.optionalChainMember = S = !0, this.next();
      }
      if (!f && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(c, a, g, S);
      {
        let F = this.eat(0);
        return F || S || this.eat(16) ? this.parseMember(c, a, g, F, S) : (g.stop = !0, c);
      }
    }
    parseMember(c, a, f, g, v) {
      let S = this.startNodeAt(a);
      return S.object = c, S.computed = g, g ? (S.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (c.type === "Super" && this.raise(x.SuperPrivateField, a), this.classScope.usePrivateName(this.state.value, this.state.startLoc), S.property = this.parsePrivateName()) : S.property = this.parseIdentifier(!0), f.optionalChainMember ? (S.optional = v, this.finishNode(S, "OptionalMemberExpression")) : this.finishNode(S, "MemberExpression");
    }
    parseBind(c, a, f, g) {
      let v = this.startNodeAt(a);
      return v.object = c, this.next(), v.callee = this.parseNoCallExpr(), g.stop = !0, this.parseSubscripts(this.finishNode(v, "BindExpression"), a, f);
    }
    parseCoverCallAndAsyncArrowHead(c, a, f, g) {
      let v = this.state.maybeInArrowParameters, S = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let F = this.startNodeAt(a);
      F.callee = c;
      let { maybeAsyncArrow: B, optionalChainMember: O } = f;
      B && (this.expressionScope.enter(cS()), S = new Rl()), O && (F.optional = g), g ? F.arguments = this.parseCallExpressionArguments(11) : F.arguments = this.parseCallExpressionArguments(11, c.type === "Import", c.type !== "Super", F, S);
      let I = this.finishCallExpression(F, O);
      return B && this.shouldParseAsyncArrow() && !g ? (f.stop = !0, this.checkDestructuringPrivate(S), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), I = this.parseAsyncArrowFromCallExpression(this.startNodeAt(a), I)) : (B && (this.checkExpressionErrors(S, !0), this.expressionScope.exit()), this.toReferencedArguments(I)), this.state.maybeInArrowParameters = v, I;
    }
    toReferencedArguments(c, a) {
      this.toReferencedListDeep(c.arguments, a);
    }
    parseTaggedTemplateExpression(c, a, f) {
      let g = this.startNodeAt(a);
      return g.tag = c, g.quasi = this.parseTemplate(!0), f.optionalChainMember && this.raise(x.OptionalChainingNoTemplate, a), this.finishNode(g, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(c) {
      return c.type === "Identifier" && c.name === "async" && this.state.lastTokEndLoc.index === c.end && !this.canInsertSemicolon() && c.end - c.start === 5 && c.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(c, a) {
      if (c.callee.type === "Import")
        if (c.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), c.arguments.length === 0 || c.arguments.length > 2)
          this.raise(x.ImportCallArity, c, { maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
        else
          for (let f of c.arguments)
            f.type === "SpreadElement" && this.raise(x.ImportCallSpreadArgument, f);
      return this.finishNode(c, a ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(c, a, f, g, v) {
      let S = [], F = !0, B = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(c); ) {
        if (F)
          F = !1;
        else if (this.expect(12), this.match(c)) {
          a && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(x.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), g && this.addTrailingCommaExtraToNode(g), this.next();
          break;
        }
        S.push(this.parseExprListItem(!1, v, f));
      }
      return this.state.inFSharpPipelineDirectBody = B, S;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(c, a) {
      var f;
      return this.resetPreviousNodeTrailingComments(a), this.expect(19), this.parseArrowExpression(c, a.arguments, !0, (f = a.extra) == null ? void 0 : f.trailingCommaLoc), a.innerComments && Vo(c, a.innerComments), a.callee.trailingComments && Vo(c, a.callee.trailingComments), c;
    }
    parseNoCallExpr() {
      let c = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), c, !0);
    }
    parseExprAtom(c) {
      let a, f = null, { type: g } = this.state;
      switch (g) {
        case 79:
          return this.parseSuper();
        case 83:
          return a = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(a) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(a) : this.finishNode(a, "Import") : (this.raise(x.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(a, "Import"));
        case 78:
          return a = this.startNode(), this.next(), this.finishNode(a, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let v = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(v);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, c);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, c);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          f = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(f, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          a = this.startNode(), this.next(), a.object = null;
          let v = a.callee = this.parseNoCallExpr();
          if (v.type === "MemberExpression")
            return this.finishNode(a, "BindExpression");
          throw this.raise(x.UnsupportedBind, v);
        }
        case 138:
          return this.raise(x.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let v = this.getPluginOption("pipelineOperator", "proposal");
          if (v)
            return this.parseTopicReference(v);
          this.unexpected();
          break;
        }
        case 47: {
          let v = this.input.codePointAt(this.nextTokenStart());
          Oe(v) || v === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (R(g)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let v = this.state.potentialArrowAt === this.state.start, S = this.state.containsEsc, F = this.parseIdentifier();
            if (!S && F.name === "async" && !this.canInsertSemicolon()) {
              let { type: B } = this.state;
              if (B === 68)
                return this.resetPreviousNodeTrailingComments(F), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(F));
              if (R(B))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(F)) : F;
              if (B === 90)
                return this.resetPreviousNodeTrailingComments(F), this.parseDo(this.startNodeAtNode(F), !0);
            }
            return v && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(F), [F], !1)) : F;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(c, a) {
      let f = this.getPluginOption("pipelineOperator", "proposal");
      if (f)
        return this.state.type = c, this.state.value = a, this.state.pos--, this.state.end--, this.state.endLoc = i(this.state.endLoc, -1), this.parseTopicReference(f);
      this.unexpected();
    }
    parseTopicReference(c) {
      let a = this.startNode(), f = this.state.startLoc, g = this.state.type;
      return this.next(), this.finishTopicReference(a, f, c, g);
    }
    finishTopicReference(c, a, f, g) {
      if (this.testTopicReferenceConfiguration(f, a, g)) {
        let v = f === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(f === "smart" ? x.PrimaryTopicNotAllowed : x.PipeTopicUnbound, a), this.registerTopicReference(), this.finishNode(c, v);
      } else
        throw this.raise(x.PipeTopicUnconfiguredToken, a, { token: an(g) });
    }
    testTopicReferenceConfiguration(c, a, f) {
      switch (c) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", { topicToken: an(f) }]);
        case "smart":
          return f === 27;
        default:
          throw this.raise(x.PipeTopicRequiresHackPipes, a);
      }
    }
    parseAsyncArrowUnaryFunction(c) {
      this.prodParam.enter($l(!0, this.prodParam.hasYield));
      let a = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(x.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(c, a, !0);
    }
    parseDo(c, a) {
      this.expectPlugin("doExpressions"), a && this.expectPlugin("asyncDoExpressions"), c.async = a, this.next();
      let f = this.state.labels;
      return this.state.labels = [], a ? (this.prodParam.enter(2), c.body = this.parseBlock(), this.prodParam.exit()) : c.body = this.parseBlock(), this.state.labels = f, this.finishNode(c, "DoExpression");
    }
    parseSuper() {
      let c = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(x.SuperNotAllowed, c) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(x.UnexpectedSuper, c), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(x.UnsupportedSuper, c), this.finishNode(c, "Super");
    }
    parsePrivateName() {
      let c = this.startNode(), a = this.startNodeAt(i(this.state.startLoc, 1)), f = this.state.value;
      return this.next(), c.id = this.createIdentifier(a, f), this.finishNode(c, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let c = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let a = this.createIdentifier(this.startNodeAtNode(c), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(c, a, "sent");
      }
      return this.parseFunction(c);
    }
    parseMetaProperty(c, a, f) {
      c.meta = a;
      let g = this.state.containsEsc;
      return c.property = this.parseIdentifier(!0), (c.property.name !== f || g) && this.raise(x.UnsupportedMetaProperty, c.property, { target: a.name, onlyValidPropertyName: f }), this.finishNode(c, "MetaProperty");
    }
    parseImportMetaProperty(c) {
      let a = this.createIdentifier(this.startNodeAtNode(c), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(x.ImportMetaOutsideModule, a), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let f = this.isContextual(105);
        if (f || this.unexpected(), this.expectPlugin(f ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(x.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
        return this.next(), c.phase = f ? "source" : "defer", this.parseImportCall(c);
      }
      return this.parseMetaProperty(c, a, "meta");
    }
    parseLiteralAtNode(c, a, f) {
      return this.addExtra(f, "rawValue", c), this.addExtra(f, "raw", this.input.slice(f.start, this.state.end)), f.value = c, this.next(), this.finishNode(f, a);
    }
    parseLiteral(c, a) {
      let f = this.startNode();
      return this.parseLiteralAtNode(c, a, f);
    }
    parseStringLiteral(c) {
      return this.parseLiteral(c, "StringLiteral");
    }
    parseNumericLiteral(c) {
      return this.parseLiteral(c, "NumericLiteral");
    }
    parseBigIntLiteral(c) {
      return this.parseLiteral(c, "BigIntLiteral");
    }
    parseDecimalLiteral(c) {
      return this.parseLiteral(c, "DecimalLiteral");
    }
    parseRegExpLiteral(c) {
      let a = this.parseLiteral(c.value, "RegExpLiteral");
      return a.pattern = c.pattern, a.flags = c.flags, a;
    }
    parseBooleanLiteral(c) {
      let a = this.startNode();
      return a.value = c, this.next(), this.finishNode(a, "BooleanLiteral");
    }
    parseNullLiteral() {
      let c = this.startNode();
      return this.next(), this.finishNode(c, "NullLiteral");
    }
    parseParenAndDistinguishExpression(c) {
      let a = this.state.startLoc, f;
      this.next(), this.expressionScope.enter(uS());
      let g = this.state.maybeInArrowParameters, v = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let S = this.state.startLoc, F = [], B = new Rl(), O = !0, I, J;
      for (; !this.match(11); ) {
        if (O)
          O = !1;
        else if (this.expect(12, B.optionalParametersLoc === null ? null : B.optionalParametersLoc), this.match(11)) {
          J = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let ae = this.state.startLoc;
          if (I = this.state.startLoc, F.push(this.parseParenItem(this.parseRestBinding(), ae)), !this.checkCommaAfterRest(41))
            break;
        } else
          F.push(this.parseMaybeAssignAllowIn(B, this.parseParenItem));
      }
      let ne = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = g, this.state.inFSharpPipelineDirectBody = v;
      let ue = this.startNodeAt(a);
      return c && this.shouldParseArrow(F) && (ue = this.parseArrow(ue)) ? (this.checkDestructuringPrivate(B), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(ue, F, !1), ue) : (this.expressionScope.exit(), F.length || this.unexpected(this.state.lastTokStartLoc), J && this.unexpected(J), I && this.unexpected(I), this.checkExpressionErrors(B, !0), this.toReferencedListDeep(F, !0), F.length > 1 ? (f = this.startNodeAt(S), f.expressions = F, this.finishNode(f, "SequenceExpression"), this.resetEndLocation(f, ne)) : f = F[0], this.wrapParenthesis(a, f));
    }
    wrapParenthesis(c, a) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(a, "parenthesized", !0), this.addExtra(a, "parenStart", c.index), this.takeSurroundingComments(a, c.index, this.state.lastTokEndLoc.index), a;
      let f = this.startNodeAt(c);
      return f.expression = a, this.finishNode(f, "ParenthesizedExpression");
    }
    shouldParseArrow(c) {
      return !this.canInsertSemicolon();
    }
    parseArrow(c) {
      if (this.eat(19))
        return c;
    }
    parseParenItem(c, a) {
      return c;
    }
    parseNewOrNewTarget() {
      let c = this.startNode();
      if (this.next(), this.match(16)) {
        let a = this.createIdentifier(this.startNodeAtNode(c), "new");
        this.next();
        let f = this.parseMetaProperty(c, a, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(x.UnexpectedNewTarget, f), f;
      }
      return this.parseNew(c);
    }
    parseNew(c) {
      if (this.parseNewCallee(c), this.eat(10)) {
        let a = this.parseExprList(11);
        this.toReferencedList(a), c.arguments = a;
      } else
        c.arguments = [];
      return this.finishNode(c, "NewExpression");
    }
    parseNewCallee(c) {
      let a = this.match(83), f = this.parseNoCallExpr();
      c.callee = f, a && (f.type === "Import" || f.type === "ImportExpression") && this.raise(x.ImportCallNotNewExpression, f);
    }
    parseTemplateElement(c) {
      let { start: a, startLoc: f, end: g, value: v } = this.state, S = a + 1, F = this.startNodeAt(i(f, 1));
      v === null && (c || this.raise(x.InvalidEscapeSequenceTemplate, i(this.state.firstInvalidTemplateEscapePos, 1)));
      let B = this.match(24), O = B ? -1 : -2, I = g + O;
      F.value = { raw: this.input.slice(S, I).replace(/\r\n?/g, `
`), cooked: v === null ? null : v.slice(1, O) }, F.tail = B, this.next();
      let J = this.finishNode(F, "TemplateElement");
      return this.resetEndLocation(J, i(this.state.lastTokEndLoc, O)), J;
    }
    parseTemplate(c) {
      let a = this.startNode();
      a.expressions = [];
      let f = this.parseTemplateElement(c);
      for (a.quasis = [f]; !f.tail; )
        a.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), a.quasis.push(f = this.parseTemplateElement(c));
      return this.finishNode(a, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(c, a, f, g) {
      f && this.expectPlugin("recordAndTuple");
      let v = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let S = /* @__PURE__ */ Object.create(null), F = !0, B = this.startNode();
      for (B.properties = [], this.next(); !this.match(c); ) {
        if (F)
          F = !1;
        else if (this.expect(12), this.match(c)) {
          this.addTrailingCommaExtraToNode(B);
          break;
        }
        let I;
        a ? I = this.parseBindingProperty() : (I = this.parsePropertyDefinition(g), this.checkProto(I, f, S, g)), f && !this.isObjectProperty(I) && I.type !== "SpreadElement" && this.raise(x.InvalidRecordProperty, I), I.shorthand && this.addExtra(I, "shorthand", !0), B.properties.push(I);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = v;
      let O = "ObjectExpression";
      return a ? O = "ObjectPattern" : f && (O = "RecordExpression"), this.finishNode(B, O);
    }
    addTrailingCommaExtraToNode(c) {
      this.addExtra(c, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(c, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(c) {
      return !c.computed && c.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(c) {
      let a = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(x.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          a.push(this.parseDecorator());
      let f = this.startNode(), g = !1, v = !1, S;
      if (this.match(21))
        return a.length && this.unexpected(), this.parseSpread();
      a.length && (f.decorators = a, a = []), f.method = !1, c && (S = this.state.startLoc);
      let F = this.eat(55);
      this.parsePropertyNamePrefixOperator(f);
      let B = this.state.containsEsc, O = this.parsePropertyName(f, c);
      if (!F && !B && this.maybeAsyncOrAccessorProp(f)) {
        let I = O.name;
        I === "async" && !this.hasPrecedingLineBreak() && (g = !0, this.resetPreviousNodeTrailingComments(O), F = this.eat(55), this.parsePropertyName(f)), (I === "get" || I === "set") && (v = !0, this.resetPreviousNodeTrailingComments(O), f.kind = I, this.match(55) && (F = !0, this.raise(x.AccessorIsGenerator, this.state.curPosition(), { kind: I }), this.next()), this.parsePropertyName(f));
      }
      return this.parseObjPropValue(f, S, F, g, !1, v, c);
    }
    getGetterSetterExpectedParamCount(c) {
      return c.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(c) {
      return c.params;
    }
    checkGetterSetterParams(c) {
      var a;
      let f = this.getGetterSetterExpectedParamCount(c), g = this.getObjectOrClassMethodParams(c);
      g.length !== f && this.raise(c.kind === "get" ? x.BadGetterArity : x.BadSetterArity, c), c.kind === "set" && ((a = g[g.length - 1]) == null ? void 0 : a.type) === "RestElement" && this.raise(x.BadSetterRestParameter, c);
    }
    parseObjectMethod(c, a, f, g, v) {
      if (v) {
        let S = this.parseMethod(c, a, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(S), S;
      }
      if (f || a || this.match(10))
        return g && this.unexpected(), c.kind = "method", c.method = !0, this.parseMethod(c, a, f, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(c, a, f, g) {
      if (c.shorthand = !1, this.eat(14))
        return c.value = f ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(g), this.finishNode(c, "ObjectProperty");
      if (!c.computed && c.key.type === "Identifier") {
        if (this.checkReservedWord(c.key.name, c.key.loc.start, !0, !1), f)
          c.value = this.parseMaybeDefault(a, Rn(c.key));
        else if (this.match(29)) {
          let v = this.state.startLoc;
          g != null ? g.shorthandAssignLoc === null && (g.shorthandAssignLoc = v) : this.raise(x.InvalidCoverInitializedName, v), c.value = this.parseMaybeDefault(a, Rn(c.key));
        } else
          c.value = Rn(c.key);
        return c.shorthand = !0, this.finishNode(c, "ObjectProperty");
      }
    }
    parseObjPropValue(c, a, f, g, v, S, F) {
      let B = this.parseObjectMethod(c, f, g, v, S) || this.parseObjectProperty(c, a, v, F);
      return B || this.unexpected(), B;
    }
    parsePropertyName(c, a) {
      if (this.eat(0))
        c.computed = !0, c.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let { type: f, value: g } = this.state, v;
        if (be(f))
          v = this.parseIdentifier(!0);
        else
          switch (f) {
            case 134:
              v = this.parseNumericLiteral(g);
              break;
            case 133:
              v = this.parseStringLiteral(g);
              break;
            case 135:
              v = this.parseBigIntLiteral(g);
              break;
            case 136:
              v = this.parseDecimalLiteral(g);
              break;
            case 138: {
              let S = this.state.startLoc;
              a != null ? a.privateKeyLoc === null && (a.privateKeyLoc = S) : this.raise(x.UnexpectedPrivateField, S), v = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        c.key = v, f !== 138 && (c.computed = !1);
      }
      return c.key;
    }
    initFunction(c, a) {
      c.id = null, c.generator = !1, c.async = a;
    }
    parseMethod(c, a, f, g, v, S, F = !1) {
      this.initFunction(c, f), c.generator = a, this.scope.enter(18 | (F ? 64 : 0) | (v ? 32 : 0)), this.prodParam.enter($l(f, c.generator)), this.parseFunctionParams(c, g);
      let B = this.parseFunctionBodyAndFinish(c, S, !0);
      return this.prodParam.exit(), this.scope.exit(), B;
    }
    parseArrayLike(c, a, f, g) {
      f && this.expectPlugin("recordAndTuple");
      let v = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let S = this.startNode();
      return this.next(), S.elements = this.parseExprList(c, !f, g, S), this.state.inFSharpPipelineDirectBody = v, this.finishNode(S, f ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(c, a, f, g) {
      this.scope.enter(6);
      let v = $l(f, !1);
      !this.match(5) && this.prodParam.hasIn && (v |= 8), this.prodParam.enter(v), this.initFunction(c, f);
      let S = this.state.maybeInArrowParameters;
      return a && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(c, a, g)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(c, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = S, this.finishNode(c, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(c, a, f) {
      this.toAssignableList(a, f, !1), c.params = a;
    }
    parseFunctionBodyAndFinish(c, a, f = !1) {
      return this.parseFunctionBody(c, !1, f), this.finishNode(c, a);
    }
    parseFunctionBody(c, a, f = !1) {
      let g = a && !this.match(5);
      if (this.expressionScope.enter(Hg()), g)
        c.body = this.parseMaybeAssign(), this.checkParams(c, !1, a, !1);
      else {
        let v = this.state.strict, S = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), c.body = this.parseBlock(!0, !1, (F) => {
          let B = !this.isSimpleParamList(c.params);
          F && B && this.raise(x.IllegalLanguageModeDirective, (c.kind === "method" || c.kind === "constructor") && c.key ? c.key.loc.end : c);
          let O = !v && this.state.strict;
          this.checkParams(c, !this.state.strict && !a && !f && !B, a, O), this.state.strict && c.id && this.checkIdentifier(c.id, 65, O);
        }), this.prodParam.exit(), this.state.labels = S;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(c) {
      return c.type === "Identifier";
    }
    isSimpleParamList(c) {
      for (let a = 0, f = c.length; a < f; a++)
        if (!this.isSimpleParameter(c[a]))
          return !1;
      return !0;
    }
    checkParams(c, a, f, g = !0) {
      let v = !a && /* @__PURE__ */ new Set(), S = { type: "FormalParameters" };
      for (let F of c.params)
        this.checkLVal(F, { in: S, binding: 5, checkClashes: v, strictModeChanged: g });
    }
    parseExprList(c, a, f, g) {
      let v = [], S = !0;
      for (; !this.eat(c); ) {
        if (S)
          S = !1;
        else if (this.expect(12), this.match(c)) {
          g && this.addTrailingCommaExtraToNode(g), this.next();
          break;
        }
        v.push(this.parseExprListItem(a, f));
      }
      return v;
    }
    parseExprListItem(c, a, f) {
      let g;
      if (this.match(12))
        c || this.raise(x.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), g = null;
      else if (this.match(21)) {
        let v = this.state.startLoc;
        g = this.parseParenItem(this.parseSpread(a), v);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), f || this.raise(x.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let v = this.startNode();
        this.next(), g = this.finishNode(v, "ArgumentPlaceholder");
      } else
        g = this.parseMaybeAssignAllowIn(a, this.parseParenItem);
      return g;
    }
    parseIdentifier(c) {
      let a = this.startNode(), f = this.parseIdentifierName(c);
      return this.createIdentifier(a, f);
    }
    createIdentifier(c, a) {
      return c.name = a, c.loc.identifierName = a, this.finishNode(c, "Identifier");
    }
    parseIdentifierName(c) {
      let a, { startLoc: f, type: g } = this.state;
      be(g) ? a = this.state.value : this.unexpected();
      let v = Ce(g);
      return c ? v && this.replaceToken(132) : this.checkReservedWord(a, f, v, !1), this.next(), a;
    }
    checkReservedWord(c, a, f, g) {
      if (!(c.length > 10 || !zw(c))) {
        if (f && Uw(c)) {
          this.raise(x.UnexpectedKeyword, a, { keyword: c });
          return;
        }
        if ((this.state.strict ? g ? Og : $s : $n)(c, this.inModule)) {
          this.raise(x.UnexpectedReservedWord, a, { reservedWord: c });
          return;
        } else if (c === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(x.YieldBindingIdentifier, a);
            return;
          }
        } else if (c === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(x.AwaitBindingIdentifier, a);
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(x.AwaitBindingIdentifierInStaticBlock, a);
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError(a);
        } else if (c === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(x.ArgumentsInClass, a);
          return;
        }
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(c) {
      let a = this.startNodeAt(c);
      return this.expressionScope.recordParameterInitializerError(x.AwaitExpressionFormalParameter, a), this.eat(55) && this.raise(x.ObsoleteAwaitStar, a), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (a.argument = this.parseMaybeUnary(null, !0)), this.finishNode(a, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak())
        return !0;
      let { type: c } = this.state;
      return c === 53 || c === 10 || c === 0 || _s(c) || c === 102 && !this.state.containsEsc || c === 137 || c === 56 || this.hasPlugin("v8intrinsic") && c === 54;
    }
    parseYield() {
      let c = this.startNode();
      this.expressionScope.recordParameterInitializerError(x.YieldInParameter, c), this.next();
      let a = !1, f = null;
      if (!this.hasPrecedingLineBreak())
        switch (a = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!a)
              break;
          default:
            f = this.parseMaybeAssign();
        }
      return c.delegate = a, c.argument = f, this.finishNode(c, "YieldExpression");
    }
    parseImportCall(c) {
      return this.next(), c.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (c.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (c.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(c, "ImportExpression");
    }
    checkPipelineAtInfixOperator(c, a) {
      this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && c.type === "SequenceExpression" && this.raise(x.PipelineHeadSequenceExpression, a);
    }
    parseSmartPipelineBodyInStyle(c, a) {
      if (this.isSimpleReference(c)) {
        let f = this.startNodeAt(a);
        return f.callee = c, this.finishNode(f, "PipelineBareFunction");
      } else {
        let f = this.startNodeAt(a);
        return this.checkSmartPipeTopicBodyEarlyErrors(a), f.expression = c, this.finishNode(f, "PipelineTopicExpression");
      }
    }
    isSimpleReference(c) {
      switch (c.type) {
        case "MemberExpression":
          return !c.computed && this.isSimpleReference(c.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(c) {
      if (this.match(19))
        throw this.raise(x.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(x.PipelineTopicUnused, c);
    }
    withTopicBindingContext(c) {
      let a = this.state.topicContext;
      this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
      try {
        return c();
      } finally {
        this.state.topicContext = a;
      }
    }
    withSmartMixTopicForbiddingContext(c) {
      if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
        let a = this.state.topicContext;
        this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
        try {
          return c();
        } finally {
          this.state.topicContext = a;
        }
      } else
        return c();
    }
    withSoloAwaitPermittingContext(c) {
      let a = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return c();
      } finally {
        this.state.soloAwait = a;
      }
    }
    allowInAnd(c) {
      let a = this.prodParam.currentFlags();
      if (8 & ~a) {
        this.prodParam.enter(a | 8);
        try {
          return c();
        } finally {
          this.prodParam.exit();
        }
      }
      return c();
    }
    disallowInAnd(c) {
      let a = this.prodParam.currentFlags();
      if (8 & a) {
        this.prodParam.enter(a & -9);
        try {
          return c();
        } finally {
          this.prodParam.exit();
        }
      }
      return c();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(c) {
      let a = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let f = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let g = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), a, c);
      return this.state.inFSharpPipelineDirectBody = f, g;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let c = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let a = this.startNodeAt(this.state.endLoc);
      this.next();
      let f = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        c.body = this.parseProgram(a, 8, "module");
      } finally {
        f();
      }
      return this.finishNode(c, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(c) {
    }
  }, Rh = { kind: 1 }, qS = { kind: 2 }, WS = /[\uD800-\uDFFF]/u, jh = /in(?:stanceof)?/y;
  function US(c, a) {
    for (let f = 0; f < c.length; f++) {
      let g = c[f], { type: v } = g;
      if (typeof v == "number") {
        {
          if (v === 138) {
            let { loc: S, start: F, value: B, end: O } = g, I = F + 1, J = i(S.start, 1);
            c.splice(f, 1, new oi({ type: Hr(27), value: "#", start: F, end: I, startLoc: S.start, endLoc: J }), new oi({ type: Hr(132), value: B, start: I, end: O, startLoc: J, endLoc: S.end })), f++;
            continue;
          }
          if (_s(v)) {
            let { loc: S, start: F, value: B, end: O } = g, I = F + 1, J = i(S.start, 1), ne;
            a.charCodeAt(F) === 96 ? ne = new oi({ type: Hr(22), value: "`", start: F, end: I, startLoc: S.start, endLoc: J }) : ne = new oi({ type: Hr(8), value: "}", start: F, end: I, startLoc: S.start, endLoc: J });
            let ue, ae, Ve, He;
            v === 24 ? (ae = O - 1, Ve = i(S.end, -1), ue = B === null ? null : B.slice(1, -1), He = new oi({ type: Hr(22), value: "`", start: ae, end: O, startLoc: Ve, endLoc: S.end })) : (ae = O - 2, Ve = i(S.end, -2), ue = B === null ? null : B.slice(1, -2), He = new oi({ type: Hr(23), value: "${", start: ae, end: O, startLoc: Ve, endLoc: S.end })), c.splice(f, 1, ne, new oi({ type: Hr(20), value: ue, start: I, end: ae, startLoc: J, endLoc: Ve }), He), f += 2;
            continue;
          }
        }
        g.type = Hr(v);
      }
    }
    return c;
  }
  var HS = class extends jS {
    parseTopLevel(c, a) {
      return c.program = this.parseProgram(a), c.comments = this.comments, this.options.tokens && (c.tokens = US(this.tokens, this.input)), this.finishNode(c, "File");
    }
    parseProgram(c, a = 139, f = this.options.sourceType) {
      if (c.sourceType = f, c.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(c, !0, !0, a), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [v, S] of Array.from(this.scope.undefinedExports))
          this.raise(x.ModuleExportUndefined, S, { localName: v });
      let g;
      return a === 139 ? g = this.finishNode(c, "Program") : g = this.finishNodeAt(c, "Program", i(this.state.startLoc, -1)), g;
    }
    stmtToDirective(c) {
      let a = c;
      a.type = "Directive", a.value = a.expression, delete a.expression;
      let f = a.value, g = f.value, v = this.input.slice(f.start, f.end), S = f.value = v.slice(1, -1);
      return this.addExtra(f, "raw", v), this.addExtra(f, "rawValue", S), this.addExtra(f, "expressionValue", g), f.type = "DirectiveLiteral", a;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let c = this.startNode();
      return c.value = this.state.value, this.next(), this.finishNode(c, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(c, a) {
      if (Oe(c)) {
        if (jh.lastIndex = a, jh.test(this.input)) {
          let f = this.codePointAtPos(jh.lastIndex);
          if (!Be(f) && f !== 92)
            return !1;
        }
        return !0;
      } else
        return c === 92;
    }
    chStartsBindingPattern(c) {
      return c === 91 || c === 123;
    }
    hasFollowingBindingAtom() {
      let c = this.nextTokenStart(), a = this.codePointAtPos(c);
      return this.chStartsBindingPattern(a) || this.chStartsBindingIdentifier(a, c);
    }
    hasInLineFollowingBindingIdentifier() {
      let c = this.nextTokenInLineStart(), a = this.codePointAtPos(c);
      return this.chStartsBindingIdentifier(a, c);
    }
    startsUsingForOf() {
      let { type: c, containsEsc: a } = this.lookahead();
      if (c === 102 && !a)
        return !1;
      if (R(c) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let c = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(c, "using")) {
        c = this.nextTokenInLineStartSince(c + 5);
        let a = this.codePointAtPos(c);
        if (this.chStartsBindingIdentifier(a, c))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(c = !1) {
      let a = 0;
      return this.options.annexB && !this.state.strict && (a |= 4, c && (a |= 8)), this.parseStatementLike(a);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(c) {
      let a = null;
      return this.match(26) && (a = this.parseDecorators(!0)), this.parseStatementContent(c, a);
    }
    parseStatementContent(c, a) {
      let f = this.state.type, g = this.startNode(), v = !!(c & 2), S = !!(c & 4), F = c & 1;
      switch (f) {
        case 60:
          return this.parseBreakContinueStatement(g, !0);
        case 63:
          return this.parseBreakContinueStatement(g, !1);
        case 64:
          return this.parseDebuggerStatement(g);
        case 90:
          return this.parseDoWhileStatement(g);
        case 91:
          return this.parseForStatement(g);
        case 68:
          if (this.lookaheadCharCode() === 46)
            break;
          return S || this.raise(this.state.strict ? x.StrictFunction : this.options.annexB ? x.SloppyFunctionAnnexB : x.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(g, !1, !v && S);
        case 80:
          return v || this.unexpected(), this.parseClass(this.maybeTakeDecorators(a, g), !0);
        case 69:
          return this.parseIfStatement(g);
        case 70:
          return this.parseReturnStatement(g);
        case 71:
          return this.parseSwitchStatement(g);
        case 72:
          return this.parseThrowStatement(g);
        case 73:
          return this.parseTryStatement(g);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.isAwaitAllowed() ? v || this.raise(x.UnexpectedLexicalDeclaration, g) : this.raise(x.AwaitUsingNotInAsyncContext, g), this.next(), this.parseVarStatement(g, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(x.UnexpectedUsingDeclaration, this.state.startLoc) : v || this.raise(x.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(g, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let I = this.nextTokenStart(), J = this.codePointAtPos(I);
          if (J !== 91 && (!v && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(J, I) && J !== 123))
            break;
        }
        case 75:
          v || this.raise(x.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let I = this.state.value;
          return this.parseVarStatement(g, I);
        }
        case 92:
          return this.parseWhileStatement(g);
        case 76:
          return this.parseWithStatement(g);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(g);
        case 83: {
          let I = this.lookaheadCharCode();
          if (I === 40 || I === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !F && this.raise(x.UnexpectedImportExport, this.state.startLoc), this.next();
          let I;
          return f === 83 ? (I = this.parseImport(g), I.type === "ImportDeclaration" && (!I.importKind || I.importKind === "value") && (this.sawUnambiguousESM = !0)) : (I = this.parseExport(g, a), (I.type === "ExportNamedDeclaration" && (!I.exportKind || I.exportKind === "value") || I.type === "ExportAllDeclaration" && (!I.exportKind || I.exportKind === "value") || I.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(I), I;
        }
        default:
          if (this.isAsyncFunction())
            return v || this.raise(x.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(g, !0, !v && S);
      }
      let B = this.state.value, O = this.parseExpression();
      return R(f) && O.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(g, B, O, c) : this.parseExpressionStatement(g, O, a);
    }
    assertModuleNodeAllowed(c) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(x.ImportOutsideModule, c);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
    }
    maybeTakeDecorators(c, a, f) {
      return c && (a.decorators && a.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(x.DecoratorsBeforeAfterExport, a.decorators[0]), a.decorators.unshift(...c)) : a.decorators = c, this.resetStartLocationFromNode(a, c[0]), f && this.resetStartLocationFromNode(f, a)), a;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(c) {
      let a = [];
      do
        a.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        c || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(x.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(x.UnexpectedLeadingDecorator, this.state.startLoc);
      return a;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let c = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let a = this.state.startLoc, f;
        if (this.match(10)) {
          let g = this.state.startLoc;
          this.next(), f = this.parseExpression(), this.expect(11), f = this.wrapParenthesis(g, f);
          let v = this.state.startLoc;
          c.expression = this.parseMaybeDecoratorArguments(f), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && c.expression !== f && this.raise(x.DecoratorArgumentsOutsideParentheses, v);
        } else {
          for (f = this.parseIdentifier(!1); this.eat(16); ) {
            let g = this.startNodeAt(a);
            g.object = f, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), g.property = this.parsePrivateName()) : g.property = this.parseIdentifier(!0), g.computed = !1, f = this.finishNode(g, "MemberExpression");
          }
          c.expression = this.parseMaybeDecoratorArguments(f);
        }
      } else
        c.expression = this.parseExprSubscripts();
      return this.finishNode(c, "Decorator");
    }
    parseMaybeDecoratorArguments(c) {
      if (this.eat(10)) {
        let a = this.startNodeAtNode(c);
        return a.callee = c, a.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(a.arguments), this.finishNode(a, "CallExpression");
      }
      return c;
    }
    parseBreakContinueStatement(c, a) {
      return this.next(), this.isLineTerminator() ? c.label = null : (c.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(c, a), this.finishNode(c, a ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(c, a) {
      let f;
      for (f = 0; f < this.state.labels.length; ++f) {
        let g = this.state.labels[f];
        if ((c.label == null || g.name === c.label.name) && (g.kind != null && (a || g.kind === 1) || c.label && a))
          break;
      }
      if (f === this.state.labels.length) {
        let g = a ? "BreakStatement" : "ContinueStatement";
        this.raise(x.IllegalBreakContinue, c, { type: g });
      }
    }
    parseDebuggerStatement(c) {
      return this.next(), this.semicolon(), this.finishNode(c, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let c = this.parseExpression();
      return this.expect(11), c;
    }
    parseDoWhileStatement(c) {
      return this.next(), this.state.labels.push(Rh), c.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), c.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(c, "DoWhileStatement");
    }
    parseForStatement(c) {
      this.next(), this.state.labels.push(Rh);
      let a = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (a = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
        return a !== null && this.unexpected(a), this.parseFor(c, null);
      let f = this.isContextual(100);
      {
        let B = this.isContextual(96) && this.startsAwaitUsing(), O = B || this.isContextual(107) && this.startsUsingForOf(), I = f && this.hasFollowingBindingAtom() || O;
        if (this.match(74) || this.match(75) || I) {
          let J = this.startNode(), ne;
          B ? (ne = "await using", this.isAwaitAllowed() || this.raise(x.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : ne = this.state.value, this.next(), this.parseVar(J, !0, ne);
          let ue = this.finishNode(J, "VariableDeclaration"), ae = this.match(58);
          return ae && O && this.raise(x.ForInUsing, ue), (ae || this.isContextual(102)) && ue.declarations.length === 1 ? this.parseForIn(c, ue, a) : (a !== null && this.unexpected(a), this.parseFor(c, ue));
        }
      }
      let g = this.isContextual(95), v = new Rl(), S = this.parseExpression(!0, v), F = this.isContextual(102);
      if (F && (f && this.raise(x.ForOfLet, S), a === null && g && S.type === "Identifier" && this.raise(x.ForOfAsync, S)), F || this.match(58)) {
        this.checkDestructuringPrivate(v), this.toAssignable(S, !0);
        let B = F ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(S, { in: { type: B } }), this.parseForIn(c, S, a);
      } else
        this.checkExpressionErrors(v, !0);
      return a !== null && this.unexpected(a), this.parseFor(c, S);
    }
    parseFunctionStatement(c, a, f) {
      return this.next(), this.parseFunction(c, 1 | (f ? 2 : 0) | (a ? 8 : 0));
    }
    parseIfStatement(c) {
      return this.next(), c.test = this.parseHeaderExpression(), c.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), c.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(c, "IfStatement");
    }
    parseReturnStatement(c) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(x.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? c.argument = null : (c.argument = this.parseExpression(), this.semicolon()), this.finishNode(c, "ReturnStatement");
    }
    parseSwitchStatement(c) {
      this.next(), c.discriminant = this.parseHeaderExpression();
      let a = c.cases = [];
      this.expect(5), this.state.labels.push(qS), this.scope.enter(0);
      let f;
      for (let g; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let v = this.match(61);
          f && this.finishNode(f, "SwitchCase"), a.push(f = this.startNode()), f.consequent = [], this.next(), v ? f.test = this.parseExpression() : (g && this.raise(x.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), g = !0, f.test = null), this.expect(14);
        } else
          f ? f.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), f && this.finishNode(f, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(c, "SwitchStatement");
    }
    parseThrowStatement(c) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(x.NewlineAfterThrow, this.state.lastTokEndLoc), c.argument = this.parseExpression(), this.semicolon(), this.finishNode(c, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let c = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && c.type === "Identifier" ? 8 : 0), this.checkLVal(c, { in: { type: "CatchClause" }, binding: 9 }), c;
    }
    parseTryStatement(c) {
      if (this.next(), c.block = this.parseBlock(), c.handler = null, this.match(62)) {
        let a = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), a.param = this.parseCatchClauseParam(), this.expect(11)) : (a.param = null, this.scope.enter(0)), a.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), c.handler = this.finishNode(a, "CatchClause");
      }
      return c.finalizer = this.eat(67) ? this.parseBlock() : null, !c.handler && !c.finalizer && this.raise(x.NoCatchOrFinally, c), this.finishNode(c, "TryStatement");
    }
    parseVarStatement(c, a, f = !1) {
      return this.next(), this.parseVar(c, !1, a, f), this.semicolon(), this.finishNode(c, "VariableDeclaration");
    }
    parseWhileStatement(c) {
      return this.next(), c.test = this.parseHeaderExpression(), this.state.labels.push(Rh), c.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(c, "WhileStatement");
    }
    parseWithStatement(c) {
      return this.state.strict && this.raise(x.StrictWith, this.state.startLoc), this.next(), c.object = this.parseHeaderExpression(), c.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(c, "WithStatement");
    }
    parseEmptyStatement(c) {
      return this.next(), this.finishNode(c, "EmptyStatement");
    }
    parseLabeledStatement(c, a, f, g) {
      for (let S of this.state.labels)
        S.name === a && this.raise(x.LabelRedeclaration, f, { labelName: a });
      let v = ii(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let S = this.state.labels.length - 1; S >= 0; S--) {
        let F = this.state.labels[S];
        if (F.statementStart === c.start)
          F.statementStart = this.state.start, F.kind = v;
        else
          break;
      }
      return this.state.labels.push({ name: a, kind: v, statementStart: this.state.start }), c.body = g & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), c.label = f, this.finishNode(c, "LabeledStatement");
    }
    parseExpressionStatement(c, a, f) {
      return c.expression = a, this.semicolon(), this.finishNode(c, "ExpressionStatement");
    }
    parseBlock(c = !1, a = !0, f) {
      let g = this.startNode();
      return c && this.state.strictErrors.clear(), this.expect(5), a && this.scope.enter(0), this.parseBlockBody(g, c, !1, 8, f), a && this.scope.exit(), this.finishNode(g, "BlockStatement");
    }
    isValidDirective(c) {
      return c.type === "ExpressionStatement" && c.expression.type === "StringLiteral" && !c.expression.extra.parenthesized;
    }
    parseBlockBody(c, a, f, g, v) {
      let S = c.body = [], F = c.directives = [];
      this.parseBlockOrModuleBlockBody(S, a ? F : void 0, f, g, v);
    }
    parseBlockOrModuleBlockBody(c, a, f, g, v) {
      let S = this.state.strict, F = !1, B = !1;
      for (; !this.match(g); ) {
        let O = f ? this.parseModuleItem() : this.parseStatementListItem();
        if (a && !B) {
          if (this.isValidDirective(O)) {
            let I = this.stmtToDirective(O);
            a.push(I), !F && I.value.value === "use strict" && (F = !0, this.setStrict(!0));
            continue;
          }
          B = !0, this.state.strictErrors.clear();
        }
        c.push(O);
      }
      v == null || v.call(this, F), S || this.setStrict(!1), this.next();
    }
    parseFor(c, a) {
      return c.init = a, this.semicolon(!1), c.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), c.update = this.match(11) ? null : this.parseExpression(), this.expect(11), c.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(c, "ForStatement");
    }
    parseForIn(c, a, f) {
      let g = this.match(58);
      return this.next(), g ? f !== null && this.unexpected(f) : c.await = f !== null, a.type === "VariableDeclaration" && a.declarations[0].init != null && (!g || !this.options.annexB || this.state.strict || a.kind !== "var" || a.declarations[0].id.type !== "Identifier") && this.raise(x.ForInOfLoopInitializer, a, { type: g ? "ForInStatement" : "ForOfStatement" }), a.type === "AssignmentPattern" && this.raise(x.InvalidLhs, a, { ancestor: { type: "ForStatement" } }), c.left = a, c.right = g ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), c.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(c, g ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(c, a, f, g = !1) {
      let v = c.declarations = [];
      for (c.kind = f; ; ) {
        let S = this.startNode();
        if (this.parseVarId(S, f), S.init = this.eat(29) ? a ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, S.init === null && !g && (S.id.type !== "Identifier" && !(a && (this.match(58) || this.isContextual(102))) ? this.raise(x.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" }) : f === "const" && !(this.match(58) || this.isContextual(102)) && this.raise(x.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "const" })), v.push(this.finishNode(S, "VariableDeclarator")), !this.eat(12))
          break;
      }
      return c;
    }
    parseVarId(c, a) {
      let f = this.parseBindingAtom();
      this.checkLVal(f, { in: { type: "VariableDeclarator" }, binding: a === "var" ? 5 : 8201 }), c.id = f;
    }
    parseAsyncFunctionExpression(c) {
      return this.parseFunction(c, 8);
    }
    parseFunction(c, a = 0) {
      let f = a & 2, g = !!(a & 1), v = g && !(a & 4), S = !!(a & 8);
      this.initFunction(c, S), this.match(55) && (f && this.raise(x.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), c.generator = !0), g && (c.id = this.parseFunctionId(v));
      let F = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter($l(S, c.generator)), g || (c.id = this.parseFunctionId()), this.parseFunctionParams(c, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(c, g ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), g && !f && this.registerFunctionStatementId(c), this.state.maybeInArrowParameters = F, c;
    }
    parseFunctionId(c) {
      return c || R(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(c, a) {
      this.expect(10), this.expressionScope.enter(lS()), c.params = this.parseBindingList(11, 41, 2 | (a ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(c) {
      c.id && this.scope.declareName(c.id.name, !this.options.annexB || this.state.strict || c.generator || c.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, c.id.loc.start);
    }
    parseClass(c, a, f) {
      this.next();
      let g = this.state.strict;
      return this.state.strict = !0, this.parseClassId(c, a, f), this.parseClassSuper(c), c.body = this.parseClassBody(!!c.superClass, g), this.finishNode(c, a ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(c) {
      return !c.computed && !c.static && (c.key.name === "constructor" || c.key.value === "constructor");
    }
    parseClassBody(c, a) {
      this.classScope.enter();
      let f = { hadConstructor: !1, hadSuperClass: c }, g = [], v = this.startNode();
      if (v.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (g.length > 0)
              throw this.raise(x.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            g.push(this.parseDecorator());
            continue;
          }
          let S = this.startNode();
          g.length && (S.decorators = g, this.resetStartLocationFromNode(S, g[0]), g = []), this.parseClassMember(v, S, f), S.kind === "constructor" && S.decorators && S.decorators.length > 0 && this.raise(x.DecoratorConstructor, S);
        }
      }), this.state.strict = a, this.next(), g.length)
        throw this.raise(x.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(v, "ClassBody");
    }
    parseClassMemberFromModifier(c, a) {
      let f = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let g = a;
        return g.kind = "method", g.computed = !1, g.key = f, g.static = !1, this.pushClassMethod(c, g, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let g = a;
        return g.computed = !1, g.key = f, g.static = !1, c.body.push(this.parseClassProperty(g)), !0;
      }
      return this.resetPreviousNodeTrailingComments(f), !1;
    }
    parseClassMember(c, a, f) {
      let g = this.isContextual(106);
      if (g) {
        if (this.parseClassMemberFromModifier(c, a))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(c, a);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(c, a, f, g);
    }
    parseClassMemberWithIsStatic(c, a, f, g) {
      let v = a, S = a, F = a, B = a, O = a, I = v, J = v;
      if (a.static = g, this.parsePropertyNamePrefixOperator(a), this.eat(55)) {
        I.kind = "method";
        let He = this.match(138);
        if (this.parseClassElementName(I), He) {
          this.pushClassPrivateMethod(c, S, !0, !1);
          return;
        }
        this.isNonstaticConstructor(v) && this.raise(x.ConstructorIsGenerator, v.key), this.pushClassMethod(c, v, !0, !1, !1, !1);
        return;
      }
      let ne = R(this.state.type) && !this.state.containsEsc, ue = this.match(138), ae = this.parseClassElementName(a), Ve = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(J), this.isClassMethod()) {
        if (I.kind = "method", ue) {
          this.pushClassPrivateMethod(c, S, !1, !1);
          return;
        }
        let He = this.isNonstaticConstructor(v), dt = !1;
        He && (v.kind = "constructor", f.hadConstructor && !this.hasPlugin("typescript") && this.raise(x.DuplicateConstructor, ae), He && this.hasPlugin("typescript") && a.override && this.raise(x.OverrideOnConstructor, ae), f.hadConstructor = !0, dt = f.hadSuperClass), this.pushClassMethod(c, v, !1, !1, He, dt);
      } else if (this.isClassProperty())
        ue ? this.pushClassPrivateProperty(c, B) : this.pushClassProperty(c, F);
      else if (ne && ae.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(ae);
        let He = this.eat(55);
        J.optional && this.unexpected(Ve), I.kind = "method";
        let dt = this.match(138);
        this.parseClassElementName(I), this.parsePostMemberNameModifiers(J), dt ? this.pushClassPrivateMethod(c, S, He, !0) : (this.isNonstaticConstructor(v) && this.raise(x.ConstructorIsAsync, v.key), this.pushClassMethod(c, v, He, !0, !1, !1));
      } else if (ne && (ae.name === "get" || ae.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(ae), I.kind = ae.name;
        let He = this.match(138);
        this.parseClassElementName(v), He ? this.pushClassPrivateMethod(c, S, !1, !1) : (this.isNonstaticConstructor(v) && this.raise(x.ConstructorIsAccessor, v.key), this.pushClassMethod(c, v, !1, !1, !1, !1)), this.checkGetterSetterParams(v);
      } else if (ne && ae.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(ae);
        let He = this.match(138);
        this.parseClassElementName(F), this.pushClassAccessorProperty(c, O, He);
      } else
        this.isLineTerminator() ? ue ? this.pushClassPrivateProperty(c, B) : this.pushClassProperty(c, F) : this.unexpected();
    }
    parseClassElementName(c) {
      let { type: a, value: f } = this.state;
      if ((a === 132 || a === 133) && c.static && f === "prototype" && this.raise(x.StaticPrototype, this.state.startLoc), a === 138) {
        f === "constructor" && this.raise(x.ConstructorClassPrivateField, this.state.startLoc);
        let g = this.parsePrivateName();
        return c.key = g, g;
      }
      return this.parsePropertyName(c);
    }
    parseClassStaticBlock(c, a) {
      var f;
      this.scope.enter(208);
      let g = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let v = a.body = [];
      this.parseBlockOrModuleBlockBody(v, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = g, c.body.push(this.finishNode(a, "StaticBlock")), (f = a.decorators) != null && f.length && this.raise(x.DecoratorStaticBlock, a);
    }
    pushClassProperty(c, a) {
      !a.computed && (a.key.name === "constructor" || a.key.value === "constructor") && this.raise(x.ConstructorClassField, a.key), c.body.push(this.parseClassProperty(a));
    }
    pushClassPrivateProperty(c, a) {
      let f = this.parseClassPrivateProperty(a);
      c.body.push(f), this.classScope.declarePrivateName(this.getPrivateNameSV(f.key), 0, f.key.loc.start);
    }
    pushClassAccessorProperty(c, a, f) {
      if (!f && !a.computed) {
        let v = a.key;
        (v.name === "constructor" || v.value === "constructor") && this.raise(x.ConstructorClassField, v);
      }
      let g = this.parseClassAccessorProperty(a);
      c.body.push(g), f && this.classScope.declarePrivateName(this.getPrivateNameSV(g.key), 0, g.key.loc.start);
    }
    pushClassMethod(c, a, f, g, v, S) {
      c.body.push(this.parseMethod(a, f, g, v, S, "ClassMethod", !0));
    }
    pushClassPrivateMethod(c, a, f, g) {
      let v = this.parseMethod(a, f, g, !1, !1, "ClassPrivateMethod", !0);
      c.body.push(v);
      let S = v.kind === "get" ? v.static ? 6 : 2 : v.kind === "set" ? v.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(v, S);
    }
    declareClassPrivateMethodInScope(c, a) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(c.key), a, c.key.loc.start);
    }
    parsePostMemberNameModifiers(c) {
    }
    parseClassPrivateProperty(c) {
      return this.parseInitializer(c), this.semicolon(), this.finishNode(c, "ClassPrivateProperty");
    }
    parseClassProperty(c) {
      return this.parseInitializer(c), this.semicolon(), this.finishNode(c, "ClassProperty");
    }
    parseClassAccessorProperty(c) {
      return this.parseInitializer(c), this.semicolon(), this.finishNode(c, "ClassAccessorProperty");
    }
    parseInitializer(c) {
      this.scope.enter(80), this.expressionScope.enter(Hg()), this.prodParam.enter(0), c.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(c, a, f, g = 8331) {
      if (R(this.state.type))
        c.id = this.parseIdentifier(), a && this.declareNameFromIdentifier(c.id, g);
      else if (f || !a)
        c.id = null;
      else
        throw this.raise(x.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(c) {
      c.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(c, a) {
      let f = this.parseMaybeImportPhase(c, !0), g = this.maybeParseExportDefaultSpecifier(c, f), v = !g || this.eat(12), S = v && this.eatExportStar(c), F = S && this.maybeParseExportNamespaceSpecifier(c), B = v && (!F || this.eat(12)), O = g || S;
      if (S && !F) {
        if (g && this.unexpected(), a)
          throw this.raise(x.UnsupportedDecoratorExport, c);
        return this.parseExportFrom(c, !0), this.finishNode(c, "ExportAllDeclaration");
      }
      let I = this.maybeParseExportNamedSpecifiers(c);
      g && v && !S && !I && this.unexpected(null, 5), F && B && this.unexpected(null, 98);
      let J;
      if (O || I) {
        if (J = !1, a)
          throw this.raise(x.UnsupportedDecoratorExport, c);
        this.parseExportFrom(c, O);
      } else
        J = this.maybeParseExportDeclaration(c);
      if (O || I || J) {
        var ne;
        let ue = c;
        if (this.checkExport(ue, !0, !1, !!ue.source), ((ne = ue.declaration) == null ? void 0 : ne.type) === "ClassDeclaration")
          this.maybeTakeDecorators(a, ue.declaration, ue);
        else if (a)
          throw this.raise(x.UnsupportedDecoratorExport, c);
        return this.finishNode(ue, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let ue = c, ae = this.parseExportDefaultExpression();
        if (ue.declaration = ae, ae.type === "ClassDeclaration")
          this.maybeTakeDecorators(a, ae, ue);
        else if (a)
          throw this.raise(x.UnsupportedDecoratorExport, c);
        return this.checkExport(ue, !0, !0), this.finishNode(ue, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(c) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(c, a) {
      if (a || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", a == null ? void 0 : a.loc.start);
        let f = a || this.parseIdentifier(!0), g = this.startNodeAtNode(f);
        return g.exported = f, c.specifiers = [this.finishNode(g, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(c) {
      if (this.isContextual(93)) {
        c.specifiers || (c.specifiers = []);
        let a = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), a.exported = this.parseModuleExportName(), c.specifiers.push(this.finishNode(a, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(c) {
      if (this.match(5)) {
        c.specifiers || (c.specifiers = []);
        let a = c.exportKind === "type";
        return c.specifiers.push(...this.parseExportSpecifiers(a)), c.source = null, c.declaration = null, this.hasPlugin("importAssertions") && (c.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(c) {
      return this.shouldParseExportDeclaration() ? (c.specifiers = [], c.source = null, this.hasPlugin("importAssertions") && (c.assertions = []), c.declaration = this.parseExportDeclaration(c), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95))
        return !1;
      let c = this.nextTokenInLineStart();
      return this.isUnparsedContextual(c, "function");
    }
    parseExportDefaultExpression() {
      let c = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(c, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(c, 13);
      if (this.match(80))
        return this.parseClass(c, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(x.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(x.UnsupportedDefaultExport, this.state.startLoc);
      let a = this.parseMaybeAssignAllowIn();
      return this.semicolon(), a;
    }
    parseExportDeclaration(c) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let { type: c } = this.state;
      if (R(c)) {
        if (c === 95 && !this.state.containsEsc || c === 100)
          return !1;
        if ((c === 130 || c === 129) && !this.state.containsEsc) {
          let { type: g } = this.lookahead();
          if (R(g) && g !== 98 || g === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let a = this.nextTokenStart(), f = this.isUnparsedContextual(a, "from");
      if (this.input.charCodeAt(a) === 44 || R(this.state.type) && f)
        return !0;
      if (this.match(65) && f) {
        let g = this.input.charCodeAt(this.nextTokenStartSince(a + 4));
        return g === 34 || g === 39;
      }
      return !1;
    }
    parseExportFrom(c, a) {
      this.eatContextual(98) ? (c.source = this.parseImportSource(), this.checkExport(c), this.maybeParseImportAttributes(c), this.checkJSONModuleImport(c)) : a && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let { type: c } = this.state;
      return c === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(x.DecoratorBeforeExport, this.state.startLoc), !0) : c === 74 || c === 75 || c === 68 || c === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(c, a, f, g) {
      if (a) {
        var v;
        if (f) {
          if (this.checkDuplicateExports(c, "default"), this.hasPlugin("exportDefaultFrom")) {
            var S;
            let F = c.declaration;
            F.type === "Identifier" && F.name === "from" && F.end - F.start === 4 && !((S = F.extra) != null && S.parenthesized) && this.raise(x.ExportDefaultFromAsIdentifier, F);
          }
        } else if ((v = c.specifiers) != null && v.length)
          for (let F of c.specifiers) {
            let { exported: B } = F, O = B.type === "Identifier" ? B.name : B.value;
            if (this.checkDuplicateExports(F, O), !g && F.local) {
              let { local: I } = F;
              I.type !== "Identifier" ? this.raise(x.ExportBindingIsString, F, { localName: I.value, exportName: O }) : (this.checkReservedWord(I.name, I.loc.start, !0, !1), this.scope.checkLocalExport(I));
            }
          }
        else if (c.declaration) {
          if (c.declaration.type === "FunctionDeclaration" || c.declaration.type === "ClassDeclaration") {
            let F = c.declaration.id;
            if (!F)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(c, F.name);
          } else if (c.declaration.type === "VariableDeclaration")
            for (let F of c.declaration.declarations)
              this.checkDeclaration(F.id);
        }
      }
    }
    checkDeclaration(c) {
      if (c.type === "Identifier")
        this.checkDuplicateExports(c, c.name);
      else if (c.type === "ObjectPattern")
        for (let a of c.properties)
          this.checkDeclaration(a);
      else if (c.type === "ArrayPattern")
        for (let a of c.elements)
          a && this.checkDeclaration(a);
      else
        c.type === "ObjectProperty" ? this.checkDeclaration(c.value) : c.type === "RestElement" ? this.checkDeclaration(c.argument) : c.type === "AssignmentPattern" && this.checkDeclaration(c.left);
    }
    checkDuplicateExports(c, a) {
      this.exportedIdentifiers.has(a) && (a === "default" ? this.raise(x.DuplicateDefaultExport, c) : this.raise(x.DuplicateExport, c, { exportName: a })), this.exportedIdentifiers.add(a);
    }
    parseExportSpecifiers(c) {
      let a = [], f = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (f)
          f = !1;
        else if (this.expect(12), this.eat(8))
          break;
        let g = this.isContextual(130), v = this.match(133), S = this.startNode();
        S.local = this.parseModuleExportName(), a.push(this.parseExportSpecifier(S, v, c, g));
      }
      return a;
    }
    parseExportSpecifier(c, a, f, g) {
      return this.eatContextual(93) ? c.exported = this.parseModuleExportName() : a ? c.exported = fS(c.local) : c.exported || (c.exported = Rn(c.local)), this.finishNode(c, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        let c = this.parseStringLiteral(this.state.value), a = c.value.match(WS);
        return a && this.raise(x.ModuleExportNameHasLoneSurrogate, c, { surrogateCharCode: a[0].charCodeAt(0) }), c;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(c) {
      return c.assertions != null ? c.assertions.some(({ key: a, value: f }) => f.value === "json" && (a.type === "Identifier" ? a.name === "type" : a.value === "type")) : !1;
    }
    checkImportReflection(c) {
      let { specifiers: a } = c, f = a.length === 1 ? a[0].type : null;
      if (c.phase === "source")
        f !== "ImportDefaultSpecifier" && this.raise(x.SourcePhaseImportRequiresDefault, a[0].loc.start);
      else if (c.phase === "defer")
        f !== "ImportNamespaceSpecifier" && this.raise(x.DeferImportRequiresNamespace, a[0].loc.start);
      else if (c.module) {
        var g;
        f !== "ImportDefaultSpecifier" && this.raise(x.ImportReflectionNotBinding, a[0].loc.start), ((g = c.assertions) == null ? void 0 : g.length) > 0 && this.raise(x.ImportReflectionHasAssertion, a[0].loc.start);
      }
    }
    checkJSONModuleImport(c) {
      if (this.isJSONModuleImport(c) && c.type !== "ExportAllDeclaration") {
        let { specifiers: a } = c;
        if (a != null) {
          let f = a.find((g) => {
            let v;
            if (g.type === "ExportSpecifier" ? v = g.local : g.type === "ImportSpecifier" && (v = g.imported), v !== void 0)
              return v.type === "Identifier" ? v.name !== "default" : v.value !== "default";
          });
          f !== void 0 && this.raise(x.ImportJSONBindingNotDefault, f.loc.start);
        }
      }
    }
    isPotentialImportPhase(c) {
      return c ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(c, a, f, g) {
      a || (f === "module" ? (this.expectPlugin("importReflection", g), c.module = !0) : this.hasPlugin("importReflection") && (c.module = !1), f === "source" ? (this.expectPlugin("sourcePhaseImports", g), c.phase = "source") : f === "defer" ? (this.expectPlugin("deferredImportEvaluation", g), c.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (c.phase = null));
    }
    parseMaybeImportPhase(c, a) {
      if (!this.isPotentialImportPhase(a))
        return this.applyImportPhase(c, a, null), null;
      let f = this.parseIdentifier(!0), { type: g } = this.state;
      return (be(g) ? g !== 98 || this.lookaheadCharCode() === 102 : g !== 12) ? (this.resetPreviousIdentifierLeadingComments(f), this.applyImportPhase(c, a, f.name, f.loc.start), null) : (this.applyImportPhase(c, a, null), f);
    }
    isPrecedingIdImportPhase(c) {
      let { type: a } = this.state;
      return R(a) ? a !== 98 || this.lookaheadCharCode() === 102 : a !== 12;
    }
    parseImport(c) {
      return this.match(133) ? this.parseImportSourceAndAttributes(c) : this.parseImportSpecifiersAndAfter(c, this.parseMaybeImportPhase(c, !1));
    }
    parseImportSpecifiersAndAfter(c, a) {
      c.specifiers = [];
      let f = !this.maybeParseDefaultImportSpecifier(c, a) || this.eat(12), g = f && this.maybeParseStarImportSpecifier(c);
      return f && !g && this.parseNamedImportSpecifiers(c), this.expectContextual(98), this.parseImportSourceAndAttributes(c);
    }
    parseImportSourceAndAttributes(c) {
      return c.specifiers != null || (c.specifiers = []), c.source = this.parseImportSource(), this.maybeParseImportAttributes(c), this.checkImportReflection(c), this.checkJSONModuleImport(c), this.semicolon(), this.finishNode(c, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(c, a, f) {
      a.local = this.parseIdentifier(), c.specifiers.push(this.finishImportSpecifier(a, f));
    }
    finishImportSpecifier(c, a, f = 8201) {
      return this.checkLVal(c.local, { in: { type: a }, binding: f }), this.finishNode(c, a);
    }
    parseImportAttributes() {
      this.expect(5);
      let c = [], a = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let f = this.startNode(), g = this.state.value;
        if (a.has(g) && this.raise(x.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: g }), a.add(g), this.match(133) ? f.key = this.parseStringLiteral(g) : f.key = this.parseIdentifier(!0), this.expect(14), !this.match(133))
          throw this.raise(x.ModuleAttributeInvalidValue, this.state.startLoc);
        f.value = this.parseStringLiteral(this.state.value), c.push(this.finishNode(f, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), c;
    }
    parseModuleAttributes() {
      let c = [], a = /* @__PURE__ */ new Set();
      do {
        let f = this.startNode();
        if (f.key = this.parseIdentifier(!0), f.key.name !== "type" && this.raise(x.ModuleAttributeDifferentFromType, f.key), a.has(f.key.name) && this.raise(x.ModuleAttributesWithDuplicateKeys, f.key, { key: f.key.name }), a.add(f.key.name), this.expect(14), !this.match(133))
          throw this.raise(x.ModuleAttributeInvalidValue, this.state.startLoc);
        f.value = this.parseStringLiteral(this.state.value), c.push(this.finishNode(f, "ImportAttribute"));
      } while (this.eat(12));
      return c;
    }
    maybeParseImportAttributes(c) {
      let a, f = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? a = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), a = this.parseImportAttributes()), f = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(x.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(c, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), a = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        a = [];
      else if (this.hasPlugin("moduleAttributes"))
        a = [];
      else
        return;
      !f && this.hasPlugin("importAssertions") ? c.assertions = a : c.attributes = a;
    }
    maybeParseDefaultImportSpecifier(c, a) {
      if (a) {
        let f = this.startNodeAtNode(a);
        return f.local = a, c.specifiers.push(this.finishImportSpecifier(f, "ImportDefaultSpecifier")), !0;
      } else if (be(this.state.type))
        return this.parseImportSpecifierLocal(c, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(c) {
      if (this.match(55)) {
        let a = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(c, a, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(c) {
      let a = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (a)
          a = !1;
        else {
          if (this.eat(14))
            throw this.raise(x.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8))
            break;
        }
        let f = this.startNode(), g = this.match(133), v = this.isContextual(130);
        f.imported = this.parseModuleExportName();
        let S = this.parseImportSpecifier(f, g, c.importKind === "type" || c.importKind === "typeof", v, void 0);
        c.specifiers.push(S);
      }
    }
    parseImportSpecifier(c, a, f, g, v) {
      if (this.eatContextual(93))
        c.local = this.parseIdentifier();
      else {
        let { imported: S } = c;
        if (a)
          throw this.raise(x.ImportBindingIsString, c, { importName: S.value });
        this.checkReservedWord(S.name, c.loc.start, !0, !0), c.local || (c.local = Rn(S));
      }
      return this.finishImportSpecifier(c, "ImportSpecifier", v);
    }
    isThisParam(c) {
      return c.type === "Identifier" && c.name === "this";
    }
  }, ry = class extends HS {
    constructor(c, a) {
      c = RS(c), super(c, a), this.options = c, this.initializeScopes(), this.plugins = VS(this.options.plugins), this.filename = c.sourceFilename;
    }
    getScopeHandler() {
      return Mh;
    }
    parse() {
      this.enterInitialScopes();
      let c = this.startNode(), a = this.startNode();
      return this.nextToken(), c.errors = null, this.parseTopLevel(c, a), c.errors = this.state.errors, c.comments.length = this.state.commentsLen, c;
    }
  };
  function VS(c) {
    let a = /* @__PURE__ */ new Map();
    for (let f of c) {
      let [g, v] = Array.isArray(f) ? f : [f, {}];
      a.has(g) || a.set(g, v || {});
    }
    return a;
  }
  function zS(c, a) {
    var f;
    if (((f = a) == null ? void 0 : f.sourceType) === "unambiguous") {
      a = Object.assign({}, a);
      try {
        a.sourceType = "module";
        let g = Go(a, c), v = g.parse();
        if (g.sawUnambiguousESM)
          return v;
        if (g.ambiguousScriptDifferentAst)
          try {
            return a.sourceType = "script", Go(a, c).parse();
          } catch {
          }
        else
          v.program.sourceType = "script";
        return v;
      } catch (g) {
        try {
          return a.sourceType = "script", Go(a, c).parse();
        } catch {
        }
        throw g;
      }
    } else
      return Go(a, c).parse();
  }
  function JS(c, a) {
    let f = Go(a, c);
    return f.options.strictMode && (f.state.strict = !0), f.getExpression();
  }
  function KS(c) {
    let a = {};
    for (let f of Object.keys(c))
      a[f] = Hr(c[f]);
    return a;
  }
  var GS = KS(W);
  function Go(c, a) {
    let f = ry;
    return c != null && c.plugins && (_S(c.plugins), f = XS(c.plugins)), new f(c, a);
  }
  var ny = {};
  function XS(c) {
    let a = $S.filter((v) => pt(c, v)), f = a.join("/"), g = ny[f];
    if (!g) {
      g = ry;
      for (let v of a)
        g = ty[v](g);
      ny[f] = g;
    }
    return g;
  }
  t.parse = zS, t.parseExpression = JS, t.tokTypes = GS;
}), u7 = MC((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = p, t.parse = m, t.parseWithComments = y, t.print = D, t.strip = d;
  var e = /\*\/$/, r = /^\/\*\*?/, n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, s = /^(\r?\n)+/, o = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, l = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, u = /(\r?\n|^) *\* ?/g, h = [];
  function p(C) {
    let A = C.match(n);
    return A ? A[0].trimLeft() : "";
  }
  function d(C) {
    let A = C.match(n);
    return A && A[0] ? C.substring(A[0].length) : C;
  }
  function m(C) {
    return y(C).pragmas;
  }
  function y(C) {
    let A = `
`;
    C = C.replace(r, "").replace(e, "").replace(u, "$1");
    let x = "";
    for (; x !== C; )
      x = C, C = C.replace(o, `${A}$1 $2${A}`);
    C = C.replace(s, "").trimRight();
    let E = /* @__PURE__ */ Object.create(null), k = C.replace(l, "").replace(s, "").trimRight(), w;
    for (; w = l.exec(C); ) {
      let T = w[2].replace(i, "");
      typeof E[w[1]] == "string" || Array.isArray(E[w[1]]) ? E[w[1]] = h.concat(E[w[1]], T) : E[w[1]] = T;
    }
    return { comments: k, pragmas: E };
  }
  function D({ comments: C = "", pragmas: A = {} }) {
    let x = `
`, E = "/**", k = " *", w = " */", T = Object.keys(A), P = T.flatMap((N) => b(N, A[N])).map((N) => `${k} ${N}${x}`).join("");
    if (!C) {
      if (T.length === 0)
        return "";
      if (T.length === 1 && !Array.isArray(A[T[0]])) {
        let N = A[T[0]];
        return `${E} ${b(T[0], N)[0]}${w}`;
      }
    }
    let M = C.split(x).map((N) => `${k} ${N}`).join(x) + x;
    return E + x + (C ? M : "") + (C && T.length ? k + x : "") + P + w;
  }
  function b(C, A) {
    return h.concat(A).map((x) => `@${C} ${x}`.trim());
  }
}), _C = {};
a7(_C, { parsers: () => o$ });
var M0 = ig(OC(), 1);
function $C(t) {
  return (e, r, n) => {
    let i = !!(n != null && n.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, o = r;
    for (; o >= 0 && o < s; ) {
      let l = e.charAt(o);
      if (t instanceof RegExp) {
        if (!t.test(l))
          return o;
      } else if (!t.includes(l))
        return o;
      i ? o-- : o++;
    }
    return o === -1 || o === s ? o : !1;
  };
}
var c7 = $C(" 	"), h7 = $C(/[^\n\r]/);
function p7(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var d7 = p7;
function f7(t, e, r) {
  let n = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let i = t.charAt(e);
  if (n) {
    if (t.charAt(e - 1) === "\r" && i === `
`)
      return e - 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e - 1;
  } else {
    if (i === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e + 1;
  }
  return e;
}
var m7 = f7;
function g7(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? h7(t, e) : e;
}
var y7 = g7;
function D7(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = c7(t, n), n = d7(t, n), n = y7(t, n), n = m7(t, n);
  return n;
}
var x7 = D7;
function b7(t) {
  let e = [];
  for (let r of t)
    try {
      return r();
    } catch (n) {
      e.push(n);
    }
  throw Object.assign(new Error("All combinations failed"), { errors: e });
}
var v7 = b7;
function C7(t) {
  if (!t.startsWith("#!"))
    return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var RC = C7, A7 = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, O0 = A7;
function E7(t) {
  return Array.isArray(t) && t.length > 0;
}
var sg = E7;
function Gr(t) {
  var e, r, n;
  let i = ((e = t.range) == null ? void 0 : e[0]) ?? t.start, s = (n = ((r = t.declaration) == null ? void 0 : r.decorators) ?? t.decorators) == null ? void 0 : n[0];
  return s ? Math.min(Gr(s), i) : i;
}
function yi(t) {
  var e;
  return ((e = t.range) == null ? void 0 : e[1]) ?? t.end;
}
function w7(t) {
  let e = new Set(t);
  return (r) => e.has(r == null ? void 0 : r.type);
}
var S7 = w7, T7 = S7(["Block", "CommentBlock", "MultiLine"]), Sd = T7;
function k7(t) {
  let e = `*${t.value}*`.split(`
`);
  return e.length > 1 && e.every((r) => r.trimStart()[0] === "*");
}
var L0 = k7;
function F7(t) {
  return Sd(t) && t.value[0] === "*" && /@(?:type|satisfies)\b/.test(t.value);
}
var P7 = F7, ia = null;
function Ba(t) {
  if (ia !== null && typeof ia.property) {
    let e = ia;
    return ia = Ba.prototype = null, e;
  }
  return ia = Ba.prototype = t ?? /* @__PURE__ */ Object.create(null), new Ba();
}
var B7 = 10;
for (let t = 0; t <= B7; t++)
  Ba();
function I7(t) {
  return Ba(t);
}
function N7(t, e = "type") {
  I7(t);
  function r(n) {
    let i = n[e], s = t[i];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: n });
    return s;
  }
  return r;
}
var M7 = N7, O7 = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value", "optional", "static", "method"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareEnum: ["id", "body"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], AsConstExpression: ["expression"], SatisfiesExpression: ["expression", "typeAnnotation"] }, L7 = M7(O7), _7 = L7;
function Td(t, e) {
  if (!(t !== null && typeof t == "object"))
    return t;
  if (Array.isArray(t)) {
    for (let n = 0; n < t.length; n++)
      t[n] = Td(t[n], e);
    return t;
  }
  let r = _7(t);
  for (let n = 0; n < r.length; n++)
    t[r[n]] = Td(t[r[n]], e);
  return e(t) || t;
}
var yp = Td;
function $7(t, e) {
  let { parser: r, text: n } = e;
  if (t.type === "File" && t.program.interpreter) {
    let { program: { interpreter: i }, comments: s } = t;
    delete t.program.interpreter, s.unshift(i);
  }
  if (r === "babel") {
    let i = /* @__PURE__ */ new Set();
    t = yp(t, (s) => {
      var o;
      (o = s.leadingComments) != null && o.some(P7) && i.add(Gr(s));
    }), t = yp(t, (s) => {
      if (s.type === "ParenthesizedExpression") {
        let { expression: o } = s;
        if (o.type === "TypeCastExpression")
          return o.range = [...s.range], o;
        let l = Gr(s);
        if (!i.has(l))
          return o.extra = { ...o.extra, parenthesized: !0 }, o;
      }
    });
  }
  if (t = yp(t, (i) => {
    var s;
    switch (i.type) {
      case "LogicalExpression":
        if (jC(i))
          return kd(i);
        break;
      case "VariableDeclaration": {
        let o = O0(!1, i.declarations, -1);
        o != null && o.init && n[yi(o)] !== ";" && (i.range = [Gr(i), yi(o)]);
        break;
      }
      case "TSParenthesizedType":
        return i.typeAnnotation;
      case "TSTypeParameter":
        if (typeof i.name == "string") {
          let o = Gr(i);
          i.name = { type: "Identifier", name: i.name, range: [o, o + i.name.length] };
        }
        break;
      case "TopicReference":
        t.extra = { ...t.extra, __isUsingHackPipeline: !0 };
        break;
      case "ExportAllDeclaration":
        if (r === "meriyah" && ((s = i.exported) == null ? void 0 : s.type) === "Identifier") {
          let { exported: o } = i, l = n.slice(Gr(o), yi(o));
          (l.startsWith('"') || l.startsWith("'")) && (i.exported = { ...i.exported, type: "Literal", value: i.exported.name, raw: l });
        }
        break;
      case "TSUnionType":
      case "TSIntersectionType":
        if (i.types.length === 1)
          return i.types[0];
        break;
    }
  }), sg(t.comments)) {
    let i = O0(!1, t.comments, -1);
    for (let s = t.comments.length - 2; s >= 0; s--) {
      let o = t.comments[s];
      yi(o) === Gr(i) && Sd(o) && Sd(i) && L0(o) && L0(i) && (t.comments.splice(s + 1, 1), o.value += "*//*" + i.value, o.range = [Gr(o), yi(i)]), i = o;
    }
  }
  return t.type === "Program" && (t.range = [0, n.length]), t;
}
function jC(t) {
  return t.type === "LogicalExpression" && t.right.type === "LogicalExpression" && t.operator === t.right.operator;
}
function kd(t) {
  return jC(t) ? kd({ type: "LogicalExpression", operator: t.operator, left: kd({ type: "LogicalExpression", operator: t.operator, left: t.left, right: t.right.left, range: [Gr(t.left), yi(t.right.left)] }), right: t.right.right, range: [Gr(t), yi(t)] }) : t;
}
var R7 = $7;
function j7(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var qC = j7;
function q7(t) {
  let { message: e, loc: { line: r, column: n }, reasonCode: i } = t, s = t;
  (i === "MissingPlugin" || i === "MissingOneOfPlugins") && (e = "Unexpected token.", s = void 0);
  let o = ` (${r}:${n})`;
  return e.endsWith(o) && (e = e.slice(0, -o.length)), qC(e, { loc: { start: { line: r, column: n + 1 } }, cause: s });
}
var WC = q7, _0 = ig(u7(), 1);
function W7(t) {
  let e = RC(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, _0.extract)(t), { pragmas: n, comments: i } = (0, _0.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: n, comments: i };
}
function U7(t) {
  let { pragmas: e } = W7(t);
  return Object.prototype.hasOwnProperty.call(e, "prettier") || Object.prototype.hasOwnProperty.call(e, "format");
}
function H7(t) {
  return t = typeof t == "function" ? { parse: t } : t, { astFormat: "estree", hasPragma: U7, locStart: Gr, locEnd: yi, ...t };
}
var fa = H7;
function V7(t) {
  let { filepath: e } = t;
  if (e) {
    if (e = e.toLowerCase(), e.endsWith(".cjs"))
      return "script";
    if (e.endsWith(".mjs"))
      return "module";
  }
}
var z7 = V7;
function J7(t, e) {
  let { type: r = "JsExpressionRoot", rootMarker: n, text: i } = e, { tokens: s, comments: o } = t;
  return delete t.tokens, delete t.comments, { tokens: s, comments: o, type: r, node: t, range: [0, i.length], rootMarker: n };
}
var UC = J7, Ro = (t) => fa(Z7(t)), K7 = { sourceType: "module", allowImportExportEverywhere: !0, allowReturnOutsideFunction: !0, allowNewTargetOutsideFunction: !0, allowSuperOutsideMethod: !0, allowUndeclaredExports: !0, errorRecovery: !0, createParenthesizedExpressions: !0, createImportExpressions: !0, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", "decorators", "decimal", "moduleBlocks", "asyncDoExpressions", "regexpUnicodeSets", "destructuringPrivate", "decoratorAutoAccessors", "importReflection", "explicitResourceManagement", ["importAttributes", { deprecatedAssertSyntax: !0 }], "sourcePhaseImports", "deferredImportEvaluation", ["optionalChainingAssign", { version: "2023-07" }]], tokens: !0, ranges: !0 }, G7 = ["recordAndTuple", { syntaxType: "hash" }], $0 = "v8intrinsic", R0 = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], En = (t, e = K7) => ({ ...e, plugins: [...e.plugins, ...t] }), X7 = /@(?:no)?flow\b/;
function Y7(t, e) {
  var r;
  if ((r = e.filepath) != null && r.endsWith(".js.flow"))
    return !0;
  let n = RC(t);
  n && (t = t.slice(n.length));
  let i = x7(t, 0);
  return i !== !1 && (t = t.slice(0, i)), X7.test(t);
}
function Q7(t, e, r) {
  let n = t(e, r), i = n.errors.find((s) => !e$.has(s.reasonCode));
  if (i)
    throw i;
  return n;
}
function Z7({ isExpression: t = !1, optionsCombinations: e }) {
  return (r, n = {}) => {
    if ((n.parser === "babel" || n.parser === "__babel_estree") && Y7(r, n))
      return n.parser = "babel-flow", VC.parse(r, n);
    let i = e;
    (n.__babelSourceType ?? z7(n)) === "script" && (i = i.map((u) => ({ ...u, sourceType: "script" }))), /#[[{]/.test(r) && (i = i.map((u) => En([G7], u)));
    let s = /%[A-Z]/.test(r);
    r.includes("|>") ? i = (s ? [...R0, $0] : R0).flatMap((u) => i.map((h) => En([u], h))) : s && (i = i.map((u) => En([$0], u)));
    let o = t ? M0.parseExpression : M0.parse, l;
    try {
      l = v7(i.map((u) => () => Q7(o, r, u)));
    } catch ({ errors: [u] }) {
      throw WC(u);
    }
    return t && (l = UC(l, { text: r, rootMarker: n.rootMarker })), R7(l, { parser: "babel", text: r });
  };
}
var e$ = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "DuplicateAccessibilityModifier", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), HC = [En(["jsx"])], j0 = Ro({ optionsCombinations: HC }), q0 = Ro({ optionsCombinations: [En(["jsx", "typescript"]), En(["typescript"])] }), W0 = Ro({ isExpression: !0, optionsCombinations: [En(["jsx"])] }), U0 = Ro({ isExpression: !0, optionsCombinations: [En(["typescript"])] }), VC = Ro({ optionsCombinations: [En(["jsx", ["flow", { all: !0, enums: !0 }], "flowComments"])] }), t$ = Ro({ optionsCombinations: HC.map((t) => En(["estree"], t)) }), r$ = { babel: j0, "babel-flow": VC, "babel-ts": q0, __js_expression: W0, __ts_expression: U0, __vue_expression: W0, __vue_ts_expression: U0, __vue_event_binding: j0, __vue_ts_event_binding: q0, __babel_estree: t$ }, n$ = ig(OC(), 1);
function zC(t = {}) {
  let { allowComments: e = !0 } = t;
  return function(r) {
    let n;
    try {
      n = (0, n$.parseExpression)(r, { tokens: !0, ranges: !0, attachComment: !1 });
    } catch (i) {
      throw WC(i);
    }
    if (!e && sg(n.comments))
      throw fi(n.comments[0], "Comment");
    return Ys(n), UC(n, { type: "JsonRoot", text: r });
  };
}
function fi(t, e) {
  let [r, n] = [t.loc.start, t.loc.end].map(({ line: i, column: s }) => ({ line: i, column: s + 1 }));
  return qC(`${e} is not allowed in JSON.`, { loc: { start: r, end: n } });
}
function Ys(t) {
  switch (t.type) {
    case "ArrayExpression":
      for (let e of t.elements)
        e !== null && Ys(e);
      return;
    case "ObjectExpression":
      for (let e of t.properties)
        Ys(e);
      return;
    case "ObjectProperty":
      if (t.computed)
        throw fi(t.key, "Computed key");
      if (t.shorthand)
        throw fi(t.key, "Shorthand property");
      t.key.type !== "Identifier" && Ys(t.key), Ys(t.value);
      return;
    case "UnaryExpression": {
      let { operator: e, argument: r } = t;
      if (e !== "+" && e !== "-")
        throw fi(t, `Operator '${t.operator}'`);
      if (r.type === "NumericLiteral" || r.type === "Identifier" && (r.name === "Infinity" || r.name === "NaN"))
        return;
      throw fi(r, `Operator '${e}' before '${r.type}'`);
    }
    case "Identifier":
      if (t.name !== "Infinity" && t.name !== "NaN" && t.name !== "undefined")
        throw fi(t, `Identifier '${t.name}'`);
      return;
    case "TemplateLiteral":
      if (sg(t.expressions))
        throw fi(t.expressions[0], "'TemplateLiteral' with expression");
      for (let e of t.quasis)
        Ys(e);
      return;
    case "NullLiteral":
    case "BooleanLiteral":
    case "NumericLiteral":
    case "StringLiteral":
    case "TemplateElement":
      return;
    default:
      throw fi(t, `'${t.type}'`);
  }
}
var Dp = zC(), i$ = { json: fa({ parse: Dp, hasPragma() {
  return !0;
} }), json5: fa(Dp), jsonc: fa(Dp), "json-stringify": fa({ parse: zC({ allowComments: !1 }), astFormat: "estree-json" }) }, s$ = i$, o$ = { ...r$, ...s$ }, a$ = _C;
const l$ = async (t, e) => {
  if (!LD(e))
    return t;
  const r = e === "js" ? "babel" : e;
  return await kP.format(t, {
    parser: r,
    plugins: [oL, EN, t7, a$],
    tabWidth: 2,
    htmlWhitespaceSensitivity: "ignore"
  });
}, JC = (t, e = { mustBeOpen: !0 }) => Object.values(t).filter((r) => !e.mustBeOpen || r.open && e.mustBeOpen).sort((r, n) => r.name.localeCompare(n.name)), Xe = {
  REPLACE_PROJECT: "REPLACE_PROJECT",
  NEW_FILE: "NEW_FILE",
  RENAME_FILE: "RENAME_FILE",
  SAVE_FILE: "SAVE_FILE",
  OPEN_FILE: "OPEN_FILE",
  ACTIVATE_FILE: "ACTIVATE_FILE",
  MOVE_FILE: "MOVE_FILE",
  CLOSE_FILE: "CLOSE_FILE",
  DELETE_FILE: "DELETE_FILE",
  NEW_FOLDER: "NEW_FOLDER",
  TOGGLE_OPEN_FOLDER: "TOGGLE_OPEN_FOLDER",
  DELETE_FOLDER: "DELETE_FOLDER",
  RENAME_FOLDER: "RENAME_FOLDER"
}, u$ = "Add your changes to ${fileName}", c$ = (t) => String(Math.max(...t.map((e) => Number(e.id))) + 1), h$ = (t) => String(Math.max(...t.map((e) => Number(e.id))) + 1), og = (t, e) => e.reduce((r, n) => (n.parentId === t && r.push(n.id, ...og(n.id, e)), r), []), p$ = (t, e, r) => {
  const n = new Set(
    r ? [t, ...og(t, r)] : [t]
  );
  return e.reduce((i, s) => (n.has(s.folderId) && i.push(s.id), i), []);
}, d$ = (t) => MD(() => {
  const e = {
    replaceProject: (r, n) => {
      t({
        type: Xe.REPLACE_PROJECT,
        payload: { project: r, shouldNotifyProjectUpdate: n }
      });
    },
    newFile: ({
      fileId: r,
      fileName: n,
      folderId: i = as,
      contents: s = u$
    }) => {
      t({
        type: Xe.NEW_FILE,
        payload: {
          fileId: r,
          fileName: n,
          folderId: i,
          contents: s.replace(/\${fileName}/g, n)
        }
      }), e.setActiveFile(r);
    },
    renameFile: (r, n) => {
      t({
        type: Xe.RENAME_FILE,
        payload: { fileId: r, newName: n }
      });
    },
    saveFile: (r, n) => {
      t({
        type: Xe.SAVE_FILE,
        payload: { fileId: r, contents: n }
      });
    },
    openFile: (r) => {
      t({
        type: Xe.OPEN_FILE,
        payload: { fileId: r }
      });
    },
    closeFile: (r) => {
      t({
        type: Xe.CLOSE_FILE,
        payload: { fileId: r }
      });
    },
    deleteFile: (r) => {
      t({
        type: Xe.DELETE_FILE,
        payload: { fileId: r }
      });
    },
    setActiveFile: (r) => {
      t({
        type: Xe.ACTIVATE_FILE,
        payload: { fileId: r }
      });
    },
    moveFile: (r, n) => {
      t({
        type: Xe.MOVE_FILE,
        payload: { fileId: r, folderId: n }
      });
    },
    newFolder: ({
      folderId: r,
      folderName: n,
      parentId: i = as
    }) => {
      t({
        type: Xe.NEW_FOLDER,
        payload: { folderId: r, folderName: n, parentId: i }
      });
    },
    renameFolder: (r, n) => {
      t({
        type: Xe.RENAME_FOLDER,
        payload: { folderId: r, newName: n }
      });
    },
    toggleOpenFolder: (r) => {
      t({
        type: Xe.TOGGLE_OPEN_FOLDER,
        payload: { folderId: r }
      });
    },
    deleteFolder: (r) => {
      t({
        type: Xe.DELETE_FOLDER,
        payload: { folderId: r }
      });
    }
  };
  return e;
}, [t]), f$ = (t, e) => {
  var r;
  switch (e.type) {
    case Xe.REPLACE_PROJECT: {
      const {
        project: n,
        shouldNotifyProjectUpdate: i
      } = e.payload;
      return t !== n && (i.current = !1), n;
    }
    case Xe.NEW_FILE: {
      const { fileId: n, fileName: i, folderId: s, contents: o = "" } = e.payload, l = { ...t, files: { ...t.files } }, [u, h] = i.split(".");
      return l.files[n] = {
        id: n,
        name: i,
        language: h || "html",
        contents: o,
        folderId: s
      }, l;
    }
    case Xe.RENAME_FILE: {
      const { fileId: n, newName: i } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], name: i }
        }
      };
    }
    case Xe.SAVE_FILE: {
      const { fileId: n, contents: i } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], contents: i }
        }
      };
    }
    case Xe.OPEN_FILE:
    case Xe.ACTIVATE_FILE: {
      const { fileId: n } = e.payload, i = (r = Object.values(t.files).filter(
        (o) => o.active
      )) == null ? void 0 : r[0];
      if ((i == null ? void 0 : i.id) === n)
        return t;
      const s = {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], active: !0, open: !0 }
        }
      };
      return i && (s.files[i.id].active = !1), s;
    }
    case Xe.CLOSE_FILE: {
      const { fileId: n } = e.payload, i = t.files[n], s = {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], open: !1, active: !1 }
        }
      };
      if (i.active) {
        const o = JC(t.files, {
          mustBeOpen: !0
        }), l = o.findIndex((h) => h.id === i.id);
        let u;
        l > 0 ? u = o[l - 1].id : l < o.length - 1 && (u = o[l + 1].id), u && (s.files[u] = {
          ...s.files[u],
          active: !0
        });
      }
      return s;
    }
    case Xe.DELETE_FILE: {
      const { fileId: n } = e.payload, i = {
        ...t,
        files: {
          ...t.files
        }
      };
      return delete i.files[n], i;
    }
    case Xe.MOVE_FILE: {
      const { fileId: n, folderId: i } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], folderId: i }
        }
      };
    }
    case Xe.NEW_FOLDER: {
      const { folderId: n, folderName: i, parentId: s } = e.payload, o = { ...t, folders: { ...t.folders } };
      return o.folders[n] = {
        id: n,
        name: i,
        parentId: s
      }, o;
    }
    case Xe.TOGGLE_OPEN_FOLDER: {
      const { folderId: n } = e.payload;
      return {
        ...t,
        folders: {
          ...t.folders,
          [n]: {
            ...t.folders[n],
            open: !t.folders[n].open
          }
        }
      };
    }
    case Xe.DELETE_FOLDER: {
      const { folderId: n } = e.payload, i = {
        ...t,
        folders: {
          ...t.folders
        }
      }, s = new Set(
        og(n, Object.values(t.folders))
      ), o = new Set(
        p$(
          n,
          Object.values(t.files),
          Object.values(t.folders)
        )
      );
      return delete i.folders[n], Object.values(i.folders).filter((l) => s.has(l.id)).forEach((l) => delete i.folders[l.id]), o.size && (i.files = { ...i.files }, Object.values(i.files).filter((l) => o.has(l.id)).forEach((l) => delete i.files[l.id])), i;
    }
    case Xe.RENAME_FOLDER: {
      const { folderId: n, newName: i } = e.payload;
      return {
        ...t,
        folders: {
          ...t.folders,
          [n]: { ...t.folders[n], name: i }
        }
      };
    }
    default:
      return t;
  }
}, m$ = ({ setActivePane: t, activePane: e }) => {
  const {
    config: { leftNav: r }
  } = vr();
  return /* @__PURE__ */ G.jsx("div", { className: "nav-bar", children: r.map((n) => /* @__PURE__ */ G.jsx(
    "div",
    {
      onClick: () => t(n.component),
      style: {
        cursor: "pointer",
        backgroundColor: n.component === e ? "#666" : ""
      },
      children: /* @__PURE__ */ G.jsx("i", { className: `fa-regular fa-2xl ${n.icon}` })
    },
    n.icon
  )) });
}, g$ = () => {
  const {
    config: { sideBar: t }
  } = vr();
  return /* @__PURE__ */ G.jsx("div", { className: "left-side-bar", children: t.map((e) => /* @__PURE__ */ G.jsx(
    "div",
    {
      onClick: () => alert("not implemented"),
      style: { cursor: "pointer" },
      children: /* @__PURE__ */ G.jsx("i", { className: `fa-regular fa-2xl ${e}` })
    },
    e
  )) });
}, KC = ({
  parentId: t,
  folders: e,
  files: r,
  newFolderPrompt: n,
  newFilePrompt: i,
  moveFilePrompt: s,
  renameFilePrompt: o,
  renameFolderPrompt: l
}) => {
  const {
    openFile: u,
    deleteFile: h,
    toggleOpenFolder: p,
    deleteFolder: d
  } = vr();
  return /* @__PURE__ */ G.jsxs(G.Fragment, { children: [
    Object.values(e).filter((m) => m.parentId === t).sort((m, y) => m.name.localeCompare(y.name)).map((m) => {
      const y = /* @__PURE__ */ G.jsx(
        "i",
        {
          className: m.open ? "fa-solid fa-caret-down" : "fa-solid fa-caret-right"
        }
      );
      return /* @__PURE__ */ G.jsxs("li", { children: [
        /* @__PURE__ */ G.jsxs("span", { className: "label", children: [
          /* @__PURE__ */ G.jsxs("span", { className: "title", children: [
            /* @__PURE__ */ G.jsx(
              "span",
              {
                className: "caret-container",
                onClick: () => p(m.id),
                children: y
              }
            ),
            /* @__PURE__ */ G.jsx("span", { children: m.name })
          ] }),
          /* @__PURE__ */ G.jsxs("span", { className: "button-bar", children: [
            /* @__PURE__ */ G.jsx("span", { onClick: () => l(m.id), children: /* @__PURE__ */ G.jsx("i", { className: "fa-solid fa-pencil" }) }),
            /* @__PURE__ */ G.jsx("span", { onClick: () => n(m.id), children: /* @__PURE__ */ G.jsx("i", { className: "fa-solid fa-folder-plus" }) }),
            /* @__PURE__ */ G.jsx("span", { onClick: () => i(m.id), children: /* @__PURE__ */ G.jsx("i", { className: "fa-solid fa-plus" }) }),
            /* @__PURE__ */ G.jsx("span", { onClick: () => d(m.id), children: /* @__PURE__ */ G.jsx("i", { className: "fa-solid fa-trash" }) })
          ] })
        ] }),
        m.open && /* @__PURE__ */ G.jsx("ul", { children: /* @__PURE__ */ G.jsx(
          KC,
          {
            folders: e,
            newFolderPrompt: n,
            parentId: m.id,
            files: r,
            newFilePrompt: i,
            moveFilePrompt: s,
            renameFilePrompt: o,
            renameFolderPrompt: l
          }
        ) })
      ] }, m.id + m.open);
    }),
    Object.values(r).filter((m) => m.folderId === t).sort((m, y) => m.name.localeCompare(y.name)).map((m) => /* @__PURE__ */ G.jsx("li", { children: /* @__PURE__ */ G.jsxs("span", { className: "label", children: [
      /* @__PURE__ */ G.jsx("span", { onClick: () => u(m.id), children: m.name }),
      /* @__PURE__ */ G.jsxs("span", { className: "button-bar", children: [
        /* @__PURE__ */ G.jsx("span", { onClick: () => s(m.id), children: /* @__PURE__ */ G.jsx("i", { className: "fa-solid fa-arrow-right" }) }),
        /* @__PURE__ */ G.jsx("span", { onClick: () => o(m.id), children: /* @__PURE__ */ G.jsx("i", { className: "fa-solid fa-pencil" }) }),
        /* @__PURE__ */ G.jsx("span", { onClick: () => h(m.id), children: /* @__PURE__ */ G.jsx("i", { className: "fa-solid fa-trash" }) })
      ] })
    ] }) }, m.id))
  ] });
}, y$ = () => {
  const {
    project: t,
    newFile: e,
    renameFile: r,
    moveFile: n,
    renameFolder: i,
    newFolder: s
  } = vr(), o = (d = as) => {
    const m = h$(Object.values(t.folders)), y = window.prompt("Please name your new folder");
    if (!y)
      return;
    if (Object.values(t.folders).some(
      (b) => b.name === y && b.parentId === d
    )) {
      alert("Folder already exists");
      return;
    }
    s({ parentId: d, folderName: y, folderId: m });
  }, l = (d = as) => {
    var A;
    const m = (A = window.prompt("Please name your new file")) == null ? void 0 : A.replace(/[^\w.]+/g, "");
    if (!m)
      return;
    if (Object.values(t.files).some(
      (x) => x.name === m && x.folderId === d
    )) {
      alert("File already exists");
      return;
    }
    const [D, b] = m.split(".");
    if (!b) {
      window.alert("Files must have extensions");
      return;
    }
    const C = c$(Object.values(t.files));
    e({
      fileId: C,
      fileName: m,
      folderId: d
    });
  }, u = (d) => {
    const m = t.files[d], y = window.prompt("Please enter your destination folder") ?? "";
    try {
      const D = _D(y.split("/"), {
        folders: Object.values(t.folders),
        required: !0
      });
      if (Object.values(t.files).some(
        (C) => C.name === m.name && C.folderId === D
      )) {
        alert("File already exists");
        return;
      }
      n(d, D);
    } catch (D) {
      window.alert($D(D));
    }
  }, h = (d) => {
    const m = t.files[d], y = window.prompt("Rename file", m.name);
    if (y === null || y === m.name)
      return;
    if (Object.values(t.files).some(
      (b) => b.name === y && b.folderId === m.folderId
    )) {
      alert("File already exists");
      return;
    }
    r(d, y);
  }, p = (d) => {
    const m = t.folders[d], y = window.prompt("Rename folder", m.name);
    if (y === null || y === m.name)
      return;
    if (Object.values(t.folders).some(
      (b) => b.name === y && b.parentId === m.parentId
    )) {
      alert("Folder already exists");
      return;
    }
    i(m.id, y);
  };
  return /* @__PURE__ */ G.jsxs("div", { children: [
    /* @__PURE__ */ G.jsxs("div", { className: "files-toolbar", children: [
      /* @__PURE__ */ G.jsx("button", { type: "button", onClick: () => o(), children: "New Folder" }),
      /* @__PURE__ */ G.jsx("button", { type: "button", onClick: () => l(), children: "New File" })
    ] }),
    /* @__PURE__ */ G.jsx("ul", { children: /* @__PURE__ */ G.jsx(
      KC,
      {
        parentId: as,
        folders: t.folders,
        newFolderPrompt: o,
        files: t.files,
        newFilePrompt: l,
        moveFilePrompt: u,
        renameFilePrompt: h,
        renameFolderPrompt: p
      }
    ) })
  ] });
}, D$ = () => {
  const {
    config: { instructions: t }
  } = vr();
  return /* @__PURE__ */ G.jsx("div", { className: "instructions", children: t });
}, x$ = () => /* @__PURE__ */ G.jsx("div", { children: "Search is not yet implemented. Sorry." }), b$ = {
  Instructions: D$,
  Files: y$,
  Search: x$
}, v$ = () => {
  const { config: t } = vr(), [e, r] = Ei(
    t.activeLeftNav || t.leftNav[0].component
  ), n = b$[e];
  return /* @__PURE__ */ G.jsxs(
    "div",
    {
      className: "left-pane-outer",
      style: { gridTemplateColumns: t.showSideBar ? "1fr 9fr" : "1fr" },
      children: [
        t.showSideBar && /* @__PURE__ */ G.jsx(g$, {}),
        /* @__PURE__ */ G.jsxs("div", { className: "left-pane-inner", children: [
          /* @__PURE__ */ G.jsx("div", { className: "left-nav", children: /* @__PURE__ */ G.jsx(m$, { setActivePane: r, activePane: e }) }),
          /* @__PURE__ */ G.jsx("div", { className: "left-main", children: /* @__PURE__ */ G.jsx(n, {}) })
        ] })
      ]
    }
  );
}, C$ = () => {
  const { project: t, closeFile: e, setActiveFile: r } = vr(), n = JC(t.files, { mustBeOpen: !0 });
  return /* @__PURE__ */ G.jsx("div", { className: "files-nav-bar", children: n.map((i) => /* @__PURE__ */ G.jsxs("div", { className: "file-tab", style: { cursor: "pointer" }, children: [
    /* @__PURE__ */ G.jsx(
      "span",
      {
        onClick: () => r(i.id),
        style: { fontWeight: i.active ? "bold" : "normal" },
        children: i.name
      }
    ),
    /* @__PURE__ */ G.jsx("span", { onClick: () => e(i.id), children: "X" })
  ] }, i.id)) });
};
function Fd() {
  return Fd = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, Fd.apply(this, arguments);
}
function A$(t, e) {
  if (t == null)
    return {};
  var r = {}, n = Object.keys(t), i, s;
  for (s = 0; s < n.length; s++)
    i = n[s], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
  return r;
}
class Ue {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, r, n) {
    [e, r] = vo(this, e, r);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), n.length && n.decompose(
      0,
      n.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      r,
      this.length,
      i,
      1
      /* Open.From */
    ), yn.from(i, this.length - (r - e) + n.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, r = this.length) {
    [e, r] = vo(this, e, r);
    let n = [];
    return this.decompose(e, r, n, 0), yn.from(n, r - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let r = this.scanIdentical(e, 1), n = this.length - this.scanIdentical(e, -1), i = new Ia(this), s = new Ia(e);
    for (let o = r, l = r; ; ) {
      if (i.next(o), s.next(o), o = 0, i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)
        return !1;
      if (l += i.value.length, i.done || l >= n)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Ia(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, r = this.length) {
    return new GC(this, e, r);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, r) {
    let n;
    if (e == null)
      n = this.iter();
    else {
      r == null && (r = this.lines + 1);
      let i = this.line(e).from;
      n = this.iterRange(i, Math.max(i, r == this.lines + 1 ? this.length : r <= 1 ? 0 : this.line(r - 1).to));
    }
    return new XC(n);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? Ue.empty : e.length <= 32 ? new lt(e) : yn.from(lt.split(e, []));
  }
}
class lt extends Ue {
  constructor(e, r = E$(e)) {
    super(), this.text = e, this.length = r;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, r, n, i) {
    for (let s = 0; ; s++) {
      let o = this.text[s], l = i + o.length;
      if ((r ? n : l) >= e)
        return new w$(i, l, n, o);
      i = l + 1, n++;
    }
  }
  decompose(e, r, n, i) {
    let s = e <= 0 && r >= this.length ? this : new lt(H0(this.text, e, r), Math.min(r, this.length) - Math.max(0, e));
    if (i & 1) {
      let o = n.pop(), l = Lu(s.text, o.text.slice(), 0, s.length);
      if (l.length <= 32)
        n.push(new lt(l, o.length + s.length));
      else {
        let u = l.length >> 1;
        n.push(new lt(l.slice(0, u)), new lt(l.slice(u)));
      }
    } else
      n.push(s);
  }
  replace(e, r, n) {
    if (!(n instanceof lt))
      return super.replace(e, r, n);
    [e, r] = vo(this, e, r);
    let i = Lu(this.text, Lu(n.text, H0(this.text, 0, e)), r), s = this.length + n.length - (r - e);
    return i.length <= 32 ? new lt(i, s) : yn.from(lt.split(i, []), s);
  }
  sliceString(e, r = this.length, n = `
`) {
    [e, r] = vo(this, e, r);
    let i = "";
    for (let s = 0, o = 0; s <= r && o < this.text.length; o++) {
      let l = this.text[o], u = s + l.length;
      s > e && o && (i += n), e < u && r > s && (i += l.slice(Math.max(0, e - s), r - s)), s = u + 1;
    }
    return i;
  }
  flatten(e) {
    for (let r of this.text)
      e.push(r);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, r) {
    let n = [], i = -1;
    for (let s of e)
      n.push(s), i += s.length + 1, n.length == 32 && (r.push(new lt(n, i)), n = [], i = -1);
    return i > -1 && r.push(new lt(n, i)), r;
  }
}
class yn extends Ue {
  constructor(e, r) {
    super(), this.children = e, this.length = r, this.lines = 0;
    for (let n of e)
      this.lines += n.lines;
  }
  lineInner(e, r, n, i) {
    for (let s = 0; ; s++) {
      let o = this.children[s], l = i + o.length, u = n + o.lines - 1;
      if ((r ? u : l) >= e)
        return o.lineInner(e, r, n, i);
      i = l + 1, n = u + 1;
    }
  }
  decompose(e, r, n, i) {
    for (let s = 0, o = 0; o <= r && s < this.children.length; s++) {
      let l = this.children[s], u = o + l.length;
      if (e <= u && r >= o) {
        let h = i & ((o <= e ? 1 : 0) | (u >= r ? 2 : 0));
        o >= e && u <= r && !h ? n.push(l) : l.decompose(e - o, r - o, n, h);
      }
      o = u + 1;
    }
  }
  replace(e, r, n) {
    if ([e, r] = vo(this, e, r), n.lines < this.lines)
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let o = this.children[i], l = s + o.length;
        if (e >= s && r <= l) {
          let u = o.replace(e - s, r - s, n), h = this.lines - o.lines + u.lines;
          if (u.lines < h >> 4 && u.lines > h >> 6) {
            let p = this.children.slice();
            return p[i] = u, new yn(p, this.length - (r - e) + n.length);
          }
          return super.replace(s, l, u);
        }
        s = l + 1;
      }
    return super.replace(e, r, n);
  }
  sliceString(e, r = this.length, n = `
`) {
    [e, r] = vo(this, e, r);
    let i = "";
    for (let s = 0, o = 0; s < this.children.length && o <= r; s++) {
      let l = this.children[s], u = o + l.length;
      o > e && s && (i += n), e < u && r > o && (i += l.sliceString(e - o, r - o, n)), o = u + 1;
    }
    return i;
  }
  flatten(e) {
    for (let r of this.children)
      r.flatten(e);
  }
  scanIdentical(e, r) {
    if (!(e instanceof yn))
      return 0;
    let n = 0, [i, s, o, l] = r > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += r, s += r) {
      if (i == o || s == l)
        return n;
      let u = this.children[i], h = e.children[s];
      if (u != h)
        return n + u.scanIdentical(h, r);
      n += u.length + 1;
    }
  }
  static from(e, r = e.reduce((n, i) => n + i.length + 1, -1)) {
    let n = 0;
    for (let y of e)
      n += y.lines;
    if (n < 32) {
      let y = [];
      for (let D of e)
        D.flatten(y);
      return new lt(y, r);
    }
    let i = Math.max(
      32,
      n >> 5
      /* Tree.BranchShift */
    ), s = i << 1, o = i >> 1, l = [], u = 0, h = -1, p = [];
    function d(y) {
      let D;
      if (y.lines > s && y instanceof yn)
        for (let b of y.children)
          d(b);
      else
        y.lines > o && (u > o || !u) ? (m(), l.push(y)) : y instanceof lt && u && (D = p[p.length - 1]) instanceof lt && y.lines + D.lines <= 32 ? (u += y.lines, h += y.length + 1, p[p.length - 1] = new lt(D.text.concat(y.text), D.length + 1 + y.length)) : (u + y.lines > i && m(), u += y.lines, h += y.length + 1, p.push(y));
    }
    function m() {
      u != 0 && (l.push(p.length == 1 ? p[0] : yn.from(p, h)), h = -1, u = p.length = 0);
    }
    for (let y of e)
      d(y);
    return m(), l.length == 1 ? l[0] : new yn(l, r);
  }
}
Ue.empty = /* @__PURE__ */ new lt([""], 0);
function E$(t) {
  let e = -1;
  for (let r of t)
    e += r.length + 1;
  return e;
}
function Lu(t, e, r = 0, n = 1e9) {
  for (let i = 0, s = 0, o = !0; s < t.length && i <= n; s++) {
    let l = t[s], u = i + l.length;
    u >= r && (u > n && (l = l.slice(0, n - i)), i < r && (l = l.slice(r - i)), o ? (e[e.length - 1] += l, o = !1) : e.push(l)), i = u + 1;
  }
  return e;
}
function H0(t, e, r) {
  return Lu(t, [""], e, r);
}
class Ia {
  constructor(e, r = 1) {
    this.dir = r, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [r > 0 ? 1 : (e instanceof lt ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, r) {
    for (this.done = this.lineBreak = !1; ; ) {
      let n = this.nodes.length - 1, i = this.nodes[n], s = this.offsets[n], o = s >> 1, l = i instanceof lt ? i.text.length : i.children.length;
      if (o == (r > 0 ? l : 0)) {
        if (n == 0)
          return this.done = !0, this.value = "", this;
        r > 0 && this.offsets[n - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (r > 0 ? 0 : 1)) {
        if (this.offsets[n] += r, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof lt) {
        let u = i.text[o + (r < 0 ? -1 : 0)];
        if (this.offsets[n] += r, u.length > Math.max(0, e))
          return this.value = e == 0 ? u : r > 0 ? u.slice(e) : u.slice(0, u.length - e), this;
        e -= u.length;
      } else {
        let u = i.children[o + (r < 0 ? -1 : 0)];
        e > u.length ? (e -= u.length, this.offsets[n] += r) : (r < 0 && this.offsets[n]--, this.nodes.push(u), this.offsets.push(r > 0 ? 1 : (u instanceof lt ? u.text.length : u.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class GC {
  constructor(e, r, n) {
    this.value = "", this.done = !1, this.cursor = new Ia(e, r > n ? -1 : 1), this.pos = r > n ? e.length : 0, this.from = Math.min(r, n), this.to = Math.max(r, n);
  }
  nextInner(e, r) {
    if (r < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, r < 0 ? this.pos - this.to : this.from - this.pos);
    let n = r < 0 ? this.pos - this.from : this.to - this.pos;
    e > n && (e = n), n -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * r, this.value = i.length <= n ? i : r < 0 ? i.slice(i.length - n) : i.slice(0, n), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class XC {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: r, lineBreak: n, value: i } = this.inner.next(e);
    return r && this.afterBreak ? (this.value = "", this.afterBreak = !1) : r ? (this.done = !0, this.value = "") : n ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Ue.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Ia.prototype[Symbol.iterator] = GC.prototype[Symbol.iterator] = XC.prototype[Symbol.iterator] = function() {
  return this;
});
class w$ {
  /**
  @internal
  */
  constructor(e, r, n, i) {
    this.from = e, this.to = r, this.number = n, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function vo(t, e, r) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, r))];
}
let ao = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
for (let t = 1; t < ao.length; t++)
  ao[t] += ao[t - 1];
function S$(t) {
  for (let e = 1; e < ao.length; e += 2)
    if (ao[e] > t)
      return ao[e - 1] <= t;
  return !1;
}
function V0(t) {
  return t >= 127462 && t <= 127487;
}
const z0 = 8205;
function Tt(t, e, r = !0, n = !0) {
  return (r ? YC : T$)(t, e, n);
}
function YC(t, e, r) {
  if (e == t.length)
    return e;
  e && QC(t.charCodeAt(e)) && ZC(t.charCodeAt(e - 1)) && e--;
  let n = Ct(t, e);
  for (e += Fr(n); e < t.length; ) {
    let i = Ct(t, e);
    if (n == z0 || i == z0 || r && S$(i))
      e += Fr(i), n = i;
    else if (V0(i)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && V0(Ct(t, o)); )
        s++, o -= 2;
      if (s % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function T$(t, e, r) {
  for (; e > 0; ) {
    let n = YC(t, e - 2, r);
    if (n < e)
      return n;
    e--;
  }
  return 0;
}
function QC(t) {
  return t >= 56320 && t < 57344;
}
function ZC(t) {
  return t >= 55296 && t < 56320;
}
function Ct(t, e) {
  let r = t.charCodeAt(e);
  if (!ZC(r) || e + 1 == t.length)
    return r;
  let n = t.charCodeAt(e + 1);
  return QC(n) ? (r - 55296 << 10) + (n - 56320) + 65536 : r;
}
function ag(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function Fr(t) {
  return t < 65536 ? 1 : 2;
}
const Pd = /\r\n?|\n/;
var Kt = /* @__PURE__ */ function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
}(Kt || (Kt = {}));
class wn {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2)
      e += this.sections[r];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2) {
      let n = this.sections[r + 1];
      e += n < 0 ? this.sections[r] : n;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let r = 0, n = 0, i = 0; r < this.sections.length; ) {
      let s = this.sections[r++], o = this.sections[r++];
      o < 0 ? (e(n, i, s), i += s) : i += o, n += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, r = !1) {
    Bd(this, e, r);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let r = 0; r < this.sections.length; ) {
      let n = this.sections[r++], i = this.sections[r++];
      i < 0 ? e.push(n, i) : e.push(i, n);
    }
    return new wn(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : eA(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, r = !1) {
    return e.empty ? this : Id(this, e, r);
  }
  mapPos(e, r = -1, n = Kt.Simple) {
    let i = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let l = this.sections[o++], u = this.sections[o++], h = i + l;
      if (u < 0) {
        if (h > e)
          return s + (e - i);
        s += l;
      } else {
        if (n != Kt.Simple && h >= e && (n == Kt.TrackDel && i < e && h > e || n == Kt.TrackBefore && i < e || n == Kt.TrackAfter && h > e))
          return null;
        if (h > e || h == e && r < 0 && !l)
          return e == i || r < 0 ? s : s + u;
        s += u;
      }
      i = h;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, r = e) {
    for (let n = 0, i = 0; n < this.sections.length && i <= r; ) {
      let s = this.sections[n++], o = this.sections[n++], l = i + s;
      if (o >= 0 && i <= r && l >= e)
        return i < e && l > r ? "cover" : !0;
      i = l;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let r = 0; r < this.sections.length; ) {
      let n = this.sections[r++], i = this.sections[r++];
      e += (e ? " " : "") + n + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((r) => typeof r != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new wn(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new wn(e);
  }
}
class mt extends wn {
  constructor(e, r) {
    super(e), this.inserted = r;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Bd(this, (r, n, i, s, o) => e = e.replace(i, i + (n - r), o), !1), e;
  }
  mapDesc(e, r = !1) {
    return Id(this, e, r, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let r = this.sections.slice(), n = [];
    for (let i = 0, s = 0; i < r.length; i += 2) {
      let o = r[i], l = r[i + 1];
      if (l >= 0) {
        r[i] = l, r[i + 1] = o;
        let u = i >> 1;
        for (; n.length < u; )
          n.push(Ue.empty);
        n.push(o ? e.slice(s, s + o) : Ue.empty);
      }
      s += o;
    }
    return new mt(r, n);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : eA(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, r = !1) {
    return e.empty ? this : Id(this, e, r, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, r = !1) {
    Bd(this, e, r);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return wn.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let r = [], n = [], i = [], s = new Ja(this);
    e:
      for (let o = 0, l = 0; ; ) {
        let u = o == e.length ? 1e9 : e[o++];
        for (; l < u || l == u && s.len == 0; ) {
          if (s.done)
            break e;
          let p = Math.min(s.len, u - l);
          _t(i, p, -1);
          let d = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
          _t(r, p, d), d > 0 && bi(n, r, s.text), s.forward(p), l += p;
        }
        let h = e[o++];
        for (; l < h; ) {
          if (s.done)
            break e;
          let p = Math.min(s.len, h - l);
          _t(r, p, -1), _t(i, p, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(p), l += p;
        }
      }
    return {
      changes: new mt(r, n),
      filtered: wn.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let r = 0; r < this.sections.length; r += 2) {
      let n = this.sections[r], i = this.sections[r + 1];
      i < 0 ? e.push(n) : i == 0 ? e.push([n]) : e.push([n].concat(this.inserted[r >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, r, n) {
    let i = [], s = [], o = 0, l = null;
    function u(p = !1) {
      if (!p && !i.length)
        return;
      o < r && _t(i, r - o, -1);
      let d = new mt(i, s);
      l = l ? l.compose(d.map(l)) : d, i = [], s = [], o = 0;
    }
    function h(p) {
      if (Array.isArray(p))
        for (let d of p)
          h(d);
      else if (p instanceof mt) {
        if (p.length != r)
          throw new RangeError(`Mismatched change set length (got ${p.length}, expected ${r})`);
        u(), l = l ? l.compose(p.map(l)) : p;
      } else {
        let { from: d, to: m = d, insert: y } = p;
        if (d > m || d < 0 || m > r)
          throw new RangeError(`Invalid change range ${d} to ${m} (in doc of length ${r})`);
        let D = y ? typeof y == "string" ? Ue.of(y.split(n || Pd)) : y : Ue.empty, b = D.length;
        if (d == m && b == 0)
          return;
        d < o && u(), d > o && _t(i, d - o, -1), _t(i, m - d, b), bi(s, i, D), o = m;
      }
    }
    return h(e), u(!l), l;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new mt(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let r = [], n = [];
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (typeof s == "number")
        r.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, l) => l && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          r.push(s[0], 0);
        else {
          for (; n.length < i; )
            n.push(Ue.empty);
          n[i] = Ue.of(s.slice(1)), r.push(s[0], n[i].length);
        }
      }
    }
    return new mt(r, n);
  }
  /**
  @internal
  */
  static createSet(e, r) {
    return new mt(e, r);
  }
}
function _t(t, e, r, n = !1) {
  if (e == 0 && r <= 0)
    return;
  let i = t.length - 2;
  i >= 0 && r <= 0 && r == t[i + 1] ? t[i] += e : e == 0 && t[i] == 0 ? t[i + 1] += r : n ? (t[i] += e, t[i + 1] += r) : t.push(e, r);
}
function bi(t, e, r) {
  if (r.length == 0)
    return;
  let n = e.length - 2 >> 1;
  if (n < t.length)
    t[t.length - 1] = t[t.length - 1].append(r);
  else {
    for (; t.length < n; )
      t.push(Ue.empty);
    t.push(r);
  }
}
function Bd(t, e, r) {
  let n = t.inserted;
  for (let i = 0, s = 0, o = 0; o < t.sections.length; ) {
    let l = t.sections[o++], u = t.sections[o++];
    if (u < 0)
      i += l, s += l;
    else {
      let h = i, p = s, d = Ue.empty;
      for (; h += l, p += u, u && n && (d = d.append(n[o - 2 >> 1])), !(r || o == t.sections.length || t.sections[o + 1] < 0); )
        l = t.sections[o++], u = t.sections[o++];
      e(i, h, s, p, d), i = h, s = p;
    }
  }
}
function Id(t, e, r, n = !1) {
  let i = [], s = n ? [] : null, o = new Ja(t), l = new Ja(e);
  for (let u = -1; ; )
    if (o.ins == -1 && l.ins == -1) {
      let h = Math.min(o.len, l.len);
      _t(i, h, -1), o.forward(h), l.forward(h);
    } else if (l.ins >= 0 && (o.ins < 0 || u == o.i || o.off == 0 && (l.len < o.len || l.len == o.len && !r))) {
      let h = l.len;
      for (_t(i, l.ins, -1); h; ) {
        let p = Math.min(o.len, h);
        o.ins >= 0 && u < o.i && o.len <= p && (_t(i, 0, o.ins), s && bi(s, i, o.text), u = o.i), o.forward(p), h -= p;
      }
      l.next();
    } else if (o.ins >= 0) {
      let h = 0, p = o.len;
      for (; p; )
        if (l.ins == -1) {
          let d = Math.min(p, l.len);
          h += d, p -= d, l.forward(d);
        } else if (l.ins == 0 && l.len < p)
          p -= l.len, l.next();
        else
          break;
      _t(i, h, u < o.i ? o.ins : 0), s && u < o.i && bi(s, i, o.text), u = o.i, o.forward(o.len - p);
    } else {
      if (o.done && l.done)
        return s ? mt.createSet(i, s) : wn.create(i);
      throw new Error("Mismatched change set lengths");
    }
}
function eA(t, e, r = !1) {
  let n = [], i = r ? [] : null, s = new Ja(t), o = new Ja(e);
  for (let l = !1; ; ) {
    if (s.done && o.done)
      return i ? mt.createSet(n, i) : wn.create(n);
    if (s.ins == 0)
      _t(n, s.len, 0, l), s.next();
    else if (o.len == 0 && !o.done)
      _t(n, 0, o.ins, l), i && bi(i, n, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let u = Math.min(s.len2, o.len), h = n.length;
        if (s.ins == -1) {
          let p = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          _t(n, u, p, l), i && p && bi(i, n, o.text);
        } else
          o.ins == -1 ? (_t(n, s.off ? 0 : s.len, u, l), i && bi(i, n, s.textBit(u))) : (_t(n, s.off ? 0 : s.len, o.off ? 0 : o.ins, l), i && !o.off && bi(i, n, o.text));
        l = (s.ins > u || o.ins >= 0 && o.len > u) && (l || n.length > h), s.forward2(u), o.forward(u);
      }
    }
  }
}
class Ja {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, r = this.i - 2 >> 1;
    return r >= e.length ? Ue.empty : e[r];
  }
  textBit(e) {
    let { inserted: r } = this.set, n = this.i - 2 >> 1;
    return n >= r.length && !e ? Ue.empty : r[n].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class ss {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.flags = n;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, r = -1) {
    let n, i;
    return this.empty ? n = i = e.mapPos(this.from, r) : (n = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), n == this.from && i == this.to ? this : new ss(n, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, r = e) {
    if (e <= this.anchor && r >= this.anchor)
      return K.range(e, r);
    let n = Math.abs(e - this.anchor) > Math.abs(r - this.anchor) ? e : r;
    return K.range(this.anchor, n);
  }
  /**
  Compare this range to another range.
  */
  eq(e, r = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!r || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return K.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new ss(e, r, n);
  }
}
class K {
  constructor(e, r) {
    this.ranges = e, this.mainIndex = r;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, r = -1) {
    return e.empty ? this : K.create(this.ranges.map((n) => n.map(e, r)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, r = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let n = 0; n < this.ranges.length; n++)
      if (!this.ranges[n].eq(e.ranges[n], r))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new K([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, r = !0) {
    return K.create([e].concat(this.ranges), r ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, r = this.mainIndex) {
    let n = this.ranges.slice();
    return n[r] = e, K.create(n, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new K(e.ranges.map((r) => ss.fromJSON(r)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, r = e) {
    return new K([K.range(e, r)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, r = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let n = 0, i = 0; i < e.length; i++) {
      let s = e[i];
      if (s.empty ? s.from <= n : s.from < n)
        return K.normalized(e.slice(), r);
      n = s.to;
    }
    return new K(e, r);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, r = 0, n, i) {
    return ss.create(e, e, (r == 0 ? 0 : r < 0 ? 8 : 16) | (n == null ? 7 : Math.min(6, n)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, r, n, i) {
    let s = (n ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return r < e ? ss.create(r, e, 48 | s) : ss.create(e, r, (r > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, r = 0) {
    let n = e[r];
    e.sort((i, s) => i.from - s.from), r = e.indexOf(n);
    for (let i = 1; i < e.length; i++) {
      let s = e[i], o = e[i - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let l = o.from, u = Math.max(s.to, o.to);
        i <= r && r--, e.splice(--i, 2, s.anchor > s.head ? K.range(u, l) : K.range(l, u));
      }
    }
    return new K(e, r);
  }
}
function tA(t, e) {
  for (let r of t.ranges)
    if (r.to > e)
      throw new RangeError("Selection points outside of document");
}
let lg = 0;
class ge {
  constructor(e, r, n, i, s) {
    this.combine = e, this.compareInput = r, this.compare = n, this.isStatic = i, this.id = lg++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new ge(e.combine || ((r) => r), e.compareInput || ((r, n) => r === n), e.compare || (e.combine ? (r, n) => r === n : ug), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new _u([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new _u(e, this, 1, r);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new _u(e, this, 2, r);
  }
  from(e, r) {
    return r || (r = (n) => n), this.compute([e], (n) => r(n.field(e)));
  }
}
function ug(t, e) {
  return t == e || t.length == e.length && t.every((r, n) => r === e[n]);
}
class _u {
  constructor(e, r, n, i) {
    this.dependencies = e, this.facet = r, this.type = n, this.value = i, this.id = lg++;
  }
  dynamicSlot(e) {
    var r;
    let n = this.value, i = this.facet.compareInput, s = this.id, o = e[s] >> 1, l = this.type == 2, u = !1, h = !1, p = [];
    for (let d of this.dependencies)
      d == "doc" ? u = !0 : d == "selection" ? h = !0 : ((r = e[d.id]) !== null && r !== void 0 ? r : 1) & 1 || p.push(e[d.id]);
    return {
      create(d) {
        return d.values[o] = n(d), 1;
      },
      update(d, m) {
        if (u && m.docChanged || h && (m.docChanged || m.selection) || Nd(d, p)) {
          let y = n(d);
          if (l ? !J0(y, d.values[o], i) : !i(y, d.values[o]))
            return d.values[o] = y, 1;
        }
        return 0;
      },
      reconfigure: (d, m) => {
        let y, D = m.config.address[s];
        if (D != null) {
          let b = ac(m, D);
          if (this.dependencies.every((C) => C instanceof ge ? m.facet(C) === d.facet(C) : C instanceof Nt ? m.field(C, !1) == d.field(C, !1) : !0) || (l ? J0(y = n(d), b, i) : i(y = n(d), b)))
            return d.values[o] = b, 0;
        } else
          y = n(d);
        return d.values[o] = y, 1;
      }
    };
  }
}
function J0(t, e, r) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!r(t[n], e[n]))
      return !1;
  return !0;
}
function Nd(t, e) {
  let r = !1;
  for (let n of e)
    Na(t, n) & 1 && (r = !0);
  return r;
}
function k$(t, e, r) {
  let n = r.map((u) => t[u.id]), i = r.map((u) => u.type), s = n.filter((u) => !(u & 1)), o = t[e.id] >> 1;
  function l(u) {
    let h = [];
    for (let p = 0; p < n.length; p++) {
      let d = ac(u, n[p]);
      if (i[p] == 2)
        for (let m of d)
          h.push(m);
      else
        h.push(d);
    }
    return e.combine(h);
  }
  return {
    create(u) {
      for (let h of n)
        Na(u, h);
      return u.values[o] = l(u), 1;
    },
    update(u, h) {
      if (!Nd(u, s))
        return 0;
      let p = l(u);
      return e.compare(p, u.values[o]) ? 0 : (u.values[o] = p, 1);
    },
    reconfigure(u, h) {
      let p = Nd(u, n), d = h.config.facets[e.id], m = h.facet(e);
      if (d && !p && ug(r, d))
        return u.values[o] = m, 0;
      let y = l(u);
      return e.compare(y, m) ? (u.values[o] = m, 0) : (u.values[o] = y, 1);
    }
  };
}
const K0 = /* @__PURE__ */ ge.define({ static: !0 });
class Nt {
  constructor(e, r, n, i, s) {
    this.id = e, this.createF = r, this.updateF = n, this.compareF = i, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let r = new Nt(lg++, e.create, e.update, e.compare || ((n, i) => n === i), e);
    return e.provide && (r.provides = e.provide(r)), r;
  }
  create(e) {
    let r = e.facet(K0).find((n) => n.field == this);
    return ((r == null ? void 0 : r.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let r = e[this.id] >> 1;
    return {
      create: (n) => (n.values[r] = this.create(n), 1),
      update: (n, i) => {
        let s = n.values[r], o = this.updateF(s, i);
        return this.compareF(s, o) ? 0 : (n.values[r] = o, 1);
      },
      reconfigure: (n, i) => i.config.address[this.id] != null ? (n.values[r] = i.field(this), 0) : (n.values[r] = this.create(n), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, K0.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const es = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function sa(t) {
  return (e) => new rA(e, t);
}
const jo = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ sa(es.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ sa(es.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ sa(es.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ sa(es.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ sa(es.lowest)
};
class rA {
  constructor(e, r) {
    this.inner = e, this.prec = r;
  }
}
class Dh {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new Md(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Dh.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class Md {
  constructor(e, r) {
    this.compartment = e, this.inner = r;
  }
}
class oc {
  constructor(e, r, n, i, s, o) {
    for (this.base = e, this.compartments = r, this.dynamicSlots = n, this.address = i, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < n.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let r = this.address[e.id];
    return r == null ? e.default : this.staticValues[r >> 1];
  }
  static resolve(e, r, n) {
    let i = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let m of F$(e, r, o))
      m instanceof Nt ? i.push(m) : (s[m.facet.id] || (s[m.facet.id] = [])).push(m);
    let l = /* @__PURE__ */ Object.create(null), u = [], h = [];
    for (let m of i)
      l[m.id] = h.length << 1, h.push((y) => m.slot(y));
    let p = n == null ? void 0 : n.config.facets;
    for (let m in s) {
      let y = s[m], D = y[0].facet, b = p && p[m] || [];
      if (y.every(
        (C) => C.type == 0
        /* Provider.Static */
      ))
        if (l[D.id] = u.length << 1 | 1, ug(b, y))
          u.push(n.facet(D));
        else {
          let C = D.combine(y.map((A) => A.value));
          u.push(n && D.compare(C, n.facet(D)) ? n.facet(D) : C);
        }
      else {
        for (let C of y)
          C.type == 0 ? (l[C.id] = u.length << 1 | 1, u.push(C.value)) : (l[C.id] = h.length << 1, h.push((A) => C.dynamicSlot(A)));
        l[D.id] = h.length << 1, h.push((C) => k$(C, D, y));
      }
    }
    let d = h.map((m) => m(l));
    return new oc(e, o, d, l, u, s);
  }
}
function F$(t, e, r) {
  let n = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function s(o, l) {
    let u = i.get(o);
    if (u != null) {
      if (u <= l)
        return;
      let h = n[u].indexOf(o);
      h > -1 && n[u].splice(h, 1), o instanceof Md && r.delete(o.compartment);
    }
    if (i.set(o, l), Array.isArray(o))
      for (let h of o)
        s(h, l);
    else if (o instanceof Md) {
      if (r.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let h = e.get(o.compartment) || o.inner;
      r.set(o.compartment, h), s(h, l);
    } else if (o instanceof rA)
      s(o.inner, o.prec);
    else if (o instanceof Nt)
      n[l].push(o), o.provides && s(o.provides, l);
    else if (o instanceof _u)
      n[l].push(o), o.facet.extensions && s(o.facet.extensions, es.default);
    else {
      let h = o.extension;
      if (!h)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(h, l);
    }
  }
  return s(t, es.default), n.reduce((o, l) => o.concat(l));
}
function Na(t, e) {
  if (e & 1)
    return 2;
  let r = e >> 1, n = t.status[r];
  if (n == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (n & 2)
    return n;
  t.status[r] = 4;
  let i = t.computeSlot(t, t.config.dynamicSlots[r]);
  return t.status[r] = 2 | i;
}
function ac(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const nA = /* @__PURE__ */ ge.define(), Od = /* @__PURE__ */ ge.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), iA = /* @__PURE__ */ ge.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), sA = /* @__PURE__ */ ge.define(), oA = /* @__PURE__ */ ge.define(), aA = /* @__PURE__ */ ge.define(), lA = /* @__PURE__ */ ge.define({
  combine: (t) => t.length ? t[0] : !1
});
class Nn {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new P$();
  }
}
class P$ {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Nn(this, e);
  }
}
class B$ {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new Se(this, e);
  }
}
class Se {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let r = this.type.map(this.value, e);
    return r === void 0 ? void 0 : r == this.value ? this : new Se(this.type, r);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new B$(e.map || ((r) => r));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, r) {
    if (!e.length)
      return e;
    let n = [];
    for (let i of e) {
      let s = i.map(r);
      s && n.push(s);
    }
    return n;
  }
}
Se.reconfigure = /* @__PURE__ */ Se.define();
Se.appendConfig = /* @__PURE__ */ Se.define();
class gt {
  constructor(e, r, n, i, s, o) {
    this.startState = e, this.changes = r, this.selection = n, this.effects = i, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, n && tA(n, r.newLength), s.some((l) => l.type == gt.time) || (this.annotations = s.concat(gt.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, r, n, i, s, o) {
    return new gt(e, r, n, i, s, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let r of this.annotations)
      if (r.type == e)
        return r.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let r = this.annotation(gt.userEvent);
    return !!(r && (r == e || r.length > e.length && r.slice(0, e.length) == e && r[e.length] == "."));
  }
}
gt.time = /* @__PURE__ */ Nn.define();
gt.userEvent = /* @__PURE__ */ Nn.define();
gt.addToHistory = /* @__PURE__ */ Nn.define();
gt.remote = /* @__PURE__ */ Nn.define();
function I$(t, e) {
  let r = [];
  for (let n = 0, i = 0; ; ) {
    let s, o;
    if (n < t.length && (i == e.length || e[i] >= t[n]))
      s = t[n++], o = t[n++];
    else if (i < e.length)
      s = e[i++], o = e[i++];
    else
      return r;
    !r.length || r[r.length - 1] < s ? r.push(s, o) : r[r.length - 1] < o && (r[r.length - 1] = o);
  }
}
function uA(t, e, r) {
  var n;
  let i, s, o;
  return r ? (i = e.changes, s = mt.empty(e.changes.length), o = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes), s = t.changes.mapDesc(e.changes, !0), o = t.changes.compose(i)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (n = t.selection) === null || n === void 0 ? void 0 : n.map(i),
    effects: Se.mapEffects(t.effects, i).concat(Se.mapEffects(e.effects, s)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function Ld(t, e, r) {
  let n = e.selection, i = lo(e.annotations);
  return e.userEvent && (i = i.concat(gt.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof mt ? e.changes : mt.of(e.changes || [], r, t.facet(iA)),
    selection: n && (n instanceof K ? n : K.single(n.anchor, n.head)),
    effects: lo(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function cA(t, e, r) {
  let n = Ld(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (r = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (r = !1);
    let o = !!e[s].sequential;
    n = uA(n, Ld(t, e[s], o ? n.changes.newLength : t.doc.length), o);
  }
  let i = gt.create(t, n.changes, n.selection, n.effects, n.annotations, n.scrollIntoView);
  return M$(r ? N$(i) : i);
}
function N$(t) {
  let e = t.startState, r = !0;
  for (let i of e.facet(sA)) {
    let s = i(t);
    if (s === !1) {
      r = !1;
      break;
    }
    Array.isArray(s) && (r = r === !0 ? s : I$(r, s));
  }
  if (r !== !0) {
    let i, s;
    if (r === !1)
      s = t.changes.invertedDesc, i = mt.empty(e.doc.length);
    else {
      let o = t.changes.filter(r);
      i = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    t = gt.create(e, i, t.selection && t.selection.map(s), Se.mapEffects(t.effects, s), t.annotations, t.scrollIntoView);
  }
  let n = e.facet(oA);
  for (let i = n.length - 1; i >= 0; i--) {
    let s = n[i](t);
    s instanceof gt ? t = s : Array.isArray(s) && s.length == 1 && s[0] instanceof gt ? t = s[0] : t = cA(e, lo(s), !1);
  }
  return t;
}
function M$(t) {
  let e = t.startState, r = e.facet(aA), n = t;
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](t);
    s && Object.keys(s).length && (n = uA(n, Ld(e, s, t.changes.newLength), !0));
  }
  return n == t ? t : gt.create(e, t.changes, t.selection, n.effects, n.annotations, n.scrollIntoView);
}
const O$ = [];
function lo(t) {
  return t == null ? O$ : Array.isArray(t) ? t : [t];
}
var nt = /* @__PURE__ */ function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
}(nt || (nt = {}));
const L$ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let _d;
try {
  _d = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function _$(t) {
  if (_d)
    return _d.test(t);
  for (let e = 0; e < t.length; e++) {
    let r = t[e];
    if (/\w/.test(r) || r > "" && (r.toUpperCase() != r.toLowerCase() || L$.test(r)))
      return !0;
  }
  return !1;
}
function $$(t) {
  return (e) => {
    if (!/\S/.test(e))
      return nt.Space;
    if (_$(e))
      return nt.Word;
    for (let r = 0; r < t.length; r++)
      if (e.indexOf(t[r]) > -1)
        return nt.Word;
    return nt.Other;
  };
}
class Ie {
  constructor(e, r, n, i, s, o) {
    this.config = e, this.doc = r, this.selection = n, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++)
      Na(this, l << 1);
    this.computeSlot = null;
  }
  field(e, r = !0) {
    let n = this.config.address[e.id];
    if (n == null) {
      if (r)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Na(this, n), ac(this, n);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return cA(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let r = this.config, { base: n, compartments: i } = r;
    for (let l of e.effects)
      l.is(Dh.reconfigure) ? (r && (i = /* @__PURE__ */ new Map(), r.compartments.forEach((u, h) => i.set(h, u)), r = null), i.set(l.value.compartment, l.value.extension)) : l.is(Se.reconfigure) ? (r = null, n = l.value) : l.is(Se.appendConfig) && (r = null, n = lo(n).concat(l.value));
    let s;
    r ? s = e.startState.values.slice() : (r = oc.resolve(n, i, this), s = new Ie(r, this.doc, this.selection, r.dynamicSlots.map(() => null), (u, h) => h.reconfigure(u, this), null).values);
    let o = e.startState.facet(Od) ? e.newSelection : e.newSelection.asSingle();
    new Ie(r, e.newDoc, o, s, (l, u) => u.update(l, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((r) => ({
      changes: { from: r.from, to: r.to, insert: e },
      range: K.cursor(r.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let r = this.selection, n = e(r.ranges[0]), i = this.changes(n.changes), s = [n.range], o = lo(n.effects);
    for (let l = 1; l < r.ranges.length; l++) {
      let u = e(r.ranges[l]), h = this.changes(u.changes), p = h.map(i);
      for (let m = 0; m < l; m++)
        s[m] = s[m].map(p);
      let d = i.mapDesc(h, !0);
      s.push(u.range.map(d)), i = i.compose(p), o = Se.mapEffects(o, p).concat(Se.mapEffects(lo(u.effects), d));
    }
    return {
      changes: i,
      selection: K.create(s, r.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof mt ? e : mt.of(e, this.doc.length, this.facet(Ie.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return Ue.of(e.split(this.facet(Ie.lineSeparator) || Pd));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, r = this.doc.length) {
    return this.doc.sliceString(e, r, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let r = this.config.address[e.id];
    return r == null ? e.default : (Na(this, r), ac(this, r));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let r = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let n in e) {
        let i = e[n];
        i instanceof Nt && this.config.address[i.id] != null && (r[n] = i.spec.toJSON(this.field(e[n]), this));
      }
    return r;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, r = {}, n) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (n) {
      for (let s in n)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = n[s], l = e[s];
          i.push(o.init((u) => o.spec.fromJSON(l, u)));
        }
    }
    return Ie.create({
      doc: e.doc,
      selection: K.fromJSON(e.selection),
      extensions: r.extensions ? i.concat([r.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let r = oc.resolve(e.extensions || [], /* @__PURE__ */ new Map()), n = e.doc instanceof Ue ? e.doc : Ue.of((e.doc || "").split(r.staticFacet(Ie.lineSeparator) || Pd)), i = e.selection ? e.selection instanceof K ? e.selection : K.single(e.selection.anchor, e.selection.head) : K.single(0);
    return tA(i, n.length), r.staticFacet(Od) || (i = i.asSingle()), new Ie(r, n, i, r.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(Ie.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(Ie.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(lA);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...r) {
    for (let n of this.facet(Ie.phrases))
      if (Object.prototype.hasOwnProperty.call(n, e)) {
        e = n[e];
        break;
      }
    return r.length && (e = e.replace(/\$(\$|\d*)/g, (n, i) => {
      if (i == "$")
        return "$";
      let s = +(i || 1);
      return !s || s > r.length ? n : r[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, r, n = -1) {
    let i = [];
    for (let s of this.facet(nA))
      for (let o of s(this, r, n))
        Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return $$(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: r, from: n, length: i } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - n, l = e - n;
    for (; o > 0; ) {
      let u = Tt(r, o, !1);
      if (s(r.slice(u, o)) != nt.Word)
        break;
      o = u;
    }
    for (; l < i; ) {
      let u = Tt(r, l);
      if (s(r.slice(l, u)) != nt.Word)
        break;
      l = u;
    }
    return o == l ? null : K.range(o + n, l + n);
  }
}
Ie.allowMultipleSelections = Od;
Ie.tabSize = /* @__PURE__ */ ge.define({
  combine: (t) => t.length ? t[0] : 4
});
Ie.lineSeparator = iA;
Ie.readOnly = lA;
Ie.phrases = /* @__PURE__ */ ge.define({
  compare(t, e) {
    let r = Object.keys(t), n = Object.keys(e);
    return r.length == n.length && r.every((i) => t[i] == e[i]);
  }
});
Ie.languageData = nA;
Ie.changeFilter = sA;
Ie.transactionFilter = oA;
Ie.transactionExtender = aA;
Dh.reconfigure = /* @__PURE__ */ Se.define();
function Mn(t, e, r = {}) {
  let n = {};
  for (let i of t)
    for (let s of Object.keys(i)) {
      let o = i[s], l = n[s];
      if (l === void 0)
        n[s] = o;
      else if (!(l === o || o === void 0))
        if (Object.hasOwnProperty.call(r, s))
          n[s] = r[s](l, o);
        else
          throw new Error("Config merge conflict for field " + s);
    }
  for (let i in e)
    n[i] === void 0 && (n[i] = e[i]);
  return n;
}
class xs {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, r = e) {
    return $d.create(e, r, this);
  }
}
xs.prototype.startSide = xs.prototype.endSide = 0;
xs.prototype.point = !1;
xs.prototype.mapMode = Kt.TrackDel;
let $d = class hA {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.value = n;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new hA(e, r, n);
  }
};
function Rd(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class cg {
  constructor(e, r, n, i) {
    this.from = e, this.to = r, this.value = n, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, r, n, i = 0) {
    let s = n ? this.to : this.from;
    for (let o = i, l = s.length; ; ) {
      if (o == l)
        return o;
      let u = o + l >> 1, h = s[u] - e || (n ? this.value[u].endSide : this.value[u].startSide) - r;
      if (u == o)
        return h >= 0 ? o : l;
      h >= 0 ? l = u : o = u + 1;
    }
  }
  between(e, r, n, i) {
    for (let s = this.findIndex(r, -1e9, !0), o = this.findIndex(n, 1e9, !1, s); s < o; s++)
      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, r) {
    let n = [], i = [], s = [], o = -1, l = -1;
    for (let u = 0; u < this.value.length; u++) {
      let h = this.value[u], p = this.from[u] + e, d = this.to[u] + e, m, y;
      if (p == d) {
        let D = r.mapPos(p, h.startSide, h.mapMode);
        if (D == null || (m = y = D, h.startSide != h.endSide && (y = r.mapPos(p, h.endSide), y < m)))
          continue;
      } else if (m = r.mapPos(p, h.startSide), y = r.mapPos(d, h.endSide), m > y || m == y && h.startSide > 0 && h.endSide <= 0)
        continue;
      (y - m || h.endSide - h.startSide) < 0 || (o < 0 && (o = m), h.point && (l = Math.max(l, y - m)), n.push(h), i.push(m - o), s.push(y - o));
    }
    return { mapped: n.length ? new cg(i, s, n, l) : null, pos: o };
  }
}
class _e {
  constructor(e, r, n, i) {
    this.chunkPos = e, this.chunk = r, this.nextLayer = n, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, r, n, i) {
    return new _e(e, r, n, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let r of this.chunk)
      e += r.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: r = [], sort: n = !1, filterFrom: i = 0, filterTo: s = this.length } = e, o = e.filter;
    if (r.length == 0 && !o)
      return this;
    if (n && (r = r.slice().sort(Rd)), this.isEmpty)
      return r.length ? _e.of(r) : this;
    let l = new pA(this, null, -1).goto(0), u = 0, h = [], p = new Mi();
    for (; l.value || u < r.length; )
      if (u < r.length && (l.from - r[u].from || l.startSide - r[u].value.startSide) >= 0) {
        let d = r[u++];
        p.addInner(d.from, d.to, d.value) || h.push(d);
      } else
        l.rangeIndex == 1 && l.chunkIndex < this.chunk.length && (u == r.length || this.chunkEnd(l.chunkIndex) < r[u].from) && (!o || i > this.chunkEnd(l.chunkIndex) || s < this.chunkPos[l.chunkIndex]) && p.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex]) ? l.nextChunk() : ((!o || i > l.to || s < l.from || o(l.from, l.to, l.value)) && (p.addInner(l.from, l.to, l.value) || h.push($d.create(l.from, l.to, l.value))), l.next());
    return p.finishInner(this.nextLayer.isEmpty && !h.length ? _e.empty : this.nextLayer.update({ add: h, filter: o, filterFrom: i, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let r = [], n = [], i = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let l = this.chunkPos[o], u = this.chunk[o], h = e.touchesRange(l, l + u.length);
      if (h === !1)
        i = Math.max(i, u.maxPoint), r.push(u), n.push(e.mapPos(l));
      else if (h === !0) {
        let { mapped: p, pos: d } = u.map(l, e);
        p && (i = Math.max(i, p.maxPoint), r.push(p), n.push(d));
      }
    }
    let s = this.nextLayer.map(e);
    return r.length == 0 ? s : new _e(n, r, s || _e.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, r, n) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i], o = this.chunk[i];
        if (r >= s && e <= s + o.length && o.between(s, e - s, r - s, n) === !1)
          return;
      }
      this.nextLayer.between(e, r, n);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Ka.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, r = 0) {
    return Ka.from(e).goto(r);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, r, n, i, s = -1) {
    let o = e.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= s), l = r.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= s), u = G0(o, l, n), h = new oa(o, u, s), p = new oa(l, u, s);
    n.iterGaps((d, m, y) => X0(h, d, p, m, y, i)), n.empty && n.length == 0 && X0(h, 0, p, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, r, n = 0, i) {
    i == null && (i = 999999999);
    let s = e.filter((p) => !p.isEmpty && r.indexOf(p) < 0), o = r.filter((p) => !p.isEmpty && e.indexOf(p) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let l = G0(s, o), u = new oa(s, l, 0).goto(n), h = new oa(o, l, 0).goto(n);
    for (; ; ) {
      if (u.to != h.to || !jd(u.active, h.active) || u.point && (!h.point || !u.point.eq(h.point)))
        return !1;
      if (u.to > i)
        return !0;
      u.next(), h.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, r, n, i, s = -1) {
    let o = new oa(e, null, s).goto(r), l = r, u = o.openStart;
    for (; ; ) {
      let h = Math.min(o.to, n);
      if (o.point) {
        let p = o.activeForPoint(o.to), d = o.pointFrom < r ? p.length + 1 : Math.min(p.length, u);
        i.point(l, h, o.point, p, d, o.pointRank), u = Math.min(o.openEnd(h), p.length);
      } else
        h > l && (i.span(l, h, o.active, u), u = o.openEnd(h));
      if (o.to > n)
        return u + (o.point && o.to > n ? 1 : 0);
      l = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, r = !1) {
    let n = new Mi();
    for (let i of e instanceof $d ? [e] : r ? R$(e) : e)
      n.add(i.from, i.to, i.value);
    return n.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return _e.empty;
    let r = e[e.length - 1];
    for (let n = e.length - 2; n >= 0; n--)
      for (let i = e[n]; i != _e.empty; i = i.nextLayer)
        r = new _e(i.chunkPos, i.chunk, r, Math.max(i.maxPoint, r.maxPoint));
    return r;
  }
}
_e.empty = /* @__PURE__ */ new _e([], [], null, -1);
function R$(t) {
  if (t.length > 1)
    for (let e = t[0], r = 1; r < t.length; r++) {
      let n = t[r];
      if (Rd(e, n) > 0)
        return t.slice().sort(Rd);
      e = n;
    }
  return t;
}
_e.empty.nextLayer = _e.empty;
class Mi {
  finishChunk(e) {
    this.chunks.push(new cg(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, r, n) {
    this.addInner(e, r, n) || (this.nextLayer || (this.nextLayer = new Mi())).add(e, r, n);
  }
  /**
  @internal
  */
  addInner(e, r, n) {
    let i = e - this.lastTo || n.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || n.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(r - this.chunkStart), this.last = n, this.lastFrom = e, this.lastTo = r, this.value.push(n), n.point && (this.maxPoint = Math.max(this.maxPoint, r - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, r) {
    if ((e - this.lastTo || r.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, r.maxPoint), this.chunks.push(r), this.chunkPos.push(e);
    let n = r.value.length - 1;
    return this.last = r.value[n], this.lastFrom = r.from[n] + e, this.lastTo = r.to[n] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(_e.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let r = _e.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, r;
  }
}
function G0(t, e, r) {
  let n = /* @__PURE__ */ new Map();
  for (let s of t)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && n.set(s.chunk[o], s.chunkPos[o]);
  let i = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let l = n.get(s.chunk[o]);
      l != null && (r ? r.mapPos(l) : l) == s.chunkPos[o] && !(r != null && r.touchesRange(l, l + s.chunk[o].length)) && i.add(s.chunk[o]);
    }
  return i;
}
class pA {
  constructor(e, r, n, i = 0) {
    this.layer = e, this.skip = r, this.minPoint = n, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, r = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, r, !1), this;
  }
  gotoInner(e, r, n) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, n = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], r, !0);
      (!n || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, r) {
    (this.to - e || this.endSide - r) < 0 && this.gotoInner(e, r, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], r = this.layer.chunk[this.chunkIndex], n = e + r.from[this.rangeIndex];
        if (this.from = n, this.to = e + r.to[this.rangeIndex], this.value = r.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Ka {
  constructor(e) {
    this.heap = e;
  }
  static from(e, r = null, n = -1) {
    let i = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= n && i.push(new pA(o, r, n, s));
    return i.length == 1 ? i[0] : new Ka(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, r = -1e9) {
    for (let n of this.heap)
      n.goto(e, r);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      xp(this.heap, n);
    return this.next(), this;
  }
  forward(e, r) {
    for (let n of this.heap)
      n.forward(e, r);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      xp(this.heap, n);
    (this.to - e || this.value.endSide - r) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), xp(this.heap, 0);
    }
  }
}
function xp(t, e) {
  for (let r = t[e]; ; ) {
    let n = (e << 1) + 1;
    if (n >= t.length)
      break;
    let i = t[n];
    if (n + 1 < t.length && i.compare(t[n + 1]) >= 0 && (i = t[n + 1], n++), r.compare(i) < 0)
      break;
    t[n] = r, t[e] = i, e = n;
  }
}
class oa {
  constructor(e, r, n) {
    this.minPoint = n, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Ka.from(e, r, n);
  }
  goto(e, r = -1e9) {
    return this.cursor.goto(e, r), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = r, this.openStart = -1, this.next(), this;
  }
  forward(e, r) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - r) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, r);
  }
  removeActive(e) {
    iu(this.active, e), iu(this.activeTo, e), iu(this.activeRank, e), this.minActive = Y0(this.active, this.activeTo);
  }
  addActive(e) {
    let r = 0, { value: n, to: i, rank: s } = this.cursor;
    for (; r < this.activeRank.length && (s - this.activeRank[r] || i - this.activeTo[r]) > 0; )
      r++;
    su(this.active, r, n), su(this.activeTo, r, i), su(this.activeRank, r, s), e && su(e, r, this.cursor.from), this.minActive = Y0(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, r = this.point;
    this.point = null;
    let n = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), n && iu(n, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(n), this.cursor.next();
          else if (r && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (n) {
      this.openStart = 0;
      for (let i = n.length - 1; i >= 0 && n[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let r = [];
    for (let n = this.active.length - 1; n >= 0 && !(this.activeRank[n] < this.pointRank); n--)
      (this.activeTo[n] > e || this.activeTo[n] == e && this.active[n].endSide >= this.point.endSide) && r.push(this.active[n]);
    return r.reverse();
  }
  openEnd(e) {
    let r = 0;
    for (let n = this.activeTo.length - 1; n >= 0 && this.activeTo[n] > e; n--)
      r++;
    return r;
  }
}
function X0(t, e, r, n, i, s) {
  t.goto(e), r.goto(n);
  let o = n + i, l = n, u = n - e;
  for (; ; ) {
    let h = t.to + u - r.to || t.endSide - r.endSide, p = h < 0 ? t.to + u : r.to, d = Math.min(p, o);
    if (t.point || r.point ? t.point && r.point && (t.point == r.point || t.point.eq(r.point)) && jd(t.activeForPoint(t.to), r.activeForPoint(r.to)) || s.comparePoint(l, d, t.point, r.point) : d > l && !jd(t.active, r.active) && s.compareRange(l, d, t.active, r.active), p > o)
      break;
    l = p, h <= 0 && t.next(), h >= 0 && r.next();
  }
}
function jd(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (t[r] != e[r] && !t[r].eq(e[r]))
      return !1;
  return !0;
}
function iu(t, e) {
  for (let r = e, n = t.length - 1; r < n; r++)
    t[r] = t[r + 1];
  t.pop();
}
function su(t, e, r) {
  for (let n = t.length - 1; n >= e; n--)
    t[n + 1] = t[n];
  t[e] = r;
}
function Y0(t, e) {
  let r = -1, n = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - n || t[i].endSide - t[r].endSide) < 0 && (r = i, n = e[i]);
  return r;
}
function qo(t, e, r = t.length) {
  let n = 0;
  for (let i = 0; i < r; )
    t.charCodeAt(i) == 9 ? (n += e - n % e, i++) : (n++, i = Tt(t, i));
  return n;
}
function qd(t, e, r, n) {
  for (let i = 0, s = 0; ; ) {
    if (s >= e)
      return i;
    if (i == t.length)
      break;
    s += t.charCodeAt(i) == 9 ? r - s % r : 1, i = Tt(t, i);
  }
  return n === !0 ? -1 : t.length;
}
const Wd = "", Q0 = typeof Symbol > "u" ? "__" + Wd : Symbol.for(Wd), Ud = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), Z0 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Oi {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, r) {
    this.rules = [];
    let { finish: n } = r || {};
    function i(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, l, u, h) {
      let p = [], d = /^@(\w+)\b/.exec(o[0]), m = d && d[1] == "keyframes";
      if (d && l == null)
        return u.push(o[0] + ";");
      for (let y in l) {
        let D = l[y];
        if (/&/.test(y))
          s(
            y.split(/,\s*/).map((b) => o.map((C) => b.replace(/&/, C))).reduce((b, C) => b.concat(C)),
            D,
            u
          );
        else if (D && typeof D == "object") {
          if (!d)
            throw new RangeError("The value of a property (" + y + ") should be a primitive value.");
          s(i(y), D, p, m);
        } else
          D != null && p.push(y.replace(/_.*/, "").replace(/[A-Z]/g, (b) => "-" + b.toLowerCase()) + ": " + D + ";");
      }
      (p.length || m) && u.push((n && !d && !h ? o.map(n) : o).join(", ") + " {" + p.join(" ") + "}");
    }
    for (let o in e)
      s(i(o), e[o], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let e = Z0[Q0] || 1;
    return Z0[Q0] = e + 1, Wd + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, r, n) {
    let i = e[Ud], s = n && n.nonce;
    i ? s && i.setNonce(s) : i = new j$(e, s), i.mount(Array.isArray(r) ? r : [r]);
  }
}
let e1 = /* @__PURE__ */ new Map();
class j$ {
  constructor(e, r) {
    let n = e.ownerDocument || e, i = n.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = e1.get(n);
      if (s)
        return e.adoptedStyleSheets = [s.sheet, ...e.adoptedStyleSheets], e[Ud] = s;
      this.sheet = new i.CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets], e1.set(n, this);
    } else {
      this.styleTag = n.createElement("style"), r && this.styleTag.setAttribute("nonce", r);
      let s = e.head || e;
      s.insertBefore(this.styleTag, s.firstChild);
    }
    this.modules = [], e[Ud] = this;
  }
  mount(e) {
    let r = this.sheet, n = 0, i = 0;
    for (let s = 0; s < e.length; s++) {
      let o = e[s], l = this.modules.indexOf(o);
      if (l < i && l > -1 && (this.modules.splice(l, 1), i--, l = -1), l == -1) {
        if (this.modules.splice(i++, 0, o), r)
          for (let u = 0; u < o.rules.length; u++)
            r.insertRule(o.rules[u], n++);
      } else {
        for (; i < l; )
          n += this.modules[i++].rules.length;
        n += o.rules.length, i++;
      }
    }
    if (!r) {
      let s = "";
      for (let o = 0; o < this.modules.length; o++)
        s += this.modules[o].getRules() + `
`;
      this.styleTag.textContent = s;
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var Li = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Ga = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, q$ = typeof navigator < "u" && /Mac/.test(navigator.platform), W$ = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var At = 0; At < 10; At++)
  Li[48 + At] = Li[96 + At] = String(At);
for (var At = 1; At <= 24; At++)
  Li[At + 111] = "F" + At;
for (var At = 65; At <= 90; At++)
  Li[At] = String.fromCharCode(At + 32), Ga[At] = String.fromCharCode(At);
for (var bp in Li)
  Ga.hasOwnProperty(bp) || (Ga[bp] = Li[bp]);
function U$(t) {
  var e = q$ && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || W$ && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", r = !e && t.key || (t.shiftKey ? Ga : Li)[t.keyCode] || t.key || "Unidentified";
  return r == "Esc" && (r = "Escape"), r == "Del" && (r = "Delete"), r == "Left" && (r = "ArrowLeft"), r == "Up" && (r = "ArrowUp"), r == "Right" && (r = "ArrowRight"), r == "Down" && (r = "ArrowDown"), r;
}
function lc(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function Hd(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function H$(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function $u(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return Hd(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function Co(t) {
  return t.nodeType == 3 ? bs(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function Ma(t, e, r, n) {
  return r ? t1(t, e, r, n, -1) || t1(t, e, r, n, 1) : !1;
}
function Xa(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function t1(t, e, r, n, i) {
  for (; ; ) {
    if (t == r && e == n)
      return !0;
    if (e == (i < 0 ? 0 : Vn(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let s = t.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = Xa(t) + (i < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = i < 0 ? Vn(t) : 0;
    } else
      return !1;
  }
}
function Vn(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function xh(t, e) {
  let r = e ? t.left : t.right;
  return { left: r, right: r, top: t.top, bottom: t.bottom };
}
function V$(t) {
  return {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function dA(t, e) {
  let r = e.width / t.offsetWidth, n = e.height / t.offsetHeight;
  return (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.width - t.offsetWidth) < 1) && (r = 1), (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.height - t.offsetHeight) < 1) && (n = 1), { scaleX: r, scaleY: n };
}
function z$(t, e, r, n, i, s, o, l) {
  let u = t.ownerDocument, h = u.defaultView || window;
  for (let p = t, d = !1; p && !d; )
    if (p.nodeType == 1) {
      let m, y = p == u.body, D = 1, b = 1;
      if (y)
        m = V$(h);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(p).position) && (d = !0), p.scrollHeight <= p.clientHeight && p.scrollWidth <= p.clientWidth) {
          p = p.assignedSlot || p.parentNode;
          continue;
        }
        let x = p.getBoundingClientRect();
        ({ scaleX: D, scaleY: b } = dA(p, x)), m = {
          left: x.left,
          right: x.left + p.clientWidth * D,
          top: x.top,
          bottom: x.top + p.clientHeight * b
        };
      }
      let C = 0, A = 0;
      if (i == "nearest")
        e.top < m.top ? (A = -(m.top - e.top + o), r > 0 && e.bottom > m.bottom + A && (A = e.bottom - m.bottom + A + o)) : e.bottom > m.bottom && (A = e.bottom - m.bottom + o, r < 0 && e.top - A < m.top && (A = -(m.top + A - e.top + o)));
      else {
        let x = e.bottom - e.top, E = m.bottom - m.top;
        A = (i == "center" && x <= E ? e.top + x / 2 - E / 2 : i == "start" || i == "center" && r < 0 ? e.top - o : e.bottom - E + o) - m.top;
      }
      if (n == "nearest" ? e.left < m.left ? (C = -(m.left - e.left + s), r > 0 && e.right > m.right + C && (C = e.right - m.right + C + s)) : e.right > m.right && (C = e.right - m.right + s, r < 0 && e.left < m.left + C && (C = -(m.left + C - e.left + s))) : C = (n == "center" ? e.left + (e.right - e.left) / 2 - (m.right - m.left) / 2 : n == "start" == l ? e.left - s : e.right - (m.right - m.left) + s) - m.left, C || A)
        if (y)
          h.scrollBy(C, A);
        else {
          let x = 0, E = 0;
          if (A) {
            let k = p.scrollTop;
            p.scrollTop += A / b, E = (p.scrollTop - k) * b;
          }
          if (C) {
            let k = p.scrollLeft;
            p.scrollLeft += C / D, x = (p.scrollLeft - k) * D;
          }
          e = {
            left: e.left - x,
            top: e.top - E,
            right: e.right - x,
            bottom: e.bottom - E
          }, x && Math.abs(x - C) < 1 && (n = "nearest"), E && Math.abs(E - A) < 1 && (i = "nearest");
        }
      if (y)
        break;
      p = p.assignedSlot || p.parentNode;
    } else if (p.nodeType == 11)
      p = p.host;
    else
      break;
}
function J$(t) {
  let e = t.ownerDocument;
  for (let r = t.parentNode; r && r != e.body; )
    if (r.nodeType == 1) {
      if (r.scrollHeight > r.clientHeight || r.scrollWidth > r.clientWidth)
        return r;
      r = r.assignedSlot || r.parentNode;
    } else if (r.nodeType == 11)
      r = r.host;
    else
      break;
  return null;
}
class K$ {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: r, focusNode: n } = e;
    this.set(r, Math.min(e.anchorOffset, r ? Vn(r) : 0), n, Math.min(e.focusOffset, n ? Vn(n) : 0));
  }
  set(e, r, n, i) {
    this.anchorNode = e, this.anchorOffset = r, this.focusNode = n, this.focusOffset = i;
  }
}
let zs = null;
function fA(t) {
  if (t.setActive)
    return t.setActive();
  if (zs)
    return t.focus(zs);
  let e = [];
  for (let r = t; r && (e.push(r, r.scrollTop, r.scrollLeft), r != r.ownerDocument); r = r.parentNode)
    ;
  if (t.focus(zs == null ? {
    get preventScroll() {
      return zs = { preventScroll: !0 }, !0;
    }
  } : void 0), !zs) {
    zs = !1;
    for (let r = 0; r < e.length; ) {
      let n = e[r++], i = e[r++], s = e[r++];
      n.scrollTop != i && (n.scrollTop = i), n.scrollLeft != s && (n.scrollLeft = s);
    }
  }
}
let r1;
function bs(t, e, r = e) {
  let n = r1 || (r1 = document.createRange());
  return n.setEnd(t, r), n.setStart(t, e), n;
}
function uo(t, e, r) {
  let n = { key: e, code: e, keyCode: r, which: r, cancelable: !0 }, i = new KeyboardEvent("keydown", n);
  i.synthetic = !0, t.dispatchEvent(i);
  let s = new KeyboardEvent("keyup", n);
  return s.synthetic = !0, t.dispatchEvent(s), i.defaultPrevented || s.defaultPrevented;
}
function G$(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function mA(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function X$(t, e) {
  let r = e.focusNode, n = e.focusOffset;
  if (!r || e.anchorNode != r || e.anchorOffset != n)
    return !1;
  for (n = Math.min(n, Vn(r)); ; )
    if (n) {
      if (r.nodeType != 1)
        return !1;
      let i = r.childNodes[n - 1];
      i.contentEditable == "false" ? n-- : (r = i, n = Vn(r));
    } else {
      if (r == t)
        return !0;
      n = Xa(r), r = r.parentNode;
    }
}
function gA(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
class Rt {
  constructor(e, r, n = !0) {
    this.node = e, this.offset = r, this.precise = n;
  }
  static before(e, r) {
    return new Rt(e.parentNode, Xa(e), r);
  }
  static after(e, r) {
    return new Rt(e.parentNode, Xa(e) + 1, r);
  }
}
const hg = [];
class et {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let r = this.posAtStart;
    for (let n of this.children) {
      if (n == e)
        return r;
      r += n.length + n.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, r) {
    if (this.flags & 2) {
      let n = this.dom, i = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = i ? i.nextSibling : n.firstChild)) {
            let l = et.get(s);
            (!l || !l.parent && l.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, r), o.flags &= -8;
        }
        if (s = i ? i.nextSibling : n.firstChild, r && !r.written && r.node == n && s != o.dom && (r.written = !0), o.dom.parentNode == n)
          for (; s && s != o.dom; )
            s = n1(s);
        else
          n.insertBefore(o.dom, s);
        i = o.dom;
      }
      for (s = i ? i.nextSibling : n.firstChild, s && r && r.node == n && (r.written = !0); s; )
        s = n1(s);
    } else if (this.flags & 1)
      for (let n of this.children)
        n.flags & 7 && (n.sync(e, r), n.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, r) {
    let n;
    if (e == this.dom)
      n = this.dom.childNodes[r];
    else {
      let i = Vn(e) == 0 ? 0 : r == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? i = -1 : i = 1), e = s;
      }
      i < 0 ? n = e : n = e.nextSibling;
    }
    if (n == this.dom.firstChild)
      return 0;
    for (; n && !et.get(n); )
      n = n.nextSibling;
    if (!n)
      return this.length;
    for (let i = 0, s = 0; ; i++) {
      let o = this.children[i];
      if (o.dom == n)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, r, n = 0) {
    let i = -1, s = -1, o = -1, l = -1;
    for (let u = 0, h = n, p = n; u < this.children.length; u++) {
      let d = this.children[u], m = h + d.length;
      if (h < e && m > r)
        return d.domBoundsAround(e, r, h);
      if (m >= e && i == -1 && (i = u, s = h), h > r && d.dom.parentNode == this.dom) {
        o = u, l = p;
        break;
      }
      p = m, h = m + d.breakAfter;
    }
    return {
      from: s,
      to: l < 0 ? n + this.length : l,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let r = this.parent; r; r = r.parent) {
      if (e && (r.flags |= 2), r.flags & 1)
        return;
      r.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let r = e.parent;
      if (!r)
        return e;
      e = r;
    }
  }
  replaceChildren(e, r, n = hg) {
    this.markDirty();
    for (let i = e; i < r; i++) {
      let s = this.children[i];
      s.parent == this && n.indexOf(s) < 0 && s.destroy();
    }
    this.children.splice(e, r - e, ...n);
    for (let i = 0; i < n.length; i++)
      n[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new yA(this.children, e, this.children.length);
  }
  childPos(e, r = 1) {
    return this.childCursor().findPos(e, r);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, r, n, i, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
et.prototype.breakAfter = 0;
function n1(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class yA {
  constructor(e, r, n) {
    this.children = e, this.pos = r, this.i = n, this.off = 0;
  }
  findPos(e, r = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (r > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let n = this.children[--this.i];
      this.pos -= n.length + n.breakAfter;
    }
  }
}
function DA(t, e, r, n, i, s, o, l, u) {
  let { children: h } = t, p = h.length ? h[e] : null, d = s.length ? s[s.length - 1] : null, m = d ? d.breakAfter : o;
  if (!(e == n && p && !o && !m && s.length < 2 && p.merge(r, i, s.length ? d : null, r == 0, l, u))) {
    if (n < h.length) {
      let y = h[n];
      y && (i < y.length || y.breakAfter && (d != null && d.breakAfter)) ? (e == n && (y = y.split(i), i = 0), !m && d && y.merge(0, i, d, !0, 0, u) ? s[s.length - 1] = y : ((i || y.children.length && !y.children[0].length) && y.merge(0, i, null, !1, 0, u), s.push(y))) : y != null && y.breakAfter && (d ? d.breakAfter = 1 : o = 1), n++;
    }
    for (p && (p.breakAfter = o, r > 0 && (!o && s.length && p.merge(r, p.length, s[0], !1, l, 0) ? p.breakAfter = s.shift().breakAfter : (r < p.length || p.children.length && p.children[p.children.length - 1].length == 0) && p.merge(r, p.length, null, !1, l, 0), e++)); e < n && s.length; )
      if (h[n - 1].become(s[s.length - 1]))
        n--, s.pop(), u = s.length ? 0 : l;
      else if (h[e].become(s[0]))
        e++, s.shift(), l = s.length ? 0 : u;
      else
        break;
    !s.length && e && n < h.length && !h[e - 1].breakAfter && h[n].merge(0, 0, h[e - 1], !1, l, u) && e--, (e < n || s.length) && t.replaceChildren(e, n, s);
  }
}
function xA(t, e, r, n, i, s) {
  let o = t.childCursor(), { i: l, off: u } = o.findPos(r, 1), { i: h, off: p } = o.findPos(e, -1), d = e - r;
  for (let m of n)
    d += m.length;
  t.length += d, DA(t, h, p, l, u, n, 0, i, s);
}
let dr = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Vd = typeof document < "u" ? document : { documentElement: { style: {} } };
const zd = /* @__PURE__ */ /Edge\/(\d+)/.exec(dr.userAgent), bA = /* @__PURE__ */ /MSIE \d/.test(dr.userAgent), Jd = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(dr.userAgent), bh = !!(bA || Jd || zd), i1 = !bh && /* @__PURE__ */ /gecko\/(\d+)/i.test(dr.userAgent), vp = !bh && /* @__PURE__ */ /Chrome\/(\d+)/.exec(dr.userAgent), s1 = "webkitFontSmoothing" in Vd.documentElement.style, vA = !bh && /* @__PURE__ */ /Apple Computer/.test(dr.vendor), o1 = vA && (/* @__PURE__ */ /Mobile\/\w+/.test(dr.userAgent) || dr.maxTouchPoints > 2);
var me = {
  mac: o1 || /* @__PURE__ */ /Mac/.test(dr.platform),
  windows: /* @__PURE__ */ /Win/.test(dr.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(dr.platform),
  ie: bh,
  ie_version: bA ? Vd.documentMode || 6 : Jd ? +Jd[1] : zd ? +zd[1] : 0,
  gecko: i1,
  gecko_version: i1 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(dr.userAgent) || [0, 0])[1] : 0,
  chrome: !!vp,
  chrome_version: vp ? +vp[1] : 0,
  ios: o1,
  android: /* @__PURE__ */ /Android\b/.test(dr.userAgent),
  webkit: s1,
  safari: vA,
  webkit_version: s1 ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: Vd.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const Y$ = 256;
class zn extends et {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, r) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (r && r.node == this.dom && (r.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, r, n) {
    return this.flags & 8 || n && (!(n instanceof zn) || this.length - (r - e) + n.length > Y$ || n.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (n ? n.text : "") + this.text.slice(r), this.markDirty(), !0);
  }
  split(e) {
    let r = new zn(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), r.flags |= this.flags & 8, r;
  }
  localPosFromDOM(e, r) {
    return e == this.dom ? r : r ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Rt(this.dom, e);
  }
  domBoundsAround(e, r, n) {
    return { from: n, to: n + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, r) {
    return Q$(this.dom, e, r);
  }
}
class Jn extends et {
  constructor(e, r = [], n = 0) {
    super(), this.mark = e, this.children = r, this.length = n;
    for (let i of r)
      i.setParent(this);
  }
  setAttrs(e) {
    if (mA(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let r in this.mark.attrs)
        e.setAttribute(r, this.mark.attrs[r]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, r);
  }
  merge(e, r, n, i, s, o) {
    return n && (!(n instanceof Jn && n.mark.eq(this.mark)) || e && s <= 0 || r < this.length && o <= 0) ? !1 : (xA(this, e, r, n ? n.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let r = [], n = 0, i = -1, s = 0;
    for (let l of this.children) {
      let u = n + l.length;
      u > e && r.push(n < e ? l.split(e - n) : l), i < 0 && n >= e && (i = s), n = u, s++;
    }
    let o = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new Jn(this.mark, r, o);
  }
  domAtPos(e) {
    return CA(this, e);
  }
  coordsAt(e, r) {
    return EA(this, e, r);
  }
}
function Q$(t, e, r) {
  let n = t.nodeValue.length;
  e > n && (e = n);
  let i = e, s = e, o = 0;
  e == 0 && r < 0 || e == n && r >= 0 ? me.chrome || me.gecko || (e ? (i--, o = 1) : s < n && (s++, o = -1)) : r < 0 ? i-- : s < n && s++;
  let l = bs(t, i, s).getClientRects();
  if (!l.length)
    return null;
  let u = l[(o ? o < 0 : r >= 0) ? 0 : l.length - 1];
  return me.safari && !o && u.width == 0 && (u = Array.prototype.find.call(l, (h) => h.width) || u), o ? xh(u, o < 0) : u || null;
}
class vi extends et {
  static create(e, r, n) {
    return new vi(e, r, n);
  }
  constructor(e, r, n) {
    super(), this.widget = e, this.length = r, this.side = n, this.prevWidget = null;
  }
  split(e) {
    let r = vi.create(this.widget, this.length - e, this.side);
    return this.length -= e, r;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, r, n, i, s, o) {
    return n && (!(n instanceof vi) || !this.widget.compare(n.widget) || e > 0 && s <= 0 || r < this.length && o <= 0) ? !1 : (this.length = e + (n ? n.length : 0) + (this.length - r), !0);
  }
  become(e) {
    return e instanceof vi && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Ue.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: r } = e, n = r && r.state.doc, i = this.posAtStart;
    return n ? n.slice(i, i + this.length) : Ue.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Rt.before(this.dom) : Rt.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, r) {
    let n = this.widget.coordsAt(this.dom, e, r);
    if (n)
      return n;
    let i = this.dom.getClientRects(), s = null;
    if (!i.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let l = o ? i.length - 1 : 0; s = i[l], !(e > 0 ? l == 0 : l == i.length - 1 || s.top < s.bottom); l += o ? -1 : 1)
      ;
    return xh(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Ao extends et {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Ao && e.side == this.side;
  }
  split() {
    return new Ao(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Rt.before(this.dom) : Rt.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Ue.empty;
  }
  get isHidden() {
    return !0;
  }
}
zn.prototype.children = vi.prototype.children = Ao.prototype.children = hg;
function CA(t, e) {
  let r = t.dom, { children: n } = t, i = 0;
  for (let s = 0; i < n.length; i++) {
    let o = n[i], l = s + o.length;
    if (!(l == s && o.getSide() <= 0)) {
      if (e > s && e < l && o.dom.parentNode == r)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = l;
    }
  }
  for (let s = i; s > 0; s--) {
    let o = n[s - 1];
    if (o.dom.parentNode == r)
      return o.domAtPos(o.length);
  }
  for (let s = i; s < n.length; s++) {
    let o = n[s];
    if (o.dom.parentNode == r)
      return o.domAtPos(0);
  }
  return new Rt(r, 0);
}
function AA(t, e, r) {
  let n, { children: i } = t;
  r > 0 && e instanceof Jn && i.length && (n = i[i.length - 1]) instanceof Jn && n.mark.eq(e.mark) ? AA(n, e.children[0], r - 1) : (i.push(e), e.setParent(t)), t.length += e.length;
}
function EA(t, e, r) {
  let n = null, i = -1, s = null, o = -1;
  function l(h, p) {
    for (let d = 0, m = 0; d < h.children.length && m <= p; d++) {
      let y = h.children[d], D = m + y.length;
      D >= p && (y.children.length ? l(y, p - m) : (!s || s.isHidden && r > 0) && (D > p || m == D && y.getSide() > 0) ? (s = y, o = p - m) : (m < p || m == D && y.getSide() < 0 && !y.isHidden) && (n = y, i = p - m)), m = D;
    }
  }
  l(t, e);
  let u = (r < 0 ? n : s) || n || s;
  return u ? u.coordsAt(Math.max(0, u == n ? i : o), r) : Z$(t);
}
function Z$(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let r = Co(e);
  return r[r.length - 1] || null;
}
function Kd(t, e) {
  for (let r in t)
    r == "class" && e.class ? e.class += " " + t.class : r == "style" && e.style ? e.style += ";" + t.style : e[r] = t[r];
  return e;
}
const a1 = /* @__PURE__ */ Object.create(null);
function pg(t, e, r) {
  if (t == e)
    return !0;
  t || (t = a1), e || (e = a1);
  let n = Object.keys(t), i = Object.keys(e);
  if (n.length - (r && n.indexOf(r) > -1 ? 1 : 0) != i.length - (r && i.indexOf(r) > -1 ? 1 : 0))
    return !1;
  for (let s of n)
    if (s != r && (i.indexOf(s) == -1 || t[s] !== e[s]))
      return !1;
  return !0;
}
function Gd(t, e, r) {
  let n = !1;
  if (e)
    for (let i in e)
      r && i in r || (n = !0, i == "style" ? t.style.cssText = "" : t.removeAttribute(i));
  if (r)
    for (let i in r)
      e && e[i] == r[i] || (n = !0, i == "style" ? t.style.cssText = r[i] : t.setAttribute(i, r[i]));
  return n;
}
function eR(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r = 0; r < t.attributes.length; r++) {
    let n = t.attributes[r];
    e[n.name] = n.value;
  }
  return e;
}
class ft extends et {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, r, n, i, s, o) {
    if (n) {
      if (!(n instanceof ft))
        return !1;
      this.dom || n.transferDOM(this);
    }
    return i && this.setDeco(n ? n.attrs : null), xA(this, e, r, n ? n.children.slice() : [], s, o), !0;
  }
  split(e) {
    let r = new ft();
    if (r.breakAfter = this.breakAfter, this.length == 0)
      return r;
    let { i: n, off: i } = this.childPos(e);
    i && (r.append(this.children[n].split(i), 0), this.children[n].merge(i, this.children[n].length, null, !1, 0, 0), n++);
    for (let s = n; s < this.children.length; s++)
      r.append(this.children[s], 0);
    for (; n > 0 && this.children[n - 1].length == 0; )
      this.children[--n].destroy();
    return this.children.length = n, this.markDirty(), this.length = e, r;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    pg(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, r) {
    AA(this, e, r);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let r = e.spec.attributes, n = e.spec.class;
    r && (this.attrs = Kd(r, this.attrs || {})), n && (this.attrs = Kd({ class: n }, this.attrs || {}));
  }
  domAtPos(e) {
    return CA(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    var n;
    this.dom ? this.flags & 4 && (mA(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Gd(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, r);
    let i = this.dom.lastChild;
    for (; i && et.get(i) instanceof Jn; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((n = et.get(i)) === null || n === void 0 ? void 0 : n.isEditable) == !1 && (!me.ios || !this.children.some((s) => s instanceof zn))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, r;
    for (let n of this.children) {
      if (!(n instanceof zn) || /[^ -~]/.test(n.text))
        return null;
      let i = Co(n.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, r = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: r
    } : null;
  }
  coordsAt(e, r) {
    let n = EA(this, e, r);
    if (!this.children.length && n && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, s = n.bottom - n.top;
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let o = (s - i.textHeight) / 2;
        return { top: n.top + o, bottom: n.bottom - o, left: n.left, right: n.left };
      }
    }
    return n;
  }
  become(e) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(e, r) {
    for (let n = 0, i = 0; n < e.children.length; n++) {
      let s = e.children[n], o = i + s.length;
      if (o >= r) {
        if (s instanceof ft)
          return s;
        if (o > r)
          break;
      }
      i = o + s.breakAfter;
    }
    return null;
  }
}
class Si extends et {
  constructor(e, r, n) {
    super(), this.widget = e, this.length = r, this.deco = n, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, r, n, i, s, o) {
    return n && (!(n instanceof Si) || !this.widget.compare(n.widget) || e > 0 && s <= 0 || r < this.length && o <= 0) ? !1 : (this.length = e + (n ? n.length : 0) + (this.length - r), !0);
  }
  domAtPos(e) {
    return e == 0 ? Rt.before(this.dom) : Rt.after(this.dom, e == this.length);
  }
  split(e) {
    let r = this.length - e;
    this.length = e;
    let n = new Si(this.widget, r, this.deco);
    return n.breakAfter = this.breakAfter, n;
  }
  get children() {
    return hg;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Ue.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Si && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, r) {
    return this.widget.coordsAt(this.dom, e, r);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: r, endSide: n } = this.deco;
    return r == n ? !1 : e < 0 ? r < 0 : n > 0;
  }
}
class ni {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, r) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, r, n) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Xt = /* @__PURE__ */ function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
}(Xt || (Xt = {}));
class xe extends xs {
  constructor(e, r, n, i) {
    super(), this.startSide = e, this.endSide = r, this.widget = n, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new wl(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let r = Math.max(-1e4, Math.min(1e4, e.side || 0)), n = !!e.block;
    return r += n && !e.inlineOrder ? r > 0 ? 3e8 : -4e8 : r > 0 ? 1e8 : -1e8, new _i(e, r, r, n, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let r = !!e.block, n, i;
    if (e.isBlockGap)
      n = -5e8, i = 4e8;
    else {
      let { start: s, end: o } = wA(e, r);
      n = (s ? r ? -3e8 : -1 : 5e8) - 1, i = (o ? r ? 2e8 : 1 : -6e8) + 1;
    }
    return new _i(e, n, i, r, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Sl(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, r = !1) {
    return _e.of(e, r);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
xe.none = _e.empty;
class wl extends xe {
  constructor(e) {
    let { start: r, end: n } = wA(e);
    super(r ? -1 : 5e8, n ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var r, n;
    return this == e || e instanceof wl && this.tagName == e.tagName && (this.class || ((r = this.attrs) === null || r === void 0 ? void 0 : r.class)) == (e.class || ((n = e.attrs) === null || n === void 0 ? void 0 : n.class)) && pg(this.attrs, e.attrs, "class");
  }
  range(e, r = e) {
    if (e >= r)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, r);
  }
}
wl.prototype.point = !1;
class Sl extends xe {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Sl && this.spec.class == e.spec.class && pg(this.spec.attributes, e.spec.attributes);
  }
  range(e, r = e) {
    if (r != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, r);
  }
}
Sl.prototype.mapMode = Kt.TrackBefore;
Sl.prototype.point = !0;
class _i extends xe {
  constructor(e, r, n, i, s, o) {
    super(r, n, s, e), this.block = i, this.isReplace = o, this.mapMode = i ? r <= 0 ? Kt.TrackBefore : Kt.TrackAfter : Kt.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Xt.WidgetRange : this.startSide <= 0 ? Xt.WidgetBefore : Xt.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof _i && tR(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, r = e) {
    if (this.isReplace && (e > r || e == r && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && r != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, r);
  }
}
_i.prototype.point = !0;
function wA(t, e = !1) {
  let { inclusiveStart: r, inclusiveEnd: n } = t;
  return r == null && (r = t.inclusive), n == null && (n = t.inclusive), { start: r ?? e, end: n ?? e };
}
function tR(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function Xd(t, e, r, n = 0) {
  let i = r.length - 1;
  i >= 0 && r[i] + n >= t ? r[i] = Math.max(r[i], e) : r.push(t, e);
}
class Oa {
  constructor(e, r, n, i) {
    this.doc = e, this.pos = r, this.end = n, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = r;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof Si && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new ft()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(ou(new Ao(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Si) && this.getLine();
  }
  buildText(e, r, n) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let i = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(r.slice(r.length - n)), this.getLine().append(ou(new zn(this.text.slice(this.textOff, this.textOff + i)), r), n), this.atCursorPos = !0, this.textOff += i, e -= i, n = 0;
    }
  }
  span(e, r, n, i) {
    this.buildText(r - e, n, i), this.pos = r, this.openStart < 0 && (this.openStart = i);
  }
  point(e, r, n, i, s, o) {
    if (this.disallowBlockEffectsFor[o] && n instanceof _i) {
      if (n.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (r > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = r - e;
    if (n instanceof _i)
      if (n.block)
        n.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Si(n.widget || new l1("div"), l, n));
      else {
        let u = vi.create(n.widget || new l1("span"), l, l ? 0 : n.startSide), h = this.atCursorPos && !u.isEditable && s <= i.length && (e < r || n.startSide > 0), p = !u.isEditable && (e < r || s > i.length || n.startSide <= 0), d = this.getLine();
        this.pendingBuffer == 2 && !h && !u.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), h && (d.append(ou(new Ao(1), i), s), s = i.length + Math.max(0, s - i.length)), d.append(ou(u, i), s), this.atCursorPos = p, this.pendingBuffer = p ? e < r || s > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(n);
    l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = r), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, r, n, i, s) {
    let o = new Oa(e, r, n, s);
    return o.openEnd = _e.spans(i, r, n, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function ou(t, e) {
  for (let r of e)
    t = new Jn(r, [t], t.length);
  return t;
}
class l1 extends ni {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
var tt = /* @__PURE__ */ function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
}(tt || (tt = {}));
const vs = tt.LTR, dg = tt.RTL;
function SA(t) {
  let e = [];
  for (let r = 0; r < t.length; r++)
    e.push(1 << +t[r]);
  return e;
}
const rR = /* @__PURE__ */ SA("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), nR = /* @__PURE__ */ SA("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Yd = /* @__PURE__ */ Object.create(null), cn = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), r = /* @__PURE__ */ t.charCodeAt(1);
  Yd[e] = r, Yd[r] = -e;
}
function TA(t) {
  return t <= 247 ? rR[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? nR[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const iR = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Ci {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? dg : vs;
  }
  /**
  @internal
  */
  constructor(e, r, n) {
    this.from = e, this.to = r, this.level = n;
  }
  /**
  @internal
  */
  side(e, r) {
    return this.dir == r == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, r) {
    return e == (this.dir == r);
  }
  /**
  @internal
  */
  static find(e, r, n, i) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l.from <= r && l.to >= r) {
        if (l.level == n)
          return o;
        (s < 0 || (i != 0 ? i < 0 ? l.from < r : l.to > r : e[s].level > l.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function kA(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++) {
    let n = t[r], i = e[r];
    if (n.from != i.from || n.to != i.to || n.direction != i.direction || !kA(n.inner, i.inner))
      return !1;
  }
  return !0;
}
const Ge = [];
function sR(t, e, r, n, i) {
  for (let s = 0; s <= n.length; s++) {
    let o = s ? n[s - 1].to : e, l = s < n.length ? n[s].from : r, u = s ? 256 : i;
    for (let h = o, p = u, d = u; h < l; h++) {
      let m = TA(t.charCodeAt(h));
      m == 512 ? m = p : m == 8 && d == 4 && (m = 16), Ge[h] = m == 4 ? 2 : m, m & 7 && (d = m), p = m;
    }
    for (let h = o, p = u, d = u; h < l; h++) {
      let m = Ge[h];
      if (m == 128)
        h < l - 1 && p == Ge[h + 1] && p & 24 ? m = Ge[h] = p : Ge[h] = 256;
      else if (m == 64) {
        let y = h + 1;
        for (; y < l && Ge[y] == 64; )
          y++;
        let D = h && p == 8 || y < r && Ge[y] == 8 ? d == 1 ? 1 : 8 : 256;
        for (let b = h; b < y; b++)
          Ge[b] = D;
        h = y - 1;
      } else
        m == 8 && d == 1 && (Ge[h] = 1);
      p = m, m & 7 && (d = m);
    }
  }
}
function oR(t, e, r, n, i) {
  let s = i == 1 ? 2 : 1;
  for (let o = 0, l = 0, u = 0; o <= n.length; o++) {
    let h = o ? n[o - 1].to : e, p = o < n.length ? n[o].from : r;
    for (let d = h, m, y, D; d < p; d++)
      if (y = Yd[m = t.charCodeAt(d)])
        if (y < 0) {
          for (let b = l - 3; b >= 0; b -= 3)
            if (cn[b + 1] == -y) {
              let C = cn[b + 2], A = C & 2 ? i : C & 4 ? C & 1 ? s : i : 0;
              A && (Ge[d] = Ge[cn[b]] = A), l = b;
              break;
            }
        } else {
          if (cn.length == 189)
            break;
          cn[l++] = d, cn[l++] = m, cn[l++] = u;
        }
      else if ((D = Ge[d]) == 2 || D == 1) {
        let b = D == i;
        u = b ? 0 : 1;
        for (let C = l - 3; C >= 0; C -= 3) {
          let A = cn[C + 2];
          if (A & 2)
            break;
          if (b)
            cn[C + 2] |= 2;
          else {
            if (A & 4)
              break;
            cn[C + 2] |= 4;
          }
        }
      }
  }
}
function aR(t, e, r, n) {
  for (let i = 0, s = n; i <= r.length; i++) {
    let o = i ? r[i - 1].to : t, l = i < r.length ? r[i].from : e;
    for (let u = o; u < l; ) {
      let h = Ge[u];
      if (h == 256) {
        let p = u + 1;
        for (; ; )
          if (p == l) {
            if (i == r.length)
              break;
            p = r[i++].to, l = i < r.length ? r[i].from : e;
          } else if (Ge[p] == 256)
            p++;
          else
            break;
        let d = s == 1, m = (p < e ? Ge[p] : n) == 1, y = d == m ? d ? 1 : 2 : n;
        for (let D = p, b = i, C = b ? r[b - 1].to : t; D > u; )
          D == C && (D = r[--b].from, C = b ? r[b - 1].to : t), Ge[--D] = y;
        u = p;
      } else
        s = h, u++;
    }
  }
}
function Qd(t, e, r, n, i, s, o) {
  let l = n % 2 ? 2 : 1;
  if (n % 2 == i % 2)
    for (let u = e, h = 0; u < r; ) {
      let p = !0, d = !1;
      if (h == s.length || u < s[h].from) {
        let b = Ge[u];
        b != l && (p = !1, d = b == 16);
      }
      let m = !p && l == 1 ? [] : null, y = p ? n : n + 1, D = u;
      e:
        for (; ; )
          if (h < s.length && D == s[h].from) {
            if (d)
              break e;
            let b = s[h];
            if (!p)
              for (let C = b.to, A = h + 1; ; ) {
                if (C == r)
                  break e;
                if (A < s.length && s[A].from == C)
                  C = s[A++].to;
                else {
                  if (Ge[C] == l)
                    break e;
                  break;
                }
              }
            if (h++, m)
              m.push(b);
            else {
              b.from > u && o.push(new Ci(u, b.from, y));
              let C = b.direction == vs != !(y % 2);
              Zd(t, C ? n + 1 : n, i, b.inner, b.from, b.to, o), u = b.to;
            }
            D = b.to;
          } else {
            if (D == r || (p ? Ge[D] != l : Ge[D] == l))
              break;
            D++;
          }
      m ? Qd(t, u, D, n + 1, i, m, o) : u < D && o.push(new Ci(u, D, y)), u = D;
    }
  else
    for (let u = r, h = s.length; u > e; ) {
      let p = !0, d = !1;
      if (!h || u > s[h - 1].to) {
        let b = Ge[u - 1];
        b != l && (p = !1, d = b == 16);
      }
      let m = !p && l == 1 ? [] : null, y = p ? n : n + 1, D = u;
      e:
        for (; ; )
          if (h && D == s[h - 1].to) {
            if (d)
              break e;
            let b = s[--h];
            if (!p)
              for (let C = b.from, A = h; ; ) {
                if (C == e)
                  break e;
                if (A && s[A - 1].to == C)
                  C = s[--A].from;
                else {
                  if (Ge[C - 1] == l)
                    break e;
                  break;
                }
              }
            if (m)
              m.push(b);
            else {
              b.to < u && o.push(new Ci(b.to, u, y));
              let C = b.direction == vs != !(y % 2);
              Zd(t, C ? n + 1 : n, i, b.inner, b.from, b.to, o), u = b.from;
            }
            D = b.from;
          } else {
            if (D == e || (p ? Ge[D - 1] != l : Ge[D - 1] == l))
              break;
            D--;
          }
      m ? Qd(t, D, u, n + 1, i, m, o) : D < u && o.push(new Ci(D, u, y)), u = D;
    }
}
function Zd(t, e, r, n, i, s, o) {
  let l = e % 2 ? 2 : 1;
  sR(t, i, s, n, l), oR(t, i, s, n, l), aR(i, s, n, l), Qd(t, i, s, e, r, n, o);
}
function lR(t, e, r) {
  if (!t)
    return [new Ci(0, 0, e == dg ? 1 : 0)];
  if (e == vs && !r.length && !iR.test(t))
    return FA(t.length);
  if (r.length)
    for (; t.length > Ge.length; )
      Ge[Ge.length] = 256;
  let n = [], i = e == vs ? 0 : 1;
  return Zd(t, i, i, r, 0, t.length, n), n;
}
function FA(t) {
  return [new Ci(0, t, 0)];
}
let PA = "";
function uR(t, e, r, n, i) {
  var s;
  let o = n.head - t.from, l = Ci.find(e, o, (s = n.bidiLevel) !== null && s !== void 0 ? s : -1, n.assoc), u = e[l], h = u.side(i, r);
  if (o == h) {
    let m = l += i ? 1 : -1;
    if (m < 0 || m >= e.length)
      return null;
    u = e[l = m], o = u.side(!i, r), h = u.side(i, r);
  }
  let p = Tt(t.text, o, u.forward(i, r));
  (p < u.from || p > u.to) && (p = h), PA = t.text.slice(Math.min(o, p), Math.max(o, p));
  let d = l == (i ? e.length - 1 : 0) ? null : e[l + (i ? 1 : -1)];
  return d && p == h && d.level + (i ? 0 : 1) < u.level ? K.cursor(d.side(!i, r) + t.from, d.forward(i, r) ? 1 : -1, d.level) : K.cursor(p + t.from, u.forward(i, r) ? -1 : 1, u.level);
}
function cR(t, e, r) {
  for (let n = e; n < r; n++) {
    let i = TA(t.charCodeAt(n));
    if (i == 1)
      return vs;
    if (i == 2 || i == 4)
      return dg;
  }
  return vs;
}
const BA = /* @__PURE__ */ ge.define(), IA = /* @__PURE__ */ ge.define(), NA = /* @__PURE__ */ ge.define(), MA = /* @__PURE__ */ ge.define(), ef = /* @__PURE__ */ ge.define(), OA = /* @__PURE__ */ ge.define(), LA = /* @__PURE__ */ ge.define(), _A = /* @__PURE__ */ ge.define({
  combine: (t) => t.some((e) => e)
}), $A = /* @__PURE__ */ ge.define({
  combine: (t) => t.some((e) => e)
});
class co {
  constructor(e, r = "nearest", n = "nearest", i = 5, s = 5, o = !1) {
    this.range = e, this.y = r, this.x = n, this.yMargin = i, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new co(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new co(K.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const au = /* @__PURE__ */ Se.define({ map: (t, e) => t.map(e) });
function Br(t, e, r) {
  let n = t.facet(MA);
  n.length ? n[0](e) : window.onerror ? window.onerror(String(e), r, void 0, void 0, e) : r ? console.error(r + ":", e) : console.error(e);
}
const vh = /* @__PURE__ */ ge.define({ combine: (t) => t.length ? t[0] : !0 });
let hR = 0;
const ma = /* @__PURE__ */ ge.define();
class ct {
  constructor(e, r, n, i, s) {
    this.id = e, this.create = r, this.domEventHandlers = n, this.domEventObservers = i, this.extension = s(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, r) {
    const { eventHandlers: n, eventObservers: i, provide: s, decorations: o } = r || {};
    return new ct(hR++, e, n, i, (l) => {
      let u = [ma.of(l)];
      return o && u.push(Ya.of((h) => {
        let p = h.plugin(l);
        return p ? o(p) : xe.none;
      })), s && u.push(s(l)), u;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, r) {
    return ct.define((n) => new e(n), r);
  }
}
class Cp {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let r = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(r);
          } catch (n) {
            if (Br(r.state, n, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (r) {
        Br(e.state, r, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var r;
    if (!((r = this.value) === null || r === void 0) && r.destroy)
      try {
        this.value.destroy();
      } catch (n) {
        Br(e.state, n, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const RA = /* @__PURE__ */ ge.define(), fg = /* @__PURE__ */ ge.define(), Ya = /* @__PURE__ */ ge.define(), jA = /* @__PURE__ */ ge.define(), mg = /* @__PURE__ */ ge.define(), qA = /* @__PURE__ */ ge.define();
function u1(t, e) {
  let r = t.state.facet(qA);
  if (!r.length)
    return r;
  let n = r.map((s) => s instanceof Function ? s(t) : s), i = [];
  return _e.spans(n, e.from, e.to, {
    point() {
    },
    span(s, o, l, u) {
      let h = s - e.from, p = o - e.from, d = i;
      for (let m = l.length - 1; m >= 0; m--, u--) {
        let y = l[m].spec.bidiIsolate, D;
        if (y == null && (y = cR(e.text, h, p)), u > 0 && d.length && (D = d[d.length - 1]).to == h && D.direction == y)
          D.to = p, d = D.inner;
        else {
          let b = { from: h, to: p, direction: y, inner: [] };
          d.push(b), d = b.inner;
        }
      }
    }
  }), i;
}
const WA = /* @__PURE__ */ ge.define();
function UA(t) {
  let e = 0, r = 0, n = 0, i = 0;
  for (let s of t.state.facet(WA)) {
    let o = s(t);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (r = Math.max(r, o.right)), o.top != null && (n = Math.max(n, o.top)), o.bottom != null && (i = Math.max(i, o.bottom)));
  }
  return { left: e, right: r, top: n, bottom: i };
}
const ga = /* @__PURE__ */ ge.define();
class Ir {
  constructor(e, r, n, i) {
    this.fromA = e, this.toA = r, this.fromB = n, this.toB = i;
  }
  join(e) {
    return new Ir(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let r = e.length, n = this;
    for (; r > 0; r--) {
      let i = e[r - 1];
      if (!(i.fromA > n.toA)) {
        if (i.toA < n.fromA)
          break;
        n = n.join(i), e.splice(r - 1, 1);
      }
    }
    return e.splice(r, 0, n), e;
  }
  static extendWithRanges(e, r) {
    if (r.length == 0)
      return e;
    let n = [];
    for (let i = 0, s = 0, o = 0, l = 0; ; i++) {
      let u = i == e.length ? null : e[i], h = o - l, p = u ? u.fromB : 1e9;
      for (; s < r.length && r[s] < p; ) {
        let d = r[s], m = r[s + 1], y = Math.max(l, d), D = Math.min(p, m);
        if (y <= D && new Ir(y + h, D + h, y, D).addToSet(n), m > p)
          break;
        s += 2;
      }
      if (!u)
        return n;
      new Ir(u.fromA, u.toA, u.fromB, u.toB).addToSet(n), o = u.toA, l = u.toB;
    }
  }
}
class uc {
  constructor(e, r, n) {
    this.view = e, this.state = r, this.transactions = n, this.flags = 0, this.startState = e.state, this.changes = mt.empty(this.startState.doc.length);
    for (let s of n)
      this.changes = this.changes.compose(s.changes);
    let i = [];
    this.changes.iterChangedRanges((s, o, l, u) => i.push(new Ir(s, o, l, u))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new uc(e, r, n);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class c1 extends et {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new ft()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Ir(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var r;
    let n = e.changedRanges;
    this.minWidth > 0 && n.length && (n.every(({ fromA: h, toA: p }) => p < this.minWidthFrom || h > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let i = -1;
    this.view.inputState.composing >= 0 && (!((r = this.domChanged) === null || r === void 0) && r.newSel ? i = this.domChanged.newSel.head : !DR(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let s = i > -1 ? dR(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: h, to: p } = this.hasComposition;
      n = new Ir(h, p, e.changes.mapPos(h, -1), e.changes.mapPos(p, 1)).addToSet(n.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (me.ie || me.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, l = this.updateDeco(), u = gR(o, l, e.changes);
    return n = Ir.extendWithRanges(n, u), !(this.flags & 7) && n.length == 0 ? !1 : (this.updateInner(n, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, r, n) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, r, n);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = me.chrome || me.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof Si && o.widget instanceof h1 && s.push(o.dom);
    i.updateGaps(s);
  }
  updateChildren(e, r, n) {
    let i = n ? n.range.addToSet(e.slice()) : e, s = this.childCursor(r);
    for (let o = i.length - 1; ; o--) {
      let l = o >= 0 ? i[o] : null;
      if (!l)
        break;
      let { fromA: u, toA: h, fromB: p, toB: d } = l, m, y, D, b;
      if (n && n.range.fromB < d && n.range.toB > p) {
        let k = Oa.build(this.view.state.doc, p, n.range.fromB, this.decorations, this.dynamicDecorationMap), w = Oa.build(this.view.state.doc, n.range.toB, d, this.decorations, this.dynamicDecorationMap);
        y = k.breakAtStart, D = k.openStart, b = w.openEnd;
        let T = this.compositionView(n);
        w.breakAtStart ? T.breakAfter = 1 : w.content.length && T.merge(T.length, T.length, w.content[0], !1, w.openStart, 0) && (T.breakAfter = w.content[0].breakAfter, w.content.shift()), k.content.length && T.merge(0, 0, k.content[k.content.length - 1], !0, 0, k.openEnd) && k.content.pop(), m = k.content.concat(T).concat(w.content);
      } else
        ({ content: m, breakAtStart: y, openStart: D, openEnd: b } = Oa.build(this.view.state.doc, p, d, this.decorations, this.dynamicDecorationMap));
      let { i: C, off: A } = s.findPos(h, 1), { i: x, off: E } = s.findPos(u, -1);
      DA(this, x, E, C, A, m, y, D, b);
    }
    n && this.fixCompositionDOM(n);
  }
  compositionView(e) {
    let r = new zn(e.text.nodeValue);
    r.flags |= 8;
    for (let { deco: i } of e.marks)
      r = new Jn(i, [r], r.length);
    let n = new ft();
    return n.append(r, 0), n;
  }
  fixCompositionDOM(e) {
    let r = (s, o) => {
      o.flags |= 8 | (o.children.some(
        (u) => u.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let l = et.get(s);
      l && l != o && (l.dom = null), o.setDOM(s);
    }, n = this.childPos(e.range.fromB, 1), i = this.children[n.i];
    r(e.line, i);
    for (let s = e.marks.length - 1; s >= -1; s--)
      n = i.childPos(n.off, 1), i = i.children[n.i], r(s >= 0 ? e.marks[s].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, r = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let n = this.view.root.activeElement, i = n == this.dom, s = !i && $u(this.dom, this.view.observer.selectionRange) && !(n && this.dom.contains(n));
    if (!(i || r || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, u = this.moveToLine(this.domAtPos(l.anchor)), h = l.empty ? u : this.moveToLine(this.domAtPos(l.head));
    if (me.gecko && l.empty && !this.hasComposition && pR(u)) {
      let d = document.createTextNode("");
      this.view.observer.ignore(() => u.node.insertBefore(d, u.node.childNodes[u.offset] || null)), u = h = new Rt(d, 0), o = !0;
    }
    let p = this.view.observer.selectionRange;
    (o || !p.focusNode || (!Ma(u.node, u.offset, p.anchorNode, p.anchorOffset) || !Ma(h.node, h.offset, p.focusNode, p.focusOffset)) && !this.suppressWidgetCursorChange(p, l)) && (this.view.observer.ignore(() => {
      me.android && me.chrome && this.dom.contains(p.focusNode) && yR(p.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let d = lc(this.view.root);
      if (d)
        if (l.empty) {
          if (me.gecko) {
            let m = fR(u.node, u.offset);
            if (m && m != 3) {
              let y = VA(u.node, u.offset, m == 1 ? 1 : -1);
              y && (u = new Rt(y.node, y.offset));
            }
          }
          d.collapse(u.node, u.offset), l.bidiLevel != null && d.caretBidiLevel !== void 0 && (d.caretBidiLevel = l.bidiLevel);
        } else if (d.extend) {
          d.collapse(u.node, u.offset);
          try {
            d.extend(h.node, h.offset);
          } catch {
          }
        } else {
          let m = document.createRange();
          l.anchor > l.head && ([u, h] = [h, u]), m.setEnd(h.node, h.offset), m.setStart(u.node, u.offset), d.removeAllRanges(), d.addRange(m);
        }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), n && n.focus());
    }), this.view.observer.setSelectionRange(u, h)), this.impreciseAnchor = u.precise ? null : new Rt(p.anchorNode, p.anchorOffset), this.impreciseHead = h.precise ? null : new Rt(p.focusNode, p.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, r) {
    return this.hasComposition && r.empty && Ma(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == r.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, r = e.state.selection.main, n = lc(e.root), { anchorNode: i, anchorOffset: s } = e.observer.selectionRange;
    if (!n || !r.empty || !r.assoc || !n.modify)
      return;
    let o = ft.find(this, r.head);
    if (!o)
      return;
    let l = o.posAtStart;
    if (r.head == l || r.head == l + o.length)
      return;
    let u = this.coordsAt(r.head, -1), h = this.coordsAt(r.head, 1);
    if (!u || !h || u.bottom > h.top)
      return;
    let p = this.domAtPos(r.head + r.assoc);
    n.collapse(p.node, p.offset), n.modify("move", r.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let d = e.observer.selectionRange;
    e.docView.posFromDOM(d.anchorNode, d.anchorOffset) != r.from && n.collapse(i, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let r = this.dom, n;
    if (e.node != r)
      return e;
    for (let i = e.offset; !n && i < r.childNodes.length; i++) {
      let s = et.get(r.childNodes[i]);
      s instanceof ft && (n = s.domAtPos(0));
    }
    for (let i = e.offset - 1; !n && i >= 0; i--) {
      let s = et.get(r.childNodes[i]);
      s instanceof ft && (n = s.domAtPos(s.length));
    }
    return n ? new Rt(n.node, n.offset, !0) : e;
  }
  nearest(e) {
    for (let r = e; r; ) {
      let n = et.get(r);
      if (n && n.rootView == this)
        return n;
      r = r.parentNode;
    }
    return null;
  }
  posFromDOM(e, r) {
    let n = this.nearest(e);
    if (!n)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return n.localPosFromDOM(e, r) + n.posAtStart;
  }
  domAtPos(e) {
    let { i: r, off: n } = this.childCursor().findPos(e, -1);
    for (; r < this.children.length - 1; ) {
      let i = this.children[r];
      if (n < i.length || i instanceof ft)
        break;
      r++, n = 0;
    }
    return this.children[r].domAtPos(n);
  }
  coordsAt(e, r) {
    let n = null, i = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let l = this.children[o], u = s - l.breakAfter, h = u - l.length;
      if (u < e)
        break;
      h <= e && (h < e || l.covers(-1)) && (u > e || l.covers(1)) && (!n || l instanceof ft && !(n instanceof ft && r >= 0)) && (n = l, i = h), s = h;
    }
    return n ? n.coordsAt(e - i, r) : null;
  }
  coordsForChar(e) {
    let { i: r, off: n } = this.childPos(e, 1), i = this.children[r];
    if (!(i instanceof ft))
      return null;
    for (; i.children.length; ) {
      let { i: l, off: u } = i.childPos(n, 1);
      for (; ; l++) {
        if (l == i.children.length)
          return null;
        if ((i = i.children[l]).length)
          break;
      }
      n = u;
    }
    if (!(i instanceof zn))
      return null;
    let s = Tt(i.text, n);
    if (s == n)
      return null;
    let o = bs(i.dom, n, s).getClientRects();
    for (let l = 0; l < o.length; l++) {
      let u = o[l];
      if (l == o.length - 1 || u.top < u.bottom && u.left < u.right)
        return u;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let r = [], { from: n, to: i } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, u = this.view.textDirection == tt.LTR;
    for (let h = 0, p = 0; p < this.children.length; p++) {
      let d = this.children[p], m = h + d.length;
      if (m > i)
        break;
      if (h >= n) {
        let y = d.dom.getBoundingClientRect();
        if (r.push(y.height), o) {
          let D = d.dom.lastChild, b = D ? Co(D) : [];
          if (b.length) {
            let C = b[b.length - 1], A = u ? C.right - y.left : y.right - C.left;
            A > l && (l = A, this.minWidth = s, this.minWidthFrom = h, this.minWidthTo = m);
          }
        }
      }
      h = m + d.breakAfter;
    }
    return r;
  }
  textDirectionAt(e) {
    let { i: r } = this.childPos(e, 1);
    return getComputedStyle(this.children[r].dom).direction == "rtl" ? tt.RTL : tt.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof ft) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), r, n, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = Co(e.firstChild)[0];
      r = e.getBoundingClientRect().height, n = s ? s.width / 27 : 7, i = s ? s.height : r, e.remove();
    }), { lineHeight: r, charWidth: n, textHeight: i };
  }
  childCursor(e = this.length) {
    let r = this.children.length;
    return r && (e -= this.children[--r].length), new yA(this.children, e, r);
  }
  computeBlockGapDeco() {
    let e = [], r = this.view.viewState;
    for (let n = 0, i = 0; ; i++) {
      let s = i == r.viewports.length ? null : r.viewports[i], o = s ? s.from - 1 : this.length;
      if (o > n) {
        let l = (r.lineBlockAt(o).bottom - r.lineBlockAt(n).top) / this.view.scaleY;
        e.push(xe.replace({
          widget: new h1(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(n, o));
      }
      if (!s)
        break;
      n = s.to + 1;
    }
    return xe.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(Ya).map((i, s) => (this.dynamicDecorationMap[s] = typeof i == "function") ? i(this.view) : i), r = !1, n = this.view.state.facet(jA).map((i, s) => {
      let o = typeof i == "function";
      return o && (r = !0), o ? i(this.view) : i;
    });
    n.length && (this.dynamicDecorationMap[e.length] = r, e.push(_e.join(n)));
    for (let i = e.length; i < e.length + 3; i++)
      this.dynamicDecorationMap[i] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let h = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = h.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    let { range: r } = e, n = this.coordsAt(r.head, r.empty ? r.assoc : r.head > r.anchor ? -1 : 1), i;
    if (!n)
      return;
    !r.empty && (i = this.coordsAt(r.anchor, r.anchor > r.head ? -1 : 1)) && (n = {
      left: Math.min(n.left, i.left),
      top: Math.min(n.top, i.top),
      right: Math.max(n.right, i.right),
      bottom: Math.max(n.bottom, i.bottom)
    });
    let s = UA(this.view), o = {
      left: n.left - s.left,
      top: n.top - s.top,
      right: n.right + s.right,
      bottom: n.bottom + s.bottom
    }, { offsetWidth: l, offsetHeight: u } = this.view.scrollDOM;
    z$(this.view.scrollDOM, o, r.head < r.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, l), -l), Math.max(Math.min(e.yMargin, u), -u), this.view.textDirection == tt.LTR);
  }
}
function pR(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
class h1 extends ni {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
function HA(t, e) {
  let r = t.observer.selectionRange, n = r.focusNode && VA(r.focusNode, r.focusOffset, 0);
  if (!n)
    return null;
  let i = e - n.offset;
  return { from: i, to: i + n.node.nodeValue.length, node: n.node };
}
function dR(t, e, r) {
  let n = HA(t, r);
  if (!n)
    return null;
  let { node: i, from: s, to: o } = n, l = i.nodeValue;
  if (/[\n\r]/.test(l) || t.state.doc.sliceString(n.from, n.to) != l)
    return null;
  let u = e.invertedDesc, h = new Ir(u.mapPos(s), u.mapPos(o), s, o), p = [];
  for (let d = i.parentNode; ; d = d.parentNode) {
    let m = et.get(d);
    if (m instanceof Jn)
      p.push({ node: d, deco: m.mark });
    else {
      if (m instanceof ft || d.nodeName == "DIV" && d.parentNode == t.contentDOM)
        return { range: h, text: i, marks: p, line: d };
      if (d != t.contentDOM)
        p.push({ node: d, deco: new wl({
          inclusive: !0,
          attributes: eR(d),
          tagName: d.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function VA(t, e, r) {
  if (r <= 0)
    for (let n = t, i = e; ; ) {
      if (n.nodeType == 3)
        return { node: n, offset: i };
      if (n.nodeType == 1 && i > 0)
        n = n.childNodes[i - 1], i = Vn(n);
      else
        break;
    }
  if (r >= 0)
    for (let n = t, i = e; ; ) {
      if (n.nodeType == 3)
        return { node: n, offset: i };
      if (n.nodeType == 1 && i < n.childNodes.length && r >= 0)
        n = n.childNodes[i], i = 0;
      else
        break;
    }
  return null;
}
function fR(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let mR = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, r) {
    Xd(e, r, this.changes);
  }
  comparePoint(e, r) {
    Xd(e, r, this.changes);
  }
};
function gR(t, e, r) {
  let n = new mR();
  return _e.compare(t, e, r, n), n.changes;
}
function yR(t, e) {
  for (let r = t; r && r != e; r = r.assignedSlot || r.parentNode)
    if (r.nodeType == 1 && r.contentEditable == "false")
      return !0;
  return !1;
}
function DR(t, e) {
  let r = !1;
  return e && t.iterChangedRanges((n, i) => {
    n < e.to && i > e.from && (r = !0);
  }), r;
}
function xR(t, e, r = 1) {
  let n = t.charCategorizer(e), i = t.doc.lineAt(e), s = e - i.from;
  if (i.length == 0)
    return K.cursor(e);
  s == 0 ? r = 1 : s == i.length && (r = -1);
  let o = s, l = s;
  r < 0 ? o = Tt(i.text, s, !1) : l = Tt(i.text, s);
  let u = n(i.text.slice(o, l));
  for (; o > 0; ) {
    let h = Tt(i.text, o, !1);
    if (n(i.text.slice(h, o)) != u)
      break;
    o = h;
  }
  for (; l < i.length; ) {
    let h = Tt(i.text, l);
    if (n(i.text.slice(l, h)) != u)
      break;
    l = h;
  }
  return K.range(o + i.from, l + i.from);
}
function bR(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function vR(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function Ap(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function p1(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function d1(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function tf(t, e, r) {
  let n, i, s, o, l = !1, u, h, p, d;
  for (let D = t.firstChild; D; D = D.nextSibling) {
    let b = Co(D);
    for (let C = 0; C < b.length; C++) {
      let A = b[C];
      i && Ap(i, A) && (A = p1(d1(A, i.bottom), i.top));
      let x = bR(e, A), E = vR(r, A);
      if (x == 0 && E == 0)
        return D.nodeType == 3 ? f1(D, e, r) : tf(D, e, r);
      if (!n || o > E || o == E && s > x) {
        n = D, i = A, s = x, o = E;
        let k = E ? r < A.top ? -1 : 1 : x ? e < A.left ? -1 : 1 : 0;
        l = !k || (k > 0 ? C < b.length - 1 : C > 0);
      }
      x == 0 ? r > A.bottom && (!p || p.bottom < A.bottom) ? (u = D, p = A) : r < A.top && (!d || d.top > A.top) && (h = D, d = A) : p && Ap(p, A) ? p = d1(p, A.bottom) : d && Ap(d, A) && (d = p1(d, A.top));
    }
  }
  if (p && p.bottom >= r ? (n = u, i = p) : d && d.top <= r && (n = h, i = d), !n)
    return { node: t, offset: 0 };
  let m = Math.max(i.left, Math.min(i.right, e));
  if (n.nodeType == 3)
    return f1(n, m, r);
  if (l && n.contentEditable != "false")
    return tf(n, m, r);
  let y = Array.prototype.indexOf.call(t.childNodes, n) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: t, offset: y };
}
function f1(t, e, r) {
  let n = t.nodeValue.length, i = -1, s = 1e9, o = 0;
  for (let l = 0; l < n; l++) {
    let u = bs(t, l, l + 1).getClientRects();
    for (let h = 0; h < u.length; h++) {
      let p = u[h];
      if (p.top == p.bottom)
        continue;
      o || (o = e - p.left);
      let d = (p.top > r ? p.top - r : r - p.bottom) - 1;
      if (p.left - 1 <= e && p.right + 1 >= e && d < s) {
        let m = e >= (p.left + p.right) / 2, y = m;
        if ((me.chrome || me.gecko) && bs(t, l).getBoundingClientRect().left == p.right && (y = !m), d <= 0)
          return { node: t, offset: l + (y ? 1 : 0) };
        i = l + (y ? 1 : 0), s = d;
      }
    }
  }
  return { node: t, offset: i > -1 ? i : o > 0 ? t.nodeValue.length : 0 };
}
function zA(t, e, r, n = -1) {
  var i, s;
  let o = t.contentDOM.getBoundingClientRect(), l = o.top + t.viewState.paddingTop, u, { docHeight: h } = t.viewState, { x: p, y: d } = e, m = d - l;
  if (m < 0)
    return 0;
  if (m > h)
    return t.state.doc.length;
  for (let k = t.viewState.heightOracle.textHeight / 2, w = !1; u = t.elementAtHeight(m), u.type != Xt.Text; )
    for (; m = n > 0 ? u.bottom + k : u.top - k, !(m >= 0 && m <= h); ) {
      if (w)
        return r ? null : 0;
      w = !0, n = -n;
    }
  d = l + m;
  let y = u.from;
  if (y < t.viewport.from)
    return t.viewport.from == 0 ? 0 : r ? null : m1(t, o, u, p, d);
  if (y > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : r ? null : m1(t, o, u, p, d);
  let D = t.dom.ownerDocument, b = t.root.elementFromPoint ? t.root : D, C = b.elementFromPoint(p, d);
  C && !t.contentDOM.contains(C) && (C = null), C || (p = Math.max(o.left + 1, Math.min(o.right - 1, p)), C = b.elementFromPoint(p, d), C && !t.contentDOM.contains(C) && (C = null));
  let A, x = -1;
  if (C && ((i = t.docView.nearest(C)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (D.caretPositionFromPoint) {
      let k = D.caretPositionFromPoint(p, d);
      k && ({ offsetNode: A, offset: x } = k);
    } else if (D.caretRangeFromPoint) {
      let k = D.caretRangeFromPoint(p, d);
      k && ({ startContainer: A, startOffset: x } = k, (!t.contentDOM.contains(A) || me.safari && CR(A, x, p) || me.chrome && AR(A, x, p)) && (A = void 0));
    }
  }
  if (!A || !t.docView.dom.contains(A)) {
    let k = ft.find(t.docView, y);
    if (!k)
      return m > u.top + u.height / 2 ? u.to : u.from;
    ({ node: A, offset: x } = tf(k.dom, p, d));
  }
  let E = t.docView.nearest(A);
  if (!E)
    return null;
  if (E.isWidget && ((s = E.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let k = E.dom.getBoundingClientRect();
    return e.y < k.top || e.y <= k.bottom && e.x <= (k.left + k.right) / 2 ? E.posAtStart : E.posAtEnd;
  } else
    return E.localPosFromDOM(A, x) + E.posAtStart;
}
function m1(t, e, r, n, i) {
  let s = Math.round((n - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && r.height > t.defaultLineHeight * 1.5) {
    let l = t.viewState.heightOracle.textHeight, u = Math.floor((i - r.top - (t.defaultLineHeight - l) * 0.5) / l);
    s += u * t.viewState.heightOracle.lineLength;
  }
  let o = t.state.sliceDoc(r.from, r.to);
  return r.from + qd(o, s, t.state.tabSize);
}
function CR(t, e, r) {
  let n;
  if (t.nodeType != 3 || e != (n = t.nodeValue.length))
    return !1;
  for (let i = t.nextSibling; i; i = i.nextSibling)
    if (i.nodeType != 1 || i.nodeName != "BR")
      return !1;
  return bs(t, n - 1, n).getBoundingClientRect().left > r;
}
function AR(t, e, r) {
  if (e != 0)
    return !1;
  for (let i = t; ; ) {
    let s = i.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != i)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    i = s;
  }
  let n = t.nodeType == 1 ? t.getBoundingClientRect() : bs(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return r - n.left > 5;
}
function rf(t, e) {
  let r = t.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    for (let n of r.type)
      if (n.to > e || n.to == e && (n.to == r.to || n.type == Xt.Text))
        return n;
  }
  return r;
}
function ER(t, e, r, n) {
  let i = rf(t, e.head), s = !n || i.type != Xt.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (s) {
    let o = t.dom.getBoundingClientRect(), l = t.textDirectionAt(i.from), u = t.posAtCoords({
      x: r == (l == tt.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (u != null)
      return K.cursor(u, r ? -1 : 1);
  }
  return K.cursor(r ? i.to : i.from, r ? -1 : 1);
}
function g1(t, e, r, n) {
  let i = t.state.doc.lineAt(e.head), s = t.bidiSpans(i), o = t.textDirectionAt(i.from);
  for (let l = e, u = null; ; ) {
    let h = uR(i, s, o, l, r), p = PA;
    if (!h) {
      if (i.number == (r ? t.state.doc.lines : 1))
        return l;
      p = `
`, i = t.state.doc.line(i.number + (r ? 1 : -1)), s = t.bidiSpans(i), h = t.visualLineSide(i, !r);
    }
    if (u) {
      if (!u(p))
        return l;
    } else {
      if (!n)
        return h;
      u = n(p);
    }
    l = h;
  }
}
function wR(t, e, r) {
  let n = t.state.charCategorizer(e), i = n(r);
  return (s) => {
    let o = n(s);
    return i == nt.Space && (i = o), i == o;
  };
}
function SR(t, e, r, n) {
  let i = e.head, s = r ? 1 : -1;
  if (i == (r ? t.state.doc.length : 0))
    return K.cursor(i, e.assoc);
  let o = e.goalColumn, l, u = t.contentDOM.getBoundingClientRect(), h = t.coordsAtPos(i, e.assoc || -1), p = t.documentTop;
  if (h)
    o == null && (o = h.left - u.left), l = s < 0 ? h.top : h.bottom;
  else {
    let y = t.viewState.lineBlockAt(i);
    o == null && (o = Math.min(u.right - u.left, t.defaultCharacterWidth * (i - y.from))), l = (s < 0 ? y.top : y.bottom) + p;
  }
  let d = u.left + o, m = n ?? t.viewState.heightOracle.textHeight >> 1;
  for (let y = 0; ; y += 10) {
    let D = l + (m + y) * s, b = zA(t, { x: d, y: D }, !1, s);
    if (D < u.top || D > u.bottom || (s < 0 ? b < i : b > i)) {
      let C = t.docView.coordsForChar(b), A = !C || D < C.top ? -1 : 1;
      return K.cursor(b, A, void 0, o);
    }
  }
}
function Ru(t, e, r) {
  for (; ; ) {
    let n = 0;
    for (let i of t)
      i.between(e - 1, e + 1, (s, o, l) => {
        if (e > s && e < o) {
          let u = n || r || (e - s < o - e ? -1 : 1);
          e = u < 0 ? s : o, n = u;
        }
      });
    if (!n)
      return e;
  }
}
function Ep(t, e, r) {
  let n = Ru(t.state.facet(mg).map((i) => i(t)), r.from, e.head > r.from ? -1 : 1);
  return n == r.from ? r : K.cursor(n, n < r.from ? 1 : -1);
}
class TR {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, me.safari && e.contentDOM.addEventListener("input", () => null), me.gecko && UR(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !OR(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, r) {
    let n = this.handlers[e];
    if (n) {
      for (let i of n.observers)
        i(this.view, r);
      for (let i of n.handlers) {
        if (r.defaultPrevented)
          break;
        if (i(this.view, r)) {
          r.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let r = kR(e), n = this.handlers, i = this.view.contentDOM;
    for (let s in r)
      if (s != "scroll") {
        let o = !r[s].handlers.length, l = n[s];
        l && o != !l.handlers.length && (i.removeEventListener(s, this.handleEvent), l = null), l || i.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in n)
      s != "scroll" && !r[s] && i.removeEventListener(s, this.handleEvent);
    this.handlers = r;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (e.keyCode != 27 && KA.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), me.android && me.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let r;
    return me.ios && !e.synthetic && !e.altKey && !e.metaKey && ((r = JA.find((n) => n.keyCode == e.keyCode)) && !e.ctrlKey || FR.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = r || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let e = this.pendingIOSKey;
    return e ? (this.pendingIOSKey = void 0, uo(this.view.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : me.safari && !me.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function y1(t, e) {
  return (r, n) => {
    try {
      return e.call(t, n, r);
    } catch (i) {
      Br(r.state, i);
    }
  };
}
function kR(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function r(n) {
    return e[n] || (e[n] = { observers: [], handlers: [] });
  }
  for (let n of t) {
    let i = n.spec;
    if (i && i.domEventHandlers)
      for (let s in i.domEventHandlers) {
        let o = i.domEventHandlers[s];
        o && r(s).handlers.push(y1(n.value, o));
      }
    if (i && i.domEventObservers)
      for (let s in i.domEventObservers) {
        let o = i.domEventObservers[s];
        o && r(s).observers.push(y1(n.value, o));
      }
  }
  for (let n in rn)
    r(n).handlers.push(rn[n]);
  for (let n in nn)
    r(n).observers.push(nn[n]);
  return e;
}
const JA = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], FR = "dthko", KA = [16, 17, 18, 20, 91, 92, 224, 225], lu = 6;
function uu(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function PR(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class BR {
  constructor(e, r, n, i) {
    this.view = e, this.startEvent = r, this.style = n, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = r, this.scrollParent = J$(e.contentDOM), this.atoms = e.state.facet(mg).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = r.shiftKey, this.multiple = e.state.facet(Ie.allowMultipleSelections) && IR(e, r), this.dragging = MR(e, r) && QA(r) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var r;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && PR(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let n = 0, i = 0, s = ((r = this.scrollParent) === null || r === void 0 ? void 0 : r.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, o = UA(this.view);
    e.clientX - o.left <= s.left + lu ? n = -uu(s.left - e.clientX) : e.clientX + o.right >= s.right - lu && (n = uu(e.clientX - s.right)), e.clientY - o.top <= s.top + lu ? i = -uu(s.top - e.clientY) : e.clientY + o.bottom >= s.bottom - lu && (i = uu(e.clientY - s.bottom)), this.setScrollSpeed(n, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, r) {
    this.scrollSpeed = { x: e, y: r }, e || r ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let r = null;
    for (let n = 0; n < e.ranges.length; n++) {
      let i = e.ranges[n], s = null;
      if (i.empty) {
        let o = Ru(this.atoms, i.from, 0);
        o != i.from && (s = K.cursor(o, -1));
      } else {
        let o = Ru(this.atoms, i.from, -1), l = Ru(this.atoms, i.to, 1);
        (o != i.from || l != i.to) && (s = K.range(i.from == i.anchor ? o : l, i.from == i.head ? o : l));
      }
      s && (r || (r = e.ranges.slice()), r[n] = s);
    }
    return r ? K.create(r, e.mainIndex) : e;
  }
  select(e) {
    let { view: r } = this, n = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !n.eq(r.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: n,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function IR(t, e) {
  let r = t.state.facet(BA);
  return r.length ? r[0](e) : me.mac ? e.metaKey : e.ctrlKey;
}
function NR(t, e) {
  let r = t.state.facet(IA);
  return r.length ? r[0](e) : me.mac ? !e.altKey : !e.ctrlKey;
}
function MR(t, e) {
  let { main: r } = t.state.selection;
  if (r.empty)
    return !1;
  let n = lc(t.root);
  if (!n || n.rangeCount == 0)
    return !0;
  let i = n.getRangeAt(0).getClientRects();
  for (let s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function OR(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let r = e.target, n; r != t.contentDOM; r = r.parentNode)
    if (!r || r.nodeType == 11 || (n = et.get(r)) && n.ignoreEvent(e))
      return !1;
  return !0;
}
const rn = /* @__PURE__ */ Object.create(null), nn = /* @__PURE__ */ Object.create(null), GA = me.ie && me.ie_version < 15 || me.ios && me.webkit_version < 604;
function LR(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let r = e.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(), setTimeout(() => {
    t.focus(), r.remove(), XA(t, r.value);
  }, 50);
}
function XA(t, e) {
  let { state: r } = t, n, i = 1, s = r.toText(e), o = s.lines == r.selection.ranges.length;
  if (nf != null && r.selection.ranges.every((u) => u.empty) && nf == s.toString()) {
    let u = -1;
    n = r.changeByRange((h) => {
      let p = r.doc.lineAt(h.from);
      if (p.from == u)
        return { range: h };
      u = p.from;
      let d = r.toText((o ? s.line(i++).text : e) + r.lineBreak);
      return {
        changes: { from: p.from, insert: d },
        range: K.cursor(h.from + d.length)
      };
    });
  } else
    o ? n = r.changeByRange((u) => {
      let h = s.line(i++);
      return {
        changes: { from: u.from, to: u.to, insert: h.text },
        range: K.cursor(u.from + h.length)
      };
    }) : n = r.replaceSelection(s);
  t.dispatch(n, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
nn.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
rn.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (t.inputState.lastEscPress = Date.now()), !1);
nn.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
nn.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
rn.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let r = null;
  for (let n of t.state.facet(NA))
    if (r = n(t, e), r)
      break;
  if (!r && e.button == 0 && (r = RR(t, e)), r) {
    let n = !t.hasFocus;
    t.inputState.startMouseSelection(new BR(t, e, r, n)), n && t.observer.ignore(() => fA(t.contentDOM));
    let i = t.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  }
  return !1;
};
function D1(t, e, r, n) {
  if (n == 1)
    return K.cursor(e, r);
  if (n == 2)
    return xR(t.state, e, r);
  {
    let i = ft.find(t.docView, e), s = t.state.doc.lineAt(i ? i.posAtEnd : e), o = i ? i.posAtStart : s.from, l = i ? i.posAtEnd : s.to;
    return l < t.state.doc.length && l == s.to && l++, K.range(o, l);
  }
}
let YA = (t, e) => t >= e.top && t <= e.bottom, x1 = (t, e, r) => YA(e, r) && t >= r.left && t <= r.right;
function _R(t, e, r, n) {
  let i = ft.find(t.docView, e);
  if (!i)
    return 1;
  let s = e - i.posAtStart;
  if (s == 0)
    return 1;
  if (s == i.length)
    return -1;
  let o = i.coordsAt(s, -1);
  if (o && x1(r, n, o))
    return -1;
  let l = i.coordsAt(s, 1);
  return l && x1(r, n, l) ? 1 : o && YA(n, o) ? -1 : 1;
}
function b1(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: r, bias: _R(t, r, e.clientX, e.clientY) };
}
const $R = me.ie && me.ie_version <= 11;
let v1 = null, C1 = 0, A1 = 0;
function QA(t) {
  if (!$R)
    return t.detail;
  let e = v1, r = A1;
  return v1 = t, A1 = Date.now(), C1 = !e || r > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (C1 + 1) % 3 : 1;
}
function RR(t, e) {
  let r = b1(t, e), n = QA(e), i = t.state.selection;
  return {
    update(s) {
      s.docChanged && (r.pos = s.changes.mapPos(r.pos), i = i.map(s.changes));
    },
    get(s, o, l) {
      let u = b1(t, s), h, p = D1(t, u.pos, u.bias, n);
      if (r.pos != u.pos && !o) {
        let d = D1(t, r.pos, r.bias, n), m = Math.min(d.from, p.from), y = Math.max(d.to, p.to);
        p = m < p.from ? K.range(m, y) : K.range(y, m);
      }
      return o ? i.replaceRange(i.main.extend(p.from, p.to)) : l && n == 1 && i.ranges.length > 1 && (h = jR(i, u.pos)) ? h : l ? i.addRange(p) : K.create([p]);
    }
  };
}
function jR(t, e) {
  for (let r = 0; r < t.ranges.length; r++) {
    let { from: n, to: i } = t.ranges[r];
    if (n <= e && i >= e)
      return K.create(t.ranges.slice(0, r).concat(t.ranges.slice(r + 1)), t.mainIndex == r ? 0 : t.mainIndex - (t.mainIndex > r ? 1 : 0));
  }
  return null;
}
rn.dragstart = (t, e) => {
  let { selection: { main: r } } = t.state;
  if (e.target.draggable) {
    let i = t.docView.nearest(e.target);
    if (i && i.isWidget) {
      let s = i.posAtStart, o = s + i.length;
      (s >= r.to || o <= r.from) && (r = K.range(s, o));
    }
  }
  let { inputState: n } = t;
  return n.mouseSelection && (n.mouseSelection.dragging = !0), n.draggedContent = r, e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(r.from, r.to)), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
rn.dragend = (t) => (t.inputState.draggedContent = null, !1);
function E1(t, e, r, n) {
  if (!r)
    return;
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = t.inputState, o = n && s && NR(t, e) ? { from: s.from, to: s.to } : null, l = { from: i, insert: r }, u = t.state.changes(o ? [o, l] : l);
  t.focus(), t.dispatch({
    changes: u,
    selection: { anchor: u.mapPos(i, -1), head: u.mapPos(i, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
rn.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let r = e.dataTransfer.files;
  if (r && r.length) {
    let n = Array(r.length), i = 0, s = () => {
      ++i == r.length && E1(t, e, n.filter((o) => o != null).join(t.state.lineBreak), !1);
    };
    for (let o = 0; o < r.length; o++) {
      let l = new FileReader();
      l.onerror = s, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (n[o] = l.result), s();
      }, l.readAsText(r[o]);
    }
    return !0;
  } else {
    let n = e.dataTransfer.getData("Text");
    if (n)
      return E1(t, e, n, !0), !0;
  }
  return !1;
};
rn.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let r = GA ? null : e.clipboardData;
  return r ? (XA(t, r.getData("text/plain") || r.getData("text/uri-text")), !0) : (LR(t), !1);
};
function qR(t, e) {
  let r = t.dom.parentNode;
  if (!r)
    return;
  let n = r.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.value = e, n.focus(), n.selectionEnd = e.length, n.selectionStart = 0, setTimeout(() => {
    n.remove(), t.focus();
  }, 50);
}
function WR(t) {
  let e = [], r = [], n = !1;
  for (let i of t.selection.ranges)
    i.empty || (e.push(t.sliceDoc(i.from, i.to)), r.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: s } of t.selection.ranges) {
      let o = t.doc.lineAt(s);
      o.number > i && (e.push(o.text), r.push({ from: o.from, to: Math.min(t.doc.length, o.to + 1) })), i = o.number;
    }
    n = !0;
  }
  return { text: e.join(t.lineBreak), ranges: r, linewise: n };
}
let nf = null;
rn.copy = rn.cut = (t, e) => {
  let { text: r, ranges: n, linewise: i } = WR(t.state);
  if (!r && !i)
    return !1;
  nf = i ? r : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: n,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = GA ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", r), !0) : (qR(t, r), !1);
};
const ZA = /* @__PURE__ */ Nn.define();
function eE(t, e) {
  let r = [];
  for (let n of t.facet(LA)) {
    let i = n(t, e);
    i && r.push(i);
  }
  return r ? t.update({ effects: r, annotations: ZA.of(!0) }) : null;
}
function tE(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let r = eE(t.state, e);
      r ? t.dispatch(r) : t.update([]);
    }
  }, 10);
}
nn.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), tE(t);
};
nn.blur = (t) => {
  t.observer.clearSelectionRange(), tE(t);
};
nn.compositionstart = nn.compositionupdate = (t) => {
  t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0);
};
nn.compositionend = (t) => {
  t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, me.chrome && me.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50);
};
nn.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
rn.beforeinput = (t, e) => {
  var r;
  let n;
  if (me.chrome && me.android && (n = JA.find((i) => i.inputType == e.inputType)) && (t.observer.delayAndroidKey(n.key, n.keyCode), n.key == "Backspace" || n.key == "Delete")) {
    let i = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > i + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return !1;
};
const w1 = /* @__PURE__ */ new Set();
function UR(t) {
  w1.has(t) || (w1.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const S1 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class HR {
  constructor(e) {
    this.lineWrapping = e, this.doc = Ue.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, r) {
    let n = this.doc.lineAt(r).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (n += Math.max(0, Math.ceil((r - e - n * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * n;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return S1.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let r = !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n];
      i < 0 ? n++ : this.heightSamples[Math.floor(i * 10)] || (r = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return r;
  }
  refresh(e, r, n, i, s, o) {
    let l = S1.indexOf(e) > -1, u = Math.round(r) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (this.lineWrapping = l, this.lineHeight = r, this.charWidth = n, this.textHeight = i, this.lineLength = s, u) {
      this.heightSamples = {};
      for (let h = 0; h < o.length; h++) {
        let p = o[h];
        p < 0 ? h++ : this.heightSamples[Math.floor(p * 10)] = !0;
      }
    }
    return u;
  }
}
class VR {
  constructor(e, r) {
    this.from = e, this.heights = r, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Dn {
  /**
  @internal
  */
  constructor(e, r, n, i, s) {
    this.from = e, this.length = r, this.top = n, this.height = i, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Xt.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof _i ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let r = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new Dn(this.from, this.length + e.length, this.top, this.height + e.height, r);
  }
}
var Ze = /* @__PURE__ */ function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
}(Ze || (Ze = {}));
const ju = 1e-3;
class Yt {
  constructor(e, r, n = 2) {
    this.length = e, this.height = r, this.flags = n;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, r) {
    this.height != r && (Math.abs(this.height - r) > ju && (e.heightChanged = !0), this.height = r);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, r, n) {
    return Yt.of(n);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, r) {
    r.push(this);
  }
  decomposeRight(e, r) {
    r.push(this);
  }
  applyChanges(e, r, n, i) {
    let s = this, o = n.doc;
    for (let l = i.length - 1; l >= 0; l--) {
      let { fromA: u, toA: h, fromB: p, toB: d } = i[l], m = s.lineAt(u, Ze.ByPosNoHeight, n.setDoc(r), 0, 0), y = m.to >= h ? m : s.lineAt(h, Ze.ByPosNoHeight, n, 0, 0);
      for (d += y.to - h, h = y.to; l > 0 && m.from <= i[l - 1].toA; )
        u = i[l - 1].fromA, p = i[l - 1].fromB, l--, u < m.from && (m = s.lineAt(u, Ze.ByPosNoHeight, n, 0, 0));
      p += m.from - u, u = m.from;
      let D = gg.build(n.setDoc(o), e, p, d);
      s = s.replace(u, h, D);
    }
    return s.updateHeight(n, 0);
  }
  static empty() {
    return new cr(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let r = 0, n = e.length, i = 0, s = 0;
    for (; ; )
      if (r == n)
        if (i > s * 2) {
          let l = e[r - 1];
          l.break ? e.splice(--r, 1, l.left, null, l.right) : e.splice(--r, 1, l.left, l.right), n += 1 + l.break, i -= l.size;
        } else if (s > i * 2) {
          let l = e[n];
          l.break ? e.splice(n, 1, l.left, null, l.right) : e.splice(n, 1, l.left, l.right), n += 2 + l.break, s -= l.size;
        } else
          break;
      else if (i < s) {
        let l = e[r++];
        l && (i += l.size);
      } else {
        let l = e[--n];
        l && (s += l.size);
      }
    let o = 0;
    return e[r - 1] == null ? (o = 1, r--) : e[r] == null && (o = 1, n++), new zR(Yt.of(e.slice(0, r)), o, Yt.of(e.slice(n)));
  }
}
Yt.prototype.size = 1;
class rE extends Yt {
  constructor(e, r, n) {
    super(e, r), this.deco = n;
  }
  blockAt(e, r, n, i) {
    return new Dn(i, this.length, n, this.height, this.deco || 0);
  }
  lineAt(e, r, n, i, s) {
    return this.blockAt(0, n, i, s);
  }
  forEachLine(e, r, n, i, s, o) {
    e <= s + this.length && r >= s && o(this.blockAt(0, n, i, s));
  }
  updateHeight(e, r = 0, n = !1, i) {
    return i && i.from <= r && i.more && this.setHeight(e, i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class cr extends rE {
  constructor(e, r) {
    super(e, r, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, r, n, i) {
    return new Dn(i, this.length, n, this.height, this.breaks);
  }
  replace(e, r, n) {
    let i = n[0];
    return n.length == 1 && (i instanceof cr || i instanceof vt && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof vt ? i = new cr(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : Yt.of(n);
  }
  updateHeight(e, r = 0, n = !1, i) {
    return i && i.from <= r && i.more ? this.setHeight(e, i.heights[i.index++]) : (n || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class vt extends Yt {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, r) {
    let n = e.doc.lineAt(r).number, i = e.doc.lineAt(r + this.length).number, s = i - n + 1, o, l = 0;
    if (e.lineWrapping) {
      let u = Math.min(this.height, e.lineHeight * s);
      o = u / s, this.length > s + 1 && (l = (this.height - u) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: n, lastLine: i, perLine: o, perChar: l };
  }
  blockAt(e, r, n, i) {
    let { firstLine: s, lastLine: o, perLine: l, perChar: u } = this.heightMetrics(r, i);
    if (r.lineWrapping) {
      let h = i + Math.round(Math.max(0, Math.min(1, (e - n) / this.height)) * this.length), p = r.doc.lineAt(h), d = l + p.length * u, m = Math.max(n, e - d / 2);
      return new Dn(p.from, p.length, m, d, 0);
    } else {
      let h = Math.max(0, Math.min(o - s, Math.floor((e - n) / l))), { from: p, length: d } = r.doc.line(s + h);
      return new Dn(p, d, n + l * h, l, 0);
    }
  }
  lineAt(e, r, n, i, s) {
    if (r == Ze.ByHeight)
      return this.blockAt(e, n, i, s);
    if (r == Ze.ByPosNoHeight) {
      let { from: y, to: D } = n.doc.lineAt(e);
      return new Dn(y, D - y, 0, 0, 0);
    }
    let { firstLine: o, perLine: l, perChar: u } = this.heightMetrics(n, s), h = n.doc.lineAt(e), p = l + h.length * u, d = h.number - o, m = i + l * d + u * (h.from - s - d);
    return new Dn(h.from, h.length, Math.max(i, Math.min(m, i + this.height - p)), p, 0);
  }
  forEachLine(e, r, n, i, s, o) {
    e = Math.max(e, s), r = Math.min(r, s + this.length);
    let { firstLine: l, perLine: u, perChar: h } = this.heightMetrics(n, s);
    for (let p = e, d = i; p <= r; ) {
      let m = n.doc.lineAt(p);
      if (p == e) {
        let D = m.number - l;
        d += u * D + h * (e - s - D);
      }
      let y = u + h * m.length;
      o(new Dn(m.from, m.length, d, y, 0)), d += y, p = m.to + 1;
    }
  }
  replace(e, r, n) {
    let i = this.length - r;
    if (i > 0) {
      let s = n[n.length - 1];
      s instanceof vt ? n[n.length - 1] = new vt(s.length + i) : n.push(null, new vt(i - 1));
    }
    if (e > 0) {
      let s = n[0];
      s instanceof vt ? n[0] = new vt(e + s.length) : n.unshift(new vt(e - 1), null);
    }
    return Yt.of(n);
  }
  decomposeLeft(e, r) {
    r.push(new vt(e - 1), null);
  }
  decomposeRight(e, r) {
    r.push(null, new vt(this.length - e - 1));
  }
  updateHeight(e, r = 0, n = !1, i) {
    let s = r + this.length;
    if (i && i.from <= r + this.length && i.more) {
      let o = [], l = Math.max(r, i.from), u = -1;
      for (i.from > r && o.push(new vt(i.from - r - 1).updateHeight(e, r)); l <= s && i.more; ) {
        let p = e.doc.lineAt(l).length;
        o.length && o.push(null);
        let d = i.heights[i.index++];
        u == -1 ? u = d : Math.abs(d - u) >= ju && (u = -2);
        let m = new cr(p, d);
        m.outdated = !1, o.push(m), l += p + 1;
      }
      l <= s && o.push(null, new vt(s - l).updateHeight(e, l));
      let h = Yt.of(o);
      return (u < 0 || Math.abs(h.height - this.height) >= ju || Math.abs(u - this.heightMetrics(e, r).perLine) >= ju) && (e.heightChanged = !0), h;
    } else
      (n || this.outdated) && (this.setHeight(e, e.heightForGap(r, r + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class zR extends Yt {
  constructor(e, r, n) {
    super(e.length + r + n.length, e.height + n.height, r | (e.outdated || n.outdated ? 2 : 0)), this.left = e, this.right = n, this.size = e.size + n.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, r, n, i) {
    let s = n + this.left.height;
    return e < s ? this.left.blockAt(e, r, n, i) : this.right.blockAt(e, r, s, i + this.left.length + this.break);
  }
  lineAt(e, r, n, i, s) {
    let o = i + this.left.height, l = s + this.left.length + this.break, u = r == Ze.ByHeight ? e < o : e < l, h = u ? this.left.lineAt(e, r, n, i, s) : this.right.lineAt(e, r, n, o, l);
    if (this.break || (u ? h.to < l : h.from > l))
      return h;
    let p = r == Ze.ByPosNoHeight ? Ze.ByPosNoHeight : Ze.ByPos;
    return u ? h.join(this.right.lineAt(l, p, n, o, l)) : this.left.lineAt(l, p, n, i, s).join(h);
  }
  forEachLine(e, r, n, i, s, o) {
    let l = i + this.left.height, u = s + this.left.length + this.break;
    if (this.break)
      e < u && this.left.forEachLine(e, r, n, i, s, o), r >= u && this.right.forEachLine(e, r, n, l, u, o);
    else {
      let h = this.lineAt(u, Ze.ByPos, n, i, s);
      e < h.from && this.left.forEachLine(e, h.from - 1, n, i, s, o), h.to >= e && h.from <= r && o(h), r > h.to && this.right.forEachLine(h.to + 1, r, n, l, u, o);
    }
  }
  replace(e, r, n) {
    let i = this.left.length + this.break;
    if (r < i)
      return this.balanced(this.left.replace(e, r, n), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, r - i, n));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let l of n)
      s.push(l);
    if (e > 0 && T1(s, o - 1), r < this.length) {
      let l = s.length;
      this.decomposeRight(r, s), T1(s, l);
    }
    return Yt.of(s);
  }
  decomposeLeft(e, r) {
    let n = this.left.length;
    if (e <= n)
      return this.left.decomposeLeft(e, r);
    r.push(this.left), this.break && (n++, e >= n && r.push(null)), e > n && this.right.decomposeLeft(e - n, r);
  }
  decomposeRight(e, r) {
    let n = this.left.length, i = n + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, r);
    e < n && this.left.decomposeRight(e, r), this.break && e < i && r.push(null), r.push(this.right);
  }
  balanced(e, r) {
    return e.size > 2 * r.size || r.size > 2 * e.size ? Yt.of(this.break ? [e, null, r] : [e, r]) : (this.left = e, this.right = r, this.height = e.height + r.height, this.outdated = e.outdated || r.outdated, this.size = e.size + r.size, this.length = e.length + this.break + r.length, this);
  }
  updateHeight(e, r = 0, n = !1, i) {
    let { left: s, right: o } = this, l = r + s.length + this.break, u = null;
    return i && i.from <= r + s.length && i.more ? u = s = s.updateHeight(e, r, n, i) : s.updateHeight(e, r, n), i && i.from <= l + o.length && i.more ? u = o = o.updateHeight(e, l, n, i) : o.updateHeight(e, l, n), u ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function T1(t, e) {
  let r, n;
  t[e] == null && (r = t[e - 1]) instanceof vt && (n = t[e + 1]) instanceof vt && t.splice(e - 1, 3, new vt(r.length + 1 + n.length));
}
const JR = 5;
class gg {
  constructor(e, r) {
    this.pos = e, this.oracle = r, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, r) {
    if (this.lineStart > -1) {
      let n = Math.min(r, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof cr ? i.length += n - this.pos : (n > this.pos || !this.isCovered) && this.nodes.push(new cr(n - this.pos, -1)), this.writtenTo = n, r > n && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = r;
  }
  point(e, r, n) {
    if (e < r || n.heightRelevant) {
      let i = n.widget ? n.widget.estimatedHeight : 0, s = n.widget ? n.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let o = r - e;
      n.block ? this.addBlock(new rE(o, i, n)) : (o || s || i >= JR) && this.addLineDeco(i, s, o);
    } else
      r > e && this.span(e, r);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: r } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = r, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new cr(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, r) {
    let n = new vt(r - e);
    return this.oracle.doc.lineAt(e).to == r && (n.flags |= 4), n;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof cr)
      return e;
    let r = new cr(0, -1);
    return this.nodes.push(r), r;
  }
  addBlock(e) {
    this.enterLine();
    let r = e.deco;
    r && r.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, r && r.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, r, n) {
    let i = this.ensureLine();
    i.length += n, i.collapsed += n, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += r, this.writtenTo = this.pos = this.pos + n;
  }
  finish(e) {
    let r = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(r instanceof cr) && !this.isCovered ? this.nodes.push(new cr(0, -1)) : (this.writtenTo < this.pos || r == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let n = e;
    for (let i of this.nodes)
      i instanceof cr && i.updateHeight(this.oracle, n), n += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, r, n, i) {
    let s = new gg(n, e);
    return _e.spans(r, n, i, s, 0), s.finish(n);
  }
}
function KR(t, e, r) {
  let n = new GR();
  return _e.compare(t, e, r, n, 0), n.changes;
}
class GR {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, r, n, i) {
    (e < r || n && n.heightRelevant || i && i.heightRelevant) && Xd(e, r, this.changes, 5);
  }
}
function XR(t, e) {
  let r = t.getBoundingClientRect(), n = t.ownerDocument, i = n.defaultView || window, s = Math.max(0, r.left), o = Math.min(i.innerWidth, r.right), l = Math.max(0, r.top), u = Math.min(i.innerHeight, r.bottom);
  for (let h = t.parentNode; h && h != n.body; )
    if (h.nodeType == 1) {
      let p = h, d = window.getComputedStyle(p);
      if ((p.scrollHeight > p.clientHeight || p.scrollWidth > p.clientWidth) && d.overflow != "visible") {
        let m = p.getBoundingClientRect();
        s = Math.max(s, m.left), o = Math.min(o, m.right), l = Math.max(l, m.top), u = h == t.parentNode ? m.bottom : Math.min(u, m.bottom);
      }
      h = d.position == "absolute" || d.position == "fixed" ? p.offsetParent : p.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
  return {
    left: s - r.left,
    right: Math.max(s, o) - r.left,
    top: l - (r.top + e),
    bottom: Math.max(l, u) - (r.top + e)
  };
}
function YR(t, e) {
  let r = t.getBoundingClientRect();
  return {
    left: 0,
    right: r.right - r.left,
    top: e,
    bottom: r.bottom - (r.top + e)
  };
}
class wp {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.size = n;
  }
  static same(e, r) {
    if (e.length != r.length)
      return !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n], s = r[n];
      if (i.from != s.from || i.to != s.to || i.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, r) {
    return xe.replace({
      widget: new QR(this.size * (r ? e.scaleY : e.scaleX), r)
    }).range(this.from, this.to);
  }
}
class QR extends ni {
  constructor(e, r) {
    super(), this.size = e, this.vertical = r;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class k1 {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = F1, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = tt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let r = e.facet(fg).some((n) => typeof n != "function" && n.class == "cm-lineWrapping");
    this.heightOracle = new HR(r), this.stateDeco = e.facet(Ya).filter((n) => typeof n != "function"), this.heightMap = Yt.empty().applyChanges(this.stateDeco, Ue.empty, this.heightOracle.setDoc(e.doc), [new Ir(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = xe.set(this.lineGaps.map((n) => n.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: r } = this.state.selection;
    for (let n = 0; n <= 1; n++) {
      let i = n ? r.head : r.anchor;
      if (!e.some(({ from: s, to: o }) => i >= s && i <= o)) {
        let { from: s, to: o } = this.lineBlockAt(i);
        e.push(new cu(s, o));
      }
    }
    this.viewports = e.sort((n, i) => n.from - i.from), this.scaler = this.heightMap.height <= 7e6 ? F1 : new tj(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : ya(e, this.scaler));
    });
  }
  update(e, r = null) {
    this.state = e.state;
    let n = this.stateDeco;
    this.stateDeco = this.state.facet(Ya).filter((p) => typeof p != "function");
    let i = e.changedRanges, s = Ir.extendWithRanges(i, KR(n, this.stateDeco, e ? e.changes : mt.empty(this.state.doc.length))), o = this.heightMap.height, l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != o && (e.flags |= 2), l ? (this.scrollAnchorPos = e.changes.mapPos(l.from, -1), this.scrollAnchorHeight = l.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let u = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (r && (r.range.head < u.from || r.range.head > u.to) || !this.viewportIsAppropriate(u)) && (u = this.getViewport(0, r));
    let h = !e.changes.empty || e.flags & 2 || u.from != this.viewport.from || u.to != this.viewport.to;
    this.viewport = u, this.updateForViewport(), h && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), r && (this.scrollTarget = r), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet($A) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let r = e.contentDOM, n = window.getComputedStyle(r), i = this.heightOracle, s = n.whiteSpace;
    this.defaultTextDirection = n.direction == "rtl" ? tt.RTL : tt.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), l = r.getBoundingClientRect(), u = o || this.mustMeasureContent || this.contentDOMHeight != l.height;
    this.contentDOMHeight = l.height, this.mustMeasureContent = !1;
    let h = 0, p = 0;
    if (l.width && l.height) {
      let { scaleX: k, scaleY: w } = dA(r, l);
      (this.scaleX != k || this.scaleY != w) && (this.scaleX = k, this.scaleY = w, h |= 8, o = u = !0);
    }
    let d = (parseInt(n.paddingTop) || 0) * this.scaleY, m = (parseInt(n.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d || this.paddingBottom != m) && (this.paddingTop = d, this.paddingBottom = m, h |= 10), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (u = !0), this.editorWidth = e.scrollDOM.clientWidth, h |= 8);
    let y = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != y && (this.scrollAnchorHeight = -1, this.scrollTop = y), this.scrolledToBottom = gA(e.scrollDOM);
    let D = (this.printing ? YR : XR)(r, this.paddingTop), b = D.top - this.pixelViewport.top, C = D.bottom - this.pixelViewport.bottom;
    this.pixelViewport = D;
    let A = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (A != this.inView && (this.inView = A, A && (u = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let x = l.width;
    if ((this.contentDOMWidth != x || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = l.width, this.editorHeight = e.scrollDOM.clientHeight, h |= 8), u) {
      let k = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(k) && (o = !0), o || i.lineWrapping && Math.abs(x - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: w, charWidth: T, textHeight: P } = e.docView.measureTextSize();
        o = w > 0 && i.refresh(s, w, T, P, x / T, k), o && (e.docView.minWidth = 0, h |= 8);
      }
      b > 0 && C > 0 ? p = Math.max(b, C) : b < 0 && C < 0 && (p = Math.min(b, C)), i.heightChanged = !1;
      for (let w of this.viewports) {
        let T = w.from == this.viewport.from ? k : e.docView.measureVisibleLineHeights(w);
        this.heightMap = (o ? Yt.empty().applyChanges(this.stateDeco, Ue.empty, this.heightOracle, [new Ir(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, o, new VR(w.from, T));
      }
      i.heightChanged && (h |= 2);
    }
    let E = !this.viewportIsAppropriate(this.viewport, p) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return E && (this.viewport = this.getViewport(p, this.scrollTarget)), this.updateForViewport(), (h & 2 || E) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), h |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), h;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, r) {
    let n = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: l } = this, u = new cu(i.lineAt(o - n * 1e3, Ze.ByHeight, s, 0, 0).from, i.lineAt(l + (1 - n) * 1e3, Ze.ByHeight, s, 0, 0).to);
    if (r) {
      let { head: h } = r.range;
      if (h < u.from || h > u.to) {
        let p = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), d = i.lineAt(h, Ze.ByPos, s, 0, 0), m;
        r.y == "center" ? m = (d.top + d.bottom) / 2 - p / 2 : r.y == "start" || r.y == "nearest" && h < u.from ? m = d.top : m = d.bottom - p, u = new cu(i.lineAt(m - 1e3 / 2, Ze.ByHeight, s, 0, 0).from, i.lineAt(m + p + 1e3 / 2, Ze.ByHeight, s, 0, 0).to);
      }
    }
    return u;
  }
  mapViewport(e, r) {
    let n = r.mapPos(e.from, -1), i = r.mapPos(e.to, 1);
    return new cu(this.heightMap.lineAt(n, Ze.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, Ze.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: r }, n = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, Ze.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(r, Ze.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: l } = this;
    return (e == 0 || i <= o - Math.max(10, Math.min(
      -n,
      250
      /* VP.MaxCoverMargin */
    ))) && (r == this.state.doc.length || s >= l + Math.max(10, Math.min(
      n,
      250
      /* VP.MaxCoverMargin */
    ))) && i > o - 2 * 1e3 && s < l + 2 * 1e3;
  }
  mapLineGaps(e, r) {
    if (!e.length || r.empty)
      return e;
    let n = [];
    for (let i of e)
      r.touchesRange(i.from, i.to) || n.push(new wp(r.mapPos(i.from), r.mapPos(i.to), i.size));
    return n;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, r) {
    let n = this.heightOracle.lineWrapping, i = n ? 1e4 : 2e3, s = i >> 1, o = i << 1;
    if (this.defaultTextDirection != tt.LTR && !n)
      return [];
    let l = [], u = (h, p, d, m) => {
      if (p - h < s)
        return;
      let y = this.state.selection.main, D = [y.from];
      y.empty || D.push(y.to);
      for (let C of D)
        if (C > h && C < p) {
          u(h, C - 10, d, m), u(C + 10, p, d, m);
          return;
        }
      let b = ej(e, (C) => C.from >= d.from && C.to <= d.to && Math.abs(C.from - h) < s && Math.abs(C.to - p) < s && !D.some((A) => C.from < A && C.to > A));
      if (!b) {
        if (p < d.to && r && n && r.visibleRanges.some((C) => C.from <= p && C.to >= p)) {
          let C = r.moveToLineBoundary(K.cursor(p), !1, !0).head;
          C > h && (p = C);
        }
        b = new wp(h, p, this.gapSize(d, h, p, m));
      }
      l.push(b);
    };
    for (let h of this.viewportLines) {
      if (h.length < o)
        continue;
      let p = ZR(h.from, h.to, this.stateDeco);
      if (p.total < o)
        continue;
      let d = this.scrollTarget ? this.scrollTarget.range.head : null, m, y;
      if (n) {
        let D = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, b, C;
        if (d != null) {
          let A = pu(p, d), x = ((this.visibleBottom - this.visibleTop) / 2 + D) / h.height;
          b = A - x, C = A + x;
        } else
          b = (this.visibleTop - h.top - D) / h.height, C = (this.visibleBottom - h.top + D) / h.height;
        m = hu(p, b), y = hu(p, C);
      } else {
        let D = p.total * this.heightOracle.charWidth, b = i * this.heightOracle.charWidth, C, A;
        if (d != null) {
          let x = pu(p, d), E = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + b) / D;
          C = x - E, A = x + E;
        } else
          C = (this.pixelViewport.left - b) / D, A = (this.pixelViewport.right + b) / D;
        m = hu(p, C), y = hu(p, A);
      }
      m > h.from && u(h.from, m, h, p), y < h.to && u(y, h.to, h, p);
    }
    return l;
  }
  gapSize(e, r, n, i) {
    let s = pu(i, n) - pu(i, r);
    return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    wp.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = xe.set(e.map((r) => r.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let r = [];
    _e.spans(e, this.viewport.from, this.viewport.to, {
      span(i, s) {
        r.push({ from: i, to: s });
      },
      point() {
      }
    }, 20);
    let n = r.length != this.visibleRanges.length || this.visibleRanges.some((i, s) => i.from != r[s].from || i.to != r[s].to);
    return this.visibleRanges = r, n ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((r) => r.from <= e && r.to >= e) || ya(this.heightMap.lineAt(e, Ze.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return ya(this.heightMap.lineAt(this.scaler.fromDOM(e), Ze.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let r = this.lineBlockAtHeight(e + 8);
    return r.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? r : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return ya(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class cu {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
function ZR(t, e, r) {
  let n = [], i = t, s = 0;
  return _e.spans(r, t, e, {
    span() {
    },
    point(o, l) {
      o > i && (n.push({ from: i, to: o }), s += o - i), i = l;
    }
  }, 20), i < e && (n.push({ from: i, to: e }), s += e - i), { total: s, ranges: n };
}
function hu({ total: t, ranges: e }, r) {
  if (r <= 0)
    return e[0].from;
  if (r >= 1)
    return e[e.length - 1].to;
  let n = Math.floor(t * r);
  for (let i = 0; ; i++) {
    let { from: s, to: o } = e[i], l = o - s;
    if (n <= l)
      return s + n;
    n -= l;
  }
}
function pu(t, e) {
  let r = 0;
  for (let { from: n, to: i } of t.ranges) {
    if (e <= i) {
      r += e - n;
      break;
    }
    r += i - n;
  }
  return r / t.total;
}
function ej(t, e) {
  for (let r of t)
    if (e(r))
      return r;
}
const F1 = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1
};
class tj {
  constructor(e, r, n) {
    let i = 0, s = 0, o = 0;
    this.viewports = n.map(({ from: l, to: u }) => {
      let h = r.lineAt(l, Ze.ByPos, e, 0, 0).top, p = r.lineAt(u, Ze.ByPos, e, 0, 0).bottom;
      return i += p - h, { from: l, to: u, top: h, bottom: p, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (r.height - i);
    for (let l of this.viewports)
      l.domTop = o + (l.top - s) * this.scale, o = l.domBottom = l.domTop + (l.bottom - l.top), s = l.bottom;
  }
  toDOM(e) {
    for (let r = 0, n = 0, i = 0; ; r++) {
      let s = r < this.viewports.length ? this.viewports[r] : null;
      if (!s || e < s.top)
        return i + (e - n) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      n = s.bottom, i = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let r = 0, n = 0, i = 0; ; r++) {
      let s = r < this.viewports.length ? this.viewports[r] : null;
      if (!s || e < s.domTop)
        return n + (e - i) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      n = s.bottom, i = s.domBottom;
    }
  }
}
function ya(t, e) {
  if (e.scale == 1)
    return t;
  let r = e.toDOM(t.top), n = e.toDOM(t.bottom);
  return new Dn(t.from, t.length, r, n - r, Array.isArray(t._content) ? t._content.map((i) => ya(i, e)) : t._content);
}
const du = /* @__PURE__ */ ge.define({ combine: (t) => t.join(" ") }), sf = /* @__PURE__ */ ge.define({ combine: (t) => t.indexOf(!0) > -1 }), of = /* @__PURE__ */ Oi.newName(), nE = /* @__PURE__ */ Oi.newName(), iE = /* @__PURE__ */ Oi.newName(), sE = { "&light": "." + nE, "&dark": "." + iE };
function af(t, e, r) {
  return new Oi(e, {
    finish(n) {
      return /&/.test(n) ? n.replace(/&\w*/, (i) => {
        if (i == "&")
          return t;
        if (!r || !r[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return r[i];
      }) : t + " " + n;
    }
  });
}
const rj = /* @__PURE__ */ af("." + of, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, sE), Da = "";
class nj {
  constructor(e, r) {
    this.points = e, this.text = "", this.lineSeparator = r.facet(Ie.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Da;
  }
  readRange(e, r) {
    if (!e)
      return this;
    let n = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(n, i);
      let s = this.text.length;
      this.readNode(i);
      let o = i.nextSibling;
      if (o == r)
        break;
      let l = et.get(i), u = et.get(o);
      (l && u ? l.breakAfter : (l ? l.breakAfter : P1(i)) || P1(o) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > s) && this.lineBreak(), i = o;
    }
    return this.findPointBefore(n, r), this;
  }
  readTextNode(e) {
    let r = e.nodeValue;
    for (let n of this.points)
      n.node == e && (n.pos = this.text.length + Math.min(n.offset, r.length));
    for (let n = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, l;
      if (this.lineSeparator ? (s = r.indexOf(this.lineSeparator, n), o = this.lineSeparator.length) : (l = i.exec(r)) && (s = l.index, o = l[0].length), this.append(r.slice(n, s < 0 ? r.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let u of this.points)
          u.node == e && u.pos > this.text.length && (u.pos -= o - 1);
      n = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let r = et.get(e), n = r && r.overrideDOMText;
    if (n != null) {
      this.findPointInside(e, n.length);
      for (let i = n.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, r) {
    for (let n of this.points)
      n.node == e && e.childNodes[n.offset] == r && (n.pos = this.text.length);
  }
  findPointInside(e, r) {
    for (let n of this.points)
      (e.nodeType == 3 ? n.node == e : e.contains(n.node)) && (n.pos = this.text.length + (ij(e, n.node, n.offset) ? r : 0));
  }
}
function ij(t, e, r) {
  for (; ; ) {
    if (!e || r < Vn(e))
      return !1;
    if (e == t)
      return !0;
    r = Xa(e) + 1, e = e.parentNode;
  }
}
function P1(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
class B1 {
  constructor(e, r) {
    this.node = e, this.offset = r, this.pos = -1;
  }
}
class sj {
  constructor(e, r, n, i) {
    this.typeOver = i, this.bounds = null, this.text = "";
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && r > -1)
      this.newSel = null;
    else if (r > -1 && (this.bounds = e.docView.domBoundsAround(r, n, 0))) {
      let l = s || o ? [] : lj(e), u = new nj(l, e.state);
      u.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = u.text, this.newSel = uj(l, this.bounds.from);
    } else {
      let l = e.observer.selectionRange, u = s && s.node == l.focusNode && s.offset == l.focusOffset || !Hd(e.contentDOM, l.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(l.focusNode, l.focusOffset), h = o && o.node == l.anchorNode && o.offset == l.anchorOffset || !Hd(e.contentDOM, l.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(l.anchorNode, l.anchorOffset), p = e.viewport;
      if ((me.ios || me.chrome) && e.state.selection.main.empty && u != h && (p.from > 0 || p.to < e.state.doc.length)) {
        let d = Math.min(u, h), m = Math.max(u, h), y = p.from - d, D = p.to - m;
        (y == 0 || y == 1 || d == 0) && (D == 0 || D == -1 || m == e.state.doc.length) && (u = 0, h = e.state.doc.length);
      }
      this.newSel = K.single(h, u);
    }
  }
}
function oE(t, e) {
  let r, { newSel: n } = e, i = t.state.selection.main, s = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: l } = e.bounds, u = i.from, h = null;
    (s === 8 || me.android && e.text.length < l - o) && (u = i.to, h = "end");
    let p = aj(t.state.doc.sliceString(o, l, Da), e.text, u - o, h);
    p && (me.chrome && s == 13 && p.toB == p.from + 2 && e.text.slice(p.from, p.toB) == Da + Da && p.toB--, r = {
      from: o + p.from,
      to: o + p.toA,
      insert: Ue.of(e.text.slice(p.from, p.toB).split(Da))
    });
  } else
    n && (!t.hasFocus && t.state.facet(vh) || n.main.eq(i)) && (n = null);
  if (!r && !n)
    return !1;
  if (!r && e.typeOver && !i.empty && n && n.main.empty ? r = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, i.to) } : r && r.from >= i.from && r.to <= i.to && (r.from != i.from || r.to != i.to) && i.to - i.from - (r.to - r.from) <= 4 ? r = {
    from: i.from,
    to: i.to,
    insert: t.state.doc.slice(i.from, r.from).append(r.insert).append(t.state.doc.slice(r.to, i.to))
  } : (me.mac || me.android) && r && r.from == r.to && r.from == i.head - 1 && /^\. ?$/.test(r.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (n && r.insert.length == 2 && (n = K.single(n.main.anchor - 1, n.main.head - 1)), r = { from: i.from, to: i.to, insert: Ue.of([" "]) }) : me.chrome && r && r.from == r.to && r.from == i.head && r.insert.toString() == `
 ` && t.lineWrapping && (n && (n = K.single(n.main.anchor - 1, n.main.head - 1)), r = { from: i.from, to: i.to, insert: Ue.of([" "]) }), r) {
    if (me.ios && t.inputState.flushIOSKey() || me.android && (r.from == i.from && r.to == i.to && r.insert.length == 1 && r.insert.lines == 2 && uo(t.contentDOM, "Enter", 13) || (r.from == i.from - 1 && r.to == i.to && r.insert.length == 0 || s == 8 && r.insert.length < r.to - r.from && r.to > i.head) && uo(t.contentDOM, "Backspace", 8) || r.from == i.from && r.to == i.to + 1 && r.insert.length == 0 && uo(t.contentDOM, "Delete", 46)))
      return !0;
    let o = r.insert.toString();
    t.inputState.composing >= 0 && t.inputState.composing++;
    let l, u = () => l || (l = oj(t, r, n));
    return t.state.facet(OA).some((h) => h(t, r.from, r.to, o, u)) || t.dispatch(u()), !0;
  } else if (n && !n.main.eq(i)) {
    let o = !1, l = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (o = !0), l = t.inputState.lastSelectionOrigin), t.dispatch({ selection: n, scrollIntoView: o, userEvent: l }), !0;
  } else
    return !1;
}
function oj(t, e, r) {
  let n, i = t.state, s = i.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!r || r.main.empty && r.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let l = s.from < e.from ? i.sliceDoc(s.from, e.from) : "", u = s.to > e.to ? i.sliceDoc(e.to, s.to) : "";
    n = i.replaceSelection(t.state.toText(l + e.insert.sliceString(0, void 0, t.state.lineBreak) + u));
  } else {
    let l = i.changes(e), u = r && r.main.to <= l.newLength ? r.main : void 0;
    if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let h = t.state.sliceDoc(e.from, e.to), p, d = r && HA(t, r.main.head);
      if (d) {
        let D = e.insert.length - (e.to - e.from);
        p = { from: d.from, to: d.to - D };
      } else
        p = t.state.doc.lineAt(s.head);
      let m = s.to - e.to, y = s.to - s.from;
      n = i.changeByRange((D) => {
        if (D.from == s.from && D.to == s.to)
          return { changes: l, range: u || D.map(l) };
        let b = D.to - m, C = b - h.length;
        if (D.to - D.from != y || t.state.sliceDoc(C, b) != h || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        D.to >= p.from && D.from <= p.to)
          return { range: D };
        let A = i.changes({ from: C, to: b, insert: e.insert }), x = D.to - s.to;
        return {
          changes: A,
          range: u ? K.range(Math.max(0, u.anchor + x), Math.max(0, u.head + x)) : D.map(A)
        };
      });
    } else
      n = {
        changes: l,
        selection: u && i.selection.replaceRange(u)
      };
  }
  let o = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, o += ".compose", t.inputState.compositionFirstChange && (o += ".start", t.inputState.compositionFirstChange = !1)), i.update(n, { userEvent: o, scrollIntoView: !0 });
}
function aj(t, e, r, n) {
  let i = Math.min(t.length, e.length), s = 0;
  for (; s < i && t.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == i && t.length == e.length)
    return null;
  let o = t.length, l = e.length;
  for (; o > 0 && l > 0 && t.charCodeAt(o - 1) == e.charCodeAt(l - 1); )
    o--, l--;
  if (n == "end") {
    let u = Math.max(0, s - Math.min(o, l));
    r -= o + u - s;
  }
  if (o < s && t.length < e.length) {
    let u = r <= s && r >= o ? s - r : 0;
    s -= u, l = s + (l - o), o = s;
  } else if (l < s) {
    let u = r <= s && r >= l ? s - r : 0;
    s -= u, o = s + (o - l), l = s;
  }
  return { from: s, toA: o, toB: l };
}
function lj(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: r, anchorOffset: n, focusNode: i, focusOffset: s } = t.observer.selectionRange;
  return r && (e.push(new B1(r, n)), (i != r || s != n) && e.push(new B1(i, s))), e;
}
function uj(t, e) {
  if (t.length == 0)
    return null;
  let r = t[0].pos, n = t.length == 2 ? t[1].pos : r;
  return r > -1 && n > -1 ? K.single(r + e, n + e) : null;
}
const cj = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Sp = me.ie && me.ie_version <= 11;
class hj {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new K$(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((r) => {
      for (let n of r)
        this.queue.push(n);
      (me.ie && me.ie_version <= 11 || me.ios && e.composing) && r.some((n) => n.type == "childList" && n.removedNodes.length || n.type == "characterData" && n.oldValue.length > n.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Sp && (this.onCharData = (r) => {
      this.queue.push({
        target: r.target,
        type: "characterData",
        oldValue: r.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var r;
      ((r = this.view.docView) === null || r === void 0 ? void 0 : r.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((r) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), r.length > 0 && r[r.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((r) => {
      r.length > 0 && r[r.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((r, n) => r != e[n]))) {
      this.gapIntersection.disconnect();
      for (let r of e)
        this.gapIntersection.observe(r);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let r = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: n } = this, i = this.selectionRange;
    if (n.state.facet(vh) ? n.root.activeElement != this.dom : !$u(n.dom, i))
      return;
    let s = i.anchorNode && n.docView.nearest(i.anchorNode);
    if (s && s.ignoreEvent(e)) {
      r || (this.selectionChanged = !1);
      return;
    }
    (me.ie && me.ie_version <= 11 || me.android && me.chrome) && !n.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && Ma(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, r = me.safari && e.root.nodeType == 11 && H$(this.dom.ownerDocument) == this.dom && pj(this.view) || lc(e.root);
    if (!r || this.selectionRange.eq(r))
      return !1;
    let n = $u(this.dom, r);
    return n && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && X$(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), n && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, r) {
    this.selectionRange.set(e.node, e.offset, r.node, r.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, r = null;
    for (let n = this.dom; n; )
      if (n.nodeType == 1)
        !r && e < this.scrollTargets.length && this.scrollTargets[e] == n ? e++ : r || (r = this.scrollTargets.slice(0, e)), r && r.push(n), n = n.assignedSlot || n.parentNode;
      else if (n.nodeType == 11)
        n = n.host;
      else
        break;
    if (e < this.scrollTargets.length && !r && (r = this.scrollTargets.slice(0, e)), r) {
      for (let n of this.scrollTargets)
        n.removeEventListener("scroll", this.onScroll);
      for (let n of this.scrollTargets = r)
        n.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, cj), Sp && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Sp && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, r) {
    var n;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && uo(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: r,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((n = this.delayedAndroidKey) === null || n === void 0) && n.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let r = -1, n = -1, i = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o && (o.typeOver && (i = !0), r == -1 ? { from: r, to: n } = o : (r = Math.min(o.from, r), n = Math.max(o.to, n)));
    }
    return { from: r, to: n, typeOver: i };
  }
  readChange() {
    let { from: e, to: r, typeOver: n } = this.processRecords(), i = this.selectionChanged && $u(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new sj(this.view, e, r, n);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let r = this.readChange();
    if (!r)
      return this.view.requestMeasure(), !1;
    let n = this.view.state, i = oE(this.view, r);
    return this.view.state == n && this.view.update([]), i;
  }
  readMutation(e) {
    let r = this.view.docView.nearest(e.target);
    if (!r || r.ignoreMutation(e))
      return null;
    if (r.markDirty(e.type == "attributes"), e.type == "attributes" && (r.flags |= 4), e.type == "childList") {
      let n = I1(r, e.previousSibling || e.target.previousSibling, -1), i = I1(r, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: n ? r.posAfter(n) : r.posAtStart,
        to: i ? r.posBefore(i) : r.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, r, n;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (r = this.gapIntersection) === null || r === void 0 || r.disconnect(), (n = this.resizeScroll) === null || n === void 0 || n.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function I1(t, e, r) {
  for (; e; ) {
    let n = et.get(e);
    if (n && n.parent == t)
      return n;
    let i = e.parentNode;
    e = i != t.dom ? i : r > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function pj(t) {
  let e = null;
  function r(u) {
    u.preventDefault(), u.stopImmediatePropagation(), e = u.getTargetRanges()[0];
  }
  if (t.contentDOM.addEventListener("beforeinput", r, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", r, !0), !e)
    return null;
  let n = e.startContainer, i = e.startOffset, s = e.endContainer, o = e.endOffset, l = t.docView.domAtPos(t.state.selection.main.anchor);
  return Ma(l.node, l.offset, s, o) && ([n, i, s, o] = [s, o, n, i]), { anchorNode: n, anchorOffset: i, focusNode: s, focusOffset: o };
}
class ce {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((n) => n.forEach((i) => r(i, this))) || ((n) => this.update(n)), this.dispatch = this.dispatch.bind(this), this._root = e.root || G$(e.parent) || document, this.viewState = new k1(e.state || Ie.create(e)), e.scrollTo && e.scrollTo.is(au) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(ma).map((n) => new Cp(n));
    for (let n of this.plugins)
      n.update(this);
    this.observer = new hj(this), this.inputState = new TR(this), this.inputState.ensureHandlers(this.plugins), this.docView = new c1(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...e) {
    let r = e.length == 1 && e[0] instanceof gt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(r, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let r = !1, n = !1, i, s = this.state;
    for (let m of e) {
      if (m.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = m.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, l = 0, u = null;
    e.some((m) => m.annotation(ZA)) ? (this.inputState.notifiedFocused = o, l = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, u = eE(s, o), u || (l = 1));
    let h = this.observer.delayedAndroidKey, p = null;
    if (h ? (this.observer.clearDelayedAndroidKey(), p = this.observer.readChange(), (p && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (p = null)) : this.observer.clear(), s.facet(Ie.phrases) != this.state.facet(Ie.phrases))
      return this.setState(s);
    i = uc.create(this, s, e), i.flags |= l;
    let d = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let m of e) {
        if (d && (d = d.map(m.changes)), m.scrollIntoView) {
          let { main: y } = m.state.selection;
          d = new co(y.empty ? y : K.cursor(y.head, y.head > y.anchor ? -1 : 1));
        }
        for (let y of m.effects)
          y.is(au) && (d = y.value.clip(this.state));
      }
      this.viewState.update(i, d), this.bidiCache = cc.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), r = this.docView.update(i), this.state.facet(ga) != this.styleModules && this.mountStyles(), n = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(r, e.some((m) => m.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(du) != i.state.facet(du) && (this.viewState.mustMeasureContent = !0), (r || n || d || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !i.empty)
      for (let m of this.state.facet(ef))
        try {
          m(i);
        } catch (y) {
          Br(this.state, y, "update listener");
        }
    (u || p) && Promise.resolve().then(() => {
      u && this.state == u.startState && this.dispatch(u), p && !oE(this, p) && h.force && uo(this.contentDOM, h.key, h.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let r = this.hasFocus;
    try {
      for (let n of this.plugins)
        n.destroy(this);
      this.viewState = new k1(e), this.plugins = e.facet(ma).map((n) => new Cp(n)), this.pluginMap.clear();
      for (let n of this.plugins)
        n.update(this);
      this.docView.destroy(), this.docView = new c1(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    r && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let r = e.startState.facet(ma), n = e.state.facet(ma);
    if (r != n) {
      let i = [];
      for (let s of n) {
        let o = r.indexOf(s);
        if (o < 0)
          i.push(new Cp(s));
        else {
          let l = this.plugins[o];
          l.mustUpdate = e, i.push(l);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    r != n && this.inputState.ensureHandlers(this.plugins);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let r = null, n = this.scrollDOM, i = n.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let l = 0; ; l++) {
        if (o < 0)
          if (gA(n))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let y = this.viewState.scrollAnchorAt(i);
            s = y.from, o = y.top;
          }
        this.updateState = 1;
        let u = this.viewState.measure(this);
        if (!u && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let h = [];
        u & 4 || ([this.measureRequests, h] = [h, this.measureRequests]);
        let p = h.map((y) => {
          try {
            return y.read(this);
          } catch (D) {
            return Br(this.state, D), N1;
          }
        }), d = uc.create(this, this.state, []), m = !1;
        d.flags |= u, r ? r.flags |= u : r = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), m = this.docView.update(d));
        for (let y = 0; y < h.length; y++)
          if (p[y] != N1)
            try {
              let D = h[y];
              D.write && D.write(p[y], this);
            } catch (D) {
              Br(this.state, D);
            }
        if (m && this.docView.updateSelection(!0), !d.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let D = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (D > 1 || D < -1) {
                i = i + D, n.scrollTop = i / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (r && !r.empty)
      for (let l of this.state.facet(ef))
        l(r);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return of + " " + (this.state.facet(sf) ? iE : nE) + " " + this.state.facet(du);
  }
  updateAttrs() {
    let e = M1(this, RA, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), r = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(vh) ? "true" : "false",
      class: "cm-content",
      style: `${me.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (r["aria-readonly"] = "true"), M1(this, fg, r);
    let n = this.observer.ignore(() => {
      let i = Gd(this.contentDOM, this.contentAttrs, r), s = Gd(this.dom, this.editorAttrs, e);
      return i || s;
    });
    return this.editorAttrs = e, this.contentAttrs = r, n;
  }
  showAnnouncements(e) {
    let r = !0;
    for (let n of e)
      for (let i of n.effects)
        if (i.is(ce.announce)) {
          r && (this.announceDOM.textContent = ""), r = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(ga);
    let e = this.state.facet(ce.cspNonce);
    Oi.mount(this.root, this.styleModules.concat(rj).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let r = 0; r < this.measureRequests.length; r++)
          if (this.measureRequests[r].key === e.key) {
            this.measureRequests[r] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let r = this.pluginMap.get(e);
    return (r === void 0 || r && r.spec != e) && this.pluginMap.set(e, r = this.plugins.find((n) => n.spec == e) || null), r && r.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, r, n) {
    return Ep(this, e, g1(this, e, r, n));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, r) {
    return Ep(this, e, g1(this, e, r, (n) => wR(this, e.head, n)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, r) {
    let n = this.bidiSpans(e), i = this.textDirectionAt(e.from), s = n[r ? n.length - 1 : 0];
    return K.cursor(s.side(r, i) + e.from, s.forward(!r, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, r, n = !0) {
    return ER(this, e, r, n);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, r, n) {
    return Ep(this, e, SR(this, e, r, n));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, r = 0) {
    return this.docView.posFromDOM(e, r);
  }
  posAtCoords(e, r = !0) {
    return this.readMeasured(), zA(this, e, r);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, r = 1) {
    this.readMeasured();
    let n = this.docView.coordsAt(e, r);
    if (!n || n.left == n.right)
      return n;
    let i = this.state.doc.lineAt(e), s = this.bidiSpans(i), o = s[Ci.find(s, e - i.from, -1, r)];
    return xh(n, o.dir == tt.LTR == r > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(_A) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > dj)
      return FA(e.length);
    let r = this.textDirectionAt(e.from), n;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == r && (s.fresh || kA(s.isolates, n = u1(this, e))))
        return s.order;
    n || (n = u1(this, e));
    let i = lR(e.text, r, n);
    return this.bidiCache.push(new cc(e.from, e.to, r, n, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || me.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      fA(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, r = {}) {
    return au.of(new co(typeof e == "number" ? K.cursor(e) : e, r.y, r.x, r.yMargin, r.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: r } = this.scrollDOM, n = this.viewState.scrollAnchorAt(e);
    return au.of(new co(K.cursor(n.from), "start", "start", n.top - e, r, !0));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return ct.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return ct.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, r) {
    let n = Oi.newName(), i = [du.of(n), ga.of(af(`.${n}`, e))];
    return r && r.dark && i.push(sf.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return jo.lowest(ga.of(af("." + of, e, sE)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var r;
    let n = e.querySelector(".cm-content"), i = n && et.get(n) || et.get(e);
    return ((r = i == null ? void 0 : i.rootView) === null || r === void 0 ? void 0 : r.view) || null;
  }
}
ce.styleModule = ga;
ce.inputHandler = OA;
ce.focusChangeEffect = LA;
ce.perLineTextDirection = _A;
ce.exceptionSink = MA;
ce.updateListener = ef;
ce.editable = vh;
ce.mouseSelectionStyle = NA;
ce.dragMovesSelection = IA;
ce.clickAddsSelectionRange = BA;
ce.decorations = Ya;
ce.outerDecorations = jA;
ce.atomicRanges = mg;
ce.bidiIsolatedRanges = qA;
ce.scrollMargins = WA;
ce.darkTheme = sf;
ce.cspNonce = /* @__PURE__ */ ge.define({ combine: (t) => t.length ? t[0] : "" });
ce.contentAttributes = fg;
ce.editorAttributes = RA;
ce.lineWrapping = /* @__PURE__ */ ce.contentAttributes.of({ class: "cm-lineWrapping" });
ce.announce = /* @__PURE__ */ Se.define();
const dj = 4096, N1 = {};
class cc {
  constructor(e, r, n, i, s, o) {
    this.from = e, this.to = r, this.dir = n, this.isolates = i, this.fresh = s, this.order = o;
  }
  static update(e, r) {
    if (r.empty && !e.some((s) => s.fresh))
      return e;
    let n = [], i = e.length ? e[e.length - 1].dir : tt.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == i && !r.touchesRange(o.from, o.to) && n.push(new cc(r.mapPos(o.from, 1), r.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return n;
  }
}
function M1(t, e, r) {
  for (let n = t.state.facet(e), i = n.length - 1; i >= 0; i--) {
    let s = n[i], o = typeof s == "function" ? s(t) : s;
    o && Kd(o, r);
  }
  return r;
}
const fj = me.mac ? "mac" : me.windows ? "win" : me.linux ? "linux" : "key";
function mj(t, e) {
  const r = t.split(/-(?!$)/);
  let n = r[r.length - 1];
  n == "Space" && (n = " ");
  let i, s, o, l;
  for (let u = 0; u < r.length - 1; ++u) {
    const h = r[u];
    if (/^(cmd|meta|m)$/i.test(h))
      l = !0;
    else if (/^a(lt)?$/i.test(h))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(h))
      s = !0;
    else if (/^s(hift)?$/i.test(h))
      o = !0;
    else if (/^mod$/i.test(h))
      e == "mac" ? l = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + h);
  }
  return i && (n = "Alt-" + n), s && (n = "Ctrl-" + n), l && (n = "Meta-" + n), o && (n = "Shift-" + n), n;
}
function fu(t, e, r) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), r !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const gj = /* @__PURE__ */ jo.default(/* @__PURE__ */ ce.domEventHandlers({
  keydown(t, e) {
    return lE(aE(e.state), t, e, "editor");
  }
})), Ch = /* @__PURE__ */ ge.define({ enables: gj }), O1 = /* @__PURE__ */ new WeakMap();
function aE(t) {
  let e = t.facet(Ch), r = O1.get(e);
  return r || O1.set(e, r = xj(e.reduce((n, i) => n.concat(i), []))), r;
}
function yj(t, e, r) {
  return lE(aE(t.state), e, t, r);
}
let Di = null;
const Dj = 4e3;
function xj(t, e = fj) {
  let r = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), i = (o, l) => {
    let u = n[o];
    if (u == null)
      n[o] = l;
    else if (u != l)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, l, u, h, p) => {
    var d, m;
    let y = r[o] || (r[o] = /* @__PURE__ */ Object.create(null)), D = l.split(/ (?!$)/).map((A) => mj(A, e));
    for (let A = 1; A < D.length; A++) {
      let x = D.slice(0, A).join(" ");
      i(x, !0), y[x] || (y[x] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(E) => {
          let k = Di = { view: E, prefix: x, scope: o };
          return setTimeout(() => {
            Di == k && (Di = null);
          }, Dj), !0;
        }]
      });
    }
    let b = D.join(" ");
    i(b, !1);
    let C = y[b] || (y[b] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((m = (d = y._any) === null || d === void 0 ? void 0 : d.run) === null || m === void 0 ? void 0 : m.slice()) || []
    });
    u && C.run.push(u), h && (C.preventDefault = !0), p && (C.stopPropagation = !0);
  };
  for (let o of t) {
    let l = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let h of l) {
        let p = r[h] || (r[h] = /* @__PURE__ */ Object.create(null));
        p._any || (p._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let d in p)
          p[d].run.push(o.any);
      }
    let u = o[e] || o.key;
    if (u)
      for (let h of l)
        s(h, u, o.run, o.preventDefault, o.stopPropagation), o.shift && s(h, "Shift-" + u, o.shift, o.preventDefault, o.stopPropagation);
  }
  return r;
}
function lE(t, e, r, n) {
  let i = U$(e), s = Ct(i, 0), o = Fr(s) == i.length && i != " ", l = "", u = !1, h = !1, p = !1;
  Di && Di.view == r && Di.scope == n && (l = Di.prefix + " ", KA.indexOf(e.keyCode) < 0 && (h = !0, Di = null));
  let d = /* @__PURE__ */ new Set(), m = (C) => {
    if (C) {
      for (let A of C.run)
        if (!d.has(A) && (d.add(A), A(r, e)))
          return C.stopPropagation && (p = !0), !0;
      C.preventDefault && (C.stopPropagation && (p = !0), h = !0);
    }
    return !1;
  }, y = t[n], D, b;
  return y && (m(y[l + fu(i, e, !o)]) ? u = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(me.windows && e.ctrlKey && e.altKey) && (D = Li[e.keyCode]) && D != i ? (m(y[l + fu(D, e, !0)]) || e.shiftKey && (b = Ga[e.keyCode]) != i && b != D && m(y[l + fu(b, e, !1)])) && (u = !0) : o && e.shiftKey && m(y[l + fu(i, e, !0)]) && (u = !0), !u && m(y._any) && (u = !0)), h && (u = !0), u && p && e.stopPropagation(), u;
}
class Tl {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, r, n, i, s) {
    this.className = e, this.left = r, this.top = n, this.width = i, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, r) {
    return r.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, r, n) {
    if (n.empty) {
      let i = e.coordsAtPos(n.head, n.assoc || 1);
      if (!i)
        return [];
      let s = uE(e);
      return [new Tl(r, i.left - s.left, i.top - s.top, null, i.bottom - i.top)];
    } else
      return bj(e, r, n);
  }
}
function uE(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == tt.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function L1(t, e, r) {
  let n = K.cursor(e);
  return {
    from: Math.max(r.from, t.moveToLineBoundary(n, !1, !0).from),
    to: Math.min(r.to, t.moveToLineBoundary(n, !0, !0).from),
    type: Xt.Text
  };
}
function bj(t, e, r) {
  if (r.to <= t.viewport.from || r.from >= t.viewport.to)
    return [];
  let n = Math.max(r.from, t.viewport.from), i = Math.min(r.to, t.viewport.to), s = t.textDirection == tt.LTR, o = t.contentDOM, l = o.getBoundingClientRect(), u = uE(t), h = o.querySelector(".cm-line"), p = h && window.getComputedStyle(h), d = l.left + (p ? parseInt(p.paddingLeft) + Math.min(0, parseInt(p.textIndent)) : 0), m = l.right - (p ? parseInt(p.paddingRight) : 0), y = rf(t, n), D = rf(t, i), b = y.type == Xt.Text ? y : null, C = D.type == Xt.Text ? D : null;
  if (b && (t.lineWrapping || y.widgetLineBreaks) && (b = L1(t, n, b)), C && (t.lineWrapping || D.widgetLineBreaks) && (C = L1(t, i, C)), b && C && b.from == C.from)
    return x(E(r.from, r.to, b));
  {
    let w = b ? E(r.from, null, b) : k(y, !1), T = C ? E(null, r.to, C) : k(D, !0), P = [];
    return (b || y).to < (C || D).from - (b && C ? 1 : 0) || y.widgetLineBreaks > 1 && w.bottom + t.defaultLineHeight / 2 < T.top ? P.push(A(d, w.bottom, m, T.top)) : w.bottom < T.top && t.elementAtHeight((w.bottom + T.top) / 2).type == Xt.Text && (w.bottom = T.top = (w.bottom + T.top) / 2), x(w).concat(P).concat(x(T));
  }
  function A(w, T, P, M) {
    return new Tl(
      e,
      w - u.left,
      T - u.top - 0.01,
      P - w,
      M - T + 0.01
      /* C.Epsilon */
    );
  }
  function x({ top: w, bottom: T, horizontal: P }) {
    let M = [];
    for (let N = 0; N < P.length; N += 2)
      M.push(A(P[N], w, P[N + 1], T));
    return M;
  }
  function E(w, T, P) {
    let M = 1e9, N = -1e9, L = [];
    function j($, U, H, Z, ye) {
      let Ee = t.coordsAtPos($, $ == P.to ? -2 : 2), ve = t.coordsAtPos(H, H == P.from ? 2 : -2);
      !Ee || !ve || (M = Math.min(Ee.top, ve.top, M), N = Math.max(Ee.bottom, ve.bottom, N), ye == tt.LTR ? L.push(s && U ? d : Ee.left, s && Z ? m : ve.right) : L.push(!s && Z ? d : ve.left, !s && U ? m : Ee.right));
    }
    let X = w ?? P.from, Q = T ?? P.to;
    for (let $ of t.visibleRanges)
      if ($.to > X && $.from < Q)
        for (let U = Math.max($.from, X), H = Math.min($.to, Q); ; ) {
          let Z = t.state.doc.lineAt(U);
          for (let ye of t.bidiSpans(Z)) {
            let Ee = ye.from + Z.from, ve = ye.to + Z.from;
            if (Ee >= H)
              break;
            ve > U && j(Math.max(Ee, U), w == null && Ee <= X, Math.min(ve, H), T == null && ve >= Q, ye.dir);
          }
          if (U = Z.to + 1, U >= H)
            break;
        }
    return L.length == 0 && j(X, w == null, Q, T == null, t.textDirection), { top: M, bottom: N, horizontal: L };
  }
  function k(w, T) {
    let P = l.top + (T ? w.top : w.bottom);
    return { top: P, bottom: P, horizontal: [] };
  }
}
function vj(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class Cj {
  constructor(e, r) {
    this.view = e, this.layer = r, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), r.above && this.dom.classList.add("cm-layer-above"), r.class && this.dom.classList.add(r.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), r.mount && r.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(qu) != e.state.facet(qu) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  setOrder(e) {
    let r = 0, n = e.facet(qu);
    for (; r < n.length && n[r] != this.layer; )
      r++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - r);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: r } = this.view;
    (e != this.scaleX || r != this.scaleY) && (this.scaleX = e, this.scaleY = r, this.dom.style.transform = `scale(${1 / e}, ${1 / r})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((r, n) => !vj(r, this.drawn[n]))) {
      let r = this.dom.firstChild, n = 0;
      for (let i of e)
        i.update && r && i.constructor && this.drawn[n].constructor && i.update(r, this.drawn[n]) ? (r = r.nextSibling, n++) : this.dom.insertBefore(i.draw(), r);
      for (; r; ) {
        let i = r.nextSibling;
        r.remove(), r = i;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const qu = /* @__PURE__ */ ge.define();
function cE(t) {
  return [
    ct.define((e) => new Cj(e, t)),
    qu.of(t)
  ];
}
const hE = !me.ios, Qa = /* @__PURE__ */ ge.define({
  combine(t) {
    return Mn(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, r) => Math.min(e, r),
      drawRangeCursor: (e, r) => e || r
    });
  }
});
function Aj(t = {}) {
  return [
    Qa.of(t),
    Ej,
    wj,
    Sj,
    $A.of(!0)
  ];
}
function pE(t) {
  return t.startState.facet(Qa) != t.state.facet(Qa);
}
const Ej = /* @__PURE__ */ cE({
  above: !0,
  markers(t) {
    let { state: e } = t, r = e.facet(Qa), n = [];
    for (let i of e.selection.ranges) {
      let s = i == e.selection.main;
      if (i.empty ? !s || hE : r.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", l = i.empty ? i : K.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let u of Tl.forRange(t, o, l))
          n.push(u);
      }
    }
    return n;
  },
  update(t, e) {
    t.transactions.some((n) => n.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let r = pE(t);
    return r && _1(t.state, e), t.docChanged || t.selectionSet || r;
  },
  mount(t, e) {
    _1(e.state, t);
  },
  class: "cm-cursorLayer"
});
function _1(t, e) {
  e.style.animationDuration = t.facet(Qa).cursorBlinkRate + "ms";
}
const wj = /* @__PURE__ */ cE({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : Tl.forRange(t, "cm-selectionBackground", e)).reduce((e, r) => e.concat(r));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || pE(t);
  },
  class: "cm-selectionLayer"
}), lf = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
hE && (lf[".cm-line"].caretColor = "transparent !important", lf[".cm-content"] = { caretColor: "transparent !important" });
const Sj = /* @__PURE__ */ jo.highest(/* @__PURE__ */ ce.theme(lf)), dE = /* @__PURE__ */ Se.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), xa = /* @__PURE__ */ Nt.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((r, n) => n.is(dE) ? n.value : r, t);
  }
}), Tj = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let r = t.state.field(xa);
    r == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(xa) != r || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(xa), r = e != null && t.coordsAtPos(e);
    if (!r)
      return null;
    let n = t.scrollDOM.getBoundingClientRect();
    return {
      left: r.left - n.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: r.top - n.top + t.scrollDOM.scrollTop * t.scaleY,
      height: r.bottom - r.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: r } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / r + "px", this.cursor.style.height = t.height / r + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(xa) != t && this.view.dispatch({ effects: dE.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function kj() {
  return [xa, Tj];
}
function $1(t, e, r, n, i) {
  e.lastIndex = 0;
  for (let s = t.iterRange(r, n), o = r, l; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; l = e.exec(s.value); )
        i(o + l.index, l);
}
function Fj(t, e) {
  let r = t.visibleRanges;
  if (r.length == 1 && r[0].from == t.viewport.from && r[0].to == t.viewport.to)
    return r;
  let n = [];
  for (let { from: i, to: s } of r)
    i = Math.max(t.state.doc.lineAt(i).from, i - e), s = Math.min(t.state.doc.lineAt(s).to, s + e), n.length && n[n.length - 1].to >= i ? n[n.length - 1].to = s : n.push({ from: i, to: s });
  return n;
}
class Pj {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: r, decoration: n, decorate: i, boundary: s, maxLength: o = 1e3 } = e;
    if (!r.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = r, i)
      this.addMatch = (l, u, h, p) => i(p, h, h + l[0].length, l, u);
    else if (typeof n == "function")
      this.addMatch = (l, u, h, p) => {
        let d = n(l, u, h);
        d && p(h, h + l[0].length, d);
      };
    else if (n)
      this.addMatch = (l, u, h, p) => p(h, h + l[0].length, n);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let r = new Mi(), n = r.add.bind(r);
    for (let { from: i, to: s } of Fj(e, this.maxLength))
      $1(e.state.doc, this.regexp, i, s, (o, l) => this.addMatch(l, e, o, n));
    return r.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, r) {
    let n = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((s, o, l, u) => {
      u > e.view.viewport.from && l < e.view.viewport.to && (n = Math.min(l, n), i = Math.max(u, i));
    }), e.viewportChanged || i - n > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, r.map(e.changes), n, i) : r;
  }
  updateRange(e, r, n, i) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, n), l = Math.min(s.to, i);
      if (l > o) {
        let u = e.state.doc.lineAt(o), h = u.to < l ? e.state.doc.lineAt(l) : u, p = Math.max(s.from, u.from), d = Math.min(s.to, h.to);
        if (this.boundary) {
          for (; o > u.from; o--)
            if (this.boundary.test(u.text[o - 1 - u.from])) {
              p = o;
              break;
            }
          for (; l < h.to; l++)
            if (this.boundary.test(h.text[l - h.from])) {
              d = l;
              break;
            }
        }
        let m = [], y, D = (b, C, A) => m.push(A.range(b, C));
        if (u == h)
          for (this.regexp.lastIndex = p - u.from; (y = this.regexp.exec(u.text)) && y.index < d - u.from; )
            this.addMatch(y, e, y.index + u.from, D);
        else
          $1(e.state.doc, this.regexp, p, d, (b, C) => this.addMatch(C, e, b, D));
        r = r.update({ filterFrom: p, filterTo: d, filter: (b, C) => b < p || C > d, add: m });
      }
    }
    return r;
  }
}
const uf = /x/.unicode != null ? "gu" : "g", Bj = /* @__PURE__ */ new RegExp(`[\0-\b
--\u2028\u2029\uFEFF-]`, uf), Ij = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let Tp = null;
function Nj() {
  var t;
  if (Tp == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    Tp = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return Tp || !1;
}
const Wu = /* @__PURE__ */ ge.define({
  combine(t) {
    let e = Mn(t, {
      render: null,
      specialChars: Bj,
      addSpecialChars: null
    });
    return (e.replaceTabs = !Nj()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, uf)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, uf)), e;
  }
});
function Mj(t = {}) {
  return [Wu.of(t), Oj()];
}
let R1 = null;
function Oj() {
  return R1 || (R1 = ct.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = xe.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(Wu)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new Pj({
        regexp: t.specialChars,
        decoration: (e, r, n) => {
          let { doc: i } = r.state, s = Ct(e[0], 0);
          if (s == 9) {
            let o = i.lineAt(n), l = r.state.tabSize, u = qo(o.text, l, n - o.from);
            return xe.replace({
              widget: new Rj((l - u % l) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = xe.replace({ widget: new $j(t, s) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(Wu);
      t.startState.facet(Wu) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const Lj = "";
function _j(t) {
  return t >= 32 ? Lj : t == 10 ? "" : String.fromCharCode(9216 + t);
}
class $j extends ni {
  constructor(e, r) {
    super(), this.options = e, this.code = r;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let r = _j(this.code), n = e.state.phrase("Control character") + " " + (Ij[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, n, r);
    if (i)
      return i;
    let s = document.createElement("span");
    return s.textContent = r, s.title = n, s.setAttribute("aria-label", n), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class Rj extends ni {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function jj() {
  return Wj;
}
const qj = /* @__PURE__ */ xe.line({ class: "cm-activeLine" }), Wj = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, r = [];
    for (let n of t.state.selection.ranges) {
      let i = t.lineBlockAt(n.head);
      i.from > e && (r.push(qj.range(i.from)), e = i.from);
    }
    return xe.set(r);
  }
}, {
  decorations: (t) => t.decorations
});
class Uj extends ni {
  constructor(e) {
    super(), this.content = e;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content), typeof this.content == "string" ? e.setAttribute("aria-label", "placeholder " + this.content) : e.setAttribute("aria-hidden", "true"), e;
  }
  coordsAt(e) {
    let r = e.firstChild ? Co(e.firstChild) : [];
    if (!r.length)
      return null;
    let n = window.getComputedStyle(e.parentNode), i = xh(r[0], n.direction != "rtl"), s = parseInt(n.lineHeight);
    return i.bottom - i.top > s * 1.5 ? { left: i.left, right: i.right, top: i.top, bottom: i.top + s } : i;
  }
  ignoreEvent() {
    return !1;
  }
}
function Hj(t) {
  return ct.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = t ? xe.set([xe.widget({ widget: new Uj(t), side: 1 }).range(0)]) : xe.none;
    }
    get decorations() {
      return this.view.state.doc.length ? xe.none : this.placeholder;
    }
  }, { decorations: (e) => e.decorations });
}
const cf = 2e3;
function Vj(t, e, r) {
  let n = Math.min(e.line, r.line), i = Math.max(e.line, r.line), s = [];
  if (e.off > cf || r.off > cf || e.col < 0 || r.col < 0) {
    let o = Math.min(e.off, r.off), l = Math.max(e.off, r.off);
    for (let u = n; u <= i; u++) {
      let h = t.doc.line(u);
      h.length <= l && s.push(K.range(h.from + o, h.to + l));
    }
  } else {
    let o = Math.min(e.col, r.col), l = Math.max(e.col, r.col);
    for (let u = n; u <= i; u++) {
      let h = t.doc.line(u), p = qd(h.text, o, t.tabSize, !0);
      if (p < 0)
        s.push(K.cursor(h.to));
      else {
        let d = qd(h.text, l, t.tabSize);
        s.push(K.range(h.from + p, h.from + d));
      }
    }
  }
  return s;
}
function zj(t, e) {
  let r = t.coordsAtPos(t.viewport.from);
  return r ? Math.round(Math.abs((r.left - e) / t.defaultCharacterWidth)) : -1;
}
function j1(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), n = t.state.doc.lineAt(r), i = r - n.from, s = i > cf ? -1 : i == n.length ? zj(t, e.clientX) : qo(n.text, t.state.tabSize, r - n.from);
  return { line: n.number, col: s, off: i };
}
function Jj(t, e) {
  let r = j1(t, e), n = t.state.selection;
  return r ? {
    update(i) {
      if (i.docChanged) {
        let s = i.changes.mapPos(i.startState.doc.line(r.line).from), o = i.state.doc.lineAt(s);
        r = { line: o.number, col: r.col, off: Math.min(r.off, o.length) }, n = n.map(i.changes);
      }
    },
    get(i, s, o) {
      let l = j1(t, i);
      if (!l)
        return n;
      let u = Vj(t.state, r, l);
      return u.length ? o ? K.create(u.concat(n.ranges)) : K.create(u) : n;
    }
  } : null;
}
function Kj(t) {
  let e = (t == null ? void 0 : t.eventFilter) || ((r) => r.altKey && r.button == 0);
  return ce.mouseSelectionStyle.of((r, n) => e(n) ? Jj(r, n) : null);
}
const Gj = {
  Alt: [18, (t) => !!t.altKey],
  Control: [17, (t) => !!t.ctrlKey],
  Shift: [16, (t) => !!t.shiftKey],
  Meta: [91, (t) => !!t.metaKey]
}, Xj = { style: "cursor: crosshair" };
function Yj(t = {}) {
  let [e, r] = Gj[t.key || "Alt"], n = ct.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || r(i));
      },
      keyup(i) {
        (i.keyCode == e || !r(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(r(i));
      }
    }
  });
  return [
    n,
    ce.contentAttributes.of((i) => {
      var s;
      return !((s = i.plugin(n)) === null || s === void 0) && s.isDown ? Xj : null;
    })
  ];
}
const aa = "-10000px";
class fE {
  constructor(e, r, n, i) {
    this.facet = r, this.createTooltipView = n, this.removeTooltipView = i, this.input = e.state.facet(r), this.tooltips = this.input.filter((o) => o);
    let s = null;
    this.tooltipViews = this.tooltips.map((o) => s = n(o, s));
  }
  update(e, r) {
    var n;
    let i = e.state.facet(this.facet), s = i.filter((u) => u);
    if (i === this.input) {
      for (let u of this.tooltipViews)
        u.update && u.update(e);
      return !1;
    }
    let o = [], l = r ? [] : null;
    for (let u = 0; u < s.length; u++) {
      let h = s[u], p = -1;
      if (h) {
        for (let d = 0; d < this.tooltips.length; d++) {
          let m = this.tooltips[d];
          m && m.create == h.create && (p = d);
        }
        if (p < 0)
          o[u] = this.createTooltipView(h, u ? o[u - 1] : null), l && (l[u] = !!h.above);
        else {
          let d = o[u] = this.tooltipViews[p];
          l && (l[u] = r[p]), d.update && d.update(e);
        }
      }
    }
    for (let u of this.tooltipViews)
      o.indexOf(u) < 0 && (this.removeTooltipView(u), (n = u.destroy) === null || n === void 0 || n.call(u));
    return r && (l.forEach((u, h) => r[h] = u), r.length = l.length), this.input = i, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function Qj(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const kp = /* @__PURE__ */ ge.define({
  combine: (t) => {
    var e, r, n;
    return {
      position: me.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((r = t.find((i) => i.parent)) === null || r === void 0 ? void 0 : r.parent) || null,
      tooltipSpace: ((n = t.find((i) => i.tooltipSpace)) === null || n === void 0 ? void 0 : n.tooltipSpace) || Qj
    };
  }
}), q1 = /* @__PURE__ */ new WeakMap(), yg = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(kp);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new fE(t, Dg, (r, n) => this.createTooltip(r, n), (r) => {
      this.resizeObserver && this.resizeObserver.unobserve(r.dom), r.dom.remove();
    }), this.above = this.manager.tooltips.map((r) => !!r.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((r) => {
      Date.now() > this.lastTransaction - 50 && r.length > 0 && r[r.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let r = e || t.geometryChanged, n = t.state.facet(kp);
    if (n.position != this.position && !this.madeAbsolute) {
      this.position = n.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      r = !0;
    }
    if (n.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = n.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      r = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    r && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let r = t.create(this.view), n = e ? e.dom : null;
    if (r.dom.classList.add("cm-tooltip"), t.arrow && !r.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", r.dom.insertBefore(i, n);
    }
    return r.dom.style.position = this.position, r.dom.style.top = aa, r.dom.style.left = "0px", this.container.insertBefore(r.dom, n), r.mount && r.mount(this.view), this.resizeObserver && this.resizeObserver.observe(r.dom), r;
  }
  destroy() {
    var t, e, r;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let n of this.manager.tooltipViews)
      n.dom.remove(), (t = n.destroy) === null || t === void 0 || t.call(n);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (r = this.intersectionObserver) === null || r === void 0 || r.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = this.view.dom.getBoundingClientRect(), e = 1, r = 1, n = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: i } = this.manager.tooltipViews[0];
      if (me.gecko)
        n = i.offsetParent != this.container.ownerDocument.body;
      else if (i.style.top == aa && i.style.left == "0px") {
        let s = i.getBoundingClientRect();
        n = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (n || this.position == "absolute")
      if (this.parent) {
        let i = this.parent.getBoundingClientRect();
        i.width && i.height && (e = i.width / this.parent.offsetWidth, r = i.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: r } = this.view.viewState);
    return {
      editor: t,
      parent: this.parent ? this.container.getBoundingClientRect() : t,
      pos: this.manager.tooltips.map((i, s) => {
        let o = this.manager.tooltipViews[s];
        return o.getCoords ? o.getCoords(i.pos) : this.view.coordsAtPos(i.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: i }) => i.getBoundingClientRect()),
      space: this.view.state.facet(kp).tooltipSpace(this.view),
      scaleX: e,
      scaleY: r,
      makeAbsolute: n
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let l of this.manager.tooltipViews)
        l.dom.style.position = "absolute";
    }
    let { editor: r, space: n, scaleX: i, scaleY: s } = t, o = [];
    for (let l = 0; l < this.manager.tooltips.length; l++) {
      let u = this.manager.tooltips[l], h = this.manager.tooltipViews[l], { dom: p } = h, d = t.pos[l], m = t.size[l];
      if (!d || d.bottom <= Math.max(r.top, n.top) || d.top >= Math.min(r.bottom, n.bottom) || d.right < Math.max(r.left, n.left) - 0.1 || d.left > Math.min(r.right, n.right) + 0.1) {
        p.style.top = aa;
        continue;
      }
      let y = u.arrow ? h.dom.querySelector(".cm-tooltip-arrow") : null, D = y ? 7 : 0, b = m.right - m.left, C = (e = q1.get(h)) !== null && e !== void 0 ? e : m.bottom - m.top, A = h.offset || eq, x = this.view.textDirection == tt.LTR, E = m.width > n.right - n.left ? x ? n.left : n.right - m.width : x ? Math.min(d.left - (y ? 14 : 0) + A.x, n.right - b) : Math.max(n.left, d.left - b + (y ? 14 : 0) - A.x), k = this.above[l];
      !u.strictSide && (k ? d.top - (m.bottom - m.top) - A.y < n.top : d.bottom + (m.bottom - m.top) + A.y > n.bottom) && k == n.bottom - d.bottom > d.top - n.top && (k = this.above[l] = !k);
      let w = (k ? d.top - n.top : n.bottom - d.bottom) - D;
      if (w < C && h.resize !== !1) {
        if (w < this.view.defaultLineHeight) {
          p.style.top = aa;
          continue;
        }
        q1.set(h, C), p.style.height = (C = w) / s + "px";
      } else
        p.style.height && (p.style.height = "");
      let T = k ? d.top - C - D - A.y : d.bottom + D + A.y, P = E + b;
      if (h.overlap !== !0)
        for (let M of o)
          M.left < P && M.right > E && M.top < T + C && M.bottom > T && (T = k ? M.top - C - 2 - D : M.bottom + D + 2);
      if (this.position == "absolute" ? (p.style.top = (T - t.parent.top) / s + "px", p.style.left = (E - t.parent.left) / i + "px") : (p.style.top = T / s + "px", p.style.left = E / i + "px"), y) {
        let M = d.left + (x ? A.x : -A.x) - (E + 14 - 7);
        y.style.left = M / i + "px";
      }
      h.overlap !== !0 && o.push({ left: E, top: T, right: P, bottom: T + C }), p.classList.toggle("cm-tooltip-above", k), p.classList.toggle("cm-tooltip-below", !k), h.positioned && h.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = aa;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), Zj = /* @__PURE__ */ ce.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), eq = { x: 0, y: 0 }, Dg = /* @__PURE__ */ ge.define({
  enables: [yg, Zj]
}), hc = /* @__PURE__ */ ge.define({
  combine: (t) => t.reduce((e, r) => e.concat(r), [])
});
class Ah {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Ah(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new fE(e, hc, (r, n) => this.createHostedView(r, n), (r) => r.dom.remove());
  }
  createHostedView(e, r) {
    let n = e.create(this.view);
    return n.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(n.dom, r ? r.dom.nextSibling : this.dom.firstChild), this.mounted && n.mount && n.mount(this.view), n;
  }
  mount(e) {
    for (let r of this.manager.tooltipViews)
      r.mount && r.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let r of this.manager.tooltipViews)
      r.positioned && r.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let r of this.manager.tooltipViews)
      (e = r.destroy) === null || e === void 0 || e.call(r);
  }
  passProp(e) {
    let r;
    for (let n of this.manager.tooltipViews) {
      let i = n[e];
      if (i !== void 0) {
        if (r === void 0)
          r = i;
        else if (r !== i)
          return;
      }
    }
    return r;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const tq = /* @__PURE__ */ Dg.compute([hc], (t) => {
  let e = t.facet(hc);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((r) => r.pos)),
    end: Math.max(...e.map((r) => {
      var n;
      return (n = r.end) !== null && n !== void 0 ? n : r.pos;
    })),
    create: Ah.create,
    above: e[0].above,
    arrow: e.some((r) => r.arrow)
  };
});
class rq {
  constructor(e, r, n, i, s) {
    this.view = e, this.source = r, this.field = n, this.setHover = i, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: r } = this, n = e.docView.nearest(r.target);
    if (!n)
      return;
    let i, s = 1;
    if (n instanceof vi)
      i = n.posAtStart;
    else {
      if (i = e.posAtCoords(r), i == null)
        return;
      let l = e.coordsAtPos(i);
      if (!l || r.y < l.top || r.y > l.bottom || r.x < l.left - e.defaultCharacterWidth || r.x > l.right + e.defaultCharacterWidth)
        return;
      let u = e.bidiSpans(e.state.doc.lineAt(i)).find((p) => p.from <= i && p.to >= i), h = u && u.dir == tt.RTL ? -1 : 1;
      s = r.x < l.left ? -h : h;
    }
    let o = this.source(e, i, s);
    if (o != null && o.then) {
      let l = this.pending = { pos: i };
      o.then((u) => {
        this.pending == l && (this.pending = null, u && !(Array.isArray(u) && !u.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(u) ? u : [u]) }));
      }, (u) => Br(e.state, u, "hover tooltip"));
    } else
      o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let e = this.view.plugin(yg), r = e ? e.manager.tooltips.findIndex((n) => n.create == Ah.create) : -1;
    return r > -1 ? e.manager.tooltipViews[r] : null;
  }
  mousemove(e) {
    var r, n;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: s } = this;
    if (i.length && s && !nq(s.dom, e) || this.pending) {
      let { pos: o } = i[0] || this.pending, l = (n = (r = i[0]) === null || r === void 0 ? void 0 : r.end) !== null && n !== void 0 ? n : o;
      (o == l ? this.view.posAtCoords(this.lastMove) != o : !iq(this.view, o, l, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: r } = this;
    if (r.length) {
      let { tooltip: n } = this;
      n && n.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(n.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let r = (n) => {
      e.removeEventListener("mouseleave", r), this.active.length && !this.view.dom.contains(n.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", r);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const mu = 4;
function nq(t, e) {
  let r = t.getBoundingClientRect();
  return e.clientX >= r.left - mu && e.clientX <= r.right + mu && e.clientY >= r.top - mu && e.clientY <= r.bottom + mu;
}
function iq(t, e, r, n, i, s) {
  let o = t.scrollDOM.getBoundingClientRect(), l = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (o.left > n || o.right < n || o.top > i || Math.min(o.bottom, l) < i)
    return !1;
  let u = t.posAtCoords({ x: n, y: i }, !1);
  return u >= e && u <= r;
}
function sq(t, e = {}) {
  let r = Se.define(), n = Nt.define({
    create() {
      return [];
    },
    update(i, s) {
      if (i.length && (e.hideOnChange && (s.docChanged || s.selection) ? i = [] : e.hideOn && (i = i.filter((o) => !e.hideOn(s, o))), s.docChanged))
        for (let o of i) {
          let l = s.changes.mapPos(o.pos, -1, Kt.TrackDel);
          if (l != null) {
            let u = Object.assign(/* @__PURE__ */ Object.create(null), o);
            u.pos = l, u.end != null && (u.end = s.changes.mapPos(u.end));
          }
        }
      for (let o of s.effects)
        o.is(r) && (i = o.value), o.is(oq) && (i = []);
      return i;
    },
    provide: (i) => hc.from(i)
  });
  return [
    n,
    ct.define((i) => new rq(
      i,
      t,
      n,
      r,
      e.hoverTime || 300
      /* Hover.Time */
    )),
    tq
  ];
}
function mE(t, e) {
  let r = t.plugin(yg);
  if (!r)
    return null;
  let n = r.manager.tooltips.indexOf(e);
  return n < 0 ? null : r.manager.tooltipViews[n];
}
const oq = /* @__PURE__ */ Se.define(), W1 = /* @__PURE__ */ ge.define({
  combine(t) {
    let e, r;
    for (let n of t)
      e = e || n.topContainer, r = r || n.bottomContainer;
    return { topContainer: e, bottomContainer: r };
  }
});
function Za(t, e) {
  let r = t.plugin(gE), n = r ? r.specs.indexOf(e) : -1;
  return n > -1 ? r.panels[n] : null;
}
const gE = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(el), this.specs = this.input.filter((r) => r), this.panels = this.specs.map((r) => r(t));
    let e = t.state.facet(W1);
    this.top = new gu(t, !0, e.topContainer), this.bottom = new gu(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((r) => r.top)), this.bottom.sync(this.panels.filter((r) => !r.top));
    for (let r of this.panels)
      r.dom.classList.add("cm-panel"), r.mount && r.mount();
  }
  update(t) {
    let e = t.state.facet(W1);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new gu(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new gu(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let r = t.state.facet(el);
    if (r != this.input) {
      let n = r.filter((u) => u), i = [], s = [], o = [], l = [];
      for (let u of n) {
        let h = this.specs.indexOf(u), p;
        h < 0 ? (p = u(t.view), l.push(p)) : (p = this.panels[h], p.update && p.update(t)), i.push(p), (p.top ? s : o).push(p);
      }
      this.specs = n, this.panels = i, this.top.sync(s), this.bottom.sync(o);
      for (let u of l)
        u.dom.classList.add("cm-panel"), u.mount && u.mount();
    } else
      for (let n of this.panels)
        n.update && n.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => ce.scrollMargins.of((e) => {
    let r = e.plugin(t);
    return r && { top: r.top.scrollMargin(), bottom: r.bottom.scrollMargin() };
  })
});
class gu {
  constructor(e, r, n) {
    this.view = e, this.top = r, this.container = n, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let r of this.panels)
      r.destroy && e.indexOf(r) < 0 && r.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let r = this.container || this.view.dom;
      r.insertBefore(this.dom, this.top ? r.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let r of this.panels)
      if (r.dom.parentNode == this.dom) {
        for (; e != r.dom; )
          e = U1(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(r.dom, e);
    for (; e; )
      e = U1(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function U1(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const el = /* @__PURE__ */ ge.define({
  enables: gE
});
class Kn extends xs {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
Kn.prototype.elementClass = "";
Kn.prototype.toDOM = void 0;
Kn.prototype.mapMode = Kt.TrackBefore;
Kn.prototype.startSide = Kn.prototype.endSide = -1;
Kn.prototype.point = !0;
const Uu = /* @__PURE__ */ ge.define(), aq = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => _e.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, La = /* @__PURE__ */ ge.define();
function lq(t) {
  return [yE(), La.of(Object.assign(Object.assign({}, aq), t))];
}
const hf = /* @__PURE__ */ ge.define({
  combine: (t) => t.some((e) => e)
});
function yE(t) {
  let e = [
    uq
  ];
  return t && t.fixed === !1 && e.push(hf.of(!0)), e;
}
const uq = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(La).map((e) => new V1(t, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !t.state.facet(hf), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, r = t.view.viewport, n = Math.min(e.to, r.to) - Math.max(e.from, r.from);
      this.syncGutters(n < (r.to - r.from) * 0.8);
    }
    t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(hf) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && this.dom.remove();
    let r = _e.iter(this.view.state.facet(Uu), this.view.viewport.from), n = [], i = this.gutters.map((s) => new cq(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (n.length && (n = []), Array.isArray(s.type)) {
        let o = !0;
        for (let l of s.type)
          if (l.type == Xt.Text && o) {
            pf(r, n, l.from);
            for (let u of i)
              u.line(this.view, l, n);
            o = !1;
          } else if (l.widget)
            for (let u of i)
              u.widget(this.view, l);
      } else if (s.type == Xt.Text) {
        pf(r, n, s.from);
        for (let o of i)
          o.line(this.view, s, n);
      } else if (s.widget)
        for (let o of i)
          o.widget(this.view, s);
    for (let s of i)
      s.finish();
    t && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(t) {
    let e = t.startState.facet(La), r = t.state.facet(La), n = t.docChanged || t.heightChanged || t.viewportChanged || !_e.eq(t.startState.facet(Uu), t.state.facet(Uu), t.view.viewport.from, t.view.viewport.to);
    if (e == r)
      for (let i of this.gutters)
        i.update(t) && (n = !0);
    else {
      n = !0;
      let i = [];
      for (let s of r) {
        let o = e.indexOf(s);
        o < 0 ? i.push(new V1(this.view, s)) : (this.gutters[o].update(t), i.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), i.indexOf(s) < 0 && s.destroy();
      for (let s of i)
        this.dom.appendChild(s.dom);
      this.gutters = i;
    }
    return n;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove();
  }
}, {
  provide: (t) => ce.scrollMargins.of((e) => {
    let r = e.plugin(t);
    return !r || r.gutters.length == 0 || !r.fixed ? null : e.textDirection == tt.LTR ? { left: r.dom.offsetWidth * e.scaleX } : { right: r.dom.offsetWidth * e.scaleX };
  })
});
function H1(t) {
  return Array.isArray(t) ? t : [t];
}
function pf(t, e, r) {
  for (; t.value && t.from <= r; )
    t.from == r && e.push(t.value), t.next();
}
class cq {
  constructor(e, r, n) {
    this.gutter = e, this.height = n, this.i = 0, this.cursor = _e.iter(e.markers, r.from);
  }
  addElement(e, r, n) {
    let { gutter: i } = this, s = (r.top - this.height) / e.scaleY, o = r.height / e.scaleY;
    if (this.i == i.elements.length) {
      let l = new DE(e, o, s, n);
      i.elements.push(l), i.dom.appendChild(l.dom);
    } else
      i.elements[this.i].update(e, o, s, n);
    this.height = r.bottom, this.i++;
  }
  line(e, r, n) {
    let i = [];
    pf(this.cursor, i, r.from), n.length && (i = i.concat(n));
    let s = this.gutter.config.lineMarker(e, r, i);
    s && i.unshift(s);
    let o = this.gutter;
    i.length == 0 && !o.config.renderEmptyElements || this.addElement(e, r, i);
  }
  widget(e, r) {
    let n = this.gutter.config.widgetMarker(e, r.widget, r);
    n && this.addElement(e, r, [n]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let r = e.elements.pop();
      e.dom.removeChild(r.dom), r.destroy();
    }
  }
}
class V1 {
  constructor(e, r) {
    this.view = e, this.config = r, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let n in r.domEventHandlers)
      this.dom.addEventListener(n, (i) => {
        let s = i.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let u = s.getBoundingClientRect();
          o = (u.top + u.bottom) / 2;
        } else
          o = i.clientY;
        let l = e.lineBlockAtHeight(o - e.documentTop);
        r.domEventHandlers[n](e, l, i) && i.preventDefault();
      });
    this.markers = H1(r.markers(e)), r.initialSpacer && (this.spacer = new DE(e, 0, 0, [r.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let r = this.markers;
    if (this.markers = H1(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let n = e.view.viewport;
    return !_e.eq(this.markers, r, n.from, n.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class DE {
  constructor(e, r, n, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, r, n, i);
  }
  update(e, r, n, i) {
    this.height != r && (this.height = r, this.dom.style.height = r + "px"), this.above != n && (this.dom.style.marginTop = (this.above = n) ? n + "px" : ""), hq(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, r) {
    let n = "cm-gutterElement", i = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let l = o, u = s < r.length ? r[s++] : null, h = !1;
      if (u) {
        let p = u.elementClass;
        p && (n += " " + p);
        for (let d = o; d < this.markers.length; d++)
          if (this.markers[d].compare(u)) {
            l = d, h = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; o < l; ) {
        let p = this.markers[o++];
        if (p.toDOM) {
          p.destroy(i);
          let d = i.nextSibling;
          i.remove(), i = d;
        }
      }
      if (!u)
        break;
      u.toDOM && (h ? i = i.nextSibling : this.dom.insertBefore(u.toDOM(e), i)), h && o++;
    }
    this.dom.className = n, this.markers = r;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function hq(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!t[r].compare(e[r]))
      return !1;
  return !0;
}
const pq = /* @__PURE__ */ ge.define(), io = /* @__PURE__ */ ge.define({
  combine(t) {
    return Mn(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, r) {
        let n = Object.assign({}, e);
        for (let i in r) {
          let s = n[i], o = r[i];
          n[i] = s ? (l, u, h) => s(l, u, h) || o(l, u, h) : o;
        }
        return n;
      }
    });
  }
});
class Fp extends Kn {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Pp(t, e) {
  return t.state.facet(io).formatNumber(e, t.state);
}
const dq = /* @__PURE__ */ La.compute([io], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(pq);
  },
  lineMarker(e, r, n) {
    return n.some((i) => i.toDOM) ? null : new Fp(Pp(e, e.state.doc.lineAt(r.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(io) != e.state.facet(io),
  initialSpacer(e) {
    return new Fp(Pp(e, z1(e.state.doc.lines)));
  },
  updateSpacer(e, r) {
    let n = Pp(r.view, z1(r.view.state.doc.lines));
    return n == e.number ? e : new Fp(n);
  },
  domEventHandlers: t.facet(io).domEventHandlers
}));
function fq(t = {}) {
  return [
    io.of(t),
    yE(),
    dq
  ];
}
function z1(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const mq = /* @__PURE__ */ new class extends Kn {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), gq = /* @__PURE__ */ Uu.compute(["selection"], (t) => {
  let e = [], r = -1;
  for (let n of t.selection.ranges) {
    let i = t.doc.lineAt(n.head).from;
    i > r && (r = i, e.push(mq.range(i)));
  }
  return _e.of(e);
});
function yq() {
  return gq;
}
const Dq = 1024;
let xq = 0;
class Bp {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
class Me {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = xq++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = jr.match(e)), (r) => {
      let n = e(r);
      return n === void 0 ? null : [this, n];
    };
  }
}
Me.closedBy = new Me({ deserialize: (t) => t.split(" ") });
Me.openedBy = new Me({ deserialize: (t) => t.split(" ") });
Me.group = new Me({ deserialize: (t) => t.split(" ") });
Me.isolate = new Me({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
Me.contextHash = new Me({ perNode: !0 });
Me.lookAhead = new Me({ perNode: !0 });
Me.mounted = new Me({ perNode: !0 });
class pc {
  constructor(e, r, n) {
    this.tree = e, this.overlay = r, this.parser = n;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[Me.mounted.id];
  }
}
const bq = /* @__PURE__ */ Object.create(null);
class jr {
  /**
  @internal
  */
  constructor(e, r, n, i = 0) {
    this.name = e, this.props = r, this.id = n, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let r = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : bq, n = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new jr(e.name || "", r, e.id, n);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(i)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          r[s[0].id] = s[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let r = this.prop(Me.group);
      return r ? r.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let n in e)
      for (let i of n.split(" "))
        r[i] = e[n];
    return (n) => {
      for (let i = n.prop(Me.group), s = -1; s < (i ? i.length : 0); s++) {
        let o = r[s < 0 ? n.name : i[s]];
        if (o)
          return o;
      }
    };
  }
}
jr.none = new jr(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
const yu = /* @__PURE__ */ new WeakMap(), J1 = /* @__PURE__ */ new WeakMap();
var Et;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Et || (Et = {}));
class jt {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, r, n, i, s) {
    if (this.type = e, this.children = r, this.positions = n, this.length = i, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, l] of s)
        this.props[typeof o == "number" ? o : o.id] = l;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = pc.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let r = "";
    for (let n of this.children) {
      let i = n.toString();
      i && (r && (r += ","), r += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (r.length ? "(" + r + ")" : "") : r;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new ff(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, r = 0, n = 0) {
    let i = yu.get(this) || this.topNode, s = new ff(i);
    return s.moveTo(e, r), yu.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Nr(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, r = 0) {
    let n = tl(yu.get(this) || this.topNode, e, r, !1);
    return yu.set(this, n), n;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, r = 0) {
    let n = tl(J1.get(this) || this.topNode, e, r, !0);
    return J1.set(this, n), n;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, r = 0) {
    return Aq(this, e, r);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: r, leave: n, from: i = 0, to: s = this.length } = e, o = e.mode || 0, l = (o & Et.IncludeAnonymous) > 0;
    for (let u = this.cursor(o | Et.IncludeAnonymous); ; ) {
      let h = !1;
      if (u.from <= s && u.to >= i && (!l && u.type.isAnonymous || r(u) !== !1)) {
        if (u.firstChild())
          continue;
        h = !0;
      }
      for (; h && n && (l || !u.type.isAnonymous) && n(u), !u.nextSibling(); ) {
        if (!u.parent())
          return;
        h = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let r in this.props)
        e.push([+r, this.props[r]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : vg(jr.none, this.children, this.positions, 0, this.children.length, 0, this.length, (r, n, i) => new jt(this.type, r, n, i, this.propValues), e.makeTree || ((r, n, i) => new jt(jr.none, r, n, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return Eq(e);
  }
}
jt.empty = new jt(jr.none, [], [], 0);
class xg {
  constructor(e, r) {
    this.buffer = e, this.index = r;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new xg(this.buffer, this.index);
  }
}
class $i {
  /**
  Create a tree buffer.
  */
  constructor(e, r, n) {
    this.buffer = e, this.length = r, this.set = n;
  }
  /**
  @internal
  */
  get type() {
    return jr.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let r = 0; r < this.buffer.length; )
      e.push(this.childString(r)), r = this.buffer[r + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let r = this.buffer[e], n = this.buffer[e + 3], i = this.set.types[r], s = i.name;
    if (/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), e += 4, n == e)
      return s;
    let o = [];
    for (; e < n; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, r, n, i, s) {
    let { buffer: o } = this, l = -1;
    for (let u = e; u != r && !(xE(s, i, o[u + 1], o[u + 2]) && (l = u, n > 0)); u = o[u + 3])
      ;
    return l;
  }
  /**
  @internal
  */
  slice(e, r, n) {
    let i = this.buffer, s = new Uint16Array(r - e), o = 0;
    for (let l = e, u = 0; l < r; ) {
      s[u++] = i[l++], s[u++] = i[l++] - n;
      let h = s[u++] = i[l++] - n;
      s[u++] = i[l++] - e, o = Math.max(o, h);
    }
    return new $i(s, o, this.set);
  }
}
function xE(t, e, r, n) {
  switch (t) {
    case -2:
      return r < e;
    case -1:
      return n >= e && r < e;
    case 0:
      return r < e && n > e;
    case 1:
      return r <= e && n > e;
    case 2:
      return n > e;
    case 4:
      return !0;
  }
}
function tl(t, e, r, n) {
  for (var i; t.from == t.to || (r < 1 ? t.from >= e : t.from > e) || (r > -1 ? t.to <= e : t.to < e); ) {
    let o = !n && t instanceof Nr && t.index < 0 ? null : t.parent;
    if (!o)
      return t;
    t = o;
  }
  let s = n ? 0 : Et.IgnoreOverlays;
  if (n)
    for (let o = t, l = o.parent; l; o = l, l = o.parent)
      o instanceof Nr && o.index < 0 && ((i = l.enter(e, r, s)) === null || i === void 0 ? void 0 : i.from) != o.from && (t = l);
  for (; ; ) {
    let o = t.enter(e, r, s);
    if (!o)
      return t;
    t = o;
  }
}
class bE {
  cursor(e = 0) {
    return new ff(this, e);
  }
  getChild(e, r = null, n = null) {
    let i = K1(this, e, r, n);
    return i.length ? i[0] : null;
  }
  getChildren(e, r = null, n = null) {
    return K1(this, e, r, n);
  }
  resolve(e, r = 0) {
    return tl(this, e, r, !1);
  }
  resolveInner(e, r = 0) {
    return tl(this, e, r, !0);
  }
  matchContext(e) {
    return df(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let r = this.childBefore(e), n = this;
    for (; r; ) {
      let i = r.lastChild;
      if (!i || i.to != r.to)
        break;
      i.type.isError && i.from == i.to ? (n = r, r = i.prevSibling) : r = i;
    }
    return n;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Nr extends bE {
  constructor(e, r, n, i) {
    super(), this._tree = e, this.from = r, this.index = n, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, r, n, i, s = 0) {
    for (let o = this; ; ) {
      for (let { children: l, positions: u } = o._tree, h = r > 0 ? l.length : -1; e != h; e += r) {
        let p = l[e], d = u[e] + o.from;
        if (xE(i, n, d, d + p.length)) {
          if (p instanceof $i) {
            if (s & Et.ExcludeBuffers)
              continue;
            let m = p.findChild(0, p.buffer.length, r, n - d, i);
            if (m > -1)
              return new Ai(new vq(o, p, e, d), null, m);
          } else if (s & Et.IncludeAnonymous || !p.type.isAnonymous || bg(p)) {
            let m;
            if (!(s & Et.IgnoreMounts) && (m = pc.get(p)) && !m.overlay)
              return new Nr(m.tree, d, e, o);
            let y = new Nr(p, d, e, o);
            return s & Et.IncludeAnonymous || !y.type.isAnonymous ? y : y.nextChild(r < 0 ? p.children.length - 1 : 0, r, n, i);
          }
        }
      }
      if (s & Et.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + r : e = r < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, n = 0) {
    let i;
    if (!(n & Et.IgnoreOverlays) && (i = pc.get(this._tree)) && i.overlay) {
      let s = e - this.from;
      for (let { from: o, to: l } of i.overlay)
        if ((r > 0 ? o <= s : o < s) && (r < 0 ? l >= s : l > s))
          return new Nr(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, r, n);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function K1(t, e, r, n) {
  let i = t.cursor(), s = [];
  if (!i.firstChild())
    return s;
  if (r != null) {
    for (let o = !1; !o; )
      if (o = i.type.is(r), !i.nextSibling())
        return s;
  }
  for (; ; ) {
    if (n != null && i.type.is(n))
      return s;
    if (i.type.is(e) && s.push(i.node), !i.nextSibling())
      return n == null ? s : [];
  }
}
function df(t, e, r = e.length - 1) {
  for (let n = t.parent; r >= 0; n = n.parent) {
    if (!n)
      return !1;
    if (!n.type.isAnonymous) {
      if (e[r] && e[r] != n.name)
        return !1;
      r--;
    }
  }
  return !0;
}
class vq {
  constructor(e, r, n, i) {
    this.parent = e, this.buffer = r, this.index = n, this.start = i;
  }
}
class Ai extends bE {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, r, n) {
    super(), this.context = e, this._parent = r, this.index = n, this.type = e.buffer.set.types[e.buffer.buffer[n]];
  }
  child(e, r, n) {
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.context.start, n);
    return s < 0 ? null : new Ai(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, n = 0) {
    if (n & Et.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], r > 0 ? 1 : -1, e - this.context.start, r);
    return s < 0 ? null : new Ai(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, r = e.buffer[this.index + 3];
    return r < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Ai(this.context, this._parent, r) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, r = this._parent ? this._parent.index + 4 : 0;
    return this.index == r ? this.externalSibling(-1) : new Ai(this.context, this._parent, e.findChild(
      r,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], r = [], { buffer: n } = this.context, i = this.index + 4, s = n.buffer[this.index + 3];
    if (s > i) {
      let o = n.buffer[this.index + 1];
      e.push(n.slice(i, s, o)), r.push(0);
    }
    return new jt(this.type, e, r, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function vE(t) {
  if (!t.length)
    return null;
  let e = 0, r = t[0];
  for (let s = 1; s < t.length; s++) {
    let o = t[s];
    (o.from > r.from || o.to < r.to) && (r = o, e = s);
  }
  let n = r instanceof Nr && r.index < 0 ? null : r.parent, i = t.slice();
  return n ? i[e] = n : i.splice(e, 1), new Cq(i, r);
}
class Cq {
  constructor(e, r) {
    this.heads = e, this.node = r;
  }
  get next() {
    return vE(this.heads);
  }
}
function Aq(t, e, r) {
  let n = t.resolveInner(e, r), i = null;
  for (let s = n instanceof Nr ? n : n.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (i || (i = [n])).push(o.resolve(e, r)), s = o;
    } else {
      let o = pc.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let l = new Nr(o.tree, o.overlay[0].from + s.from, -1, s);
        (i || (i = [n])).push(tl(l, e, r, !1));
      }
    }
  return i ? vE(i) : n;
}
class ff {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, r = 0) {
    if (this.mode = r, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Nr)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let n = e._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, r) {
    this.index = e;
    let { start: n, buffer: i } = this.buffer;
    return this.type = r || i.set.types[i.buffer[e]], this.from = n + i.buffer[e + 1], this.to = n + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Nr ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, r, n) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, r, n, this.mode));
    let { buffer: i } = this.buffer, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.buffer.start, n);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, r, n = this.mode) {
    return this.buffer ? n & Et.ExcludeBuffers ? !1 : this.enterChild(1, e, r) : this.yield(this._tree.enter(e, r, n));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Et.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Et.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: r } = this.buffer, n = this.stack.length - 1;
    if (e < 0) {
      let i = n < 0 ? 0 : this.stack[n] + 4;
      if (this.index != i)
        return this.yieldBuf(r.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = r.buffer[this.index + 3];
      if (i < (n < 0 ? r.buffer.length : r.buffer[this.stack[n] + 3]))
        return this.yieldBuf(i);
    }
    return n < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let r, n, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (i.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: r, parent: n } = i);
    } else
      ({ index: r, _parent: n } = this._tree);
    for (; n; { index: r, _parent: n } = n)
      if (r > -1)
        for (let s = r + e, o = e < 0 ? -1 : n._tree.children.length; s != o; s += e) {
          let l = n._tree.children[s];
          if (this.mode & Et.IncludeAnonymous || l instanceof $i || !l.type.isAnonymous || bg(l))
            return !1;
        }
    return !0;
  }
  move(e, r) {
    if (r && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, r = 0) {
    for (; (this.from == this.to || (r < 1 ? this.from >= e : this.from > e) || (r > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, r); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, r = null, n = 0;
    if (e && e.context == this.buffer)
      e:
        for (let i = this.index, s = this.stack.length; s >= 0; ) {
          for (let o = e; o; o = o._parent)
            if (o.index == i) {
              if (i == this.index)
                return o;
              r = o, n = s + 1;
              break e;
            }
          i = this.stack[--s];
        }
    for (let i = n; i < this.stack.length; i++)
      r = new Ai(this.buffer, r, this.stack[i]);
    return this.bufferNode = new Ai(this.buffer, r, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, r) {
    for (let n = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          n++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; i && r && r(this), i = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!n)
          return;
        this.parent(), n--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return df(this.node, e);
    let { buffer: r } = this.buffer, { types: n } = r.set;
    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0)
        return df(this.node, e, i);
      let o = n[r.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[i] && e[i] != o.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function bg(t) {
  return t.children.some((e) => e instanceof $i || !e.type.isAnonymous || bg(e));
}
function Eq(t) {
  var e;
  let { buffer: r, nodeSet: n, maxBufferLength: i = Dq, reused: s = [], minRepeatType: o = n.types.length } = t, l = Array.isArray(r) ? new xg(r, r.length) : r, u = n.types, h = 0, p = 0;
  function d(w, T, P, M, N, L) {
    let { id: j, start: X, end: Q, size: $ } = l, U = p;
    for (; $ < 0; )
      if (l.next(), $ == -1) {
        let ve = s[j];
        P.push(ve), M.push(X - w);
        return;
      } else if ($ == -3) {
        h = j;
        return;
      } else if ($ == -4) {
        p = j;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${$}`);
    let H = u[j], Z, ye, Ee = X - w;
    if (Q - X <= i && (ye = C(l.pos - T, N))) {
      let ve = new Uint16Array(ye.size - ye.skip), $e = l.pos - ye.size, Ke = ve.length;
      for (; l.pos > $e; )
        Ke = A(ye.start, ve, Ke);
      Z = new $i(ve, Q - ye.start, n), Ee = ye.start - w;
    } else {
      let ve = l.pos - $;
      l.next();
      let $e = [], Ke = [], Qe = j >= o ? j : -1, Fe = 0, ht = Q;
      for (; l.pos > ve; )
        Qe >= 0 && l.id == Qe && l.size >= 0 ? (l.end <= ht - i && (D($e, Ke, X, Fe, l.end, ht, Qe, U), Fe = $e.length, ht = l.end), l.next()) : L > 2500 ? m(X, ve, $e, Ke) : d(X, ve, $e, Ke, Qe, L + 1);
      if (Qe >= 0 && Fe > 0 && Fe < $e.length && D($e, Ke, X, Fe, X, ht, Qe, U), $e.reverse(), Ke.reverse(), Qe > -1 && Fe > 0) {
        let le = y(H);
        Z = vg(H, $e, Ke, 0, $e.length, 0, Q - X, le, le);
      } else
        Z = b(H, $e, Ke, Q - X, U - Q);
    }
    P.push(Z), M.push(Ee);
  }
  function m(w, T, P, M) {
    let N = [], L = 0, j = -1;
    for (; l.pos > T; ) {
      let { id: X, start: Q, end: $, size: U } = l;
      if (U > 4)
        l.next();
      else {
        if (j > -1 && Q < j)
          break;
        j < 0 && (j = $ - i), N.push(X, Q, $), L++, l.next();
      }
    }
    if (L) {
      let X = new Uint16Array(L * 4), Q = N[N.length - 2];
      for (let $ = N.length - 3, U = 0; $ >= 0; $ -= 3)
        X[U++] = N[$], X[U++] = N[$ + 1] - Q, X[U++] = N[$ + 2] - Q, X[U++] = U;
      P.push(new $i(X, N[2] - Q, n)), M.push(Q - w);
    }
  }
  function y(w) {
    return (T, P, M) => {
      let N = 0, L = T.length - 1, j, X;
      if (L >= 0 && (j = T[L]) instanceof jt) {
        if (!L && j.type == w && j.length == M)
          return j;
        (X = j.prop(Me.lookAhead)) && (N = P[L] + j.length + X);
      }
      return b(w, T, P, M, N);
    };
  }
  function D(w, T, P, M, N, L, j, X) {
    let Q = [], $ = [];
    for (; w.length > M; )
      Q.push(w.pop()), $.push(T.pop() + P - N);
    w.push(b(n.types[j], Q, $, L - N, X - L)), T.push(N - P);
  }
  function b(w, T, P, M, N = 0, L) {
    if (h) {
      let j = [Me.contextHash, h];
      L = L ? [j].concat(L) : [j];
    }
    if (N > 25) {
      let j = [Me.lookAhead, N];
      L = L ? [j].concat(L) : [j];
    }
    return new jt(w, T, P, M, L);
  }
  function C(w, T) {
    let P = l.fork(), M = 0, N = 0, L = 0, j = P.end - i, X = { size: 0, start: 0, skip: 0 };
    e:
      for (let Q = P.pos - w; P.pos > Q; ) {
        let $ = P.size;
        if (P.id == T && $ >= 0) {
          X.size = M, X.start = N, X.skip = L, L += 4, M += 4, P.next();
          continue;
        }
        let U = P.pos - $;
        if ($ < 0 || U < Q || P.start < j)
          break;
        let H = P.id >= o ? 4 : 0, Z = P.start;
        for (P.next(); P.pos > U; ) {
          if (P.size < 0)
            if (P.size == -3)
              H += 4;
            else
              break e;
          else
            P.id >= o && (H += 4);
          P.next();
        }
        N = Z, M += $, L += H;
      }
    return (T < 0 || M == w) && (X.size = M, X.start = N, X.skip = L), X.size > 4 ? X : void 0;
  }
  function A(w, T, P) {
    let { id: M, start: N, end: L, size: j } = l;
    if (l.next(), j >= 0 && M < o) {
      let X = P;
      if (j > 4) {
        let Q = l.pos - (j - 4);
        for (; l.pos > Q; )
          P = A(w, T, P);
      }
      T[--P] = X, T[--P] = L - w, T[--P] = N - w, T[--P] = M;
    } else
      j == -3 ? h = M : j == -4 && (p = M);
    return P;
  }
  let x = [], E = [];
  for (; l.pos > 0; )
    d(t.start || 0, t.bufferStart || 0, x, E, -1, 0);
  let k = (e = t.length) !== null && e !== void 0 ? e : x.length ? E[0] + x[0].length : 0;
  return new jt(u[t.topID], x.reverse(), E.reverse(), k);
}
const G1 = /* @__PURE__ */ new WeakMap();
function Hu(t, e) {
  if (!t.isAnonymous || e instanceof $i || e.type != t)
    return 1;
  let r = G1.get(e);
  if (r == null) {
    r = 1;
    for (let n of e.children) {
      if (n.type != t || !(n instanceof jt)) {
        r = 1;
        break;
      }
      r += Hu(t, n);
    }
    G1.set(e, r);
  }
  return r;
}
function vg(t, e, r, n, i, s, o, l, u) {
  let h = 0;
  for (let D = n; D < i; D++)
    h += Hu(t, e[D]);
  let p = Math.ceil(
    h * 1.5 / 8
    /* Balance.BranchFactor */
  ), d = [], m = [];
  function y(D, b, C, A, x) {
    for (let E = C; E < A; ) {
      let k = E, w = b[E], T = Hu(t, D[E]);
      for (E++; E < A; E++) {
        let P = Hu(t, D[E]);
        if (T + P >= p)
          break;
        T += P;
      }
      if (E == k + 1) {
        if (T > p) {
          let P = D[k];
          y(P.children, P.positions, 0, P.children.length, b[k] + x);
          continue;
        }
        d.push(D[k]);
      } else {
        let P = b[E - 1] + D[E - 1].length - w;
        d.push(vg(t, D, b, k, E, w, P, null, u));
      }
      m.push(w + x - s);
    }
  }
  return y(e, r, n, i, 0), (l || u)(d, m, o);
}
class us {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, r, n, i, s = !1, o = !1) {
    this.from = e, this.to = r, this.tree = n, this.offset = i, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, r = [], n = !1) {
    let i = [new us(0, e.length, e, 0, !1, n)];
    for (let s of r)
      s.to > e.length && i.push(s);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, r, n = 128) {
    if (!r.length)
      return e;
    let i = [], s = 1, o = e.length ? e[0] : null;
    for (let l = 0, u = 0, h = 0; ; l++) {
      let p = l < r.length ? r[l] : null, d = p ? p.fromA : 1e9;
      if (d - u >= n)
        for (; o && o.from < d; ) {
          let m = o;
          if (u >= m.from || d <= m.to || h) {
            let y = Math.max(m.from, u) - h, D = Math.min(m.to, d) - h;
            m = y >= D ? null : new us(y, D, m.tree, m.offset + h, l > 0, !!p);
          }
          if (m && i.push(m), o.to > d)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!p)
        break;
      u = p.toA, h = p.toA - p.toB;
    }
    return i;
  }
}
class wq {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, r, n) {
    return typeof e == "string" && (e = new Sq(e)), n = n ? n.length ? n.map((i) => new Bp(i.from, i.to)) : [new Bp(0, 0)] : [new Bp(0, e.length)], this.createParse(e, r || [], n);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, r, n) {
    let i = this.startParse(e, r, n);
    for (; ; ) {
      let s = i.advance();
      if (s)
        return s;
    }
  }
}
class Sq {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, r) {
    return this.string.slice(e, r);
  }
}
new Me({ perNode: !0 });
let Tq = 0;
class gn {
  /**
  @internal
  */
  constructor(e, r, n) {
    this.set = e, this.base = r, this.modified = n, this.id = Tq++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let r = new gn([], null, []);
    if (r.set.push(r), e)
      for (let n of e.set)
        r.set.push(n);
    return r;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new dc();
    return (r) => r.modified.indexOf(e) > -1 ? r : dc.get(r.base || r, r.modified.concat(e).sort((n, i) => n.id - i.id));
  }
}
let kq = 0;
class dc {
  constructor() {
    this.instances = [], this.id = kq++;
  }
  static get(e, r) {
    if (!r.length)
      return e;
    let n = r[0].instances.find((l) => l.base == e && Fq(r, l.modified));
    if (n)
      return n;
    let i = [], s = new gn(i, e, r);
    for (let l of r)
      l.instances.push(s);
    let o = Pq(r);
    for (let l of e.set)
      if (!l.modified.length)
        for (let u of o)
          i.push(dc.get(l, u));
    return s;
  }
}
function Fq(t, e) {
  return t.length == e.length && t.every((r, n) => r == e[n]);
}
function Pq(t) {
  let e = [[]];
  for (let r = 0; r < t.length; r++)
    for (let n = 0, i = e.length; n < i; n++)
      e.push(e[n].concat(t[r]));
  return e.sort((r, n) => n.length - r.length);
}
function Bq(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let n = t[r];
    Array.isArray(n) || (n = [n]);
    for (let i of r.split(" "))
      if (i) {
        let s = [], o = 2, l = i;
        for (let d = 0; ; ) {
          if (l == "..." && d > 0 && d + 3 == i.length) {
            o = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!m)
            throw new RangeError("Invalid path: " + i);
          if (s.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]), d += m[0].length, d == i.length)
            break;
          let y = i[d++];
          if (d == i.length && y == "!") {
            o = 0;
            break;
          }
          if (y != "/")
            throw new RangeError("Invalid path: " + i);
          l = i.slice(d);
        }
        let u = s.length - 1, h = s[u];
        if (!h)
          throw new RangeError("Invalid path: " + i);
        let p = new fc(n, o, u > 0 ? s.slice(0, u) : null);
        e[h] = p.sort(e[h]);
      }
  }
  return CE.add(e);
}
const CE = new Me();
class fc {
  constructor(e, r, n, i) {
    this.tags = e, this.mode = r, this.context = n, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
fc.empty = new fc([], 2, null);
function AE(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let s of t)
    if (!Array.isArray(s.tag))
      r[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        r[o.id] = s.class;
  let { scope: n, all: i = null } = e || {};
  return {
    style: (s) => {
      let o = i;
      for (let l of s)
        for (let u of l.set) {
          let h = r[u.id];
          if (h) {
            o = o ? o + " " + h : h;
            break;
          }
        }
      return o;
    },
    scope: n
  };
}
function Iq(t, e) {
  let r = null;
  for (let n of t) {
    let i = n.style(e);
    i && (r = r ? r + " " + i : i);
  }
  return r;
}
function Nq(t, e, r, n = 0, i = t.length) {
  let s = new Mq(n, Array.isArray(e) ? e : [e], r);
  s.highlightRange(t.cursor(), n, i, "", s.highlighters), s.flush(i);
}
class Mq {
  constructor(e, r, n) {
    this.at = e, this.highlighters = r, this.span = n, this.class = "";
  }
  startSpan(e, r) {
    r != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = r);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, r, n, i, s) {
    let { type: o, from: l, to: u } = e;
    if (l >= n || u <= r)
      return;
    o.isTop && (s = this.highlighters.filter((y) => !y.scope || y.scope(o)));
    let h = i, p = Oq(e) || fc.empty, d = Iq(s, p.tags);
    if (d && (h && (h += " "), h += d, p.mode == 1 && (i += (i ? " " : "") + d)), this.startSpan(Math.max(r, l), h), p.opaque)
      return;
    let m = e.tree && e.tree.prop(Me.mounted);
    if (m && m.overlay) {
      let y = e.node.enter(m.overlay[0].from + l, 1), D = this.highlighters.filter((C) => !C.scope || C.scope(m.tree.type)), b = e.firstChild();
      for (let C = 0, A = l; ; C++) {
        let x = C < m.overlay.length ? m.overlay[C] : null, E = x ? x.from + l : u, k = Math.max(r, A), w = Math.min(n, E);
        if (k < w && b)
          for (; e.from < w && (this.highlightRange(e, k, w, i, s), this.startSpan(Math.min(w, e.to), h), !(e.to >= E || !e.nextSibling())); )
            ;
        if (!x || E > n)
          break;
        A = x.to + l, A > r && (this.highlightRange(y.cursor(), Math.max(r, x.from + l), Math.min(n, A), "", D), this.startSpan(Math.min(n, A), h));
      }
      b && e.parent();
    } else if (e.firstChild()) {
      m && (i = "");
      do
        if (!(e.to <= r)) {
          if (e.from >= n)
            break;
          this.highlightRange(e, r, n, i, s), this.startSpan(Math.min(n, e.to), h);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function Oq(t) {
  let e = t.type.prop(CE);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const oe = gn.define, Du = oe(), mi = oe(), X1 = oe(mi), Y1 = oe(mi), gi = oe(), xu = oe(gi), Ip = oe(gi), mn = oe(), Xi = oe(mn), hn = oe(), pn = oe(), mf = oe(), la = oe(mf), bu = oe(), V = {
  /**
  A comment.
  */
  comment: Du,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: oe(Du),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: oe(Du),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: oe(Du),
  /**
  Any kind of identifier.
  */
  name: mi,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: oe(mi),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: X1,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: oe(X1),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: Y1,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: oe(Y1),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: oe(mi),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: oe(mi),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: oe(mi),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: oe(mi),
  /**
  A literal value.
  */
  literal: gi,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: xu,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: oe(xu),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: oe(xu),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: oe(xu),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Ip,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: oe(Ip),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: oe(Ip),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: oe(gi),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: oe(gi),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: oe(gi),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: oe(gi),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: oe(gi),
  /**
  A language keyword.
  */
  keyword: hn,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: oe(hn),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: oe(hn),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: oe(hn),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: oe(hn),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: oe(hn),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: oe(hn),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: oe(hn),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: oe(hn),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: oe(hn),
  /**
  An operator.
  */
  operator: pn,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: oe(pn),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: oe(pn),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: oe(pn),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: oe(pn),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: oe(pn),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: oe(pn),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: oe(pn),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: oe(pn),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: oe(pn),
  /**
  Program or markup punctuation.
  */
  punctuation: mf,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: oe(mf),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: la,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: oe(la),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: oe(la),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: oe(la),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: oe(la),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: mn,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Xi,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: oe(Xi),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: oe(Xi),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: oe(Xi),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: oe(Xi),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: oe(Xi),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: oe(Xi),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: oe(mn),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: oe(mn),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: oe(mn),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: oe(mn),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: oe(mn),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: oe(mn),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: oe(mn),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: oe(mn),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: oe(),
  /**
  Deleted text.
  */
  deleted: oe(),
  /**
  Changed text.
  */
  changed: oe(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: oe(),
  /**
  Metadata or meta-instruction.
  */
  meta: bu,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: oe(bu),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: oe(bu),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: oe(bu),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: gn.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: gn.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: gn.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: gn.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: gn.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: gn.defineModifier()
};
AE([
  { tag: V.link, class: "tok-link" },
  { tag: V.heading, class: "tok-heading" },
  { tag: V.emphasis, class: "tok-emphasis" },
  { tag: V.strong, class: "tok-strong" },
  { tag: V.keyword, class: "tok-keyword" },
  { tag: V.atom, class: "tok-atom" },
  { tag: V.bool, class: "tok-bool" },
  { tag: V.url, class: "tok-url" },
  { tag: V.labelName, class: "tok-labelName" },
  { tag: V.inserted, class: "tok-inserted" },
  { tag: V.deleted, class: "tok-deleted" },
  { tag: V.literal, class: "tok-literal" },
  { tag: V.string, class: "tok-string" },
  { tag: V.number, class: "tok-number" },
  { tag: [V.regexp, V.escape, V.special(V.string)], class: "tok-string2" },
  { tag: V.variableName, class: "tok-variableName" },
  { tag: V.local(V.variableName), class: "tok-variableName tok-local" },
  { tag: V.definition(V.variableName), class: "tok-variableName tok-definition" },
  { tag: V.special(V.variableName), class: "tok-variableName2" },
  { tag: V.definition(V.propertyName), class: "tok-propertyName tok-definition" },
  { tag: V.typeName, class: "tok-typeName" },
  { tag: V.namespace, class: "tok-namespace" },
  { tag: V.className, class: "tok-className" },
  { tag: V.macroName, class: "tok-macroName" },
  { tag: V.propertyName, class: "tok-propertyName" },
  { tag: V.operator, class: "tok-operator" },
  { tag: V.comment, class: "tok-comment" },
  { tag: V.meta, class: "tok-meta" },
  { tag: V.invalid, class: "tok-invalid" },
  { tag: V.punctuation, class: "tok-punctuation" }
]);
var Np;
const ba = /* @__PURE__ */ new Me(), Lq = /* @__PURE__ */ new Me();
class bn {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, r, n = [], i = "") {
    this.data = e, this.name = i, Ie.prototype.hasOwnProperty("tree") || Object.defineProperty(Ie.prototype, "tree", { get() {
      return Ut(this);
    } }), this.parser = r, this.extension = [
      Ri.of(this),
      Ie.languageData.of((s, o, l) => {
        let u = Q1(s, o, l), h = u.type.prop(ba);
        if (!h)
          return [];
        let p = s.facet(h), d = u.type.prop(Lq);
        if (d) {
          let m = u.resolve(o - u.from, l);
          for (let y of d)
            if (y.test(m, s)) {
              let D = s.facet(y.facet);
              return y.type == "replace" ? D : D.concat(p);
            }
        }
        return p;
      })
    ].concat(n);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, r, n = -1) {
    return Q1(e, r, n).type.prop(ba) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let r = e.facet(Ri);
    if ((r == null ? void 0 : r.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!r || !r.allowsNesting)
      return [];
    let n = [], i = (s, o) => {
      if (s.prop(ba) == this.data) {
        n.push({ from: o, to: o + s.length });
        return;
      }
      let l = s.prop(Me.mounted);
      if (l) {
        if (l.tree.prop(ba) == this.data) {
          if (l.overlay)
            for (let u of l.overlay)
              n.push({ from: u.from + o, to: u.to + o });
          else
            n.push({ from: o, to: o + s.length });
          return;
        } else if (l.overlay) {
          let u = n.length;
          if (i(l.tree, l.overlay[0].from + o), n.length > u)
            return;
        }
      }
      for (let u = 0; u < s.children.length; u++) {
        let h = s.children[u];
        h instanceof jt && i(h, s.positions[u] + o);
      }
    };
    return i(Ut(e), 0), n;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
bn.setState = /* @__PURE__ */ Se.define();
function Q1(t, e, r) {
  let n = t.facet(Ri), i = Ut(t).topNode;
  if (!n || n.allowsNesting)
    for (let s = i; s; s = s.enter(e, r, Et.ExcludeBuffers))
      s.type.isTop && (i = s);
  return i;
}
function Ut(t) {
  let e = t.field(bn.state, !1);
  return e ? e.tree : jt.empty;
}
class _q {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, r) {
    let n = this.cursorPos - this.string.length;
    return e < n || r >= this.cursorPos ? this.doc.sliceString(e, r) : this.string.slice(e - n, r - n);
  }
}
let ua = null;
class mc {
  constructor(e, r, n = [], i, s, o, l, u) {
    this.parser = e, this.state = r, this.fragments = n, this.tree = i, this.treeLen = s, this.viewport = o, this.skipped = l, this.scheduleOn = u, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new mc(e, r, [], jt.empty, 0, n, [], null);
  }
  startParse() {
    return this.parser.startParse(new _q(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, r) {
    return r != null && r >= this.state.doc.length && (r = void 0), this.tree != jt.empty && this.isDone(r ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var n;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), r != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > r) && r < this.state.doc.length && this.parse.stopAt(r); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(us.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (n = this.parse.stoppedAt) !== null && n !== void 0 ? n : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (r ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, r;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(r = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = r, this.fragments = this.withoutTempSkipped(us.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let r = ua;
    ua = this;
    try {
      return e();
    } finally {
      ua = r;
    }
  }
  withoutTempSkipped(e) {
    for (let r; r = this.tempSkipped.pop(); )
      e = Z1(e, r.from, r.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, r) {
    let { fragments: n, tree: i, treeLen: s, viewport: o, skipped: l } = this;
    if (this.takeTree(), !e.empty) {
      let u = [];
      if (e.iterChangedRanges((h, p, d, m) => u.push({ fromA: h, toA: p, fromB: d, toB: m })), n = us.applyChanges(n, u), i = jt.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        l = [];
        for (let h of this.skipped) {
          let p = e.mapPos(h.from, 1), d = e.mapPos(h.to, -1);
          p < d && l.push({ from: p, to: d });
        }
      }
    }
    return new mc(this.parser, r, n, i, s, o, l, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let r = this.skipped.length;
    for (let n = 0; n < this.skipped.length; n++) {
      let { from: i, to: s } = this.skipped[n];
      i < e.to && s > e.from && (this.fragments = Z1(this.fragments, i, s), this.skipped.splice(n--, 1));
    }
    return this.skipped.length >= r ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, r) {
    this.skipped.push({ from: e, to: r });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends wq {
      createParse(r, n, i) {
        let s = i[0].from, o = i[i.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let u = ua;
            if (u) {
              for (let h of i)
                u.tempSkipped.push(h);
              e && (u.scheduleOn = u.scheduleOn ? Promise.all([u.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new jt(jr.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let r = this.fragments;
    return this.treeLen >= e && r.length && r[0].from == 0 && r[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return ua;
  }
}
function Z1(t, e, r) {
  return us.applyChanges(t, [{ fromA: e, toA: r, fromB: e, toB: r }]);
}
class Eo {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let r = this.context.changes(e.changes, e.state), n = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), r.viewport.to);
    return r.work(20, n) || r.takeTree(), new Eo(r);
  }
  static init(e) {
    let r = Math.min(3e3, e.doc.length), n = mc.create(e.facet(Ri).parser, e, { from: 0, to: r });
    return n.work(20, r) || n.takeTree(), new Eo(n);
  }
}
bn.state = /* @__PURE__ */ Nt.define({
  create: Eo.init,
  update(t, e) {
    for (let r of e.effects)
      if (r.is(bn.setState))
        return r.value;
    return e.startState.facet(Ri) != e.state.facet(Ri) ? Eo.init(e.state) : t.apply(e);
  }
});
let EE = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (EE = (t) => {
  let e = -1, r = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(r) : cancelIdleCallback(e);
});
const Mp = typeof navigator < "u" && (!((Np = navigator.scheduling) === null || Np === void 0) && Np.isInputPending) ? () => navigator.scheduling.isInputPending() : null, $q = /* @__PURE__ */ ct.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let r = this.view.state.field(bn.state).context;
    (r.updateViewport(e.view.viewport) || this.view.viewport.to > r.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(r);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, r = e.field(bn.state);
    (r.tree != r.context.tree || !r.context.isDone(e.doc.length)) && (this.working = EE(this.work));
  }
  work(e) {
    this.working = null;
    let r = Date.now();
    if (this.chunkEnd < r && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = r + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: n, viewport: { to: i } } = this.view, s = n.field(bn.state);
    if (s.tree == s.context.tree && s.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !Mp ? Math.max(25, e.timeRemaining() - 5) : 1e9), l = s.context.treeLen < i && n.doc.length > i + 1e3, u = s.context.work(() => Mp && Mp() || Date.now() > o, i + (l ? 0 : 1e5));
    this.chunkBudget -= Date.now() - r, (u || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: bn.setState.of(new Eo(s.context)) })), this.chunkBudget > 0 && !(u && !l) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((r) => Br(this.view.state, r)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Ri = /* @__PURE__ */ ge.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    bn.state,
    $q,
    ce.contentAttributes.compute([t], (e) => {
      let r = e.facet(t);
      return r && r.name ? { "data-language": r.name } : {};
    })
  ]
}), Rq = /* @__PURE__ */ ge.define(), Eh = /* @__PURE__ */ ge.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((r) => r != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function gc(t) {
  let e = t.facet(Eh);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function rl(t, e) {
  let r = "", n = t.tabSize, i = t.facet(Eh)[0];
  if (i == "	") {
    for (; e >= n; )
      r += "	", e -= n;
    i = " ";
  }
  for (let s = 0; s < e; s++)
    r += i;
  return r;
}
function Cg(t, e) {
  t instanceof Ie && (t = new wh(t));
  for (let n of t.state.facet(Rq)) {
    let i = n(t, e);
    if (i !== void 0)
      return i;
  }
  let r = Ut(t.state);
  return r.length >= e ? qq(t, r, e) : null;
}
class wh {
  /**
  Create an indent context.
  */
  constructor(e, r = {}) {
    this.state = e, this.options = r, this.unit = gc(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, r = 1) {
    let n = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: s } = this.options;
    return i != null && i >= n.from && i <= n.to ? s && i == e ? { text: "", from: e } : (r < 0 ? i < e : i <= e) ? { text: n.text.slice(i - n.from), from: i } : { text: n.text.slice(0, i - n.from), from: n.from } : n;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, r = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: n, from: i } = this.lineAt(e, r);
    return n.slice(e - i, Math.min(n.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, r = 1) {
    let { text: n, from: i } = this.lineAt(e, r), s = this.countColumn(n, e - i), o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return o > -1 && (s += o - this.countColumn(n, n.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, r = e.length) {
    return qo(e, this.state.tabSize, r);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, r = 1) {
    let { text: n, from: i } = this.lineAt(e, r), s = this.options.overrideIndentation;
    if (s) {
      let o = s(i);
      if (o > -1)
        return o;
    }
    return this.countColumn(n, n.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const jq = /* @__PURE__ */ new Me();
function qq(t, e, r) {
  let n = e.resolveStack(r), i = n.node.enterUnfinishedNodesBefore(r);
  if (i != n.node) {
    let s = [];
    for (let o = i; o != n.node; o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      n = { node: s[o], next: n };
  }
  return wE(n, t, r);
}
function wE(t, e, r) {
  for (let n = t; n; n = n.next) {
    let i = Uq(n.node);
    if (i)
      return i(Ag.create(e, r, n));
  }
  return 0;
}
function Wq(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function Uq(t) {
  let e = t.type.prop(jq);
  if (e)
    return e;
  let r = t.firstChild, n;
  if (r && (n = r.type.prop(Me.closedBy))) {
    let i = t.lastChild, s = i && n.indexOf(i.name) > -1;
    return (o) => Jq(o, !0, 1, void 0, s && !Wq(o) ? i.from : void 0);
  }
  return t.parent == null ? Hq : null;
}
function Hq() {
  return 0;
}
class Ag extends wh {
  constructor(e, r, n) {
    super(e.state, e.options), this.base = e, this.pos = r, this.context = n;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new Ag(e, r, n);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let r = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let n = e.resolve(r.from);
      for (; n.parent && n.parent.from == n.from; )
        n = n.parent;
      if (Vq(n, e))
        break;
      r = this.state.doc.lineAt(n.from);
    }
    return this.lineIndent(r.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return wE(this.context.next, this.base, this.pos);
  }
}
function Vq(t, e) {
  for (let r = e; r; r = r.parent)
    if (t == r)
      return !0;
  return !1;
}
function zq(t) {
  let e = t.node, r = e.childAfter(e.from), n = e.lastChild;
  if (!r)
    return null;
  let i = t.options.simulateBreak, s = t.state.doc.lineAt(r.from), o = i == null || i <= s.from ? s.to : Math.min(s.to, i);
  for (let l = r.to; ; ) {
    let u = e.childAfter(l);
    if (!u || u == n)
      return null;
    if (!u.type.isSkipped)
      return u.from < o ? r : null;
    l = u.to;
  }
}
function Jq(t, e, r, n, i) {
  let s = t.textAfter, o = s.match(/^\s*/)[0].length, l = n && s.slice(o, o + n.length) == n || i == t.pos + o, u = e ? zq(t) : null;
  return u ? l ? t.column(u.from) : t.column(u.to) : t.baseIndent + (l ? 0 : t.unit * r);
}
const Kq = 200;
function Gq() {
  return Ie.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let r = t.newDoc, { head: n } = t.newSelection.main, i = r.lineAt(n);
    if (n > i.from + Kq)
      return t;
    let s = r.sliceString(i.from, n);
    if (!e.some((h) => h.test(s)))
      return t;
    let { state: o } = t, l = -1, u = [];
    for (let { head: h } of o.selection.ranges) {
      let p = o.doc.lineAt(h);
      if (p.from == l)
        continue;
      l = p.from;
      let d = Cg(o, p.from);
      if (d == null)
        continue;
      let m = /^\s*/.exec(p.text)[0], y = rl(o, d);
      m != y && u.push({ from: p.from, to: p.from + m.length, insert: y });
    }
    return u.length ? [t, { changes: u, sequential: !0 }] : t;
  });
}
const Xq = /* @__PURE__ */ ge.define(), Yq = /* @__PURE__ */ new Me();
function Qq(t, e, r) {
  let n = Ut(t);
  if (n.length < r)
    return null;
  let i = n.resolveStack(r, 1), s = null;
  for (let o = i; o; o = o.next) {
    let l = o.node;
    if (l.to <= r || l.from > r)
      continue;
    if (s && l.from < e)
      break;
    let u = l.type.prop(Yq);
    if (u && (l.to < n.length - 50 || n.length == t.doc.length || !Zq(l))) {
      let h = u(l, t);
      h && h.from <= r && h.from >= e && h.to > r && (s = h);
    }
  }
  return s;
}
function Zq(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function yc(t, e, r) {
  for (let n of t.facet(Xq)) {
    let i = n(t, e, r);
    if (i)
      return i;
  }
  return Qq(t, e, r);
}
function SE(t, e) {
  let r = e.mapPos(t.from, 1), n = e.mapPos(t.to, -1);
  return r >= n ? void 0 : { from: r, to: n };
}
const Sh = /* @__PURE__ */ Se.define({ map: SE }), kl = /* @__PURE__ */ Se.define({ map: SE });
function TE(t) {
  let e = [];
  for (let { head: r } of t.state.selection.ranges)
    e.some((n) => n.from <= r && n.to >= r) || e.push(t.lineBlockAt(r));
  return e;
}
const Cs = /* @__PURE__ */ Nt.define({
  create() {
    return xe.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let r of e.effects)
      if (r.is(Sh) && !eW(t, r.value.from, r.value.to)) {
        let { preparePlaceholder: n } = e.state.facet(Eg), i = n ? xe.replace({ widget: new aW(n(e.state, r.value)) }) : eD;
        t = t.update({ add: [i.range(r.value.from, r.value.to)] });
      } else
        r.is(kl) && (t = t.update({
          filter: (n, i) => r.value.from != n || r.value.to != i,
          filterFrom: r.value.from,
          filterTo: r.value.to
        }));
    if (e.selection) {
      let r = !1, { head: n } = e.selection.main;
      t.between(n, n, (i, s) => {
        i < n && s > n && (r = !0);
      }), r && (t = t.update({
        filterFrom: n,
        filterTo: n,
        filter: (i, s) => s <= n || i >= n
      }));
    }
    return t;
  },
  provide: (t) => ce.decorations.from(t),
  toJSON(t, e) {
    let r = [];
    return t.between(0, e.doc.length, (n, i) => {
      r.push(n, i);
    }), r;
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let r = 0; r < t.length; ) {
      let n = t[r++], i = t[r++];
      if (typeof n != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(eD.range(n, i));
    }
    return xe.set(e, !0);
  }
});
function Dc(t, e, r) {
  var n;
  let i = null;
  return (n = t.field(Cs, !1)) === null || n === void 0 || n.between(e, r, (s, o) => {
    (!i || i.from > s) && (i = { from: s, to: o });
  }), i;
}
function eW(t, e, r) {
  let n = !1;
  return t.between(e, e, (i, s) => {
    i == e && s == r && (n = !0);
  }), n;
}
function kE(t, e) {
  return t.field(Cs, !1) ? e : e.concat(Se.appendConfig.of(PE()));
}
const tW = (t) => {
  for (let e of TE(t)) {
    let r = yc(t.state, e.from, e.to);
    if (r)
      return t.dispatch({ effects: kE(t.state, [Sh.of(r), FE(t, r)]) }), !0;
  }
  return !1;
}, rW = (t) => {
  if (!t.state.field(Cs, !1))
    return !1;
  let e = [];
  for (let r of TE(t)) {
    let n = Dc(t.state, r.from, r.to);
    n && e.push(kl.of(n), FE(t, n, !1));
  }
  return e.length && t.dispatch({ effects: e }), e.length > 0;
};
function FE(t, e, r = !0) {
  let n = t.state.doc.lineAt(e.from).number, i = t.state.doc.lineAt(e.to).number;
  return ce.announce.of(`${t.state.phrase(r ? "Folded lines" : "Unfolded lines")} ${n} ${t.state.phrase("to")} ${i}.`);
}
const nW = (t) => {
  let { state: e } = t, r = [];
  for (let n = 0; n < e.doc.length; ) {
    let i = t.lineBlockAt(n), s = yc(e, i.from, i.to);
    s && r.push(Sh.of(s)), n = (s ? t.lineBlockAt(s.to) : i).to + 1;
  }
  return r.length && t.dispatch({ effects: kE(t.state, r) }), !!r.length;
}, iW = (t) => {
  let e = t.state.field(Cs, !1);
  if (!e || !e.size)
    return !1;
  let r = [];
  return e.between(0, t.state.doc.length, (n, i) => {
    r.push(kl.of({ from: n, to: i }));
  }), t.dispatch({ effects: r }), !0;
}, sW = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: tW },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: rW },
  { key: "Ctrl-Alt-[", run: nW },
  { key: "Ctrl-Alt-]", run: iW }
], oW = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
}, Eg = /* @__PURE__ */ ge.define({
  combine(t) {
    return Mn(t, oW);
  }
});
function PE(t) {
  let e = [Cs, cW];
  return t && e.push(Eg.of(t)), e;
}
function BE(t, e) {
  let { state: r } = t, n = r.facet(Eg), i = (o) => {
    let l = t.lineBlockAt(t.posAtDOM(o.target)), u = Dc(t.state, l.from, l.to);
    u && t.dispatch({ effects: kl.of(u) }), o.preventDefault();
  };
  if (n.placeholderDOM)
    return n.placeholderDOM(t, i, e);
  let s = document.createElement("span");
  return s.textContent = n.placeholderText, s.setAttribute("aria-label", r.phrase("folded code")), s.title = r.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = i, s;
}
const eD = /* @__PURE__ */ xe.replace({ widget: /* @__PURE__ */ new class extends ni {
  toDOM(t) {
    return BE(t, null);
  }
}() });
class aW extends ni {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return BE(e, this.value);
  }
}
const lW = {
  openText: "",
  closedText: "",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Op extends Kn {
  constructor(e, r) {
    super(), this.config = e, this.open = r;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let r = document.createElement("span");
    return r.textContent = this.open ? this.config.openText : this.config.closedText, r.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), r;
  }
}
function uW(t = {}) {
  let e = Object.assign(Object.assign({}, lW), t), r = new Op(e, !0), n = new Op(e, !1), i = ct.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(Ri) != o.state.facet(Ri) || o.startState.field(Cs, !1) != o.state.field(Cs, !1) || Ut(o.startState) != Ut(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let l = new Mi();
      for (let u of o.viewportLineBlocks) {
        let h = Dc(o.state, u.from, u.to) ? n : yc(o.state, u.from, u.to) ? r : null;
        h && l.add(u.from, u.from, h);
      }
      return l.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    i,
    lq({
      class: "cm-foldGutter",
      markers(o) {
        var l;
        return ((l = o.plugin(i)) === null || l === void 0 ? void 0 : l.markers) || _e.empty;
      },
      initialSpacer() {
        return new Op(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, s), { click: (o, l, u) => {
        if (s.click && s.click(o, l, u))
          return !0;
        let h = Dc(o.state, l.from, l.to);
        if (h)
          return o.dispatch({ effects: kl.of(h) }), !0;
        let p = yc(o.state, l.from, l.to);
        return p ? (o.dispatch({ effects: Sh.of(p) }), !0) : !1;
      } })
    }),
    PE()
  ];
}
const cW = /* @__PURE__ */ ce.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Fl {
  constructor(e, r) {
    this.specs = e;
    let n;
    function i(l) {
      let u = Oi.newName();
      return (n || (n = /* @__PURE__ */ Object.create(null)))["." + u] = l, u;
    }
    const s = typeof r.all == "string" ? r.all : r.all ? i(r.all) : void 0, o = r.scope;
    this.scope = o instanceof bn ? (l) => l.prop(ba) == o.data : o ? (l) => l == o : void 0, this.style = AE(e.map((l) => ({
      tag: l.tag,
      class: l.class || i(Object.assign({}, l, { tag: null }))
    })), {
      all: s
    }).style, this.module = n ? new Oi(n) : null, this.themeType = r.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, r) {
    return new Fl(e, r || {});
  }
}
const gf = /* @__PURE__ */ ge.define(), IE = /* @__PURE__ */ ge.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function Lp(t) {
  let e = t.facet(gf);
  return e.length ? e : t.facet(IE);
}
function NE(t, e) {
  let r = [pW], n;
  return t instanceof Fl && (t.module && r.push(ce.styleModule.of(t.module)), n = t.themeType), e != null && e.fallback ? r.push(IE.of(t)) : n ? r.push(gf.computeN([ce.darkTheme], (i) => i.facet(ce.darkTheme) == (n == "dark") ? [t] : [])) : r.push(gf.of(t)), r;
}
class hW {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Ut(e.state), this.decorations = this.buildDeco(e, Lp(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let r = Ut(e.state), n = Lp(e.state), i = n != Lp(e.startState), { viewport: s } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    r.length < s.to && !i && r.type == this.tree.type && o >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (r != this.tree || e.viewportChanged || i) && (this.tree = r, this.decorations = this.buildDeco(e.view, n), this.decoratedTo = s.to);
  }
  buildDeco(e, r) {
    if (!r || !this.tree.length)
      return xe.none;
    let n = new Mi();
    for (let { from: i, to: s } of e.visibleRanges)
      Nq(this.tree, r, (o, l, u) => {
        n.add(o, l, this.markCache[u] || (this.markCache[u] = xe.mark({ class: u })));
      }, i, s);
    return n.finish();
  }
}
const pW = /* @__PURE__ */ jo.high(/* @__PURE__ */ ct.fromClass(hW, {
  decorations: (t) => t.decorations
})), dW = /* @__PURE__ */ Fl.define([
  {
    tag: V.meta,
    color: "#404740"
  },
  {
    tag: V.link,
    textDecoration: "underline"
  },
  {
    tag: V.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: V.emphasis,
    fontStyle: "italic"
  },
  {
    tag: V.strong,
    fontWeight: "bold"
  },
  {
    tag: V.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: V.keyword,
    color: "#708"
  },
  {
    tag: [V.atom, V.bool, V.url, V.contentSeparator, V.labelName],
    color: "#219"
  },
  {
    tag: [V.literal, V.inserted],
    color: "#164"
  },
  {
    tag: [V.string, V.deleted],
    color: "#a11"
  },
  {
    tag: [V.regexp, V.escape, /* @__PURE__ */ V.special(V.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ V.definition(V.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ V.local(V.variableName),
    color: "#30a"
  },
  {
    tag: [V.typeName, V.namespace],
    color: "#085"
  },
  {
    tag: V.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ V.special(V.variableName), V.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ V.definition(V.propertyName),
    color: "#00c"
  },
  {
    tag: V.comment,
    color: "#940"
  },
  {
    tag: V.invalid,
    color: "#f00"
  }
]), fW = /* @__PURE__ */ ce.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), ME = 1e4, OE = "()[]{}", LE = /* @__PURE__ */ ge.define({
  combine(t) {
    return Mn(t, {
      afterCursor: !0,
      brackets: OE,
      maxScanDistance: ME,
      renderMatch: yW
    });
  }
}), mW = /* @__PURE__ */ xe.mark({ class: "cm-matchingBracket" }), gW = /* @__PURE__ */ xe.mark({ class: "cm-nonmatchingBracket" });
function yW(t) {
  let e = [], r = t.matched ? mW : gW;
  return e.push(r.range(t.start.from, t.start.to)), t.end && e.push(r.range(t.end.from, t.end.to)), e;
}
const DW = /* @__PURE__ */ Nt.define({
  create() {
    return xe.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let r = [], n = e.state.facet(LE);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let s = vn(e.state, i.head, -1, n) || i.head > 0 && vn(e.state, i.head - 1, 1, n) || n.afterCursor && (vn(e.state, i.head, 1, n) || i.head < e.state.doc.length && vn(e.state, i.head + 1, -1, n));
      s && (r = r.concat(n.renderMatch(s, e.state)));
    }
    return xe.set(r, !0);
  },
  provide: (t) => ce.decorations.from(t)
}), xW = [
  DW,
  fW
];
function bW(t = {}) {
  return [LE.of(t), xW];
}
const vW = /* @__PURE__ */ new Me();
function yf(t, e, r) {
  let n = t.prop(e < 0 ? Me.openedBy : Me.closedBy);
  if (n)
    return n;
  if (t.name.length == 1) {
    let i = r.indexOf(t.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [r[i + e]];
  }
  return null;
}
function Df(t) {
  let e = t.type.prop(vW);
  return e ? e(t.node) : t;
}
function vn(t, e, r, n = {}) {
  let i = n.maxScanDistance || ME, s = n.brackets || OE, o = Ut(t), l = o.resolveInner(e, r);
  for (let u = l; u; u = u.parent) {
    let h = yf(u.type, r, s);
    if (h && u.from < u.to) {
      let p = Df(u);
      if (p && (r > 0 ? e >= p.from && e < p.to : e > p.from && e <= p.to))
        return CW(t, e, r, u, p, h, s);
    }
  }
  return AW(t, e, r, o, l.type, i, s);
}
function CW(t, e, r, n, i, s, o) {
  let l = n.parent, u = { from: i.from, to: i.to }, h = 0, p = l == null ? void 0 : l.cursor();
  if (p && (r < 0 ? p.childBefore(n.from) : p.childAfter(n.to)))
    do
      if (r < 0 ? p.to <= n.from : p.from >= n.to) {
        if (h == 0 && s.indexOf(p.type.name) > -1 && p.from < p.to) {
          let d = Df(p);
          return { start: u, end: d ? { from: d.from, to: d.to } : void 0, matched: !0 };
        } else if (yf(p.type, r, o))
          h++;
        else if (yf(p.type, -r, o)) {
          if (h == 0) {
            let d = Df(p);
            return {
              start: u,
              end: d && d.from < d.to ? { from: d.from, to: d.to } : void 0,
              matched: !1
            };
          }
          h--;
        }
      }
    while (r < 0 ? p.prevSibling() : p.nextSibling());
  return { start: u, matched: !1 };
}
function AW(t, e, r, n, i, s, o) {
  let l = r < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), u = o.indexOf(l);
  if (u < 0 || u % 2 == 0 != r > 0)
    return null;
  let h = { from: r < 0 ? e - 1 : e, to: r > 0 ? e + 1 : e }, p = t.doc.iterRange(e, r > 0 ? t.doc.length : 0), d = 0;
  for (let m = 0; !p.next().done && m <= s; ) {
    let y = p.value;
    r < 0 && (m += y.length);
    let D = e + m * r;
    for (let b = r > 0 ? 0 : y.length - 1, C = r > 0 ? y.length : -1; b != C; b += r) {
      let A = o.indexOf(y[b]);
      if (!(A < 0 || n.resolveInner(D + b, 1).type != i))
        if (A % 2 == 0 == r > 0)
          d++;
        else {
          if (d == 1)
            return { start: h, end: { from: D + b, to: D + b + 1 }, matched: A >> 1 == u >> 1 };
          d--;
        }
    }
    r > 0 && (m += y.length);
  }
  return p.done ? { start: h, matched: !1 } : null;
}
const EW = /* @__PURE__ */ Object.create(null), tD = [jr.none], rD = [], nD = /* @__PURE__ */ Object.create(null), wW = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  wW[t] = /* @__PURE__ */ SW(EW, e);
function _p(t, e) {
  rD.indexOf(t) > -1 || (rD.push(t), console.warn(e));
}
function SW(t, e) {
  let r = [];
  for (let l of e.split(" ")) {
    let u = [];
    for (let h of l.split(".")) {
      let p = t[h] || V[h];
      p ? typeof p == "function" ? u.length ? u = u.map(p) : _p(h, `Modifier ${h} used at start of tag`) : u.length ? _p(h, `Tag ${h} used as modifier`) : u = Array.isArray(p) ? p : [p] : _p(h, `Unknown highlighting tag ${h}`);
    }
    for (let h of u)
      r.push(h);
  }
  if (!r.length)
    return 0;
  let n = e.replace(/ /g, "_"), i = n + " " + r.map((l) => l.id), s = nD[i];
  if (s)
    return s.id;
  let o = nD[i] = jr.define({
    id: tD.length,
    name: n,
    props: [Bq({ [n]: r })]
  });
  return tD.push(o), o.id;
}
tt.RTL, tt.LTR;
const TW = (t) => {
  let { state: e } = t, r = e.doc.lineAt(e.selection.main.from), n = Sg(t.state, r.from);
  return n.line ? kW(t) : n.block ? PW(t) : !1;
};
function wg(t, e) {
  return ({ state: r, dispatch: n }) => {
    if (r.readOnly)
      return !1;
    let i = t(e, r);
    return i ? (n(r.update(i)), !0) : !1;
  };
}
const kW = /* @__PURE__ */ wg(
  NW,
  0
  /* CommentOption.Toggle */
), FW = /* @__PURE__ */ wg(
  _E,
  0
  /* CommentOption.Toggle */
), PW = /* @__PURE__ */ wg(
  (t, e) => _E(t, e, IW(e)),
  0
  /* CommentOption.Toggle */
);
function Sg(t, e) {
  let r = t.languageDataAt("commentTokens", e);
  return r.length ? r[0] : {};
}
const ca = 50;
function BW(t, { open: e, close: r }, n, i) {
  let s = t.sliceDoc(n - ca, n), o = t.sliceDoc(i, i + ca), l = /\s*$/.exec(s)[0].length, u = /^\s*/.exec(o)[0].length, h = s.length - l;
  if (s.slice(h - e.length, h) == e && o.slice(u, u + r.length) == r)
    return {
      open: { pos: n - l, margin: l && 1 },
      close: { pos: i + u, margin: u && 1 }
    };
  let p, d;
  i - n <= 2 * ca ? p = d = t.sliceDoc(n, i) : (p = t.sliceDoc(n, n + ca), d = t.sliceDoc(i - ca, i));
  let m = /^\s*/.exec(p)[0].length, y = /\s*$/.exec(d)[0].length, D = d.length - y - r.length;
  return p.slice(m, m + e.length) == e && d.slice(D, D + r.length) == r ? {
    open: {
      pos: n + m + e.length,
      margin: /\s/.test(p.charAt(m + e.length)) ? 1 : 0
    },
    close: {
      pos: i - y - r.length,
      margin: /\s/.test(d.charAt(D - 1)) ? 1 : 0
    }
  } : null;
}
function IW(t) {
  let e = [];
  for (let r of t.selection.ranges) {
    let n = t.doc.lineAt(r.from), i = r.to <= n.to ? n : t.doc.lineAt(r.to), s = e.length - 1;
    s >= 0 && e[s].to > n.from ? e[s].to = i.to : e.push({ from: n.from + /^\s*/.exec(n.text)[0].length, to: i.to });
  }
  return e;
}
function _E(t, e, r = e.selection.ranges) {
  let n = r.map((s) => Sg(e, s.from).block);
  if (!n.every((s) => s))
    return null;
  let i = r.map((s, o) => BW(e, n[o], s.from, s.to));
  if (t != 2 && !i.every((s) => s))
    return { changes: e.changes(r.map((s, o) => i[o] ? [] : [{ from: s.from, insert: n[o].open + " " }, { from: s.to, insert: " " + n[o].close }])) };
  if (t != 1 && i.some((s) => s)) {
    let s = [];
    for (let o = 0, l; o < i.length; o++)
      if (l = i[o]) {
        let u = n[o], { open: h, close: p } = l;
        s.push({ from: h.pos - u.open.length, to: h.pos + h.margin }, { from: p.pos - p.margin, to: p.pos + u.close.length });
      }
    return { changes: s };
  }
  return null;
}
function NW(t, e, r = e.selection.ranges) {
  let n = [], i = -1;
  for (let { from: s, to: o } of r) {
    let l = n.length, u = 1e9, h = Sg(e, s).line;
    if (h) {
      for (let p = s; p <= o; ) {
        let d = e.doc.lineAt(p);
        if (d.from > i && (s == o || o > d.from)) {
          i = d.from;
          let m = /^\s*/.exec(d.text)[0].length, y = m == d.length, D = d.text.slice(m, m + h.length) == h ? m : -1;
          m < d.text.length && m < u && (u = m), n.push({ line: d, comment: D, token: h, indent: m, empty: y, single: !1 });
        }
        p = d.to + 1;
      }
      if (u < 1e9)
        for (let p = l; p < n.length; p++)
          n[p].indent < n[p].line.text.length && (n[p].indent = u);
      n.length == l + 1 && (n[l].single = !0);
    }
  }
  if (t != 2 && n.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: l, token: u, indent: h, empty: p, single: d } of n)
      (d || !p) && s.push({ from: l.from + h, insert: u + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (t != 1 && n.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: l, token: u } of n)
      if (l >= 0) {
        let h = o.from + l, p = h + u.length;
        o.text[p - o.from] == " " && p++, s.push({ from: h, to: p });
      }
    return { changes: s };
  }
  return null;
}
const xf = /* @__PURE__ */ Nn.define(), MW = /* @__PURE__ */ Nn.define(), OW = /* @__PURE__ */ ge.define(), $E = /* @__PURE__ */ ge.define({
  combine(t) {
    return Mn(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, r) => r
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, r) => (n, i) => e(n, i) || r(n, i)
    });
  }
}), RE = /* @__PURE__ */ Nt.define({
  create() {
    return Cn.empty;
  },
  update(t, e) {
    let r = e.state.facet($E), n = e.annotation(xf);
    if (n) {
      let u = rr.fromTransaction(e, n.selection), h = n.side, p = h == 0 ? t.undone : t.done;
      return u ? p = xc(p, p.length, r.minDepth, u) : p = WE(p, e.startState.selection), new Cn(h == 0 ? n.rest : p, h == 0 ? p : n.rest);
    }
    let i = e.annotation(MW);
    if ((i == "full" || i == "before") && (t = t.isolate()), e.annotation(gt.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let s = rr.fromTransaction(e), o = e.annotation(gt.time), l = e.annotation(gt.userEvent);
    return s ? t = t.addChanges(s, o, l, r, e) : e.selection && (t = t.addSelection(e.startState.selection, o, l, r.newGroupDelay)), (i == "full" || i == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new Cn(t.done.map(rr.fromJSON), t.undone.map(rr.fromJSON));
  }
});
function LW(t = {}) {
  return [
    RE,
    $E.of(t),
    ce.domEventHandlers({
      beforeinput(e, r) {
        let n = e.inputType == "historyUndo" ? jE : e.inputType == "historyRedo" ? bf : null;
        return n ? (e.preventDefault(), n(r)) : !1;
      }
    })
  ];
}
function Th(t, e) {
  return function({ state: r, dispatch: n }) {
    if (!e && r.readOnly)
      return !1;
    let i = r.field(RE, !1);
    if (!i)
      return !1;
    let s = i.pop(t, r, e);
    return s ? (n(s), !0) : !1;
  };
}
const jE = /* @__PURE__ */ Th(0, !1), bf = /* @__PURE__ */ Th(1, !1), _W = /* @__PURE__ */ Th(0, !0), $W = /* @__PURE__ */ Th(1, !0);
class rr {
  constructor(e, r, n, i, s) {
    this.changes = e, this.effects = r, this.mapped = n, this.startSelection = i, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new rr(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, r, n;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (r = this.mapped) === null || r === void 0 ? void 0 : r.toJSON(),
      startSelection: (n = this.startSelection) === null || n === void 0 ? void 0 : n.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new rr(e.changes && mt.fromJSON(e.changes), [], e.mapped && wn.fromJSON(e.mapped), e.startSelection && K.fromJSON(e.startSelection), e.selectionsAfter.map(K.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, r) {
    let n = Pr;
    for (let i of e.startState.facet(OW)) {
      let s = i(e);
      s.length && (n = n.concat(s));
    }
    return !n.length && e.changes.empty ? null : new rr(e.changes.invert(e.startState.doc), n, void 0, r || e.startState.selection, Pr);
  }
  static selection(e) {
    return new rr(void 0, Pr, void 0, void 0, e);
  }
}
function xc(t, e, r, n) {
  let i = e + 1 > r + 20 ? e - r - 1 : 0, s = t.slice(i, e);
  return s.push(n), s;
}
function RW(t, e) {
  let r = [], n = !1;
  return t.iterChangedRanges((i, s) => r.push(i, s)), e.iterChangedRanges((i, s, o, l) => {
    for (let u = 0; u < r.length; ) {
      let h = r[u++], p = r[u++];
      l >= h && o <= p && (n = !0);
    }
  }), n;
}
function jW(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((r, n) => r.empty != e.ranges[n].empty).length === 0;
}
function qE(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const Pr = [], qW = 200;
function WE(t, e) {
  if (t.length) {
    let r = t[t.length - 1], n = r.selectionsAfter.slice(Math.max(0, r.selectionsAfter.length - qW));
    return n.length && n[n.length - 1].eq(e) ? t : (n.push(e), xc(t, t.length - 1, 1e9, r.setSelAfter(n)));
  } else
    return [rr.selection([e])];
}
function WW(t) {
  let e = t[t.length - 1], r = t.slice();
  return r[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), r;
}
function $p(t, e) {
  if (!t.length)
    return t;
  let r = t.length, n = Pr;
  for (; r; ) {
    let i = UW(t[r - 1], e, n);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let s = t.slice(0, r);
      return s[r - 1] = i, s;
    } else
      e = i.mapped, r--, n = i.selectionsAfter;
  }
  return n.length ? [rr.selection(n)] : Pr;
}
function UW(t, e, r) {
  let n = qE(t.selectionsAfter.length ? t.selectionsAfter.map((l) => l.map(e)) : Pr, r);
  if (!t.changes)
    return rr.selection(n);
  let i = t.changes.map(e), s = e.mapDesc(t.changes, !0), o = t.mapped ? t.mapped.composeDesc(s) : s;
  return new rr(i, Se.mapEffects(t.effects, e), o, t.startSelection.map(s), n);
}
const HW = /^(input\.type|delete)($|\.)/;
class Cn {
  constructor(e, r, n = 0, i = void 0) {
    this.done = e, this.undone = r, this.prevTime = n, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new Cn(this.done, this.undone) : this;
  }
  addChanges(e, r, n, i, s) {
    let o = this.done, l = o[o.length - 1];
    return l && l.changes && !l.changes.empty && e.changes && (!n || HW.test(n)) && (!l.selectionsAfter.length && r - this.prevTime < i.newGroupDelay && i.joinToEvent(s, RW(l.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    n == "input.type.compose") ? o = xc(o, o.length - 1, i.minDepth, new rr(e.changes.compose(l.changes), qE(e.effects, l.effects), l.mapped, l.startSelection, Pr)) : o = xc(o, o.length, i.minDepth, e), new Cn(o, Pr, r, n);
  }
  addSelection(e, r, n, i) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Pr;
    return s.length > 0 && r - this.prevTime < i && n == this.prevUserEvent && n && /^select($|\.)/.test(n) && jW(s[s.length - 1], e) ? this : new Cn(WE(this.done, e), this.undone, r, n);
  }
  addMapping(e) {
    return new Cn($p(this.done, e), $p(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, r, n) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let s = i[i.length - 1], o = s.selectionsAfter[0] || r.selection;
    if (n && s.selectionsAfter.length)
      return r.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: xf.of({ side: e, rest: WW(i), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let l = i.length == 1 ? Pr : i.slice(0, i.length - 1);
      return s.mapped && (l = $p(l, s.mapped)), r.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: xf.of({ side: e, rest: l, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Cn.empty = /* @__PURE__ */ new Cn(Pr, Pr);
const VW = [
  { key: "Mod-z", run: jE, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: bf, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: bf, preventDefault: !0 },
  { key: "Mod-u", run: _W, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: $W, preventDefault: !0 }
];
function Wo(t, e) {
  return K.create(t.ranges.map(e), t.mainIndex);
}
function On(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function sn({ state: t, dispatch: e }, r) {
  let n = Wo(t.selection, r);
  return n.eq(t.selection, !0) ? !1 : (e(On(t, n)), !0);
}
function kh(t, e) {
  return K.cursor(e ? t.to : t.from);
}
function UE(t, e) {
  return sn(t, (r) => r.empty ? t.moveByChar(r, e) : kh(r, e));
}
function Ht(t) {
  return t.textDirectionAt(t.state.selection.main.head) == tt.LTR;
}
const HE = (t) => UE(t, !Ht(t)), VE = (t) => UE(t, Ht(t));
function zE(t, e) {
  return sn(t, (r) => r.empty ? t.moveByGroup(r, e) : kh(r, e));
}
const zW = (t) => zE(t, !Ht(t)), JW = (t) => zE(t, Ht(t));
function KW(t, e, r) {
  if (e.type.prop(r))
    return !0;
  let n = e.to - e.from;
  return n && (n > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Fh(t, e, r) {
  let n = Ut(t).resolveInner(e.head), i = r ? Me.closedBy : Me.openedBy;
  for (let u = e.head; ; ) {
    let h = r ? n.childAfter(u) : n.childBefore(u);
    if (!h)
      break;
    KW(t, h, i) ? n = h : u = r ? h.to : h.from;
  }
  let s = n.type.prop(i), o, l;
  return s && (o = r ? vn(t, n.from, 1) : vn(t, n.to, -1)) && o.matched ? l = r ? o.end.to : o.end.from : l = r ? n.to : n.from, K.cursor(l, r ? -1 : 1);
}
const GW = (t) => sn(t, (e) => Fh(t.state, e, !Ht(t))), XW = (t) => sn(t, (e) => Fh(t.state, e, Ht(t)));
function JE(t, e) {
  return sn(t, (r) => {
    if (!r.empty)
      return kh(r, e);
    let n = t.moveVertically(r, e);
    return n.head != r.head ? n : t.moveToLineBoundary(r, e);
  });
}
const KE = (t) => JE(t, !1), GE = (t) => JE(t, !0);
function XE(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, r = 0, n = 0, i;
  if (e) {
    for (let s of t.state.facet(ce.scrollMargins)) {
      let o = s(t);
      o != null && o.top && (r = Math.max(o == null ? void 0 : o.top, r)), o != null && o.bottom && (n = Math.max(o == null ? void 0 : o.bottom, n));
    }
    i = t.scrollDOM.clientHeight - r - n;
  } else
    i = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: r,
    marginBottom: n,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, i - 5)
  };
}
function YE(t, e) {
  let r = XE(t), { state: n } = t, i = Wo(n.selection, (o) => o.empty ? t.moveVertically(o, e, r.height) : kh(o, e));
  if (i.eq(n.selection))
    return !1;
  let s;
  if (r.selfScroll) {
    let o = t.coordsAtPos(n.selection.main.head), l = t.scrollDOM.getBoundingClientRect(), u = l.top + r.marginTop, h = l.bottom - r.marginBottom;
    o && o.top > u && o.bottom < h && (s = ce.scrollIntoView(i.main.head, { y: "start", yMargin: o.top - u }));
  }
  return t.dispatch(On(n, i), { effects: s }), !0;
}
const iD = (t) => YE(t, !1), vf = (t) => YE(t, !0);
function zi(t, e, r) {
  let n = t.lineBlockAt(e.head), i = t.moveToLineBoundary(e, r);
  if (i.head == e.head && i.head != (r ? n.to : n.from) && (i = t.moveToLineBoundary(e, r, !1)), !r && i.head == n.from && n.length) {
    let s = /^\s*/.exec(t.state.sliceDoc(n.from, Math.min(n.from + 100, n.to)))[0].length;
    s && e.head != n.from + s && (i = K.cursor(n.from + s));
  }
  return i;
}
const YW = (t) => sn(t, (e) => zi(t, e, !0)), QW = (t) => sn(t, (e) => zi(t, e, !1)), ZW = (t) => sn(t, (e) => zi(t, e, !Ht(t))), eU = (t) => sn(t, (e) => zi(t, e, Ht(t))), tU = (t) => sn(t, (e) => K.cursor(t.lineBlockAt(e.head).from, 1)), rU = (t) => sn(t, (e) => K.cursor(t.lineBlockAt(e.head).to, -1));
function nU(t, e, r) {
  let n = !1, i = Wo(t.selection, (s) => {
    let o = vn(t, s.head, -1) || vn(t, s.head, 1) || s.head > 0 && vn(t, s.head - 1, 1) || s.head < t.doc.length && vn(t, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    n = !0;
    let l = o.start.from == s.head ? o.end.to : o.end.from;
    return r ? K.range(s.anchor, l) : K.cursor(l);
  });
  return n ? (e(On(t, i)), !0) : !1;
}
const iU = ({ state: t, dispatch: e }) => nU(t, e, !1);
function Wr(t, e) {
  let r = Wo(t.state.selection, (n) => {
    let i = e(n);
    return K.range(n.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return r.eq(t.state.selection) ? !1 : (t.dispatch(On(t.state, r)), !0);
}
function QE(t, e) {
  return Wr(t, (r) => t.moveByChar(r, e));
}
const ZE = (t) => QE(t, !Ht(t)), ew = (t) => QE(t, Ht(t));
function tw(t, e) {
  return Wr(t, (r) => t.moveByGroup(r, e));
}
const sU = (t) => tw(t, !Ht(t)), oU = (t) => tw(t, Ht(t)), aU = (t) => Wr(t, (e) => Fh(t.state, e, !Ht(t))), lU = (t) => Wr(t, (e) => Fh(t.state, e, Ht(t)));
function rw(t, e) {
  return Wr(t, (r) => t.moveVertically(r, e));
}
const nw = (t) => rw(t, !1), iw = (t) => rw(t, !0);
function sw(t, e) {
  return Wr(t, (r) => t.moveVertically(r, e, XE(t).height));
}
const sD = (t) => sw(t, !1), oD = (t) => sw(t, !0), uU = (t) => Wr(t, (e) => zi(t, e, !0)), cU = (t) => Wr(t, (e) => zi(t, e, !1)), hU = (t) => Wr(t, (e) => zi(t, e, !Ht(t))), pU = (t) => Wr(t, (e) => zi(t, e, Ht(t))), dU = (t) => Wr(t, (e) => K.cursor(t.lineBlockAt(e.head).from)), fU = (t) => Wr(t, (e) => K.cursor(t.lineBlockAt(e.head).to)), aD = ({ state: t, dispatch: e }) => (e(On(t, { anchor: 0 })), !0), lD = ({ state: t, dispatch: e }) => (e(On(t, { anchor: t.doc.length })), !0), uD = ({ state: t, dispatch: e }) => (e(On(t, { anchor: t.selection.main.anchor, head: 0 })), !0), cD = ({ state: t, dispatch: e }) => (e(On(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), mU = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), gU = ({ state: t, dispatch: e }) => {
  let r = Ph(t).map(({ from: n, to: i }) => K.range(n, Math.min(i + 1, t.doc.length)));
  return e(t.update({ selection: K.create(r), userEvent: "select" })), !0;
}, yU = ({ state: t, dispatch: e }) => {
  let r = Wo(t.selection, (n) => {
    var i;
    let s = Ut(t).resolveStack(n.from, 1);
    for (let o = s; o; o = o.next) {
      let { node: l } = o;
      if ((l.from < n.from && l.to >= n.to || l.to > n.to && l.from <= n.from) && (!((i = l.parent) === null || i === void 0) && i.parent))
        return K.range(l.to, l.from);
    }
    return n;
  });
  return e(On(t, r)), !0;
}, DU = ({ state: t, dispatch: e }) => {
  let r = t.selection, n = null;
  return r.ranges.length > 1 ? n = K.create([r.main]) : r.main.empty || (n = K.create([K.cursor(r.main.head)])), n ? (e(On(t, n)), !0) : !1;
};
function Pl(t, e) {
  if (t.state.readOnly)
    return !1;
  let r = "delete.selection", { state: n } = t, i = n.changeByRange((s) => {
    let { from: o, to: l } = s;
    if (o == l) {
      let u = e(s);
      u < o ? (r = "delete.backward", u = vu(t, u, !1)) : u > o && (r = "delete.forward", u = vu(t, u, !0)), o = Math.min(o, u), l = Math.max(l, u);
    } else
      o = vu(t, o, !1), l = vu(t, l, !0);
    return o == l ? { range: s } : { changes: { from: o, to: l }, range: K.cursor(o, o < s.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (t.dispatch(n.update(i, {
    scrollIntoView: !0,
    userEvent: r,
    effects: r == "delete.selection" ? ce.announce.of(n.phrase("Selection deleted")) : void 0
  })), !0);
}
function vu(t, e, r) {
  if (t instanceof ce)
    for (let n of t.state.facet(ce.atomicRanges).map((i) => i(t)))
      n.between(e, e, (i, s) => {
        i < e && s > e && (e = r ? s : i);
      });
  return e;
}
const ow = (t, e) => Pl(t, (r) => {
  let n = r.from, { state: i } = t, s = i.doc.lineAt(n), o, l;
  if (!e && n > s.from && n < s.from + 200 && !/[^ \t]/.test(o = s.text.slice(0, n - s.from))) {
    if (o[o.length - 1] == "	")
      return n - 1;
    let u = qo(o, i.tabSize), h = u % gc(i) || gc(i);
    for (let p = 0; p < h && o[o.length - 1 - p] == " "; p++)
      n--;
    l = n;
  } else
    l = Tt(s.text, n - s.from, e, e) + s.from, l == n && s.number != (e ? i.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(l - s.from, n - s.from)) && (l = Tt(s.text, l - s.from, !1, !1) + s.from);
  return l;
}), Cf = (t) => ow(t, !1), aw = (t) => ow(t, !0), lw = (t, e) => Pl(t, (r) => {
  let n = r.head, { state: i } = t, s = i.doc.lineAt(n), o = i.charCategorizer(n);
  for (let l = null; ; ) {
    if (n == (e ? s.to : s.from)) {
      n == r.head && s.number != (e ? i.doc.lines : 1) && (n += e ? 1 : -1);
      break;
    }
    let u = Tt(s.text, n - s.from, e) + s.from, h = s.text.slice(Math.min(n, u) - s.from, Math.max(n, u) - s.from), p = o(h);
    if (l != null && p != l)
      break;
    (h != " " || n != r.head) && (l = p), n = u;
  }
  return n;
}), uw = (t) => lw(t, !1), xU = (t) => lw(t, !0), bU = (t) => Pl(t, (e) => {
  let r = t.lineBlockAt(e.head).to;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), vU = (t) => Pl(t, (e) => {
  let r = t.moveToLineBoundary(e, !1).head;
  return e.head > r ? r : Math.max(0, e.head - 1);
}), CU = (t) => Pl(t, (e) => {
  let r = t.moveToLineBoundary(e, !0).head;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), AU = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((n) => ({
    changes: { from: n.from, to: n.to, insert: Ue.of(["", ""]) },
    range: K.cursor(n.from)
  }));
  return e(t.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
}, EU = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((n) => {
    if (!n.empty || n.from == 0 || n.from == t.doc.length)
      return { range: n };
    let i = n.from, s = t.doc.lineAt(i), o = i == s.from ? i - 1 : Tt(s.text, i - s.from, !1) + s.from, l = i == s.to ? i + 1 : Tt(s.text, i - s.from, !0) + s.from;
    return {
      changes: { from: o, to: l, insert: t.doc.slice(i, l).append(t.doc.slice(o, i)) },
      range: K.cursor(l)
    };
  });
  return r.changes.empty ? !1 : (e(t.update(r, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Ph(t) {
  let e = [], r = -1;
  for (let n of t.selection.ranges) {
    let i = t.doc.lineAt(n.from), s = t.doc.lineAt(n.to);
    if (!n.empty && n.to == s.from && (s = t.doc.lineAt(n.to - 1)), r >= i.number) {
      let o = e[e.length - 1];
      o.to = s.to, o.ranges.push(n);
    } else
      e.push({ from: i.from, to: s.to, ranges: [n] });
    r = s.number + 1;
  }
  return e;
}
function cw(t, e, r) {
  if (t.readOnly)
    return !1;
  let n = [], i = [];
  for (let s of Ph(t)) {
    if (r ? s.to == t.doc.length : s.from == 0)
      continue;
    let o = t.doc.lineAt(r ? s.to + 1 : s.from - 1), l = o.length + 1;
    if (r) {
      n.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + t.lineBreak });
      for (let u of s.ranges)
        i.push(K.range(Math.min(t.doc.length, u.anchor + l), Math.min(t.doc.length, u.head + l)));
    } else {
      n.push({ from: o.from, to: s.from }, { from: s.to, insert: t.lineBreak + o.text });
      for (let u of s.ranges)
        i.push(K.range(u.anchor - l, u.head - l));
    }
  }
  return n.length ? (e(t.update({
    changes: n,
    scrollIntoView: !0,
    selection: K.create(i, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const wU = ({ state: t, dispatch: e }) => cw(t, e, !1), SU = ({ state: t, dispatch: e }) => cw(t, e, !0);
function hw(t, e, r) {
  if (t.readOnly)
    return !1;
  let n = [];
  for (let i of Ph(t))
    r ? n.push({ from: i.from, insert: t.doc.slice(i.from, i.to) + t.lineBreak }) : n.push({ from: i.to, insert: t.lineBreak + t.doc.slice(i.from, i.to) });
  return e(t.update({ changes: n, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const TU = ({ state: t, dispatch: e }) => hw(t, e, !1), kU = ({ state: t, dispatch: e }) => hw(t, e, !0), FU = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, r = e.changes(Ph(e).map(({ from: i, to: s }) => (i > 0 ? i-- : s < e.doc.length && s++, { from: i, to: s }))), n = Wo(e.selection, (i) => t.moveVertically(i, !0)).map(r);
  return t.dispatch({ changes: r, selection: n, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function PU(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let r = Ut(t).resolveInner(e), n = r.childBefore(e), i = r.childAfter(e), s;
  return n && i && n.to <= e && i.from >= e && (s = n.type.prop(Me.closedBy)) && s.indexOf(i.name) > -1 && t.doc.lineAt(n.to).from == t.doc.lineAt(i.from).from && !/\S/.test(t.sliceDoc(n.to, i.from)) ? { from: n.to, to: i.from } : null;
}
const BU = /* @__PURE__ */ pw(!1), IU = /* @__PURE__ */ pw(!0);
function pw(t) {
  return ({ state: e, dispatch: r }) => {
    if (e.readOnly)
      return !1;
    let n = e.changeByRange((i) => {
      let { from: s, to: o } = i, l = e.doc.lineAt(s), u = !t && s == o && PU(e, s);
      t && (s = o = (o <= l.to ? l : e.doc.lineAt(o)).to);
      let h = new wh(e, { simulateBreak: s, simulateDoubleBreak: !!u }), p = Cg(h, s);
      for (p == null && (p = qo(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < l.to && /\s/.test(l.text[o - l.from]); )
        o++;
      u ? { from: s, to: o } = u : s > l.from && s < l.from + 100 && !/\S/.test(l.text.slice(0, s)) && (s = l.from);
      let d = ["", rl(e, p)];
      return u && d.push(rl(e, h.lineIndent(l.from, -1))), {
        changes: { from: s, to: o, insert: Ue.of(d) },
        range: K.cursor(s + 1 + d[1].length)
      };
    });
    return r(e.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Tg(t, e) {
  let r = -1;
  return t.changeByRange((n) => {
    let i = [];
    for (let o = n.from; o <= n.to; ) {
      let l = t.doc.lineAt(o);
      l.number > r && (n.empty || n.to > l.from) && (e(l, i, n), r = l.number), o = l.to + 1;
    }
    let s = t.changes(i);
    return {
      changes: i,
      range: K.range(s.mapPos(n.anchor, 1), s.mapPos(n.head, 1))
    };
  });
}
const NU = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = /* @__PURE__ */ Object.create(null), n = new wh(t, { overrideIndentation: (s) => {
    let o = r[s];
    return o ?? -1;
  } }), i = Tg(t, (s, o, l) => {
    let u = Cg(n, s.from);
    if (u == null)
      return;
    /\S/.test(s.text) || (u = 0);
    let h = /^\s*/.exec(s.text)[0], p = rl(t, u);
    (h != p || l.from < s.from + h.length) && (r[s.from] = u, o.push({ from: s.from, to: s.from + h.length, insert: p }));
  });
  return i.changes.empty || e(t.update(i, { userEvent: "indent" })), !0;
}, dw = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Tg(t, (r, n) => {
  n.push({ from: r.from, insert: t.facet(Eh) });
}), { userEvent: "input.indent" })), !0), fw = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Tg(t, (r, n) => {
  let i = /^\s*/.exec(r.text)[0];
  if (!i)
    return;
  let s = qo(i, t.tabSize), o = 0, l = rl(t, Math.max(0, s - gc(t)));
  for (; o < i.length && o < l.length && i.charCodeAt(o) == l.charCodeAt(o); )
    o++;
  n.push({ from: r.from + o, to: r.from + i.length, insert: l.slice(o) });
}), { userEvent: "delete.dedent" })), !0), MU = [
  { key: "Ctrl-b", run: HE, shift: ZE, preventDefault: !0 },
  { key: "Ctrl-f", run: VE, shift: ew },
  { key: "Ctrl-p", run: KE, shift: nw },
  { key: "Ctrl-n", run: GE, shift: iw },
  { key: "Ctrl-a", run: tU, shift: dU },
  { key: "Ctrl-e", run: rU, shift: fU },
  { key: "Ctrl-d", run: aw },
  { key: "Ctrl-h", run: Cf },
  { key: "Ctrl-k", run: bU },
  { key: "Ctrl-Alt-h", run: uw },
  { key: "Ctrl-o", run: AU },
  { key: "Ctrl-t", run: EU },
  { key: "Ctrl-v", run: vf }
], OU = /* @__PURE__ */ [
  { key: "ArrowLeft", run: HE, shift: ZE, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: zW, shift: sU, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: ZW, shift: hU, preventDefault: !0 },
  { key: "ArrowRight", run: VE, shift: ew, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: JW, shift: oU, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: eU, shift: pU, preventDefault: !0 },
  { key: "ArrowUp", run: KE, shift: nw, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: aD, shift: uD },
  { mac: "Ctrl-ArrowUp", run: iD, shift: sD },
  { key: "ArrowDown", run: GE, shift: iw, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: lD, shift: cD },
  { mac: "Ctrl-ArrowDown", run: vf, shift: oD },
  { key: "PageUp", run: iD, shift: sD },
  { key: "PageDown", run: vf, shift: oD },
  { key: "Home", run: QW, shift: cU, preventDefault: !0 },
  { key: "Mod-Home", run: aD, shift: uD },
  { key: "End", run: YW, shift: uU, preventDefault: !0 },
  { key: "Mod-End", run: lD, shift: cD },
  { key: "Enter", run: BU },
  { key: "Mod-a", run: mU },
  { key: "Backspace", run: Cf, shift: Cf },
  { key: "Delete", run: aw },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: uw },
  { key: "Mod-Delete", mac: "Alt-Delete", run: xU },
  { mac: "Mod-Backspace", run: vU },
  { mac: "Mod-Delete", run: CU }
].concat(/* @__PURE__ */ MU.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), LU = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: GW, shift: aU },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: XW, shift: lU },
  { key: "Alt-ArrowUp", run: wU },
  { key: "Shift-Alt-ArrowUp", run: TU },
  { key: "Alt-ArrowDown", run: SU },
  { key: "Shift-Alt-ArrowDown", run: kU },
  { key: "Escape", run: DU },
  { key: "Mod-Enter", run: IU },
  { key: "Alt-l", mac: "Ctrl-l", run: gU },
  { key: "Mod-i", run: yU, preventDefault: !0 },
  { key: "Mod-[", run: fw },
  { key: "Mod-]", run: dw },
  { key: "Mod-Alt-\\", run: NU },
  { key: "Shift-Mod-k", run: FU },
  { key: "Shift-Mod-\\", run: iU },
  { key: "Mod-/", run: TW },
  { key: "Alt-A", run: FW }
].concat(OU), _U = { key: "Tab", run: dw, shift: fw };
function Ye() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, r = arguments[1];
  if (r && typeof r == "object" && r.nodeType == null && !Array.isArray(r)) {
    for (var n in r)
      if (Object.prototype.hasOwnProperty.call(r, n)) {
        var i = r[n];
        typeof i == "string" ? t.setAttribute(n, i) : i != null && (t[n] = i);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    mw(t, arguments[e]);
  return t;
}
function mw(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      t.appendChild(e);
    else if (Array.isArray(e))
      for (var r = 0; r < e.length; r++)
        mw(t, e[r]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const hD = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class wo {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, r, n = 0, i = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(n, i), this.bufferStart = n, this.normalize = s ? (l) => s(hD(l)) : hD, this.query = this.normalize(r);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Ct(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let r = ag(e), n = this.bufferStart + this.bufferPos;
      this.bufferPos += Fr(e);
      let i = this.normalize(r);
      for (let s = 0, o = n; ; s++) {
        let l = i.charCodeAt(s), u = this.match(l, o, this.bufferPos + this.bufferStart);
        if (s == i.length - 1) {
          if (u)
            return this.value = u, this;
          break;
        }
        o == n && s < r.length && r.charCodeAt(s) == l && o++;
      }
    }
  }
  match(e, r, n) {
    let i = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let o = this.matches[s], l = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? i = { from: this.matches[s + 1], to: n } : (this.matches[s]++, l = !0)), l || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: r, to: n } : this.matches.push(1, r)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (wo.prototype[Symbol.iterator] = function() {
  return this;
});
const gw = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, kg = "gm" + (/x/.unicode == null ? "" : "u");
class yw {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, r, n, i = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = gw, /\\[sWDnr]|\n|\r|\[\^/.test(r))
      return new Dw(e, r, n, i, s);
    this.re = new RegExp(r, kg + (n != null && n.ignoreCase ? "i" : "")), this.test = n == null ? void 0 : n.test, this.iter = e.iter();
    let o = e.lineAt(i);
    this.curLineStart = o.from, this.matchPos = bc(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let r = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (r) {
        let n = this.curLineStart + r.index, i = n + r[0].length;
        if (this.matchPos = bc(this.text, i + (n == i ? 1 : 0)), n == this.curLineStart + this.curLine.length && this.nextLine(), (n < i || n > this.value.to) && (!this.test || this.test(n, i, r)))
          return this.value = { from: n, to: i, match: r }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Rp = /* @__PURE__ */ new WeakMap();
class ho {
  constructor(e, r) {
    this.from = e, this.text = r;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, r, n) {
    let i = Rp.get(e);
    if (!i || i.from >= n || i.to <= r) {
      let l = new ho(r, e.sliceString(r, n));
      return Rp.set(e, l), l;
    }
    if (i.from == r && i.to == n)
      return i;
    let { text: s, from: o } = i;
    return o > r && (s = e.sliceString(r, o) + s, o = r), i.to < n && (s += e.sliceString(i.to, n)), Rp.set(e, new ho(o, s)), new ho(r, s.slice(r - o, n - o));
  }
}
class Dw {
  constructor(e, r, n, i, s) {
    this.text = e, this.to = s, this.done = !1, this.value = gw, this.matchPos = bc(e, i), this.re = new RegExp(r, kg + (n != null && n.ignoreCase ? "i" : "")), this.test = n == null ? void 0 : n.test, this.flat = ho.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, r = this.re.exec(this.flat.text);
      if (r && !r[0] && r.index == e && (this.re.lastIndex = e + 1, r = this.re.exec(this.flat.text)), r) {
        let n = this.flat.from + r.index, i = n + r[0].length;
        if ((this.flat.to >= this.to || r.index + r[0].length <= this.flat.text.length - 10) && (!this.test || this.test(n, i, r)))
          return this.value = { from: n, to: i, match: r }, this.matchPos = bc(this.text, i + (n == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = ho.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (yw.prototype[Symbol.iterator] = Dw.prototype[Symbol.iterator] = function() {
  return this;
});
function $U(t) {
  try {
    return new RegExp(t, kg), !0;
  } catch {
    return !1;
  }
}
function bc(t, e) {
  if (e >= t.length)
    return e;
  let r = t.lineAt(e), n;
  for (; e < r.to && (n = r.text.charCodeAt(e - r.from)) >= 56320 && n < 57344; )
    e++;
  return e;
}
function Af(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), r = Ye("input", { class: "cm-textfield", name: "line", value: e }), n = Ye("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), t.dispatch({ effects: vc.of(!1) }), t.focus()) : s.keyCode == 13 && (s.preventDefault(), i());
    },
    onsubmit: (s) => {
      s.preventDefault(), i();
    }
  }, Ye("label", t.state.phrase("Go to line"), ": ", r), " ", Ye("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")));
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(r.value);
    if (!s)
      return;
    let { state: o } = t, l = o.doc.lineAt(o.selection.main.head), [, u, h, p, d] = s, m = p ? +p.slice(1) : 0, y = h ? +h : l.number;
    if (h && d) {
      let C = y / 100;
      u && (C = C * (u == "-" ? -1 : 1) + l.number / o.doc.lines), y = Math.round(o.doc.lines * C);
    } else
      h && u && (y = y * (u == "-" ? -1 : 1) + l.number);
    let D = o.doc.line(Math.max(1, Math.min(o.doc.lines, y))), b = K.cursor(D.from + Math.max(0, Math.min(m, D.length)));
    t.dispatch({
      effects: [vc.of(!1), ce.scrollIntoView(b.from, { y: "center" })],
      selection: b
    }), t.focus();
  }
  return { dom: n };
}
const vc = /* @__PURE__ */ Se.define(), pD = /* @__PURE__ */ Nt.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(vc) && (t = r.value);
    return t;
  },
  provide: (t) => el.from(t, (e) => e ? Af : null)
}), RU = (t) => {
  let e = Za(t, Af);
  if (!e) {
    let r = [vc.of(!0)];
    t.state.field(pD, !1) == null && r.push(Se.appendConfig.of([pD, jU])), t.dispatch({ effects: r }), e = Za(t, Af);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, jU = /* @__PURE__ */ ce.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), qU = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, xw = /* @__PURE__ */ ge.define({
  combine(t) {
    return Mn(t, qU, {
      highlightWordAroundCursor: (e, r) => e || r,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function WU(t) {
  let e = [JU, zU];
  return t && e.push(xw.of(t)), e;
}
const UU = /* @__PURE__ */ xe.mark({ class: "cm-selectionMatch" }), HU = /* @__PURE__ */ xe.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function dD(t, e, r, n) {
  return (r == 0 || t(e.sliceDoc(r - 1, r)) != nt.Word) && (n == e.doc.length || t(e.sliceDoc(n, n + 1)) != nt.Word);
}
function VU(t, e, r, n) {
  return t(e.sliceDoc(r, r + 1)) == nt.Word && t(e.sliceDoc(n - 1, n)) == nt.Word;
}
const zU = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(xw), { state: r } = t, n = r.selection;
    if (n.ranges.length > 1)
      return xe.none;
    let i = n.main, s, o = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return xe.none;
      let u = r.wordAt(i.head);
      if (!u)
        return xe.none;
      o = r.charCategorizer(i.head), s = r.sliceDoc(u.from, u.to);
    } else {
      let u = i.to - i.from;
      if (u < e.minSelectionLength || u > 200)
        return xe.none;
      if (e.wholeWords) {
        if (s = r.sliceDoc(i.from, i.to), o = r.charCategorizer(i.head), !(dD(o, r, i.from, i.to) && VU(o, r, i.from, i.to)))
          return xe.none;
      } else if (s = r.sliceDoc(i.from, i.to), !s)
        return xe.none;
    }
    let l = [];
    for (let u of t.visibleRanges) {
      let h = new wo(r.doc, s, u.from, u.to);
      for (; !h.next().done; ) {
        let { from: p, to: d } = h.value;
        if ((!o || dD(o, r, p, d)) && (i.empty && p <= i.from && d >= i.to ? l.push(HU.range(p, d)) : (p >= i.to || d <= i.from) && l.push(UU.range(p, d)), l.length > e.maxMatches))
          return xe.none;
      }
    }
    return xe.set(l);
  }
}, {
  decorations: (t) => t.decorations
}), JU = /* @__PURE__ */ ce.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), KU = ({ state: t, dispatch: e }) => {
  let { selection: r } = t, n = K.create(r.ranges.map((i) => t.wordAt(i.head) || K.cursor(i.head)), r.mainIndex);
  return n.eq(r) ? !1 : (e(t.update({ selection: n })), !0);
};
function GU(t, e) {
  let { main: r, ranges: n } = t.selection, i = t.wordAt(r.head), s = i && i.from == r.from && i.to == r.to;
  for (let o = !1, l = new wo(t.doc, e, n[n.length - 1].to); ; )
    if (l.next(), l.done) {
      if (o)
        return null;
      l = new wo(t.doc, e, 0, Math.max(0, n[n.length - 1].from - 1)), o = !0;
    } else {
      if (o && n.some((u) => u.from == l.value.from))
        continue;
      if (s) {
        let u = t.wordAt(l.value.from);
        if (!u || u.from != l.value.from || u.to != l.value.to)
          continue;
      }
      return l.value;
    }
}
const XU = ({ state: t, dispatch: e }) => {
  let { ranges: r } = t.selection;
  if (r.some((s) => s.from === s.to))
    return KU({ state: t, dispatch: e });
  let n = t.sliceDoc(r[0].from, r[0].to);
  if (t.selection.ranges.some((s) => t.sliceDoc(s.from, s.to) != n))
    return !1;
  let i = GU(t, n);
  return i ? (e(t.update({
    selection: t.selection.addRange(K.range(i.from, i.to), !1),
    effects: ce.scrollIntoView(i.to)
  })), !0) : !1;
}, Uo = /* @__PURE__ */ ge.define({
  combine(t) {
    return Mn(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new lH(e),
      scrollToMatch: (e) => ce.scrollIntoView(e)
    });
  }
});
class bw {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || $U(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (r, n) => n == "n" ? `
` : n == "r" ? "\r" : n == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new eH(this) : new QU(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, r = 0, n) {
    let i = e.doc ? e : Ie.create({ doc: e });
    return n == null && (n = i.doc.length), this.regexp ? Zs(this, i, r, n) : Qs(this, i, r, n);
  }
}
class vw {
  constructor(e) {
    this.spec = e;
  }
}
function Qs(t, e, r, n) {
  return new wo(e.doc, t.unquoted, r, n, t.caseSensitive ? void 0 : (i) => i.toLowerCase(), t.wholeWord ? YU(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function YU(t, e) {
  return (r, n, i, s) => ((s > r || s + i.length < n) && (s = Math.max(0, r - 2), i = t.sliceString(s, Math.min(t.length, n + 2))), (e(Cc(i, r - s)) != nt.Word || e(Ac(i, r - s)) != nt.Word) && (e(Ac(i, n - s)) != nt.Word || e(Cc(i, n - s)) != nt.Word));
}
class QU extends vw {
  constructor(e) {
    super(e);
  }
  nextMatch(e, r, n) {
    let i = Qs(this.spec, e, n, e.doc.length).nextOverlapping();
    return i.done && (i = Qs(this.spec, e, 0, r).nextOverlapping()), i.done ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, r, n) {
    for (let i = n; ; ) {
      let s = Math.max(r, i - 1e4 - this.spec.unquoted.length), o = Qs(this.spec, e, s, i), l = null;
      for (; !o.nextOverlapping().done; )
        l = o.value;
      if (l)
        return l;
      if (s == r)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, r, n) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, r) {
    let n = Qs(this.spec, e, 0, e.doc.length), i = [];
    for (; !n.next().done; ) {
      if (i.length >= r)
        return null;
      i.push(n.value);
    }
    return i;
  }
  highlight(e, r, n, i) {
    let s = Qs(this.spec, e, Math.max(0, r - this.spec.unquoted.length), Math.min(n + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
function Zs(t, e, r, n) {
  return new yw(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? ZU(e.charCategorizer(e.selection.main.head)) : void 0
  }, r, n);
}
function Cc(t, e) {
  return t.slice(Tt(t, e, !1), e);
}
function Ac(t, e) {
  return t.slice(e, Tt(t, e));
}
function ZU(t) {
  return (e, r, n) => !n[0].length || (t(Cc(n.input, n.index)) != nt.Word || t(Ac(n.input, n.index)) != nt.Word) && (t(Ac(n.input, n.index + n[0].length)) != nt.Word || t(Cc(n.input, n.index + n[0].length)) != nt.Word);
}
class eH extends vw {
  nextMatch(e, r, n) {
    let i = Zs(this.spec, e, n, e.doc.length).next();
    return i.done && (i = Zs(this.spec, e, 0, r).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, r, n) {
    for (let i = 1; ; i++) {
      let s = Math.max(
        r,
        n - i * 1e4
        /* FindPrev.ChunkSize */
      ), o = Zs(this.spec, e, s, n), l = null;
      for (; !o.next().done; )
        l = o.value;
      if (l && (s == r || l.from > s + 10))
        return l;
      if (s == r)
        return null;
    }
  }
  prevMatch(e, r, n) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (r, n) => n == "$" ? "$" : n == "&" ? e.match[0] : n != "0" && +n < e.match.length ? e.match[n] : r);
  }
  matchAll(e, r) {
    let n = Zs(this.spec, e, 0, e.doc.length), i = [];
    for (; !n.next().done; ) {
      if (i.length >= r)
        return null;
      i.push(n.value);
    }
    return i;
  }
  highlight(e, r, n, i) {
    let s = Zs(this.spec, e, Math.max(
      0,
      r - 250
      /* RegExp.HighlightMargin */
    ), Math.min(n + 250, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
const nl = /* @__PURE__ */ Se.define(), Fg = /* @__PURE__ */ Se.define(), Ti = /* @__PURE__ */ Nt.define({
  create(t) {
    return new jp(Ef(t).create(), null);
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(nl) ? t = new jp(r.value.create(), t.panel) : r.is(Fg) && (t = new jp(t.query, r.value ? Pg : null));
    return t;
  },
  provide: (t) => el.from(t, (e) => e.panel)
});
class jp {
  constructor(e, r) {
    this.query = e, this.panel = r;
  }
}
const tH = /* @__PURE__ */ xe.mark({ class: "cm-searchMatch" }), rH = /* @__PURE__ */ xe.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), nH = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(Ti));
  }
  update(t) {
    let e = t.state.field(Ti);
    (e != t.startState.field(Ti) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return xe.none;
    let { view: r } = this, n = new Mi();
    for (let i = 0, s = r.visibleRanges, o = s.length; i < o; i++) {
      let { from: l, to: u } = s[i];
      for (; i < o - 1 && u > s[i + 1].from - 2 * 250; )
        u = s[++i].to;
      t.highlight(r.state, l, u, (h, p) => {
        let d = r.state.selection.ranges.some((m) => m.from == h && m.to == p);
        n.add(h, p, d ? rH : tH);
      });
    }
    return n.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function Bl(t) {
  return (e) => {
    let r = e.state.field(Ti, !1);
    return r && r.query.spec.valid ? t(e, r) : Ew(e);
  };
}
const Ec = /* @__PURE__ */ Bl((t, { query: e }) => {
  let { to: r } = t.state.selection.main, n = e.nextMatch(t.state, r, r);
  if (!n)
    return !1;
  let i = K.single(n.from, n.to), s = t.state.facet(Uo);
  return t.dispatch({
    selection: i,
    effects: [Bg(t, n), s.scrollToMatch(i.main, t)],
    userEvent: "select.search"
  }), Aw(t), !0;
}), wc = /* @__PURE__ */ Bl((t, { query: e }) => {
  let { state: r } = t, { from: n } = r.selection.main, i = e.prevMatch(r, n, n);
  if (!i)
    return !1;
  let s = K.single(i.from, i.to), o = t.state.facet(Uo);
  return t.dispatch({
    selection: s,
    effects: [Bg(t, i), o.scrollToMatch(s.main, t)],
    userEvent: "select.search"
  }), Aw(t), !0;
}), iH = /* @__PURE__ */ Bl((t, { query: e }) => {
  let r = e.matchAll(t.state, 1e3);
  return !r || !r.length ? !1 : (t.dispatch({
    selection: K.create(r.map((n) => K.range(n.from, n.to))),
    userEvent: "select.search.matches"
  }), !0);
}), sH = ({ state: t, dispatch: e }) => {
  let r = t.selection;
  if (r.ranges.length > 1 || r.main.empty)
    return !1;
  let { from: n, to: i } = r.main, s = [], o = 0;
  for (let l = new wo(t.doc, t.sliceDoc(n, i)); !l.next().done; ) {
    if (s.length > 1e3)
      return !1;
    l.value.from == n && (o = s.length), s.push(K.range(l.value.from, l.value.to));
  }
  return e(t.update({
    selection: K.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, fD = /* @__PURE__ */ Bl((t, { query: e }) => {
  let { state: r } = t, { from: n, to: i } = r.selection.main;
  if (r.readOnly)
    return !1;
  let s = e.nextMatch(r, n, n);
  if (!s)
    return !1;
  let o = [], l, u, h = [];
  if (s.from == n && s.to == i && (u = r.toText(e.getReplacement(s)), o.push({ from: s.from, to: s.to, insert: u }), s = e.nextMatch(r, s.from, s.to), h.push(ce.announce.of(r.phrase("replaced match on line $", r.doc.lineAt(n).number) + "."))), s) {
    let p = o.length == 0 || o[0].from >= s.to ? 0 : s.to - s.from - u.length;
    l = K.single(s.from - p, s.to - p), h.push(Bg(t, s)), h.push(r.facet(Uo).scrollToMatch(l.main, t));
  }
  return t.dispatch({
    changes: o,
    selection: l,
    effects: h,
    userEvent: "input.replace"
  }), !0;
}), oH = /* @__PURE__ */ Bl((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let r = e.matchAll(t.state, 1e9).map((i) => {
    let { from: s, to: o } = i;
    return { from: s, to: o, insert: e.getReplacement(i) };
  });
  if (!r.length)
    return !1;
  let n = t.state.phrase("replaced $ matches", r.length) + ".";
  return t.dispatch({
    changes: r,
    effects: ce.announce.of(n),
    userEvent: "input.replace.all"
  }), !0;
});
function Pg(t) {
  return t.state.facet(Uo).createPanel(t);
}
function Ef(t, e) {
  var r, n, i, s, o;
  let l = t.selection.main, u = l.empty || l.to > l.from + 100 ? "" : t.sliceDoc(l.from, l.to);
  if (e && !u)
    return e;
  let h = t.facet(Uo);
  return new bw({
    search: ((r = e == null ? void 0 : e.literal) !== null && r !== void 0 ? r : h.literal) ? u : u.replace(/\n/g, "\\n"),
    caseSensitive: (n = e == null ? void 0 : e.caseSensitive) !== null && n !== void 0 ? n : h.caseSensitive,
    literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : h.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : h.regexp,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : h.wholeWord
  });
}
function Cw(t) {
  let e = Za(t, Pg);
  return e && e.dom.querySelector("[main-field]");
}
function Aw(t) {
  let e = Cw(t);
  e && e == t.root.activeElement && e.select();
}
const Ew = (t) => {
  let e = t.state.field(Ti, !1);
  if (e && e.panel) {
    let r = Cw(t);
    if (r && r != t.root.activeElement) {
      let n = Ef(t.state, e.query.spec);
      n.valid && t.dispatch({ effects: nl.of(n) }), r.focus(), r.select();
    }
  } else
    t.dispatch({ effects: [
      Fg.of(!0),
      e ? nl.of(Ef(t.state, e.query.spec)) : Se.appendConfig.of(cH)
    ] });
  return !0;
}, ww = (t) => {
  let e = t.state.field(Ti, !1);
  if (!e || !e.panel)
    return !1;
  let r = Za(t, Pg);
  return r && r.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: Fg.of(!1) }), !0;
}, aH = [
  { key: "Mod-f", run: Ew, scope: "editor search-panel" },
  { key: "F3", run: Ec, shift: wc, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Ec, shift: wc, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: ww, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: sH },
  { key: "Mod-Alt-g", run: RU },
  { key: "Mod-d", run: XU, preventDefault: !0 }
];
class lH {
  constructor(e) {
    this.view = e;
    let r = this.query = e.state.field(Ti).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Ye("input", {
      value: r.search,
      placeholder: lr(e, "Find"),
      "aria-label": lr(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Ye("input", {
      value: r.replace,
      placeholder: lr(e, "Replace"),
      "aria-label": lr(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Ye("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: r.caseSensitive,
      onchange: this.commit
    }), this.reField = Ye("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: r.regexp,
      onchange: this.commit
    }), this.wordField = Ye("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: r.wholeWord,
      onchange: this.commit
    });
    function n(i, s, o) {
      return Ye("button", { class: "cm-button", name: i, onclick: s, type: "button" }, o);
    }
    this.dom = Ye("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      n("next", () => Ec(e), [lr(e, "next")]),
      n("prev", () => wc(e), [lr(e, "previous")]),
      n("select", () => iH(e), [lr(e, "all")]),
      Ye("label", null, [this.caseField, lr(e, "match case")]),
      Ye("label", null, [this.reField, lr(e, "regexp")]),
      Ye("label", null, [this.wordField, lr(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Ye("br"),
        this.replaceField,
        n("replace", () => fD(e), [lr(e, "replace")]),
        n("replaceAll", () => oH(e), [lr(e, "replace all")])
      ],
      Ye("button", {
        name: "close",
        onclick: () => ww(e),
        "aria-label": lr(e, "close"),
        type: "button"
      }, [""])
    ]);
  }
  commit() {
    let e = new bw({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: nl.of(e) }));
  }
  keydown(e) {
    yj(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? wc : Ec)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), fD(this.view));
  }
  update(e) {
    for (let r of e.transactions)
      for (let n of r.effects)
        n.is(nl) && !n.value.eq(this.query) && this.setQuery(n.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Uo).top;
  }
}
function lr(t, e) {
  return t.state.phrase(e);
}
const Cu = 30, Au = /[\s\.,:;?!]/;
function Bg(t, { from: e, to: r }) {
  let n = t.state.doc.lineAt(e), i = t.state.doc.lineAt(r).to, s = Math.max(n.from, e - Cu), o = Math.min(i, r + Cu), l = t.state.sliceDoc(s, o);
  if (s != n.from) {
    for (let u = 0; u < Cu; u++)
      if (!Au.test(l[u + 1]) && Au.test(l[u])) {
        l = l.slice(u);
        break;
      }
  }
  if (o != i) {
    for (let u = l.length - 1; u > l.length - Cu; u--)
      if (!Au.test(l[u - 1]) && Au.test(l[u])) {
        l = l.slice(0, u);
        break;
      }
  }
  return ce.announce.of(`${t.state.phrase("current match")}. ${l} ${t.state.phrase("on line")} ${n.number}.`);
}
const uH = /* @__PURE__ */ ce.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), cH = [
  Ti,
  /* @__PURE__ */ jo.low(nH),
  uH
];
class Sw {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(e, r, n) {
    this.state = e, this.pos = r, this.explicit = n, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let r = Ut(this.state).resolveInner(this.pos, -1);
    for (; r && e.indexOf(r.name) < 0; )
      r = r.parent;
    return r ? {
      from: r.from,
      to: this.pos,
      text: this.state.sliceDoc(r.from, this.pos),
      type: r.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let r = this.state.doc.lineAt(this.pos), n = Math.max(r.from, this.pos - 250), i = r.text.slice(n - r.from, this.pos - r.from), s = i.search(Tw(e, !1));
    return s < 0 ? null : { from: n + s, to: this.pos, text: i.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, r) {
    e == "abort" && this.abortListeners && this.abortListeners.push(r);
  }
}
function mD(t) {
  let e = Object.keys(t).join(""), r = /\w/.test(e);
  return r && (e = e.replace(/\w/g, "")), `[${r ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function hH(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of t) {
    e[i[0]] = !0;
    for (let s = 1; s < i.length; s++)
      r[i[s]] = !0;
  }
  let n = mD(e) + mD(r) + "*$";
  return [new RegExp("^" + n), new RegExp(n)];
}
function pH(t) {
  let e = t.map((i) => typeof i == "string" ? { label: i } : i), [r, n] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : hH(e);
  return (i) => {
    let s = i.matchBefore(n);
    return s || i.explicit ? { from: s ? s.from : i.pos, options: e, validFor: r } : null;
  };
}
class gD {
  constructor(e, r, n, i) {
    this.completion = e, this.source = r, this.match = n, this.score = i;
  }
}
function ki(t) {
  return t.selection.main.from;
}
function Tw(t, e) {
  var r;
  let { source: n } = t, i = e && n[0] != "^", s = n[n.length - 1] != "$";
  return !i && !s ? t : new RegExp(`${i ? "^" : ""}(?:${n})${s ? "$" : ""}`, (r = t.flags) !== null && r !== void 0 ? r : t.ignoreCase ? "i" : "");
}
const dH = /* @__PURE__ */ Nn.define();
function fH(t, e, r, n) {
  let { main: i } = t.selection, s = r - i.from, o = n - i.from;
  return Object.assign(Object.assign({}, t.changeByRange((l) => l != i && r != n && t.sliceDoc(l.from + s, l.from + o) != t.sliceDoc(r, n) ? { range: l } : {
    changes: { from: l.from + s, to: n == i.from ? l.to : l.from + o, insert: e },
    range: K.cursor(l.from + s + e.length)
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const yD = /* @__PURE__ */ new WeakMap();
function mH(t) {
  if (!Array.isArray(t))
    return t;
  let e = yD.get(t);
  return e || yD.set(t, e = pH(t)), e;
}
const Sc = /* @__PURE__ */ Se.define(), il = /* @__PURE__ */ Se.define();
class gH {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let r = 0; r < e.length; ) {
      let n = Ct(e, r), i = Fr(n);
      this.chars.push(n);
      let s = e.slice(r, r + i), o = s.toUpperCase();
      this.folded.push(Ct(o == s ? s.toLowerCase() : o, 0)), r += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, r) {
    return this.score = e, this.matched = r, !0;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return !1;
    let { chars: r, folded: n, any: i, precise: s, byWord: o } = this;
    if (r.length == 1) {
      let x = Ct(e, 0), E = Fr(x), k = E == e.length ? 0 : -100;
      if (x != r[0])
        if (x == n[0])
          k += -200;
        else
          return !1;
      return this.ret(k, [0, E]);
    }
    let l = e.indexOf(this.pattern);
    if (l == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let u = r.length, h = 0;
    if (l < 0) {
      for (let x = 0, E = Math.min(e.length, 200); x < E && h < u; ) {
        let k = Ct(e, x);
        (k == r[h] || k == n[h]) && (i[h++] = x), x += Fr(k);
      }
      if (h < u)
        return !1;
    }
    let p = 0, d = 0, m = !1, y = 0, D = -1, b = -1, C = /[a-z]/.test(e), A = !0;
    for (let x = 0, E = Math.min(e.length, 200), k = 0; x < E && d < u; ) {
      let w = Ct(e, x);
      l < 0 && (p < u && w == r[p] && (s[p++] = x), y < u && (w == r[y] || w == n[y] ? (y == 0 && (D = x), b = x + 1, y++) : y = 0));
      let T, P = w < 255 ? w >= 48 && w <= 57 || w >= 97 && w <= 122 ? 2 : w >= 65 && w <= 90 ? 1 : 0 : (T = ag(w)) != T.toLowerCase() ? 1 : T != T.toUpperCase() ? 2 : 0;
      (!x || P == 1 && C || k == 0 && P != 0) && (r[d] == w || n[d] == w && (m = !0) ? o[d++] = x : o.length && (A = !1)), k = P, x += Fr(w);
    }
    return d == u && o[0] == 0 && A ? this.result(-100 + (m ? -200 : 0), o, e) : y == u && D == 0 ? this.ret(-200 - e.length + (b == e.length ? 0 : -100), [0, b]) : l > -1 ? this.ret(-700 - e.length, [l, l + this.pattern.length]) : y == u ? this.ret(-900 - e.length, [D, b]) : d == u ? this.result(-100 + (m ? -200 : 0) + -700 + (A ? 0 : -1100), o, e) : r.length == 2 ? !1 : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, r, n) {
    let i = [], s = 0;
    for (let o of r) {
      let l = o + (this.astral ? Fr(Ct(n, o)) : 1);
      s && i[s - 1] == o ? i[s - 1] = l : (i[s++] = o, i[s++] = l);
    }
    return this.ret(e - n.length, i);
  }
}
const St = /* @__PURE__ */ ge.define({
  combine(t) {
    return Mn(t, {
      activateOnTyping: !0,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: yH,
      compareCompletions: (e, r) => e.label.localeCompare(r.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, r) => e && r,
      closeOnBlur: (e, r) => e && r,
      icons: (e, r) => e && r,
      tooltipClass: (e, r) => (n) => DD(e(n), r(n)),
      optionClass: (e, r) => (n) => DD(e(n), r(n)),
      addToOptions: (e, r) => e.concat(r)
    });
  }
});
function DD(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function yH(t, e, r, n, i, s) {
  let o = t.textDirection == tt.RTL, l = o, u = !1, h = "top", p, d, m = e.left - i.left, y = i.right - e.right, D = n.right - n.left, b = n.bottom - n.top;
  if (l && m < Math.min(D, y) ? l = !1 : !l && y < Math.min(D, m) && (l = !0), D <= (l ? m : y))
    p = Math.max(i.top, Math.min(r.top, i.bottom - b)) - e.top, d = Math.min(400, l ? m : y);
  else {
    u = !0, d = Math.min(
      400,
      (o ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let x = i.bottom - e.bottom;
    x >= b || x > e.top ? p = r.bottom - e.top : (h = "bottom", p = e.bottom - r.top);
  }
  let C = (e.bottom - e.top) / s.offsetHeight, A = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${h}: ${p / C}px; max-width: ${d / A}px`,
    class: "cm-completionInfo-" + (u ? o ? "left-narrow" : "right-narrow" : l ? "left" : "right")
  };
}
function DH(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(r) {
      let n = document.createElement("div");
      return n.classList.add("cm-completionIcon"), r.type && n.classList.add(...r.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), n.setAttribute("aria-hidden", "true"), n;
    },
    position: 20
  }), e.push({
    render(r, n, i, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let l = r.displayLabel || r.label, u = 0;
      for (let h = 0; h < s.length; ) {
        let p = s[h++], d = s[h++];
        p > u && o.appendChild(document.createTextNode(l.slice(u, p)));
        let m = o.appendChild(document.createElement("span"));
        m.appendChild(document.createTextNode(l.slice(p, d))), m.className = "cm-completionMatchedText", u = d;
      }
      return u < l.length && o.appendChild(document.createTextNode(l.slice(u))), o;
    },
    position: 50
  }, {
    render(r) {
      if (!r.detail)
        return null;
      let n = document.createElement("span");
      return n.className = "cm-completionDetail", n.textContent = r.detail, n;
    },
    position: 80
  }), e.sort((r, n) => r.position - n.position).map((r) => r.render);
}
function qp(t, e, r) {
  if (t <= r)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let i = Math.floor(e / r);
    return { from: i * r, to: (i + 1) * r };
  }
  let n = Math.floor((t - e) / r);
  return { from: t - (n + 1) * r, to: t - n * r };
}
class xH {
  constructor(e, r, n) {
    this.view = e, this.stateField = r, this.applyCompletion = n, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (u) => this.placeInfo(u),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(r), { options: s, selected: o } = i.open, l = e.state.facet(St);
    this.optionContent = DH(l), this.optionClass = l.optionClass, this.tooltipClass = l.tooltipClass, this.range = qp(s.length, o, l.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (u) => {
      let { options: h } = e.state.field(r).open;
      for (let p = u.target, d; p && p != this.dom; p = p.parentNode)
        if (p.nodeName == "LI" && (d = /-(\d+)$/.exec(p.id)) && +d[1] < h.length) {
          this.applyCompletion(e, h[+d[1]]), u.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (u) => {
      let h = e.state.field(this.stateField, !1);
      h && h.tooltip && e.state.facet(St).closeOnBlur && u.relatedTarget != e.contentDOM && e.dispatch({ effects: il.of(null) });
    }), this.showOptions(s, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, r) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, r, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var r;
    let n = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), n != i) {
      let { options: s, selected: o, disabled: l } = n.open;
      (!i.open || i.open.options != s) && (this.range = qp(s.length, o, e.state.facet(St).maxRenderedOptions), this.showOptions(s, n.id)), this.updateSel(), l != ((r = i.open) === null || r === void 0 ? void 0 : r.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!l);
    }
  }
  updateTooltipClass(e) {
    let r = this.tooltipClass(e);
    if (r != this.currentClass) {
      for (let n of this.currentClass.split(" "))
        n && this.dom.classList.remove(n);
      for (let n of r.split(" "))
        n && this.dom.classList.add(n);
      this.currentClass = r;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), r = e.open;
    if ((r.selected > -1 && r.selected < this.range.from || r.selected >= this.range.to) && (this.range = qp(r.options.length, r.selected, this.view.state.facet(St).maxRenderedOptions), this.showOptions(r.options, e.id)), this.updateSelectedOption(r.selected)) {
      this.destroyInfo();
      let { completion: n } = r.options[r.selected], { info: i } = n;
      if (!i)
        return;
      let s = typeof i == "string" ? document.createTextNode(i) : i(n);
      if (!s)
        return;
      "then" in s ? s.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, n);
      }).catch((o) => Br(this.view.state, o, "completion info")) : this.addInfoPane(s, n);
    }
  }
  addInfoPane(e, r) {
    this.destroyInfo();
    let n = this.info = document.createElement("div");
    if (n.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      n.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: s } = e;
      n.appendChild(i), this.infoDestroy = s || null;
    }
    this.dom.appendChild(n), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let r = null;
    for (let n = this.list.firstChild, i = this.range.from; n; n = n.nextSibling, i++)
      n.nodeName != "LI" || !n.id ? i-- : i == e ? n.hasAttribute("aria-selected") || (n.setAttribute("aria-selected", "true"), r = n) : n.hasAttribute("aria-selected") && n.removeAttribute("aria-selected");
    return r && vH(this.list, r), r;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let r = this.dom.getBoundingClientRect(), n = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };
    }
    return i.top > Math.min(s.bottom, r.bottom) - 10 || i.bottom < Math.max(s.top, r.top) + 10 ? null : this.view.state.facet(St).positionInfo(this.view, r, i, n, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, r, n) {
    const i = document.createElement("ul");
    i.id = r, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let s = null;
    for (let o = n.from; o < n.to; o++) {
      let { completion: l, match: u } = e[o], { section: h } = l;
      if (h) {
        let m = typeof h == "string" ? h : h.name;
        if (m != s && (o > n.from || n.from == 0))
          if (s = m, typeof h != "string" && h.header)
            i.appendChild(h.header(h));
          else {
            let y = i.appendChild(document.createElement("completion-section"));
            y.textContent = m;
          }
      }
      const p = i.appendChild(document.createElement("li"));
      p.id = r + "-" + o, p.setAttribute("role", "option");
      let d = this.optionClass(l);
      d && (p.className = d);
      for (let m of this.optionContent) {
        let y = m(l, this.view.state, this.view, u);
        y && p.appendChild(y);
      }
    }
    return n.from && i.classList.add("cm-completionListIncompleteTop"), n.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function bH(t, e) {
  return (r) => new xH(r, t, e);
}
function vH(t, e) {
  let r = t.getBoundingClientRect(), n = e.getBoundingClientRect(), i = r.height / t.offsetHeight;
  n.top < r.top ? t.scrollTop -= (r.top - n.top) / i : n.bottom > r.bottom && (t.scrollTop += (n.bottom - r.bottom) / i);
}
function xD(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function CH(t, e) {
  let r = [], n = null, i = (u) => {
    r.push(u);
    let { section: h } = u.completion;
    if (h) {
      n || (n = []);
      let p = typeof h == "string" ? h : h.name;
      n.some((d) => d.name == p) || n.push(typeof h == "string" ? { name: p } : h);
    }
  };
  for (let u of t)
    if (u.hasResult()) {
      let h = u.result.getMatch;
      if (u.result.filter === !1)
        for (let p of u.result.options)
          i(new gD(p, u.source, h ? h(p) : [], 1e9 - r.length));
      else {
        let p = new gH(e.sliceDoc(u.from, u.to));
        for (let d of u.result.options)
          if (p.match(d.label)) {
            let m = d.displayLabel ? h ? h(d, p.matched) : [] : p.matched;
            i(new gD(d, u.source, m, p.score + (d.boost || 0)));
          }
      }
    }
  if (n) {
    let u = /* @__PURE__ */ Object.create(null), h = 0, p = (d, m) => {
      var y, D;
      return ((y = d.rank) !== null && y !== void 0 ? y : 1e9) - ((D = m.rank) !== null && D !== void 0 ? D : 1e9) || (d.name < m.name ? -1 : 1);
    };
    for (let d of n.sort(p))
      h -= 1e5, u[d.name] = h;
    for (let d of r) {
      let { section: m } = d.completion;
      m && (d.score += u[typeof m == "string" ? m : m.name]);
    }
  }
  let s = [], o = null, l = e.facet(St).compareCompletions;
  for (let u of r.sort((h, p) => p.score - h.score || l(h.completion, p.completion))) {
    let h = u.completion;
    !o || o.label != h.label || o.detail != h.detail || o.type != null && h.type != null && o.type != h.type || o.apply != h.apply || o.boost != h.boost ? s.push(u) : xD(u.completion) > xD(o) && (s[s.length - 1] = u), o = u.completion;
  }
  return s;
}
class so {
  constructor(e, r, n, i, s, o) {
    this.options = e, this.attrs = r, this.tooltip = n, this.timestamp = i, this.selected = s, this.disabled = o;
  }
  setSelected(e, r) {
    return e == this.selected || e >= this.options.length ? this : new so(this.options, bD(r, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, r, n, i, s) {
    let o = CH(e, r);
    if (!o.length)
      return i && e.some(
        (u) => u.state == 1
        /* State.Pending */
      ) ? new so(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, !0) : null;
    let l = r.facet(St).selectOnOpen ? 0 : -1;
    if (i && i.selected != l && i.selected != -1) {
      let u = i.options[i.selected].completion;
      for (let h = 0; h < o.length; h++)
        if (o[h].completion == u) {
          l = h;
          break;
        }
    }
    return new so(o, bD(n, l), {
      pos: e.reduce((u, h) => h.hasResult() ? Math.min(u, h.from) : u, 1e8),
      create: TH,
      above: s.aboveCursor
    }, i ? i.timestamp : Date.now(), l, !1);
  }
  map(e) {
    return new so(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class Tc {
  constructor(e, r, n) {
    this.active = e, this.id = r, this.open = n;
  }
  static start() {
    return new Tc(wH, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: r } = e, n = r.facet(St), s = (n.override || r.languageDataAt("autocomplete", ki(r)).map(mH)).map((l) => (this.active.find((h) => h.source == l) || new tr(
      l,
      this.active.some(
        (h) => h.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, n));
    s.length == this.active.length && s.every((l, u) => l == this.active[u]) && (s = this.active);
    let o = this.open;
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !AH(s, this.active) ? o = so.build(s, r, this.id, o, n) : o && o.disabled && !s.some(
      (l) => l.state == 1
      /* State.Pending */
    ) && (o = null), !o && s.every(
      (l) => l.state != 1
      /* State.Pending */
    ) && s.some((l) => l.hasResult()) && (s = s.map((l) => l.hasResult() ? new tr(
      l.source,
      0
      /* State.Inactive */
    ) : l));
    for (let l of e.effects)
      l.is(Fw) && (o = o && o.setSelected(l.value, this.id));
    return s == this.active && o == this.open ? this : new Tc(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : EH;
  }
}
function AH(t, e) {
  if (t == e)
    return !0;
  for (let r = 0, n = 0; ; ) {
    for (; r < t.length && !t[r].hasResult; )
      r++;
    for (; n < e.length && !e[n].hasResult; )
      n++;
    let i = r == t.length, s = n == e.length;
    if (i || s)
      return i == s;
    if (t[r++].result != e[n++].result)
      return !1;
  }
}
const EH = {
  "aria-autocomplete": "list"
};
function bD(t, e) {
  let r = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (r["aria-activedescendant"] = t + "-" + e), r;
}
const wH = [];
function wf(t) {
  return t.isUserEvent("input.type") ? "input" : t.isUserEvent("delete.backward") ? "delete" : null;
}
class tr {
  constructor(e, r, n = -1) {
    this.source = e, this.state = r, this.explicitPos = n;
  }
  hasResult() {
    return !1;
  }
  update(e, r) {
    let n = wf(e), i = this;
    n ? i = i.handleUserEvent(e, n, r) : e.docChanged ? i = i.handleChange(e) : e.selection && i.state != 0 && (i = new tr(
      i.source,
      0
      /* State.Inactive */
    ));
    for (let s of e.effects)
      if (s.is(Sc))
        i = new tr(i.source, 1, s.value ? ki(e.state) : -1);
      else if (s.is(il))
        i = new tr(
          i.source,
          0
          /* State.Inactive */
        );
      else if (s.is(kw))
        for (let o of s.value)
          o.source == i.source && (i = o);
    return i;
  }
  handleUserEvent(e, r, n) {
    return r == "delete" || !n.activateOnTyping ? this.map(e.changes) : new tr(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(ki(e.startState)) ? new tr(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new tr(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class po extends tr {
  constructor(e, r, n, i, s) {
    super(e, 2, r), this.result = n, this.from = i, this.to = s;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, r, n) {
    var i;
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), l = ki(e.state);
    if ((this.explicitPos < 0 ? l <= s : l < this.from) || l > o || r == "delete" && ki(e.startState) == this.from)
      return new tr(
        this.source,
        r == "input" && n.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let u = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), h;
    return SH(this.result.validFor, e.state, s, o) ? new po(this.source, u, this.result, s, o) : this.result.update && (h = this.result.update(this.result, s, o, new Sw(e.state, l, u >= 0))) ? new po(this.source, u, h, h.from, (i = h.to) !== null && i !== void 0 ? i : ki(e.state)) : new tr(this.source, 1, u);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new tr(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new po(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function SH(t, e, r, n) {
  if (!t)
    return !1;
  let i = e.sliceDoc(r, n);
  return typeof t == "function" ? t(i, r, n, e) : Tw(t, !0).test(i);
}
const kw = /* @__PURE__ */ Se.define({
  map(t, e) {
    return t.map((r) => r.map(e));
  }
}), Fw = /* @__PURE__ */ Se.define(), hr = /* @__PURE__ */ Nt.define({
  create() {
    return Tc.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    Dg.from(t, (e) => e.tooltip),
    ce.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function Pw(t, e) {
  const r = e.completion.apply || e.completion.label;
  let n = t.state.field(hr).active.find((i) => i.source == e.source);
  return n instanceof po ? (typeof r == "string" ? t.dispatch(Object.assign(Object.assign({}, fH(t.state, r, n.from, n.to)), { annotations: dH.of(e.completion) })) : r(t, e.completion, n.from, n.to), !0) : !1;
}
const TH = /* @__PURE__ */ bH(hr, Pw);
function Eu(t, e = "option") {
  return (r) => {
    let n = r.state.field(hr, !1);
    if (!n || !n.open || n.open.disabled || Date.now() - n.open.timestamp < r.state.facet(St).interactionDelay)
      return !1;
    let i = 1, s;
    e == "page" && (s = mE(r, n.open.tooltip)) && (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = n.open.options, l = n.open.selected > -1 ? n.open.selected + i * (t ? 1 : -1) : t ? 0 : o - 1;
    return l < 0 ? l = e == "page" ? 0 : o - 1 : l >= o && (l = e == "page" ? o - 1 : 0), r.dispatch({ effects: Fw.of(l) }), !0;
  };
}
const kH = (t) => {
  let e = t.state.field(hr, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(St).interactionDelay ? !1 : Pw(t, e.open.options[e.open.selected]);
}, FH = (t) => t.state.field(hr, !1) ? (t.dispatch({ effects: Sc.of(!0) }), !0) : !1, PH = (t) => {
  let e = t.state.field(hr, !1);
  return !e || !e.active.some(
    (r) => r.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: il.of(null) }), !0);
};
class BH {
  constructor(e, r) {
    this.active = e, this.context = r, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const IH = 50, NH = 1e3, MH = /* @__PURE__ */ ct.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(hr).active)
      e.state == 1 && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(hr);
    if (!t.selectionSet && !t.docChanged && t.startState.field(hr) == e)
      return;
    let r = t.transactions.some((i) => (i.selection || i.docChanged) && !wf(i));
    for (let i = 0; i < this.running.length; i++) {
      let s = this.running[i];
      if (r || s.updates.length + t.transactions.length > IH && Date.now() - s.time > NH) {
        for (let o of s.context.abortListeners)
          try {
            o();
          } catch (l) {
            Br(this.view.state, l);
          }
        s.context.abortListeners = null, this.running.splice(i--, 1);
      } else
        s.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((i) => i.effects.some((s) => s.is(Sc))) && (this.pendingStart = !0);
    let n = this.pendingStart ? 50 : t.state.facet(St).activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((i) => i.state == 1 && !this.running.some((s) => s.active.source == i.source)) ? setTimeout(() => this.startUpdate(), n) : -1, this.composing != 0)
      for (let i of t.transactions)
        wf(i) == "input" ? this.composing = 2 : this.composing == 2 && i.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(hr);
    for (let r of e.active)
      r.state == 1 && !this.running.some((n) => n.active.source == r.source) && this.startQuery(r);
  }
  startQuery(t) {
    let { state: e } = this.view, r = ki(e), n = new Sw(e, r, t.explicitPos == r), i = new BH(t, n);
    this.running.push(i), Promise.resolve(t.source(n)).then((s) => {
      i.context.aborted || (i.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: il.of(null) }), Br(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(St).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], r = this.view.state.facet(St);
    for (let n = 0; n < this.running.length; n++) {
      let i = this.running[n];
      if (i.done === void 0)
        continue;
      if (this.running.splice(n--, 1), i.done) {
        let o = new po(i.active.source, i.active.explicitPos, i.done, i.done.from, (t = i.done.to) !== null && t !== void 0 ? t : ki(i.updates.length ? i.updates[0].startState : this.view.state));
        for (let l of i.updates)
          o = o.update(l, r);
        if (o.hasResult()) {
          e.push(o);
          continue;
        }
      }
      let s = this.view.state.field(hr).active.find((o) => o.source == i.active.source);
      if (s && s.state == 1)
        if (i.done == null) {
          let o = new tr(
            i.active.source,
            0
            /* State.Inactive */
          );
          for (let l of i.updates)
            o = o.update(l, r);
          o.state != 1 && e.push(o);
        } else
          this.startQuery(s);
    }
    e.length && this.view.dispatch({ effects: kw.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(hr, !1);
      if (e && e.tooltip && this.view.state.facet(St).closeOnBlur) {
        let r = e.open && mE(this.view, e.open.tooltip);
        (!r || !r.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: il.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Sc.of(!1) }), 20), this.composing = 0;
    }
  }
}), OH = /* @__PURE__ */ ce.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
}), sl = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, os = /* @__PURE__ */ Se.define({
  map(t, e) {
    let r = e.mapPos(t, -1, Kt.TrackAfter);
    return r ?? void 0;
  }
}), Ig = /* @__PURE__ */ new class extends xs {
}();
Ig.startSide = 1;
Ig.endSide = -1;
const Bw = /* @__PURE__ */ Nt.define({
  create() {
    return _e.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let r = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (n) => n >= r.from && n <= r.to });
    }
    for (let r of e.effects)
      r.is(os) && (t = t.update({ add: [Ig.range(r.value, r.value + 1)] }));
    return t;
  }
});
function LH() {
  return [$H, Bw];
}
const Wp = "()[]{}<>";
function Iw(t) {
  for (let e = 0; e < Wp.length; e += 2)
    if (Wp.charCodeAt(e) == t)
      return Wp.charAt(e + 1);
  return ag(t < 128 ? t : t + 1);
}
function Nw(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || sl;
}
const _H = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), $H = /* @__PURE__ */ ce.inputHandler.of((t, e, r, n) => {
  if ((_H ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let i = t.state.selection.main;
  if (n.length > 2 || n.length == 2 && Fr(Ct(n, 0)) == 1 || e != i.from || r != i.to)
    return !1;
  let s = qH(t.state, n);
  return s ? (t.dispatch(s), !0) : !1;
}), RH = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = Nw(t, t.selection.main.head).brackets || sl.brackets, i = null, s = t.changeByRange((o) => {
    if (o.empty) {
      let l = WH(t.doc, o.head);
      for (let u of n)
        if (u == l && Bh(t.doc, o.head) == Iw(Ct(u, 0)))
          return {
            changes: { from: o.head - u.length, to: o.head + u.length },
            range: K.cursor(o.head - u.length)
          };
    }
    return { range: i = o };
  });
  return i || e(t.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, jH = [
  { key: "Backspace", run: RH }
];
function qH(t, e) {
  let r = Nw(t, t.selection.main.head), n = r.brackets || sl.brackets;
  for (let i of n) {
    let s = Iw(Ct(i, 0));
    if (e == i)
      return s == i ? VH(t, i, n.indexOf(i + i + i) > -1, r) : UH(t, i, s, r.before || sl.before);
    if (e == s && Mw(t, t.selection.main.from))
      return HH(t, i, s);
  }
  return null;
}
function Mw(t, e) {
  let r = !1;
  return t.field(Bw).between(0, t.doc.length, (n) => {
    n == e && (r = !0);
  }), r;
}
function Bh(t, e) {
  let r = t.sliceString(e, e + 2);
  return r.slice(0, Fr(Ct(r, 0)));
}
function WH(t, e) {
  let r = t.sliceString(e - 2, e);
  return Fr(Ct(r, 0)) == r.length ? r : r.slice(1);
}
function UH(t, e, r, n) {
  let i = null, s = t.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: r, from: o.to }],
        effects: os.of(o.to + e.length),
        range: K.range(o.anchor + e.length, o.head + e.length)
      };
    let l = Bh(t.doc, o.head);
    return !l || /\s/.test(l) || n.indexOf(l) > -1 ? {
      changes: { insert: e + r, from: o.head },
      effects: os.of(o.head + e.length),
      range: K.cursor(o.head + e.length)
    } : { range: i = o };
  });
  return i ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function HH(t, e, r) {
  let n = null, i = t.changeByRange((s) => s.empty && Bh(t.doc, s.head) == r ? {
    changes: { from: s.head, to: s.head + r.length, insert: r },
    range: K.cursor(s.head + r.length)
  } : n = { range: s });
  return n ? null : t.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function VH(t, e, r, n) {
  let i = n.stringPrefixes || sl.stringPrefixes, s = null, o = t.changeByRange((l) => {
    if (!l.empty)
      return {
        changes: [{ insert: e, from: l.from }, { insert: e, from: l.to }],
        effects: os.of(l.to + e.length),
        range: K.range(l.anchor + e.length, l.head + e.length)
      };
    let u = l.head, h = Bh(t.doc, u), p;
    if (h == e) {
      if (vD(t, u))
        return {
          changes: { insert: e + e, from: u },
          effects: os.of(u + e.length),
          range: K.cursor(u + e.length)
        };
      if (Mw(t, u)) {
        let m = r && t.sliceDoc(u, u + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: u, to: u + m.length, insert: m },
          range: K.cursor(u + m.length)
        };
      }
    } else {
      if (r && t.sliceDoc(u - 2 * e.length, u) == e + e && (p = CD(t, u - 2 * e.length, i)) > -1 && vD(t, p))
        return {
          changes: { insert: e + e + e + e, from: u },
          effects: os.of(u + e.length),
          range: K.cursor(u + e.length)
        };
      if (t.charCategorizer(u)(h) != nt.Word && CD(t, u, i) > -1 && !zH(t, u, e, i))
        return {
          changes: { insert: e + e, from: u },
          effects: os.of(u + e.length),
          range: K.cursor(u + e.length)
        };
    }
    return { range: s = l };
  });
  return s ? null : t.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function vD(t, e) {
  let r = Ut(t).resolveInner(e + 1);
  return r.parent && r.from == e;
}
function zH(t, e, r, n) {
  let i = Ut(t).resolveInner(e, -1), s = n.reduce((o, l) => Math.max(o, l.length), 0);
  for (let o = 0; o < 5; o++) {
    let l = t.sliceDoc(i.from, Math.min(i.to, i.from + r.length + s)), u = l.indexOf(r);
    if (!u || u > -1 && n.indexOf(l.slice(0, u)) > -1) {
      let p = i.firstChild;
      for (; p && p.from == i.from && p.to - p.from > r.length + u; ) {
        if (t.sliceDoc(p.to - r.length, p.to) == r)
          return !1;
        p = p.firstChild;
      }
      return !0;
    }
    let h = i.to == e && i.parent;
    if (!h)
      break;
    i = h;
  }
  return !1;
}
function CD(t, e, r) {
  let n = t.charCategorizer(e);
  if (n(t.sliceDoc(e - 1, e)) != nt.Word)
    return e;
  for (let i of r) {
    let s = e - i.length;
    if (t.sliceDoc(s, e) == i && n(t.sliceDoc(s - 1, s)) != nt.Word)
      return s;
  }
  return -1;
}
function JH(t = {}) {
  return [
    hr,
    St.of(t),
    MH,
    KH,
    OH
  ];
}
const Ow = [
  { key: "Ctrl-Space", run: FH },
  { key: "Escape", run: PH },
  { key: "ArrowDown", run: /* @__PURE__ */ Eu(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Eu(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Eu(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Eu(!1, "page") },
  { key: "Enter", run: kH }
], KH = /* @__PURE__ */ jo.highest(/* @__PURE__ */ Ch.computeN([St], (t) => t.facet(St).defaultKeymap ? [Ow] : []));
class GH {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.diagnostic = n;
  }
}
class ts {
  constructor(e, r, n) {
    this.diagnostics = e, this.panel = r, this.selected = n;
  }
  static init(e, r, n) {
    let i = e, s = n.facet($w).markerFilter;
    s && (i = s(i, n));
    let o = xe.set(i.map((l) => l.from == l.to || l.from == l.to - 1 && n.doc.lineAt(l.from).to == l.from ? xe.widget({
      widget: new iV(l),
      diagnostic: l
    }).range(l.from) : xe.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + l.severity + (l.markClass ? " " + l.markClass : "") },
      diagnostic: l,
      inclusive: !0
    }).range(l.from, l.to)), !0);
    return new ts(o, r, So(o));
  }
}
function So(t, e = null, r = 0) {
  let n = null;
  return t.between(r, 1e9, (i, s, { spec: o }) => {
    if (!(e && o.diagnostic != e))
      return n = new GH(i, s, o.diagnostic), !1;
  }), n;
}
function XH(t, e) {
  let r = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((n) => n.is(Lw)) || t.changes.touchesRange(r.from, r.to));
}
function YH(t, e) {
  return t.field(gr, !1) ? e : e.concat(Se.appendConfig.of(aV));
}
const Lw = /* @__PURE__ */ Se.define(), Ng = /* @__PURE__ */ Se.define(), _w = /* @__PURE__ */ Se.define(), gr = /* @__PURE__ */ Nt.define({
  create() {
    return new ts(xe.none, null, null);
  },
  update(t, e) {
    if (e.docChanged) {
      let r = t.diagnostics.map(e.changes), n = null;
      if (t.selected) {
        let i = e.changes.mapPos(t.selected.from, 1);
        n = So(r, t.selected.diagnostic, i) || So(r, null, i);
      }
      t = new ts(r, t.panel, n);
    }
    for (let r of e.effects)
      r.is(Lw) ? t = ts.init(r.value, t.panel, e.state) : r.is(Ng) ? t = new ts(t.diagnostics, r.value ? Ih.open : null, t.selected) : r.is(_w) && (t = new ts(t.diagnostics, t.panel, r.value));
    return t;
  },
  provide: (t) => [
    el.from(t, (e) => e.panel),
    ce.decorations.from(t, (e) => e.diagnostics)
  ]
}), QH = /* @__PURE__ */ xe.mark({ class: "cm-lintRange cm-lintRange-active", inclusive: !0 });
function ZH(t, e, r) {
  let { diagnostics: n } = t.state.field(gr), i = [], s = 2e8, o = 0;
  n.between(e - (r < 0 ? 1 : 0), e + (r > 0 ? 1 : 0), (u, h, { spec: p }) => {
    e >= u && e <= h && (u == h || (e > u || r > 0) && (e < h || r < 0)) && (i.push(p.diagnostic), s = Math.min(u, s), o = Math.max(h, o));
  });
  let l = t.state.facet($w).tooltipFilter;
  return l && (i = l(i, t.state)), i.length ? {
    pos: s,
    end: o,
    above: t.state.doc.lineAt(s).to < o,
    create() {
      return { dom: eV(t, i) };
    }
  } : null;
}
function eV(t, e) {
  return Ye("ul", { class: "cm-tooltip-lint" }, e.map((r) => jw(t, r, !1)));
}
const tV = (t) => {
  let e = t.state.field(gr, !1);
  (!e || !e.panel) && t.dispatch({ effects: YH(t.state, [Ng.of(!0)]) });
  let r = Za(t, Ih.open);
  return r && r.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, AD = (t) => {
  let e = t.state.field(gr, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: Ng.of(!1) }), !0);
}, rV = (t) => {
  let e = t.state.field(gr, !1);
  if (!e)
    return !1;
  let r = t.state.selection.main, n = e.diagnostics.iter(r.to + 1);
  return !n.value && (n = e.diagnostics.iter(0), !n.value || n.from == r.from && n.to == r.to) ? !1 : (t.dispatch({ selection: { anchor: n.from, head: n.to }, scrollIntoView: !0 }), !0);
}, nV = [
  { key: "Mod-Shift-m", run: tV, preventDefault: !0 },
  { key: "F8", run: rV }
], $w = /* @__PURE__ */ ge.define({
  combine(t) {
    return Object.assign({ sources: t.map((e) => e.source).filter((e) => e != null) }, Mn(t.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (e, r) => e ? r ? (n) => e(n) || r(n) : e : r
    }));
  }
});
function Rw(t) {
  let e = [];
  if (t)
    e:
      for (let { name: r } of t) {
        for (let n = 0; n < r.length; n++) {
          let i = r[n];
          if (/[a-zA-Z]/.test(i) && !e.some((s) => s.toLowerCase() == i.toLowerCase())) {
            e.push(i);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function jw(t, e, r) {
  var n;
  let i = r ? Rw(e.actions) : [];
  return Ye("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Ye("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (n = e.actions) === null || n === void 0 ? void 0 : n.map((s, o) => {
    let l = !1, u = (m) => {
      if (m.preventDefault(), l)
        return;
      l = !0;
      let y = So(t.state.field(gr).diagnostics, e);
      y && s.apply(t, y.from, y.to);
    }, { name: h } = s, p = i[o] ? h.indexOf(i[o]) : -1, d = p < 0 ? h : [
      h.slice(0, p),
      Ye("u", h.slice(p, p + 1)),
      h.slice(p + 1)
    ];
    return Ye("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: u,
      onmousedown: u,
      "aria-label": ` Action: ${h}${p < 0 ? "" : ` (access key "${i[o]})"`}.`
    }, d);
  }), e.source && Ye("div", { class: "cm-diagnosticSource" }, e.source));
}
class iV extends ni {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return Ye("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class ED {
  constructor(e, r) {
    this.diagnostic = r, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = jw(e, r, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class Ih {
  constructor(e) {
    this.view = e, this.items = [];
    let r = (i) => {
      if (i.keyCode == 27)
        AD(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = Rw(s.actions);
        for (let l = 0; l < o.length; l++)
          if (o[l].toUpperCase().charCodeAt(0) == i.keyCode) {
            let u = So(this.view.state.field(gr).diagnostics, s);
            u && s.actions[l].apply(e, u.from, u.to);
          }
      } else
        return;
      i.preventDefault();
    }, n = (i) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(i.target) && this.moveSelection(s);
    };
    this.list = Ye("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: r,
      onclick: n
    }), this.dom = Ye("div", { class: "cm-panel-lint" }, this.list, Ye("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => AD(this.view)
    }, "")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(gr).selected;
    if (!e)
      return -1;
    for (let r = 0; r < this.items.length; r++)
      if (this.items[r].diagnostic == e.diagnostic)
        return r;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: r } = this.view.state.field(gr), n = 0, i = !1, s = null;
    for (e.between(0, this.view.state.doc.length, (o, l, { spec: u }) => {
      let h = -1, p;
      for (let d = n; d < this.items.length; d++)
        if (this.items[d].diagnostic == u.diagnostic) {
          h = d;
          break;
        }
      h < 0 ? (p = new ED(this.view, u.diagnostic), this.items.splice(n, 0, p), i = !0) : (p = this.items[h], h > n && (this.items.splice(n, h - n), i = !0)), r && p.diagnostic == r.diagnostic ? p.dom.hasAttribute("aria-selected") || (p.dom.setAttribute("aria-selected", "true"), s = p) : p.dom.hasAttribute("aria-selected") && p.dom.removeAttribute("aria-selected"), n++;
    }); n < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new ED(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: o, panel: l }) => {
        let u = l.height / this.list.offsetHeight;
        o.top < l.top ? this.list.scrollTop -= (l.top - o.top) / u : o.bottom > l.bottom && (this.list.scrollTop += (o.bottom - l.bottom) / u);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function r() {
      let n = e;
      e = n.nextSibling, n.remove();
    }
    for (let n of this.items)
      if (n.dom.parentNode == this.list) {
        for (; e != n.dom; )
          r();
        e = n.dom.nextSibling;
      } else
        this.list.insertBefore(n.dom, e);
    for (; e; )
      r();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let r = this.view.state.field(gr), n = So(r.diagnostics, this.items[e].diagnostic);
    n && this.view.dispatch({
      selection: { anchor: n.from, head: n.to },
      scrollIntoView: !0,
      effects: _w.of(n)
    });
  }
  static open(e) {
    return new Ih(e);
  }
}
function sV(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function wu(t) {
  return sV(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const oV = /* @__PURE__ */ ce.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ wu("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ wu("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ wu("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ wu("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), aV = [
  gr,
  /* @__PURE__ */ ce.decorations.compute([gr], (t) => {
    let { selected: e, panel: r } = t.field(gr);
    return !e || !r || e.from == e.to ? xe.none : xe.set([
      QH.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ sq(ZH, { hideOn: XH }),
  oV
];
var wD = function(e) {
  e === void 0 && (e = {});
  var {
    crosshairCursor: r = !1
  } = e, n = [];
  e.closeBracketsKeymap !== !1 && (n = n.concat(jH)), e.defaultKeymap !== !1 && (n = n.concat(LU)), e.searchKeymap !== !1 && (n = n.concat(aH)), e.historyKeymap !== !1 && (n = n.concat(VW)), e.foldKeymap !== !1 && (n = n.concat(sW)), e.completionKeymap !== !1 && (n = n.concat(Ow)), e.lintKeymap !== !1 && (n = n.concat(nV));
  var i = [];
  return e.lineNumbers !== !1 && i.push(fq()), e.highlightActiveLineGutter !== !1 && i.push(yq()), e.highlightSpecialChars !== !1 && i.push(Mj()), e.history !== !1 && i.push(LW()), e.foldGutter !== !1 && i.push(uW()), e.drawSelection !== !1 && i.push(Aj()), e.dropCursor !== !1 && i.push(kj()), e.allowMultipleSelections !== !1 && i.push(Ie.allowMultipleSelections.of(!0)), e.indentOnInput !== !1 && i.push(Gq()), e.syntaxHighlighting !== !1 && i.push(NE(dW, {
    fallback: !0
  })), e.bracketMatching !== !1 && i.push(bW()), e.closeBrackets !== !1 && i.push(LH()), e.autocompletion !== !1 && i.push(JH()), e.rectangularSelection !== !1 && i.push(Kj()), r !== !1 && i.push(Yj()), e.highlightActiveLine !== !1 && i.push(jj()), e.highlightSelectionMatches !== !1 && i.push(WU()), e.tabSize && typeof e.tabSize == "number" && i.push(Eh.of(" ".repeat(e.tabSize))), i.concat([Ch.of(n.flat())]).filter(Boolean);
};
const lV = "#e5c07b", SD = "#e06c75", uV = "#56b6c2", cV = "#ffffff", Vu = "#abb2bf", Sf = "#7d8799", hV = "#61afef", pV = "#98c379", TD = "#d19a66", dV = "#c678dd", fV = "#21252b", kD = "#2c313a", FD = "#282c34", Up = "#353a42", mV = "#3E4451", PD = "#528bff", gV = /* @__PURE__ */ ce.theme({
  "&": {
    color: Vu,
    backgroundColor: FD
  },
  ".cm-content": {
    caretColor: PD
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: PD },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: mV },
  ".cm-panels": { backgroundColor: fV, color: Vu },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: FD,
    color: Sf,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: kD
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: Up
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: Up,
    borderBottomColor: Up
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: kD,
      color: Vu
    }
  }
}, { dark: !0 }), yV = /* @__PURE__ */ Fl.define([
  {
    tag: V.keyword,
    color: dV
  },
  {
    tag: [V.name, V.deleted, V.character, V.propertyName, V.macroName],
    color: SD
  },
  {
    tag: [/* @__PURE__ */ V.function(V.variableName), V.labelName],
    color: hV
  },
  {
    tag: [V.color, /* @__PURE__ */ V.constant(V.name), /* @__PURE__ */ V.standard(V.name)],
    color: TD
  },
  {
    tag: [/* @__PURE__ */ V.definition(V.name), V.separator],
    color: Vu
  },
  {
    tag: [V.typeName, V.className, V.number, V.changed, V.annotation, V.modifier, V.self, V.namespace],
    color: lV
  },
  {
    tag: [V.operator, V.operatorKeyword, V.url, V.escape, V.regexp, V.link, /* @__PURE__ */ V.special(V.string)],
    color: uV
  },
  {
    tag: [V.meta, V.comment],
    color: Sf
  },
  {
    tag: V.strong,
    fontWeight: "bold"
  },
  {
    tag: V.emphasis,
    fontStyle: "italic"
  },
  {
    tag: V.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: V.link,
    color: Sf,
    textDecoration: "underline"
  },
  {
    tag: V.heading,
    fontWeight: "bold",
    color: SD
  },
  {
    tag: [V.atom, V.bool, /* @__PURE__ */ V.special(V.variableName)],
    color: TD
  },
  {
    tag: [V.processingInstruction, V.string, V.inserted],
    color: pV
  },
  {
    tag: V.invalid,
    color: cV
  }
]), DV = [gV, /* @__PURE__ */ NE(yV)];
var xV = ce.theme({
  "&": {
    backgroundColor: "#fff"
  }
}, {
  dark: !1
}), bV = function(e) {
  e === void 0 && (e = {});
  var {
    indentWithTab: r = !0,
    editable: n = !0,
    readOnly: i = !1,
    theme: s = "light",
    placeholder: o = "",
    basicSetup: l = !0
  } = e, u = [];
  switch (r && u.unshift(Ch.of([_U])), l && (typeof l == "boolean" ? u.unshift(wD()) : u.unshift(wD(l))), o && u.unshift(Hj(o)), s) {
    case "light":
      u.push(xV);
      break;
    case "dark":
      u.push(DV);
      break;
    case "none":
      break;
    default:
      u.push(s);
      break;
  }
  return n === !1 && u.push(ce.editable.of(!1)), i && u.push(Ie.readOnly.of(!0)), [...u];
}, vV = (t) => ({
  line: t.state.doc.lineAt(t.state.selection.main.from),
  lineCount: t.state.doc.lines,
  lineBreak: t.state.lineBreak,
  length: t.state.doc.length,
  readOnly: t.state.readOnly,
  tabSize: t.state.tabSize,
  selection: t.state.selection,
  selectionAsSingle: t.state.selection.asSingle().main,
  ranges: t.state.selection.ranges,
  selectionCode: t.state.sliceDoc(t.state.selection.main.from, t.state.selection.main.to),
  selections: t.state.selection.ranges.map((e) => t.state.sliceDoc(e.from, e.to)),
  selectedText: t.state.selection.ranges.some((e) => !e.empty)
}), BD = Nn.define(), CV = [];
function AV(t) {
  var {
    value: e,
    selection: r,
    onChange: n,
    onStatistics: i,
    onCreateEditor: s,
    onUpdate: o,
    extensions: l = CV,
    autoFocus: u,
    theme: h = "light",
    height: p = null,
    minHeight: d = null,
    maxHeight: m = null,
    width: y = null,
    minWidth: D = null,
    maxWidth: b = null,
    placeholder: C = "",
    editable: A = !0,
    readOnly: x = !1,
    indentWithTab: E = !0,
    basicSetup: k = !0,
    root: w,
    initialState: T
  } = t, [P, M] = Ei(), [N, L] = Ei(), [j, X] = Ei(), Q = ce.theme({
    "&": {
      height: p,
      minHeight: d,
      maxHeight: m,
      width: y,
      minWidth: D,
      maxWidth: b
    },
    "& .cm-scroller": {
      height: "100% !important"
    }
  }), $ = ce.updateListener.of((Z) => {
    if (Z.docChanged && typeof n == "function" && // Fix echoing of the remote changes:
    // If transaction is market as remote we don't have to call `onChange` handler again
    !Z.transactions.some((ve) => ve.annotation(BD))) {
      var ye = Z.state.doc, Ee = ye.toString();
      n(Ee, Z);
    }
    i && i(vV(Z));
  }), U = bV({
    theme: h,
    editable: A,
    readOnly: x,
    placeholder: C,
    indentWithTab: E,
    basicSetup: k
  }), H = [$, Q, ...U];
  return o && typeof o == "function" && H.push(ce.updateListener.of(o)), H = H.concat(l), Xr(() => {
    if (P && !j) {
      var Z = {
        doc: e,
        selection: r,
        extensions: H
      }, ye = T ? Ie.fromJSON(T.json, Z, T.fields) : Ie.create(Z);
      if (X(ye), !N) {
        var Ee = new ce({
          state: ye,
          parent: P,
          root: w
        });
        L(Ee), s && s(Ee, ye);
      }
    }
    return () => {
      N && (X(void 0), L(void 0));
    };
  }, [P, j]), Xr(() => M(t.container), [t.container]), Xr(() => () => {
    N && (N.destroy(), L(void 0));
  }, [N]), Xr(() => {
    u && N && N.focus();
  }, [u, N]), Xr(() => {
    N && N.dispatch({
      effects: Se.reconfigure.of(H)
    });
  }, [h, l, p, d, m, y, D, b, C, A, x, E, k, n, o]), Xr(() => {
    if (e !== void 0) {
      var Z = N ? N.state.doc.toString() : "";
      N && e !== Z && N.dispatch({
        changes: {
          from: 0,
          to: Z.length,
          insert: e || ""
        },
        annotations: [BD.of(!0)]
      });
    }
  }, [e, N]), {
    state: j,
    setState: X,
    view: N,
    setView: L,
    container: P,
    setContainer: M
  };
}
var EV = ["className", "value", "selection", "extensions", "onChange", "onStatistics", "onCreateEditor", "onUpdate", "autoFocus", "theme", "height", "minHeight", "maxHeight", "width", "minWidth", "maxWidth", "basicSetup", "placeholder", "indentWithTab", "editable", "readOnly", "root", "initialState"], qw = /* @__PURE__ */ tT((t, e) => {
  var {
    className: r,
    value: n = "",
    selection: i,
    extensions: s = [],
    onChange: o,
    onStatistics: l,
    onCreateEditor: u,
    onUpdate: h,
    autoFocus: p,
    theme: d = "light",
    height: m,
    minHeight: y,
    maxHeight: D,
    width: b,
    minWidth: C,
    maxWidth: A,
    basicSetup: x,
    placeholder: E,
    indentWithTab: k,
    editable: w,
    readOnly: T,
    root: P,
    initialState: M
  } = t, N = A$(t, EV), L = Tf(null), {
    state: j,
    view: X,
    container: Q
  } = AV({
    container: L.current,
    root: P,
    value: n,
    autoFocus: p,
    theme: d,
    height: m,
    minHeight: y,
    maxHeight: D,
    width: b,
    minWidth: C,
    maxWidth: A,
    basicSetup: x,
    placeholder: E,
    indentWithTab: k,
    editable: w,
    readOnly: T,
    selection: i,
    onChange: o,
    onStatistics: l,
    onCreateEditor: u,
    onUpdate: h,
    extensions: s,
    initialState: M
  });
  if (rT(e, () => ({
    editor: L.current,
    state: j,
    view: X
  }), [L, Q, j, X]), typeof n != "string")
    throw new Error("value must be typeof string but got " + typeof n);
  var $ = typeof d == "string" ? "cm-theme-" + d : "cm-theme";
  return /* @__PURE__ */ G.jsx("div", Fd({
    ref: L,
    className: "" + $ + (r ? " " + r : "")
  }, N));
});
qw.displayName = "CodeMirror";
const wV = () => {
  const { config: t } = vr();
  return yT(t);
}, SV = {
  html: sT(),
  css: oT(),
  js: aT(),
  json: lT()
}, TV = () => {
  var h;
  const [t, e] = Ei("light"), {
    project: r,
    saveFile: n,
    config: { editableFileTypes: i }
  } = vr(), s = wV(), o = (h = Object.values(r.files).filter((p) => p.active)) == null ? void 0 : h[0], l = nT(
    (p) => {
      n(o.id, p);
    },
    [n, o]
  ), u = async () => {
    try {
      const p = await l$(o.contents, o.language);
      n(o.id, p);
    } catch (p) {
      console.log("FAILURE : ", p);
    }
  };
  return o ? LD(o.language, i) ? /* @__PURE__ */ G.jsxs("div", { className: "editor-container", children: [
    /* @__PURE__ */ G.jsx("button", { onClick: () => u(), children: "Format" }),
    /* @__PURE__ */ G.jsxs("select", { onChange: (p) => e(p.target.value), children: [
      /* @__PURE__ */ G.jsx("option", { value: "light", children: "light theme" }),
      /* @__PURE__ */ G.jsx("option", { value: "dark", children: "dark theme" })
    ] }),
    o && /* @__PURE__ */ G.jsx(
      qw,
      {
        value: o.contents,
        width: "100%",
        height: "100%",
        extensions: [SV[o.language]],
        onChange: l,
        theme: t
      }
    )
  ] }) : /* @__PURE__ */ G.jsxs("div", { children: [
    "Can only edit html, css, or javascript files. Cannot edit",
    " ",
    o.language,
    " files."
  ] }) : /* @__PURE__ */ G.jsx(s, {});
}, kV = () => {
  const { config: t } = vr(), e = t.EditorComponent || TV;
  return /* @__PURE__ */ G.jsxs("div", { className: "center-pane", children: [
    /* @__PURE__ */ G.jsx("div", { className: "center-nav", children: /* @__PURE__ */ G.jsx(C$, {}) }),
    /* @__PURE__ */ G.jsx("div", { className: "center-main", children: /* @__PURE__ */ G.jsx(e, {}) })
  ] });
}, FV = ({ file: t }) => {
  const e = Tf(null), {
    project: { files: r, folders: n }
  } = vr(), i = MD(() => t ? t.contents.replace(
    new RegExp('<link rel="stylesheet" href="([^"]+)"\\s*/>', "g"),
    (o, l) => {
      const u = l.split("/"), h = u.pop(), p = _D(u, {
        folders: Object.values(n)
      }), d = Object.values(r).find(
        (m) => m.name === h && m.folderId === p
      );
      return `
          <style>
            ${d == null ? void 0 : d.contents}
          </style>
      `;
    }
  ) : "", [r, t]);
  return /* @__PURE__ */ G.jsx(G.Fragment, { children: t && /* @__PURE__ */ G.jsx(
    "iframe",
    {
      allow: "self",
      title: "Web Preview",
      ref: e,
      id: "preview",
      style: { width: "100%", height: "100%" },
      srcDoc: i
    }
  ) });
};
var Ww = { exports: {} };
(function(t, e) {
  (function(n, i) {
    t.exports = i();
  })(uT, function() {
    return (
      /******/
      function(r) {
        var n = {};
        function i(s) {
          if (n[s])
            return n[s].exports;
          var o = n[s] = {
            /******/
            i: s,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return r[s].call(o.exports, o, o.exports, i), o.l = !0, o.exports;
        }
        return i.m = r, i.c = n, i.i = function(s) {
          return s;
        }, i.d = function(s, o, l) {
          i.o(s, o) || Object.defineProperty(s, o, {
            /******/
            configurable: !1,
            /******/
            enumerable: !0,
            /******/
            get: l
            /******/
          });
        }, i.n = function(s) {
          var o = s && s.__esModule ? (
            /******/
            function() {
              return s.default;
            }
          ) : (
            /******/
            function() {
              return s;
            }
          );
          return i.d(o, "a", o), o;
        }, i.o = function(s, o) {
          return Object.prototype.hasOwnProperty.call(s, o);
        }, i.p = "", i(i.s = 3);
      }([
        /* 0 */
        /***/
        function(r, n, i) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          });
          var s = Object.assign || function(C) {
            for (var A = 1; A < arguments.length; A++) {
              var x = arguments[A];
              for (var E in x)
                Object.prototype.hasOwnProperty.call(x, E) && (C[E] = x[E]);
            }
            return C;
          }, o = /* @__PURE__ */ function() {
            function C(A, x) {
              for (var E = 0; E < x.length; E++) {
                var k = x[E];
                k.enumerable = k.enumerable || !1, k.configurable = !0, "value" in k && (k.writable = !0), Object.defineProperty(A, k.key, k);
              }
            }
            return function(A, x, E) {
              return x && C(A.prototype, x), E && C(A, E), A;
            };
          }();
          function l(C) {
            if (Array.isArray(C)) {
              for (var A = 0, x = Array(C.length); A < C.length; A++)
                x[A] = C[A];
              return x;
            } else
              return Array.from(C);
          }
          function u(C, A) {
            if (!(C instanceof A))
              throw new TypeError("Cannot call a class as a function");
          }
          var h = n.TYPE_MESSAGE = "message", p = n.TYPE_RESPONSE = "response", d = n.TYPE_SET_INTERFACE = "set-interface", m = n.TYPE_SERVICE_MESSAGE = "service-message", y = !!window.MSInputMethodContext && !!document.documentMode, D = {
            //Will not affect IE11 because there sandboxed iframe has not 'null' origin
            //but base URL of iframe's src
            allowedSenderOrigin: void 0
          }, b = function() {
            function C(A, x, E) {
              var k = this;
              u(this, C), this.options = s({}, D, E), this.incrementalID = Math.floor(Math.random() * 1e5), this.postMessage = A, this.remote = {}, this.callbacks = {}, this.remoteMethodsWaitPromise = new Promise(function(w) {
                k._resolveRemoteMethodsPromise = w;
              }), x(function() {
                return k.onMessageListener.apply(k, arguments);
              });
            }
            return o(C, [{
              key: "onMessageListener",
              value: function(x) {
                var E = this, k = x.data, w = this.options.allowedSenderOrigin;
                w && x.origin !== w && !y || (k.type === p ? this.popCallback(k.callId, k.success, k.result) : k.type === h ? this.callLocalApi(k.methodName, k.arguments).then(function(T) {
                  return E.responseOtherSide(k.callId, T);
                }).catch(function(T) {
                  return E.responseOtherSide(k.callId, T, !1);
                }) : k.type === d ? (this.setInterface(k.apiMethods), this.responseOtherSide(k.callId)) : k.type === m && this.callLocalServiceMethod(k.methodName, k.arguments).then(function(T) {
                  return E.responseOtherSide(k.callId, T);
                }).catch(function(T) {
                  return E.responseOtherSide(k.callId, T, !1);
                }));
              }
            }, {
              key: "postMessageToOtherSide",
              value: function(x) {
                this.postMessage(x, "*");
              }
              /**
                 * Sets remote interface methods
                 * @param remote - hash with keys of remote API methods. Values is ignored
                 */
            }, {
              key: "setInterface",
              value: function(x) {
                var E = this;
                this.remote = {}, x.forEach(function(k) {
                  return E.remote[k] = E.createMethodWrapper(k);
                }), this._resolveRemoteMethodsPromise();
              }
            }, {
              key: "setLocalApi",
              value: function(x) {
                var E = this;
                return new Promise(function(k, w) {
                  var T = E.registerCallback(k, w);
                  E.postMessageToOtherSide({
                    callId: T,
                    apiMethods: Object.keys(x),
                    type: d
                  });
                }).then(function() {
                  return E.localApi = x;
                });
              }
            }, {
              key: "setServiceMethods",
              value: function(x) {
                this.serviceMethods = x;
              }
              /**
                 * Calls local method
                 * @param methodName
                 * @param args
                 * @returns {Promise.<*>|string}
                 */
            }, {
              key: "callLocalApi",
              value: function(x, E) {
                var k;
                return Promise.resolve((k = this.localApi)[x].apply(k, l(E)));
              }
              /**
                 * Calls local method registered as "service method"
                 * @param methodName
                 * @param args
                 * @returns {Promise.<*>}
                 */
            }, {
              key: "callLocalServiceMethod",
              value: function(x, E) {
                var k;
                if (!this.serviceMethods[x])
                  throw new Error("Serivce method " + x + " is not registered");
                return Promise.resolve((k = this.serviceMethods)[x].apply(k, l(E)));
              }
              /**
                 * Wraps remote method with callback storing code
                 * @param methodName - method to wrap
                 * @returns {Function} - function to call as remote API interface
                 */
            }, {
              key: "createMethodWrapper",
              value: function(x) {
                var E = this;
                return function() {
                  for (var k = arguments.length, w = Array(k), T = 0; T < k; T++)
                    w[T] = arguments[T];
                  return E.callRemoteMethod.apply(E, [x].concat(w));
                };
              }
              /**
                 * Calls other side with arguments provided
                 * @param id
                 * @param methodName
                 * @param args
                 */
            }, {
              key: "callRemoteMethod",
              value: function(x) {
                for (var E = this, k = arguments.length, w = Array(k > 1 ? k - 1 : 0), T = 1; T < k; T++)
                  w[T - 1] = arguments[T];
                return new Promise(function(P, M) {
                  var N = E.registerCallback(P, M);
                  E.postMessageToOtherSide({
                    callId: N,
                    methodName: x,
                    type: h,
                    arguments: w
                  });
                });
              }
              /**
                 * Calls remote service method
                 * @param methodName
                 * @param args
                 * @returns {*}
                 */
            }, {
              key: "callRemoteServiceMethod",
              value: function(x) {
                for (var E = this, k = arguments.length, w = Array(k > 1 ? k - 1 : 0), T = 1; T < k; T++)
                  w[T - 1] = arguments[T];
                return new Promise(function(P, M) {
                  var N = E.registerCallback(P, M);
                  E.postMessageToOtherSide({
                    callId: N,
                    methodName: x,
                    type: m,
                    arguments: w
                  });
                });
              }
              /**
                 * Respond to remote call
                 * @param id - remote call ID
                 * @param result - result to pass to calling function
                 */
            }, {
              key: "responseOtherSide",
              value: function(x, E) {
                var k = this, w = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
                E instanceof Error && (E = [].concat(l(Object.keys(E)), ["message"]).reduce(function(P, M) {
                  return P[M] = E[M], P;
                }, {}));
                var T = function() {
                  return k.postMessage({
                    callId: x,
                    type: p,
                    success: w,
                    result: E
                  }, "*");
                };
                try {
                  T();
                } catch (P) {
                  console.error("Failed to post response, recovering...", P), P instanceof DOMException && (E = JSON.parse(JSON.stringify(E)), T());
                }
              }
              /**
                 * Stores callbacks to call later when remote call will be answered
                 * @param successCallback
                 * @param failureCallback
                 */
            }, {
              key: "registerCallback",
              value: function(x, E) {
                var k = (++this.incrementalID).toString();
                return this.callbacks[k] = { successCallback: x, failureCallback: E }, k;
              }
              /**
                 * Calls and delete stored callback
                 * @param id - call id
                 * @param success - was call successful
                 * @param result - result of remote call
                 */
            }, {
              key: "popCallback",
              value: function(x, E, k) {
                E ? this.callbacks[x].successCallback(k) : this.callbacks[x].failureCallback(k), delete this.callbacks[x];
              }
            }]), C;
          }();
          n.default = b;
        },
        /* 1 */
        /***/
        function(r, n) {
          r.exports = `/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TYPE_MESSAGE = exports.TYPE_MESSAGE = 'message';
var TYPE_RESPONSE = exports.TYPE_RESPONSE = 'response';
var TYPE_SET_INTERFACE = exports.TYPE_SET_INTERFACE = 'set-interface';
var TYPE_SERVICE_MESSAGE = exports.TYPE_SERVICE_MESSAGE = 'service-message';

var isIE11 = !!window.MSInputMethodContext && !!document.documentMode;

var defaultOptions = {
  //Will not affect IE11 because there sandboxed iframe has not 'null' origin
  //but base URL of iframe's src
  allowedSenderOrigin: undefined
};

var Connection = function () {
  function Connection(postMessage, registerOnMessageListener, options) {
    var _this = this;

    _classCallCheck(this, Connection);

    this.options = _extends({}, defaultOptions, options);
    //Random number between 0 and 100000
    this.incrementalID = Math.floor(Math.random() * 100000);

    this.postMessage = postMessage;
    this.remote = {};
    this.callbacks = {};

    this.remoteMethodsWaitPromise = new Promise(function (resolve) {
      _this._resolveRemoteMethodsPromise = resolve;
    });

    registerOnMessageListener(function () {
      return _this.onMessageListener.apply(_this, arguments);
    });
  }

  /**
     * Listens to remote messages. Calls local method if it is called outside or call stored callback if it is response.
     * @param e - onMessage event
     */


  _createClass(Connection, [{
    key: 'onMessageListener',
    value: function onMessageListener(e) {
      var _this2 = this;

      var data = e.data;

      var allowedSenderOrigin = this.options.allowedSenderOrigin;

      if (allowedSenderOrigin && e.origin !== allowedSenderOrigin && !isIE11) {
        return;
      }

      if (data.type === TYPE_RESPONSE) {
        this.popCallback(data.callId, data.success, data.result);
      } else if (data.type === TYPE_MESSAGE) {
        this.callLocalApi(data.methodName, data.arguments).then(function (res) {
          return _this2.responseOtherSide(data.callId, res);
        }).catch(function (err) {
          return _this2.responseOtherSide(data.callId, err, false);
        });
      } else if (data.type === TYPE_SET_INTERFACE) {
        this.setInterface(data.apiMethods);
        this.responseOtherSide(data.callId);
      } else if (data.type === TYPE_SERVICE_MESSAGE) {
        this.callLocalServiceMethod(data.methodName, data.arguments).then(function (res) {
          return _this2.responseOtherSide(data.callId, res);
        }).catch(function (err) {
          return _this2.responseOtherSide(data.callId, err, false);
        });
      }
    }
  }, {
    key: 'postMessageToOtherSide',
    value: function postMessageToOtherSide(dataToPost) {
      this.postMessage(dataToPost, '*');
    }

    /**
       * Sets remote interface methods
       * @param remote - hash with keys of remote API methods. Values is ignored
       */

  }, {
    key: 'setInterface',
    value: function setInterface(remoteMethods) {
      var _this3 = this;

      this.remote = {};

      remoteMethods.forEach(function (key) {
        return _this3.remote[key] = _this3.createMethodWrapper(key);
      });

      this._resolveRemoteMethodsPromise();
    }
  }, {
    key: 'setLocalApi',
    value: function setLocalApi(api) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        var id = _this4.registerCallback(resolve, reject);
        _this4.postMessageToOtherSide({
          callId: id,
          apiMethods: Object.keys(api),
          type: TYPE_SET_INTERFACE
        });
      }).then(function () {
        return _this4.localApi = api;
      });
    }
  }, {
    key: 'setServiceMethods',
    value: function setServiceMethods(api) {
      this.serviceMethods = api;
    }

    /**
       * Calls local method
       * @param methodName
       * @param args
       * @returns {Promise.<*>|string}
       */

  }, {
    key: 'callLocalApi',
    value: function callLocalApi(methodName, args) {
      var _localApi;

      return Promise.resolve((_localApi = this.localApi)[methodName].apply(_localApi, _toConsumableArray(args)));
    }

    /**
       * Calls local method registered as "service method"
       * @param methodName
       * @param args
       * @returns {Promise.<*>}
       */

  }, {
    key: 'callLocalServiceMethod',
    value: function callLocalServiceMethod(methodName, args) {
      var _serviceMethods;

      if (!this.serviceMethods[methodName]) {
        throw new Error('Serivce method ' + methodName + ' is not registered');
      }
      return Promise.resolve((_serviceMethods = this.serviceMethods)[methodName].apply(_serviceMethods, _toConsumableArray(args)));
    }

    /**
       * Wraps remote method with callback storing code
       * @param methodName - method to wrap
       * @returns {Function} - function to call as remote API interface
       */

  }, {
    key: 'createMethodWrapper',
    value: function createMethodWrapper(methodName) {
      var _this5 = this;

      return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _this5.callRemoteMethod.apply(_this5, [methodName].concat(args));
      };
    }

    /**
       * Calls other side with arguments provided
       * @param id
       * @param methodName
       * @param args
       */

  }, {
    key: 'callRemoteMethod',
    value: function callRemoteMethod(methodName) {
      var _this6 = this;

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return new Promise(function (resolve, reject) {
        var id = _this6.registerCallback(resolve, reject);
        _this6.postMessageToOtherSide({
          callId: id,
          methodName: methodName,
          type: TYPE_MESSAGE,
          arguments: args
        });
      });
    }

    /**
       * Calls remote service method
       * @param methodName
       * @param args
       * @returns {*}
       */

  }, {
    key: 'callRemoteServiceMethod',
    value: function callRemoteServiceMethod(methodName) {
      var _this7 = this;

      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return new Promise(function (resolve, reject) {
        var id = _this7.registerCallback(resolve, reject);
        _this7.postMessageToOtherSide({
          callId: id,
          methodName: methodName,
          type: TYPE_SERVICE_MESSAGE,
          arguments: args
        });
      });
    }

    /**
       * Respond to remote call
       * @param id - remote call ID
       * @param result - result to pass to calling function
       */

  }, {
    key: 'responseOtherSide',
    value: function responseOtherSide(id, result) {
      var _this8 = this;

      var success = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (result instanceof Error) {
        // Error could be non-serializable, so we copy properties manually
        result = [].concat(_toConsumableArray(Object.keys(result)), ['message']).reduce(function (acc, it) {
          acc[it] = result[it];
          return acc;
        }, {});
      }

      var doPost = function doPost() {
        return _this8.postMessage({
          callId: id,
          type: TYPE_RESPONSE,
          success: success,
          result: result
        }, '*');
      };

      try {
        doPost();
      } catch (err) {
        console.error('Failed to post response, recovering...', err); // eslint-disable-line no-console
        if (err instanceof DOMException) {
          result = JSON.parse(JSON.stringify(result));
          doPost();
        }
      }
    }

    /**
       * Stores callbacks to call later when remote call will be answered
       * @param successCallback
       * @param failureCallback
       */

  }, {
    key: 'registerCallback',
    value: function registerCallback(successCallback, failureCallback) {
      var id = (++this.incrementalID).toString();
      this.callbacks[id] = { successCallback: successCallback, failureCallback: failureCallback };
      return id;
    }

    /**
       * Calls and delete stored callback
       * @param id - call id
       * @param success - was call successful
       * @param result - result of remote call
       */

  }, {
    key: 'popCallback',
    value: function popCallback(id, success, result) {
      if (success) {
        this.callbacks[id].successCallback(result);
      } else {
        this.callbacks[id].failureCallback(result);
      }
      delete this.callbacks[id];
    }
  }]);

  return Connection;
}();

exports.default = Connection;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _connection = __webpack_require__(0);

var _connection2 = _interopRequireDefault(_connection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Frame = function () {
  function Frame() {
    var _this = this;

    _classCallCheck(this, Frame);

    this.connection = new _connection2.default(window.parent.postMessage.bind(window.parent), function (listener) {
      window.addEventListener('message', listener);
    });

    this.connection.setServiceMethods({
      runCode: function runCode(code) {
        return _this.runCode(code);
      },
      importScript: function importScript(path) {
        return _this.importScript(path);
      },
      injectStyle: function injectStyle(style) {
        return _this.injectStyle(style);
      },
      importStyle: function importStyle(path) {
        return _this.importStyle(path);
      }
    });

    this.connection.callRemoteServiceMethod('iframeInitialized');
  }

  /**
     * Creates script tag with passed code and attaches it. Runs synchronous
     * @param code
     */


  _createClass(Frame, [{
    key: 'runCode',
    value: function runCode(code) {
      var scriptTag = document.createElement('script');
      scriptTag.innerHTML = code;
      document.getElementsByTagName('head')[0].appendChild(scriptTag);
    }
  }, {
    key: 'importScript',
    value: function importScript(scriptUrl) {
      var scriptTag = document.createElement('script');
      scriptTag.src = scriptUrl;
      document.getElementsByTagName('head')[0].appendChild(scriptTag);
      return new Promise(function (resolve) {
        return scriptTag.onload = function () {
          return resolve();
        };
      });
    }
  }, {
    key: 'injectStyle',
    value: function injectStyle(style) {
      var styleTag = document.createElement('style');
      styleTag.innerHTML = style;
      document.getElementsByTagName('head')[0].appendChild(styleTag);
    }
  }, {
    key: 'importStyle',
    value: function importStyle(styleUrl) {
      var linkTag = document.createElement('link');
      linkTag.rel = 'stylesheet';
      linkTag.href = styleUrl;
      document.getElementsByTagName('head')[0].appendChild(linkTag);
    }
  }]);

  return Frame;
}();

var Websandbox = new Frame();
window.Websandbox = window.Websandbox || Websandbox;
module.exports = Websandbox; // eslint-disable-line

/***/ })
/******/ ]);
//# sourceMappingURL=compile-loader-file-name.js.map`;
        },
        ,
        /* 3 */
        /***/
        function(r, n, i) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.BaseOptions = void 0;
          var s = Object.assign || function(b) {
            for (var C = 1; C < arguments.length; C++) {
              var A = arguments[C];
              for (var x in A)
                Object.prototype.hasOwnProperty.call(A, x) && (b[x] = A[x]);
            }
            return b;
          }, o = /* @__PURE__ */ function() {
            function b(C, A) {
              for (var x = 0; x < A.length; x++) {
                var E = A[x];
                E.enumerable = E.enumerable || !1, E.configurable = !0, "value" in E && (E.writable = !0), Object.defineProperty(C, E.key, E);
              }
            }
            return function(C, A, x) {
              return A && b(C.prototype, A), x && b(C, x), C;
            };
          }(), l = i(0), u = d(l), h = i(1), p = d(h);
          function d(b) {
            return b && b.__esModule ? b : { default: b };
          }
          function m(b, C) {
            if (!(b instanceof C))
              throw new TypeError("Cannot call a class as a function");
          }
          var y = n.BaseOptions = {
            frameContainer: "body",
            frameClassName: "websandbox__frame",
            frameSrc: null,
            frameContent: `
<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"></head>
<body></body>
</html>
  `,
            codeToRunBeforeInit: null,
            initialStyles: null,
            baseUrl: null,
            allowPointerLock: !1,
            allowFullScreen: !1,
            sandboxAdditionalAttributes: ""
          }, D = function() {
            o(b, null, [{
              key: "create",
              /**
               * Creates sandbox instancea
               * @param {?Object} localApi Api of this side. Will be available for sandboxed code as remoteApi
               * @param {?SandboxOptions} options Options of created sandbox
               */
              value: function(A) {
                var x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                return new b(A, s(y, x));
              }
              /**
               * {Constructor}
               * @param {?Object} localApi
               * @param {?SandboxOptions} options
               */
            }]);
            function b(C, A) {
              var x = this;
              m(this, b), this.options = A, this.iframe = this.createIframe(), this.promise = new Promise(function(E) {
                x.connection = new u.default(x.iframe.contentWindow.postMessage.bind(x.iframe.contentWindow), function(k) {
                  var w = function(P) {
                    if (P.source === x.iframe.contentWindow)
                      return k(P);
                  };
                  window.addEventListener("message", w), x.removeMessageListener = function() {
                    return window.removeEventListener("message", w);
                  };
                }, { allowedSenderOrigin: "null" }), x.connection.setServiceMethods({
                  iframeInitialized: function() {
                    return x.connection.setLocalApi(C).then(function() {
                      return E(x);
                    });
                  }
                });
              });
            }
            return o(b, [{
              key: "_prepareFrameContent",
              value: function(A) {
                var x = A.frameContent.replace("</head>", "<script>" + p.default + `<\/script>
</head>`);
                return A.initialStyles && (x = x.replace("</head>", "<style>" + A.initialStyles + `</style>
</head>`)), A.baseUrl && (x = x.replace("<head>", `<head>
<base href="` + A.baseUrl + '"/>')), A.codeToRunBeforeInit && (x = x.replace("<head>", `<head>
<script>` + A.codeToRunBeforeInit + "<\/script>")), x;
              }
            }, {
              key: "createIframe",
              value: function() {
                var A = this.options.frameContainer, x = typeof A == "string" ? document.querySelector(A) : A;
                if (!x)
                  throw new Error("Websandbox: Cannot find container for sandbox " + x);
                var E = document.createElement("iframe");
                if (E.sandbox = "allow-scripts " + this.options.sandboxAdditionalAttributes, E.className = this.options.frameClassName, this.options.allowFullScreen && (E.allowfullscreen = "true"), this.options.frameSrc)
                  return E.src = this.options.frameSrc, x.appendChild(E), E;
                if (this.options.frameContent.indexOf("<head>") < 0)
                  throw new Error('Websandbox: iFrame content must have "<head>" tag.');
                return E.setAttribute("srcdoc", this._prepareFrameContent(this.options)), x.appendChild(E), E;
              }
            }, {
              key: "destroy",
              value: function() {
                this.iframe.remove(), this.removeMessageListener();
              }
            }, {
              key: "_runCode",
              value: function(A) {
                return this.connection.callRemoteServiceMethod("runCode", A);
              }
            }, {
              key: "_runFunction",
              value: function(A) {
                return this._runCode("(" + A.toString() + ")()");
              }
            }, {
              key: "run",
              value: function(A) {
                return A.name ? this._runFunction(A) : this._runCode(A);
              }
            }, {
              key: "importScript",
              value: function(A) {
                return this.connection.callRemoteServiceMethod("importScript", A);
              }
            }, {
              key: "injectStyle",
              value: function(A) {
                return this.connection.callRemoteServiceMethod("injectStyle", A);
              }
            }]), b;
          }();
          n.default = D;
        }
        /******/
      ])
    );
  });
})(Ww);
var PV = Ww.exports;
const BV = /* @__PURE__ */ cT(PV), IV = ({ output: t }) => {
  const [e, r] = Ei(t);
  return Xr(() => r(t), [t]), /* @__PURE__ */ G.jsxs("div", { className: "debugger-pane", children: [
    /* @__PURE__ */ G.jsxs("div", { className: "debugger-title-bar", children: [
      /* @__PURE__ */ G.jsx("div", { className: "debugger-title", children: "Console" }),
      /* @__PURE__ */ G.jsx("button", { type: "button", onClick: () => r(void 0), children: "Clear console" })
    ] }),
    /* @__PURE__ */ G.jsx("div", { className: "debugger-view", children: e == null ? void 0 : e.map((n) => n.join(", ")).join(`
`) })
  ] });
}, NV = ({
  contentFrameHeight: t = "1fr",
  debuggerOutput: e,
  children: r
}) => {
  const { config: n } = vr();
  return /* @__PURE__ */ G.jsxs(
    "div",
    {
      className: "debugger-wrapper",
      style: {
        gridTemplateRows: n.showDebug ? `${t} 1fr` : "auto"
      },
      children: [
        /* @__PURE__ */ G.jsx("div", { className: "debugger-wrapper-child", children: r }),
        /* @__PURE__ */ G.jsx(IV, { output: e })
      ]
    }
  );
}, MV = ({ file: t }) => {
  const [e, r] = Ei([]), n = () => {
    const i = {
      consoleLog: (...s) => (r((o) => [...o, s]), Promise.resolve("messaged"))
    };
    for (let s of document.getElementsByClassName("js-preview-output"))
      s.innerHTML = "";
    BV.create(i, {
      frameContainer: ".js-preview-output"
    }).promise.then(function(s) {
      r([]), s.run(
        `
        console.log = Websandbox.connection.remote.consoleLog;
        ${t.contents}
      `
      );
    });
  };
  return /* @__PURE__ */ G.jsx(NV, { contentFrameHeight: "1fr", debuggerOutput: e, children: /* @__PURE__ */ G.jsxs("div", { className: "js-preview-container", children: [
    /* @__PURE__ */ G.jsx("div", { className: "js-preview-output", children: "pending..." }),
    /* @__PURE__ */ G.jsx("div", { className: "button-bar", children: /* @__PURE__ */ G.jsx("button", { onClick: n, children: "Run" }) })
  ] }) });
}, OV = ({ file: t }) => {
  let e = "";
  try {
    e = JSON.stringify(JSON.parse(t.contents), void 0, 2);
  } catch (r) {
    const n = $D(r);
    return /* @__PURE__ */ G.jsxs("div", { className: "json-preview", children: [
      "Cannot display json: invalid format.",
      n
    ] });
  }
  return /* @__PURE__ */ G.jsx("div", { className: "json-preview", children: e });
}, ID = {
  html: FV,
  js: MV,
  json: OV
}, LV = (t, e = {}) => t ? e[t == null ? void 0 : t.language] ? e[t == null ? void 0 : t.language] : ID[t == null ? void 0 : t.language] ? ID[t == null ? void 0 : t.language] : () => /* @__PURE__ */ G.jsxs("div", { children: [
  "Cannot preview files of type ",
  t == null ? void 0 : t.language
] }) : () => "", _V = () => {
  const {
    project: { files: t },
    config: { previewFileTypes: e, PreviewComponents: r }
  } = vr(), [n, i] = Ei(
    Object.values(t).find((l) => l.name === "index.html" && !l.folderId)
  ), s = Object.values(t).find(
    (l) => l.active && ql(l.language)
  );
  Xr(() => {
    ql(s == null ? void 0 : s.language, e) && i(s);
  }, [s]), Xr(() => {
    n && !t[n.id] && i(
      Object.values(t).find(
        (l) => ql(l.language, e)
      )
    );
  }, [n, t]);
  const o = LV(n, r);
  return /* @__PURE__ */ G.jsxs("div", { className: "right-pane", children: [
    /* @__PURE__ */ G.jsx(
      "select",
      {
        onChange: (l) => {
          const u = Object.values(t).find(
            (h) => h.id === l.target.value
          );
          i(u);
        },
        value: n == null ? void 0 : n.id,
        children: Object.values(t).sort().filter((l) => ql(l.language, e)).map((l) => /* @__PURE__ */ G.jsx("option", { value: l.id, children: l.name }, l.id))
      }
    ),
    n && /* @__PURE__ */ G.jsx(o, { file: n })
  ] });
}, $V = () => /* @__PURE__ */ G.jsxs("div", { className: "run-bar", children: [
  /* @__PURE__ */ G.jsx("div", { children: /* @__PURE__ */ G.jsx("button", { type: "button", onClick: () => alert("not implemented"), children: "Share" }) }),
  /* @__PURE__ */ G.jsx("div", { children: /* @__PURE__ */ G.jsx("button", { type: "button", onClick: () => alert("not implemented"), children: "Finish" }) })
] }), RV = {
  showPreview: !0,
  showEditor: !0,
  showLeftNav: !0,
  showRunBar: !1
}, Js = (t, e) => e[t] ?? RV[t] ?? !1, jV = [
  { key: "showLeftNav", width: "1fr" },
  { key: "showPreview", width: "2fr" },
  { key: "showEditor", width: "2fr" }
], qV = [
  { key: "showRunBar", height: "40px" }
], Wz = ({
  project: t,
  config: e,
  setProject: r,
  setConfig: n
}) => {
  const i = Tf(!0), [s, o] = iT(f$, t), l = d$(o);
  Xr(() => {
    i.current && r(s), i.current = !0;
  }, [s]), Xr(() => {
    l.replaceProject(t, i);
  }, [t, l.replaceProject]);
  const u = ["auto"];
  qV.forEach((p) => {
    Js(p.key, e) && u.push(p.height);
  });
  const h = [];
  return jV.forEach((p) => {
    Js(p.key, e) && h.push(p.width);
  }), /* @__PURE__ */ G.jsx(
    dT,
    {
      value: {
        project: s,
        config: e,
        setProject: r,
        setConfig: n,
        ...l
      },
      children: /* @__PURE__ */ G.jsxs(
        "div",
        {
          className: "cdo-ide-outer",
          style: { gridTemplateRows: u.join(" ") },
          children: [
            /* @__PURE__ */ G.jsxs(
              "div",
              {
                className: "cdo-ide-inner",
                style: {
                  gridTemplateColumns: h.join(" ")
                },
                children: [
                  Js("showLeftNav", e) && /* @__PURE__ */ G.jsx("div", { className: "cdo-ide-area", children: /* @__PURE__ */ G.jsx(v$, {}) }),
                  Js("showEditor", e) && /* @__PURE__ */ G.jsx("div", { className: "cdo-ide-area", children: /* @__PURE__ */ G.jsx(kV, {}) }),
                  Js("showPreview", e) && /* @__PURE__ */ G.jsx(_V, {})
                ]
              }
            ),
            Js("showRunBar", e) && /* @__PURE__ */ G.jsx($V, {})
          ]
        }
      )
    }
  );
};
export {
  Wz as CDOIDE,
  OD as CDOIDEContext,
  dT as CDOIDEContextProvider,
  LD as editableFileType,
  p$ as findFiles,
  _D as findFolder,
  og as findSubFolders,
  yT as getEmptyEditor,
  KV as getEmptyProject,
  $D as getErrorMessage,
  c$ as getNextFileId,
  h$ as getNextFolderId,
  l$ as prettify,
  ql as previewFileType,
  f$ as projectReducer,
  JC as sortFilesByName,
  vr as useCDOIDEContext,
  d$ as useProjectUtilities
};
//# sourceMappingURL=cdo-ide-poc.js.map
