import './style.css';
var Wv = Object.defineProperty;
var qv = (t, e, r) => e in t ? Wv(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var Tr = (t, e, r) => (qv(t, typeof e != "symbol" ? e + "" : e, r), r);
import Yp, { createContext as Hv, useContext as Vv, useMemo as Jp, useState as jr, useEffect as Nt, forwardRef as zv, useRef as vc, useImperativeHandle as Uv, useCallback as Gv, useReducer as Kv } from "react";
import { html as Yv } from "@codemirror/lang-html";
import { css as Jv } from "@codemirror/lang-css";
import { javascript as Xv } from "@codemirror/lang-javascript";
import { json as Qv } from "@codemirror/lang-json";
var Zv = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function e2(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var tu = { exports: {} }, Nn = {};
/** @license React v16.14.0
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xh;
function t2() {
  if (Xh)
    return Nn;
  Xh = 1;
  var t = Yp, e = 60103;
  if (Nn.Fragment = 60107, typeof Symbol == "function" && Symbol.for) {
    var r = Symbol.for;
    e = r("react.element"), Nn.Fragment = r("react.fragment");
  }
  var n = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = Object.prototype.hasOwnProperty, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, l, c) {
    var u, h = {}, f = null, d = null;
    c !== void 0 && (f = "" + c), l.key !== void 0 && (f = "" + l.key), l.ref !== void 0 && (d = l.ref);
    for (u in l)
      i.call(l, u) && !s.hasOwnProperty(u) && (h[u] = l[u]);
    if (a && a.defaultProps)
      for (u in l = a.defaultProps, l)
        h[u] === void 0 && (h[u] = l[u]);
    return { $$typeof: e, type: a, key: f, ref: d, props: h, _owner: n.current };
  }
  return Nn.jsx = o, Nn.jsxs = o, Nn;
}
var hl = {};
/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Qh;
function r2() {
  return Qh || (Qh = 1, function(t) {
    process.env.NODE_ENV !== "production" && function() {
      var e = Yp, r = 60103, n = 60106;
      t.Fragment = 60107;
      var i = 60108, s = 60114, o = 60109, a = 60110, l = 60112, c = 60113, u = 60120, h = 60115, f = 60116, d = 60121, p = 60122, m = 60117, y = 60129, v = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var g = Symbol.for;
        r = g("react.element"), n = g("react.portal"), t.Fragment = g("react.fragment"), i = g("react.strict_mode"), s = g("react.profiler"), o = g("react.provider"), a = g("react.context"), l = g("react.forward_ref"), c = g("react.suspense"), u = g("react.suspense_list"), h = g("react.memo"), f = g("react.lazy"), d = g("react.block"), p = g("react.server.block"), m = g("react.fundamental"), g("react.scope"), g("react.opaque.id"), y = g("react.debug_trace_mode"), g("react.offscreen"), v = g("react.legacy_hidden");
      }
      var b = typeof Symbol == "function" && Symbol.iterator, w = "@@iterator";
      function D(E) {
        if (E === null || typeof E != "object")
          return null;
        var j = b && E[b] || E[w];
        return typeof j == "function" ? j : null;
      }
      var x = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function C(E) {
        {
          for (var j = arguments.length, U = new Array(j > 1 ? j - 1 : 0), Q = 1; Q < j; Q++)
            U[Q - 1] = arguments[Q];
          k("error", E, U);
        }
      }
      function k(E, j, U) {
        {
          var Q = x.ReactDebugCurrentFrame, be = "";
          if (re) {
            var De = P(re.type), ce = re._owner;
            be += N(De, re._source, ce && P(ce.type));
          }
          be += Q.getStackAddendum(), be !== "" && (j += "%s", U = U.concat([be]));
          var Z = U.map(function(tt) {
            return "" + tt;
          });
          Z.unshift("Warning: " + j), Function.prototype.apply.call(console[E], console, Z);
        }
      }
      var S = !1;
      function A(E) {
        return !!(typeof E == "string" || typeof E == "function" || E === t.Fragment || E === s || E === y || E === i || E === c || E === u || E === v || S || typeof E == "object" && E !== null && (E.$$typeof === f || E.$$typeof === h || E.$$typeof === o || E.$$typeof === a || E.$$typeof === l || E.$$typeof === m || E.$$typeof === d || E[0] === p));
      }
      var _ = /^(.*)[\\\/]/;
      function N(E, j, U) {
        var Q = "";
        if (j) {
          var be = j.fileName, De = be.replace(_, "");
          if (/^index\./.test(De)) {
            var ce = be.match(_);
            if (ce) {
              var Z = ce[1];
              if (Z) {
                var tt = Z.replace(_, "");
                De = tt + "/" + De;
              }
            }
          }
          Q = " (at " + De + ":" + j.lineNumber + ")";
        } else
          U && (Q = " (created by " + U + ")");
        return `
    in ` + (E || "Unknown") + Q;
      }
      var $ = 1;
      function L(E) {
        return E._status === $ ? E._result : null;
      }
      function I(E, j, U) {
        var Q = j.displayName || j.name || "";
        return E.displayName || (Q !== "" ? U + "(" + Q + ")" : U);
      }
      function P(E) {
        if (E == null)
          return null;
        if (typeof E.tag == "number" && C("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof E == "function")
          return E.displayName || E.name || null;
        if (typeof E == "string")
          return E;
        switch (E) {
          case t.Fragment:
            return "Fragment";
          case n:
            return "Portal";
          case s:
            return "Profiler";
          case i:
            return "StrictMode";
          case c:
            return "Suspense";
          case u:
            return "SuspenseList";
        }
        if (typeof E == "object")
          switch (E.$$typeof) {
            case a:
              return "Context.Consumer";
            case o:
              return "Context.Provider";
            case l:
              return I(E, E.render, "ForwardRef");
            case h:
              return P(E.type);
            case d:
              return P(E.render);
            case f: {
              var j = E, U = L(j);
              if (U)
                return P(U);
              break;
            }
          }
        return null;
      }
      var G = {};
      x.ReactDebugCurrentFrame;
      var re = null;
      function oe(E) {
        re = E;
      }
      function ue(E, j, U, Q, be) {
        {
          var De = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var ce in E)
            if (De(E, ce)) {
              var Z = void 0;
              try {
                if (typeof E[ce] != "function") {
                  var tt = Error((Q || "React class") + ": " + U + " type `" + ce + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof E[ce] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw tt.name = "Invariant Violation", tt;
                }
                Z = E[ce](j, ce, Q, U, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Vt) {
                Z = Vt;
              }
              Z && !(Z instanceof Error) && (oe(be), C("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Q || "React class", U, ce, typeof Z), oe(null)), Z instanceof Error && !(Z.message in G) && (G[Z.message] = !0, oe(be), C("Failed %s type: %s", U, Z.message), oe(null));
            }
        }
      }
      var pe = x.ReactCurrentOwner, ke = Object.prototype.hasOwnProperty, qe = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, se, at, qt;
      qt = {};
      function q(E) {
        if (ke.call(E, "ref")) {
          var j = Object.getOwnPropertyDescriptor(E, "ref").get;
          if (j && j.isReactWarning)
            return !1;
        }
        return E.ref !== void 0;
      }
      function F(E) {
        if (ke.call(E, "key")) {
          var j = Object.getOwnPropertyDescriptor(E, "key").get;
          if (j && j.isReactWarning)
            return !1;
        }
        return E.key !== void 0;
      }
      function O(E, j) {
        if (typeof E.ref == "string" && pe.current && j && pe.current.stateNode !== j) {
          var U = P(pe.current.type);
          qt[U] || (C('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', P(pe.current.type), E.ref), qt[U] = !0);
        }
      }
      function X(E, j) {
        {
          var U = function() {
            se || (se = !0, C("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", j));
          };
          U.isReactWarning = !0, Object.defineProperty(E, "key", {
            get: U,
            configurable: !0
          });
        }
      }
      function ae(E, j) {
        {
          var U = function() {
            at || (at = !0, C("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", j));
          };
          U.isReactWarning = !0, Object.defineProperty(E, "ref", {
            get: U,
            configurable: !0
          });
        }
      }
      var ve = function(E, j, U, Q, be, De, ce) {
        var Z = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: r,
          // Built-in properties that belong on the element
          type: E,
          key: j,
          ref: U,
          props: ce,
          // Record the component responsible for creating this element.
          _owner: De
        };
        return Z._store = {}, Object.defineProperty(Z._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(Z, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Q
        }), Object.defineProperty(Z, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: be
        }), Object.freeze && (Object.freeze(Z.props), Object.freeze(Z)), Z;
      };
      function Dt(E, j, U, Q, be) {
        {
          var De, ce = {}, Z = null, tt = null;
          U !== void 0 && (Z = "" + U), F(j) && (Z = "" + j.key), q(j) && (tt = j.ref, O(j, be));
          for (De in j)
            ke.call(j, De) && !qe.hasOwnProperty(De) && (ce[De] = j[De]);
          if (E && E.defaultProps) {
            var Vt = E.defaultProps;
            for (De in Vt)
              ce[De] === void 0 && (ce[De] = Vt[De]);
          }
          if (Z || tt) {
            var Fr = typeof E == "function" ? E.displayName || E.name || "Unknown" : E;
            Z && X(ce, Fr), tt && ae(ce, Fr);
          }
          return ve(E, Z, tt, be, Q, pe.current, ce);
        }
      }
      var wt = x.ReactCurrentOwner;
      x.ReactDebugCurrentFrame;
      function Je(E) {
        re = E;
      }
      var Er;
      Er = !1;
      function Mn(E) {
        return typeof E == "object" && E !== null && E.$$typeof === r;
      }
      function hr() {
        {
          if (wt.current) {
            var E = P(wt.current.type);
            if (E)
              return `

Check the render method of \`` + E + "`.";
          }
          return "";
        }
      }
      function Ht(E) {
        {
          if (E !== void 0) {
            var j = E.fileName.replace(/^.*[\\\/]/, ""), U = E.lineNumber;
            return `

Check your code at ` + j + ":" + U + ".";
          }
          return "";
        }
      }
      var Ar = {};
      function Ln(E) {
        {
          var j = hr();
          if (!j) {
            var U = typeof E == "string" ? E : E.displayName || E.name;
            U && (j = `

Check the top-level render call using <` + U + ">.");
          }
          return j;
        }
      }
      function rn(E, j) {
        {
          if (!E._store || E._store.validated || E.key != null)
            return;
          E._store.validated = !0;
          var U = Ln(j);
          if (Ar[U])
            return;
          Ar[U] = !0;
          var Q = "";
          E && E._owner && E._owner !== wt.current && (Q = " It was passed a child from " + P(E._owner.type) + "."), Je(E), C('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', U, Q), Je(null);
        }
      }
      function nn(E, j) {
        {
          if (typeof E != "object")
            return;
          if (Array.isArray(E))
            for (var U = 0; U < E.length; U++) {
              var Q = E[U];
              Mn(Q) && rn(Q, j);
            }
          else if (Mn(E))
            E._store && (E._store.validated = !0);
          else if (E) {
            var be = D(E);
            if (typeof be == "function" && be !== E.entries)
              for (var De = be.call(E), ce; !(ce = De.next()).done; )
                Mn(ce.value) && rn(ce.value, j);
          }
        }
      }
      function Pv(E) {
        {
          var j = E.type;
          if (j == null || typeof j == "string")
            return;
          var U;
          if (typeof j == "function")
            U = j.propTypes;
          else if (typeof j == "object" && (j.$$typeof === l || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          j.$$typeof === h))
            U = j.propTypes;
          else
            return;
          if (U) {
            var Q = P(j);
            ue(U, E.props, "prop", Q, E);
          } else if (j.PropTypes !== void 0 && !Er) {
            Er = !0;
            var be = P(j);
            C("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", be || "Unknown");
          }
          typeof j.getDefaultProps == "function" && !j.getDefaultProps.isReactClassApproved && C("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Nv(E) {
        {
          for (var j = Object.keys(E.props), U = 0; U < j.length; U++) {
            var Q = j[U];
            if (Q !== "children" && Q !== "key") {
              Je(E), C("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Q), Je(null);
              break;
            }
          }
          E.ref !== null && (Je(E), C("Invalid attribute `ref` supplied to `React.Fragment`."), Je(null));
        }
      }
      function Jh(E, j, U, Q, be, De) {
        {
          var ce = A(E);
          if (!ce) {
            var Z = "";
            (E === void 0 || typeof E == "object" && E !== null && Object.keys(E).length === 0) && (Z += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var tt = Ht(be);
            tt ? Z += tt : Z += hr();
            var Vt;
            E === null ? Vt = "null" : Array.isArray(E) ? Vt = "array" : E !== void 0 && E.$$typeof === r ? (Vt = "<" + (P(E.type) || "Unknown") + " />", Z = " Did you accidentally export a JSX literal instead of a component?") : Vt = typeof E, C("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Vt, Z);
          }
          var Fr = Dt(E, j, U, be, De);
          if (Fr == null)
            return Fr;
          if (ce) {
            var Pn = j.children;
            if (Pn !== void 0)
              if (Q)
                if (Array.isArray(Pn)) {
                  for (var cl = 0; cl < Pn.length; cl++)
                    nn(Pn[cl], E);
                  Object.freeze && Object.freeze(Pn);
                } else
                  C("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                nn(Pn, E);
          }
          return E === t.Fragment ? Nv(Fr) : Pv(Fr), Fr;
        }
      }
      function Rv(E, j, U) {
        return Jh(E, j, U, !0);
      }
      function Iv(E, j, U) {
        return Jh(E, j, U, !1);
      }
      var $v = Iv, jv = Rv;
      t.jsx = $v, t.jsxs = jv;
    }();
  }(hl)), hl;
}
process.env.NODE_ENV === "production" ? tu.exports = t2() : tu.exports = r2();
var M = tu.exports;
const Xp = Hv(null), vt = () => {
  const t = Vv(Xp);
  if (t === null)
    throw new Error("CDO IDE Context has not been provided!");
  return t;
}, n2 = ({
  children: t,
  value: e
}) => /* @__PURE__ */ M.jsx(Xp.Provider, { value: e, children: t }), i2 = ["html", "css", "js", "json"], s2 = (t, e = i2) => new Set(e).has(t), gn = "0", Qp = (t = [], e) => t.reduce((r, n) => {
  if (!n.length)
    return r;
  const i = Object.values(e.folders).find(
    (s) => s.name === n && s.parentId === r
  );
  if (!i) {
    if (e.required)
      throw new Error(`Could not find folder ${t.join("/")}`);
    return gn;
  }
  return i.id;
}, gn), o2 = () => /* @__PURE__ */ M.jsx("div", { children: "No files are open. Choose a file from the browser to the left." }), a2 = () => /* @__PURE__ */ M.jsx("div", {}), l2 = (t) => t.EmptyEditorComponent ? t.EmptyEditorComponent : t.blankEmptyEditor ? a2 : o2, IP = () => ({ files: {}, folders: {} }), Zp = (t) => typeof t == "string" ? t : t instanceof Error ? t.message : "", u2 = ["html", "js", "json"], Ws = (t, e = u2) => new Set(e).has(t);
var c2 = Object.create, ga = Object.defineProperty, h2 = Object.getOwnPropertyDescriptor, f2 = Object.getOwnPropertyNames, d2 = Object.getPrototypeOf, p2 = Object.prototype.hasOwnProperty, m2 = (t, e) => () => (t && (e = t(t = 0)), e), ya = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), va = (t, e) => {
  for (var r in e)
    ga(t, r, { get: e[r], enumerable: !0 });
}, em = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of f2(e))
      !p2.call(t, i) && i !== r && ga(t, i, { get: () => e[i], enumerable: !(n = h2(e, i)) || n.enumerable });
  return t;
}, Ds = (t, e, r) => (r = t != null ? c2(d2(t)) : {}, em(e || !t || !t.__esModule ? ga(r, "default", { value: t, enumerable: !0 }) : r, t)), g2 = (t) => em(ga({}, "__esModule", { value: !0 }), t), y2 = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, Zh = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, ki = (t, e, r) => (y2(t, e, "access private method"), r), v2 = ya((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = e;
  function e() {
  }
  e.prototype = { diff: function(i, s) {
    var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = o.callback;
    typeof o == "function" && (a = o, o = {}), this.options = o;
    var l = this;
    function c(g) {
      return a ? (setTimeout(function() {
        a(void 0, g);
      }, 0), !0) : g;
    }
    i = this.castInput(i), s = this.castInput(s), i = this.removeEmpty(this.tokenize(i)), s = this.removeEmpty(this.tokenize(s));
    var u = s.length, h = i.length, f = 1, d = u + h;
    o.maxEditLength && (d = Math.min(d, o.maxEditLength));
    var p = [{ newPos: -1, components: [] }], m = this.extractCommon(p[0], s, i, 0);
    if (p[0].newPos + 1 >= u && m + 1 >= h)
      return c([{ value: this.join(s), count: s.length }]);
    function y() {
      for (var g = -1 * f; g <= f; g += 2) {
        var b = void 0, w = p[g - 1], D = p[g + 1], x = (D ? D.newPos : 0) - g;
        w && (p[g - 1] = void 0);
        var C = w && w.newPos + 1 < u, k = D && 0 <= x && x < h;
        if (!C && !k) {
          p[g] = void 0;
          continue;
        }
        if (!C || k && w.newPos < D.newPos ? (b = n(D), l.pushComponent(b.components, void 0, !0)) : (b = w, b.newPos++, l.pushComponent(b.components, !0, void 0)), x = l.extractCommon(b, s, i, g), b.newPos + 1 >= u && x + 1 >= h)
          return c(r(l, b.components, s, i, l.useLongestToken));
        p[g] = b;
      }
      f++;
    }
    if (a)
      (function g() {
        setTimeout(function() {
          if (f > d)
            return a();
          y() || g();
        }, 0);
      })();
    else
      for (; f <= d; ) {
        var v = y();
        if (v)
          return v;
      }
  }, pushComponent: function(i, s, o) {
    var a = i[i.length - 1];
    a && a.added === s && a.removed === o ? i[i.length - 1] = { count: a.count + 1, added: s, removed: o } : i.push({ count: 1, added: s, removed: o });
  }, extractCommon: function(i, s, o, a) {
    for (var l = s.length, c = o.length, u = i.newPos, h = u - a, f = 0; u + 1 < l && h + 1 < c && this.equals(s[u + 1], o[h + 1]); )
      u++, h++, f++;
    return f && i.components.push({ count: f }), i.newPos = u, h;
  }, equals: function(i, s) {
    return this.options.comparator ? this.options.comparator(i, s) : i === s || this.options.ignoreCase && i.toLowerCase() === s.toLowerCase();
  }, removeEmpty: function(i) {
    for (var s = [], o = 0; o < i.length; o++)
      i[o] && s.push(i[o]);
    return s;
  }, castInput: function(i) {
    return i;
  }, tokenize: function(i) {
    return i.split("");
  }, join: function(i) {
    return i.join("");
  } };
  function r(i, s, o, a, l) {
    for (var c = 0, u = s.length, h = 0, f = 0; c < u; c++) {
      var d = s[c];
      if (d.removed) {
        if (d.value = i.join(a.slice(f, f + d.count)), f += d.count, c && s[c - 1].added) {
          var p = s[c - 1];
          s[c - 1] = s[c], s[c] = p;
        }
      } else {
        if (!d.added && l) {
          var m = o.slice(h, h + d.count);
          m = m.map(function(v, g) {
            var b = a[f + g];
            return b.length > v.length ? b : v;
          }), d.value = i.join(m);
        } else
          d.value = i.join(o.slice(h, h + d.count));
        h += d.count, d.added || (f += d.count);
      }
    }
    var y = s[u - 1];
    return u > 1 && typeof y.value == "string" && (y.added || y.removed) && i.equals("", y.value) && (s[u - 2].value += y.value, s.pop()), s;
  }
  function n(i) {
    return { newPos: i.newPos, components: i.components.slice(0) };
  }
}), b2 = ya((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.diffArrays = i, t.arrayDiff = void 0;
  var e = r(v2());
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  var n = new e.default();
  t.arrayDiff = n, n.tokenize = function(s) {
    return s.slice();
  }, n.join = n.removeEmpty = function(s) {
    return s;
  };
  function i(s, o, a) {
    return n.diff(s, o, a);
  }
}), ba = ya((t, e) => {
  var r = new Proxy(String, { get: () => r });
  e.exports = r;
}), tm = {};
va(tm, { default: () => nm, shouldHighlight: () => rm });
var rm, nm, D2 = m2(() => {
  rm = () => !1, nm = String;
}), w2 = ya((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.codeFrameColumns = h, t.default = f;
  var e = (D2(), g2(tm)), r = i(ba(), !0);
  function n(d) {
    if (typeof WeakMap != "function")
      return null;
    var p = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap();
    return (n = function(y) {
      return y ? m : p;
    })(d);
  }
  function i(d, p) {
    if (!p && d && d.__esModule)
      return d;
    if (d === null || typeof d != "object" && typeof d != "function")
      return { default: d };
    var m = n(p);
    if (m && m.has(d))
      return m.get(d);
    var y = { __proto__: null }, v = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var g in d)
      if (g !== "default" && Object.prototype.hasOwnProperty.call(d, g)) {
        var b = v ? Object.getOwnPropertyDescriptor(d, g) : null;
        b && (b.get || b.set) ? Object.defineProperty(y, g, b) : y[g] = d[g];
      }
    return y.default = d, m && m.set(d, y), y;
  }
  var s;
  function o(d) {
    return d ? (s != null || (s = new r.default.constructor({ enabled: !0, level: 1 })), s) : r.default;
  }
  var a = !1;
  function l(d) {
    return { gutter: d.grey, marker: d.red.bold, message: d.red.bold };
  }
  var c = /\r\n|[\n\r\u2028\u2029]/;
  function u(d, p, m) {
    let y = Object.assign({ column: 0, line: -1 }, d.start), v = Object.assign({}, y, d.end), { linesAbove: g = 2, linesBelow: b = 3 } = m || {}, w = y.line, D = y.column, x = v.line, C = v.column, k = Math.max(w - (g + 1), 0), S = Math.min(p.length, x + b);
    w === -1 && (k = 0), x === -1 && (S = p.length);
    let A = x - w, _ = {};
    if (A)
      for (let N = 0; N <= A; N++) {
        let $ = N + w;
        if (!D)
          _[$] = !0;
        else if (N === 0) {
          let L = p[$ - 1].length;
          _[$] = [D, L - D + 1];
        } else if (N === A)
          _[$] = [0, C];
        else {
          let L = p[$ - N].length;
          _[$] = [0, L];
        }
      }
    else
      D === C ? D ? _[w] = [D, 0] : _[w] = !0 : _[w] = [D, C - D];
    return { start: k, end: S, markerLines: _ };
  }
  function h(d, p, m = {}) {
    let y = (m.highlightCode || m.forceColor) && (0, e.shouldHighlight)(m), v = o(m.forceColor), g = l(v), b = (_, N) => y ? _(N) : N, w = d.split(c), { start: D, end: x, markerLines: C } = u(p, w, m), k = p.start && typeof p.start.column == "number", S = String(x).length, A = (y ? (0, e.default)(d, m) : d).split(c, x).slice(D, x).map((_, N) => {
      let $ = D + 1 + N, L = ` ${` ${$}`.slice(-S)} |`, I = C[$], P = !C[$ + 1];
      if (I) {
        let G = "";
        if (Array.isArray(I)) {
          let re = _.slice(0, Math.max(I[0] - 1, 0)).replace(/[^\t]/g, " "), oe = I[1] || 1;
          G = [`
 `, b(g.gutter, L.replace(/\d/g, " ")), " ", re, b(g.marker, "^").repeat(oe)].join(""), P && m.message && (G += " " + b(g.message, m.message));
        }
        return [b(g.marker, ">"), b(g.gutter, L), _.length > 0 ? ` ${_}` : "", G].join("");
      } else
        return ` ${b(g.gutter, L)}${_.length > 0 ? ` ${_}` : ""}`;
    }).join(`
`);
    return m.message && !k && (A = `${" ".repeat(S + 1)}${m.message}
${A}`), y ? v.reset(A) : A;
  }
  function f(d, p, m, y = {}) {
    if (!a) {
      a = !0;
      let v = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      {
        let g = new Error(v);
        g.name = "DeprecationWarning", console.warn(new Error(v));
      }
    }
    return m = Math.max(m, 0), h(d, { start: { column: m, line: p } }, y);
  }
}), im = {};
va(im, { __debug: () => vw, check: () => gw, doc: () => qm, format: () => zm, formatWithCursor: () => Vm, getSupportInfo: () => yw, util: () => Hm, version: () => UD });
var x2 = (t, e, r, n) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
}, Da = x2, C2 = Ds(b2(), 1);
function k2(t) {
  let e = t.indexOf("\r");
  return e >= 0 ? t.charAt(e + 1) === `
` ? "crlf" : "cr" : "lf";
}
function bc(t) {
  switch (t) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function sm(t, e) {
  let r;
  switch (e) {
    case `
`:
      r = /\n/g;
      break;
    case "\r":
      r = /\r/g;
      break;
    case `\r
`:
      r = /\r\n/g;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(e)}.`);
  }
  let n = t.match(r);
  return n ? n.length : 0;
}
function S2(t) {
  return Da(!1, t, /\r\n?/g, `
`);
}
var An = "string", zr = "array", Fn = "cursor", vr = "indent", br = "align", Dr = "trim", st = "group", _t = "fill", gt = "if-break", wr = "indent-if-break", xr = "line-suffix", Cr = "line-suffix-boundary", je = "line", or = "label", Bt = "break-parent", om = /* @__PURE__ */ new Set([Fn, vr, br, Dr, st, _t, gt, wr, xr, Cr, je, or, Bt]);
function E2(t) {
  if (typeof t == "string")
    return An;
  if (Array.isArray(t))
    return zr;
  if (!t)
    return;
  let { type: e } = t;
  if (om.has(e))
    return e;
}
var Tn = E2, A2 = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function F2(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (Tn(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = A2([...om].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`;
}
var T2 = class extends Error {
  constructor(r) {
    super(F2(r));
    Tr(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, si = T2, ef = {};
function _2(t, e, r, n) {
  let i = [t];
  for (; i.length > 0; ) {
    let s = i.pop();
    if (s === ef) {
      r(i.pop());
      continue;
    }
    r && i.push(s, ef);
    let o = Tn(s);
    if (!o)
      throw new si(s);
    if ((e == null ? void 0 : e(s)) !== !1)
      switch (o) {
        case zr:
        case _t: {
          let a = o === zr ? s : s.parts;
          for (let l = a.length, c = l - 1; c >= 0; --c)
            i.push(a[c]);
          break;
        }
        case gt:
          i.push(s.flatContents, s.breakContents);
          break;
        case st:
          if (n && s.expandedStates)
            for (let a = s.expandedStates.length, l = a - 1; l >= 0; --l)
              i.push(s.expandedStates[l]);
          else
            i.push(s.contents);
          break;
        case br:
        case vr:
        case wr:
        case or:
        case xr:
          i.push(s.contents);
          break;
        case An:
        case Fn:
        case Dr:
        case Cr:
        case je:
        case Bt:
          break;
        default:
          throw new si(s);
      }
  }
}
var Dc = _2, B2 = () => {
}, O2 = B2;
function $o(t) {
  return { type: vr, contents: t };
}
function oi(t, e) {
  return { type: br, contents: e, n: t };
}
function am(t, e = {}) {
  return O2(e.expandedStates), { type: st, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function M2(t) {
  return oi(Number.NEGATIVE_INFINITY, t);
}
function L2(t) {
  return oi({ type: "root" }, t);
}
function P2(t) {
  return oi(-1, t);
}
function N2(t, e) {
  return am(t[0], { ...e, expandedStates: t });
}
function lm(t) {
  return { type: _t, parts: t };
}
function R2(t, e = "", r = {}) {
  return { type: gt, breakContents: t, flatContents: e, groupId: r.groupId };
}
function I2(t, e) {
  return { type: wr, contents: t, groupId: e.groupId, negate: e.negate };
}
function ru(t) {
  return { type: xr, contents: t };
}
var $2 = { type: Cr }, wa = { type: Bt }, j2 = { type: Dr }, wc = { type: je, hard: !0 }, um = { type: je, hard: !0, literal: !0 }, cm = { type: je }, W2 = { type: je, soft: !0 }, yn = [wc, wa], hm = [um, wa], nu = { type: Fn };
function fm(t, e) {
  let r = [];
  for (let n = 0; n < e.length; n++)
    n !== 0 && r.push(t), r.push(e[n]);
  return r;
}
function dm(t, e, r) {
  let n = t;
  if (e > 0) {
    for (let i = 0; i < Math.floor(e / r); ++i)
      n = $o(n);
    n = oi(e % r, n), n = oi(Number.NEGATIVE_INFINITY, n);
  }
  return n;
}
function q2(t, e) {
  return t ? { type: or, label: t, contents: e } : e;
}
function fr(t) {
  var e;
  if (!t)
    return "";
  if (Array.isArray(t)) {
    let r = [];
    for (let n of t)
      if (Array.isArray(n))
        r.push(...fr(n));
      else {
        let i = fr(n);
        i !== "" && r.push(i);
      }
    return r;
  }
  return t.type === gt ? { ...t, breakContents: fr(t.breakContents), flatContents: fr(t.flatContents) } : t.type === st ? { ...t, contents: fr(t.contents), expandedStates: (e = t.expandedStates) == null ? void 0 : e.map(fr) } : t.type === _t ? { type: "fill", parts: t.parts.map(fr) } : t.contents ? { ...t, contents: fr(t.contents) } : t;
}
function H2(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Set();
  return n(fr(t));
  function n(s, o, a) {
    var l, c;
    if (typeof s == "string")
      return JSON.stringify(s);
    if (Array.isArray(s)) {
      let u = s.map(n).filter(Boolean);
      return u.length === 1 ? u[0] : `[${u.join(", ")}]`;
    }
    if (s.type === je) {
      let u = ((l = a == null ? void 0 : a[o + 1]) == null ? void 0 : l.type) === Bt;
      return s.literal ? u ? "literalline" : "literallineWithoutBreakParent" : s.hard ? u ? "hardline" : "hardlineWithoutBreakParent" : s.soft ? "softline" : "line";
    }
    if (s.type === Bt)
      return ((c = a == null ? void 0 : a[o - 1]) == null ? void 0 : c.type) === je && a[o - 1].hard ? void 0 : "breakParent";
    if (s.type === Dr)
      return "trim";
    if (s.type === vr)
      return "indent(" + n(s.contents) + ")";
    if (s.type === br)
      return s.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n(s.contents) + ")" : s.n < 0 ? "dedent(" + n(s.contents) + ")" : s.n.type === "root" ? "markAsRoot(" + n(s.contents) + ")" : "align(" + JSON.stringify(s.n) + ", " + n(s.contents) + ")";
    if (s.type === gt)
      return "ifBreak(" + n(s.breakContents) + (s.flatContents ? ", " + n(s.flatContents) : "") + (s.groupId ? (s.flatContents ? "" : ', ""') + `, { groupId: ${i(s.groupId)} }` : "") + ")";
    if (s.type === wr) {
      let u = [];
      s.negate && u.push("negate: true"), s.groupId && u.push(`groupId: ${i(s.groupId)}`);
      let h = u.length > 0 ? `, { ${u.join(", ")} }` : "";
      return `indentIfBreak(${n(s.contents)}${h})`;
    }
    if (s.type === st) {
      let u = [];
      s.break && s.break !== "propagated" && u.push("shouldBreak: true"), s.id && u.push(`id: ${i(s.id)}`);
      let h = u.length > 0 ? `, { ${u.join(", ")} }` : "";
      return s.expandedStates ? `conditionalGroup([${s.expandedStates.map((f) => n(f)).join(",")}]${h})` : `group(${n(s.contents)}${h})`;
    }
    if (s.type === _t)
      return `fill([${s.parts.map((u) => n(u)).join(", ")}])`;
    if (s.type === xr)
      return "lineSuffix(" + n(s.contents) + ")";
    if (s.type === Cr)
      return "lineSuffixBoundary";
    if (s.type === or)
      return `label(${JSON.stringify(s.label)}, ${n(s.contents)})`;
    throw new Error("Unknown doc type " + s.type);
  }
  function i(s) {
    if (typeof s != "symbol")
      return JSON.stringify(String(s));
    if (s in e)
      return e[s];
    let o = s.description || "symbol";
    for (let a = 0; ; a++) {
      let l = o + (a > 0 ? ` #${a}` : "");
      if (!r.has(l))
        return r.add(l), e[s] = `Symbol.for(${JSON.stringify(l)})`;
    }
  }
}
var V2 = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, _e = V2, z2 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function U2(t) {
  return t === 12288 || t >= 65281 && t <= 65376 || t >= 65504 && t <= 65510;
}
function G2(t) {
  return t >= 4352 && t <= 4447 || t === 8986 || t === 8987 || t === 9001 || t === 9002 || t >= 9193 && t <= 9196 || t === 9200 || t === 9203 || t === 9725 || t === 9726 || t === 9748 || t === 9749 || t >= 9800 && t <= 9811 || t === 9855 || t === 9875 || t === 9889 || t === 9898 || t === 9899 || t === 9917 || t === 9918 || t === 9924 || t === 9925 || t === 9934 || t === 9940 || t === 9962 || t === 9970 || t === 9971 || t === 9973 || t === 9978 || t === 9981 || t === 9989 || t === 9994 || t === 9995 || t === 10024 || t === 10060 || t === 10062 || t >= 10067 && t <= 10069 || t === 10071 || t >= 10133 && t <= 10135 || t === 10160 || t === 10175 || t === 11035 || t === 11036 || t === 11088 || t === 11093 || t >= 11904 && t <= 11929 || t >= 11931 && t <= 12019 || t >= 12032 && t <= 12245 || t >= 12272 && t <= 12287 || t >= 12289 && t <= 12350 || t >= 12353 && t <= 12438 || t >= 12441 && t <= 12543 || t >= 12549 && t <= 12591 || t >= 12593 && t <= 12686 || t >= 12688 && t <= 12771 || t >= 12783 && t <= 12830 || t >= 12832 && t <= 12871 || t >= 12880 && t <= 19903 || t >= 19968 && t <= 42124 || t >= 42128 && t <= 42182 || t >= 43360 && t <= 43388 || t >= 44032 && t <= 55203 || t >= 63744 && t <= 64255 || t >= 65040 && t <= 65049 || t >= 65072 && t <= 65106 || t >= 65108 && t <= 65126 || t >= 65128 && t <= 65131 || t >= 94176 && t <= 94180 || t === 94192 || t === 94193 || t >= 94208 && t <= 100343 || t >= 100352 && t <= 101589 || t >= 101632 && t <= 101640 || t >= 110576 && t <= 110579 || t >= 110581 && t <= 110587 || t === 110589 || t === 110590 || t >= 110592 && t <= 110882 || t === 110898 || t >= 110928 && t <= 110930 || t === 110933 || t >= 110948 && t <= 110951 || t >= 110960 && t <= 111355 || t === 126980 || t === 127183 || t === 127374 || t >= 127377 && t <= 127386 || t >= 127488 && t <= 127490 || t >= 127504 && t <= 127547 || t >= 127552 && t <= 127560 || t === 127568 || t === 127569 || t >= 127584 && t <= 127589 || t >= 127744 && t <= 127776 || t >= 127789 && t <= 127797 || t >= 127799 && t <= 127868 || t >= 127870 && t <= 127891 || t >= 127904 && t <= 127946 || t >= 127951 && t <= 127955 || t >= 127968 && t <= 127984 || t === 127988 || t >= 127992 && t <= 128062 || t === 128064 || t >= 128066 && t <= 128252 || t >= 128255 && t <= 128317 || t >= 128331 && t <= 128334 || t >= 128336 && t <= 128359 || t === 128378 || t === 128405 || t === 128406 || t === 128420 || t >= 128507 && t <= 128591 || t >= 128640 && t <= 128709 || t === 128716 || t >= 128720 && t <= 128722 || t >= 128725 && t <= 128727 || t >= 128732 && t <= 128735 || t === 128747 || t === 128748 || t >= 128756 && t <= 128764 || t >= 128992 && t <= 129003 || t === 129008 || t >= 129292 && t <= 129338 || t >= 129340 && t <= 129349 || t >= 129351 && t <= 129535 || t >= 129648 && t <= 129660 || t >= 129664 && t <= 129672 || t >= 129680 && t <= 129725 || t >= 129727 && t <= 129733 || t >= 129742 && t <= 129755 || t >= 129760 && t <= 129768 || t >= 129776 && t <= 129784 || t >= 131072 && t <= 196605 || t >= 196608 && t <= 262141;
}
var K2 = (t) => !(U2(t) || G2(t)), Y2 = /[^\x20-\x7F]/;
function J2(t) {
  if (!t)
    return 0;
  if (!Y2.test(t))
    return t.length;
  t = t.replace(z2(), "  ");
  let e = 0;
  for (let r of t) {
    let n = r.codePointAt(0);
    n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (e += K2(n) ? 1 : 2);
  }
  return e;
}
var xc = J2, X2 = (t) => {
  if (Array.isArray(t))
    return t;
  if (t.type !== _t)
    throw new Error(`Expect doc to be 'array' or '${_t}'.`);
  return t.parts;
};
function xa(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return n(t);
  function n(s) {
    if (r.has(s))
      return r.get(s);
    let o = i(s);
    return r.set(s, o), o;
  }
  function i(s) {
    switch (Tn(s)) {
      case zr:
        return e(s.map(n));
      case _t:
        return e({ ...s, parts: s.parts.map(n) });
      case gt:
        return e({ ...s, breakContents: n(s.breakContents), flatContents: n(s.flatContents) });
      case st: {
        let { expandedStates: o, contents: a } = s;
        return o ? (o = o.map(n), a = o[0]) : a = n(a), e({ ...s, contents: a, expandedStates: o });
      }
      case br:
      case vr:
      case wr:
      case or:
      case xr:
        return e({ ...s, contents: n(s.contents) });
      case An:
      case Fn:
      case Dr:
      case Cr:
      case je:
      case Bt:
        return e(s);
      default:
        throw new si(s);
    }
  }
}
function Cc(t, e, r) {
  let n = r, i = !1;
  function s(o) {
    if (i)
      return !1;
    let a = e(o);
    a !== void 0 && (i = !0, n = a);
  }
  return Dc(t, s), n;
}
function Q2(t) {
  if (t.type === st && t.break || t.type === je && t.hard || t.type === Bt)
    return !0;
}
function Z2(t) {
  return Cc(t, Q2, !1);
}
function tf(t) {
  if (t.length > 0) {
    let e = _e(!1, t, -1);
    !e.expandedStates && !e.break && (e.break = "propagated");
  }
  return null;
}
function eb(t) {
  let e = /* @__PURE__ */ new Set(), r = [];
  function n(s) {
    if (s.type === Bt && tf(r), s.type === st) {
      if (r.push(s), e.has(s))
        return !1;
      e.add(s);
    }
  }
  function i(s) {
    s.type === st && r.pop().break && tf(r);
  }
  Dc(t, n, i, !0);
}
function tb(t) {
  return t.type === je && !t.hard ? t.soft ? "" : " " : t.type === gt ? t.flatContents : t;
}
function rb(t) {
  return xa(t, tb);
}
function rf(t) {
  for (t = [...t]; t.length >= 2 && _e(!1, t, -2).type === je && _e(!1, t, -1).type === Bt; )
    t.length -= 2;
  if (t.length > 0) {
    let e = zi(_e(!1, t, -1));
    t[t.length - 1] = e;
  }
  return t;
}
function zi(t) {
  switch (Tn(t)) {
    case br:
    case vr:
    case wr:
    case st:
    case xr:
    case or: {
      let e = zi(t.contents);
      return { ...t, contents: e };
    }
    case gt:
      return { ...t, breakContents: zi(t.breakContents), flatContents: zi(t.flatContents) };
    case _t:
      return { ...t, parts: rf(t.parts) };
    case zr:
      return rf(t);
    case An:
      return t.replace(/[\n\r]*$/, "");
    case Fn:
    case Dr:
    case Cr:
    case je:
    case Bt:
      break;
    default:
      throw new si(t);
  }
  return t;
}
function pm(t) {
  return zi(ib(t));
}
function nb(t) {
  switch (Tn(t)) {
    case _t:
      if (t.parts.every((e) => e === ""))
        return "";
      break;
    case st:
      if (!t.contents && !t.id && !t.break && !t.expandedStates)
        return "";
      if (t.contents.type === st && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates)
        return t.contents;
      break;
    case br:
    case vr:
    case wr:
    case xr:
      if (!t.contents)
        return "";
      break;
    case gt:
      if (!t.flatContents && !t.breakContents)
        return "";
      break;
    case zr: {
      let e = [];
      for (let r of t) {
        if (!r)
          continue;
        let [n, ...i] = Array.isArray(r) ? r : [r];
        typeof n == "string" && typeof _e(!1, e, -1) == "string" ? e[e.length - 1] += n : e.push(n), e.push(...i);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case An:
    case Fn:
    case Dr:
    case Cr:
    case je:
    case or:
    case Bt:
      break;
    default:
      throw new si(t);
  }
  return t;
}
function ib(t) {
  return xa(t, (e) => nb(e));
}
function sb(t, e = hm) {
  return xa(t, (r) => typeof r == "string" ? fm(e, r.split(`
`)) : r);
}
function ob(t) {
  if (t.type === je)
    return !0;
}
function ab(t) {
  return Cc(t, ob, !1);
}
function mm(t, e) {
  return t.type === or ? { ...t, contents: e(t.contents) } : e(t);
}
var rt = Symbol("MODE_BREAK"), Yt = Symbol("MODE_FLAT"), Ui = Symbol("cursor");
function gm() {
  return { value: "", length: 0, queue: [] };
}
function lb(t, e) {
  return iu(t, { type: "indent" }, e);
}
function ub(t, e, r) {
  return e === Number.NEGATIVE_INFINITY ? t.root || gm() : e < 0 ? iu(t, { type: "dedent" }, r) : e ? e.type === "root" ? { ...t, root: t } : iu(t, { type: typeof e == "string" ? "stringAlign" : "numberAlign", n: e }, r) : t;
}
function iu(t, e, r) {
  let n = e.type === "dedent" ? t.queue.slice(0, -1) : [...t.queue, e], i = "", s = 0, o = 0, a = 0;
  for (let p of n)
    switch (p.type) {
      case "indent":
        u(), r.useTabs ? l(1) : c(r.tabWidth);
        break;
      case "stringAlign":
        u(), i += p.n, s += p.n.length;
        break;
      case "numberAlign":
        o += 1, a += p.n;
        break;
      default:
        throw new Error(`Unexpected type '${p.type}'`);
    }
  return f(), { ...t, value: i, length: s, queue: n };
  function l(p) {
    i += "	".repeat(p), s += r.tabWidth * p;
  }
  function c(p) {
    i += " ".repeat(p), s += p;
  }
  function u() {
    r.useTabs ? h() : f();
  }
  function h() {
    o > 0 && l(o), d();
  }
  function f() {
    a > 0 && c(a), d();
  }
  function d() {
    o = 0, a = 0;
  }
}
function su(t) {
  let e = 0, r = 0, n = t.length;
  e:
    for (; n--; ) {
      let i = t[n];
      if (i === Ui) {
        r++;
        continue;
      }
      for (let s = i.length - 1; s >= 0; s--) {
        let o = i[s];
        if (o === " " || o === "	")
          e++;
        else {
          t[n] = i.slice(0, s + 1);
          break e;
        }
      }
    }
  if (e > 0 || r > 0)
    for (t.length = n + 1; r-- > 0; )
      t.push(Ui);
  return e;
}
function qs(t, e, r, n, i, s) {
  if (r === Number.POSITIVE_INFINITY)
    return !0;
  let o = e.length, a = [t], l = [];
  for (; r >= 0; ) {
    if (a.length === 0) {
      if (o === 0)
        return !0;
      a.push(e[--o]);
      continue;
    }
    let { mode: c, doc: u } = a.pop();
    switch (Tn(u)) {
      case An:
        l.push(u), r -= xc(u);
        break;
      case zr:
      case _t: {
        let h = X2(u);
        for (let f = h.length - 1; f >= 0; f--)
          a.push({ mode: c, doc: h[f] });
        break;
      }
      case vr:
      case br:
      case wr:
      case or:
        a.push({ mode: c, doc: u.contents });
        break;
      case Dr:
        r += su(l);
        break;
      case st: {
        if (s && u.break)
          return !1;
        let h = u.break ? rt : c, f = u.expandedStates && h === rt ? _e(!1, u.expandedStates, -1) : u.contents;
        a.push({ mode: h, doc: f });
        break;
      }
      case gt: {
        let h = (u.groupId ? i[u.groupId] || Yt : c) === rt ? u.breakContents : u.flatContents;
        h && a.push({ mode: c, doc: h });
        break;
      }
      case je:
        if (c === rt || u.hard)
          return !0;
        u.soft || (l.push(" "), r--);
        break;
      case xr:
        n = !0;
        break;
      case Cr:
        if (n)
          return !1;
        break;
    }
  }
  return !1;
}
function Ca(t, e) {
  let r = {}, n = e.printWidth, i = bc(e.endOfLine), s = 0, o = [{ ind: gm(), mode: rt, doc: t }], a = [], l = !1, c = [], u = 0;
  for (eb(t); o.length > 0; ) {
    let { ind: f, mode: d, doc: p } = o.pop();
    switch (Tn(p)) {
      case An: {
        let m = i !== `
` ? Da(!1, p, `
`, i) : p;
        a.push(m), o.length > 0 && (s += xc(m));
        break;
      }
      case zr:
        for (let m = p.length - 1; m >= 0; m--)
          o.push({ ind: f, mode: d, doc: p[m] });
        break;
      case Fn:
        if (u >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        a.push(Ui), u++;
        break;
      case vr:
        o.push({ ind: lb(f, e), mode: d, doc: p.contents });
        break;
      case br:
        o.push({ ind: ub(f, p.n, e), mode: d, doc: p.contents });
        break;
      case Dr:
        s -= su(a);
        break;
      case st:
        switch (d) {
          case Yt:
            if (!l) {
              o.push({ ind: f, mode: p.break ? rt : Yt, doc: p.contents });
              break;
            }
          case rt: {
            l = !1;
            let m = { ind: f, mode: Yt, doc: p.contents }, y = n - s, v = c.length > 0;
            if (!p.break && qs(m, o, y, v, r))
              o.push(m);
            else if (p.expandedStates) {
              let g = _e(!1, p.expandedStates, -1);
              if (p.break) {
                o.push({ ind: f, mode: rt, doc: g });
                break;
              } else
                for (let b = 1; b < p.expandedStates.length + 1; b++)
                  if (b >= p.expandedStates.length) {
                    o.push({ ind: f, mode: rt, doc: g });
                    break;
                  } else {
                    let w = p.expandedStates[b], D = { ind: f, mode: Yt, doc: w };
                    if (qs(D, o, y, v, r)) {
                      o.push(D);
                      break;
                    }
                  }
            } else
              o.push({ ind: f, mode: rt, doc: p.contents });
            break;
          }
        }
        p.id && (r[p.id] = _e(!1, o, -1).mode);
        break;
      case _t: {
        let m = n - s, { parts: y } = p;
        if (y.length === 0)
          break;
        let [v, g] = y, b = { ind: f, mode: Yt, doc: v }, w = { ind: f, mode: rt, doc: v }, D = qs(b, [], m, c.length > 0, r, !0);
        if (y.length === 1) {
          D ? o.push(b) : o.push(w);
          break;
        }
        let x = { ind: f, mode: Yt, doc: g }, C = { ind: f, mode: rt, doc: g };
        if (y.length === 2) {
          D ? o.push(x, b) : o.push(C, w);
          break;
        }
        y.splice(0, 2);
        let k = { ind: f, mode: d, doc: lm(y) }, S = y[0];
        qs({ ind: f, mode: Yt, doc: [v, g, S] }, [], m, c.length > 0, r, !0) ? o.push(k, x, b) : D ? o.push(k, C, b) : o.push(k, C, w);
        break;
      }
      case gt:
      case wr: {
        let m = p.groupId ? r[p.groupId] : d;
        if (m === rt) {
          let y = p.type === gt ? p.breakContents : p.negate ? p.contents : $o(p.contents);
          y && o.push({ ind: f, mode: d, doc: y });
        }
        if (m === Yt) {
          let y = p.type === gt ? p.flatContents : p.negate ? $o(p.contents) : p.contents;
          y && o.push({ ind: f, mode: d, doc: y });
        }
        break;
      }
      case xr:
        c.push({ ind: f, mode: d, doc: p.contents });
        break;
      case Cr:
        c.length > 0 && o.push({ ind: f, mode: d, doc: wc });
        break;
      case je:
        switch (d) {
          case Yt:
            if (p.hard)
              l = !0;
            else {
              p.soft || (a.push(" "), s += 1);
              break;
            }
          case rt:
            if (c.length > 0) {
              o.push({ ind: f, mode: d, doc: p }, ...c.reverse()), c.length = 0;
              break;
            }
            p.literal ? f.root ? (a.push(i, f.root.value), s = f.root.length) : (a.push(i), s = 0) : (s -= su(a), a.push(i + f.value), s = f.length);
            break;
        }
        break;
      case or:
        o.push({ ind: f, mode: d, doc: p.contents });
        break;
      case Bt:
        break;
      default:
        throw new si(p);
    }
    o.length === 0 && c.length > 0 && (o.push(...c.reverse()), c.length = 0);
  }
  let h = a.indexOf(Ui);
  if (h !== -1) {
    let f = a.indexOf(Ui, h + 1), d = a.slice(0, h).join(""), p = a.slice(h + 1, f).join(""), m = a.slice(f + 1).join("");
    return { formatted: d + p + m, cursorNodeStart: d.length, cursorNodeText: p };
  }
  return { formatted: a.join("") };
}
function cb(t, e, r = 0) {
  let n = 0;
  for (let i = r; i < t.length; ++i)
    t[i] === "	" ? n = n + e - n % e : n++;
  return n;
}
var kc = cb, wo, ou, Ri, xo, hb = class {
  constructor(e) {
    Zh(this, wo), Zh(this, Ri), this.stack = [e];
  }
  get key() {
    let { stack: e, siblings: r } = this;
    return _e(!1, e, r === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : _e(!1, this.stack, -2);
  }
  get node() {
    return _e(!1, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: e } = this, r = _e(!1, e, -3);
    return Array.isArray(r) ? r : null;
  }
  get next() {
    let { siblings: e } = this;
    return e === null ? null : e[this.index + 1];
  }
  get previous() {
    let { siblings: e } = this;
    return e === null ? null : e[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: e, index: r } = this;
    return e !== null && r === e.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...ki(this, Ri, xo).call(this)];
  }
  getName() {
    let { stack: e } = this, { length: r } = e;
    return r > 1 ? _e(!1, e, -2) : null;
  }
  getValue() {
    return _e(!1, this.stack, -1);
  }
  getNode(e = 0) {
    let r = ki(this, wo, ou).call(this, e);
    return r === -1 ? null : this.stack[r];
  }
  getParentNode(e = 0) {
    return this.getNode(e + 1);
  }
  call(e, ...r) {
    let { stack: n } = this, { length: i } = n, s = _e(!1, n, -1);
    for (let o of r)
      s = s[o], n.push(o, s);
    try {
      return e(this);
    } finally {
      n.length = i;
    }
  }
  callParent(e, r = 0) {
    let n = ki(this, wo, ou).call(this, r + 1), i = this.stack.splice(n + 1);
    try {
      return e(this);
    } finally {
      this.stack.push(...i);
    }
  }
  each(e, ...r) {
    let { stack: n } = this, { length: i } = n, s = _e(!1, n, -1);
    for (let o of r)
      s = s[o], n.push(o, s);
    try {
      for (let o = 0; o < s.length; ++o)
        n.push(o, s[o]), e(this, o, s), n.length -= 2;
    } finally {
      n.length = i;
    }
  }
  map(e, ...r) {
    let n = [];
    return this.each((i, s, o) => {
      n[s] = e(i, s, o);
    }, ...r), n;
  }
  match(...e) {
    let r = this.stack.length - 1, n = null, i = this.stack[r--];
    for (let s of e) {
      if (i === void 0)
        return !1;
      let o = null;
      if (typeof n == "number" && (o = n, n = this.stack[r--], i = this.stack[r--]), s && !s(i, n, o))
        return !1;
      n = this.stack[r--], i = this.stack[r--];
    }
    return !0;
  }
  findAncestor(e) {
    for (let r of ki(this, Ri, xo).call(this))
      if (e(r))
        return r;
  }
  hasAncestor(e) {
    for (let r of ki(this, Ri, xo).call(this))
      if (e(r))
        return !0;
    return !1;
  }
};
wo = /* @__PURE__ */ new WeakSet(), ou = function(t) {
  let { stack: e } = this;
  for (let r = e.length - 1; r >= 0; r -= 2)
    if (!Array.isArray(e[r]) && --t < 0)
      return r;
  return -1;
}, Ri = /* @__PURE__ */ new WeakSet(), xo = function* () {
  let { stack: t } = this;
  for (let e = t.length - 3; e >= 0; e -= 2) {
    let r = t[e];
    Array.isArray(r) || (yield r);
  }
};
var fb = hb, ym = new Proxy(() => {
}, { get: () => ym }), au = ym;
function db(t) {
  return t !== null && typeof t == "object";
}
var pb = db;
function* vm(t, e) {
  let { getVisitorKeys: r, filter: n = () => !0 } = e, i = (s) => pb(s) && n(s);
  for (let s of r(t)) {
    let o = t[s];
    if (Array.isArray(o))
      for (let a of o)
        i(a) && (yield a);
    else
      i(o) && (yield o);
  }
}
function* mb(t, e) {
  let r = [t];
  for (let n = 0; n < r.length; n++) {
    let i = r[n];
    for (let s of vm(i, e))
      yield s, r.push(s);
  }
}
function ws(t) {
  return (e, r, n) => {
    let i = !!(n != null && n.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, o = r;
    for (; o >= 0 && o < s; ) {
      let a = e.charAt(o);
      if (t instanceof RegExp) {
        if (!t.test(a))
          return o;
      } else if (!t.includes(a))
        return o;
      i ? o-- : o++;
    }
    return o === -1 || o === s ? o : !1;
  };
}
var gb = ws(/\s/), Ur = ws(" 	"), bm = ws(",; 	"), Dm = ws(/[^\n\r]/);
function yb(t, e, r) {
  let n = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let i = t.charAt(e);
  if (n) {
    if (t.charAt(e - 1) === "\r" && i === `
`)
      return e - 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e - 1;
  } else {
    if (i === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e + 1;
  }
  return e;
}
var bn = yb;
function vb(t, e, r = {}) {
  let n = Ur(t, r.backwards ? e - 1 : e, r), i = bn(t, n, r);
  return n !== i;
}
var Wr = vb;
function bb(t) {
  return Array.isArray(t) && t.length > 0;
}
var Db = bb, wm = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]), wb = (t) => Object.keys(t).filter((e) => !wm.has(e));
function xb(t) {
  return t ? (e) => t(e, wm) : wb;
}
var ka = xb;
function Cb(t) {
  let e = t.type || t.kind || "(unknown type)", r = String(t.name || t.id && (typeof t.id == "object" ? t.id.name : t.id) || t.key && (typeof t.key == "object" ? t.key.name : t.key) || t.value && (typeof t.value == "object" ? "" : String(t.value)) || t.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + "…"), e + (r ? " " + r : "");
}
function Sc(t, e) {
  (t.comments ?? (t.comments = [])).push(e), e.printed = !1, e.nodeDescription = Cb(t);
}
function Gn(t, e) {
  e.leading = !0, e.trailing = !1, Sc(t, e);
}
function an(t, e, r) {
  e.leading = !1, e.trailing = !1, r && (e.marker = r), Sc(t, e);
}
function Kn(t, e) {
  e.leading = !1, e.trailing = !0, Sc(t, e);
}
var fl = /* @__PURE__ */ new WeakMap();
function Ec(t, e) {
  if (fl.has(t))
    return fl.get(t);
  let { printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: i }, locStart: s, locEnd: o } = e;
  if (!n)
    return [];
  let a = ((r == null ? void 0 : r(t, e)) ?? [...vm(t, { getVisitorKeys: ka(i) })]).flatMap((l) => n(l) ? [l] : Ec(l, e));
  return a.sort((l, c) => s(l) - s(c) || o(l) - o(c)), fl.set(t, a), a;
}
function xm(t, e, r, n) {
  let { locStart: i, locEnd: s } = r, o = i(e), a = s(e), l = Ec(t, r), c, u, h = 0, f = l.length;
  for (; h < f; ) {
    let d = h + f >> 1, p = l[d], m = i(p), y = s(p);
    if (m <= o && a <= y)
      return xm(p, e, r, p);
    if (y <= o) {
      c = p, h = d + 1;
      continue;
    }
    if (a <= m) {
      u = p, f = d;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((n == null ? void 0 : n.type) === "TemplateLiteral") {
    let { quasis: d } = n, p = pl(d, e, r);
    c && pl(d, c, r) !== p && (c = null), u && pl(d, u, r) !== p && (u = null);
  }
  return { enclosingNode: n, precedingNode: c, followingNode: u };
}
var dl = () => !1;
function kb(t, e) {
  let { comments: r } = t;
  if (delete t.comments, !Db(r) || !e.printer.canAttachComment)
    return;
  let n = [], { locStart: i, locEnd: s, printer: { experimentalFeatures: { avoidAstMutation: o = !1 } = {}, handleComments: a = {} }, originalText: l } = e, { ownLine: c = dl, endOfLine: u = dl, remaining: h = dl } = a, f = r.map((d, p) => ({ ...xm(t, d, e), comment: d, text: l, options: e, ast: t, isLastComment: r.length - 1 === p }));
  for (let [d, p] of f.entries()) {
    let { comment: m, precedingNode: y, enclosingNode: v, followingNode: g, text: b, options: w, ast: D, isLastComment: x } = p;
    if (w.parser === "json" || w.parser === "json5" || w.parser === "jsonc" || w.parser === "__js_expression" || w.parser === "__ts_expression" || w.parser === "__vue_expression" || w.parser === "__vue_ts_expression") {
      if (i(m) - i(D) <= 0) {
        Gn(D, m);
        continue;
      }
      if (s(m) - s(D) >= 0) {
        Kn(D, m);
        continue;
      }
    }
    let C;
    if (o ? C = [p] : (m.enclosingNode = v, m.precedingNode = y, m.followingNode = g, C = [m, b, w, D, x]), Sb(b, w, f, d))
      m.placement = "ownLine", c(...C) || (g ? Gn(g, m) : y ? Kn(y, m) : an(v || D, m));
    else if (Eb(b, w, f, d))
      m.placement = "endOfLine", u(...C) || (y ? Kn(y, m) : g ? Gn(g, m) : an(v || D, m));
    else if (m.placement = "remaining", !h(...C))
      if (y && g) {
        let k = n.length;
        k > 0 && n[k - 1].followingNode !== g && nf(n, w), n.push(p);
      } else
        y ? Kn(y, m) : g ? Gn(g, m) : an(v || D, m);
  }
  if (nf(n, e), !o)
    for (let d of r)
      delete d.precedingNode, delete d.enclosingNode, delete d.followingNode;
}
var Cm = (t) => !/[\S\n\u2028\u2029]/.test(t);
function Sb(t, e, r, n) {
  let { comment: i, precedingNode: s } = r[n], { locStart: o, locEnd: a } = e, l = o(i);
  if (s)
    for (let c = n - 1; c >= 0; c--) {
      let { comment: u, precedingNode: h } = r[c];
      if (h !== s || !Cm(t.slice(a(u), l)))
        break;
      l = o(u);
    }
  return Wr(t, l, { backwards: !0 });
}
function Eb(t, e, r, n) {
  let { comment: i, followingNode: s } = r[n], { locStart: o, locEnd: a } = e, l = a(i);
  if (s)
    for (let c = n + 1; c < r.length; c++) {
      let { comment: u, followingNode: h } = r[c];
      if (h !== s || !Cm(t.slice(l, o(u))))
        break;
      l = a(u);
    }
  return Wr(t, l);
}
function nf(t, e) {
  var r, n;
  let i = t.length;
  if (i === 0)
    return;
  let { precedingNode: s, followingNode: o } = t[0], a = e.locStart(o), l;
  for (l = i; l > 0; --l) {
    let { comment: c, precedingNode: u, followingNode: h } = t[l - 1];
    au.strictEqual(u, s), au.strictEqual(h, o);
    let f = e.originalText.slice(e.locEnd(c), a);
    if (((n = (r = e.printer).isGap) == null ? void 0 : n.call(r, f, e)) ?? /^[\s(]*$/.test(f))
      a = e.locStart(c);
    else
      break;
  }
  for (let [c, { comment: u }] of t.entries())
    c < l ? Kn(s, u) : Gn(o, u);
  for (let c of [s, o])
    c.comments && c.comments.length > 1 && c.comments.sort((u, h) => e.locStart(u) - e.locStart(h));
  t.length = 0;
}
function pl(t, e, r) {
  let n = r.locStart(e) - 1;
  for (let i = 1; i < t.length; ++i)
    if (n < r.locStart(t[i]))
      return i - 1;
  return 0;
}
function Ab(t, e) {
  let r = e - 1;
  r = Ur(t, r, { backwards: !0 }), r = bn(t, r, { backwards: !0 }), r = Ur(t, r, { backwards: !0 });
  let n = bn(t, r, { backwards: !0 });
  return r !== n;
}
var Ac = Ab;
function km(t, e) {
  let r = t.node;
  return r.printed = !0, e.printer.printComment(t, e);
}
function Fb(t, e) {
  var r;
  let n = t.node, i = [km(t, e)], { printer: s, originalText: o, locStart: a, locEnd: l } = e;
  if ((r = s.isBlockComment) != null && r.call(s, n)) {
    let u = Wr(o, l(n)) ? Wr(o, a(n), { backwards: !0 }) ? yn : cm : " ";
    i.push(u);
  } else
    i.push(yn);
  let c = bn(o, Ur(o, l(n)));
  return c !== !1 && Wr(o, c) && i.push(yn), i;
}
function Tb(t, e, r) {
  var n;
  let i = t.node, s = km(t, e), { printer: o, originalText: a, locStart: l } = e, c = (n = o.isBlockComment) == null ? void 0 : n.call(o, i);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || Wr(a, l(i), { backwards: !0 })) {
    let u = Ac(a, l(i));
    return { doc: ru([yn, u ? yn : "", s]), isBlock: c, hasLineSuffix: !0 };
  }
  return !c || r != null && r.hasLineSuffix ? { doc: [ru([" ", s]), wa], isBlock: c, hasLineSuffix: !0 } : { doc: [" ", s], isBlock: c, hasLineSuffix: !1 };
}
function _b(t, e) {
  let r = t.node;
  if (!r)
    return {};
  let n = e[Symbol.for("printedComments")];
  if ((r.comments || []).filter((a) => !n.has(a)).length === 0)
    return { leading: "", trailing: "" };
  let i = [], s = [], o;
  return t.each(() => {
    let a = t.node;
    if (n != null && n.has(a))
      return;
    let { leading: l, trailing: c } = a;
    l ? i.push(Fb(t, e)) : c && (o = Tb(t, e, o), s.push(o.doc));
  }, "comments"), { leading: i, trailing: s };
}
function Bb(t, e, r) {
  let { leading: n, trailing: i } = _b(t, r);
  return !n && !i ? e : mm(e, (s) => [n, s, i]);
}
function Ob(t) {
  let { [Symbol.for("comments")]: e, [Symbol.for("printedComments")]: r } = t;
  for (let n of e) {
    if (!n.printed && !r.has(n))
      throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
    delete n.printed;
  }
}
var Sm = class extends Error {
  constructor() {
    super(...arguments);
    Tr(this, "name", "ConfigError");
  }
}, sf = class extends Error {
  constructor() {
    super(...arguments);
    Tr(this, "name", "UndefinedParserError");
  }
}, Mb = { cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (t) => typeof t == "string" || typeof t == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }] }, plugins: { type: "path", array: !0, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (t) => typeof t == "string" || typeof t == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: !1, description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: !1, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function Em({ plugins: t = [], showDeprecated: e = !1 } = {}) {
  let r = t.flatMap((i) => i.languages ?? []), n = [];
  for (let i of Pb(Object.assign({}, ...t.map(({ options: s }) => s), Mb)))
    !e && i.deprecated || (Array.isArray(i.choices) && (e || (i.choices = i.choices.filter((s) => !s.deprecated)), i.name === "parser" && (i.choices = [...i.choices, ...Lb(i.choices, r, t)])), i.pluginDefaults = Object.fromEntries(t.filter((s) => {
      var o;
      return ((o = s.defaultOptions) == null ? void 0 : o[i.name]) !== void 0;
    }).map((s) => [s.name, s.defaultOptions[i.name]])), n.push(i));
  return { languages: r, options: n };
}
function* Lb(t, e, r) {
  let n = new Set(t.map((i) => i.value));
  for (let i of e)
    if (i.parsers) {
      for (let s of i.parsers)
        if (!n.has(s)) {
          n.add(s);
          let o = r.find((l) => l.parsers && Object.prototype.hasOwnProperty.call(l.parsers, s)), a = i.name;
          o != null && o.name && (a += ` (plugin: ${o.name})`), yield { value: s, description: a };
        }
    }
}
function Pb(t) {
  let e = [];
  for (let [r, n] of Object.entries(t)) {
    let i = { name: r, ...n };
    Array.isArray(i.default) && (i.default = _e(!1, i.default, -1).value), e.push(i);
  }
  return e;
}
var Nb = (t) => String(t).split(/[/\\]/).pop();
function of(t, e) {
  if (!e)
    return;
  let r = Nb(e).toLowerCase();
  return t.find(({ filenames: n }) => n == null ? void 0 : n.some((i) => i.toLowerCase() === r)) ?? t.find(({ extensions: n }) => n == null ? void 0 : n.some((i) => r.endsWith(i)));
}
function Rb(t, e) {
  if (e)
    return t.find(({ name: r }) => r.toLowerCase() === e) ?? t.find(({ aliases: r }) => r == null ? void 0 : r.includes(e)) ?? t.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${e}`));
}
function Ib(t, e) {
  let r = t.plugins.flatMap((i) => i.languages ?? []), n = Rb(r, e.language) ?? of(r, e.physicalFile) ?? of(r, e.file) ?? (e.physicalFile, void 0);
  return n == null ? void 0 : n.parsers[0];
}
var $b = Ib, Yn = { key: (t) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(t) ? t : JSON.stringify(t), value(t) {
  if (t === null || typeof t != "object")
    return JSON.stringify(t);
  if (Array.isArray(t))
    return `[${t.map((r) => Yn.value(r)).join(", ")}]`;
  let e = Object.keys(t);
  return e.length === 0 ? "{}" : `{ ${e.map((r) => `${Yn.key(r)}: ${Yn.value(t[r])}`).join(", ")} }`;
}, pair: ({ key: t, value: e }) => Yn.value({ [t]: e }) }, af = Ds(ba(), 1), jb = (t, e, { descriptor: r }) => {
  let n = [`${af.default.yellow(typeof t == "string" ? r.key(t) : r.pair(t))} is deprecated`];
  return e && n.push(`we now treat it as ${af.default.blue(typeof e == "string" ? r.key(e) : r.pair(e))}`), n.join("; ") + ".";
}, Jn = Ds(ba(), 1), Am = Symbol.for("vnopts.VALUE_NOT_EXIST"), Co = Symbol.for("vnopts.VALUE_UNCHANGED"), lf = " ".repeat(2), Wb = (t, e, r) => {
  let { text: n, list: i } = r.normalizeExpectedResult(r.schemas[t].expected(r)), s = [];
  return n && s.push(uf(t, e, n, r.descriptor)), i && s.push([uf(t, e, i.title, r.descriptor)].concat(i.values.map((o) => Fm(o, r.loggerPrintWidth))).join(`
`)), Tm(s, r.loggerPrintWidth);
};
function uf(t, e, r, n) {
  return [`Invalid ${Jn.default.red(n.key(t))} value.`, `Expected ${Jn.default.blue(r)},`, `but received ${e === Am ? Jn.default.gray("nothing") : Jn.default.red(n.value(e))}.`].join(" ");
}
function Fm({ text: t, list: e }, r) {
  let n = [];
  return t && n.push(`- ${Jn.default.blue(t)}`), e && n.push([`- ${Jn.default.blue(e.title)}:`].concat(e.values.map((i) => Fm(i, r - lf.length).replace(/^|\n/g, `$&${lf}`))).join(`
`)), Tm(n, r);
}
function Tm(t, e) {
  if (t.length === 1)
    return t[0];
  let [r, n] = t, [i, s] = t.map((o) => o.split(`
`, 1)[0].length);
  return i > e && i > s ? n : r;
}
var cf = Ds(ba(), 1), ml = [], hf = [];
function qb(t, e) {
  if (t === e)
    return 0;
  let r = t;
  t.length > e.length && (t = e, e = r);
  let n = t.length, i = e.length;
  for (; n > 0 && t.charCodeAt(~-n) === e.charCodeAt(~-i); )
    n--, i--;
  let s = 0;
  for (; s < n && t.charCodeAt(s) === e.charCodeAt(s); )
    s++;
  if (n -= s, i -= s, n === 0)
    return i;
  let o, a, l, c, u = 0, h = 0;
  for (; u < n; )
    hf[u] = t.charCodeAt(s + u), ml[u] = ++u;
  for (; h < i; )
    for (o = e.charCodeAt(s + h), l = h++, a = h, u = 0; u < n; u++)
      c = o === hf[u] ? l : l + 1, l = ml[u], a = ml[u] = l > a ? c > a ? a + 1 : c : c > l ? l + 1 : c;
  return a;
}
var _m = (t, e, { descriptor: r, logger: n, schemas: i }) => {
  let s = [`Ignored unknown option ${cf.default.yellow(r.pair({ key: t, value: e }))}.`], o = Object.keys(i).sort().find((a) => qb(t, a) < 3);
  o && s.push(`Did you mean ${cf.default.blue(r.key(o))}?`), n.warn(s.join(" "));
}, Hb = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function Vb(t, e) {
  let r = new t(e), n = Object.create(r);
  for (let i of Hb)
    i in e && (n[i] = zb(e[i], r, Zr.prototype[i].length));
  return n;
}
var Zr = class {
  static create(e) {
    return Vb(this, e);
  }
  constructor(e) {
    this.name = e.name;
  }
  default(e) {
  }
  expected(e) {
    return "nothing";
  }
  validate(e, r) {
    return !1;
  }
  deprecated(e, r) {
    return !1;
  }
  forward(e, r) {
  }
  redirect(e, r) {
  }
  overlap(e, r, n) {
    return e;
  }
  preprocess(e, r) {
    return e;
  }
  postprocess(e, r) {
    return Co;
  }
};
function zb(t, e, r) {
  return typeof t == "function" ? (...n) => t(...n.slice(0, r - 1), e, ...n.slice(r - 1)) : () => t;
}
var Ub = class extends Zr {
  constructor(e) {
    super(e), this._sourceName = e.sourceName;
  }
  expected(e) {
    return e.schemas[this._sourceName].expected(e);
  }
  validate(e, r) {
    return r.schemas[this._sourceName].validate(e, r);
  }
  redirect(e, r) {
    return this._sourceName;
  }
}, Gb = class extends Zr {
  expected() {
    return "anything";
  }
  validate() {
    return !0;
  }
}, Kb = class extends Zr {
  constructor({ valueSchema: e, name: r = e.name, ...n }) {
    super({ ...n, name: r }), this._valueSchema = e;
  }
  expected(e) {
    let { text: r, list: n } = e.normalizeExpectedResult(this._valueSchema.expected(e));
    return { text: r && `an array of ${r}`, list: n && { title: "an array of the following values", values: [{ list: n }] } };
  }
  validate(e, r) {
    if (!Array.isArray(e))
      return !1;
    let n = [];
    for (let i of e) {
      let s = r.normalizeValidateResult(this._valueSchema.validate(i, r), i);
      s !== !0 && n.push(s.value);
    }
    return n.length === 0 ? !0 : { value: n };
  }
  deprecated(e, r) {
    let n = [];
    for (let i of e) {
      let s = r.normalizeDeprecatedResult(this._valueSchema.deprecated(i, r), i);
      s !== !1 && n.push(...s.map(({ value: o }) => ({ value: [o] })));
    }
    return n;
  }
  forward(e, r) {
    let n = [];
    for (let i of e) {
      let s = r.normalizeForwardResult(this._valueSchema.forward(i, r), i);
      n.push(...s.map(ff));
    }
    return n;
  }
  redirect(e, r) {
    let n = [], i = [];
    for (let s of e) {
      let o = r.normalizeRedirectResult(this._valueSchema.redirect(s, r), s);
      "remain" in o && n.push(o.remain), i.push(...o.redirect.map(ff));
    }
    return n.length === 0 ? { redirect: i } : { redirect: i, remain: n };
  }
  overlap(e, r) {
    return e.concat(r);
  }
};
function ff({ from: t, to: e }) {
  return { from: [t], to: e };
}
var Yb = class extends Zr {
  expected() {
    return "true or false";
  }
  validate(e) {
    return typeof e == "boolean";
  }
};
function Jb(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let n of t) {
    let i = n[e];
    if (r[i])
      throw new Error(`Duplicate ${e} ${JSON.stringify(i)}`);
    r[i] = n;
  }
  return r;
}
function Xb(t, e) {
  let r = /* @__PURE__ */ new Map();
  for (let n of t) {
    let i = n[e];
    if (r.has(i))
      throw new Error(`Duplicate ${e} ${JSON.stringify(i)}`);
    r.set(i, n);
  }
  return r;
}
function Qb() {
  let t = /* @__PURE__ */ Object.create(null);
  return (e) => {
    let r = JSON.stringify(e);
    return t[r] ? !0 : (t[r] = !0, !1);
  };
}
function Zb(t, e) {
  let r = [], n = [];
  for (let i of t)
    e(i) ? r.push(i) : n.push(i);
  return [r, n];
}
function eD(t) {
  return t === Math.floor(t);
}
function tD(t, e) {
  if (t === e)
    return 0;
  let r = typeof t, n = typeof e, i = ["undefined", "object", "boolean", "number", "string"];
  return r !== n ? i.indexOf(r) - i.indexOf(n) : r !== "string" ? Number(t) - Number(e) : t.localeCompare(e);
}
function rD(t) {
  return (...e) => {
    let r = t(...e);
    return typeof r == "string" ? new Error(r) : r;
  };
}
function df(t) {
  return t === void 0 ? {} : t;
}
function Bm(t) {
  if (typeof t == "string")
    return { text: t };
  let { text: e, list: r } = t;
  return nD((e || r) !== void 0, "Unexpected `expected` result, there should be at least one field."), r ? { text: e, list: { title: r.title, values: r.values.map(Bm) } } : { text: e };
}
function pf(t, e) {
  return t === !0 ? !0 : t === !1 ? { value: e } : t;
}
function mf(t, e, r = !1) {
  return t === !1 ? !1 : t === !0 ? r ? !0 : [{ value: e }] : "value" in t ? [t] : t.length === 0 ? !1 : t;
}
function gf(t, e) {
  return typeof t == "string" || "key" in t ? { from: e, to: t } : "from" in t ? { from: t.from, to: t.to } : { from: e, to: t.to };
}
function lu(t, e) {
  return t === void 0 ? [] : Array.isArray(t) ? t.map((r) => gf(r, e)) : [gf(t, e)];
}
function yf(t, e) {
  let r = lu(typeof t == "object" && "redirect" in t ? t.redirect : t, e);
  return r.length === 0 ? { remain: e, redirect: r } : typeof t == "object" && "remain" in t ? { remain: t.remain, redirect: r } : { redirect: r };
}
function nD(t, e) {
  if (!t)
    throw new Error(e);
}
var iD = class extends Zr {
  constructor(e) {
    super(e), this._choices = Xb(e.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
  }
  expected({ descriptor: e }) {
    let r = Array.from(this._choices.keys()).map((s) => this._choices.get(s)).filter(({ hidden: s }) => !s).map((s) => s.value).sort(tD).map(e.value), n = r.slice(0, -2), i = r.slice(-2);
    return { text: n.concat(i.join(" or ")).join(", "), list: { title: "one of the following values", values: r } };
  }
  validate(e) {
    return this._choices.has(e);
  }
  deprecated(e) {
    let r = this._choices.get(e);
    return r && r.deprecated ? { value: e } : !1;
  }
  forward(e) {
    let r = this._choices.get(e);
    return r ? r.forward : void 0;
  }
  redirect(e) {
    let r = this._choices.get(e);
    return r ? r.redirect : void 0;
  }
}, sD = class extends Zr {
  expected() {
    return "a number";
  }
  validate(e, r) {
    return typeof e == "number";
  }
}, oD = class extends sD {
  expected() {
    return "an integer";
  }
  validate(e, r) {
    return r.normalizeValidateResult(super.validate(e, r), e) === !0 && eD(e);
  }
}, vf = class extends Zr {
  expected() {
    return "a string";
  }
  validate(e) {
    return typeof e == "string";
  }
}, aD = Yn, lD = _m, uD = Wb, cD = jb, hD = class {
  constructor(e, r) {
    let { logger: n = console, loggerPrintWidth: i = 80, descriptor: s = aD, unknown: o = lD, invalid: a = uD, deprecated: l = cD, missing: c = () => !1, required: u = () => !1, preprocess: h = (d) => d, postprocess: f = () => Co } = r || {};
    this._utils = { descriptor: s, logger: n || { warn: () => {
    } }, loggerPrintWidth: i, schemas: Jb(e, "name"), normalizeDefaultResult: df, normalizeExpectedResult: Bm, normalizeDeprecatedResult: mf, normalizeForwardResult: lu, normalizeRedirectResult: yf, normalizeValidateResult: pf }, this._unknownHandler = o, this._invalidHandler = rD(a), this._deprecatedHandler = l, this._identifyMissing = (d, p) => !(d in p) || c(d, p), this._identifyRequired = u, this._preprocess = h, this._postprocess = f, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = Qb();
  }
  normalize(e) {
    let r = {}, n = [this._preprocess(e, this._utils)], i = () => {
      for (; n.length !== 0; ) {
        let s = n.shift(), o = this._applyNormalization(s, r);
        n.push(...o);
      }
    };
    i();
    for (let s of Object.keys(this._utils.schemas)) {
      let o = this._utils.schemas[s];
      if (!(s in r)) {
        let a = df(o.default(this._utils));
        "value" in a && n.push({ [s]: a.value });
      }
    }
    i();
    for (let s of Object.keys(this._utils.schemas)) {
      if (!(s in r))
        continue;
      let o = this._utils.schemas[s], a = r[s], l = o.postprocess(a, this._utils);
      l !== Co && (this._applyValidation(l, s, o), r[s] = l);
    }
    return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
  }
  _applyNormalization(e, r) {
    let n = [], { knownKeys: i, unknownKeys: s } = this._partitionOptionKeys(e);
    for (let o of i) {
      let a = this._utils.schemas[o], l = a.preprocess(e[o], this._utils);
      this._applyValidation(l, o, a);
      let c = ({ from: f, to: d }) => {
        n.push(typeof d == "string" ? { [d]: f } : { [d.key]: d.value });
      }, u = ({ value: f, redirectTo: d }) => {
        let p = mf(a.deprecated(f, this._utils), l, !0);
        if (p !== !1)
          if (p === !0)
            this._hasDeprecationWarned(o) || this._utils.logger.warn(this._deprecatedHandler(o, d, this._utils));
          else
            for (let { value: m } of p) {
              let y = { key: o, value: m };
              if (!this._hasDeprecationWarned(y)) {
                let v = typeof d == "string" ? { key: d, value: m } : d;
                this._utils.logger.warn(this._deprecatedHandler(y, v, this._utils));
              }
            }
      };
      lu(a.forward(l, this._utils), l).forEach(c);
      let h = yf(a.redirect(l, this._utils), l);
      if (h.redirect.forEach(c), "remain" in h) {
        let f = h.remain;
        r[o] = o in r ? a.overlap(r[o], f, this._utils) : f, u({ value: f });
      }
      for (let { from: f, to: d } of h.redirect)
        u({ value: f, redirectTo: d });
    }
    for (let o of s) {
      let a = e[o];
      this._applyUnknownHandler(o, a, r, (l, c) => {
        n.push({ [l]: c });
      });
    }
    return n;
  }
  _applyRequiredCheck(e) {
    for (let r of Object.keys(this._utils.schemas))
      if (this._identifyMissing(r, e) && this._identifyRequired(r))
        throw this._invalidHandler(r, Am, this._utils);
  }
  _partitionOptionKeys(e) {
    let [r, n] = Zb(Object.keys(e).filter((i) => !this._identifyMissing(i, e)), (i) => i in this._utils.schemas);
    return { knownKeys: r, unknownKeys: n };
  }
  _applyValidation(e, r, n) {
    let i = pf(n.validate(e, this._utils), e);
    if (i !== !0)
      throw this._invalidHandler(r, i.value, this._utils);
  }
  _applyUnknownHandler(e, r, n, i) {
    let s = this._unknownHandler(e, r, this._utils);
    if (s)
      for (let o of Object.keys(s)) {
        if (this._identifyMissing(o, s))
          continue;
        let a = s[o];
        o in this._utils.schemas ? i(o, a) : n[o] = a;
      }
  }
  _applyPostprocess(e) {
    let r = this._postprocess(e, this._utils);
    if (r !== Co) {
      if (r.delete)
        for (let n of r.delete)
          delete e[n];
      if (r.override) {
        let { knownKeys: n, unknownKeys: i } = this._partitionOptionKeys(r.override);
        for (let s of n) {
          let o = r.override[s];
          this._applyValidation(o, s, this._utils.schemas[s]), e[s] = o;
        }
        for (let s of i) {
          let o = r.override[s];
          this._applyUnknownHandler(s, o, e, (a, l) => {
            let c = this._utils.schemas[a];
            this._applyValidation(l, a, c), e[a] = l;
          });
        }
      }
    }
  }
}, gl;
function fD(t, e, { logger: r = !1, isCLI: n = !1, passThrough: i = !1, FlagSchema: s, descriptor: o } = {}) {
  if (n) {
    if (!s)
      throw new Error("'FlagSchema' option is required.");
    if (!o)
      throw new Error("'descriptor' option is required.");
  } else
    o = Yn;
  let a = i ? Array.isArray(i) ? (f, d) => i.includes(f) ? { [f]: d } : void 0 : (f, d) => ({ [f]: d }) : (f, d, p) => {
    let { _: m, ...y } = p.schemas;
    return _m(f, d, { ...p, schemas: y });
  }, l = dD(e, { isCLI: n, FlagSchema: s }), c = new hD(l, { logger: r, unknown: a, descriptor: o }), u = r !== !1;
  u && gl && (c._hasDeprecationWarned = gl);
  let h = c.normalize(t);
  return u && (gl = c._hasDeprecationWarned), h;
}
function dD(t, { isCLI: e, FlagSchema: r }) {
  let n = [];
  e && n.push(Gb.create({ name: "_" }));
  for (let i of t)
    n.push(pD(i, { isCLI: e, optionInfos: t, FlagSchema: r })), i.alias && e && n.push(Ub.create({ name: i.alias, sourceName: i.name }));
  return n;
}
function pD(t, { isCLI: e, optionInfos: r, FlagSchema: n }) {
  let { name: i } = t, s = { name: i }, o, a = {};
  switch (t.type) {
    case "int":
      o = oD, e && (s.preprocess = Number);
      break;
    case "string":
      o = vf;
      break;
    case "choice":
      o = iD, s.choices = t.choices.map((l) => l != null && l.redirect ? { ...l, redirect: { to: { key: t.name, value: l.redirect } } } : l);
      break;
    case "boolean":
      o = Yb;
      break;
    case "flag":
      o = n, s.flags = r.flatMap((l) => [l.alias, l.description && l.name, l.oppositeDescription && `no-${l.name}`].filter(Boolean));
      break;
    case "path":
      o = vf;
      break;
    default:
      throw new Error(`Unexpected type ${t.type}`);
  }
  if (t.exception ? s.validate = (l, c, u) => t.exception(l) || c.validate(l, u) : s.validate = (l, c, u) => l === void 0 || c.validate(l, u), t.redirect && (a.redirect = (l) => l ? { to: { key: t.redirect.option, value: t.redirect.value } } : void 0), t.deprecated && (a.deprecated = !0), e && !t.array) {
    let l = s.preprocess || ((c) => c);
    s.preprocess = (c, u, h) => u.preprocess(l(Array.isArray(c) ? _e(!1, c, -1) : c), h);
  }
  return t.array ? Kb.create({ ...e ? { preprocess: (l) => Array.isArray(l) ? l : [l] } : {}, ...a, valueSchema: o.create(s) }) : o.create({ ...s, ...a });
}
var mD = fD, gD = (t, e, r) => {
  if (!(t && e == null)) {
    if (e.findLast)
      return e.findLast(r);
    for (let n = e.length - 1; n >= 0; n--) {
      let i = e[n];
      if (r(i, n, e))
        return i;
    }
  }
}, Om = gD;
function Mm(t, e) {
  if (!e)
    throw new Error("parserName is required.");
  let r = Om(!1, t, (i) => i.parsers && Object.prototype.hasOwnProperty.call(i.parsers, e));
  if (r)
    return r;
  let n = `Couldn't resolve parser "${e}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new Sm(n);
}
function yD(t, e) {
  if (!e)
    throw new Error("astFormat is required.");
  let r = Om(!1, t, (i) => i.printers && Object.prototype.hasOwnProperty.call(i.printers, e));
  if (r)
    return r;
  let n = `Couldn't find plugin for AST format "${e}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new Sm(n);
}
function Lm({ plugins: t, parser: e }) {
  let r = Mm(t, e);
  return Pm(r, e);
}
function Pm(t, e) {
  let r = t.parsers[e];
  return typeof r == "function" ? r() : r;
}
function vD(t, e) {
  let r = t.printers[e];
  return typeof r == "function" ? r() : r;
}
var bf = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
async function bD(t, e = {}) {
  var r;
  let n = { ...t };
  if (!n.parser)
    if (n.filepath) {
      if (n.parser = $b(n, { physicalFile: n.filepath }), !n.parser)
        throw new sf(`No parser could be inferred for file "${n.filepath}".`);
    } else
      throw new sf("No parser and no file path given, couldn't infer a parser.");
  let i = Em({ plugins: t.plugins, showDeprecated: !0 }).options, s = { ...bf, ...Object.fromEntries(i.filter((f) => f.default !== void 0).map((f) => [f.name, f.default])) }, o = Mm(n.plugins, n.parser), a = await Pm(o, n.parser);
  n.astFormat = a.astFormat, n.locEnd = a.locEnd, n.locStart = a.locStart;
  let l = (r = o.printers) != null && r[a.astFormat] ? o : yD(n.plugins, a.astFormat), c = await vD(l, a.astFormat);
  n.printer = c;
  let u = l.defaultOptions ? Object.fromEntries(Object.entries(l.defaultOptions).filter(([, f]) => f !== void 0)) : {}, h = { ...s, ...u };
  for (let [f, d] of Object.entries(h))
    (n[f] === null || n[f] === void 0) && (n[f] = d);
  return n.parser === "json" && (n.trailingComma = "none"), mD(n, i, { passThrough: Object.keys(bf), ...e });
}
var pi = bD, DD = Ds(w2(), 1);
async function wD(t, e) {
  let r = await Lm(e), n = r.preprocess ? r.preprocess(t, e) : t;
  e.originalText = n;
  let i;
  try {
    i = await r.parse(n, e, e);
  } catch (s) {
    xD(s, t);
  }
  return { text: n, ast: i };
}
function xD(t, e) {
  let { loc: r } = t;
  if (r) {
    let n = (0, DD.codeFrameColumns)(e, r, { highlightCode: !0 });
    throw t.message += `
` + n, t.codeFrame = n, t;
  }
  throw t;
}
var xs = wD;
async function CD(t, e, r, n, i) {
  let { embeddedLanguageFormatting: s, printer: { embed: o, hasPrettierIgnore: a = () => !1, getVisitorKeys: l } } = r;
  if (!o || s !== "auto")
    return;
  if (o.length > 2)
    throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed");
  let c = ka(o.getVisitorKeys ?? l), u = [];
  d();
  let h = t.stack;
  for (let { print: p, node: m, pathStack: y } of u)
    try {
      t.stack = y;
      let v = await p(f, e, t, r);
      v && i.set(m, v);
    } catch (v) {
      if (globalThis.PRETTIER_DEBUG)
        throw v;
    }
  t.stack = h;
  function f(p, m) {
    return kD(p, m, r, n);
  }
  function d() {
    let { node: p } = t;
    if (p === null || typeof p != "object" || a(t))
      return;
    for (let y of c(p))
      Array.isArray(p[y]) ? t.each(d, y) : t.call(d, y);
    let m = o(t, r);
    if (m) {
      if (typeof m == "function") {
        u.push({ print: m, node: p, pathStack: [...t.stack] });
        return;
      }
      i.set(p, m);
    }
  }
}
async function kD(t, e, r, n) {
  let i = await pi({ ...r, ...e, parentParser: r.parser, originalText: t }, { passThrough: !0 }), { ast: s } = await xs(t, i), o = await n(s, i);
  return pm(o);
}
function SD(t, e) {
  let { originalText: r, [Symbol.for("comments")]: n, locStart: i, locEnd: s, [Symbol.for("printedComments")]: o } = e, { node: a } = t, l = i(a), c = s(a);
  for (let u of n)
    i(u) >= l && s(u) <= c && o.add(u);
  return r.slice(l, c);
}
var ED = SD;
async function Sa(t, e) {
  ({ ast: t } = await Nm(t, e));
  let r = /* @__PURE__ */ new Map(), n = new fb(t), i = /* @__PURE__ */ new Map();
  await CD(n, o, e, Sa, i);
  let s = await Df(n, e, o, void 0, i);
  return Ob(e), s;
  function o(l, c) {
    return l === void 0 || l === n ? a(c) : Array.isArray(l) ? n.call(() => a(c), ...l) : n.call(() => a(c), l);
  }
  function a(l) {
    let c = n.node;
    if (c == null)
      return "";
    let u = c && typeof c == "object" && l === void 0;
    if (u && r.has(c))
      return r.get(c);
    let h = Df(n, e, o, l, i);
    return u && r.set(c, h), h;
  }
}
function Df(t, e, r, n, i) {
  var s;
  let { node: o } = t, { printer: a } = e, l;
  return (s = a.hasPrettierIgnore) != null && s.call(a, t) ? l = ED(t, e) : i.has(o) ? l = i.get(o) : l = a.print(t, e, r, n), o === e.cursorNode && (l = mm(l, (c) => [nu, c, nu])), a.printComment && (!a.willPrintOwnComments || !a.willPrintOwnComments(t, e)) && (l = Bb(t, l, e)), l;
}
async function Nm(t, e) {
  let r = t.comments ?? [];
  e[Symbol.for("comments")] = r, e[Symbol.for("tokens")] = t.tokens ?? [], e[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), kb(t, e);
  let { printer: { preprocess: n } } = e;
  return t = n ? await n(t, e) : t, { ast: t, comments: r };
}
function AD(t, e) {
  let { cursorOffset: r, locStart: n, locEnd: i } = e, s = ka(e.printer.getVisitorKeys), o = (l) => n(l) <= r && i(l) >= r, a = t;
  for (let l of mb(t, { getVisitorKeys: s, filter: o }))
    a = l;
  return a;
}
var FD = AD;
function TD(t, e) {
  let { printer: { massageAstNode: r, getVisitorKeys: n } } = e;
  if (!r)
    return t;
  let i = ka(n), s = r.ignoredProperties ?? /* @__PURE__ */ new Set();
  return o(t);
  function o(a, l) {
    if (!(a !== null && typeof a == "object"))
      return a;
    if (Array.isArray(a))
      return a.map((f) => o(f, l)).filter(Boolean);
    let c = {}, u = new Set(i(a));
    for (let f in a)
      !Object.prototype.hasOwnProperty.call(a, f) || s.has(f) || (u.has(f) ? c[f] = o(a[f], a) : c[f] = a[f]);
    let h = r(a, c, l);
    if (h !== null)
      return h ?? c;
  }
}
var _D = TD, BD = ({ parser: t }) => t === "json" || t === "json5" || t === "jsonc" || t === "json-stringify";
function OD(t, e) {
  let r = [t.node, ...t.parentNodes], n = /* @__PURE__ */ new Set([e.node, ...e.parentNodes]);
  return r.find((i) => Rm.has(i.type) && n.has(i));
}
function wf(t) {
  let e = t.length - 1;
  for (; ; ) {
    let r = t[e];
    if ((r == null ? void 0 : r.type) === "Program" || (r == null ? void 0 : r.type) === "File")
      e--;
    else
      break;
  }
  return t.slice(0, e + 1);
}
function MD(t, e, { locStart: r, locEnd: n }) {
  let i = t.node, s = e.node;
  if (i === s)
    return { startNode: i, endNode: s };
  let o = r(t.node);
  for (let l of wf(e.parentNodes))
    if (r(l) >= o)
      s = l;
    else
      break;
  let a = n(e.node);
  for (let l of wf(t.parentNodes)) {
    if (n(l) <= a)
      i = l;
    else
      break;
    if (i === s)
      break;
  }
  return { startNode: i, endNode: s };
}
function uu(t, e, r, n, i = [], s) {
  let { locStart: o, locEnd: a } = r, l = o(t), c = a(t);
  if (!(e > c || e < l || s === "rangeEnd" && e === l || s === "rangeStart" && e === c)) {
    for (let u of Ec(t, r)) {
      let h = uu(u, e, r, n, [t, ...i], s);
      if (h)
        return h;
    }
    if (!n || n(t, i[0]))
      return { node: t, parentNodes: i };
  }
}
function LD(t, e) {
  return e !== "DeclareExportDeclaration" && t !== "TypeParameterDeclaration" && (t === "Directive" || t === "TypeAlias" || t === "TSExportAssignment" || t.startsWith("Declare") || t.startsWith("TSDeclare") || t.endsWith("Statement") || t.endsWith("Declaration"));
}
var Rm = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), PD = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function xf(t, e, r) {
  if (!e)
    return !1;
  switch (t.parser) {
    case "flow":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "__babel_estree":
      return LD(e.type, r == null ? void 0 : r.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return Rm.has(e.type);
    case "graphql":
      return PD.has(e.kind);
    case "vue":
      return e.tag !== "root";
  }
  return !1;
}
function ND(t, e, r) {
  let { rangeStart: n, rangeEnd: i, locStart: s, locEnd: o } = e;
  au.ok(i > n);
  let a = t.slice(n, i).search(/\S/), l = a === -1;
  if (!l)
    for (n += a; i > n && !/\S/.test(t[i - 1]); --i)
      ;
  let c = uu(r, n, e, (d, p) => xf(e, d, p), [], "rangeStart"), u = l ? c : uu(r, i, e, (d) => xf(e, d), [], "rangeEnd");
  if (!c || !u)
    return { rangeStart: 0, rangeEnd: 0 };
  let h, f;
  if (BD(e)) {
    let d = OD(c, u);
    h = d, f = d;
  } else
    ({ startNode: h, endNode: f } = MD(c, u, e));
  return { rangeStart: Math.min(s(h), s(f)), rangeEnd: Math.max(o(h), o(f)) };
}
var Im = "\uFEFF", Cf = Symbol("cursor");
async function $m(t, e, r = 0) {
  if (!t || t.trim().length === 0)
    return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: n, text: i } = await xs(t, e);
  e.cursorOffset >= 0 && (e.cursorNode = FD(n, e));
  let s = await Sa(n, e);
  r > 0 && (s = dm([yn, s], r, e.tabWidth));
  let o = Ca(s, e);
  if (r > 0) {
    let l = o.formatted.trim();
    o.cursorNodeStart !== void 0 && (o.cursorNodeStart -= o.formatted.indexOf(l)), o.formatted = l + bc(e.endOfLine);
  }
  let a = e[Symbol.for("comments")];
  if (e.cursorOffset >= 0) {
    let l, c, u, h, f;
    if (e.cursorNode && o.cursorNodeText ? (l = e.locStart(e.cursorNode), c = i.slice(l, e.locEnd(e.cursorNode)), u = e.cursorOffset - l, h = o.cursorNodeStart, f = o.cursorNodeText) : (l = 0, c = i, u = e.cursorOffset, h = 0, f = o.formatted), c === f)
      return { formatted: o.formatted, cursorOffset: h + u, comments: a };
    let d = c.split("");
    d.splice(u, 0, Cf);
    let p = f.split(""), m = (0, C2.diffArrays)(d, p), y = h;
    for (let v of m)
      if (v.removed) {
        if (v.value.includes(Cf))
          break;
      } else
        y += v.count;
    return { formatted: o.formatted, cursorOffset: y, comments: a };
  }
  return { formatted: o.formatted, cursorOffset: -1, comments: a };
}
async function RD(t, e) {
  let { ast: r, text: n } = await xs(t, e), { rangeStart: i, rangeEnd: s } = ND(n, e, r), o = n.slice(i, s), a = Math.min(i, n.lastIndexOf(`
`, i) + 1), l = n.slice(a, i).match(/^\s*/)[0], c = kc(l, e.tabWidth), u = await $m(o, { ...e, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: e.cursorOffset > i && e.cursorOffset <= s ? e.cursorOffset - i : -1, endOfLine: "lf" }, c), h = u.formatted.trimEnd(), { cursorOffset: f } = e;
  f > s ? f += h.length - o.length : u.cursorOffset >= 0 && (f = u.cursorOffset + i);
  let d = n.slice(0, i) + h + n.slice(s);
  if (e.endOfLine !== "lf") {
    let p = bc(e.endOfLine);
    f >= 0 && p === `\r
` && (f += sm(d.slice(0, f), `
`)), d = Da(!1, d, `
`, p);
  }
  return { formatted: d, cursorOffset: f, comments: u.comments };
}
function yl(t, e, r) {
  return typeof e != "number" || Number.isNaN(e) || e < 0 || e > t.length ? r : e;
}
function kf(t, e) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: i } = e;
  return r = yl(t, r, -1), n = yl(t, n, 0), i = yl(t, i, t.length), { ...e, cursorOffset: r, rangeStart: n, rangeEnd: i };
}
function jm(t, e) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: i, endOfLine: s } = kf(t, e), o = t.charAt(0) === Im;
  if (o && (t = t.slice(1), r--, n--, i--), s === "auto" && (s = k2(t)), t.includes("\r")) {
    let a = (l) => sm(t.slice(0, Math.max(l, 0)), `\r
`);
    r -= a(r), n -= a(n), i -= a(i), t = S2(t);
  }
  return { hasBOM: o, text: t, options: kf(t, { ...e, cursorOffset: r, rangeStart: n, rangeEnd: i, endOfLine: s }) };
}
async function Sf(t, e) {
  let r = await Lm(e);
  return !r.hasPragma || r.hasPragma(t);
}
async function Wm(t, e) {
  let { hasBOM: r, text: n, options: i } = jm(t, await pi(e));
  if (i.rangeStart >= i.rangeEnd && n !== "" || i.requirePragma && !await Sf(n, i))
    return { formatted: t, cursorOffset: e.cursorOffset, comments: [] };
  let s;
  return i.rangeStart > 0 || i.rangeEnd < n.length ? s = await RD(n, i) : (!i.requirePragma && i.insertPragma && i.printer.insertPragma && !await Sf(n, i) && (n = i.printer.insertPragma(n)), s = await $m(n, i)), r && (s.formatted = Im + s.formatted, s.cursorOffset >= 0 && s.cursorOffset++), s;
}
async function ID(t, e, r) {
  let { text: n, options: i } = jm(t, await pi(e)), s = await xs(n, i);
  return r && (r.preprocessForPrint && (s.ast = await Nm(s.ast, i)), r.massage && (s.ast = _D(s.ast, i))), s;
}
async function $D(t, e) {
  e = await pi(e);
  let r = await Sa(t, e);
  return Ca(r, e);
}
async function jD(t, e) {
  let r = H2(t), { formatted: n } = await Wm(r, { ...e, parser: "__js_expression" });
  return n;
}
async function WD(t, e) {
  e = await pi(e);
  let { ast: r } = await xs(t, e);
  return Sa(r, e);
}
async function qD(t, e) {
  return Ca(t, await pi(e));
}
var qm = {};
va(qm, { builders: () => HD, printer: () => VD, utils: () => zD });
var HD = { join: fm, line: cm, softline: W2, hardline: yn, literalline: hm, group: am, conditionalGroup: N2, fill: lm, lineSuffix: ru, lineSuffixBoundary: $2, cursor: nu, breakParent: wa, ifBreak: R2, trim: j2, indent: $o, indentIfBreak: I2, align: oi, addAlignmentToDoc: dm, markAsRoot: L2, dedentToRoot: M2, dedent: P2, hardlineWithoutBreakParent: wc, literallineWithoutBreakParent: um, label: q2, concat: (t) => t }, VD = { printDocToString: Ca }, zD = { willBreak: Z2, traverseDoc: Dc, findInDoc: Cc, mapDoc: xa, removeLines: rb, stripTrailingHardline: pm, replaceEndOfLine: sb, canBreak: ab }, UD = "3.2.5", Hm = {};
va(Hm, { addDanglingComment: () => an, addLeadingComment: () => Gn, addTrailingComment: () => Kn, getAlignmentSize: () => kc, getIndentSize: () => QD, getMaxContinuousCount: () => tw, getNextNonSpaceNonCommentCharacter: () => nw, getNextNonSpaceNonCommentCharacterIndex: () => hw, getStringWidth: () => xc, hasNewline: () => Wr, hasNewlineInRange: () => sw, hasSpaces: () => aw, isNextLineEmpty: () => mw, isNextLineEmptyAfterIndex: () => Bc, isPreviousLineEmpty: () => dw, makeString: () => uw, skip: () => ws, skipEverythingButNewLine: () => Dm, skipInlineComment: () => Fc, skipNewline: () => bn, skipSpaces: () => Ur, skipToLineEnd: () => bm, skipTrailingComment: () => Tc, skipWhitespace: () => gb });
function GD(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var Fc = GD;
function KD(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? Dm(t, e) : e;
}
var Tc = KD;
function YD(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = Ur(t, n), n = Fc(t, n), n = Tc(t, n), n = bn(t, n);
  return n;
}
var _c = YD;
function JD(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = bm(t, n), n = Fc(t, n), n = Ur(t, n);
  return n = Tc(t, n), n = bn(t, n), n !== !1 && Wr(t, n);
}
var Bc = JD;
function XD(t, e) {
  let r = t.lastIndexOf(`
`);
  return r === -1 ? 0 : kc(t.slice(r + 1).match(/^[\t ]*/)[0], e);
}
var QD = XD;
function ZD(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function ew(t, e) {
  let r = t.match(new RegExp(`(${ZD(e)})+`, "g"));
  return r === null ? 0 : r.reduce((n, i) => Math.max(n, i.length / e.length), 0);
}
var tw = ew;
function rw(t, e) {
  let r = _c(t, e);
  return r === !1 ? "" : t.charAt(r);
}
var nw = rw;
function iw(t, e, r) {
  for (let n = e; n < r; ++n)
    if (t.charAt(n) === `
`)
      return !0;
  return !1;
}
var sw = iw;
function ow(t, e, r = {}) {
  return Ur(t, r.backwards ? e - 1 : e, r) !== e;
}
var aw = ow;
function lw(t, e, r) {
  let n = e === '"' ? "'" : '"', i = Da(!1, t, /\\(.)|(["'])/gs, (s, o, a) => o === n ? o : a === e ? "\\" + a : a || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o) ? o : "\\" + o));
  return e + i + e;
}
var uw = lw;
function cw(t, e, r) {
  return _c(t, r(e));
}
function hw(t, e) {
  return arguments.length === 2 || typeof e == "number" ? _c(t, e) : cw(...arguments);
}
function fw(t, e, r) {
  return Ac(t, r(e));
}
function dw(t, e) {
  return arguments.length === 2 || typeof e == "number" ? Ac(t, e) : fw(...arguments);
}
function pw(t, e, r) {
  return Bc(t, r(e));
}
function mw(t, e) {
  return arguments.length === 2 || typeof e == "number" ? Bc(t, e) : pw(...arguments);
}
function un(t, e = 1) {
  return async (...r) => {
    let n = r[e] ?? {}, i = n.plugins ?? [];
    return r[e] = { ...n, plugins: Array.isArray(i) ? i : Object.values(i) }, t(...r);
  };
}
var Vm = un(Wm);
async function zm(t, e) {
  let { formatted: r } = await Vm(t, { ...e, cursorOffset: -1 });
  return r;
}
async function gw(t, e) {
  return await zm(t, e) === t;
}
var yw = un(Em, 0), vw = { parse: un(ID), formatAST: un($D), formatDoc: un(jD), printToDoc: un(WD), printDocToString: un(qD) }, bw = im, Dw = Object.defineProperty, Um = (t, e) => {
  for (var r in e)
    Dw(t, r, { get: e[r], enumerable: !0 });
}, Gm = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, _r = (t, e, r) => (Gm(t, e, "read from private field"), r ? r.call(t) : e.get(t)), ww = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, xw = (t, e, r, n) => (Gm(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r), Km = {};
Um(Km, { languages: () => ak, options: () => uk, parsers: () => Fg, printers: () => pS });
var Cw = (t, e, r, n) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
}, yt = Cw, Oc = "string", Mc = "array", Lc = "cursor", Ea = "indent", Aa = "align", Pc = "trim", rs = "group", Fa = "fill", Ta = "if-break", _a = "indent-if-break", Nc = "line-suffix", Rc = "line-suffix-boundary", _n = "line", Ic = "label", Ba = "break-parent", Ym = /* @__PURE__ */ new Set([Lc, Ea, Aa, Pc, rs, Fa, Ta, _a, Nc, Rc, _n, Ic, Ba]);
function kw(t) {
  if (typeof t == "string")
    return Oc;
  if (Array.isArray(t))
    return Mc;
  if (!t)
    return;
  let { type: e } = t;
  if (Ym.has(e))
    return e;
}
var $c = kw, Sw = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function Ew(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if ($c(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = Sw([...Ym].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`;
}
var Aw = class extends Error {
  constructor(e) {
    super(Ew(e));
    Tr(this, "name", "InvalidDocError");
    this.doc = e;
  }
}, Jm = Aw, Fw = () => {
}, Tw = Fw;
function kr(t) {
  return { type: Ea, contents: t };
}
function Xm(t, e) {
  return { type: Aa, contents: e, n: t };
}
function Ge(t, e = {}) {
  return Tw(e.expandedStates), { type: rs, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function _w(t) {
  return Xm(Number.NEGATIVE_INFINITY, t);
}
function Bw(t) {
  return Xm({ type: "root" }, t);
}
function Qm(t) {
  return { type: Fa, parts: t };
}
function jo(t, e = "", r = {}) {
  return { type: Ta, breakContents: t, flatContents: e, groupId: r.groupId };
}
function Ow(t, e) {
  return { type: _a, contents: t, groupId: e.groupId, negate: e.negate };
}
var Cs = { type: Ba }, Mw = { type: _n, hard: !0 }, Lw = { type: _n, hard: !0, literal: !0 }, $e = { type: _n }, Ve = { type: _n, soft: !0 }, we = [Mw, Cs], Pw = [Lw, Cs];
function mi(t, e) {
  let r = [];
  for (let n = 0; n < e.length; n++)
    n !== 0 && r.push(t), r.push(e[n]);
  return r;
}
var Nw = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, ks = Nw;
function jc(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return n(t);
  function n(s) {
    if (r.has(s))
      return r.get(s);
    let o = i(s);
    return r.set(s, o), o;
  }
  function i(s) {
    switch ($c(s)) {
      case Mc:
        return e(s.map(n));
      case Fa:
        return e({ ...s, parts: s.parts.map(n) });
      case Ta:
        return e({ ...s, breakContents: n(s.breakContents), flatContents: n(s.flatContents) });
      case rs: {
        let { expandedStates: o, contents: a } = s;
        return o ? (o = o.map(n), a = o[0]) : a = n(a), e({ ...s, contents: a, expandedStates: o });
      }
      case Aa:
      case Ea:
      case _a:
      case Ic:
      case Nc:
        return e({ ...s, contents: n(s.contents) });
      case Oc:
      case Lc:
      case Pc:
      case Rc:
      case _n:
      case Ba:
        return e(s);
      default:
        throw new Jm(s);
    }
  }
}
function Rw(t) {
  switch ($c(t)) {
    case Fa:
      if (t.parts.every((e) => e === ""))
        return "";
      break;
    case rs:
      if (!t.contents && !t.id && !t.break && !t.expandedStates)
        return "";
      if (t.contents.type === rs && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates)
        return t.contents;
      break;
    case Aa:
    case Ea:
    case _a:
    case Nc:
      if (!t.contents)
        return "";
      break;
    case Ta:
      if (!t.flatContents && !t.breakContents)
        return "";
      break;
    case Mc: {
      let e = [];
      for (let r of t) {
        if (!r)
          continue;
        let [n, ...i] = Array.isArray(r) ? r : [r];
        typeof n == "string" && typeof ks(!1, e, -1) == "string" ? e[e.length - 1] += n : e.push(n), e.push(...i);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case Oc:
    case Lc:
    case Pc:
    case Rc:
    case _n:
    case Ic:
    case Ba:
      break;
    default:
      throw new Jm(t);
  }
  return t;
}
function Iw(t) {
  return jc(t, (e) => Rw(e));
}
function It(t, e = Pw) {
  return jc(t, (r) => typeof r == "string" ? mi(e, r.split(`
`)) : r);
}
var Hs = "'", Ef = '"';
function $w(t, e) {
  let r = e === !0 || e === Hs ? Hs : Ef, n = r === Hs ? Ef : Hs, i = 0, s = 0;
  for (let o of t)
    o === r ? i++ : o === n && s++;
  return i > s ? n : r;
}
var jw = $w;
function Ww(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var Lt, qw = class {
  constructor(t) {
    ww(this, Lt, void 0), xw(this, Lt, new Set(t));
  }
  getLeadingWhitespaceCount(t) {
    let e = _r(this, Lt), r = 0;
    for (let n = 0; n < t.length && e.has(t.charAt(n)); n++)
      r++;
    return r;
  }
  getTrailingWhitespaceCount(t) {
    let e = _r(this, Lt), r = 0;
    for (let n = t.length - 1; n >= 0 && e.has(t.charAt(n)); n--)
      r++;
    return r;
  }
  getLeadingWhitespace(t) {
    let e = this.getLeadingWhitespaceCount(t);
    return t.slice(0, e);
  }
  getTrailingWhitespace(t) {
    let e = this.getTrailingWhitespaceCount(t);
    return t.slice(t.length - e);
  }
  hasLeadingWhitespace(t) {
    return _r(this, Lt).has(t.charAt(0));
  }
  hasTrailingWhitespace(t) {
    return _r(this, Lt).has(ks(!1, t, -1));
  }
  trimStart(t) {
    let e = this.getLeadingWhitespaceCount(t);
    return t.slice(e);
  }
  trimEnd(t) {
    let e = this.getTrailingWhitespaceCount(t);
    return t.slice(0, t.length - e);
  }
  trim(t) {
    return this.trimEnd(this.trimStart(t));
  }
  split(t, e = !1) {
    let r = `[${Ww([..._r(this, Lt)].join(""))}]+`, n = new RegExp(e ? `(${r})` : r);
    return t.split(n);
  }
  hasWhitespaceCharacter(t) {
    let e = _r(this, Lt);
    return Array.prototype.some.call(t, (r) => e.has(r));
  }
  hasNonWhitespaceCharacter(t) {
    let e = _r(this, Lt);
    return Array.prototype.some.call(t, (r) => !e.has(r));
  }
  isWhitespaceOnly(t) {
    let e = _r(this, Lt);
    return Array.prototype.every.call(t, (r) => e.has(r));
  }
};
Lt = /* @__PURE__ */ new WeakMap();
var Hw = qw, Vw = ["	", `
`, "\f", "\r", " "], zw = new Hw(Vw), ir = zw, Uw = class extends Error {
  constructor(e, r, n = "type") {
    super(`Unexpected ${r} node ${n}: ${JSON.stringify(e[n])}.`);
    Tr(this, "name", "UnexpectedNodeError");
    this.node = e;
  }
}, Gw = Uw;
function Kw(t) {
  return (t == null ? void 0 : t.type) === "front-matter";
}
var Oa = Kw, Yw = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "keySpan", "tagDefinition", "tokens", "valueTokens", "switchValueSourceSpan", "expSourceSpan", "valueSourceSpan"]), Jw = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function Zm(t, e) {
  var r;
  if (t.type === "text" || t.type === "comment" || Oa(t) || t.type === "yaml" || t.type === "toml")
    return null;
  if (t.type === "attribute" && delete e.value, t.type === "docType" && delete e.value, t.type === "angularControlFlowBlock" && (r = e.parameters) != null && r.children)
    for (let n of e.parameters.children)
      Jw.has(t.name) ? delete n.expression : n.expression = n.expression.trim();
  t.type === "angularIcuExpression" && (e.switchValue = t.switchValue.trim());
}
Zm.ignoredProperties = Yw;
var Xw = Zm;
async function Qw(t, e) {
  if (t.lang === "yaml") {
    let r = t.value.trim(), n = r ? await e(r, { parser: "yaml" }) : "";
    return Bw([t.startDelimiter, we, n, n ? we : "", t.endDelimiter]);
  }
}
var Zw = Qw;
function Ma(t, e = !0) {
  return [kr([Ve, t]), e ? Ve : ""];
}
function gi(t, e) {
  let r = t.type === "NGRoot" ? t.node.type === "NGMicrosyntax" && t.node.body.length === 1 && t.node.body[0].type === "NGMicrosyntaxExpression" ? t.node.body[0].expression : t.node : t.type === "JsExpressionRoot" ? t.node : t;
  return r && (r.type === "ObjectExpression" || r.type === "ArrayExpression" || (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && (r.type === "TemplateLiteral" || r.type === "StringLiteral"));
}
async function sr(t, e, r, n) {
  r = { __isInHtmlAttribute: !0, __embeddedInHtml: !0, ...r };
  let i = !0;
  n && (r.__onHtmlBindingRoot = (o, a) => {
    i = n(o, a);
  });
  let s = await e(t, r, e);
  return i ? Ge(s) : Ma(s);
}
function ex(t, e, r, n) {
  let { node: i } = r, s = n.originalText.slice(i.sourceSpan.start.offset, i.sourceSpan.end.offset);
  return /^\s*$/.test(s) ? "" : sr(s, t, { parser: "__ng_directive", __isInHtmlAttribute: !1, trailingComma: "none" }, gi);
}
var tx = ex, rx = (t) => String(t).split(/[/\\]/).pop();
function Af(t, e) {
  if (!e)
    return;
  let r = rx(e).toLowerCase();
  return t.find(({ filenames: n }) => n == null ? void 0 : n.some((i) => i.toLowerCase() === r)) ?? t.find(({ extensions: n }) => n == null ? void 0 : n.some((i) => r.endsWith(i)));
}
function nx(t, e) {
  if (e)
    return t.find(({ name: r }) => r.toLowerCase() === e) ?? t.find(({ aliases: r }) => r == null ? void 0 : r.includes(e)) ?? t.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${e}`));
}
function ix(t, e) {
  let r = t.plugins.flatMap((i) => i.languages ?? []), n = nx(r, e.language) ?? Af(r, e.physicalFile) ?? Af(r, e.file) ?? (e.physicalFile, void 0);
  return n == null ? void 0 : n.parsers[0];
}
var La = ix, sx = "inline", ox = { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", style: "none", template: "inline", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", dialog: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", search: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", menu: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", input: "inline-block", button: "inline-block", fieldset: "block", marquee: "inline-block", source: "block", track: "block", details: "block", summary: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, ax = "normal", lx = { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" };
function ux(t) {
  return t.type === "element" && !t.hasExplicitNamespace && !["html", "svg"].includes(t.namespace);
}
var ns = ux, cx = (t) => yt(!1, t, /^[\t\f\r ]*\n/g, ""), eg = (t) => cx(ir.trimEnd(t)), hx = (t) => {
  let e = t, r = ir.getLeadingWhitespace(e);
  r && (e = e.slice(r.length));
  let n = ir.getTrailingWhitespace(e);
  return n && (e = e.slice(0, -n.length)), { leadingWhitespace: r, trailingWhitespace: n, text: e };
};
function tg(t, e) {
  return !!(t.type === "ieConditionalComment" && t.lastChild && !t.lastChild.isSelfClosing && !t.lastChild.endSourceSpan || t.type === "ieConditionalComment" && !t.complete || ai(t) && t.children.some((r) => r.type !== "text" && r.type !== "interpolation") || qc(t, e) && !dr(t) && t.type !== "interpolation");
}
function Pa(t) {
  return t.type === "attribute" || !t.parent || !t.prev ? !1 : fx(t.prev);
}
function fx(t) {
  return t.type === "comment" && t.value.trim() === "prettier-ignore";
}
function Ct(t) {
  return t.type === "text" || t.type === "comment";
}
function dr(t) {
  return t.type === "element" && (t.fullName === "script" || t.fullName === "style" || t.fullName === "svg:style" || t.fullName === "svg:script" || ns(t) && (t.name === "script" || t.name === "style"));
}
function dx(t) {
  return t.children && !dr(t);
}
function px(t) {
  return dr(t) || t.type === "interpolation" || rg(t);
}
function rg(t) {
  return ug(t).startsWith("pre");
}
function mx(t, e) {
  var r, n;
  let i = s();
  if (i && !t.prev && (n = (r = t.parent) == null ? void 0 : r.tagDefinition) != null && n.ignoreFirstLf)
    return t.type === "interpolation";
  return i;
  function s() {
    return Oa(t) || t.type === "angularControlFlowBlock" ? !1 : (t.type === "text" || t.type === "interpolation") && t.prev && (t.prev.type === "text" || t.prev.type === "interpolation") ? !0 : !t.parent || t.parent.cssDisplay === "none" ? !1 : ai(t.parent) ? !0 : !(!t.prev && (t.parent.type === "root" || ai(t) && t.parent || dr(t.parent) || Na(t.parent, e) || !kx(t.parent.cssDisplay)) || t.prev && !Ax(t.prev.cssDisplay));
  }
}
function gx(t, e) {
  return Oa(t) || t.type === "angularControlFlowBlock" ? !1 : (t.type === "text" || t.type === "interpolation") && t.next && (t.next.type === "text" || t.next.type === "interpolation") ? !0 : !t.parent || t.parent.cssDisplay === "none" ? !1 : ai(t.parent) ? !0 : !(!t.next && (t.parent.type === "root" || ai(t) && t.parent || dr(t.parent) || Na(t.parent, e) || !Sx(t.parent.cssDisplay)) || t.next && !Ex(t.next.cssDisplay));
}
function yx(t) {
  return Fx(t.cssDisplay) && !dr(t);
}
function Vs(t) {
  return Oa(t) || t.next && t.sourceSpan.end && t.sourceSpan.end.line + 1 < t.next.sourceSpan.start.line;
}
function vx(t) {
  return ng(t) || t.type === "element" && t.children.length > 0 && (["body", "script", "style"].includes(t.name) || t.children.some((e) => Dx(e))) || t.firstChild && t.firstChild === t.lastChild && t.firstChild.type !== "text" && sg(t.firstChild) && (!t.lastChild.isTrailingSpaceSensitive || og(t.lastChild));
}
function ng(t) {
  return t.type === "element" && t.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(t.name) || t.cssDisplay.startsWith("table") && t.cssDisplay !== "table-cell");
}
function vl(t) {
  return ag(t) || t.prev && bx(t.prev) || ig(t);
}
function bx(t) {
  return ag(t) || t.type === "element" && t.fullName === "br" || ig(t);
}
function ig(t) {
  return sg(t) && og(t);
}
function sg(t) {
  return t.hasLeadingSpaces && (t.prev ? t.prev.sourceSpan.end.line < t.sourceSpan.start.line : t.parent.type === "root" || t.parent.startSourceSpan.end.line < t.sourceSpan.start.line);
}
function og(t) {
  return t.hasTrailingSpaces && (t.next ? t.next.sourceSpan.start.line > t.sourceSpan.end.line : t.parent.type === "root" || t.parent.endSourceSpan && t.parent.endSourceSpan.start.line > t.sourceSpan.end.line);
}
function ag(t) {
  switch (t.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return !0;
    case "element":
      return ["script", "select"].includes(t.name);
  }
  return !1;
}
function Wc(t) {
  return t.lastChild ? Wc(t.lastChild) : t;
}
function Dx(t) {
  var e;
  return (e = t.children) == null ? void 0 : e.some((r) => r.type !== "text");
}
function lg(t) {
  if (t)
    switch (t) {
      case "module":
      case "text/javascript":
      case "text/babel":
      case "application/javascript":
        return "babel";
      case "application/x-typescript":
        return "typescript";
      case "text/markdown":
        return "markdown";
      case "text/html":
        return "html";
      case "text/x-handlebars-template":
        return "glimmer";
      default:
        if (t.endsWith("json") || t.endsWith("importmap") || t === "speculationrules")
          return "json";
    }
}
function wx(t, e) {
  let { name: r, attrMap: n } = t;
  if (r !== "script" || Object.prototype.hasOwnProperty.call(n, "src"))
    return;
  let { type: i, lang: s } = t.attrMap;
  return !s && !i ? "babel" : La(e, { language: s }) ?? lg(i);
}
function xx(t, e) {
  if (!qc(t, e))
    return;
  let { attrMap: r } = t;
  if (Object.prototype.hasOwnProperty.call(r, "src"))
    return;
  let { type: n, lang: i } = r;
  return La(e, { language: i }) ?? lg(n);
}
function Cx(t, e) {
  if (t.name !== "style")
    return;
  let { lang: r } = t.attrMap;
  return r ? La(e, { language: r }) : "css";
}
function Ff(t, e) {
  return wx(t, e) ?? Cx(t, e) ?? xx(t, e);
}
function Ss(t) {
  return t === "block" || t === "list-item" || t.startsWith("table");
}
function kx(t) {
  return !Ss(t) && t !== "inline-block";
}
function Sx(t) {
  return !Ss(t) && t !== "inline-block";
}
function Ex(t) {
  return !Ss(t);
}
function Ax(t) {
  return !Ss(t);
}
function Fx(t) {
  return !Ss(t) && t !== "inline-block";
}
function ai(t) {
  return ug(t).startsWith("pre");
}
function Tx(t, e) {
  let r = t;
  for (; r; ) {
    if (e(r))
      return !0;
    r = r.parent;
  }
  return !1;
}
function _x(t, e) {
  var r;
  if (yi(t, e))
    return "block";
  if (((r = t.prev) == null ? void 0 : r.type) === "comment") {
    let i = t.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
    if (i)
      return i[1];
  }
  let n = !1;
  if (t.type === "element" && t.namespace === "svg")
    if (Tx(t, (i) => i.fullName === "svg:foreignObject"))
      n = !0;
    else
      return t.name === "svg" ? "inline-block" : "block";
  switch (e.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      return t.type === "element" && (!t.namespace || n || ns(t)) && ox[t.name] || sx;
  }
}
function ug(t) {
  return t.type === "element" && (!t.namespace || ns(t)) && lx[t.name] || ax;
}
function Bx(t) {
  let e = Number.POSITIVE_INFINITY;
  for (let r of t.split(`
`)) {
    if (r.length === 0)
      continue;
    let n = ir.getLeadingWhitespaceCount(r);
    if (n === 0)
      return 0;
    r.length !== n && n < e && (e = n);
  }
  return e === Number.POSITIVE_INFINITY ? 0 : e;
}
function cg(t, e = Bx(t)) {
  return e === 0 ? t : t.split(`
`).map((r) => r.slice(e)).join(`
`);
}
function hg(t) {
  return yt(!1, yt(!1, t, "&apos;", "'"), "&quot;", '"');
}
function en(t) {
  return hg(t.value);
}
var Ox = /* @__PURE__ */ new Set(["template", "style", "script"]);
function Na(t, e) {
  return yi(t, e) && !Ox.has(t.fullName);
}
function yi(t, e) {
  return e.parser === "vue" && t.type === "element" && t.parent.type === "root" && t.fullName.toLowerCase() !== "html";
}
function qc(t, e) {
  return yi(t, e) && (Na(t, e) || t.attrMap.lang && t.attrMap.lang !== "html");
}
function Mx(t) {
  let e = t.fullName;
  return e.charAt(0) === "#" || e === "slot-scope" || e === "v-slot" || e.startsWith("v-slot:");
}
function Lx(t, e) {
  let r = t.parent;
  if (!yi(r, e))
    return !1;
  let n = r.fullName, i = t.fullName;
  return n === "script" && i === "setup" || n === "style" && i === "vars";
}
function fg(t, e = t.value) {
  return t.parent.isWhitespaceSensitive ? t.parent.isIndentationSensitive ? It(e) : It(cg(eg(e)), we) : mi($e, ir.split(e));
}
function dg(t, e) {
  return yi(t, e) && t.name === "script";
}
var pg = /{{(.+?)}}/s;
async function Px(t, e) {
  let r = [];
  for (let [n, i] of t.split(pg).entries())
    if (n % 2 === 0)
      r.push(It(i));
    else
      try {
        r.push(Ge(["{{", kr([$e, await sr(i, e, { parser: "__ng_interpolation", __isInHtmlInterpolation: !0, trailingComma: "none" })]), $e, "}}"]));
      } catch {
        r.push("{{", It(i), "}}");
      }
  return r;
}
function Hc({ parser: t }) {
  return (e, r, n) => sr(en(n.node), e, { parser: t, trailingComma: "none" }, gi);
}
var Nx = Hc({ parser: "__ng_action" }), Rx = Hc({ parser: "__ng_binding" }), Ix = Hc({ parser: "__ng_directive" });
function $x(t, e) {
  if (e.parser !== "angular")
    return;
  let { node: r } = t, n = r.fullName;
  if (n.startsWith("(") && n.endsWith(")") || n.startsWith("on-"))
    return Nx;
  if (n.startsWith("[") && n.endsWith("]") || /^bind(?:on)?-/.test(n) || /^ng-(?:if|show|hide|class|style)$/.test(n))
    return Rx;
  if (n.startsWith("*"))
    return Ix;
  let i = en(r);
  if (/^i18n(?:-.+)?$/.test(n))
    return () => Ma(Qm(fg(r, i.trim())), !i.includes("@@"));
  if (pg.test(i))
    return (s) => Px(i, s);
}
var jx = $x;
function Wx(t, e) {
  let { node: r } = t, n = en(r);
  if (r.fullName === "class" && !e.parentParser && !n.includes("{{"))
    return () => n.trim().split(/\s+/).join(" ");
}
var qx = Wx;
function Tf(t) {
  return t === "	" || t === `
` || t === "\f" || t === "\r" || t === " ";
}
var Hx = /^[ \t\n\r\u000c]+/, Vx = /^[, \t\n\r\u000c]+/, zx = /^[^ \t\n\r\u000c]+/, Ux = /[,]+$/, _f = /^\d+$/, Gx = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
function Kx(t) {
  let e = t.length, r, n, i, s, o, a = 0, l;
  function c(d) {
    let p, m = d.exec(t.substring(a));
    if (m)
      return [p] = m, a += p.length, p;
  }
  let u = [];
  for (; ; ) {
    if (c(Vx), a >= e) {
      if (u.length === 0)
        throw new Error("Must contain one or more image candidate strings.");
      return u;
    }
    l = a, r = c(zx), n = [], r.slice(-1) === "," ? (r = r.replace(Ux, ""), f()) : h();
  }
  function h() {
    for (c(Hx), i = "", s = "in descriptor"; ; ) {
      if (o = t.charAt(a), s === "in descriptor")
        if (Tf(o))
          i && (n.push(i), i = "", s = "after descriptor");
        else if (o === ",") {
          a += 1, i && n.push(i), f();
          return;
        } else if (o === "(")
          i += o, s = "in parens";
        else if (o === "") {
          i && n.push(i), f();
          return;
        } else
          i += o;
      else if (s === "in parens")
        if (o === ")")
          i += o, s = "in descriptor";
        else if (o === "") {
          n.push(i), f();
          return;
        } else
          i += o;
      else if (s === "after descriptor" && !Tf(o))
        if (o === "") {
          f();
          return;
        } else
          s = "in descriptor", a -= 1;
      a += 1;
    }
  }
  function f() {
    let d = !1, p, m, y, v, g = {}, b, w, D, x, C;
    for (v = 0; v < n.length; v++)
      b = n[v], w = b[b.length - 1], D = b.substring(0, b.length - 1), x = parseInt(D, 10), C = parseFloat(D), _f.test(D) && w === "w" ? ((p || m) && (d = !0), x === 0 ? d = !0 : p = x) : Gx.test(D) && w === "x" ? ((p || m || y) && (d = !0), C < 0 ? d = !0 : m = C) : _f.test(D) && w === "h" ? ((y || m) && (d = !0), x === 0 ? d = !0 : y = x) : d = !0;
    if (!d)
      g.source = { value: r, startOffset: l }, p && (g.width = { value: p }), m && (g.density = { value: m }), y && (g.height = { value: y }), u.push(g);
    else
      throw new Error(`Invalid srcset descriptor found in "${t}" at "${b}".`);
  }
}
var Yx = Kx;
function Jx(t) {
  if (t.node.fullName === "srcset" && (t.parent.fullName === "img" || t.parent.fullName === "source"))
    return () => Qx(en(t.node));
}
var mg = { width: "w", height: "h", density: "x" }, Xx = Object.keys(mg);
function Qx(t) {
  let e = Yx(t), r = Xx.filter((u) => e.some((h) => Object.prototype.hasOwnProperty.call(h, u)));
  if (r.length > 1)
    throw new Error("Mixed descriptor in srcset is not supported");
  let [n] = r, i = mg[n], s = e.map((u) => u.source.value), o = Math.max(...s.map((u) => u.length)), a = e.map((u) => u[n] ? String(u[n].value) : ""), l = a.map((u) => {
    let h = u.indexOf(".");
    return h === -1 ? u.length : h;
  }), c = Math.max(...l);
  return Ma(mi([",", $e], s.map((u, h) => {
    let f = [u], d = a[h];
    if (d) {
      let p = o - u.length + 1, m = c - l[h], y = " ".repeat(p + m);
      f.push(jo(y, " "), d + i);
    }
    return f;
  })));
}
var Zx = Jx;
function eC(t, e) {
  let { node: r } = t, n = en(t.node).trim();
  if (r.fullName === "style" && !e.parentParser && !n.includes("{{"))
    return async (i) => Ma(await i(n, { parser: "css", __isHTMLStyleAttribute: !0 }));
}
var bl = /* @__PURE__ */ new WeakMap();
function tC(t, e) {
  let { root: r } = t;
  return bl.has(r) || bl.set(r, r.children.some((n) => dg(n, e) && ["ts", "typescript"].includes(n.attrMap.lang))), bl.get(r);
}
var Vc = tC;
function rC(t, e, r) {
  let { node: n } = r, i = en(n);
  return sr(`type T<${i}> = any`, t, { parser: "babel-ts", __isEmbeddedTypescriptGenericParameters: !0 }, gi);
}
function nC(t, e, { parseWithTs: r }) {
  return sr(`function _(${t}) {}`, e, { parser: r ? "babel-ts" : "babel", __isVueBindings: !0 });
}
function iC(t) {
  let e = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, r = /^[$_a-z][\w$]*(?:\.[$_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$_a-z][\w$]*])*$/i, n = t.trim();
  return e.test(n) || r.test(n);
}
async function sC(t, e, r, n) {
  let i = en(r.node), { left: s, operator: o, right: a } = oC(i), l = Vc(r, n);
  return [Ge(await sr(`function _(${s}) {}`, t, { parser: l ? "babel-ts" : "babel", __isVueForBindingLeft: !0 })), " ", o, " ", await sr(a, t, { parser: l ? "__ts_expression" : "__js_expression" })];
}
function oC(t) {
  let e = /(.*?)\s+(in|of)\s+(.*)/s, r = /,([^,\]}]*)(?:,([^,\]}]*))?$/, n = /^\(|\)$/g, i = t.match(e);
  if (!i)
    return;
  let s = {};
  if (s.for = i[3].trim(), !s.for)
    return;
  let o = yt(!1, i[1].trim(), n, ""), a = o.match(r);
  a ? (s.alias = o.replace(r, ""), s.iterator1 = a[1].trim(), a[2] && (s.iterator2 = a[2].trim())) : s.alias = o;
  let l = [s.alias, s.iterator1, s.iterator2];
  if (!l.some((c, u) => !c && (u === 0 || l.slice(u + 1).some(Boolean))))
    return { left: l.filter(Boolean).join(","), operator: i[2], right: s.for };
}
function aC(t, e) {
  if (e.parser !== "vue")
    return;
  let { node: r } = t, n = r.fullName;
  if (n === "v-for")
    return sC;
  if (n === "generic" && dg(r.parent, e))
    return rC;
  let i = en(r), s = Vc(t, e);
  if (Mx(r) || Lx(r, e))
    return (o) => nC(i, o, { parseWithTs: s });
  if (n.startsWith("@") || n.startsWith("v-on:"))
    return (o) => lC(i, o, { parseWithTs: s });
  if (n.startsWith(":") || n.startsWith("v-bind:"))
    return (o) => uC(i, o, { parseWithTs: s });
  if (n.startsWith("v-"))
    return (o) => gg(i, o, { parseWithTs: s });
}
function lC(t, e, { parseWithTs: r }) {
  return iC(t) ? gg(t, e, { parseWithTs: r }) : sr(t, e, { parser: r ? "__vue_ts_event_binding" : "__vue_event_binding" }, gi);
}
function uC(t, e, { parseWithTs: r }) {
  return sr(t, e, { parser: r ? "__vue_ts_expression" : "__vue_expression" }, gi);
}
function gg(t, e, { parseWithTs: r }) {
  return sr(t, e, { parser: r ? "__ts_expression" : "__js_expression" }, gi);
}
var cC = aC;
function hC(t, e) {
  let { node: r } = t;
  if (r.value) {
    if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(e.originalText.slice(r.valueSpan.start.offset, r.valueSpan.end.offset)) || e.parser === "lwc" && r.value.startsWith("{") && r.value.endsWith("}"))
      return [r.rawName, "=", r.value];
    for (let n of [Zx, eC, qx, cC, jx]) {
      let i = n(t, e);
      if (i)
        return fC(i);
    }
  }
}
function fC(t) {
  return async (e, r, n, i) => {
    let s = await t(e, r, n, i);
    if (s)
      return s = jc(s, (o) => typeof o == "string" ? yt(!1, o, '"', "&quot;") : o), [n.node.rawName, '="', Ge(s), '"'];
  };
}
var dC = hC, yg = new Proxy(() => {
}, { get: () => yg }), vg = yg;
function pC(t) {
  return Array.isArray(t) && t.length > 0;
}
var zc = pC;
function Ra(t) {
  return t.sourceSpan.start.offset;
}
function Ia(t) {
  return t.sourceSpan.end.offset;
}
function cu(t, e) {
  return [t.isSelfClosing ? "" : mC(t, e), Gi(t, e)];
}
function mC(t, e) {
  return t.lastChild && is(t.lastChild) ? "" : [gC(t, e), Uc(t, e)];
}
function Gi(t, e) {
  return (t.next ? wn(t.next) : As(t.parent)) ? "" : [Es(t, e), Dn(t, e)];
}
function gC(t, e) {
  return As(t) ? Es(t.lastChild, e) : "";
}
function Dn(t, e) {
  return is(t) ? Uc(t.parent, e) : $a(t) ? Gc(t.next) : "";
}
function Uc(t, e) {
  if (vg(!t.isSelfClosing), bg(t, e))
    return "";
  switch (t.type) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (t.hasHtmComponentClosingTag)
        return "<//";
    default:
      return `</${t.rawName}`;
  }
}
function Es(t, e) {
  if (bg(t, e))
    return "";
  switch (t.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "angularIcuExpression":
      return "}";
    case "element":
      if (t.isSelfClosing)
        return "/>";
    default:
      return ">";
  }
}
function bg(t, e) {
  return !t.isSelfClosing && !t.endSourceSpan && (Pa(t) || tg(t.parent, e));
}
function wn(t) {
  return t.prev && t.prev.type !== "docType" && t.type !== "angularControlFlowBlock" && !Ct(t.prev) && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
}
function As(t) {
  var e;
  return ((e = t.lastChild) == null ? void 0 : e.isTrailingSpaceSensitive) && !t.lastChild.hasTrailingSpaces && !Ct(Wc(t.lastChild)) && !ai(t);
}
function is(t) {
  return !t.next && !t.hasTrailingSpaces && t.isTrailingSpaceSensitive && Ct(Wc(t));
}
function $a(t) {
  return t.next && !Ct(t.next) && Ct(t) && t.isTrailingSpaceSensitive && !t.hasTrailingSpaces;
}
function yC(t) {
  let e = t.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
  return e ? e[1] ? e[1].split(/\s+/) : !0 : !1;
}
function ja(t) {
  return !t.prev && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
}
function vC(t, e, r) {
  var n;
  let { node: i } = t;
  if (!zc(i.attrs))
    return i.isSelfClosing ? " " : "";
  let s = ((n = i.prev) == null ? void 0 : n.type) === "comment" && yC(i.prev.value), o = typeof s == "boolean" ? () => s : Array.isArray(s) ? (h) => s.includes(h.rawName) : () => !1, a = t.map(({ node: h }) => o(h) ? It(e.originalText.slice(Ra(h), Ia(h))) : r(), "attrs"), l = i.type === "element" && i.fullName === "script" && i.attrs.length === 1 && i.attrs[0].fullName === "src" && i.children.length === 0, c = e.singleAttributePerLine && i.attrs.length > 1 && !yi(i, e) ? we : $e, u = [kr([l ? " " : $e, mi(c, a)])];
  return i.firstChild && ja(i.firstChild) || i.isSelfClosing && As(i.parent) || l ? u.push(i.isSelfClosing ? " " : "") : u.push(e.bracketSameLine ? i.isSelfClosing ? " " : "" : i.isSelfClosing ? $e : Ve), u;
}
function bC(t) {
  return t.firstChild && ja(t.firstChild) ? "" : Kc(t);
}
function hu(t, e, r) {
  let { node: n } = t;
  return [Ki(n, e), vC(t, e, r), n.isSelfClosing ? "" : bC(n)];
}
function Ki(t, e) {
  return t.prev && $a(t.prev) ? "" : [xn(t, e), Gc(t)];
}
function xn(t, e) {
  return ja(t) ? Kc(t.parent) : wn(t) ? Es(t.prev, e) : "";
}
function Gc(t) {
  switch (t.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${t.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType":
      return t.value === "html" ? "<!doctype" : "<!DOCTYPE";
    case "angularIcuExpression":
      return "{";
    case "element":
      if (t.condition)
        return `<!--[if ${t.condition}]><!--><${t.rawName}`;
    default:
      return `<${t.rawName}`;
  }
}
function Kc(t) {
  switch (vg(!t.isSelfClosing), t.type) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (t.condition)
        return "><!--<![endif]-->";
    default:
      return ">";
  }
}
function DC(t, e) {
  if (!t.endSourceSpan)
    return "";
  let r = t.startSourceSpan.end.offset;
  t.firstChild && ja(t.firstChild) && (r -= Kc(t).length);
  let n = t.endSourceSpan.start.offset;
  return t.lastChild && is(t.lastChild) ? n += Uc(t, e).length : As(t) && (n -= Es(t.lastChild, e).length), e.originalText.slice(r, n);
}
var Dg = DC, wC = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function xC(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "element":
      if (dr(r) || r.type === "interpolation")
        return;
      if (!r.isSelfClosing && qc(r, e)) {
        let n = Ff(r, e);
        return n ? async (i, s) => {
          let o = Dg(r, e), a = /^\s*$/.test(o), l = "";
          return a || (l = await i(eg(o), { parser: n, __embeddedInHtml: !0 }), a = l === ""), [xn(r, e), Ge(hu(t, e, s)), a ? "" : we, l, a ? "" : we, cu(r, e), Dn(r, e)];
        } : void 0;
      }
      break;
    case "text":
      if (dr(r.parent)) {
        let n = Ff(r.parent, e);
        if (n)
          return async (i) => {
            let s = n === "markdown" ? cg(r.value.replace(/^[^\S\n]*\n/, "")) : r.value, o = { parser: n, __embeddedInHtml: !0 };
            if (e.parser === "html" && n === "babel") {
              let a = "script", { attrMap: l } = r.parent;
              l && (l.type === "module" || l.type === "text/babel" && l["data-type"] === "module") && (a = "module"), o.__babelSourceType = a;
            }
            return [Cs, xn(r, e), await i(s, o), Dn(r, e)];
          };
      } else if (r.parent.type === "interpolation")
        return async (n) => {
          let i = { __isInHtmlInterpolation: !0, __embeddedInHtml: !0 };
          return e.parser === "angular" ? (i.parser = "__ng_interpolation", i.trailingComma = "none") : e.parser === "vue" ? i.parser = Vc(t, e) ? "__vue_ts_expression" : "__vue_expression" : i.parser = "__js_expression", [kr([$e, await n(r.value, i)]), r.parent.next && wn(r.parent.next) ? " " : $e];
        };
      break;
    case "attribute":
      return dC(t, e);
    case "front-matter":
      return (n) => Zw(r, n);
    case "angularControlFlowBlockParameters":
      return wC.has(t.parent.name) ? tx : void 0;
  }
}
var CC = xC, Si = null;
function Yi(t) {
  if (Si !== null && typeof Si.property) {
    let e = Si;
    return Si = Yi.prototype = null, e;
  }
  return Si = Yi.prototype = t ?? /* @__PURE__ */ Object.create(null), new Yi();
}
var kC = 10;
for (let t = 0; t <= kC; t++)
  Yi();
function SC(t) {
  return Yi(t);
}
function EC(t, e = "type") {
  SC(t);
  function r(n) {
    let i = n[e], s = t[i];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: n });
    return s;
  }
  return r;
}
var AC = EC, FC = { "front-matter": [], root: ["children"], element: ["attrs", "children"], ieConditionalComment: ["children"], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ["children"], text: ["children"], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ["children", "parameters"], angularControlFlowBlockParameters: ["children"], angularControlFlowBlockParameter: [], angularIcuExpression: ["cases"], angularIcuCase: ["expression"] }, TC = FC, _C = AC(TC), BC = _C;
function OC(t) {
  return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(t);
}
function MC(t) {
  return `<!-- @format -->

` + t;
}
var LC = /* @__PURE__ */ new Map([["if", /* @__PURE__ */ new Set(["else if", "else"])], ["else if", /* @__PURE__ */ new Set(["else if", "else"])], ["for", /* @__PURE__ */ new Set(["empty"])], ["defer", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["placeholder", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["error", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["loading", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])]]);
function wg(t) {
  let e = Ia(t);
  return t.type === "element" && !t.endSourceSpan && zc(t.children) ? Math.max(e, wg(ks(!1, t.children, -1))) : e;
}
function Ei(t, e, r) {
  let n = t.node;
  if (Pa(n)) {
    let i = wg(n);
    return [xn(n, e), It(ir.trimEnd(e.originalText.slice(Ra(n) + (n.prev && $a(n.prev) ? Gc(n).length : 0), i - (n.next && wn(n.next) ? Es(n, e).length : 0)))), Dn(n, e)];
  }
  return r();
}
function zs(t, e) {
  return Ct(t) && Ct(e) ? t.isTrailingSpaceSensitive ? t.hasTrailingSpaces ? vl(e) ? we : $e : "" : vl(e) ? we : Ve : $a(t) && (Pa(e) || e.firstChild || e.isSelfClosing || e.type === "element" && e.attrs.length > 0) || t.type === "element" && t.isSelfClosing && wn(e) ? "" : !e.isLeadingSpaceSensitive || vl(e) || wn(e) && t.lastChild && is(t.lastChild) && t.lastChild.lastChild && is(t.lastChild.lastChild) ? we : e.hasLeadingSpaces ? $e : Ve;
}
function Yc(t, e, r) {
  let { node: n } = t;
  if (ng(n))
    return [Cs, ...t.map((s) => {
      let o = s.node, a = o.prev ? zs(o.prev, o) : "";
      return [a ? [a, Vs(o.prev) ? we : ""] : "", Ei(s, e, r)];
    }, "children")];
  let i = n.children.map(() => Symbol(""));
  return t.map((s, o) => {
    let a = s.node;
    if (Ct(a)) {
      if (a.prev && Ct(a.prev)) {
        let p = zs(a.prev, a);
        if (p)
          return Vs(a.prev) ? [we, we, Ei(s, e, r)] : [p, Ei(s, e, r)];
      }
      return Ei(s, e, r);
    }
    let l = [], c = [], u = [], h = [], f = a.prev ? zs(a.prev, a) : "", d = a.next ? zs(a, a.next) : "";
    return f && (Vs(a.prev) ? l.push(we, we) : f === we ? l.push(we) : Ct(a.prev) ? c.push(f) : c.push(jo("", Ve, { groupId: i[o - 1] }))), d && (Vs(a) ? Ct(a.next) && h.push(we, we) : d === we ? Ct(a.next) && h.push(we) : u.push(d)), [...l, Ge([...c, Ge([Ei(s, e, r), ...u], { id: i[o] })]), ...h];
  }, "children");
}
function PC(t, e, r) {
  let { node: n } = t, i = [];
  NC(t) && i.push("} "), i.push("@", n.name), n.parameters && i.push(" (", Ge(r("parameters")), ")"), i.push(" {");
  let s = xg(n);
  return n.children.length > 0 ? (n.firstChild.hasLeadingSpaces = !0, n.lastChild.hasTrailingSpaces = !0, i.push(kr([we, Yc(t, e, r)])), s && i.push(we, "}")) : s && i.push("}"), Ge(i, { shouldBreak: !0 });
}
function xg(t) {
  var e, r;
  return !(((e = t.next) == null ? void 0 : e.type) === "angularControlFlowBlock" && (r = LC.get(t.name)) != null && r.has(t.next.name));
}
function NC(t) {
  let { previous: e } = t;
  return (e == null ? void 0 : e.type) === "angularControlFlowBlock" && !Pa(e) && !xg(e);
}
function RC(t, e, r) {
  return [kr([Ve, mi([";", $e], t.map(r, "children"))]), Ve];
}
function IC(t, e, r) {
  let { node: n } = t;
  return [Ki(n, e), Ge([n.switchValue.trim(), ", ", n.clause, n.cases.length > 0 ? [",", kr([$e, mi($e, t.map(r, "cases"))])] : "", Ve]), Gi(n, e)];
}
function $C(t, e, r) {
  let { node: n } = t;
  return [n.value, " {", Ge([kr([Ve, t.map(({ node: i }) => i.type === "text" && !ir.trim(i.value) ? "" : r(), "expression")]), Ve]), "}"];
}
function jC(t, e, r) {
  let { node: n } = t;
  if (tg(n, e))
    return [xn(n, e), Ge(hu(t, e, r)), It(Dg(n, e)), ...cu(n, e), Dn(n, e)];
  let i = n.children.length === 1 && (n.firstChild.type === "interpolation" || n.firstChild.type === "angularIcuExpression") && n.firstChild.isLeadingSpaceSensitive && !n.firstChild.hasLeadingSpaces && n.lastChild.isTrailingSpaceSensitive && !n.lastChild.hasTrailingSpaces, s = Symbol("element-attr-group-id"), o = (u) => Ge([Ge(hu(t, e, r), { id: s }), u, cu(n, e)]), a = (u) => i ? Ow(u, { groupId: s }) : (dr(n) || Na(n, e)) && n.parent.type === "root" && e.parser === "vue" && !e.vueIndentScriptAndStyle ? u : kr(u), l = () => i ? jo(Ve, "", { groupId: s }) : n.firstChild.hasLeadingSpaces && n.firstChild.isLeadingSpaceSensitive ? $e : n.firstChild.type === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive ? _w(Ve) : Ve, c = () => (n.next ? wn(n.next) : As(n.parent)) ? n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? " " : "" : i ? jo(Ve, "", { groupId: s }) : n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? $e : (n.lastChild.type === "comment" || n.lastChild.type === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${e.tabWidth * (t.ancestors.length - 1)}}$`).test(n.lastChild.value) ? "" : Ve;
  return n.children.length === 0 ? o(n.hasDanglingSpaces && n.isDanglingSpaceSensitive ? $e : "") : o([vx(n) ? Cs : "", a([l(), Yc(t, e, r)]), c()]);
}
function Jc(t) {
  return t >= 9 && t <= 32 || t == 160;
}
function Cg(t) {
  return 48 <= t && t <= 57;
}
function Xc(t) {
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function WC(t) {
  return t >= 97 && t <= 102 || t >= 65 && t <= 70 || Cg(t);
}
function kg(t) {
  return t === 10 || t === 13;
}
function Bf(t) {
  return 48 <= t && t <= 55;
}
function Of(t) {
  return t === 39 || t === 34 || t === 96;
}
var qC = /-+([a-z0-9])/g;
function HC(t) {
  return t.replace(qC, (...e) => e[1].toUpperCase());
}
var fu = class Sg {
  constructor(e, r, n, i) {
    this.file = e, this.offset = r, this.line = n, this.col = i;
  }
  toString() {
    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
  }
  moveBy(e) {
    let r = this.file.content, n = r.length, i = this.offset, s = this.line, o = this.col;
    for (; i > 0 && e < 0; )
      if (i--, e++, r.charCodeAt(i) == 10) {
        s--;
        let a = r.substring(0, i - 1).lastIndexOf(`
`);
        o = a > 0 ? i - a : i;
      } else
        o--;
    for (; i < n && e > 0; ) {
      let a = r.charCodeAt(i);
      i++, e--, a == 10 ? (s++, o = 0) : o++;
    }
    return new Sg(this.file, i, s, o);
  }
  getContext(e, r) {
    let n = this.file.content, i = this.offset;
    if (i != null) {
      i > n.length - 1 && (i = n.length - 1);
      let s = i, o = 0, a = 0;
      for (; o < e && i > 0 && (i--, o++, !(n[i] == `
` && ++a == r)); )
        ;
      for (o = 0, a = 0; o < e && s < n.length - 1 && (s++, o++, !(n[s] == `
` && ++a == r)); )
        ;
      return { before: n.substring(i, this.offset), after: n.substring(this.offset, s + 1) };
    }
    return null;
  }
}, Eg = class {
  constructor(e, r) {
    this.content = e, this.url = r;
  }
}, ne = class {
  constructor(t, e, r = t, n = null) {
    this.start = t, this.end = e, this.fullStart = r, this.details = n;
  }
  toString() {
    return this.start.file.content.substring(this.start.offset, this.end.offset);
  }
}, Wo;
(function(t) {
  t[t.WARNING = 0] = "WARNING", t[t.ERROR = 1] = "ERROR";
})(Wo || (Wo = {}));
var Ag = class {
  constructor(e, r, n = Wo.ERROR) {
    this.span = e, this.msg = r, this.level = n;
  }
  contextualMessage() {
    let e = this.span.start.getContext(100, 3);
    return e ? `${this.msg} ("${e.before}[${Wo[this.level]} ->]${e.after}")` : this.msg;
  }
  toString() {
    let e = this.span.details ? `, ${this.span.details}` : "";
    return `${this.contextualMessage()}: ${this.span.start}${e}`;
  }
}, VC = [UC, GC, YC, XC, QC, tk, ZC, ek, rk, JC];
function zC(t, e) {
  for (let r of VC)
    r(t, e);
  return t;
}
function UC(t) {
  t.walk((e) => {
    if (e.type === "element" && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && e.children[0].type === "text" && e.children[0].value[0] === `
`) {
      let r = e.children[0];
      r.value.length === 1 ? e.removeChild(r) : r.value = r.value.slice(1);
    }
  });
}
function GC(t) {
  let e = (r) => {
    var n, i;
    return r.type === "element" && ((n = r.prev) == null ? void 0 : n.type) === "ieConditionalStartComment" && r.prev.sourceSpan.end.offset === r.startSourceSpan.start.offset && ((i = r.firstChild) == null ? void 0 : i.type) === "ieConditionalEndComment" && r.firstChild.sourceSpan.start.offset === r.startSourceSpan.end.offset;
  };
  t.walk((r) => {
    if (r.children)
      for (let n = 0; n < r.children.length; n++) {
        let i = r.children[n];
        if (!e(i))
          continue;
        let s = i.prev, o = i.firstChild;
        r.removeChild(s), n--;
        let a = new ne(s.sourceSpan.start, o.sourceSpan.end), l = new ne(a.start, i.sourceSpan.end);
        i.condition = s.condition, i.sourceSpan = l, i.startSourceSpan = a, i.removeChild(o);
      }
  });
}
function KC(t, e, r) {
  t.walk((n) => {
    if (n.children)
      for (let i = 0; i < n.children.length; i++) {
        let s = n.children[i];
        if (s.type !== "text" && !e(s))
          continue;
        s.type !== "text" && (s.type = "text", s.value = r(s));
        let o = s.prev;
        !o || o.type !== "text" || (o.value += s.value, o.sourceSpan = new ne(o.sourceSpan.start, s.sourceSpan.end), n.removeChild(s), i--);
      }
  });
}
function YC(t) {
  return KC(t, (e) => e.type === "cdata", (e) => `<![CDATA[${e.value}]]>`);
}
function JC(t) {
  let e = (r) => {
    var n, i;
    return r.type === "element" && r.attrs.length === 0 && r.children.length === 1 && r.firstChild.type === "text" && !ir.hasWhitespaceCharacter(r.children[0].value) && !r.firstChild.hasLeadingSpaces && !r.firstChild.hasTrailingSpaces && r.isLeadingSpaceSensitive && !r.hasLeadingSpaces && r.isTrailingSpaceSensitive && !r.hasTrailingSpaces && ((n = r.prev) == null ? void 0 : n.type) === "text" && ((i = r.next) == null ? void 0 : i.type) === "text";
  };
  t.walk((r) => {
    if (r.children)
      for (let n = 0; n < r.children.length; n++) {
        let i = r.children[n];
        if (!e(i))
          continue;
        let s = i.prev, o = i.next;
        s.value += `<${i.rawName}>` + i.firstChild.value + `</${i.rawName}>` + o.value, s.sourceSpan = new ne(s.sourceSpan.start, o.sourceSpan.end), s.isTrailingSpaceSensitive = o.isTrailingSpaceSensitive, s.hasTrailingSpaces = o.hasTrailingSpaces, r.removeChild(i), n--, r.removeChild(o);
      }
  });
}
function XC(t, e) {
  if (e.parser === "html")
    return;
  let r = /{{(.+?)}}/s;
  t.walk((n) => {
    if (dx(n))
      for (let i of n.children) {
        if (i.type !== "text")
          continue;
        let s = i.sourceSpan.start, o = null, a = i.value.split(r);
        for (let l = 0; l < a.length; l++, s = o) {
          let c = a[l];
          if (l % 2 === 0) {
            o = s.moveBy(c.length), c.length > 0 && n.insertChildBefore(i, { type: "text", value: c, sourceSpan: new ne(s, o) });
            continue;
          }
          o = s.moveBy(c.length + 4), n.insertChildBefore(i, { type: "interpolation", sourceSpan: new ne(s, o), children: c.length === 0 ? [] : [{ type: "text", value: c, sourceSpan: new ne(s.moveBy(2), o.moveBy(-2)) }] });
        }
        n.removeChild(i);
      }
  });
}
function QC(t) {
  t.walk((e) => {
    if (!e.children)
      return;
    if (e.children.length === 0 || e.children.length === 1 && e.children[0].type === "text" && ir.trim(e.children[0].value).length === 0) {
      e.hasDanglingSpaces = e.children.length > 0, e.children = [];
      return;
    }
    let r = px(e), n = rg(e);
    if (!r)
      for (let i = 0; i < e.children.length; i++) {
        let s = e.children[i];
        if (s.type !== "text")
          continue;
        let { leadingWhitespace: o, text: a, trailingWhitespace: l } = hx(s.value), c = s.prev, u = s.next;
        a ? (s.value = a, s.sourceSpan = new ne(s.sourceSpan.start.moveBy(o.length), s.sourceSpan.end.moveBy(-l.length)), o && (c && (c.hasTrailingSpaces = !0), s.hasLeadingSpaces = !0), l && (s.hasTrailingSpaces = !0, u && (u.hasLeadingSpaces = !0))) : (e.removeChild(s), i--, (o || l) && (c && (c.hasTrailingSpaces = !0), u && (u.hasLeadingSpaces = !0)));
      }
    e.isWhitespaceSensitive = r, e.isIndentationSensitive = n;
  });
}
function ZC(t) {
  t.walk((e) => {
    e.isSelfClosing = !e.children || e.type === "element" && (e.tagDefinition.isVoid || e.endSourceSpan && e.startSourceSpan.start === e.endSourceSpan.start && e.startSourceSpan.end === e.endSourceSpan.end);
  });
}
function ek(t, e) {
  t.walk((r) => {
    r.type === "element" && (r.hasHtmComponentClosingTag = r.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(e.originalText.slice(r.endSourceSpan.start.offset, r.endSourceSpan.end.offset)));
  });
}
function tk(t, e) {
  t.walk((r) => {
    r.cssDisplay = _x(r, e);
  });
}
function rk(t, e) {
  t.walk((r) => {
    let { children: n } = r;
    if (n) {
      if (n.length === 0) {
        r.isDanglingSpaceSensitive = yx(r);
        return;
      }
      for (let i of n)
        i.isLeadingSpaceSensitive = mx(i, e), i.isTrailingSpaceSensitive = gx(i, e);
      for (let i = 0; i < n.length; i++) {
        let s = n[i];
        s.isLeadingSpaceSensitive = (i === 0 || s.prev.isTrailingSpaceSensitive) && s.isLeadingSpaceSensitive, s.isTrailingSpaceSensitive = (i === n.length - 1 || s.next.isLeadingSpaceSensitive) && s.isTrailingSpaceSensitive;
      }
    }
  });
}
var nk = zC;
function ik(t, e, r) {
  let { node: n } = t;
  switch (n.type) {
    case "front-matter":
      return It(n.raw);
    case "root":
      return e.__onHtmlRoot && e.__onHtmlRoot(n), [Ge(Yc(t, e, r)), we];
    case "element":
    case "ieConditionalComment":
      return jC(t, e, r);
    case "angularControlFlowBlock":
      return PC(t, e, r);
    case "angularControlFlowBlockParameters":
      return RC(t, e, r);
    case "angularControlFlowBlockParameter":
      return ir.trim(n.expression);
    case "angularIcuExpression":
      return IC(t, e, r);
    case "angularIcuCase":
      return $C(t, e, r);
    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return [Ki(n), Gi(n)];
    case "interpolation":
      return [Ki(n, e), ...t.map(r, "children"), Gi(n, e)];
    case "text": {
      if (n.parent.type === "interpolation") {
        let s = /\n[^\S\n]*$/, o = s.test(n.value), a = o ? n.value.replace(s, "") : n.value;
        return [It(a), o ? we : ""];
      }
      let i = Iw([xn(n, e), ...fg(n), Dn(n, e)]);
      return Array.isArray(i) ? Qm(i) : i;
    }
    case "docType":
      return [Ge([Ki(n, e), " ", yt(!1, n.value.replace(/^html\b/i, "html"), /\s+/g, " ")]), Gi(n, e)];
    case "comment":
      return [xn(n, e), It(e.originalText.slice(Ra(n), Ia(n))), Dn(n, e)];
    case "attribute": {
      if (n.value === null)
        return n.rawName;
      let i = hg(n.value), s = jw(i, '"');
      return [n.rawName, "=", s, It(s === '"' ? yt(!1, i, '"', "&quot;") : yt(!1, i, "'", "&apos;")), s];
    }
    case "cdata":
    default:
      throw new Gw(n, "HTML");
  }
}
var sk = { preprocess: nk, print: ik, insertPragma: MC, massageAstNode: Xw, embed: CC, getVisitorKeys: BC }, ok = sk, ak = [{ linguistLanguageId: 146, name: "Angular", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".component.html"], parsers: ["angular"], vscodeLanguageIds: ["html"], filenames: [] }, { linguistLanguageId: 146, name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml", ".mjml"], parsers: ["html"], vscodeLanguageIds: ["html"] }, { linguistLanguageId: 146, name: "Lightning Web Components", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [], parsers: ["lwc"], vscodeLanguageIds: ["html"], filenames: [] }, { linguistLanguageId: 391, name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", parsers: ["vue"], vscodeLanguageIds: ["vue"] }], Mf = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, Lf = "HTML", lk = { bracketSameLine: Mf.bracketSameLine, htmlWhitespaceSensitivity: { category: Lf, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: Mf.singleAttributePerLine, vueIndentScriptAndStyle: { category: Lf, type: "boolean", default: !1, description: "Indent script and style tags in Vue files." } }, uk = lk, Fg = {};
Um(Fg, { angular: () => hS, html: () => cS, lwc: () => dS, vue: () => fS });
var Pf;
(function(t) {
  t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom";
})(Pf || (Pf = {}));
var Nf;
(function(t) {
  t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default";
})(Nf || (Nf = {}));
var Rf = { name: "custom-elements" }, If = { name: "no-errors-schema" }, fn;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL";
})(fn || (fn = {}));
var $f;
(function(t) {
  t[t.Error = 0] = "Error", t[t.Warning = 1] = "Warning", t[t.Ignore = 2] = "Ignore";
})($f || ($f = {}));
var Rt;
(function(t) {
  t[t.RAW_TEXT = 0] = "RAW_TEXT", t[t.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", t[t.PARSABLE_DATA = 2] = "PARSABLE_DATA";
})(Rt || (Rt = {}));
function Wa(t) {
  if (t[0] != ":")
    return [null, t];
  let e = t.indexOf(":", 1);
  if (e === -1)
    throw new Error(`Unsupported format "${t}" expecting ":namespace:name"`);
  return [t.slice(1, e), t.slice(e + 1)];
}
function jf(t) {
  return Wa(t)[1] === "ng-container";
}
function Wf(t) {
  return Wa(t)[1] === "ng-content";
}
function ko(t) {
  return t === null ? null : Wa(t)[0];
}
function qo(t, e) {
  return t ? `:${t}:${e}` : e;
}
var So;
function qf() {
  return So || (So = {}, Us(fn.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), Us(fn.STYLE, ["*|style"]), Us(fn.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), Us(fn.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), So;
}
function Us(t, e) {
  for (let r of e)
    So[r.toLowerCase()] = t;
}
var ck = class {
}, hk = "boolean", fk = "number", dk = "string", pk = "object", mk = ["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|"], Tg = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" })), gk = Array.from(Tg).reduce((t, [e, r]) => (t.set(e, r), t), /* @__PURE__ */ new Map()), yk = class extends ck {
  constructor() {
    super(), this._schema = /* @__PURE__ */ new Map(), this._eventSchema = /* @__PURE__ */ new Map(), mk.forEach((e) => {
      let r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), [i, s] = e.split("|"), o = s.split(","), [a, l] = i.split("^");
      a.split(",").forEach((u) => {
        this._schema.set(u.toLowerCase(), r), this._eventSchema.set(u.toLowerCase(), n);
      });
      let c = l && this._schema.get(l.toLowerCase());
      if (c) {
        for (let [u, h] of c)
          r.set(u, h);
        for (let u of this._eventSchema.get(l.toLowerCase()))
          n.add(u);
      }
      o.forEach((u) => {
        if (u.length > 0)
          switch (u[0]) {
            case "*":
              n.add(u.substring(1));
              break;
            case "!":
              r.set(u.substring(1), hk);
              break;
            case "#":
              r.set(u.substring(1), fk);
              break;
            case "%":
              r.set(u.substring(1), pk);
              break;
            default:
              r.set(u, dk);
          }
      });
    });
  }
  hasProperty(e, r, n) {
    if (n.some((i) => i.name === If.name))
      return !0;
    if (e.indexOf("-") > -1) {
      if (jf(e) || Wf(e))
        return !1;
      if (n.some((i) => i.name === Rf.name))
        return !0;
    }
    return (this._schema.get(e.toLowerCase()) || this._schema.get("unknown")).has(r);
  }
  hasElement(e, r) {
    return r.some((n) => n.name === If.name) || e.indexOf("-") > -1 && (jf(e) || Wf(e) || r.some((n) => n.name === Rf.name)) ? !0 : this._schema.has(e.toLowerCase());
  }
  securityContext(e, r, n) {
    n && (r = this.getMappedPropName(r)), e = e.toLowerCase(), r = r.toLowerCase();
    let i = qf()[e + "|" + r];
    return i || (i = qf()["*|" + r], i || fn.NONE);
  }
  getMappedPropName(e) {
    return Tg.get(e) ?? e;
  }
  getDefaultComponentElementName() {
    return "ng-component";
  }
  validateProperty(e) {
    return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...
If '${e}' is a directive input, make sure the directive is imported by the current module.` } : { error: !1 };
  }
  validateAttribute(e) {
    return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...` } : { error: !1 };
  }
  allKnownElementNames() {
    return Array.from(this._schema.keys());
  }
  allKnownAttributesOfElement(e) {
    let r = this._schema.get(e.toLowerCase()) || this._schema.get("unknown");
    return Array.from(r.keys()).map((n) => gk.get(n) ?? n);
  }
  allKnownEventsOfElement(e) {
    return Array.from(this._eventSchema.get(e.toLowerCase()) ?? []);
  }
  normalizeAnimationStyleProperty(e) {
    return HC(e);
  }
  normalizeAnimationStyleValue(e, r, n) {
    let i = "", s = n.toString().trim(), o = null;
    if (vk(e) && n !== 0 && n !== "0")
      if (typeof n == "number")
        i = "px";
      else {
        let a = n.match(/^[+-]?[\d\.]+([a-z]*)$/);
        a && a[1].length == 0 && (o = `Please provide a CSS unit value for ${r}:${n}`);
      }
    return { error: o, value: s + i };
  }
};
function vk(t) {
  switch (t) {
    case "width":
    case "height":
    case "minWidth":
    case "minHeight":
    case "maxWidth":
    case "maxHeight":
    case "left":
    case "top":
    case "bottom":
    case "right":
    case "fontSize":
    case "outlineWidth":
    case "outlineOffset":
    case "paddingTop":
    case "paddingLeft":
    case "paddingBottom":
    case "paddingRight":
    case "marginTop":
    case "marginLeft":
    case "marginBottom":
    case "marginRight":
    case "borderRadius":
    case "borderWidth":
    case "borderTopWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderBottomWidth":
    case "textIndent":
      return !0;
    default:
      return !1;
  }
}
var Y = class {
  constructor({ closedByChildren: t, implicitNamespacePrefix: e, contentType: r = Rt.PARSABLE_DATA, closedByParent: n = !1, isVoid: i = !1, ignoreFirstLf: s = !1, preventNamespaceInheritance: o = !1, canSelfClose: a = !1 } = {}) {
    this.closedByChildren = {}, this.closedByParent = !1, t && t.length > 0 && t.forEach((l) => this.closedByChildren[l] = !0), this.isVoid = i, this.closedByParent = n || i, this.implicitNamespacePrefix = e || null, this.contentType = r, this.ignoreFirstLf = s, this.preventNamespaceInheritance = o, this.canSelfClose = a ?? i;
  }
  isClosedByChild(t) {
    return this.isVoid || t.toLowerCase() in this.closedByChildren;
  }
  getContentType(t) {
    return typeof this.contentType == "object" ? (t === void 0 ? void 0 : this.contentType[t]) ?? this.contentType.default : this.contentType;
  }
}, Hf, Ai;
function du(t) {
  return Ai || (Hf = new Y({ canSelfClose: !0 }), Ai = Object.assign(/* @__PURE__ */ Object.create(null), { base: new Y({ isVoid: !0 }), meta: new Y({ isVoid: !0 }), area: new Y({ isVoid: !0 }), embed: new Y({ isVoid: !0 }), link: new Y({ isVoid: !0 }), img: new Y({ isVoid: !0 }), input: new Y({ isVoid: !0 }), param: new Y({ isVoid: !0 }), hr: new Y({ isVoid: !0 }), br: new Y({ isVoid: !0 }), source: new Y({ isVoid: !0 }), track: new Y({ isVoid: !0 }), wbr: new Y({ isVoid: !0 }), p: new Y({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: !0 }), thead: new Y({ closedByChildren: ["tbody", "tfoot"] }), tbody: new Y({ closedByChildren: ["tbody", "tfoot"], closedByParent: !0 }), tfoot: new Y({ closedByChildren: ["tbody"], closedByParent: !0 }), tr: new Y({ closedByChildren: ["tr"], closedByParent: !0 }), td: new Y({ closedByChildren: ["td", "th"], closedByParent: !0 }), th: new Y({ closedByChildren: ["td", "th"], closedByParent: !0 }), col: new Y({ isVoid: !0 }), svg: new Y({ implicitNamespacePrefix: "svg" }), foreignObject: new Y({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: !0 }), math: new Y({ implicitNamespacePrefix: "math" }), li: new Y({ closedByChildren: ["li"], closedByParent: !0 }), dt: new Y({ closedByChildren: ["dt", "dd"] }), dd: new Y({ closedByChildren: ["dt", "dd"], closedByParent: !0 }), rb: new Y({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rt: new Y({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rtc: new Y({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: !0 }), rp: new Y({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), optgroup: new Y({ closedByChildren: ["optgroup"], closedByParent: !0 }), option: new Y({ closedByChildren: ["option", "optgroup"], closedByParent: !0 }), pre: new Y({ ignoreFirstLf: !0 }), listing: new Y({ ignoreFirstLf: !0 }), style: new Y({ contentType: Rt.RAW_TEXT }), script: new Y({ contentType: Rt.RAW_TEXT }), title: new Y({ contentType: { default: Rt.ESCAPABLE_RAW_TEXT, svg: Rt.PARSABLE_DATA } }), textarea: new Y({ contentType: Rt.ESCAPABLE_RAW_TEXT, ignoreFirstLf: !0 }) }), new yk().allKnownElementNames().forEach((e) => {
    !Ai[e] && ko(e) === null && (Ai[e] = new Y({ canSelfClose: !1 }));
  })), Ai[t] ?? Hf;
}
var Fs = class {
  constructor(e, r) {
    this.sourceSpan = e, this.i18n = r;
  }
}, bk = class extends Fs {
  constructor(e, r, n, i) {
    super(r, i), this.value = e, this.tokens = n, this.type = "text";
  }
  visit(e, r) {
    return e.visitText(this, r);
  }
}, Dk = class extends Fs {
  constructor(e, r, n, i) {
    super(r, i), this.value = e, this.tokens = n, this.type = "cdata";
  }
  visit(e, r) {
    return e.visitCdata(this, r);
  }
}, wk = class extends Fs {
  constructor(e, r, n, i, s, o) {
    super(i, o), this.switchValue = e, this.type = r, this.cases = n, this.switchValueSourceSpan = s;
  }
  visit(e, r) {
    return e.visitExpansion(this, r);
  }
}, xk = class {
  constructor(e, r, n, i, s) {
    this.value = e, this.expression = r, this.sourceSpan = n, this.valueSourceSpan = i, this.expSourceSpan = s, this.type = "expansionCase";
  }
  visit(e, r) {
    return e.visitExpansionCase(this, r);
  }
}, Ck = class extends Fs {
  constructor(t, e, r, n, i, s, o) {
    super(r, o), this.name = t, this.value = e, this.keySpan = n, this.valueSpan = i, this.valueTokens = s, this.type = "attribute";
  }
  visit(t, e) {
    return t.visitAttribute(this, e);
  }
  get nameSpan() {
    return this.keySpan;
  }
}, Br = class extends Fs {
  constructor(e, r, n, i, s, o = null, a = null, l) {
    super(i, l), this.name = e, this.attrs = r, this.children = n, this.startSourceSpan = s, this.endSourceSpan = o, this.nameSpan = a, this.type = "element";
  }
  visit(e, r) {
    return e.visitElement(this, r);
  }
}, kk = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "comment";
  }
  visit(e, r) {
    return e.visitComment(this, r);
  }
}, Sk = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "docType";
  }
  visit(e, r) {
    return e.visitDocType(this, r);
  }
}, Rn = class {
  constructor(e, r, n, i, s, o = null) {
    this.name = e, this.parameters = r, this.children = n, this.sourceSpan = i, this.startSourceSpan = s, this.endSourceSpan = o, this.type = "block";
  }
  visit(e, r) {
    return e.visitBlock(this, r);
  }
}, Vf = class {
  constructor(e, r) {
    this.expression = e, this.sourceSpan = r, this.type = "blockParameter", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e, r) {
    return e.visitBlockParameter(this, r);
  }
};
function _g(t, e, r = null) {
  let n = [], i = t.visit ? (s) => t.visit(s, r) || s.visit(t, r) : (s) => s.visit(t, r);
  return e.forEach((s) => {
    let o = i(s);
    o && n.push(o);
  }), n;
}
var Ek = class {
  constructor() {
  }
  visitElement(t, e) {
    this.visitChildren(e, (r) => {
      r(t.attrs), r(t.children);
    });
  }
  visitAttribute(t, e) {
  }
  visitText(t, e) {
  }
  visitCdata(t, e) {
  }
  visitComment(t, e) {
  }
  visitDocType(t, e) {
  }
  visitExpansion(t, e) {
    return this.visitChildren(e, (r) => {
      r(t.cases);
    });
  }
  visitExpansionCase(t, e) {
  }
  visitBlock(t, e) {
    this.visitChildren(e, (r) => {
      r(t.parameters), r(t.children);
    });
  }
  visitBlockParameter(t, e) {
  }
  visitChildren(t, e) {
    let r = [], n = this;
    function i(s) {
      s && r.push(_g(n, s, t));
    }
    return e(i), Array.prototype.concat.apply([], r);
  }
}, Ho = { AElig: "Æ", AMP: "&", amp: "&", Aacute: "Á", Abreve: "Ă", Acirc: "Â", Acy: "А", Afr: "𝔄", Agrave: "À", Alpha: "Α", Amacr: "Ā", And: "⩓", Aogon: "Ą", Aopf: "𝔸", ApplyFunction: "⁡", af: "⁡", Aring: "Å", angst: "Å", Ascr: "𝒜", Assign: "≔", colone: "≔", coloneq: "≔", Atilde: "Ã", Auml: "Ä", Backslash: "∖", setminus: "∖", setmn: "∖", smallsetminus: "∖", ssetmn: "∖", Barv: "⫧", Barwed: "⌆", doublebarwedge: "⌆", Bcy: "Б", Because: "∵", becaus: "∵", because: "∵", Bernoullis: "ℬ", Bscr: "ℬ", bernou: "ℬ", Beta: "Β", Bfr: "𝔅", Bopf: "𝔹", Breve: "˘", breve: "˘", Bumpeq: "≎", HumpDownHump: "≎", bump: "≎", CHcy: "Ч", COPY: "©", copy: "©", Cacute: "Ć", Cap: "⋒", CapitalDifferentialD: "ⅅ", DD: "ⅅ", Cayleys: "ℭ", Cfr: "ℭ", Ccaron: "Č", Ccedil: "Ç", Ccirc: "Ĉ", Cconint: "∰", Cdot: "Ċ", Cedilla: "¸", cedil: "¸", CenterDot: "·", centerdot: "·", middot: "·", Chi: "Χ", CircleDot: "⊙", odot: "⊙", CircleMinus: "⊖", ominus: "⊖", CirclePlus: "⊕", oplus: "⊕", CircleTimes: "⊗", otimes: "⊗", ClockwiseContourIntegral: "∲", cwconint: "∲", CloseCurlyDoubleQuote: "”", rdquo: "”", rdquor: "”", CloseCurlyQuote: "’", rsquo: "’", rsquor: "’", Colon: "∷", Proportion: "∷", Colone: "⩴", Congruent: "≡", equiv: "≡", Conint: "∯", DoubleContourIntegral: "∯", ContourIntegral: "∮", conint: "∮", oint: "∮", Copf: "ℂ", complexes: "ℂ", Coproduct: "∐", coprod: "∐", CounterClockwiseContourIntegral: "∳", awconint: "∳", Cross: "⨯", Cscr: "𝒞", Cup: "⋓", CupCap: "≍", asympeq: "≍", DDotrahd: "⤑", DJcy: "Ђ", DScy: "Ѕ", DZcy: "Џ", Dagger: "‡", ddagger: "‡", Darr: "↡", Dashv: "⫤", DoubleLeftTee: "⫤", Dcaron: "Ď", Dcy: "Д", Del: "∇", nabla: "∇", Delta: "Δ", Dfr: "𝔇", DiacriticalAcute: "´", acute: "´", DiacriticalDot: "˙", dot: "˙", DiacriticalDoubleAcute: "˝", dblac: "˝", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "˜", tilde: "˜", Diamond: "⋄", diam: "⋄", diamond: "⋄", DifferentialD: "ⅆ", dd: "ⅆ", Dopf: "𝔻", Dot: "¨", DoubleDot: "¨", die: "¨", uml: "¨", DotDot: "⃜", DotEqual: "≐", doteq: "≐", esdot: "≐", DoubleDownArrow: "⇓", Downarrow: "⇓", dArr: "⇓", DoubleLeftArrow: "⇐", Leftarrow: "⇐", lArr: "⇐", DoubleLeftRightArrow: "⇔", Leftrightarrow: "⇔", hArr: "⇔", iff: "⇔", DoubleLongLeftArrow: "⟸", Longleftarrow: "⟸", xlArr: "⟸", DoubleLongLeftRightArrow: "⟺", Longleftrightarrow: "⟺", xhArr: "⟺", DoubleLongRightArrow: "⟹", Longrightarrow: "⟹", xrArr: "⟹", DoubleRightArrow: "⇒", Implies: "⇒", Rightarrow: "⇒", rArr: "⇒", DoubleRightTee: "⊨", vDash: "⊨", DoubleUpArrow: "⇑", Uparrow: "⇑", uArr: "⇑", DoubleUpDownArrow: "⇕", Updownarrow: "⇕", vArr: "⇕", DoubleVerticalBar: "∥", par: "∥", parallel: "∥", shortparallel: "∥", spar: "∥", DownArrow: "↓", ShortDownArrow: "↓", darr: "↓", downarrow: "↓", DownArrowBar: "⤓", DownArrowUpArrow: "⇵", duarr: "⇵", DownBreve: "̑", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVector: "↽", leftharpoondown: "↽", lhard: "↽", DownLeftVectorBar: "⥖", DownRightTeeVector: "⥟", DownRightVector: "⇁", rhard: "⇁", rightharpoondown: "⇁", DownRightVectorBar: "⥗", DownTee: "⊤", top: "⊤", DownTeeArrow: "↧", mapstodown: "↧", Dscr: "𝒟", Dstrok: "Đ", ENG: "Ŋ", ETH: "Ð", Eacute: "É", Ecaron: "Ě", Ecirc: "Ê", Ecy: "Э", Edot: "Ė", Efr: "𝔈", Egrave: "È", Element: "∈", in: "∈", isin: "∈", isinv: "∈", Emacr: "Ē", EmptySmallSquare: "◻", EmptyVerySmallSquare: "▫", Eogon: "Ę", Eopf: "𝔼", Epsilon: "Ε", Equal: "⩵", EqualTilde: "≂", eqsim: "≂", esim: "≂", Equilibrium: "⇌", rightleftharpoons: "⇌", rlhar: "⇌", Escr: "ℰ", expectation: "ℰ", Esim: "⩳", Eta: "Η", Euml: "Ë", Exists: "∃", exist: "∃", ExponentialE: "ⅇ", ee: "ⅇ", exponentiale: "ⅇ", Fcy: "Ф", Ffr: "𝔉", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", blacksquare: "▪", squarf: "▪", squf: "▪", Fopf: "𝔽", ForAll: "∀", forall: "∀", Fouriertrf: "ℱ", Fscr: "ℱ", GJcy: "Ѓ", GT: ">", gt: ">", Gamma: "Γ", Gammad: "Ϝ", Gbreve: "Ğ", Gcedil: "Ģ", Gcirc: "Ĝ", Gcy: "Г", Gdot: "Ġ", Gfr: "𝔊", Gg: "⋙", ggg: "⋙", Gopf: "𝔾", GreaterEqual: "≥", ge: "≥", geq: "≥", GreaterEqualLess: "⋛", gel: "⋛", gtreqless: "⋛", GreaterFullEqual: "≧", gE: "≧", geqq: "≧", GreaterGreater: "⪢", GreaterLess: "≷", gl: "≷", gtrless: "≷", GreaterSlantEqual: "⩾", geqslant: "⩾", ges: "⩾", GreaterTilde: "≳", gsim: "≳", gtrsim: "≳", Gscr: "𝒢", Gt: "≫", NestedGreaterGreater: "≫", gg: "≫", HARDcy: "Ъ", Hacek: "ˇ", caron: "ˇ", Hat: "^", Hcirc: "Ĥ", Hfr: "ℌ", Poincareplane: "ℌ", HilbertSpace: "ℋ", Hscr: "ℋ", hamilt: "ℋ", Hopf: "ℍ", quaternions: "ℍ", HorizontalLine: "─", boxh: "─", Hstrok: "Ħ", HumpEqual: "≏", bumpe: "≏", bumpeq: "≏", IEcy: "Е", IJlig: "Ĳ", IOcy: "Ё", Iacute: "Í", Icirc: "Î", Icy: "И", Idot: "İ", Ifr: "ℑ", Im: "ℑ", image: "ℑ", imagpart: "ℑ", Igrave: "Ì", Imacr: "Ī", ImaginaryI: "ⅈ", ii: "ⅈ", Int: "∬", Integral: "∫", int: "∫", Intersection: "⋂", bigcap: "⋂", xcap: "⋂", InvisibleComma: "⁣", ic: "⁣", InvisibleTimes: "⁢", it: "⁢", Iogon: "Į", Iopf: "𝕀", Iota: "Ι", Iscr: "ℐ", imagline: "ℐ", Itilde: "Ĩ", Iukcy: "І", Iuml: "Ï", Jcirc: "Ĵ", Jcy: "Й", Jfr: "𝔍", Jopf: "𝕁", Jscr: "𝒥", Jsercy: "Ј", Jukcy: "Є", KHcy: "Х", KJcy: "Ќ", Kappa: "Κ", Kcedil: "Ķ", Kcy: "К", Kfr: "𝔎", Kopf: "𝕂", Kscr: "𝒦", LJcy: "Љ", LT: "<", lt: "<", Lacute: "Ĺ", Lambda: "Λ", Lang: "⟪", Laplacetrf: "ℒ", Lscr: "ℒ", lagran: "ℒ", Larr: "↞", twoheadleftarrow: "↞", Lcaron: "Ľ", Lcedil: "Ļ", Lcy: "Л", LeftAngleBracket: "⟨", lang: "⟨", langle: "⟨", LeftArrow: "←", ShortLeftArrow: "←", larr: "←", leftarrow: "←", slarr: "←", LeftArrowBar: "⇤", larrb: "⇤", LeftArrowRightArrow: "⇆", leftrightarrows: "⇆", lrarr: "⇆", LeftCeiling: "⌈", lceil: "⌈", LeftDoubleBracket: "⟦", lobrk: "⟦", LeftDownTeeVector: "⥡", LeftDownVector: "⇃", dharl: "⇃", downharpoonleft: "⇃", LeftDownVectorBar: "⥙", LeftFloor: "⌊", lfloor: "⌊", LeftRightArrow: "↔", harr: "↔", leftrightarrow: "↔", LeftRightVector: "⥎", LeftTee: "⊣", dashv: "⊣", LeftTeeArrow: "↤", mapstoleft: "↤", LeftTeeVector: "⥚", LeftTriangle: "⊲", vartriangleleft: "⊲", vltri: "⊲", LeftTriangleBar: "⧏", LeftTriangleEqual: "⊴", ltrie: "⊴", trianglelefteq: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVector: "↿", uharl: "↿", upharpoonleft: "↿", LeftUpVectorBar: "⥘", LeftVector: "↼", leftharpoonup: "↼", lharu: "↼", LeftVectorBar: "⥒", LessEqualGreater: "⋚", leg: "⋚", lesseqgtr: "⋚", LessFullEqual: "≦", lE: "≦", leqq: "≦", LessGreater: "≶", lessgtr: "≶", lg: "≶", LessLess: "⪡", LessSlantEqual: "⩽", leqslant: "⩽", les: "⩽", LessTilde: "≲", lesssim: "≲", lsim: "≲", Lfr: "𝔏", Ll: "⋘", Lleftarrow: "⇚", lAarr: "⇚", Lmidot: "Ŀ", LongLeftArrow: "⟵", longleftarrow: "⟵", xlarr: "⟵", LongLeftRightArrow: "⟷", longleftrightarrow: "⟷", xharr: "⟷", LongRightArrow: "⟶", longrightarrow: "⟶", xrarr: "⟶", Lopf: "𝕃", LowerLeftArrow: "↙", swarr: "↙", swarrow: "↙", LowerRightArrow: "↘", searr: "↘", searrow: "↘", Lsh: "↰", lsh: "↰", Lstrok: "Ł", Lt: "≪", NestedLessLess: "≪", ll: "≪", Map: "⤅", Mcy: "М", MediumSpace: " ", Mellintrf: "ℳ", Mscr: "ℳ", phmmat: "ℳ", Mfr: "𝔐", MinusPlus: "∓", mnplus: "∓", mp: "∓", Mopf: "𝕄", Mu: "Μ", NJcy: "Њ", Nacute: "Ń", Ncaron: "Ň", Ncedil: "Ņ", Ncy: "Н", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", ZeroWidthSpace: "​", NewLine: `
`, Nfr: "𝔑", NoBreak: "⁠", NonBreakingSpace: " ", nbsp: " ", Nopf: "ℕ", naturals: "ℕ", Not: "⫬", NotCongruent: "≢", nequiv: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", npar: "∦", nparallel: "∦", nshortparallel: "∦", nspar: "∦", NotElement: "∉", notin: "∉", notinva: "∉", NotEqual: "≠", ne: "≠", NotEqualTilde: "≂̸", nesim: "≂̸", NotExists: "∄", nexist: "∄", nexists: "∄", NotGreater: "≯", ngt: "≯", ngtr: "≯", NotGreaterEqual: "≱", nge: "≱", ngeq: "≱", NotGreaterFullEqual: "≧̸", ngE: "≧̸", ngeqq: "≧̸", NotGreaterGreater: "≫̸", nGtv: "≫̸", NotGreaterLess: "≹", ntgl: "≹", NotGreaterSlantEqual: "⩾̸", ngeqslant: "⩾̸", nges: "⩾̸", NotGreaterTilde: "≵", ngsim: "≵", NotHumpDownHump: "≎̸", nbump: "≎̸", NotHumpEqual: "≏̸", nbumpe: "≏̸", NotLeftTriangle: "⋪", nltri: "⋪", ntriangleleft: "⋪", NotLeftTriangleBar: "⧏̸", NotLeftTriangleEqual: "⋬", nltrie: "⋬", ntrianglelefteq: "⋬", NotLess: "≮", nless: "≮", nlt: "≮", NotLessEqual: "≰", nle: "≰", nleq: "≰", NotLessGreater: "≸", ntlg: "≸", NotLessLess: "≪̸", nLtv: "≪̸", NotLessSlantEqual: "⩽̸", nleqslant: "⩽̸", nles: "⩽̸", NotLessTilde: "≴", nlsim: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", NotPrecedes: "⊀", npr: "⊀", nprec: "⊀", NotPrecedesEqual: "⪯̸", npre: "⪯̸", npreceq: "⪯̸", NotPrecedesSlantEqual: "⋠", nprcue: "⋠", NotReverseElement: "∌", notni: "∌", notniva: "∌", NotRightTriangle: "⋫", nrtri: "⋫", ntriangleright: "⋫", NotRightTriangleBar: "⧐̸", NotRightTriangleEqual: "⋭", nrtrie: "⋭", ntrianglerighteq: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", nsqsube: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", nsqsupe: "⋣", NotSubset: "⊂⃒", nsubset: "⊂⃒", vnsub: "⊂⃒", NotSubsetEqual: "⊈", nsube: "⊈", nsubseteq: "⊈", NotSucceeds: "⊁", nsc: "⊁", nsucc: "⊁", NotSucceedsEqual: "⪰̸", nsce: "⪰̸", nsucceq: "⪰̸", NotSucceedsSlantEqual: "⋡", nsccue: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", nsupset: "⊃⃒", vnsup: "⊃⃒", NotSupersetEqual: "⊉", nsupe: "⊉", nsupseteq: "⊉", NotTilde: "≁", nsim: "≁", NotTildeEqual: "≄", nsime: "≄", nsimeq: "≄", NotTildeFullEqual: "≇", ncong: "≇", NotTildeTilde: "≉", nap: "≉", napprox: "≉", NotVerticalBar: "∤", nmid: "∤", nshortmid: "∤", nsmid: "∤", Nscr: "𝒩", Ntilde: "Ñ", Nu: "Ν", OElig: "Œ", Oacute: "Ó", Ocirc: "Ô", Ocy: "О", Odblac: "Ő", Ofr: "𝔒", Ograve: "Ò", Omacr: "Ō", Omega: "Ω", ohm: "Ω", Omicron: "Ο", Oopf: "𝕆", OpenCurlyDoubleQuote: "“", ldquo: "“", OpenCurlyQuote: "‘", lsquo: "‘", Or: "⩔", Oscr: "𝒪", Oslash: "Ø", Otilde: "Õ", Otimes: "⨷", Ouml: "Ö", OverBar: "‾", oline: "‾", OverBrace: "⏞", OverBracket: "⎴", tbrk: "⎴", OverParenthesis: "⏜", PartialD: "∂", part: "∂", Pcy: "П", Pfr: "𝔓", Phi: "Φ", Pi: "Π", PlusMinus: "±", plusmn: "±", pm: "±", Popf: "ℙ", primes: "ℙ", Pr: "⪻", Precedes: "≺", pr: "≺", prec: "≺", PrecedesEqual: "⪯", pre: "⪯", preceq: "⪯", PrecedesSlantEqual: "≼", prcue: "≼", preccurlyeq: "≼", PrecedesTilde: "≾", precsim: "≾", prsim: "≾", Prime: "″", Product: "∏", prod: "∏", Proportional: "∝", prop: "∝", propto: "∝", varpropto: "∝", vprop: "∝", Pscr: "𝒫", Psi: "Ψ", QUOT: '"', quot: '"', Qfr: "𝔔", Qopf: "ℚ", rationals: "ℚ", Qscr: "𝒬", RBarr: "⤐", drbkarow: "⤐", REG: "®", circledR: "®", reg: "®", Racute: "Ŕ", Rang: "⟫", Rarr: "↠", twoheadrightarrow: "↠", Rarrtl: "⤖", Rcaron: "Ř", Rcedil: "Ŗ", Rcy: "Р", Re: "ℜ", Rfr: "ℜ", real: "ℜ", realpart: "ℜ", ReverseElement: "∋", SuchThat: "∋", ni: "∋", niv: "∋", ReverseEquilibrium: "⇋", leftrightharpoons: "⇋", lrhar: "⇋", ReverseUpEquilibrium: "⥯", duhar: "⥯", Rho: "Ρ", RightAngleBracket: "⟩", rang: "⟩", rangle: "⟩", RightArrow: "→", ShortRightArrow: "→", rarr: "→", rightarrow: "→", srarr: "→", RightArrowBar: "⇥", rarrb: "⇥", RightArrowLeftArrow: "⇄", rightleftarrows: "⇄", rlarr: "⇄", RightCeiling: "⌉", rceil: "⌉", RightDoubleBracket: "⟧", robrk: "⟧", RightDownTeeVector: "⥝", RightDownVector: "⇂", dharr: "⇂", downharpoonright: "⇂", RightDownVectorBar: "⥕", RightFloor: "⌋", rfloor: "⌋", RightTee: "⊢", vdash: "⊢", RightTeeArrow: "↦", map: "↦", mapsto: "↦", RightTeeVector: "⥛", RightTriangle: "⊳", vartriangleright: "⊳", vrtri: "⊳", RightTriangleBar: "⧐", RightTriangleEqual: "⊵", rtrie: "⊵", trianglerighteq: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVector: "↾", uharr: "↾", upharpoonright: "↾", RightUpVectorBar: "⥔", RightVector: "⇀", rharu: "⇀", rightharpoonup: "⇀", RightVectorBar: "⥓", Ropf: "ℝ", reals: "ℝ", RoundImplies: "⥰", Rrightarrow: "⇛", rAarr: "⇛", Rscr: "ℛ", realine: "ℛ", Rsh: "↱", rsh: "↱", RuleDelayed: "⧴", SHCHcy: "Щ", SHcy: "Ш", SOFTcy: "Ь", Sacute: "Ś", Sc: "⪼", Scaron: "Š", Scedil: "Ş", Scirc: "Ŝ", Scy: "С", Sfr: "𝔖", ShortUpArrow: "↑", UpArrow: "↑", uarr: "↑", uparrow: "↑", Sigma: "Σ", SmallCircle: "∘", compfn: "∘", Sopf: "𝕊", Sqrt: "√", radic: "√", Square: "□", squ: "□", square: "□", SquareIntersection: "⊓", sqcap: "⊓", SquareSubset: "⊏", sqsub: "⊏", sqsubset: "⊏", SquareSubsetEqual: "⊑", sqsube: "⊑", sqsubseteq: "⊑", SquareSuperset: "⊐", sqsup: "⊐", sqsupset: "⊐", SquareSupersetEqual: "⊒", sqsupe: "⊒", sqsupseteq: "⊒", SquareUnion: "⊔", sqcup: "⊔", Sscr: "𝒮", Star: "⋆", sstarf: "⋆", Sub: "⋐", Subset: "⋐", SubsetEqual: "⊆", sube: "⊆", subseteq: "⊆", Succeeds: "≻", sc: "≻", succ: "≻", SucceedsEqual: "⪰", sce: "⪰", succeq: "⪰", SucceedsSlantEqual: "≽", sccue: "≽", succcurlyeq: "≽", SucceedsTilde: "≿", scsim: "≿", succsim: "≿", Sum: "∑", sum: "∑", Sup: "⋑", Supset: "⋑", Superset: "⊃", sup: "⊃", supset: "⊃", SupersetEqual: "⊇", supe: "⊇", supseteq: "⊇", THORN: "Þ", TRADE: "™", trade: "™", TSHcy: "Ћ", TScy: "Ц", Tab: "	", Tau: "Τ", Tcaron: "Ť", Tcedil: "Ţ", Tcy: "Т", Tfr: "𝔗", Therefore: "∴", there4: "∴", therefore: "∴", Theta: "Θ", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", Tilde: "∼", sim: "∼", thicksim: "∼", thksim: "∼", TildeEqual: "≃", sime: "≃", simeq: "≃", TildeFullEqual: "≅", cong: "≅", TildeTilde: "≈", ap: "≈", approx: "≈", asymp: "≈", thickapprox: "≈", thkap: "≈", Topf: "𝕋", TripleDot: "⃛", tdot: "⃛", Tscr: "𝒯", Tstrok: "Ŧ", Uacute: "Ú", Uarr: "↟", Uarrocir: "⥉", Ubrcy: "Ў", Ubreve: "Ŭ", Ucirc: "Û", Ucy: "У", Udblac: "Ű", Ufr: "𝔘", Ugrave: "Ù", Umacr: "Ū", UnderBar: "_", lowbar: "_", UnderBrace: "⏟", UnderBracket: "⎵", bbrk: "⎵", UnderParenthesis: "⏝", Union: "⋃", bigcup: "⋃", xcup: "⋃", UnionPlus: "⊎", uplus: "⊎", Uogon: "Ų", Uopf: "𝕌", UpArrowBar: "⤒", UpArrowDownArrow: "⇅", udarr: "⇅", UpDownArrow: "↕", updownarrow: "↕", varr: "↕", UpEquilibrium: "⥮", udhar: "⥮", UpTee: "⊥", bot: "⊥", bottom: "⊥", perp: "⊥", UpTeeArrow: "↥", mapstoup: "↥", UpperLeftArrow: "↖", nwarr: "↖", nwarrow: "↖", UpperRightArrow: "↗", nearr: "↗", nearrow: "↗", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", Uring: "Ů", Uscr: "𝒰", Utilde: "Ũ", Uuml: "Ü", VDash: "⊫", Vbar: "⫫", Vcy: "В", Vdash: "⊩", Vdashl: "⫦", Vee: "⋁", bigvee: "⋁", xvee: "⋁", Verbar: "‖", Vert: "‖", VerticalBar: "∣", mid: "∣", shortmid: "∣", smid: "∣", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "❘", VerticalTilde: "≀", wr: "≀", wreath: "≀", VeryThinSpace: " ", hairsp: " ", Vfr: "𝔙", Vopf: "𝕍", Vscr: "𝒱", Vvdash: "⊪", Wcirc: "Ŵ", Wedge: "⋀", bigwedge: "⋀", xwedge: "⋀", Wfr: "𝔚", Wopf: "𝕎", Wscr: "𝒲", Xfr: "𝔛", Xi: "Ξ", Xopf: "𝕏", Xscr: "𝒳", YAcy: "Я", YIcy: "Ї", YUcy: "Ю", Yacute: "Ý", Ycirc: "Ŷ", Ycy: "Ы", Yfr: "𝔜", Yopf: "𝕐", Yscr: "𝒴", Yuml: "Ÿ", ZHcy: "Ж", Zacute: "Ź", Zcaron: "Ž", Zcy: "З", Zdot: "Ż", Zeta: "Ζ", Zfr: "ℨ", zeetrf: "ℨ", Zopf: "ℤ", integers: "ℤ", Zscr: "𝒵", aacute: "á", abreve: "ă", ac: "∾", mstpos: "∾", acE: "∾̳", acd: "∿", acirc: "â", acy: "а", aelig: "æ", afr: "𝔞", agrave: "à", alefsym: "ℵ", aleph: "ℵ", alpha: "α", amacr: "ā", amalg: "⨿", and: "∧", wedge: "∧", andand: "⩕", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", angle: "∠", ange: "⦤", angmsd: "∡", measuredangle: "∡", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angzarr: "⍼", aogon: "ą", aopf: "𝕒", apE: "⩰", apacir: "⩯", ape: "≊", approxeq: "≊", apid: "≋", apos: "'", aring: "å", ascr: "𝒶", ast: "*", midast: "*", atilde: "ã", auml: "ä", awint: "⨑", bNot: "⫭", backcong: "≌", bcong: "≌", backepsilon: "϶", bepsi: "϶", backprime: "‵", bprime: "‵", backsim: "∽", bsim: "∽", backsimeq: "⋍", bsime: "⋍", barvee: "⊽", barwed: "⌅", barwedge: "⌅", bbrktbrk: "⎶", bcy: "б", bdquo: "„", ldquor: "„", bemptyv: "⦰", beta: "β", beth: "ℶ", between: "≬", twixt: "≬", bfr: "𝔟", bigcirc: "◯", xcirc: "◯", bigodot: "⨀", xodot: "⨀", bigoplus: "⨁", xoplus: "⨁", bigotimes: "⨂", xotime: "⨂", bigsqcup: "⨆", xsqcup: "⨆", bigstar: "★", starf: "★", bigtriangledown: "▽", xdtri: "▽", bigtriangleup: "△", xutri: "△", biguplus: "⨄", xuplus: "⨄", bkarow: "⤍", rbarr: "⤍", blacklozenge: "⧫", lozf: "⧫", blacktriangle: "▴", utrif: "▴", blacktriangledown: "▾", dtrif: "▾", blacktriangleleft: "◂", ltrif: "◂", blacktriangleright: "▸", rtrif: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bnot: "⌐", bopf: "𝕓", bowtie: "⋈", boxDL: "╗", boxDR: "╔", boxDl: "╖", boxDr: "╓", boxH: "═", boxHD: "╦", boxHU: "╩", boxHd: "╤", boxHu: "╧", boxUL: "╝", boxUR: "╚", boxUl: "╜", boxUr: "╙", boxV: "║", boxVH: "╬", boxVL: "╣", boxVR: "╠", boxVh: "╫", boxVl: "╢", boxVr: "╟", boxbox: "⧉", boxdL: "╕", boxdR: "╒", boxdl: "┐", boxdr: "┌", boxhD: "╥", boxhU: "╨", boxhd: "┬", boxhu: "┴", boxminus: "⊟", minusb: "⊟", boxplus: "⊞", plusb: "⊞", boxtimes: "⊠", timesb: "⊠", boxuL: "╛", boxuR: "╘", boxul: "┘", boxur: "└", boxv: "│", boxvH: "╪", boxvL: "╡", boxvR: "╞", boxvh: "┼", boxvl: "┤", boxvr: "├", brvbar: "¦", bscr: "𝒷", bsemi: "⁏", bsol: "\\", bsolb: "⧅", bsolhsub: "⟈", bull: "•", bullet: "•", bumpE: "⪮", cacute: "ć", cap: "∩", capand: "⩄", capbrcup: "⩉", capcap: "⩋", capcup: "⩇", capdot: "⩀", caps: "∩︀", caret: "⁁", ccaps: "⩍", ccaron: "č", ccedil: "ç", ccirc: "ĉ", ccups: "⩌", ccupssm: "⩐", cdot: "ċ", cemptyv: "⦲", cent: "¢", cfr: "𝔠", chcy: "ч", check: "✓", checkmark: "✓", chi: "χ", cir: "○", cirE: "⧃", circ: "ˆ", circeq: "≗", cire: "≗", circlearrowleft: "↺", olarr: "↺", circlearrowright: "↻", orarr: "↻", circledS: "Ⓢ", oS: "Ⓢ", circledast: "⊛", oast: "⊛", circledcirc: "⊚", ocir: "⊚", circleddash: "⊝", odash: "⊝", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", clubs: "♣", clubsuit: "♣", colon: ":", comma: ",", commat: "@", comp: "∁", complement: "∁", congdot: "⩭", copf: "𝕔", copysr: "℗", crarr: "↵", cross: "✗", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", curlyeqprec: "⋞", cuesc: "⋟", curlyeqsucc: "⋟", cularr: "↶", curvearrowleft: "↶", cularrp: "⤽", cup: "∪", cupbrcap: "⩈", cupcap: "⩆", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curvearrowright: "↷", curarrm: "⤼", curlyvee: "⋎", cuvee: "⋎", curlywedge: "⋏", cuwed: "⋏", curren: "¤", cwint: "∱", cylcty: "⌭", dHar: "⥥", dagger: "†", daleth: "ℸ", dash: "‐", hyphen: "‐", dbkarow: "⤏", rBarr: "⤏", dcaron: "ď", dcy: "д", ddarr: "⇊", downdownarrows: "⇊", ddotseq: "⩷", eDDot: "⩷", deg: "°", delta: "δ", demptyv: "⦱", dfisht: "⥿", dfr: "𝔡", diamondsuit: "♦", diams: "♦", digamma: "ϝ", gammad: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", djcy: "ђ", dlcorn: "⌞", llcorner: "⌞", dlcrop: "⌍", dollar: "$", dopf: "𝕕", doteqdot: "≑", eDot: "≑", dotminus: "∸", minusd: "∸", dotplus: "∔", plusdo: "∔", dotsquare: "⊡", sdotb: "⊡", drcorn: "⌟", lrcorner: "⌟", drcrop: "⌌", dscr: "𝒹", dscy: "ѕ", dsol: "⧶", dstrok: "đ", dtdot: "⋱", dtri: "▿", triangledown: "▿", dwangle: "⦦", dzcy: "џ", dzigrarr: "⟿", eacute: "é", easter: "⩮", ecaron: "ě", ecir: "≖", eqcirc: "≖", ecirc: "ê", ecolon: "≕", eqcolon: "≕", ecy: "э", edot: "ė", efDot: "≒", fallingdotseq: "≒", efr: "𝔢", eg: "⪚", egrave: "è", egs: "⪖", eqslantgtr: "⪖", egsdot: "⪘", el: "⪙", elinters: "⏧", ell: "ℓ", els: "⪕", eqslantless: "⪕", elsdot: "⪗", emacr: "ē", empty: "∅", emptyset: "∅", emptyv: "∅", varnothing: "∅", emsp13: " ", emsp14: " ", emsp: " ", eng: "ŋ", ensp: " ", eogon: "ę", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", epsilon: "ε", epsiv: "ϵ", straightepsilon: "ϵ", varepsilon: "ϵ", equals: "=", equest: "≟", questeq: "≟", equivDD: "⩸", eqvparsl: "⧥", erDot: "≓", risingdotseq: "≓", erarr: "⥱", escr: "ℯ", eta: "η", eth: "ð", euml: "ë", euro: "€", excl: "!", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", ffr: "𝔣", filig: "ﬁ", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", fopf: "𝕗", fork: "⋔", pitchfork: "⋔", forkv: "⫙", fpartint: "⨍", frac12: "½", half: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", sfrown: "⌢", fscr: "𝒻", gEl: "⪌", gtreqqless: "⪌", gacute: "ǵ", gamma: "γ", gap: "⪆", gtrapprox: "⪆", gbreve: "ğ", gcirc: "ĝ", gcy: "г", gdot: "ġ", gescc: "⪩", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", gfr: "𝔤", gimel: "ℷ", gjcy: "ѓ", glE: "⪒", gla: "⪥", glj: "⪤", gnE: "≩", gneqq: "≩", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gneq: "⪈", gnsim: "⋧", gopf: "𝕘", gscr: "ℊ", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gtdot: "⋗", gtrdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrarr: "⥸", gvertneqq: "≩︀", gvnE: "≩︀", hardcy: "ъ", harrcir: "⥈", harrw: "↭", leftrightsquigarrow: "↭", hbar: "ℏ", hslash: "ℏ", planck: "ℏ", plankv: "ℏ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", mldr: "…", hercon: "⊹", hfr: "𝔥", hksearow: "⤥", searhk: "⤥", hkswarow: "⤦", swarhk: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", larrhk: "↩", hookrightarrow: "↪", rarrhk: "↪", hopf: "𝕙", horbar: "―", hscr: "𝒽", hstrok: "ħ", hybull: "⁃", iacute: "í", icirc: "î", icy: "и", iecy: "е", iexcl: "¡", ifr: "𝔦", igrave: "ì", iiiint: "⨌", qint: "⨌", iiint: "∭", tint: "∭", iinfin: "⧜", iiota: "℩", ijlig: "ĳ", imacr: "ī", imath: "ı", inodot: "ı", imof: "⊷", imped: "Ƶ", incare: "℅", infin: "∞", infintie: "⧝", intcal: "⊺", intercal: "⊺", intlarhk: "⨗", intprod: "⨼", iprod: "⨼", iocy: "ё", iogon: "į", iopf: "𝕚", iota: "ι", iquest: "¿", iscr: "𝒾", isinE: "⋹", isindot: "⋵", isins: "⋴", isinsv: "⋳", itilde: "ĩ", iukcy: "і", iuml: "ï", jcirc: "ĵ", jcy: "й", jfr: "𝔧", jmath: "ȷ", jopf: "𝕛", jscr: "𝒿", jsercy: "ј", jukcy: "є", kappa: "κ", kappav: "ϰ", varkappa: "ϰ", kcedil: "ķ", kcy: "к", kfr: "𝔨", kgreen: "ĸ", khcy: "х", kjcy: "ќ", kopf: "𝕜", kscr: "𝓀", lAtail: "⤛", lBarr: "⤎", lEg: "⪋", lesseqqgtr: "⪋", lHar: "⥢", lacute: "ĺ", laemptyv: "⦴", lambda: "λ", langd: "⦑", lap: "⪅", lessapprox: "⪅", laquo: "«", larrbfs: "⤟", larrfs: "⤝", larrlp: "↫", looparrowleft: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", leftarrowtail: "↢", lat: "⪫", latail: "⤙", late: "⪭", lates: "⪭︀", lbarr: "⤌", lbbrk: "❲", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", lcaron: "ľ", lcedil: "ļ", lcy: "л", ldca: "⤶", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", leq: "≤", leftleftarrows: "⇇", llarr: "⇇", leftthreetimes: "⋋", lthree: "⋋", lescc: "⪨", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessdot: "⋖", ltdot: "⋖", lfisht: "⥼", lfr: "𝔩", lgE: "⪑", lharul: "⥪", lhblk: "▄", ljcy: "љ", llhard: "⥫", lltri: "◺", lmidot: "ŀ", lmoust: "⎰", lmoustache: "⎰", lnE: "≨", lneqq: "≨", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lneq: "⪇", lnsim: "⋦", loang: "⟬", loarr: "⇽", longmapsto: "⟼", xmap: "⟼", looparrowright: "↬", rarrlp: "↬", lopar: "⦅", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", loz: "◊", lozenge: "◊", lpar: "(", lparlt: "⦓", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", lscr: "𝓁", lsime: "⪍", lsimg: "⪏", lsquor: "‚", sbquo: "‚", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltrPar: "⦖", ltri: "◃", triangleleft: "◃", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", mDDot: "∺", macr: "¯", strns: "¯", male: "♂", malt: "✠", maltese: "✠", marker: "▮", mcomma: "⨩", mcy: "м", mdash: "—", mfr: "𝔪", mho: "℧", micro: "µ", midcir: "⫰", minus: "−", minusdu: "⨪", mlcp: "⫛", models: "⊧", mopf: "𝕞", mscr: "𝓂", mu: "μ", multimap: "⊸", mumap: "⊸", nGg: "⋙̸", nGt: "≫⃒", nLeftarrow: "⇍", nlArr: "⇍", nLeftrightarrow: "⇎", nhArr: "⇎", nLl: "⋘̸", nLt: "≪⃒", nRightarrow: "⇏", nrArr: "⇏", nVDash: "⊯", nVdash: "⊮", nacute: "ń", nang: "∠⃒", napE: "⩰̸", napid: "≋̸", napos: "ŉ", natur: "♮", natural: "♮", ncap: "⩃", ncaron: "ň", ncedil: "ņ", ncongdot: "⩭̸", ncup: "⩂", ncy: "н", ndash: "–", neArr: "⇗", nearhk: "⤤", nedot: "≐̸", nesear: "⤨", toea: "⤨", nfr: "𝔫", nharr: "↮", nleftrightarrow: "↮", nhpar: "⫲", nis: "⋼", nisd: "⋺", njcy: "њ", nlE: "≦̸", nleqq: "≦̸", nlarr: "↚", nleftarrow: "↚", nldr: "‥", nopf: "𝕟", not: "¬", notinE: "⋹̸", notindot: "⋵̸", notinvb: "⋷", notinvc: "⋶", notnivb: "⋾", notnivc: "⋽", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", nrarr: "↛", nrightarrow: "↛", nrarrc: "⤳̸", nrarrw: "↝̸", nscr: "𝓃", nsub: "⊄", nsubE: "⫅̸", nsubseteqq: "⫅̸", nsup: "⊅", nsupE: "⫆̸", nsupseteqq: "⫆̸", ntilde: "ñ", nu: "ν", num: "#", numero: "№", numsp: " ", nvDash: "⊭", nvHarr: "⤄", nvap: "≍⃒", nvdash: "⊬", nvge: "≥⃒", nvgt: ">⃒", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwArr: "⇖", nwarhk: "⤣", nwnear: "⤧", oacute: "ó", ocirc: "ô", ocy: "о", odblac: "ő", odiv: "⨸", odsold: "⦼", oelig: "œ", ofcir: "⦿", ofr: "𝔬", ogon: "˛", ograve: "ò", ogt: "⧁", ohbar: "⦵", olcir: "⦾", olcross: "⦻", olt: "⧀", omacr: "ō", omega: "ω", omicron: "ο", omid: "⦶", oopf: "𝕠", opar: "⦷", operp: "⦹", or: "∨", vee: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", oscr: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oslash: "ø", osol: "⊘", otilde: "õ", otimesas: "⨶", ouml: "ö", ovbar: "⌽", para: "¶", parsim: "⫳", parsl: "⫽", pcy: "п", percnt: "%", period: ".", permil: "‰", pertenk: "‱", pfr: "𝔭", phi: "φ", phiv: "ϕ", straightphi: "ϕ", varphi: "ϕ", phone: "☎", pi: "π", piv: "ϖ", varpi: "ϖ", planckh: "ℎ", plus: "+", plusacir: "⨣", pluscir: "⨢", plusdu: "⨥", pluse: "⩲", plussim: "⨦", plustwo: "⨧", pointint: "⨕", popf: "𝕡", pound: "£", prE: "⪳", prap: "⪷", precapprox: "⪷", precnapprox: "⪹", prnap: "⪹", precneqq: "⪵", prnE: "⪵", precnsim: "⋨", prnsim: "⋨", prime: "′", profalar: "⌮", profline: "⌒", profsurf: "⌓", prurel: "⊰", pscr: "𝓅", psi: "ψ", puncsp: " ", qfr: "𝔮", qopf: "𝕢", qprime: "⁗", qscr: "𝓆", quatint: "⨖", quest: "?", rAtail: "⤜", rHar: "⥤", race: "∽̱", racute: "ŕ", raemptyv: "⦳", rangd: "⦒", range: "⦥", raquo: "»", rarrap: "⥵", rarrbfs: "⤠", rarrc: "⤳", rarrfs: "⤞", rarrpl: "⥅", rarrsim: "⥴", rarrtl: "↣", rightarrowtail: "↣", rarrw: "↝", rightsquigarrow: "↝", ratail: "⤚", ratio: "∶", rbbrk: "❳", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", rcaron: "ř", rcedil: "ŗ", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdsh: "↳", rect: "▭", rfisht: "⥽", rfr: "𝔯", rharul: "⥬", rho: "ρ", rhov: "ϱ", varrho: "ϱ", rightrightarrows: "⇉", rrarr: "⇉", rightthreetimes: "⋌", rthree: "⋌", ring: "˚", rlm: "‏", rmoust: "⎱", rmoustache: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", ropar: "⦆", ropf: "𝕣", roplus: "⨮", rotimes: "⨵", rpar: ")", rpargt: "⦔", rppolint: "⨒", rsaquo: "›", rscr: "𝓇", rtimes: "⋊", rtri: "▹", triangleright: "▹", rtriltri: "⧎", ruluhar: "⥨", rx: "℞", sacute: "ś", scE: "⪴", scap: "⪸", succapprox: "⪸", scaron: "š", scedil: "ş", scirc: "ŝ", scnE: "⪶", succneqq: "⪶", scnap: "⪺", succnapprox: "⪺", scnsim: "⋩", succnsim: "⋩", scpolint: "⨓", scy: "с", sdot: "⋅", sdote: "⩦", seArr: "⇘", sect: "§", semi: ";", seswar: "⤩", tosa: "⤩", sext: "✶", sfr: "𝔰", sharp: "♯", shchcy: "щ", shcy: "ш", shy: "­", sigma: "σ", sigmaf: "ς", sigmav: "ς", varsigma: "ς", simdot: "⩪", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", smashp: "⨳", smeparsl: "⧤", smile: "⌣", ssmile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", softcy: "ь", sol: "/", solb: "⧄", solbar: "⌿", sopf: "𝕤", spades: "♠", spadesuit: "♠", sqcaps: "⊓︀", sqcups: "⊔︀", sscr: "𝓈", star: "☆", sub: "⊂", subset: "⊂", subE: "⫅", subseteqq: "⫅", subdot: "⪽", subedot: "⫃", submult: "⫁", subnE: "⫋", subsetneqq: "⫋", subne: "⊊", subsetneq: "⊊", subplus: "⪿", subrarr: "⥹", subsim: "⫇", subsub: "⫕", subsup: "⫓", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", supE: "⫆", supseteqq: "⫆", supdot: "⪾", supdsub: "⫘", supedot: "⫄", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supsetneqq: "⫌", supne: "⊋", supsetneq: "⊋", supplus: "⫀", supsim: "⫈", supsub: "⫔", supsup: "⫖", swArr: "⇙", swnwar: "⤪", szlig: "ß", target: "⌖", tau: "τ", tcaron: "ť", tcedil: "ţ", tcy: "т", telrec: "⌕", tfr: "𝔱", theta: "θ", thetasym: "ϑ", thetav: "ϑ", vartheta: "ϑ", thorn: "þ", times: "×", timesbar: "⨱", timesd: "⨰", topbot: "⌶", topcir: "⫱", topf: "𝕥", topfork: "⫚", tprime: "‴", triangle: "▵", utri: "▵", triangleq: "≜", trie: "≜", tridot: "◬", triminus: "⨺", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", tscr: "𝓉", tscy: "ц", tshcy: "ћ", tstrok: "ŧ", uHar: "⥣", uacute: "ú", ubrcy: "ў", ubreve: "ŭ", ucirc: "û", ucy: "у", udblac: "ű", ufisht: "⥾", ufr: "𝔲", ugrave: "ù", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", umacr: "ū", uogon: "ų", uopf: "𝕦", upsi: "υ", upsilon: "υ", upuparrows: "⇈", uuarr: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", uring: "ů", urtri: "◹", uscr: "𝓊", utdot: "⋰", utilde: "ũ", uuml: "ü", uwangle: "⦧", vBar: "⫨", vBarv: "⫩", vangrt: "⦜", varsubsetneq: "⊊︀", vsubne: "⊊︀", varsubsetneqq: "⫋︀", vsubnE: "⫋︀", varsupsetneq: "⊋︀", vsupne: "⊋︀", varsupsetneqq: "⫌︀", vsupnE: "⫌︀", vcy: "в", veebar: "⊻", veeeq: "≚", vellip: "⋮", vfr: "𝔳", vopf: "𝕧", vscr: "𝓋", vzigzag: "⦚", wcirc: "ŵ", wedbar: "⩟", wedgeq: "≙", weierp: "℘", wp: "℘", wfr: "𝔴", wopf: "𝕨", wscr: "𝓌", xfr: "𝔵", xi: "ξ", xnis: "⋻", xopf: "𝕩", xscr: "𝓍", yacute: "ý", yacy: "я", ycirc: "ŷ", ycy: "ы", yen: "¥", yfr: "𝔶", yicy: "ї", yopf: "𝕪", yscr: "𝓎", yucy: "ю", yuml: "ÿ", zacute: "ź", zcaron: "ž", zcy: "з", zdot: "ż", zeta: "ζ", zfr: "𝔷", zhcy: "ж", zigrarr: "⇝", zopf: "𝕫", zscr: "𝓏", zwj: "‍", zwnj: "‌" }, Ak = "";
Ho.ngsp = Ak;
var Fk = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
function Tk(t, e) {
  if (e != null && !(Array.isArray(e) && e.length == 2))
    throw new Error(`Expected '${t}' to be an array, [start, end].`);
  if (e != null) {
    let r = e[0], n = e[1];
    Fk.forEach((i) => {
      if (i.test(r) || i.test(n))
        throw new Error(`['${r}', '${n}'] contains unusable interpolation symbol.`);
    });
  }
}
var _k = class Bg {
  static fromArray(e) {
    return e ? (Tk("interpolation", e), new Bg(e[0], e[1])) : Og;
  }
  constructor(e, r) {
    this.start = e, this.end = r;
  }
}, Og = new _k("{{", "}}"), Dl = class extends Ag {
  constructor(t, e, r) {
    super(r, t), this.tokenType = e;
  }
}, Bk = class {
  constructor(t, e, r) {
    this.tokens = t, this.errors = e, this.nonNormalizedIcuExpressions = r;
  }
};
function Ok(t, e, r, n = {}) {
  let i = new Pk(new Eg(t, e), r, n);
  return i.tokenize(), new Bk(Wk(i.tokens), i.errors, i.nonNormalizedIcuExpressions);
}
var Mk = /\r\n?/g;
function In(t) {
  return `Unexpected character "${t === 0 ? "EOF" : String.fromCharCode(t)}"`;
}
function zf(t) {
  return `Unknown entity "${t}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
}
function Lk(t, e) {
  return `Unable to parse entity "${e}" - ${t} character reference entities must end with ";"`;
}
var Vo;
(function(t) {
  t.HEX = "hexadecimal", t.DEC = "decimal";
})(Vo || (Vo = {}));
var wl = class {
  constructor(e) {
    this.error = e;
  }
}, Pk = class {
  constructor(t, e, r) {
    this._getTagContentType = e, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = !1, this._fullNameStack = [], this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = r.tokenizeExpansionForms || !1, this._interpolationConfig = r.interpolationConfig || Og, this._leadingTriviaCodePoints = r.leadingTriviaChars && r.leadingTriviaChars.map((i) => i.codePointAt(0) || 0), this._canSelfClose = r.canSelfClose || !1, this._allowHtmComponentClosingTags = r.allowHtmComponentClosingTags || !1;
    let n = r.range || { endPos: t.content.length, startPos: 0, startLine: 0, startCol: 0 };
    this._cursor = r.escapedString ? new qk(t, n) : new Mg(t, n), this._preserveLineEndings = r.preserveLineEndings || !1, this._i18nNormalizeLineEndingsInICUs = r.i18nNormalizeLineEndingsInICUs || !1, this._tokenizeBlocks = r.tokenizeBlocks ?? !0;
    try {
      this._cursor.init();
    } catch (i) {
      this.handleError(i);
    }
  }
  _processCarriageReturns(t) {
    return this._preserveLineEndings ? t : t.replace(Mk, `
`);
  }
  tokenize() {
    for (; this._cursor.peek() !== 0; ) {
      let t = this._cursor.clone();
      try {
        if (this._attemptCharCode(60))
          if (this._attemptCharCode(33))
            this._attemptStr("[CDATA[") ? this._consumeCdata(t) : this._attemptStr("--") ? this._consumeComment(t) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(t) : this._consumeBogusComment(t);
          else if (this._attemptCharCode(47))
            this._consumeTagClose(t);
          else {
            let e = this._cursor.clone();
            this._attemptCharCode(63) ? (this._cursor = e, this._consumeBogusComment(t)) : this._consumeTagOpen(t);
          }
        else
          this._tokenizeBlocks && this._attemptCharCode(64) ? this._consumeBlockStart(t) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(125) ? this._consumeBlockEnd(t) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
      } catch (e) {
        this.handleError(e);
      }
    }
    this._beginToken(30), this._endToken([]);
  }
  _getBlockName() {
    let t = !1, e = this._cursor.clone();
    return this._attemptCharCodeUntilFn((r) => Jc(r) ? !t : Kf(r) ? (t = !0, !1) : !0), this._cursor.getChars(e).trim();
  }
  _consumeBlockStart(t) {
    this._beginToken(25, t);
    let e = this._endToken([this._getBlockName()]);
    if (this._cursor.peek() === 40)
      if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(Be), this._attemptCharCode(41))
        this._attemptCharCodeUntilFn(Be);
      else {
        e.type = 29;
        return;
      }
    this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : e.type = 29;
  }
  _consumeBlockEnd(t) {
    this._beginToken(27, t), this._endToken([]);
  }
  _consumeBlockParameters() {
    for (this._attemptCharCodeUntilFn(Yf); this._cursor.peek() !== 41 && this._cursor.peek() !== 0; ) {
      this._beginToken(28);
      let t = this._cursor.clone(), e = null, r = 0;
      for (; this._cursor.peek() !== 59 && this._cursor.peek() !== 0 || e !== null; ) {
        let n = this._cursor.peek();
        if (n === 92)
          this._cursor.advance();
        else if (n === e)
          e = null;
        else if (e === null && Of(n))
          e = n;
        else if (n === 40 && e === null)
          r++;
        else if (n === 41 && e === null) {
          if (r === 0)
            break;
          r > 0 && r--;
        }
        this._cursor.advance();
      }
      this._endToken([this._cursor.getChars(t)]), this._attemptCharCodeUntilFn(Yf);
    }
  }
  _tokenizeExpansionForm() {
    if (this.isExpansionFormStart())
      return this._consumeExpansionFormStart(), !0;
    if ($k(this._cursor.peek()) && this._isInExpansionForm())
      return this._consumeExpansionCaseStart(), !0;
    if (this._cursor.peek() === 125) {
      if (this._isInExpansionCase())
        return this._consumeExpansionCaseEnd(), !0;
      if (this._isInExpansionForm())
        return this._consumeExpansionFormEnd(), !0;
    }
    return !1;
  }
  _beginToken(t, e = this._cursor.clone()) {
    this._currentTokenStart = e, this._currentTokenType = t;
  }
  _endToken(t, e) {
    if (this._currentTokenStart === null)
      throw new Dl("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(e));
    if (this._currentTokenType === null)
      throw new Dl("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
    let r = { type: this._currentTokenType, parts: t, sourceSpan: (e ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
    return this.tokens.push(r), this._currentTokenStart = null, this._currentTokenType = null, r;
  }
  _createError(t, e) {
    this._isInExpansionForm() && (t += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
    let r = new Dl(t, this._currentTokenType, e);
    return this._currentTokenStart = null, this._currentTokenType = null, new wl(r);
  }
  handleError(t) {
    if (t instanceof Qc && (t = this._createError(t.msg, this._cursor.getSpan(t.cursor))), t instanceof wl)
      this.errors.push(t.error);
    else
      throw t;
  }
  _attemptCharCode(t) {
    return this._cursor.peek() === t ? (this._cursor.advance(), !0) : !1;
  }
  _attemptCharCodeCaseInsensitive(t) {
    return jk(this._cursor.peek(), t) ? (this._cursor.advance(), !0) : !1;
  }
  _requireCharCode(t) {
    let e = this._cursor.clone();
    if (!this._attemptCharCode(t))
      throw this._createError(In(this._cursor.peek()), this._cursor.getSpan(e));
  }
  _attemptStr(t) {
    let e = t.length;
    if (this._cursor.charsLeft() < e)
      return !1;
    let r = this._cursor.clone();
    for (let n = 0; n < e; n++)
      if (!this._attemptCharCode(t.charCodeAt(n)))
        return this._cursor = r, !1;
    return !0;
  }
  _attemptStrCaseInsensitive(t) {
    for (let e = 0; e < t.length; e++)
      if (!this._attemptCharCodeCaseInsensitive(t.charCodeAt(e)))
        return !1;
    return !0;
  }
  _requireStr(t) {
    let e = this._cursor.clone();
    if (!this._attemptStr(t))
      throw this._createError(In(this._cursor.peek()), this._cursor.getSpan(e));
  }
  _requireStrCaseInsensitive(t) {
    let e = this._cursor.clone();
    if (!this._attemptStrCaseInsensitive(t))
      throw this._createError(In(this._cursor.peek()), this._cursor.getSpan(e));
  }
  _attemptCharCodeUntilFn(t) {
    for (; !t(this._cursor.peek()); )
      this._cursor.advance();
  }
  _requireCharCodeUntilFn(t, e) {
    let r = this._cursor.clone();
    if (this._attemptCharCodeUntilFn(t), this._cursor.diff(r) < e)
      throw this._createError(In(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptUntilChar(t) {
    for (; this._cursor.peek() !== t; )
      this._cursor.advance();
  }
  _readChar() {
    let t = String.fromCodePoint(this._cursor.peek());
    return this._cursor.advance(), t;
  }
  _consumeEntity(t) {
    this._beginToken(9);
    let e = this._cursor.clone();
    if (this._cursor.advance(), this._attemptCharCode(35)) {
      let r = this._attemptCharCode(120) || this._attemptCharCode(88), n = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(Rk), this._cursor.peek() != 59) {
        this._cursor.advance();
        let s = r ? Vo.HEX : Vo.DEC;
        throw this._createError(Lk(s, this._cursor.getChars(e)), this._cursor.getSpan());
      }
      let i = this._cursor.getChars(n);
      this._cursor.advance();
      try {
        let s = parseInt(i, r ? 16 : 10);
        this._endToken([String.fromCharCode(s), this._cursor.getChars(e)]);
      } catch {
        throw this._createError(zf(this._cursor.getChars(e)), this._cursor.getSpan());
      }
    } else {
      let r = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(Ik), this._cursor.peek() != 59)
        this._beginToken(t, e), this._cursor = r, this._endToken(["&"]);
      else {
        let n = this._cursor.getChars(r);
        this._cursor.advance();
        let i = Ho[n];
        if (!i)
          throw this._createError(zf(n), this._cursor.getSpan(e));
        this._endToken([i, `&${n};`]);
      }
    }
  }
  _consumeRawText(t, e) {
    this._beginToken(t ? 6 : 7);
    let r = [];
    for (; ; ) {
      let n = this._cursor.clone(), i = e();
      if (this._cursor = n, i)
        break;
      t && this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(r.join(""))]), r.length = 0, this._consumeEntity(6), this._beginToken(6)) : r.push(this._readChar());
    }
    this._endToken([this._processCarriageReturns(r.join(""))]);
  }
  _consumeComment(t) {
    this._beginToken(10, t), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("-->")), this._beginToken(11), this._requireStr("-->"), this._endToken([]);
  }
  _consumeBogusComment(t) {
    this._beginToken(10, t), this._endToken([]), this._consumeRawText(!1, () => this._cursor.peek() === 62), this._beginToken(11), this._cursor.advance(), this._endToken([]);
  }
  _consumeCdata(t) {
    this._beginToken(12, t), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]);
  }
  _consumeDocType(t) {
    this._beginToken(18, t), this._endToken([]), this._consumeRawText(!1, () => this._cursor.peek() === 62), this._beginToken(19), this._cursor.advance(), this._endToken([]);
  }
  _consumePrefixAndName() {
    let t = this._cursor.clone(), e = "";
    for (; this._cursor.peek() !== 58 && !Nk(this._cursor.peek()); )
      this._cursor.advance();
    let r;
    this._cursor.peek() === 58 ? (e = this._cursor.getChars(t), this._cursor.advance(), r = this._cursor.clone()) : r = t, this._requireCharCodeUntilFn(Uf, e === "" ? 0 : 1);
    let n = this._cursor.getChars(r);
    return [e, n];
  }
  _consumeTagOpen(t) {
    let e, r, n, i = [];
    try {
      if (!Xc(this._cursor.peek()))
        throw this._createError(In(this._cursor.peek()), this._cursor.getSpan(t));
      for (n = this._consumeTagOpenStart(t), r = n.parts[0], e = n.parts[1], this._attemptCharCodeUntilFn(Be); this._cursor.peek() !== 47 && this._cursor.peek() !== 62 && this._cursor.peek() !== 60 && this._cursor.peek() !== 0; ) {
        let [o, a] = this._consumeAttributeName();
        if (this._attemptCharCodeUntilFn(Be), this._attemptCharCode(61)) {
          this._attemptCharCodeUntilFn(Be);
          let l = this._consumeAttributeValue();
          i.push({ prefix: o, name: a, value: l });
        } else
          i.push({ prefix: o, name: a });
        this._attemptCharCodeUntilFn(Be);
      }
      this._consumeTagOpenEnd();
    } catch (o) {
      if (o instanceof wl) {
        n ? n.type = 4 : (this._beginToken(5, t), this._endToken(["<"]));
        return;
      }
      throw o;
    }
    if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === 2)
      return;
    let s = this._getTagContentType(e, r, this._fullNameStack.length > 0, i);
    this._handleFullNameStackForTagOpen(r, e), s === Rt.RAW_TEXT ? this._consumeRawTextWithTagClose(r, e, !1) : s === Rt.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(r, e, !0);
  }
  _consumeRawTextWithTagClose(t, e, r) {
    this._consumeRawText(r, () => !this._attemptCharCode(60) || !this._attemptCharCode(47) || (this._attemptCharCodeUntilFn(Be), !this._attemptStrCaseInsensitive(t ? `${t}:${e}` : e)) ? !1 : (this._attemptCharCodeUntilFn(Be), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((n) => n === 62, 3), this._cursor.advance(), this._endToken([t, e]), this._handleFullNameStackForTagClose(t, e);
  }
  _consumeTagOpenStart(t) {
    this._beginToken(0, t);
    let e = this._consumePrefixAndName();
    return this._endToken(e);
  }
  _consumeAttributeName() {
    let t = this._cursor.peek();
    if (t === 39 || t === 34)
      throw this._createError(In(t), this._cursor.getSpan());
    this._beginToken(14);
    let e = this._consumePrefixAndName();
    return this._endToken(e), e;
  }
  _consumeAttributeValue() {
    let t;
    if (this._cursor.peek() === 39 || this._cursor.peek() === 34) {
      let e = this._cursor.peek();
      this._consumeQuote(e);
      let r = () => this._cursor.peek() === e;
      t = this._consumeWithInterpolation(16, 17, r, r), this._consumeQuote(e);
    } else {
      let e = () => Uf(this._cursor.peek());
      t = this._consumeWithInterpolation(16, 17, e, e);
    }
    return t;
  }
  _consumeQuote(t) {
    this._beginToken(15), this._requireCharCode(t), this._endToken([String.fromCodePoint(t)]);
  }
  _consumeTagOpenEnd() {
    let t = this._attemptCharCode(47) ? 2 : 1;
    this._beginToken(t), this._requireCharCode(62), this._endToken([]);
  }
  _consumeTagClose(t) {
    if (this._beginToken(3, t), this._attemptCharCodeUntilFn(Be), this._allowHtmComponentClosingTags && this._attemptCharCode(47))
      this._attemptCharCodeUntilFn(Be), this._requireCharCode(62), this._endToken([]);
    else {
      let [e, r] = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(Be), this._requireCharCode(62), this._endToken([e, r]), this._handleFullNameStackForTagClose(e, r);
    }
  }
  _consumeExpansionFormStart() {
    this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
    let t = this._readUntil(44), e = this._processCarriageReturns(t);
    if (this._i18nNormalizeLineEndingsInICUs)
      this._endToken([e]);
    else {
      let n = this._endToken([t]);
      e !== t && this.nonNormalizedIcuExpressions.push(n);
    }
    this._requireCharCode(44), this._attemptCharCodeUntilFn(Be), this._beginToken(7);
    let r = this._readUntil(44);
    this._endToken([r]), this._requireCharCode(44), this._attemptCharCodeUntilFn(Be);
  }
  _consumeExpansionCaseStart() {
    this._beginToken(21);
    let t = this._readUntil(123).trim();
    this._endToken([t]), this._attemptCharCodeUntilFn(Be), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(Be), this._expansionCaseStack.push(22);
  }
  _consumeExpansionCaseEnd() {
    this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(Be), this._expansionCaseStack.pop();
  }
  _consumeExpansionFormEnd() {
    this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
  }
  _consumeWithInterpolation(t, e, r, n) {
    this._beginToken(t);
    let i = [];
    for (; !r(); ) {
      let o = this._cursor.clone();
      this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(i.join(""))], o), i.length = 0, this._consumeInterpolation(e, o, n), this._beginToken(t)) : this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(i.join(""))]), i.length = 0, this._consumeEntity(t), this._beginToken(t)) : i.push(this._readChar());
    }
    this._inInterpolation = !1;
    let s = this._processCarriageReturns(i.join(""));
    return this._endToken([s]), s;
  }
  _consumeInterpolation(t, e, r) {
    let n = [];
    this._beginToken(t, e), n.push(this._interpolationConfig.start);
    let i = this._cursor.clone(), s = null, o = !1;
    for (; this._cursor.peek() !== 0 && (r === null || !r()); ) {
      let a = this._cursor.clone();
      if (this._isTagStart()) {
        this._cursor = a, n.push(this._getProcessedChars(i, a)), this._endToken(n);
        return;
      }
      if (s === null)
        if (this._attemptStr(this._interpolationConfig.end)) {
          n.push(this._getProcessedChars(i, a)), n.push(this._interpolationConfig.end), this._endToken(n);
          return;
        } else
          this._attemptStr("//") && (o = !0);
      let l = this._cursor.peek();
      this._cursor.advance(), l === 92 ? this._cursor.advance() : l === s ? s = null : !o && s === null && Of(l) && (s = l);
    }
    n.push(this._getProcessedChars(i, this._cursor)), this._endToken(n);
  }
  _getProcessedChars(t, e) {
    return this._processCarriageReturns(e.getChars(t));
  }
  _isTextEnd() {
    return !!(this._isTagStart() || this._cursor.peek() === 0 || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === 125 && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._cursor.peek() === 125));
  }
  _isTagStart() {
    if (this._cursor.peek() === 60) {
      let t = this._cursor.clone();
      t.advance();
      let e = t.peek();
      if (97 <= e && e <= 122 || 65 <= e && e <= 90 || e === 47 || e === 33)
        return !0;
    }
    return !1;
  }
  _isBlockStart() {
    if (this._tokenizeBlocks && this._cursor.peek() === 64) {
      let t = this._cursor.clone();
      if (t.advance(), Kf(t.peek()))
        return !0;
    }
    return !1;
  }
  _readUntil(t) {
    let e = this._cursor.clone();
    return this._attemptUntilChar(t), this._cursor.getChars(e);
  }
  _isInExpansion() {
    return this._isInExpansionCase() || this._isInExpansionForm();
  }
  _isInExpansionCase() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 22;
  }
  _isInExpansionForm() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 20;
  }
  isExpansionFormStart() {
    if (this._cursor.peek() !== 123)
      return !1;
    if (this._interpolationConfig) {
      let t = this._cursor.clone(), e = this._attemptStr(this._interpolationConfig.start);
      return this._cursor = t, !e;
    }
    return !0;
  }
  _handleFullNameStackForTagOpen(t, e) {
    let r = qo(t, e);
    (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === r) && this._fullNameStack.push(r);
  }
  _handleFullNameStackForTagClose(t, e) {
    let r = qo(t, e);
    this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === r && this._fullNameStack.pop();
  }
};
function Be(t) {
  return !Jc(t) || t === 0;
}
function Uf(t) {
  return Jc(t) || t === 62 || t === 60 || t === 47 || t === 39 || t === 34 || t === 61 || t === 0;
}
function Nk(t) {
  return (t < 97 || 122 < t) && (t < 65 || 90 < t) && (t < 48 || t > 57);
}
function Rk(t) {
  return t === 59 || t === 0 || !WC(t);
}
function Ik(t) {
  return t === 59 || t === 0 || !Xc(t);
}
function $k(t) {
  return t !== 125;
}
function jk(t, e) {
  return Gf(t) === Gf(e);
}
function Gf(t) {
  return t >= 97 && t <= 122 ? t - 97 + 65 : t;
}
function Kf(t) {
  return Xc(t) || Cg(t) || t === 95;
}
function Yf(t) {
  return t !== 59 && Be(t);
}
function Wk(t) {
  let e = [], r;
  for (let n = 0; n < t.length; n++) {
    let i = t[n];
    r && r.type === 5 && i.type === 5 || r && r.type === 16 && i.type === 16 ? (r.parts[0] += i.parts[0], r.sourceSpan.end = i.sourceSpan.end) : (r = i, e.push(r));
  }
  return e;
}
var Mg = class pu {
  constructor(e, r) {
    if (e instanceof pu) {
      this.file = e.file, this.input = e.input, this.end = e.end;
      let n = e.state;
      this.state = { peek: n.peek, offset: n.offset, line: n.line, column: n.column };
    } else {
      if (!r)
        throw new Error("Programming error: the range argument must be provided with a file argument.");
      this.file = e, this.input = e.content, this.end = r.endPos, this.state = { peek: -1, offset: r.startPos, line: r.startLine, column: r.startCol };
    }
  }
  clone() {
    return new pu(this);
  }
  peek() {
    return this.state.peek;
  }
  charsLeft() {
    return this.end - this.state.offset;
  }
  diff(e) {
    return this.state.offset - e.state.offset;
  }
  advance() {
    this.advanceState(this.state);
  }
  init() {
    this.updatePeek(this.state);
  }
  getSpan(e, r) {
    e = e || this;
    let n = e;
    if (r)
      for (; this.diff(e) > 0 && r.indexOf(e.peek()) !== -1; )
        n === e && (e = e.clone()), e.advance();
    let i = this.locationFromCursor(e), s = this.locationFromCursor(this), o = n !== e ? this.locationFromCursor(n) : i;
    return new ne(i, s, o);
  }
  getChars(e) {
    return this.input.substring(e.state.offset, this.state.offset);
  }
  charAt(e) {
    return this.input.charCodeAt(e);
  }
  advanceState(e) {
    if (e.offset >= this.end)
      throw this.state = e, new Qc('Unexpected character "EOF"', this);
    let r = this.charAt(e.offset);
    r === 10 ? (e.line++, e.column = 0) : kg(r) || e.column++, e.offset++, this.updatePeek(e);
  }
  updatePeek(e) {
    e.peek = e.offset >= this.end ? 0 : this.charAt(e.offset);
  }
  locationFromCursor(e) {
    return new fu(e.file, e.state.offset, e.state.line, e.state.column);
  }
}, qk = class mu extends Mg {
  constructor(e, r) {
    e instanceof mu ? (super(e), this.internalState = { ...e.internalState }) : (super(e, r), this.internalState = this.state);
  }
  advance() {
    this.state = this.internalState, super.advance(), this.processEscapeSequence();
  }
  init() {
    super.init(), this.processEscapeSequence();
  }
  clone() {
    return new mu(this);
  }
  getChars(e) {
    let r = e.clone(), n = "";
    for (; r.internalState.offset < this.internalState.offset; )
      n += String.fromCodePoint(r.peek()), r.advance();
    return n;
  }
  processEscapeSequence() {
    let e = () => this.internalState.peek;
    if (e() === 92)
      if (this.internalState = { ...this.state }, this.advanceState(this.internalState), e() === 110)
        this.state.peek = 10;
      else if (e() === 114)
        this.state.peek = 13;
      else if (e() === 118)
        this.state.peek = 11;
      else if (e() === 116)
        this.state.peek = 9;
      else if (e() === 98)
        this.state.peek = 8;
      else if (e() === 102)
        this.state.peek = 12;
      else if (e() === 117)
        if (this.advanceState(this.internalState), e() === 123) {
          this.advanceState(this.internalState);
          let r = this.clone(), n = 0;
          for (; e() !== 125; )
            this.advanceState(this.internalState), n++;
          this.state.peek = this.decodeHexDigits(r, n);
        } else {
          let r = this.clone();
          this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 4);
        }
      else if (e() === 120) {
        this.advanceState(this.internalState);
        let r = this.clone();
        this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 2);
      } else if (Bf(e())) {
        let r = "", n = 0, i = this.clone();
        for (; Bf(e()) && n < 3; )
          i = this.clone(), r += String.fromCodePoint(e()), this.advanceState(this.internalState), n++;
        this.state.peek = parseInt(r, 8), this.internalState = i.internalState;
      } else
        kg(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
  }
  decodeHexDigits(e, r) {
    let n = this.input.slice(e.internalState.offset, e.internalState.offset + r), i = parseInt(n, 16);
    if (isNaN(i))
      throw e.state = e.internalState, new Qc("Invalid hexadecimal escape sequence", e);
    return i;
  }
}, Qc = class {
  constructor(t, e) {
    this.msg = t, this.cursor = e;
  }
}, xt = class Lg extends Ag {
  static create(e, r, n) {
    return new Lg(e, r, n);
  }
  constructor(e, r, n) {
    super(r, n), this.elementName = e;
  }
}, Hk = class {
  constructor(t, e) {
    this.rootNodes = t, this.errors = e;
  }
}, Vk = class {
  constructor(e) {
    this.getTagDefinition = e;
  }
  parse(e, r, n, i = !1, s) {
    let o = (p) => (m, ...y) => p(m.toLowerCase(), ...y), a = i ? this.getTagDefinition : o(this.getTagDefinition), l = (p) => a(p).getContentType(), c = i ? s : o(s), u = Ok(e, r, s ? (p, m, y, v) => {
      let g = c(p, m, y, v);
      return g !== void 0 ? g : l(p);
    } : l, n), h = n && n.canSelfClose || !1, f = n && n.allowHtmComponentClosingTags || !1, d = new zk(u.tokens, a, h, f, i);
    return d.build(), new Hk(d.rootNodes, u.errors.concat(d.errors));
  }
}, zk = class Pg {
  constructor(e, r, n, i, s) {
    this.tokens = e, this.getTagDefinition = r, this.canSelfClose = n, this.allowHtmComponentClosingTags = i, this.isTagNameCaseSensitive = s, this._index = -1, this._containerStack = [], this.rootNodes = [], this.errors = [], this._advance();
  }
  build() {
    for (; this._peek.type !== 30; )
      this._peek.type === 0 || this._peek.type === 4 ? this._consumeStartTag(this._advance()) : this._peek.type === 3 ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === 12 ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === 10 ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6 ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === 20 ? this._consumeExpansion(this._advance()) : this._peek.type === 25 ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === 27 ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === 29 ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === 18 ? this._consumeDocType(this._advance()) : this._advance();
    for (let e of this._containerStack)
      e instanceof Rn && this.errors.push(xt.create(e.name, e.sourceSpan, `Unclosed block "${e.name}"`));
  }
  _advance() {
    let e = this._peek;
    return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e;
  }
  _advanceIf(e) {
    return this._peek.type === e ? this._advance() : null;
  }
  _consumeCdata(e) {
    let r = this._advance(), n = this._getText(r), i = this._advanceIf(13);
    this._addToParent(new Dk(n, new ne(e.sourceSpan.start, (i || r).sourceSpan.end), [r]));
  }
  _consumeComment(e) {
    let r = this._advanceIf(7), n = this._advanceIf(11), i = r != null ? r.parts[0].trim() : null, s = new ne(e.sourceSpan.start, (n || r || e).sourceSpan.end);
    this._addToParent(new kk(i, s));
  }
  _consumeDocType(e) {
    let r = this._advanceIf(7), n = this._advanceIf(19), i = r != null ? r.parts[0].trim() : null, s = new ne(e.sourceSpan.start, (n || r || e).sourceSpan.end);
    this._addToParent(new Sk(i, s));
  }
  _consumeExpansion(e) {
    let r = this._advance(), n = this._advance(), i = [];
    for (; this._peek.type === 21; ) {
      let o = this._parseExpansionCase();
      if (!o)
        return;
      i.push(o);
    }
    if (this._peek.type !== 24) {
      this.errors.push(xt.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      return;
    }
    let s = new ne(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart);
    this._addToParent(new wk(r.parts[0], n.parts[0], i, s, r.sourceSpan)), this._advance();
  }
  _parseExpansionCase() {
    let e = this._advance();
    if (this._peek.type !== 22)
      return this.errors.push(xt.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
    let r = this._advance(), n = this._collectExpansionExpTokens(r);
    if (!n)
      return null;
    let i = this._advance();
    n.push({ type: 30, parts: [], sourceSpan: i.sourceSpan });
    let s = new Pg(n, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
    if (s.build(), s.errors.length > 0)
      return this.errors = this.errors.concat(s.errors), null;
    let o = new ne(e.sourceSpan.start, i.sourceSpan.end, e.sourceSpan.fullStart), a = new ne(r.sourceSpan.start, i.sourceSpan.end, r.sourceSpan.fullStart);
    return new xk(e.parts[0], s.rootNodes, o, e.sourceSpan, a);
  }
  _collectExpansionExpTokens(e) {
    let r = [], n = [22];
    for (; ; ) {
      if ((this._peek.type === 20 || this._peek.type === 22) && n.push(this._peek.type), this._peek.type === 23)
        if (Jf(n, 22)) {
          if (n.pop(), n.length === 0)
            return r;
        } else
          return this.errors.push(xt.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 24)
        if (Jf(n, 20))
          n.pop();
        else
          return this.errors.push(xt.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 30)
        return this.errors.push(xt.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      r.push(this._advance());
    }
  }
  _getText(e) {
    let r = e.parts[0];
    if (r.length > 0 && r[0] == `
`) {
      let n = this._getClosestParentElement();
      n != null && n.children.length == 0 && this.getTagDefinition(n.name).ignoreFirstLf && (r = r.substring(1));
    }
    return r;
  }
  _consumeText(e) {
    let r = [e], n = e.sourceSpan, i = e.parts[0];
    if (i.length > 0 && i[0] === `
`) {
      let s = this._getContainer();
      s != null && s.children.length === 0 && this.getTagDefinition(s.name).ignoreFirstLf && (i = i.substring(1), r[0] = { type: e.type, sourceSpan: e.sourceSpan, parts: [i] });
    }
    for (; this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9; )
      e = this._advance(), r.push(e), e.type === 8 ? i += e.parts.join("").replace(/&([^;]+);/g, Xf) : e.type === 9 ? i += e.parts[0] : i += e.parts.join("");
    if (i.length > 0) {
      let s = e.sourceSpan;
      this._addToParent(new bk(i, new ne(n.start, s.end, n.fullStart, n.details), r));
    }
  }
  _closeVoidElement() {
    let e = this._getContainer();
    e instanceof Br && this.getTagDefinition(e.name).isVoid && this._containerStack.pop();
  }
  _consumeStartTag(e) {
    let [r, n] = e.parts, i = [];
    for (; this._peek.type === 14; )
      i.push(this._consumeAttr(this._advance()));
    let s = this._getElementFullName(r, n, this._getClosestParentElement()), o = !1;
    if (this._peek.type === 2) {
      this._advance(), o = !0;
      let d = this.getTagDefinition(s);
      this.canSelfClose || d.canSelfClose || ko(s) !== null || d.isVoid || this.errors.push(xt.create(s, e.sourceSpan, `Only void, custom and foreign elements can be self closed "${e.parts[1]}"`));
    } else
      this._peek.type === 1 && (this._advance(), o = !1);
    let a = this._peek.sourceSpan.fullStart, l = new ne(e.sourceSpan.start, a, e.sourceSpan.fullStart), c = new ne(e.sourceSpan.start, a, e.sourceSpan.fullStart), u = new ne(e.sourceSpan.start.moveBy(1), e.sourceSpan.end), h = new Br(s, i, [], l, c, void 0, u), f = this._getContainer();
    this._pushContainer(h, f instanceof Br && this.getTagDefinition(f.name).isClosedByChild(h.name)), o ? this._popContainer(s, Br, l) : e.type === 4 && (this._popContainer(s, Br, null), this.errors.push(xt.create(s, l, `Opening tag "${s}" not terminated.`)));
  }
  _pushContainer(e, r) {
    r && this._containerStack.pop(), this._addToParent(e), this._containerStack.push(e);
  }
  _consumeEndTag(e) {
    let r = this.allowHtmComponentClosingTags && e.parts.length === 0 ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getClosestParentElement());
    if (r && this.getTagDefinition(r).isVoid)
      this.errors.push(xt.create(r, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
    else if (!this._popContainer(r, Br, e.sourceSpan)) {
      let n = `Unexpected closing tag "${r}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
      this.errors.push(xt.create(r, e.sourceSpan, n));
    }
  }
  _popContainer(e, r, n) {
    let i = !1;
    for (let s = this._containerStack.length - 1; s >= 0; s--) {
      let o = this._containerStack[s];
      if (ko(o.name) ? o.name === e : (e == null || o.name.toLowerCase() === e.toLowerCase()) && o instanceof r)
        return o.endSourceSpan = n, o.sourceSpan.end = n !== null ? n.end : o.sourceSpan.end, this._containerStack.splice(s, this._containerStack.length - s), !i;
      (o instanceof Rn || o instanceof Br && !this.getTagDefinition(o.name).closedByParent) && (i = !0);
    }
    return !1;
  }
  _consumeAttr(e) {
    let r = qo(e.parts[0], e.parts[1]), n = e.sourceSpan.end, i;
    this._peek.type === 15 && (i = this._advance());
    let s = "", o = [], a, l;
    if (this._peek.type === 16)
      for (a = this._peek.sourceSpan, l = this._peek.sourceSpan.end; this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9; ) {
        let u = this._advance();
        o.push(u), u.type === 17 ? s += u.parts.join("").replace(/&([^;]+);/g, Xf) : u.type === 9 ? s += u.parts[0] : s += u.parts.join(""), l = n = u.sourceSpan.end;
      }
    this._peek.type === 15 && (l = n = this._advance().sourceSpan.end);
    let c = a && l && new ne((i == null ? void 0 : i.sourceSpan.start) ?? a.start, l, (i == null ? void 0 : i.sourceSpan.fullStart) ?? a.fullStart);
    return new Ck(r, s, new ne(e.sourceSpan.start, n, e.sourceSpan.fullStart), e.sourceSpan, c, o.length > 0 ? o : void 0, void 0);
  }
  _consumeBlockOpen(e) {
    let r = [];
    for (; this._peek.type === 28; ) {
      let a = this._advance();
      r.push(new Vf(a.parts[0], a.sourceSpan));
    }
    this._peek.type === 26 && this._advance();
    let n = this._peek.sourceSpan.fullStart, i = new ne(e.sourceSpan.start, n, e.sourceSpan.fullStart), s = new ne(e.sourceSpan.start, n, e.sourceSpan.fullStart), o = new Rn(e.parts[0], r, [], i, s);
    this._pushContainer(o, !1);
  }
  _consumeBlockClose(e) {
    this._popContainer(null, Rn, e.sourceSpan) || this.errors.push(xt.create(null, e.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
  }
  _consumeIncompleteBlock(e) {
    let r = [];
    for (; this._peek.type === 28; ) {
      let a = this._advance();
      r.push(new Vf(a.parts[0], a.sourceSpan));
    }
    let n = this._peek.sourceSpan.fullStart, i = new ne(e.sourceSpan.start, n, e.sourceSpan.fullStart), s = new ne(e.sourceSpan.start, n, e.sourceSpan.fullStart), o = new Rn(e.parts[0], r, [], i, s);
    this._pushContainer(o, !1), this._popContainer(null, Rn, null), this.errors.push(xt.create(e.parts[0], i, `Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
  }
  _getContainer() {
    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
  }
  _getClosestParentElement() {
    for (let e = this._containerStack.length - 1; e > -1; e--)
      if (this._containerStack[e] instanceof Br)
        return this._containerStack[e];
    return null;
  }
  _addToParent(e) {
    let r = this._getContainer();
    r === null ? this.rootNodes.push(e) : r.children.push(e);
  }
  _getElementFullName(e, r, n) {
    if (e === "" && (e = this.getTagDefinition(r).implicitNamespacePrefix || "", e === "" && n != null)) {
      let i = Wa(n.name)[1];
      this.getTagDefinition(i).preventNamespaceInheritance || (e = ko(n.name));
    }
    return qo(e, r);
  }
};
function Jf(t, e) {
  return t.length > 0 && t[t.length - 1] === e;
}
function Xf(t, e) {
  return Ho[e] !== void 0 ? Ho[e] || t : /^#x[a-f0-9]+$/i.test(e) ? String.fromCodePoint(parseInt(e.slice(2), 16)) : /^#\d+$/.test(e) ? String.fromCodePoint(parseInt(e.slice(1), 10)) : t;
}
var Uk = class extends Vk {
  constructor() {
    super(du);
  }
  parse(t, e, r, n = !1, i) {
    return super.parse(t, e, r, n, i);
  }
}, xl = null, Gk = () => (xl || (xl = new Uk()), xl);
function Qf(t, e = {}) {
  let { canSelfClose: r = !1, allowHtmComponentClosingTags: n = !1, isTagNameCaseSensitive: i = !1, getTagContentType: s, tokenizeAngularBlocks: o = !1 } = e;
  return Gk().parse(t, "angular-html-parser", { tokenizeExpansionForms: o, interpolationConfig: void 0, canSelfClose: r, allowHtmComponentClosingTags: n, tokenizeBlocks: o }, i, s);
}
function Kk(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var Yk = Kk, Jk = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
function Xk(t) {
  let e = t.match(Jk);
  if (!e)
    return { content: t };
  let { startDelimiter: r, language: n, value: i = "", endDelimiter: s } = e.groups, o = n.trim() || "yaml";
  if (r === "+++" && (o = "toml"), o !== "yaml" && r !== s)
    return { content: t };
  let [a] = e;
  return { frontMatter: { type: "front-matter", lang: o, value: i, startDelimiter: r, endDelimiter: s, raw: a.replace(/\n$/, "") }, content: yt(!1, a, /[^\n]/g, " ") + t.slice(a.length) };
}
var Qk = Xk, Gs = { attrs: !0, children: !0, cases: !0, expression: !0 }, Zf = /* @__PURE__ */ new Set(["parent"]), Zk = class Ii {
  constructor(e = {}) {
    for (let r of /* @__PURE__ */ new Set([...Zf, ...Object.keys(e)]))
      this.setProperty(r, e[r]);
  }
  setProperty(e, r) {
    if (this[e] !== r) {
      if (e in Gs && (r = r.map((n) => this.createChild(n))), !Zf.has(e)) {
        this[e] = r;
        return;
      }
      Object.defineProperty(this, e, { value: r, enumerable: !1, configurable: !0 });
    }
  }
  map(e) {
    let r;
    for (let n in Gs) {
      let i = this[n];
      if (i) {
        let s = eS(i, (o) => o.map(e));
        r !== i && (r || (r = new Ii({ parent: this.parent })), r.setProperty(n, s));
      }
    }
    if (r)
      for (let n in this)
        n in Gs || (r[n] = this[n]);
    return e(r || this);
  }
  walk(e) {
    for (let r in Gs) {
      let n = this[r];
      if (n)
        for (let i = 0; i < n.length; i++)
          n[i].walk(e);
    }
    e(this);
  }
  createChild(e) {
    let r = e instanceof Ii ? e.clone() : new Ii(e);
    return r.setProperty("parent", this), r;
  }
  insertChildBefore(e, r) {
    this.children.splice(this.children.indexOf(e), 0, this.createChild(r));
  }
  removeChild(e) {
    this.children.splice(this.children.indexOf(e), 1);
  }
  replaceChild(e, r) {
    this.children[this.children.indexOf(e)] = this.createChild(r);
  }
  clone() {
    return new Ii(this);
  }
  get firstChild() {
    var e;
    return (e = this.children) == null ? void 0 : e[0];
  }
  get lastChild() {
    var e;
    return (e = this.children) == null ? void 0 : e[this.children.length - 1];
  }
  get prev() {
    var e, r;
    return (r = (e = this.parent) == null ? void 0 : e.children) == null ? void 0 : r[this.parent.children.indexOf(this) - 1];
  }
  get next() {
    var e, r;
    return (r = (e = this.parent) == null ? void 0 : e.children) == null ? void 0 : r[this.parent.children.indexOf(this) + 1];
  }
  get rawName() {
    return this.hasExplicitNamespace ? this.fullName : this.name;
  }
  get fullName() {
    return this.namespace ? this.namespace + ":" + this.name : this.name;
  }
  get attrMap() {
    return Object.fromEntries(this.attrs.map((e) => [e.fullName, e.value]));
  }
};
function eS(t, e) {
  let r = t.map(e);
  return r.some((n, i) => n !== t[i]) ? r : t;
}
var tS = [{ regex: /^(\[if([^\]]*)]>)(.*?)<!\s*\[endif]$/s, parse: nS }, { regex: /^\[if([^\]]*)]><!$/, parse: iS }, { regex: /^<!\s*\[endif]$/, parse: sS }];
function rS(t, e) {
  if (t.value)
    for (let { regex: r, parse: n } of tS) {
      let i = t.value.match(r);
      if (i)
        return n(t, e, i);
    }
  return null;
}
function nS(t, e, r) {
  let [, n, i, s] = r, o = 4 + n.length, a = t.sourceSpan.start.moveBy(o), l = a.moveBy(s.length), [c, u] = (() => {
    try {
      return [!0, e(s, a).children];
    } catch {
      return [!1, [{ type: "text", value: s, sourceSpan: new ne(a, l) }]];
    }
  })();
  return { type: "ieConditionalComment", complete: c, children: u, condition: yt(!1, i.trim(), /\s+/g, " "), sourceSpan: t.sourceSpan, startSourceSpan: new ne(t.sourceSpan.start, a), endSourceSpan: new ne(l, t.sourceSpan.end) };
}
function iS(t, e, r) {
  let [, n] = r;
  return { type: "ieConditionalStartComment", condition: yt(!1, n.trim(), /\s+/g, " "), sourceSpan: t.sourceSpan };
}
function sS(t) {
  return { type: "ieConditionalEndComment", sourceSpan: t.sourceSpan };
}
var Cl = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set(["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "slot", "spellcheck", "style", "tabindex", "title", "translate"])], ["a", /* @__PURE__ */ new Set(["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"])], ["applet", /* @__PURE__ */ new Set(["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"])], ["area", /* @__PURE__ */ new Set(["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"])], ["audio", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"])], ["base", /* @__PURE__ */ new Set(["href", "target"])], ["basefont", /* @__PURE__ */ new Set(["color", "face", "size"])], ["blockquote", /* @__PURE__ */ new Set(["cite"])], ["body", /* @__PURE__ */ new Set(["alink", "background", "bgcolor", "link", "text", "vlink"])], ["br", /* @__PURE__ */ new Set(["clear"])], ["button", /* @__PURE__ */ new Set(["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "popovertarget", "popovertargetaction", "type", "value"])], ["canvas", /* @__PURE__ */ new Set(["height", "width"])], ["caption", /* @__PURE__ */ new Set(["align"])], ["col", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["colgroup", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["data", /* @__PURE__ */ new Set(["value"])], ["del", /* @__PURE__ */ new Set(["cite", "datetime"])], ["details", /* @__PURE__ */ new Set(["name", "open"])], ["dialog", /* @__PURE__ */ new Set(["open"])], ["dir", /* @__PURE__ */ new Set(["compact"])], ["div", /* @__PURE__ */ new Set(["align"])], ["dl", /* @__PURE__ */ new Set(["compact"])], ["embed", /* @__PURE__ */ new Set(["height", "src", "type", "width"])], ["fieldset", /* @__PURE__ */ new Set(["disabled", "form", "name"])], ["font", /* @__PURE__ */ new Set(["color", "face", "size"])], ["form", /* @__PURE__ */ new Set(["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"])], ["frame", /* @__PURE__ */ new Set(["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"])], ["frameset", /* @__PURE__ */ new Set(["cols", "rows"])], ["h1", /* @__PURE__ */ new Set(["align"])], ["h2", /* @__PURE__ */ new Set(["align"])], ["h3", /* @__PURE__ */ new Set(["align"])], ["h4", /* @__PURE__ */ new Set(["align"])], ["h5", /* @__PURE__ */ new Set(["align"])], ["h6", /* @__PURE__ */ new Set(["align"])], ["head", /* @__PURE__ */ new Set(["profile"])], ["hr", /* @__PURE__ */ new Set(["align", "noshade", "size", "width"])], ["html", /* @__PURE__ */ new Set(["manifest", "version"])], ["iframe", /* @__PURE__ */ new Set(["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"])], ["img", /* @__PURE__ */ new Set(["align", "alt", "border", "crossorigin", "decoding", "fetchpriority", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"])], ["input", /* @__PURE__ */ new Set(["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "popovertarget", "popovertargetaction", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"])], ["ins", /* @__PURE__ */ new Set(["cite", "datetime"])], ["isindex", /* @__PURE__ */ new Set(["prompt"])], ["label", /* @__PURE__ */ new Set(["for", "form"])], ["legend", /* @__PURE__ */ new Set(["align"])], ["li", /* @__PURE__ */ new Set(["type", "value"])], ["link", /* @__PURE__ */ new Set(["as", "blocking", "charset", "color", "crossorigin", "disabled", "fetchpriority", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"])], ["map", /* @__PURE__ */ new Set(["name"])], ["menu", /* @__PURE__ */ new Set(["compact"])], ["meta", /* @__PURE__ */ new Set(["charset", "content", "http-equiv", "media", "name", "scheme"])], ["meter", /* @__PURE__ */ new Set(["high", "low", "max", "min", "optimum", "value"])], ["object", /* @__PURE__ */ new Set(["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"])], ["ol", /* @__PURE__ */ new Set(["compact", "reversed", "start", "type"])], ["optgroup", /* @__PURE__ */ new Set(["disabled", "label"])], ["option", /* @__PURE__ */ new Set(["disabled", "label", "selected", "value"])], ["output", /* @__PURE__ */ new Set(["for", "form", "name"])], ["p", /* @__PURE__ */ new Set(["align"])], ["param", /* @__PURE__ */ new Set(["name", "type", "value", "valuetype"])], ["pre", /* @__PURE__ */ new Set(["width"])], ["progress", /* @__PURE__ */ new Set(["max", "value"])], ["q", /* @__PURE__ */ new Set(["cite"])], ["script", /* @__PURE__ */ new Set(["async", "blocking", "charset", "crossorigin", "defer", "fetchpriority", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"])], ["select", /* @__PURE__ */ new Set(["autocomplete", "disabled", "form", "multiple", "name", "required", "size"])], ["slot", /* @__PURE__ */ new Set(["name"])], ["source", /* @__PURE__ */ new Set(["height", "media", "sizes", "src", "srcset", "type", "width"])], ["style", /* @__PURE__ */ new Set(["blocking", "media", "type"])], ["table", /* @__PURE__ */ new Set(["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"])], ["tbody", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["td", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["template", /* @__PURE__ */ new Set(["shadowrootdelegatesfocus", "shadowrootmode"])], ["textarea", /* @__PURE__ */ new Set(["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"])], ["tfoot", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["th", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["thead", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["time", /* @__PURE__ */ new Set(["datetime"])], ["tr", /* @__PURE__ */ new Set(["align", "bgcolor", "char", "charoff", "valign"])], ["track", /* @__PURE__ */ new Set(["default", "kind", "label", "src", "srclang"])], ["ul", /* @__PURE__ */ new Set(["compact", "type"])], ["video", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"])]]), oS = /* @__PURE__ */ new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
function aS(t) {
  if (t.type === "block") {
    if (t.name = yt(!1, t.name.toLowerCase(), /\s+/g, " ").trim(), t.type = "angularControlFlowBlock", !zc(t.parameters)) {
      delete t.parameters;
      return;
    }
    for (let e of t.parameters)
      e.type = "angularControlFlowBlockParameter";
    t.parameters = { type: "angularControlFlowBlockParameters", children: t.parameters, sourceSpan: new ne(t.parameters[0].sourceSpan.start, ks(!1, t.parameters, -1).sourceSpan.end) };
  }
}
function lS(t) {
  (t.type === "plural" || t.type === "select") && (t.clause = t.type, t.type = "angularIcuExpression"), t.type === "expansionCase" && (t.type = "angularIcuCase");
}
function Ng(t, e, r) {
  let { name: n, canSelfClose: i = !0, normalizeTagName: s = !1, normalizeAttributeName: o = !1, allowHtmComponentClosingTags: a = !1, isTagNameCaseSensitive: l = !1, shouldParseAsRawText: c } = e, { rootNodes: u, errors: h } = Qf(t, { canSelfClose: i, allowHtmComponentClosingTags: a, isTagNameCaseSensitive: l, getTagContentType: c ? (...g) => c(...g) ? Rt.RAW_TEXT : void 0 : void 0, tokenizeAngularBlocks: n === "angular" ? !0 : void 0 });
  if (n === "vue") {
    if (u.some((D) => D.type === "docType" && D.value === "html" || D.type === "element" && D.name.toLowerCase() === "html"))
      return Ng(t, Ig, r);
    let g, b = () => g ?? (g = Qf(t, { canSelfClose: i, allowHtmComponentClosingTags: a, isTagNameCaseSensitive: l })), w = (D) => b().rootNodes.find(({ startSourceSpan: x }) => x && x.start.offset === D.startSourceSpan.start.offset) ?? D;
    for (let [D, x] of u.entries()) {
      let { endSourceSpan: C, startSourceSpan: k } = x;
      if (C === null)
        h = b().errors, u[D] = w(x);
      else if (uS(x, r)) {
        let S = b().errors.find((A) => A.span.start.offset > k.start.offset && A.span.start.offset < C.end.offset);
        S && ed(S), u[D] = w(x);
      }
    }
  }
  h.length > 0 && ed(h[0]);
  let f = (g) => {
    let b = g.name.startsWith(":") ? g.name.slice(1).split(":")[0] : null, w = g.nameSpan.toString(), D = b !== null && w.startsWith(`${b}:`), x = D ? w.slice(b.length + 1) : w;
    g.name = x, g.namespace = b, g.hasExplicitNamespace = D;
  }, d = (g) => {
    switch (g.type) {
      case "element":
        f(g);
        for (let b of g.attrs)
          f(b), b.valueSpan ? (b.value = b.valueSpan.toString(), /["']/.test(b.value[0]) && (b.value = b.value.slice(1, -1))) : b.value = null;
        break;
      case "comment":
        g.value = g.sourceSpan.toString().slice(4, -3);
        break;
      case "text":
        g.value = g.sourceSpan.toString();
        break;
    }
  }, p = (g, b) => {
    let w = g.toLowerCase();
    return b(w) ? w : g;
  }, m = (g) => {
    if (g.type === "element" && (s && (!g.namespace || g.namespace === g.tagDefinition.implicitNamespacePrefix || ns(g)) && (g.name = p(g.name, (b) => oS.has(b))), o))
      for (let b of g.attrs)
        b.namespace || (b.name = p(b.name, (w) => Cl.has(g.name) && (Cl.get("*").has(w) || Cl.get(g.name).has(w))));
  }, y = (g) => {
    g.sourceSpan && g.endSourceSpan && (g.sourceSpan = new ne(g.sourceSpan.start, g.endSourceSpan.end));
  }, v = (g) => {
    if (g.type === "element") {
      let b = du(l ? g.name : g.name.toLowerCase());
      !g.namespace || g.namespace === b.implicitNamespacePrefix || ns(g) ? g.tagDefinition = b : g.tagDefinition = du("");
    }
  };
  return _g(new class extends Ek {
    visitExpansionCase(g, b) {
      n === "angular" && this.visitChildren(b, (w) => {
        w(g.expression);
      });
    }
    visit(g) {
      d(g), v(g), m(g), y(g);
    }
  }(), u), u;
}
function uS(t, e) {
  var r;
  if (t.type !== "element" || t.name !== "template")
    return !1;
  let n = (r = t.attrs.find((i) => i.name === "lang")) == null ? void 0 : r.value;
  return !n || La(e, { language: n }) === "html";
}
function ed(t) {
  let { msg: e, span: { start: r, end: n } } = t;
  throw Yk(e, { loc: { start: { line: r.line + 1, column: r.col + 1 }, end: { line: n.line + 1, column: n.col + 1 } }, cause: t });
}
function Rg(t, e, r = {}, n = !0) {
  let { frontMatter: i, content: s } = n ? Qk(t) : { frontMatter: null, content: t }, o = new Eg(t, r.filepath), a = new fu(o, 0, 0, 0), l = a.moveBy(t.length), c = { type: "root", sourceSpan: new ne(a, l), children: Ng(s, e, r) };
  if (i) {
    let f = new fu(o, 0, 0, 0), d = f.moveBy(i.raw.length);
    i.sourceSpan = new ne(f, d), c.children.unshift(i);
  }
  let u = new Zk(c), h = (f, d) => {
    let { offset: p } = d, m = yt(!1, t.slice(0, p), /[^\n\r]/g, " "), y = Rg(m + f, e, r, !1);
    y.sourceSpan = new ne(d, ks(!1, y.children, -1).sourceSpan.end);
    let v = y.children[0];
    return v.length === p ? y.children.shift() : (v.sourceSpan = new ne(v.sourceSpan.start.moveBy(p), v.sourceSpan.end), v.value = v.value.slice(p)), y;
  };
  return u.walk((f) => {
    if (f.type === "comment") {
      let d = rS(f, h);
      d && f.parent.replaceChild(f, d);
    }
    aS(f), lS(f);
  }), u;
}
function qa(t) {
  return { parse: (e, r) => Rg(e, t, r), hasPragma: OC, astFormat: "html", locStart: Ra, locEnd: Ia };
}
var Ig = { name: "html", normalizeTagName: !0, normalizeAttributeName: !0, allowHtmComponentClosingTags: !0 }, cS = qa(Ig), hS = qa({ name: "angular" }), fS = qa({ name: "vue", isTagNameCaseSensitive: !0, shouldParseAsRawText(t, e, r, n) {
  return t.toLowerCase() !== "html" && !r && (t !== "template" || n.some(({ name: i, value: s }) => i === "lang" && s !== "html" && s !== "" && s !== void 0));
} }), dS = qa({ name: "lwc", canSelfClose: !1 }), pS = { html: ok }, mS = Km, gS = Object.create, Zc = Object.defineProperty, yS = Object.getOwnPropertyDescriptor, vS = Object.getOwnPropertyNames, bS = Object.getPrototypeOf, DS = Object.prototype.hasOwnProperty, R = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), $g = (t, e) => {
  for (var r in e)
    Zc(t, r, { get: e[r], enumerable: !0 });
}, wS = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of vS(e))
      !DS.call(t, i) && i !== r && Zc(t, i, { get: () => e[i], enumerable: !(n = yS(e, i)) || n.enumerable });
  return t;
}, Bn = (t, e, r) => (r = t != null ? gS(bS(t)) : {}, wS(e || !t || !t.__esModule ? Zc(r, "default", { value: t, enumerable: !0 }) : r, t)), xS = R((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = u, t.parse = f, t.parseWithComments = d, t.print = p, t.strip = h;
  var e = /\*\/$/, r = /^\/\*\*?/, n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, s = /^(\r?\n)+/, o = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, a = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, l = /(\r?\n|^) *\* ?/g, c = [];
  function u(y) {
    let v = y.match(n);
    return v ? v[0].trimLeft() : "";
  }
  function h(y) {
    let v = y.match(n);
    return v && v[0] ? y.substring(v[0].length) : y;
  }
  function f(y) {
    return d(y).pragmas;
  }
  function d(y) {
    let v = `
`;
    y = y.replace(r, "").replace(e, "").replace(l, "$1");
    let g = "";
    for (; g !== y; )
      g = y, y = y.replace(o, `${v}$1 $2${v}`);
    y = y.replace(s, "").trimRight();
    let b = /* @__PURE__ */ Object.create(null), w = y.replace(a, "").replace(s, "").trimRight(), D;
    for (; D = a.exec(y); ) {
      let x = D[2].replace(i, "");
      typeof b[D[1]] == "string" || Array.isArray(b[D[1]]) ? b[D[1]] = c.concat(b[D[1]], x) : b[D[1]] = x;
    }
    return { comments: w, pragmas: b };
  }
  function p({ comments: y = "", pragmas: v = {} }) {
    let g = `
`, b = "/**", w = " *", D = " */", x = Object.keys(v), C = x.flatMap((S) => m(S, v[S])).map((S) => `${w} ${S}${g}`).join("");
    if (!y) {
      if (x.length === 0)
        return "";
      if (x.length === 1 && !Array.isArray(v[x[0]])) {
        let S = v[x[0]];
        return `${b} ${m(x[0], S)[0]}${D}`;
      }
    }
    let k = y.split(g).map((S) => `${w} ${S}`).join(g) + g;
    return b + g + (y ? k : "") + (y && x.length ? w + g : "") + C + D;
  }
  function m(y, v) {
    return c.concat(v).map((g) => `@${y} ${g}`.trim());
  }
}), eh = R((t, e) => {
  e.exports.isClean = Symbol("isClean"), e.exports.my = Symbol("my");
}), CS = R((t, e) => {
  var r = String, n = function() {
    return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r };
  };
  e.exports = n(), e.exports.createColors = n;
}), jg = R(() => {
}), th = R((t, e) => {
  var r = CS(), n = jg(), i = class Wg extends Error {
    constructor(o, a, l, c, u, h) {
      super(o), this.name = "CssSyntaxError", this.reason = o, u && (this.file = u), c && (this.source = c), h && (this.plugin = h), typeof a < "u" && typeof l < "u" && (typeof a == "number" ? (this.line = a, this.column = l) : (this.line = a.line, this.column = a.column, this.endLine = l.line, this.endColumn = l.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, Wg);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(o) {
      if (!this.source)
        return "";
      let a = this.source;
      o == null && (o = r.isColorSupported), n && o && (a = n(a));
      let l = a.split(/\r?\n/), c = Math.max(this.line - 3, 0), u = Math.min(this.line + 2, l.length), h = String(u).length, f, d;
      if (o) {
        let { bold: p, gray: m, red: y } = r.createColors(!0);
        f = (v) => p(y(v)), d = (v) => m(v);
      } else
        f = d = (p) => p;
      return l.slice(c, u).map((p, m) => {
        let y = c + 1 + m, v = " " + (" " + y).slice(-h) + " | ";
        if (y === this.line) {
          let g = d(v.replace(/\d/g, " ")) + p.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return f(">") + d(v) + p + `
 ` + g + f("^");
        }
        return " " + d(v) + p;
      }).join(`
`);
    }
    toString() {
      let o = this.showSourceCode();
      return o && (o = `

` + o + `
`), this.name + ": " + this.message + o;
    }
  };
  e.exports = i, i.default = i;
}), rh = R((t, e) => {
  var r = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: !1 };
  function n(s) {
    return s[0].toUpperCase() + s.slice(1);
  }
  var i = class {
    constructor(s) {
      this.builder = s;
    }
    atrule(s, o) {
      let a = "@" + s.name, l = s.params ? this.rawValue(s, "params") : "";
      if (typeof s.raws.afterName < "u" ? a += s.raws.afterName : l && (a += " "), s.nodes)
        this.block(s, a + l);
      else {
        let c = (s.raws.between || "") + (o ? ";" : "");
        this.builder(a + l + c, s);
      }
    }
    beforeAfter(s, o) {
      let a;
      s.type === "decl" ? a = this.raw(s, null, "beforeDecl") : s.type === "comment" ? a = this.raw(s, null, "beforeComment") : o === "before" ? a = this.raw(s, null, "beforeRule") : a = this.raw(s, null, "beforeClose");
      let l = s.parent, c = 0;
      for (; l && l.type !== "root"; )
        c += 1, l = l.parent;
      if (a.includes(`
`)) {
        let u = this.raw(s, null, "indent");
        if (u.length)
          for (let h = 0; h < c; h++)
            a += u;
      }
      return a;
    }
    block(s, o) {
      let a = this.raw(s, "between", "beforeOpen");
      this.builder(o + a + "{", s, "start");
      let l;
      s.nodes && s.nodes.length ? (this.body(s), l = this.raw(s, "after")) : l = this.raw(s, "after", "emptyBody"), l && this.builder(l), this.builder("}", s, "end");
    }
    body(s) {
      let o = s.nodes.length - 1;
      for (; o > 0 && s.nodes[o].type === "comment"; )
        o -= 1;
      let a = this.raw(s, "semicolon");
      for (let l = 0; l < s.nodes.length; l++) {
        let c = s.nodes[l], u = this.raw(c, "before");
        u && this.builder(u), this.stringify(c, o !== l || a);
      }
    }
    comment(s) {
      let o = this.raw(s, "left", "commentLeft"), a = this.raw(s, "right", "commentRight");
      this.builder("/*" + o + s.text + a + "*/", s);
    }
    decl(s, o) {
      let a = this.raw(s, "between", "colon"), l = s.prop + a + this.rawValue(s, "value");
      s.important && (l += s.raws.important || " !important"), o && (l += ";"), this.builder(l, s);
    }
    document(s) {
      this.body(s);
    }
    raw(s, o, a) {
      let l;
      if (a || (a = o), o && (l = s.raws[o], typeof l < "u"))
        return l;
      let c = s.parent;
      if (a === "before" && (!c || c.type === "root" && c.first === s || c && c.type === "document"))
        return "";
      if (!c)
        return r[a];
      let u = s.root();
      if (u.rawCache || (u.rawCache = {}), typeof u.rawCache[a] < "u")
        return u.rawCache[a];
      if (a === "before" || a === "after")
        return this.beforeAfter(s, a);
      {
        let h = "raw" + n(a);
        this[h] ? l = this[h](u, s) : u.walk((f) => {
          if (l = f.raws[o], typeof l < "u")
            return !1;
        });
      }
      return typeof l > "u" && (l = r[a]), u.rawCache[a] = l, l;
    }
    rawBeforeClose(s) {
      let o;
      return s.walk((a) => {
        if (a.nodes && a.nodes.length > 0 && typeof a.raws.after < "u")
          return o = a.raws.after, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), !1;
      }), o && (o = o.replace(/\S/g, "")), o;
    }
    rawBeforeComment(s, o) {
      let a;
      return s.walkComments((l) => {
        if (typeof l.raws.before < "u")
          return a = l.raws.before, a.includes(`
`) && (a = a.replace(/[^\n]+$/, "")), !1;
      }), typeof a > "u" ? a = this.raw(o, null, "beforeDecl") : a && (a = a.replace(/\S/g, "")), a;
    }
    rawBeforeDecl(s, o) {
      let a;
      return s.walkDecls((l) => {
        if (typeof l.raws.before < "u")
          return a = l.raws.before, a.includes(`
`) && (a = a.replace(/[^\n]+$/, "")), !1;
      }), typeof a > "u" ? a = this.raw(o, null, "beforeRule") : a && (a = a.replace(/\S/g, "")), a;
    }
    rawBeforeOpen(s) {
      let o;
      return s.walk((a) => {
        if (a.type !== "decl" && (o = a.raws.between, typeof o < "u"))
          return !1;
      }), o;
    }
    rawBeforeRule(s) {
      let o;
      return s.walk((a) => {
        if (a.nodes && (a.parent !== s || s.first !== a) && typeof a.raws.before < "u")
          return o = a.raws.before, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), !1;
      }), o && (o = o.replace(/\S/g, "")), o;
    }
    rawColon(s) {
      let o;
      return s.walkDecls((a) => {
        if (typeof a.raws.between < "u")
          return o = a.raws.between.replace(/[^\s:]/g, ""), !1;
      }), o;
    }
    rawEmptyBody(s) {
      let o;
      return s.walk((a) => {
        if (a.nodes && a.nodes.length === 0 && (o = a.raws.after, typeof o < "u"))
          return !1;
      }), o;
    }
    rawIndent(s) {
      if (s.raws.indent)
        return s.raws.indent;
      let o;
      return s.walk((a) => {
        let l = a.parent;
        if (l && l !== s && l.parent && l.parent === s && typeof a.raws.before < "u") {
          let c = a.raws.before.split(`
`);
          return o = c[c.length - 1], o = o.replace(/\S/g, ""), !1;
        }
      }), o;
    }
    rawSemicolon(s) {
      let o;
      return s.walk((a) => {
        if (a.nodes && a.nodes.length && a.last.type === "decl" && (o = a.raws.semicolon, typeof o < "u"))
          return !1;
      }), o;
    }
    rawValue(s, o) {
      let a = s[o], l = s.raws[o];
      return l && l.value === a ? l.raw : a;
    }
    root(s) {
      this.body(s), s.raws.after && this.builder(s.raws.after);
    }
    rule(s) {
      this.block(s, this.rawValue(s, "selector")), s.raws.ownSemicolon && this.builder(s.raws.ownSemicolon, s, "end");
    }
    stringify(s, o) {
      if (!this[s.type])
        throw new Error("Unknown AST node type " + s.type + ". Maybe you need to change PostCSS stringifier.");
      this[s.type](s, o);
    }
  };
  e.exports = i, i.default = i;
}), Ha = R((t, e) => {
  var r = rh();
  function n(i, s) {
    new r(s).stringify(i);
  }
  e.exports = n, n.default = n;
}), Va = R((t, e) => {
  var { isClean: r, my: n } = eh(), i = th(), s = rh(), o = Ha();
  function a(c, u) {
    let h = new c.constructor();
    for (let f in c) {
      if (!Object.prototype.hasOwnProperty.call(c, f) || f === "proxyCache")
        continue;
      let d = c[f], p = typeof d;
      f === "parent" && p === "object" ? u && (h[f] = u) : f === "source" ? h[f] = d : Array.isArray(d) ? h[f] = d.map((m) => a(m, h)) : (p === "object" && d !== null && (d = a(d)), h[f] = d);
    }
    return h;
  }
  var l = class {
    constructor(c = {}) {
      this.raws = {}, this[r] = !1, this[n] = !0;
      for (let u in c)
        if (u === "nodes") {
          this.nodes = [];
          for (let h of c[u])
            typeof h.clone == "function" ? this.append(h.clone()) : this.append(h);
        } else
          this[u] = c[u];
    }
    addToError(c) {
      if (c.postcssNode = this, c.stack && this.source && /\n\s{4}at /.test(c.stack)) {
        let u = this.source;
        c.stack = c.stack.replace(/\n\s{4}at /, `$&${u.input.from}:${u.start.line}:${u.start.column}$&`);
      }
      return c;
    }
    after(c) {
      return this.parent.insertAfter(this, c), this;
    }
    assign(c = {}) {
      for (let u in c)
        this[u] = c[u];
      return this;
    }
    before(c) {
      return this.parent.insertBefore(this, c), this;
    }
    cleanRaws(c) {
      delete this.raws.before, delete this.raws.after, c || delete this.raws.between;
    }
    clone(c = {}) {
      let u = a(this);
      for (let h in c)
        u[h] = c[h];
      return u;
    }
    cloneAfter(c = {}) {
      let u = this.clone(c);
      return this.parent.insertAfter(this, u), u;
    }
    cloneBefore(c = {}) {
      let u = this.clone(c);
      return this.parent.insertBefore(this, u), u;
    }
    error(c, u = {}) {
      if (this.source) {
        let { end: h, start: f } = this.rangeBy(u);
        return this.source.input.error(c, { column: f.column, line: f.line }, { column: h.column, line: h.line }, u);
      }
      return new i(c);
    }
    getProxyProcessor() {
      return { get(c, u) {
        return u === "proxyOf" ? c : u === "root" ? () => c.root().toProxy() : c[u];
      }, set(c, u, h) {
        return c[u] === h || (c[u] = h, (u === "prop" || u === "value" || u === "name" || u === "params" || u === "important" || u === "text") && c.markDirty()), !0;
      } };
    }
    markDirty() {
      if (this[r]) {
        this[r] = !1;
        let c = this;
        for (; c = c.parent; )
          c[r] = !1;
      }
    }
    next() {
      if (!this.parent)
        return;
      let c = this.parent.index(this);
      return this.parent.nodes[c + 1];
    }
    positionBy(c, u) {
      let h = this.source.start;
      if (c.index)
        h = this.positionInside(c.index, u);
      else if (c.word) {
        u = this.toString();
        let f = u.indexOf(c.word);
        f !== -1 && (h = this.positionInside(f, u));
      }
      return h;
    }
    positionInside(c, u) {
      let h = u || this.toString(), f = this.source.start.column, d = this.source.start.line;
      for (let p = 0; p < c; p++)
        h[p] === `
` ? (f = 1, d += 1) : f += 1;
      return { column: f, line: d };
    }
    prev() {
      if (!this.parent)
        return;
      let c = this.parent.index(this);
      return this.parent.nodes[c - 1];
    }
    rangeBy(c) {
      let u = { column: this.source.start.column, line: this.source.start.line }, h = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: u.column + 1, line: u.line };
      if (c.word) {
        let f = this.toString(), d = f.indexOf(c.word);
        d !== -1 && (u = this.positionInside(d, f), h = this.positionInside(d + c.word.length, f));
      } else
        c.start ? u = { column: c.start.column, line: c.start.line } : c.index && (u = this.positionInside(c.index)), c.end ? h = { column: c.end.column, line: c.end.line } : c.endIndex ? h = this.positionInside(c.endIndex) : c.index && (h = this.positionInside(c.index + 1));
      return (h.line < u.line || h.line === u.line && h.column <= u.column) && (h = { column: u.column + 1, line: u.line }), { end: h, start: u };
    }
    raw(c, u) {
      return new s().raw(this, c, u);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith(...c) {
      if (this.parent) {
        let u = this, h = !1;
        for (let f of c)
          f === this ? h = !0 : h ? (this.parent.insertAfter(u, f), u = f) : this.parent.insertBefore(u, f);
        h || this.remove();
      }
      return this;
    }
    root() {
      let c = this;
      for (; c.parent && c.parent.type !== "document"; )
        c = c.parent;
      return c;
    }
    toJSON(c, u) {
      let h = {}, f = u == null;
      u = u || /* @__PURE__ */ new Map();
      let d = 0;
      for (let p in this) {
        if (!Object.prototype.hasOwnProperty.call(this, p) || p === "parent" || p === "proxyCache")
          continue;
        let m = this[p];
        if (Array.isArray(m))
          h[p] = m.map((y) => typeof y == "object" && y.toJSON ? y.toJSON(null, u) : y);
        else if (typeof m == "object" && m.toJSON)
          h[p] = m.toJSON(null, u);
        else if (p === "source") {
          let y = u.get(m.input);
          y == null && (y = d, u.set(m.input, d), d++), h[p] = { end: m.end, inputId: y, start: m.start };
        } else
          h[p] = m;
      }
      return f && (h.inputs = [...u.keys()].map((p) => p.toJSON())), h;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(c = o) {
      c.stringify && (c = c.stringify);
      let u = "";
      return c(this, (h) => {
        u += h;
      }), u;
    }
    warn(c, u, h) {
      let f = { node: this };
      for (let d in h)
        f[d] = h[d];
      return c.warn(u, f);
    }
    get proxyOf() {
      return this;
    }
  };
  e.exports = l, l.default = l;
}), za = R((t, e) => {
  var r = Va(), n = class extends r {
    constructor(i) {
      i && typeof i.value < "u" && typeof i.value != "string" && (i = { ...i, value: String(i.value) }), super(i), this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
  };
  e.exports = n, n.default = n;
}), Ts = R((t, e) => {
  var r = Va(), n = class extends r {
    constructor(i) {
      super(i), this.type = "comment";
    }
  };
  e.exports = n, n.default = n;
}), On = R((t, e) => {
  var { isClean: r, my: n } = eh(), i = za(), s = Ts(), o = Va(), a, l, c, u;
  function h(p) {
    return p.map((m) => (m.nodes && (m.nodes = h(m.nodes)), delete m.source, m));
  }
  function f(p) {
    if (p[r] = !1, p.proxyOf.nodes)
      for (let m of p.proxyOf.nodes)
        f(m);
  }
  var d = class qg extends o {
    append(...m) {
      for (let y of m) {
        let v = this.normalize(y, this.last);
        for (let g of v)
          this.proxyOf.nodes.push(g);
      }
      return this.markDirty(), this;
    }
    cleanRaws(m) {
      if (super.cleanRaws(m), this.nodes)
        for (let y of this.nodes)
          y.cleanRaws(m);
    }
    each(m) {
      if (!this.proxyOf.nodes)
        return;
      let y = this.getIterator(), v, g;
      for (; this.indexes[y] < this.proxyOf.nodes.length && (v = this.indexes[y], g = m(this.proxyOf.nodes[v], v), g !== !1); )
        this.indexes[y] += 1;
      return delete this.indexes[y], g;
    }
    every(m) {
      return this.nodes.every(m);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let m = this.lastEach;
      return this.indexes[m] = 0, m;
    }
    getProxyProcessor() {
      return { get(m, y) {
        return y === "proxyOf" ? m : m[y] ? y === "each" || typeof y == "string" && y.startsWith("walk") ? (...v) => m[y](...v.map((g) => typeof g == "function" ? (b, w) => g(b.toProxy(), w) : g)) : y === "every" || y === "some" ? (v) => m[y]((g, ...b) => v(g.toProxy(), ...b)) : y === "root" ? () => m.root().toProxy() : y === "nodes" ? m.nodes.map((v) => v.toProxy()) : y === "first" || y === "last" ? m[y].toProxy() : m[y] : m[y];
      }, set(m, y, v) {
        return m[y] === v || (m[y] = v, (y === "name" || y === "params" || y === "selector") && m.markDirty()), !0;
      } };
    }
    index(m) {
      return typeof m == "number" ? m : (m.proxyOf && (m = m.proxyOf), this.proxyOf.nodes.indexOf(m));
    }
    insertAfter(m, y) {
      let v = this.index(m), g = this.normalize(y, this.proxyOf.nodes[v]).reverse();
      v = this.index(m);
      for (let w of g)
        this.proxyOf.nodes.splice(v + 1, 0, w);
      let b;
      for (let w in this.indexes)
        b = this.indexes[w], v < b && (this.indexes[w] = b + g.length);
      return this.markDirty(), this;
    }
    insertBefore(m, y) {
      let v = this.index(m), g = v === 0 ? "prepend" : !1, b = this.normalize(y, this.proxyOf.nodes[v], g).reverse();
      v = this.index(m);
      for (let D of b)
        this.proxyOf.nodes.splice(v, 0, D);
      let w;
      for (let D in this.indexes)
        w = this.indexes[D], v <= w && (this.indexes[D] = w + b.length);
      return this.markDirty(), this;
    }
    normalize(m, y) {
      if (typeof m == "string")
        m = h(a(m).nodes);
      else if (Array.isArray(m)) {
        m = m.slice(0);
        for (let v of m)
          v.parent && v.parent.removeChild(v, "ignore");
      } else if (m.type === "root" && this.type !== "document") {
        m = m.nodes.slice(0);
        for (let v of m)
          v.parent && v.parent.removeChild(v, "ignore");
      } else if (m.type)
        m = [m];
      else if (m.prop) {
        if (typeof m.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof m.value != "string" && (m.value = String(m.value)), m = [new i(m)];
      } else if (m.selector)
        m = [new l(m)];
      else if (m.name)
        m = [new c(m)];
      else if (m.text)
        m = [new s(m)];
      else
        throw new Error("Unknown node type in node creation");
      return m.map((v) => (v[n] || qg.rebuild(v), v = v.proxyOf, v.parent && v.parent.removeChild(v), v[r] && f(v), typeof v.raws.before > "u" && y && typeof y.raws.before < "u" && (v.raws.before = y.raws.before.replace(/\S/g, "")), v.parent = this.proxyOf, v));
    }
    prepend(...m) {
      m = m.reverse();
      for (let y of m) {
        let v = this.normalize(y, this.first, "prepend").reverse();
        for (let g of v)
          this.proxyOf.nodes.unshift(g);
        for (let g in this.indexes)
          this.indexes[g] = this.indexes[g] + v.length;
      }
      return this.markDirty(), this;
    }
    push(m) {
      return m.parent = this, this.proxyOf.nodes.push(m), this;
    }
    removeAll() {
      for (let m of this.proxyOf.nodes)
        m.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(m) {
      m = this.index(m), this.proxyOf.nodes[m].parent = void 0, this.proxyOf.nodes.splice(m, 1);
      let y;
      for (let v in this.indexes)
        y = this.indexes[v], y >= m && (this.indexes[v] = y - 1);
      return this.markDirty(), this;
    }
    replaceValues(m, y, v) {
      return v || (v = y, y = {}), this.walkDecls((g) => {
        y.props && !y.props.includes(g.prop) || y.fast && !g.value.includes(y.fast) || (g.value = g.value.replace(m, v));
      }), this.markDirty(), this;
    }
    some(m) {
      return this.nodes.some(m);
    }
    walk(m) {
      return this.each((y, v) => {
        let g;
        try {
          g = m(y, v);
        } catch (b) {
          throw y.addToError(b);
        }
        return g !== !1 && y.walk && (g = y.walk(m)), g;
      });
    }
    walkAtRules(m, y) {
      return y ? m instanceof RegExp ? this.walk((v, g) => {
        if (v.type === "atrule" && m.test(v.name))
          return y(v, g);
      }) : this.walk((v, g) => {
        if (v.type === "atrule" && v.name === m)
          return y(v, g);
      }) : (y = m, this.walk((v, g) => {
        if (v.type === "atrule")
          return y(v, g);
      }));
    }
    walkComments(m) {
      return this.walk((y, v) => {
        if (y.type === "comment")
          return m(y, v);
      });
    }
    walkDecls(m, y) {
      return y ? m instanceof RegExp ? this.walk((v, g) => {
        if (v.type === "decl" && m.test(v.prop))
          return y(v, g);
      }) : this.walk((v, g) => {
        if (v.type === "decl" && v.prop === m)
          return y(v, g);
      }) : (y = m, this.walk((v, g) => {
        if (v.type === "decl")
          return y(v, g);
      }));
    }
    walkRules(m, y) {
      return y ? m instanceof RegExp ? this.walk((v, g) => {
        if (v.type === "rule" && m.test(v.selector))
          return y(v, g);
      }) : this.walk((v, g) => {
        if (v.type === "rule" && v.selector === m)
          return y(v, g);
      }) : (y = m, this.walk((v, g) => {
        if (v.type === "rule")
          return y(v, g);
      }));
    }
    get first() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
  };
  d.registerParse = (p) => {
    a = p;
  }, d.registerRule = (p) => {
    l = p;
  }, d.registerAtRule = (p) => {
    c = p;
  }, d.registerRoot = (p) => {
    u = p;
  }, e.exports = d, d.default = d, d.rebuild = (p) => {
    p.type === "atrule" ? Object.setPrototypeOf(p, c.prototype) : p.type === "rule" ? Object.setPrototypeOf(p, l.prototype) : p.type === "decl" ? Object.setPrototypeOf(p, i.prototype) : p.type === "comment" ? Object.setPrototypeOf(p, s.prototype) : p.type === "root" && Object.setPrototypeOf(p, u.prototype), p[n] = !0, p.nodes && p.nodes.forEach((m) => {
      d.rebuild(m);
    });
  };
}), nh = R((t, e) => {
  var r = /[\t\n\f\r "#'()/;[\\\]{}]/g, n = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, i = /.[\r\n"'(/\\]/, s = /[\da-f]/i;
  e.exports = function(o, a = {}) {
    let l = o.css.valueOf(), c = a.ignoreErrors, u, h, f, d, p, m, y, v, g, b, w = l.length, D = 0, x = [], C = [];
    function k() {
      return D;
    }
    function S($) {
      throw o.error("Unclosed " + $, D);
    }
    function A() {
      return C.length === 0 && D >= w;
    }
    function _($) {
      if (C.length)
        return C.pop();
      if (D >= w)
        return;
      let L = $ ? $.ignoreUnclosed : !1;
      switch (u = l.charCodeAt(D), u) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12: {
          h = D;
          do
            h += 1, u = l.charCodeAt(h);
          while (u === 32 || u === 10 || u === 9 || u === 13 || u === 12);
          b = ["space", l.slice(D, h)], D = h - 1;
          break;
        }
        case 91:
        case 93:
        case 123:
        case 125:
        case 58:
        case 59:
        case 41: {
          let I = String.fromCharCode(u);
          b = [I, I, D];
          break;
        }
        case 40: {
          if (v = x.length ? x.pop()[1] : "", g = l.charCodeAt(D + 1), v === "url" && g !== 39 && g !== 34 && g !== 32 && g !== 10 && g !== 9 && g !== 12 && g !== 13) {
            h = D;
            do {
              if (m = !1, h = l.indexOf(")", h + 1), h === -1)
                if (c || L) {
                  h = D;
                  break;
                } else
                  S("bracket");
              for (y = h; l.charCodeAt(y - 1) === 92; )
                y -= 1, m = !m;
            } while (m);
            b = ["brackets", l.slice(D, h + 1), D, h], D = h;
          } else
            h = l.indexOf(")", D + 1), d = l.slice(D, h + 1), h === -1 || i.test(d) ? b = ["(", "(", D] : (b = ["brackets", d, D, h], D = h);
          break;
        }
        case 39:
        case 34: {
          f = u === 39 ? "'" : '"', h = D;
          do {
            if (m = !1, h = l.indexOf(f, h + 1), h === -1)
              if (c || L) {
                h = D + 1;
                break;
              } else
                S("string");
            for (y = h; l.charCodeAt(y - 1) === 92; )
              y -= 1, m = !m;
          } while (m);
          b = ["string", l.slice(D, h + 1), D, h], D = h;
          break;
        }
        case 64: {
          r.lastIndex = D + 1, r.test(l), r.lastIndex === 0 ? h = l.length - 1 : h = r.lastIndex - 2, b = ["at-word", l.slice(D, h + 1), D, h], D = h;
          break;
        }
        case 92: {
          for (h = D, p = !0; l.charCodeAt(h + 1) === 92; )
            h += 1, p = !p;
          if (u = l.charCodeAt(h + 1), p && u !== 47 && u !== 32 && u !== 10 && u !== 9 && u !== 13 && u !== 12 && (h += 1, s.test(l.charAt(h)))) {
            for (; s.test(l.charAt(h + 1)); )
              h += 1;
            l.charCodeAt(h + 1) === 32 && (h += 1);
          }
          b = ["word", l.slice(D, h + 1), D, h], D = h;
          break;
        }
        default: {
          u === 47 && l.charCodeAt(D + 1) === 42 ? (h = l.indexOf("*/", D + 2) + 1, h === 0 && (c || L ? h = l.length : S("comment")), b = ["comment", l.slice(D, h + 1), D, h], D = h) : (n.lastIndex = D + 1, n.test(l), n.lastIndex === 0 ? h = l.length - 1 : h = n.lastIndex - 2, b = ["word", l.slice(D, h + 1), D, h], x.push(b), D = h);
          break;
        }
      }
      return D++, b;
    }
    function N($) {
      C.push($);
    }
    return { back: N, endOfFile: A, nextToken: _, position: k };
  };
}), ih = R((t, e) => {
  var r = On(), n = class extends r {
    constructor(i) {
      super(i), this.type = "atrule";
    }
    append(...i) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...i);
    }
    prepend(...i) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...i);
    }
  };
  e.exports = n, n.default = n, r.registerAtRule(n);
}), _s = R((t, e) => {
  var r = On(), n, i, s = class extends r {
    constructor(o) {
      super(o), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(o, a, l) {
      let c = super.normalize(o);
      if (a) {
        if (l === "prepend")
          this.nodes.length > 1 ? a.raws.before = this.nodes[1].raws.before : delete a.raws.before;
        else if (this.first !== a)
          for (let u of c)
            u.raws.before = a.raws.before;
      }
      return c;
    }
    removeChild(o, a) {
      let l = this.index(o);
      return !a && l === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[l].raws.before), super.removeChild(o);
    }
    toResult(o = {}) {
      return new n(new i(), this, o).stringify();
    }
  };
  s.registerLazyResult = (o) => {
    n = o;
  }, s.registerProcessor = (o) => {
    i = o;
  }, e.exports = s, s.default = s, r.registerRoot(s);
}), Hg = R((t, e) => {
  var r = { comma(n) {
    return r.split(n, [","], !0);
  }, space(n) {
    let i = [" ", `
`, "	"];
    return r.split(n, i);
  }, split(n, i, s) {
    let o = [], a = "", l = !1, c = 0, u = !1, h = "", f = !1;
    for (let d of n)
      f ? f = !1 : d === "\\" ? f = !0 : u ? d === h && (u = !1) : d === '"' || d === "'" ? (u = !0, h = d) : d === "(" ? c += 1 : d === ")" ? c > 0 && (c -= 1) : c === 0 && i.includes(d) && (l = !0), l ? (a !== "" && o.push(a.trim()), a = "", l = !1) : a += d;
    return (s || a !== "") && o.push(a.trim()), o;
  } };
  e.exports = r, r.default = r;
}), sh = R((t, e) => {
  var r = On(), n = Hg(), i = class extends r {
    constructor(s) {
      super(s), this.type = "rule", this.nodes || (this.nodes = []);
    }
    get selectors() {
      return n.comma(this.selector);
    }
    set selectors(s) {
      let o = this.selector ? this.selector.match(/,\s*/) : null, a = o ? o[0] : "," + this.raw("between", "beforeOpen");
      this.selector = s.join(a);
    }
  };
  e.exports = i, i.default = i, r.registerRule(i);
}), oh = R((t, e) => {
  var r = za(), n = nh(), i = Ts(), s = ih(), o = _s(), a = sh(), l = { empty: !0, space: !0 };
  function c(h) {
    for (let f = h.length - 1; f >= 0; f--) {
      let d = h[f], p = d[3] || d[2];
      if (p)
        return p;
    }
  }
  var u = class {
    constructor(h) {
      this.input = h, this.root = new o(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.customProperty = !1, this.createTokenizer(), this.root.source = { input: h, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(h) {
      let f = new s();
      f.name = h[1].slice(1), f.name === "" && this.unnamedAtrule(f, h), this.init(f, h[2]);
      let d, p, m, y = !1, v = !1, g = [], b = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (h = this.tokenizer.nextToken(), d = h[0], d === "(" || d === "[" ? b.push(d === "(" ? ")" : "]") : d === "{" && b.length > 0 ? b.push("}") : d === b[b.length - 1] && b.pop(), b.length === 0)
          if (d === ";") {
            f.source.end = this.getPosition(h[2]), f.source.end.offset++, this.semicolon = !0;
            break;
          } else if (d === "{") {
            v = !0;
            break;
          } else if (d === "}") {
            if (g.length > 0) {
              for (m = g.length - 1, p = g[m]; p && p[0] === "space"; )
                p = g[--m];
              p && (f.source.end = this.getPosition(p[3] || p[2]), f.source.end.offset++);
            }
            this.end(h);
            break;
          } else
            g.push(h);
        else
          g.push(h);
        if (this.tokenizer.endOfFile()) {
          y = !0;
          break;
        }
      }
      f.raws.between = this.spacesAndCommentsFromEnd(g), g.length ? (f.raws.afterName = this.spacesAndCommentsFromStart(g), this.raw(f, "params", g), y && (h = g[g.length - 1], f.source.end = this.getPosition(h[3] || h[2]), f.source.end.offset++, this.spaces = f.raws.between, f.raws.between = "")) : (f.raws.afterName = "", f.params = ""), v && (f.nodes = [], this.current = f);
    }
    checkMissedSemicolon(h) {
      let f = this.colon(h);
      if (f === !1)
        return;
      let d = 0, p;
      for (let m = f - 1; m >= 0 && (p = h[m], !(p[0] !== "space" && (d += 1, d === 2))); m--)
        ;
      throw this.input.error("Missed semicolon", p[0] === "word" ? p[3] + 1 : p[2]);
    }
    colon(h) {
      let f = 0, d, p, m;
      for (let [y, v] of h.entries()) {
        if (d = v, p = d[0], p === "(" && (f += 1), p === ")" && (f -= 1), f === 0 && p === ":")
          if (!m)
            this.doubleColon(d);
          else {
            if (m[0] === "word" && m[1] === "progid")
              continue;
            return y;
          }
        m = d;
      }
      return !1;
    }
    comment(h) {
      let f = new i();
      this.init(f, h[2]), f.source.end = this.getPosition(h[3] || h[2]), f.source.end.offset++;
      let d = h[1].slice(2, -2);
      if (/^\s*$/.test(d))
        f.text = "", f.raws.left = d, f.raws.right = "";
      else {
        let p = d.match(/^(\s*)([^]*\S)(\s*)$/);
        f.text = p[2], f.raws.left = p[1], f.raws.right = p[3];
      }
    }
    createTokenizer() {
      this.tokenizer = n(this.input);
    }
    decl(h, f) {
      let d = new r();
      this.init(d, h[0][2]);
      let p = h[h.length - 1];
      for (p[0] === ";" && (this.semicolon = !0, h.pop()), d.source.end = this.getPosition(p[3] || p[2] || c(h)), d.source.end.offset++; h[0][0] !== "word"; )
        h.length === 1 && this.unknownWord(h), d.raws.before += h.shift()[1];
      for (d.source.start = this.getPosition(h[0][2]), d.prop = ""; h.length; ) {
        let g = h[0][0];
        if (g === ":" || g === "space" || g === "comment")
          break;
        d.prop += h.shift()[1];
      }
      d.raws.between = "";
      let m;
      for (; h.length; )
        if (m = h.shift(), m[0] === ":") {
          d.raws.between += m[1];
          break;
        } else
          m[0] === "word" && /\w/.test(m[1]) && this.unknownWord([m]), d.raws.between += m[1];
      (d.prop[0] === "_" || d.prop[0] === "*") && (d.raws.before += d.prop[0], d.prop = d.prop.slice(1));
      let y = [], v;
      for (; h.length && (v = h[0][0], !(v !== "space" && v !== "comment")); )
        y.push(h.shift());
      this.precheckMissedSemicolon(h);
      for (let g = h.length - 1; g >= 0; g--) {
        if (m = h[g], m[1].toLowerCase() === "!important") {
          d.important = !0;
          let b = this.stringFrom(h, g);
          b = this.spacesFromEnd(h) + b, b !== " !important" && (d.raws.important = b);
          break;
        } else if (m[1].toLowerCase() === "important") {
          let b = h.slice(0), w = "";
          for (let D = g; D > 0; D--) {
            let x = b[D][0];
            if (w.trim().indexOf("!") === 0 && x !== "space")
              break;
            w = b.pop()[1] + w;
          }
          w.trim().indexOf("!") === 0 && (d.important = !0, d.raws.important = w, h = b);
        }
        if (m[0] !== "space" && m[0] !== "comment")
          break;
      }
      h.some((g) => g[0] !== "space" && g[0] !== "comment") && (d.raws.between += y.map((g) => g[1]).join(""), y = []), this.raw(d, "value", y.concat(h), f), d.value.includes(":") && !f && this.checkMissedSemicolon(h);
    }
    doubleColon(h) {
      throw this.input.error("Double colon", { offset: h[2] }, { offset: h[2] + h[1].length });
    }
    emptyRule(h) {
      let f = new a();
      this.init(f, h[2]), f.selector = "", f.raws.between = "", this.current = f;
    }
    end(h) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(h[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(h);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(h) {
      if (this.spaces += h[1], this.current.nodes) {
        let f = this.current.nodes[this.current.nodes.length - 1];
        f && f.type === "rule" && !f.raws.ownSemicolon && (f.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }
    getPosition(h) {
      let f = this.input.fromOffset(h);
      return { column: f.col, line: f.line, offset: h };
    }
    init(h, f) {
      this.current.push(h), h.source = { input: this.input, start: this.getPosition(f) }, h.raws.before = this.spaces, this.spaces = "", h.type !== "comment" && (this.semicolon = !1);
    }
    other(h) {
      let f = !1, d = null, p = !1, m = null, y = [], v = h[1].startsWith("--"), g = [], b = h;
      for (; b; ) {
        if (d = b[0], g.push(b), d === "(" || d === "[")
          m || (m = b), y.push(d === "(" ? ")" : "]");
        else if (v && p && d === "{")
          m || (m = b), y.push("}");
        else if (y.length === 0)
          if (d === ";")
            if (p) {
              this.decl(g, v);
              return;
            } else
              break;
          else if (d === "{") {
            this.rule(g);
            return;
          } else if (d === "}") {
            this.tokenizer.back(g.pop()), f = !0;
            break;
          } else
            d === ":" && (p = !0);
        else
          d === y[y.length - 1] && (y.pop(), y.length === 0 && (m = null));
        b = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (f = !0), y.length > 0 && this.unclosedBracket(m), f && p) {
        if (!v)
          for (; g.length && (b = g[g.length - 1][0], !(b !== "space" && b !== "comment")); )
            this.tokenizer.back(g.pop());
        this.decl(g, v);
      } else
        this.unknownWord(g);
    }
    parse() {
      let h;
      for (; !this.tokenizer.endOfFile(); )
        switch (h = this.tokenizer.nextToken(), h[0]) {
          case "space":
            this.spaces += h[1];
            break;
          case ";":
            this.freeSemicolon(h);
            break;
          case "}":
            this.end(h);
            break;
          case "comment":
            this.comment(h);
            break;
          case "at-word":
            this.atrule(h);
            break;
          case "{":
            this.emptyRule(h);
            break;
          default:
            this.other(h);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(h, f, d, p) {
      let m, y, v = d.length, g = "", b = !0, w, D;
      for (let x = 0; x < v; x += 1)
        m = d[x], y = m[0], y === "space" && x === v - 1 && !p ? b = !1 : y === "comment" ? (D = d[x - 1] ? d[x - 1][0] : "empty", w = d[x + 1] ? d[x + 1][0] : "empty", !l[D] && !l[w] ? g.slice(-1) === "," ? b = !1 : g += m[1] : b = !1) : g += m[1];
      if (!b) {
        let x = d.reduce((C, k) => C + k[1], "");
        h.raws[f] = { raw: x, value: g };
      }
      h[f] = g;
    }
    rule(h) {
      h.pop();
      let f = new a();
      this.init(f, h[0][2]), f.raws.between = this.spacesAndCommentsFromEnd(h), this.raw(f, "selector", h), this.current = f;
    }
    spacesAndCommentsFromEnd(h) {
      let f, d = "";
      for (; h.length && (f = h[h.length - 1][0], !(f !== "space" && f !== "comment")); )
        d = h.pop()[1] + d;
      return d;
    }
    spacesAndCommentsFromStart(h) {
      let f, d = "";
      for (; h.length && (f = h[0][0], !(f !== "space" && f !== "comment")); )
        d += h.shift()[1];
      return d;
    }
    spacesFromEnd(h) {
      let f, d = "";
      for (; h.length && (f = h[h.length - 1][0], f === "space"); )
        d = h.pop()[1] + d;
      return d;
    }
    stringFrom(h, f) {
      let d = "";
      for (let p = f; p < h.length; p++)
        d += h[p][1];
      return h.splice(f, h.length - f), d;
    }
    unclosedBlock() {
      let h = this.current.source.start;
      throw this.input.error("Unclosed block", h.line, h.column);
    }
    unclosedBracket(h) {
      throw this.input.error("Unclosed bracket", { offset: h[2] }, { offset: h[2] + 1 });
    }
    unexpectedClose(h) {
      throw this.input.error("Unexpected }", { offset: h[2] }, { offset: h[2] + 1 });
    }
    unknownWord(h) {
      throw this.input.error("Unknown word", { offset: h[0][2] }, { offset: h[0][2] + h[0][1].length });
    }
    unnamedAtrule(h, f) {
      throw this.input.error("At-rule without name", { offset: f[2] }, { offset: f[2] + f[1].length });
    }
  };
  e.exports = u;
}), kS = R(() => {
}), SS = R((t, e) => {
  var r = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", n = (s, o = 21) => (a = o) => {
    let l = "", c = a;
    for (; c--; )
      l += s[Math.random() * s.length | 0];
    return l;
  }, i = (s = 21) => {
    let o = "", a = s;
    for (; a--; )
      o += r[Math.random() * 64 | 0];
    return o;
  };
  e.exports = { nanoid: i, customAlphabet: n };
}), Vg = R((t, e) => {
  e.exports = class {
  };
}), Bs = R((t, e) => {
  var { SourceMapConsumer: r, SourceMapGenerator: n } = kS(), { fileURLToPath: i, pathToFileURL: s } = {}, { isAbsolute: o, resolve: a } = {}, { nanoid: l } = SS(), c = jg(), u = th(), h = Vg(), f = Symbol("fromOffsetCache"), d = !!(r && n), p = !!(a && o), m = class {
    constructor(y, v = {}) {
      if (y === null || typeof y > "u" || typeof y == "object" && !y.toString)
        throw new Error(`PostCSS received ${y} instead of CSS string`);
      if (this.css = y.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, v.from && (!p || /^\w+:\/\//.test(v.from) || o(v.from) ? this.file = v.from : this.file = a(v.from)), p && d) {
        let g = new h(this.css, v);
        if (g.text) {
          this.map = g;
          let b = g.consumer().file;
          !this.file && b && (this.file = this.mapResolve(b));
        }
      }
      this.file || (this.id = "<input css " + l(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(y, v, g, b = {}) {
      let w, D, x;
      if (v && typeof v == "object") {
        let k = v, S = g;
        if (typeof k.offset == "number") {
          let A = this.fromOffset(k.offset);
          v = A.line, g = A.col;
        } else
          v = k.line, g = k.column;
        if (typeof S.offset == "number") {
          let A = this.fromOffset(S.offset);
          D = A.line, x = A.col;
        } else
          D = S.line, x = S.column;
      } else if (!g) {
        let k = this.fromOffset(v);
        v = k.line, g = k.col;
      }
      let C = this.origin(v, g, D, x);
      return C ? w = new u(y, C.endLine === void 0 ? C.line : { column: C.column, line: C.line }, C.endLine === void 0 ? C.column : { column: C.endColumn, line: C.endLine }, C.source, C.file, b.plugin) : w = new u(y, D === void 0 ? v : { column: g, line: v }, D === void 0 ? g : { column: x, line: D }, this.css, this.file, b.plugin), w.input = { column: g, endColumn: x, endLine: D, line: v, source: this.css }, this.file && (s && (w.input.url = s(this.file).toString()), w.input.file = this.file), w;
    }
    fromOffset(y) {
      let v, g;
      if (this[f])
        g = this[f];
      else {
        let w = this.css.split(`
`);
        g = new Array(w.length);
        let D = 0;
        for (let x = 0, C = w.length; x < C; x++)
          g[x] = D, D += w[x].length + 1;
        this[f] = g;
      }
      v = g[g.length - 1];
      let b = 0;
      if (y >= v)
        b = g.length - 1;
      else {
        let w = g.length - 2, D;
        for (; b < w; )
          if (D = b + (w - b >> 1), y < g[D])
            w = D - 1;
          else if (y >= g[D + 1])
            b = D + 1;
          else {
            b = D;
            break;
          }
      }
      return { col: y - g[b] + 1, line: b + 1 };
    }
    mapResolve(y) {
      return /^\w+:\/\//.test(y) ? y : a(this.map.consumer().sourceRoot || this.map.root || ".", y);
    }
    origin(y, v, g, b) {
      if (!this.map)
        return !1;
      let w = this.map.consumer(), D = w.originalPositionFor({ column: v, line: y });
      if (!D.source)
        return !1;
      let x;
      typeof g == "number" && (x = w.originalPositionFor({ column: b, line: g }));
      let C;
      o(D.source) ? C = s(D.source) : C = new URL(D.source, this.map.consumer().sourceRoot || s(this.map.mapFile));
      let k = { column: D.column, endColumn: x && x.column, endLine: x && x.line, line: D.line, url: C.toString() };
      if (C.protocol === "file:")
        if (i)
          k.file = i(C);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let S = w.sourceContentFor(D.source);
      return S && (k.source = S), k;
    }
    toJSON() {
      let y = {};
      for (let v of ["hasBOM", "css", "file", "id"])
        this[v] != null && (y[v] = this[v]);
      return this.map && (y.map = { ...this.map }, y.map.consumerCache && (y.map.consumerCache = void 0)), y;
    }
    get from() {
      return this.file || this.id;
    }
  };
  e.exports = m, m.default = m, c && c.registerInput && c.registerInput(m);
}), Ua = R((t, e) => {
  var r = On(), n = oh(), i = Bs();
  function s(o, a) {
    let l = new i(o, a), c = new n(l);
    try {
      c.parse();
    } catch (u) {
      throw u;
    }
    return c.root;
  }
  e.exports = s, s.default = s, r.registerParse(s);
}), ES = R((t, e) => {
  var r = nh(), n = Bs();
  e.exports = { isInlineComment(i) {
    if (i[0] === "word" && i[1].slice(0, 2) === "//") {
      let s = i, o = [], a, l;
      for (; i; ) {
        if (/\r?\n/.test(i[1])) {
          if (/['"].*\r?\n/.test(i[1])) {
            o.push(i[1].substring(0, i[1].indexOf(`
`))), l = i[1].substring(i[1].indexOf(`
`));
            let u = this.input.css.valueOf().substring(this.tokenizer.position());
            l += u, a = i[3] + u.length - l.length;
          } else
            this.tokenizer.back(i);
          break;
        }
        o.push(i[1]), a = i[2], i = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
      }
      let c = ["comment", o.join(""), s[2], a];
      return this.inlineComment(c), l && (this.input = new n(l), this.tokenizer = r(this.input)), !0;
    } else if (i[1] === "/") {
      let s = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
      if (s[0] === "comment" && /^\/\*/.test(s[1]))
        return s[0] = "word", s[1] = s[1].slice(1), i[1] = "//", this.tokenizer.back(s), e.exports.isInlineComment.bind(this)(i);
    }
    return !1;
  } };
}), AS = R((t, e) => {
  e.exports = { interpolation(r) {
    let n = [r, this.tokenizer.nextToken()], i = ["word", "}"];
    if (n[0][1].length > 1 || n[1][0] !== "{")
      return this.tokenizer.back(n[1]), !1;
    for (r = this.tokenizer.nextToken(); r && i.includes(r[0]); )
      n.push(r), r = this.tokenizer.nextToken();
    let s = n.map((c) => c[1]), [o] = n, a = n.pop(), l = ["word", s.join(""), o[2], a[2]];
    return this.tokenizer.back(r), this.tokenizer.back(l), !0;
  } };
}), FS = R((t, e) => {
  var r = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, n = /\.[0-9]/, i = (s) => {
    let [, o] = s, [a] = o;
    return (a === "." || a === "#") && r.test(o) === !1 && n.test(o) === !1;
  };
  e.exports = { isMixinToken: i };
}), TS = R((t, e) => {
  var r = nh(), n = /^url\((.+)\)/;
  e.exports = (i) => {
    let { name: s, params: o = "" } = i;
    if (s === "import" && o.length) {
      i.import = !0;
      let a = r({ css: o });
      for (i.filename = o.replace(n, "$1"); !a.endOfFile(); ) {
        let [l, c] = a.nextToken();
        if (l === "word" && c === "url")
          return;
        if (l === "brackets") {
          i.options = c, i.filename = o.replace(c, "").trim();
          break;
        }
      }
    }
  };
}), _S = R((t, e) => {
  var r = /:$/, n = /^:(\s+)?/;
  e.exports = (i) => {
    let { name: s, params: o = "" } = i;
    if (i.name.slice(-1) === ":") {
      if (r.test(s)) {
        let [a] = s.match(r);
        i.name = s.replace(a, ""), i.raws.afterName = a + (i.raws.afterName || ""), i.variable = !0, i.value = i.params;
      }
      if (n.test(o)) {
        let [a] = o.match(n);
        i.value = o.replace(a, ""), i.raws.afterName = (i.raws.afterName || "") + a, i.variable = !0;
      }
    }
  };
}), BS = R((t, e) => {
  var r = Ts(), n = oh(), { isInlineComment: i } = ES(), { interpolation: s } = AS(), { isMixinToken: o } = FS(), a = TS(), l = _S(), c = /(!\s*important)$/i;
  e.exports = class extends n {
    constructor(...u) {
      super(...u), this.lastNode = null;
    }
    atrule(u) {
      s.bind(this)(u) || (super.atrule(u), a(this.lastNode), l(this.lastNode));
    }
    decl(...u) {
      super.decl(...u), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = !0);
    }
    each(u) {
      u[0][1] = ` ${u[0][1]}`;
      let h = u.findIndex((m) => m[0] === "("), f = u.reverse().find((m) => m[0] === ")"), d = u.reverse().indexOf(f), p = u.splice(h, d).map((m) => m[1]).join("");
      for (let m of u.reverse())
        this.tokenizer.back(m);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.function = !0, this.lastNode.params = p;
    }
    init(u, h, f) {
      super.init(u, h, f), this.lastNode = u;
    }
    inlineComment(u) {
      let h = new r(), f = u[1].slice(2);
      if (this.init(h, u[2]), h.source.end = this.getPosition(u[3] || u[2]), h.inline = !0, h.raws.begin = "//", /^\s*$/.test(f))
        h.text = "", h.raws.left = f, h.raws.right = "";
      else {
        let d = f.match(/^(\s*)([^]*[^\s])(\s*)$/);
        [, h.raws.left, h.text, h.raws.right] = d;
      }
    }
    mixin(u) {
      let [h] = u, f = h[1].slice(0, 1), d = u.findIndex((g) => g[0] === "brackets"), p = u.findIndex((g) => g[0] === "("), m = "";
      if ((d < 0 || d > 3) && p > 0) {
        let g = u.reduce((_, N, $) => N[0] === ")" ? $ : _), b = u.slice(p, g + p).map((_) => _[1]).join(""), [w] = u.slice(p), D = [w[2], w[3]], [x] = u.slice(g, g + 1), C = [x[2], x[3]], k = ["brackets", b].concat(D, C), S = u.slice(0, p), A = u.slice(g + 1);
        u = S, u.push(k), u = u.concat(A);
      }
      let y = [];
      for (let g of u)
        if ((g[1] === "!" || y.length) && y.push(g), g[1] === "important")
          break;
      if (y.length) {
        let [g] = y, b = u.indexOf(g), w = y[y.length - 1], D = [g[2], g[3]], x = [w[4], w[5]], C = ["word", y.map((k) => k[1]).join("")].concat(D, x);
        u.splice(b, y.length, C);
      }
      let v = u.findIndex((g) => c.test(g[1]));
      v > 0 && ([, m] = u[v], u.splice(v, 1));
      for (let g of u.reverse())
        this.tokenizer.back(g);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = !0, this.lastNode.raws.identifier = f, m && (this.lastNode.important = !0, this.lastNode.raws.important = m);
    }
    other(u) {
      i.bind(this)(u) || super.other(u);
    }
    rule(u) {
      let h = u[u.length - 1], f = u[u.length - 2];
      if (f[0] === "at-word" && h[0] === "{" && (this.tokenizer.back(h), s.bind(this)(f))) {
        let d = this.tokenizer.nextToken();
        u = u.slice(0, u.length - 2).concat([d]);
        for (let p of u.reverse())
          this.tokenizer.back(p);
        return;
      }
      super.rule(u), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = !0);
    }
    unknownWord(u) {
      let [h] = u;
      if (u[0][1] === "each" && u[1][0] === "(") {
        this.each(u);
        return;
      }
      if (o(h)) {
        this.mixin(u);
        return;
      }
      super.unknownWord(u);
    }
  };
}), OS = R((t, e) => {
  var r = rh();
  e.exports = class extends r {
    atrule(n, i) {
      if (!n.mixin && !n.variable && !n.function) {
        super.atrule(n, i);
        return;
      }
      let s = `${n.function ? "" : n.raws.identifier || "@"}${n.name}`, o = n.params ? this.rawValue(n, "params") : "", a = n.raws.important || "";
      if (n.variable && (o = n.value), typeof n.raws.afterName < "u" ? s += n.raws.afterName : o && (s += " "), n.nodes)
        this.block(n, s + o + a);
      else {
        let l = (n.raws.between || "") + a + (i ? ";" : "");
        this.builder(s + o + l, n);
      }
    }
    comment(n) {
      if (n.inline) {
        let i = this.raw(n, "left", "commentLeft"), s = this.raw(n, "right", "commentRight");
        this.builder(`//${i}${n.text}${s}`, n);
      } else
        super.comment(n);
    }
  };
}), MS = R((t, e) => {
  var r = Bs(), n = BS(), i = OS();
  e.exports = { parse(s, o) {
    let a = new r(s, o), l = new n(a);
    return l.parse(), l.root.walk((c) => {
      let u = a.css.lastIndexOf(c.source.input.css);
      if (u === 0)
        return;
      if (u + c.source.input.css.length !== a.css.length)
        throw new Error("Invalid state detected in postcss-less");
      let h = u + c.source.start.offset, f = a.fromOffset(u + c.source.start.offset);
      if (c.source.start = { offset: h, line: f.line, column: f.col }, c.source.end) {
        let d = u + c.source.end.offset, p = a.fromOffset(u + c.source.end.offset);
        c.source.end = { offset: d, line: p.line, column: p.col };
      }
    }), l.root;
  }, stringify(s, o) {
    new i(o).stringify(s);
  }, nodeToString(s) {
    let o = "";
    return e.exports.stringify(s, (a) => {
      o += a;
    }), o;
  } };
}), zg = R((t, e) => {
  e.exports = class {
    generate() {
    }
  };
}), ah = R((t, e) => {
  var r = On(), n, i, s = class extends r {
    constructor(o) {
      super({ type: "document", ...o }), this.nodes || (this.nodes = []);
    }
    toResult(o = {}) {
      return new n(new i(), this, o).stringify();
    }
  };
  s.registerLazyResult = (o) => {
    n = o;
  }, s.registerProcessor = (o) => {
    i = o;
  }, e.exports = s, s.default = s;
}), Ug = R((t, e) => {
  var r = {};
  e.exports = function(n) {
    r[n] || (r[n] = !0, typeof console < "u" && console.warn && console.warn(n));
  };
}), Gg = R((t, e) => {
  var r = class {
    constructor(n, i = {}) {
      if (this.type = "warning", this.text = n, i.node && i.node.source) {
        let s = i.node.rangeBy(i);
        this.line = s.start.line, this.column = s.start.column, this.endLine = s.end.line, this.endColumn = s.end.column;
      }
      for (let s in i)
        this[s] = i[s];
    }
    toString() {
      return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  };
  e.exports = r, r.default = r;
}), lh = R((t, e) => {
  var r = Gg(), n = class {
    constructor(i, s, o) {
      this.processor = i, this.messages = [], this.root = s, this.opts = o, this.css = void 0, this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(i, s = {}) {
      s.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (s.plugin = this.lastPlugin.postcssPlugin);
      let o = new r(i, s);
      return this.messages.push(o), o;
    }
    warnings() {
      return this.messages.filter((i) => i.type === "warning");
    }
    get content() {
      return this.css;
    }
  };
  e.exports = n, n.default = n;
}), Kg = R((t, e) => {
  var { isClean: r, my: n } = eh(), i = zg(), s = Ha(), o = On(), a = ah();
  Ug();
  var l = lh(), c = Ua(), u = _s(), h = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, f = { AtRule: !0, AtRuleExit: !0, Comment: !0, CommentExit: !0, Declaration: !0, DeclarationExit: !0, Document: !0, DocumentExit: !0, Once: !0, OnceExit: !0, postcssPlugin: !0, prepare: !0, Root: !0, RootExit: !0, Rule: !0, RuleExit: !0 }, d = { Once: !0, postcssPlugin: !0, prepare: !0 }, p = 0;
  function m(D) {
    return typeof D == "object" && typeof D.then == "function";
  }
  function y(D) {
    let x = !1, C = h[D.type];
    return D.type === "decl" ? x = D.prop.toLowerCase() : D.type === "atrule" && (x = D.name.toLowerCase()), x && D.append ? [C, C + "-" + x, p, C + "Exit", C + "Exit-" + x] : x ? [C, C + "-" + x, C + "Exit", C + "Exit-" + x] : D.append ? [C, p, C + "Exit"] : [C, C + "Exit"];
  }
  function v(D) {
    let x;
    return D.type === "document" ? x = ["Document", p, "DocumentExit"] : D.type === "root" ? x = ["Root", p, "RootExit"] : x = y(D), { eventIndex: 0, events: x, iterator: 0, node: D, visitorIndex: 0, visitors: [] };
  }
  function g(D) {
    return D[r] = !1, D.nodes && D.nodes.forEach((x) => g(x)), D;
  }
  var b = {}, w = class Yg {
    constructor(x, C, k) {
      this.stringified = !1, this.processed = !1;
      let S;
      if (typeof C == "object" && C !== null && (C.type === "root" || C.type === "document"))
        S = g(C);
      else if (C instanceof Yg || C instanceof l)
        S = g(C.root), C.map && (typeof k.map > "u" && (k.map = {}), k.map.inline || (k.map.inline = !1), k.map.prev = C.map);
      else {
        let A = c;
        k.syntax && (A = k.syntax.parse), k.parser && (A = k.parser), A.parse && (A = A.parse);
        try {
          S = A(C, k);
        } catch (_) {
          this.processed = !0, this.error = _;
        }
        S && !S[n] && o.rebuild(S);
      }
      this.result = new l(x, S, k), this.helpers = { ...b, postcss: b, result: this.result }, this.plugins = this.processor.plugins.map((A) => typeof A == "object" && A.prepare ? { ...A, ...A.prepare(this.result) } : A);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(x) {
      return this.async().catch(x);
    }
    finally(x) {
      return this.async().then(x, x);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(x, C) {
      let k = this.result.lastPlugin;
      try {
        C && C.addToError(x), this.error = x, x.name === "CssSyntaxError" && !x.plugin ? (x.plugin = k.postcssPlugin, x.setMessage()) : k.postcssVersion;
      } catch (S) {
        console && console.error && console.error(S);
      }
      return x;
    }
    prepareVisitors() {
      this.listeners = {};
      let x = (C, k, S) => {
        this.listeners[k] || (this.listeners[k] = []), this.listeners[k].push([C, S]);
      };
      for (let C of this.plugins)
        if (typeof C == "object")
          for (let k in C) {
            if (!f[k] && /^[A-Z]/.test(k))
              throw new Error(`Unknown event ${k} in ${C.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
            if (!d[k])
              if (typeof C[k] == "object")
                for (let S in C[k])
                  S === "*" ? x(C, k, C[k][S]) : x(C, k + "-" + S.toLowerCase(), C[k][S]);
              else
                typeof C[k] == "function" && x(C, k, C[k]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let x = 0; x < this.plugins.length; x++) {
        let C = this.plugins[x], k = this.runOnRoot(C);
        if (m(k))
          try {
            await k;
          } catch (S) {
            throw this.handleError(S);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let x = this.result.root;
        for (; !x[r]; ) {
          x[r] = !0;
          let C = [v(x)];
          for (; C.length > 0; ) {
            let k = this.visitTick(C);
            if (m(k))
              try {
                await k;
              } catch (S) {
                let A = C[C.length - 1].node;
                throw this.handleError(S, A);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [C, k] of this.listeners.OnceExit) {
            this.result.lastPlugin = C;
            try {
              if (x.type === "document") {
                let S = x.nodes.map((A) => k(A, this.helpers));
                await Promise.all(S);
              } else
                await k(x, this.helpers);
            } catch (S) {
              throw this.handleError(S);
            }
          }
      }
      return this.processed = !0, this.stringify();
    }
    runOnRoot(x) {
      this.result.lastPlugin = x;
      try {
        if (typeof x == "object" && x.Once) {
          if (this.result.root.type === "document") {
            let C = this.result.root.nodes.map((k) => x.Once(k, this.helpers));
            return m(C[0]) ? Promise.all(C) : C;
          }
          return x.Once(this.result.root, this.helpers);
        } else if (typeof x == "function")
          return x(this.result.root, this.result);
      } catch (C) {
        throw this.handleError(C);
      }
    }
    stringify() {
      if (this.error)
        throw this.error;
      if (this.stringified)
        return this.result;
      this.stringified = !0, this.sync();
      let x = this.result.opts, C = s;
      x.syntax && (C = x.syntax.stringify), x.stringifier && (C = x.stringifier), C.stringify && (C = C.stringify);
      let k = new i(C, this.result.root, this.result.opts).generate();
      return this.result.css = k[0], this.result.map = k[1], this.result;
    }
    sync() {
      if (this.error)
        throw this.error;
      if (this.processed)
        return this.result;
      if (this.processed = !0, this.processing)
        throw this.getAsyncError();
      for (let x of this.plugins) {
        let C = this.runOnRoot(x);
        if (m(C))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let x = this.result.root;
        for (; !x[r]; )
          x[r] = !0, this.walkSync(x);
        if (this.listeners.OnceExit)
          if (x.type === "document")
            for (let C of x.nodes)
              this.visitSync(this.listeners.OnceExit, C);
          else
            this.visitSync(this.listeners.OnceExit, x);
      }
      return this.result;
    }
    then(x, C) {
      return this.async().then(x, C);
    }
    toString() {
      return this.css;
    }
    visitSync(x, C) {
      for (let [k, S] of x) {
        this.result.lastPlugin = k;
        let A;
        try {
          A = S(C, this.helpers);
        } catch (_) {
          throw this.handleError(_, C.proxyOf);
        }
        if (C.type !== "root" && C.type !== "document" && !C.parent)
          return !0;
        if (m(A))
          throw this.getAsyncError();
      }
    }
    visitTick(x) {
      let C = x[x.length - 1], { node: k, visitors: S } = C;
      if (k.type !== "root" && k.type !== "document" && !k.parent) {
        x.pop();
        return;
      }
      if (S.length > 0 && C.visitorIndex < S.length) {
        let [_, N] = S[C.visitorIndex];
        C.visitorIndex += 1, C.visitorIndex === S.length && (C.visitors = [], C.visitorIndex = 0), this.result.lastPlugin = _;
        try {
          return N(k.toProxy(), this.helpers);
        } catch ($) {
          throw this.handleError($, k);
        }
      }
      if (C.iterator !== 0) {
        let _ = C.iterator, N;
        for (; N = k.nodes[k.indexes[_]]; )
          if (k.indexes[_] += 1, !N[r]) {
            N[r] = !0, x.push(v(N));
            return;
          }
        C.iterator = 0, delete k.indexes[_];
      }
      let A = C.events;
      for (; C.eventIndex < A.length; ) {
        let _ = A[C.eventIndex];
        if (C.eventIndex += 1, _ === p) {
          k.nodes && k.nodes.length && (k[r] = !0, C.iterator = k.getIterator());
          return;
        } else if (this.listeners[_]) {
          C.visitors = this.listeners[_];
          return;
        }
      }
      x.pop();
    }
    walkSync(x) {
      x[r] = !0;
      let C = y(x);
      for (let k of C)
        if (k === p)
          x.nodes && x.each((S) => {
            S[r] || this.walkSync(S);
          });
        else {
          let S = this.listeners[k];
          if (S && this.visitSync(S, x.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
  };
  w.registerPostcss = (D) => {
    b = D;
  }, e.exports = w, w.default = w, u.registerLazyResult(w), a.registerLazyResult(w);
}), LS = R((t, e) => {
  var r = zg(), n = Ha();
  Ug();
  var i = Ua(), s = lh(), o = class {
    constructor(a, l, c) {
      l = l.toString(), this.stringified = !1, this._processor = a, this._css = l, this._opts = c, this._map = void 0;
      let u, h = n;
      this.result = new s(this._processor, u, this._opts), this.result.css = l;
      let f = this;
      Object.defineProperty(this.result, "root", { get() {
        return f.root;
      } });
      let d = new r(h, u, this._opts, l);
      if (d.isMap()) {
        let [p, m] = d.generate();
        p && (this.result.css = p), m && (this.result.map = m);
      } else
        d.clearAnnotation(), this.result.css = d.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(a) {
      return this.async().catch(a);
    }
    finally(a) {
      return this.async().then(a, a);
    }
    sync() {
      if (this.error)
        throw this.error;
      return this.result;
    }
    then(a, l) {
      return this.async().then(a, l);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let a, l = i;
      try {
        a = l(this._css, this._opts);
      } catch (c) {
        this.error = c;
      }
      if (this.error)
        throw this.error;
      return this._root = a, a;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
  };
  e.exports = o, o.default = o;
}), PS = R((t, e) => {
  var r = LS(), n = Kg(), i = ah(), s = _s(), o = class {
    constructor(a = []) {
      this.version = "8.4.33", this.plugins = this.normalize(a);
    }
    normalize(a) {
      let l = [];
      for (let c of a)
        if (c.postcss === !0 ? c = c() : c.postcss && (c = c.postcss), typeof c == "object" && Array.isArray(c.plugins))
          l = l.concat(c.plugins);
        else if (typeof c == "object" && c.postcssPlugin)
          l.push(c);
        else if (typeof c == "function")
          l.push(c);
        else if (!(typeof c == "object" && (c.parse || c.stringify)))
          throw new Error(c + " is not a PostCSS plugin");
      return l;
    }
    process(a, l = {}) {
      return !this.plugins.length && !l.parser && !l.stringifier && !l.syntax ? new r(this, a, l) : new n(this, a, l);
    }
    use(a) {
      return this.plugins = this.plugins.concat(this.normalize([a])), this;
    }
  };
  e.exports = o, o.default = o, s.registerProcessor(o), i.registerProcessor(o);
}), NS = R((t, e) => {
  var r = za(), n = Vg(), i = Ts(), s = ih(), o = Bs(), a = _s(), l = sh();
  function c(u, h) {
    if (Array.isArray(u))
      return u.map((p) => c(p));
    let { inputs: f, ...d } = u;
    if (f) {
      h = [];
      for (let p of f) {
        let m = { ...p, __proto__: o.prototype };
        m.map && (m.map = { ...m.map, __proto__: n.prototype }), h.push(m);
      }
    }
    if (d.nodes && (d.nodes = u.nodes.map((p) => c(p, h))), d.source) {
      let { inputId: p, ...m } = d.source;
      d.source = m, p != null && (d.source.input = h[p]);
    }
    if (d.type === "root")
      return new a(d);
    if (d.type === "decl")
      return new r(d);
    if (d.type === "rule")
      return new l(d);
    if (d.type === "comment")
      return new i(d);
    if (d.type === "atrule")
      return new s(d);
    throw new Error("Unknown node type: " + u.type);
  }
  e.exports = c, c.default = c;
}), uh = R((t, e) => {
  var r = th(), n = za(), i = Kg(), s = On(), o = PS(), a = Ha(), l = NS(), c = ah(), u = Gg(), h = Ts(), f = ih(), d = lh(), p = Bs(), m = Ua(), y = Hg(), v = sh(), g = _s(), b = Va();
  function w(...D) {
    return D.length === 1 && Array.isArray(D[0]) && (D = D[0]), new o(D);
  }
  w.plugin = function(D, x) {
    let C = !1;
    function k(...A) {
      console && console.warn && !C && (C = !0, console.warn(D + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`));
      let _ = x(...A);
      return _.postcssPlugin = D, _.postcssVersion = new o().version, _;
    }
    let S;
    return Object.defineProperty(k, "postcss", { get() {
      return S || (S = k()), S;
    } }), k.process = function(A, _, N) {
      return w([k(N)]).process(A, _);
    }, k;
  }, w.stringify = a, w.parse = m, w.fromJSON = l, w.list = y, w.comment = (D) => new h(D), w.atRule = (D) => new f(D), w.decl = (D) => new n(D), w.rule = (D) => new v(D), w.root = (D) => new g(D), w.document = (D) => new c(D), w.CssSyntaxError = r, w.Declaration = n, w.Container = s, w.Processor = o, w.Document = c, w.Comment = h, w.Warning = u, w.AtRule = f, w.Result = d, w.Input = p, w.Rule = v, w.Root = g, w.Node = b, i.registerPostcss(w), e.exports = w, w.default = w;
}), RS = R((t, e) => {
  var { Container: r } = uh(), n = class extends r {
    constructor(i) {
      super(i), this.type = "decl", this.isNested = !0, this.nodes || (this.nodes = []);
    }
  };
  e.exports = n;
}), IS = R((t, e) => {
  var r = /[\t\n\f\r "#'()/;[\\\]{}]/g, n = /[,\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, i = /.[\r\n"'(/\\]/, s = /[\da-f]/i, o = /[\n\f\r]/g;
  e.exports = function(a, l = {}) {
    let c = a.css.valueOf(), u = l.ignoreErrors, h, f, d, p, m, y, v, g, b, w = c.length, D = 0, x = [], C = [], k;
    function S() {
      return D;
    }
    function A(I) {
      throw a.error("Unclosed " + I, D);
    }
    function _() {
      return C.length === 0 && D >= w;
    }
    function N() {
      let I = 1, P = !1, G = !1;
      for (; I > 0; )
        f += 1, c.length <= f && A("interpolation"), h = c.charCodeAt(f), g = c.charCodeAt(f + 1), P ? !G && h === P ? (P = !1, G = !1) : h === 92 ? G = !G : G && (G = !1) : h === 39 || h === 34 ? P = h : h === 125 ? I -= 1 : h === 35 && g === 123 && (I += 1);
    }
    function $(I) {
      if (C.length)
        return C.pop();
      if (D >= w)
        return;
      let P = I ? I.ignoreUnclosed : !1;
      switch (h = c.charCodeAt(D), h) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12: {
          f = D;
          do
            f += 1, h = c.charCodeAt(f);
          while (h === 32 || h === 10 || h === 9 || h === 13 || h === 12);
          b = ["space", c.slice(D, f)], D = f - 1;
          break;
        }
        case 91:
        case 93:
        case 123:
        case 125:
        case 58:
        case 59:
        case 41: {
          let G = String.fromCharCode(h);
          b = [G, G, D];
          break;
        }
        case 44: {
          b = ["word", ",", D, D + 1];
          break;
        }
        case 40: {
          if (v = x.length ? x.pop()[1] : "", g = c.charCodeAt(D + 1), v === "url" && g !== 39 && g !== 34) {
            for (k = 1, y = !1, f = D + 1; f <= c.length - 1; ) {
              if (g = c.charCodeAt(f), g === 92)
                y = !y;
              else if (g === 40)
                k += 1;
              else if (g === 41 && (k -= 1, k === 0))
                break;
              f += 1;
            }
            p = c.slice(D, f + 1), b = ["brackets", p, D, f], D = f;
          } else
            f = c.indexOf(")", D + 1), p = c.slice(D, f + 1), f === -1 || i.test(p) ? b = ["(", "(", D] : (b = ["brackets", p, D, f], D = f);
          break;
        }
        case 39:
        case 34: {
          for (d = h, f = D, y = !1; f < w && (f++, f === w && A("string"), h = c.charCodeAt(f), g = c.charCodeAt(f + 1), !(!y && h === d)); )
            h === 92 ? y = !y : y ? y = !1 : h === 35 && g === 123 && N();
          b = ["string", c.slice(D, f + 1), D, f], D = f;
          break;
        }
        case 64: {
          r.lastIndex = D + 1, r.test(c), r.lastIndex === 0 ? f = c.length - 1 : f = r.lastIndex - 2, b = ["at-word", c.slice(D, f + 1), D, f], D = f;
          break;
        }
        case 92: {
          for (f = D, m = !0; c.charCodeAt(f + 1) === 92; )
            f += 1, m = !m;
          if (h = c.charCodeAt(f + 1), m && h !== 47 && h !== 32 && h !== 10 && h !== 9 && h !== 13 && h !== 12 && (f += 1, s.test(c.charAt(f)))) {
            for (; s.test(c.charAt(f + 1)); )
              f += 1;
            c.charCodeAt(f + 1) === 32 && (f += 1);
          }
          b = ["word", c.slice(D, f + 1), D, f], D = f;
          break;
        }
        default:
          g = c.charCodeAt(D + 1), h === 35 && g === 123 ? (f = D, N(), p = c.slice(D, f + 1), b = ["word", p, D, f], D = f) : h === 47 && g === 42 ? (f = c.indexOf("*/", D + 2) + 1, f === 0 && (u || P ? f = c.length : A("comment")), b = ["comment", c.slice(D, f + 1), D, f], D = f) : h === 47 && g === 47 ? (o.lastIndex = D + 1, o.test(c), o.lastIndex === 0 ? f = c.length - 1 : f = o.lastIndex - 2, p = c.slice(D, f + 1), b = ["comment", p, D, f, "inline"], D = f) : (n.lastIndex = D + 1, n.test(c), n.lastIndex === 0 ? f = c.length - 1 : f = n.lastIndex - 2, b = ["word", c.slice(D, f + 1), D, f], x.push(b), D = f);
          break;
      }
      return D++, b;
    }
    function L(I) {
      C.push(I);
    }
    return { back: L, endOfFile: _, nextToken: $, position: S };
  };
}), $S = R((t, e) => {
  var { Comment: r } = uh(), n = oh(), i = RS(), s = IS(), o = class extends n {
    atrule(a) {
      let l = a[1], c = a;
      for (; !this.tokenizer.endOfFile(); ) {
        let u = this.tokenizer.nextToken();
        if (u[0] === "word" && u[2] === c[3] + 1)
          l += u[1], c = u;
        else {
          this.tokenizer.back(u);
          break;
        }
      }
      super.atrule(["at-word", l, a[2], c[3]]);
    }
    comment(a) {
      if (a[4] === "inline") {
        let l = new r();
        this.init(l, a[2]), l.raws.inline = !0;
        let c = this.input.fromOffset(a[3]);
        l.source.end = { column: c.col, line: c.line, offset: a[3] + 1 };
        let u = a[1].slice(2);
        if (/^\s*$/.test(u))
          l.text = "", l.raws.left = u, l.raws.right = "";
        else {
          let h = u.match(/^(\s*)([^]*\S)(\s*)$/), f = h[2].replace(/(\*\/|\/\*)/g, "*//*");
          l.text = f, l.raws.left = h[1], l.raws.right = h[3], l.raws.text = h[2];
        }
      } else
        super.comment(a);
    }
    createTokenizer() {
      this.tokenizer = s(this.input);
    }
    raw(a, l, c, u) {
      if (super.raw(a, l, c, u), a.raws[l]) {
        let h = a.raws[l].raw;
        a.raws[l].raw = c.reduce((f, d) => {
          if (d[0] === "comment" && d[4] === "inline") {
            let p = d[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*");
            return f + "/*" + p + "*/";
          } else
            return f + d[1];
        }, ""), h !== a.raws[l].raw && (a.raws[l].scss = h);
      }
    }
    rule(a) {
      let l = !1, c = 0, u = "";
      for (let h of a)
        if (l)
          h[0] !== "comment" && h[0] !== "{" && (u += h[1]);
        else {
          if (h[0] === "space" && h[1].includes(`
`))
            break;
          h[0] === "(" ? c += 1 : h[0] === ")" ? c -= 1 : c === 0 && h[0] === ":" && (l = !0);
        }
      if (!l || u.trim() === "" || /^[#:A-Za-z-]/.test(u))
        super.rule(a);
      else {
        a.pop();
        let h = new i();
        this.init(h, a[0][2]);
        let f;
        for (let p = a.length - 1; p >= 0; p--)
          if (a[p][0] !== "space") {
            f = a[p];
            break;
          }
        if (f[3]) {
          let p = this.input.fromOffset(f[3]);
          h.source.end = { column: p.col, line: p.line, offset: f[3] + 1 };
        } else {
          let p = this.input.fromOffset(f[2]);
          h.source.end = { column: p.col, line: p.line, offset: f[2] + 1 };
        }
        for (; a[0][0] !== "word"; )
          h.raws.before += a.shift()[1];
        if (a[0][2]) {
          let p = this.input.fromOffset(a[0][2]);
          h.source.start = { column: p.col, line: p.line, offset: a[0][2] };
        }
        for (h.prop = ""; a.length; ) {
          let p = a[0][0];
          if (p === ":" || p === "space" || p === "comment")
            break;
          h.prop += a.shift()[1];
        }
        h.raws.between = "";
        let d;
        for (; a.length; )
          if (d = a.shift(), d[0] === ":") {
            h.raws.between += d[1];
            break;
          } else
            h.raws.between += d[1];
        (h.prop[0] === "_" || h.prop[0] === "*") && (h.raws.before += h.prop[0], h.prop = h.prop.slice(1)), h.raws.between += this.spacesAndCommentsFromStart(a), this.precheckMissedSemicolon(a);
        for (let p = a.length - 1; p > 0; p--) {
          if (d = a[p], d[1] === "!important") {
            h.important = !0;
            let m = this.stringFrom(a, p);
            m = this.spacesFromEnd(a) + m, m !== " !important" && (h.raws.important = m);
            break;
          } else if (d[1] === "important") {
            let m = a.slice(0), y = "";
            for (let v = p; v > 0; v--) {
              let g = m[v][0];
              if (y.trim().indexOf("!") === 0 && g !== "space")
                break;
              y = m.pop()[1] + y;
            }
            y.trim().indexOf("!") === 0 && (h.important = !0, h.raws.important = y, a = m);
          }
          if (d[0] !== "space" && d[0] !== "comment")
            break;
        }
        this.raw(h, "value", a), h.value.includes(":") && this.checkMissedSemicolon(a), this.current = h;
      }
    }
  };
  e.exports = o;
}), jS = R((t, e) => {
  var { Input: r } = uh(), n = $S();
  e.exports = function(i, s) {
    let o = new r(i, s), a = new n(o);
    return a.parse(), a.root;
  };
}), Jg = R((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(r) {
    this.after = r.after, this.before = r.before, this.type = r.type, this.value = r.value, this.sourceIndex = r.sourceIndex;
  }
  t.default = e;
}), Xg = R((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = Jg(), r = n(e);
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i(s) {
    var o = this;
    this.constructor(s), this.nodes = s.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(a) {
      a.parent = o;
    });
  }
  i.prototype = Object.create(r.default.prototype), i.constructor = r.default, i.prototype.walk = function(s, o) {
    for (var a = typeof s == "string" || s instanceof RegExp, l = a ? o : s, c = typeof s == "string" ? new RegExp(s) : s, u = 0; u < this.nodes.length; u++) {
      var h = this.nodes[u], f = a ? c.test(h.type) : !0;
      if (f && l && l(h, u, this.nodes) === !1 || h.nodes && h.walk(s, o) === !1)
        return !1;
    }
    return !0;
  }, i.prototype.each = function() {
    for (var s = arguments.length <= 0 || arguments[0] === void 0 ? function() {
    } : arguments[0], o = 0; o < this.nodes.length; o++) {
      var a = this.nodes[o];
      if (s(a, o, this.nodes) === !1)
        return !1;
    }
    return !0;
  }, t.default = i;
}), WS = R((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.parseMediaFeature = o, t.parseMediaQuery = a, t.parseMediaList = l;
  var e = Jg(), r = s(e), n = Xg(), i = s(n);
  function s(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function o(c) {
    var u = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], h = [{ mode: "normal", character: null }], f = [], d = 0, p = "", m = null, y = null, v = u, g = c;
    c[0] === "(" && c[c.length - 1] === ")" && (g = c.substring(1, c.length - 1), v++);
    for (var b = 0; b < g.length; b++) {
      var w = g[b];
      if ((w === "'" || w === '"') && (h[d].isCalculationEnabled === !0 ? (h.push({ mode: "string", isCalculationEnabled: !1, character: w }), d++) : h[d].mode === "string" && h[d].character === w && g[b - 1] !== "\\" && (h.pop(), d--)), w === "{" ? (h.push({ mode: "interpolation", isCalculationEnabled: !0 }), d++) : w === "}" && (h.pop(), d--), h[d].mode === "normal" && w === ":") {
        var D = g.substring(b + 1);
        y = { type: "value", before: /^(\s*)/.exec(D)[1], after: /(\s*)$/.exec(D)[1], value: D.trim() }, y.sourceIndex = y.before.length + b + 1 + v, m = { type: "colon", sourceIndex: b + v, after: y.before, value: ":" };
        break;
      }
      p += w;
    }
    return p = { type: "media-feature", before: /^(\s*)/.exec(p)[1], after: /(\s*)$/.exec(p)[1], value: p.trim() }, p.sourceIndex = p.before.length + v, f.push(p), m !== null && (m.before = p.after, f.push(m)), y !== null && f.push(y), f;
  }
  function a(c) {
    var u = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], h = [], f = 0, d = !1, p = void 0;
    function m() {
      return { before: "", after: "", value: "" };
    }
    p = m();
    for (var y = 0; y < c.length; y++) {
      var v = c[y];
      d ? (p.value += v, (v === "{" || v === "(") && f++, (v === ")" || v === "}") && f--) : v.search(/\s/) !== -1 ? p.before += v : (v === "(" && (p.type = "media-feature-expression", f++), p.value = v, p.sourceIndex = u + y, d = !0), d && f === 0 && (v === ")" || y === c.length - 1 || c[y + 1].search(/\s/) !== -1) && (["not", "only", "and"].indexOf(p.value) !== -1 && (p.type = "keyword"), p.type === "media-feature-expression" && (p.nodes = o(p.value, p.sourceIndex)), h.push(Array.isArray(p.nodes) ? new i.default(p) : new r.default(p)), p = m(), d = !1);
    }
    for (var g = 0; g < h.length; g++)
      if (p = h[g], g > 0 && (h[g - 1].after = p.before), p.type === void 0) {
        if (g > 0) {
          if (h[g - 1].type === "media-feature-expression") {
            p.type = "keyword";
            continue;
          }
          if (h[g - 1].value === "not" || h[g - 1].value === "only") {
            p.type = "media-type";
            continue;
          }
          if (h[g - 1].value === "and") {
            p.type = "media-feature-expression";
            continue;
          }
          h[g - 1].type === "media-type" && (h[g + 1] ? p.type = h[g + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : p.type = "media-feature-expression");
        }
        if (g === 0) {
          if (!h[g + 1]) {
            p.type = "media-type";
            continue;
          }
          if (h[g + 1] && (h[g + 1].type === "media-feature-expression" || h[g + 1].type === "keyword")) {
            p.type = "media-type";
            continue;
          }
          if (h[g + 2]) {
            if (h[g + 2].type === "media-feature-expression") {
              p.type = "media-type", h[g + 1].type = "keyword";
              continue;
            }
            if (h[g + 2].type === "keyword") {
              p.type = "keyword", h[g + 1].type = "media-type";
              continue;
            }
          }
          if (h[g + 3] && h[g + 3].type === "media-feature-expression") {
            p.type = "keyword", h[g + 1].type = "media-type", h[g + 2].type = "keyword";
            continue;
          }
        }
      }
    return h;
  }
  function l(c) {
    var u = [], h = 0, f = 0, d = /^(\s*)url\s*\(/.exec(c);
    if (d !== null) {
      for (var p = d[0].length, m = 1; m > 0; ) {
        var y = c[p];
        y === "(" && m++, y === ")" && m--, p++;
      }
      u.unshift(new r.default({ type: "url", value: c.substring(0, p).trim(), sourceIndex: d[1].length, before: d[1], after: /^(\s*)/.exec(c.substring(p))[1] })), h = p;
    }
    for (var v = h; v < c.length; v++) {
      var g = c[v];
      if (g === "(" && f++, g === ")" && f--, f === 0 && g === ",") {
        var b = c.substring(h, v), w = /^(\s*)/.exec(b)[1];
        u.push(new i.default({ type: "media-query", value: b.trim(), sourceIndex: h + w.length, nodes: a(b, h), before: w, after: /(\s*)$/.exec(b)[1] })), h = v + 1;
      }
    }
    var D = c.substring(h), x = /^(\s*)/.exec(D)[1];
    return u.push(new i.default({ type: "media-query", value: D.trim(), sourceIndex: h + x.length, nodes: a(D, h), before: x, after: /(\s*)$/.exec(D)[1] })), u;
  }
}), qS = R((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = s;
  var e = Xg(), r = i(e), n = WS();
  function i(o) {
    return o && o.__esModule ? o : { default: o };
  }
  function s(o) {
    return new r.default({ nodes: (0, n.parseMediaList)(o), type: "media-query-list", value: o.trim() });
  }
}), Qg = R((t, e) => {
  e.exports = function(r, n) {
    if (n = typeof n == "number" ? n : 1 / 0, !n)
      return Array.isArray(r) ? r.map(function(s) {
        return s;
      }) : r;
    return i(r, 1);
    function i(s, o) {
      return s.reduce(function(a, l) {
        return Array.isArray(l) && o < n ? a.concat(i(l, o + 1)) : a.concat(l);
      }, []);
    }
  };
}), Zg = R((t, e) => {
  e.exports = function(r, n) {
    for (var i = -1, s = []; (i = r.indexOf(n, i + 1)) !== -1; )
      s.push(i);
    return s;
  };
}), e0 = R((t, e) => {
  function r(s, o) {
    for (var a = 1, l = s.length, c = s[0], u = s[0], h = 1; h < l; ++h)
      if (u = c, c = s[h], o(c, u)) {
        if (h === a) {
          a++;
          continue;
        }
        s[a++] = c;
      }
    return s.length = a, s;
  }
  function n(s) {
    for (var o = 1, a = s.length, l = s[0], c = s[0], u = 1; u < a; ++u, c = l)
      if (c = l, l = s[u], l !== c) {
        if (u === o) {
          o++;
          continue;
        }
        s[o++] = l;
      }
    return s.length = o, s;
  }
  function i(s, o, a) {
    return s.length === 0 ? s : o ? (a || s.sort(o), r(s, o)) : (a || s.sort(), n(s));
  }
  e.exports = i;
}), vi = R((t, e) => {
  t.__esModule = !0;
  var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
    return typeof o;
  } : function(o) {
    return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  };
  function n(o, a) {
    if (!(o instanceof a))
      throw new TypeError("Cannot call a class as a function");
  }
  var i = function o(a, l) {
    if ((typeof a > "u" ? "undefined" : r(a)) !== "object")
      return a;
    var c = new a.constructor();
    for (var u in a)
      if (a.hasOwnProperty(u)) {
        var h = a[u], f = typeof h > "u" ? "undefined" : r(h);
        u === "parent" && f === "object" ? l && (c[u] = l) : h instanceof Array ? c[u] = h.map(function(d) {
          return o(d, c);
        }) : c[u] = o(h, c);
      }
    return c;
  }, s = function() {
    function o() {
      var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      n(this, o);
      for (var l in a)
        this[l] = a[l];
      var c = a.spaces;
      c = c === void 0 ? {} : c;
      var u = c.before, h = u === void 0 ? "" : u, f = c.after, d = f === void 0 ? "" : f;
      this.spaces = { before: h, after: d };
    }
    return o.prototype.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, o.prototype.replaceWith = function() {
      if (this.parent) {
        for (var a in arguments)
          this.parent.insertBefore(this, arguments[a]);
        this.remove();
      }
      return this;
    }, o.prototype.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, o.prototype.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, o.prototype.clone = function() {
      var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, l = i(this);
      for (var c in a)
        l[c] = a[c];
      return l;
    }, o.prototype.toString = function() {
      return [this.spaces.before, String(this.value), this.spaces.after].join("");
    }, o;
  }();
  t.default = s, e.exports = t.default;
}), ot = R((t) => {
  t.__esModule = !0, t.TAG = "tag", t.STRING = "string", t.SELECTOR = "selector", t.ROOT = "root", t.PSEUDO = "pseudo", t.NESTING = "nesting", t.ID = "id", t.COMMENT = "comment", t.COMBINATOR = "combinator", t.CLASS = "class", t.ATTRIBUTE = "attribute", t.UNIVERSAL = "universal";
}), ch = R((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function d(p, m) {
      for (var y = 0; y < m.length; y++) {
        var v = m[y];
        v.enumerable = v.enumerable || !1, v.configurable = !0, "value" in v && (v.writable = !0), Object.defineProperty(p, v.key, v);
      }
    }
    return function(p, m, y) {
      return m && d(p.prototype, m), y && d(p, y), p;
    };
  }(), n = vi(), i = l(n), s = ot(), o = a(s);
  function a(d) {
    if (d && d.__esModule)
      return d;
    var p = {};
    if (d != null)
      for (var m in d)
        Object.prototype.hasOwnProperty.call(d, m) && (p[m] = d[m]);
    return p.default = d, p;
  }
  function l(d) {
    return d && d.__esModule ? d : { default: d };
  }
  function c(d, p) {
    if (!(d instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function u(d, p) {
    if (!d)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return p && (typeof p == "object" || typeof p == "function") ? p : d;
  }
  function h(d, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof p);
    d.prototype = Object.create(p && p.prototype, { constructor: { value: d, enumerable: !1, writable: !0, configurable: !0 } }), p && (Object.setPrototypeOf ? Object.setPrototypeOf(d, p) : d.__proto__ = p);
  }
  var f = function(d) {
    h(p, d);
    function p(m) {
      c(this, p);
      var y = u(this, d.call(this, m));
      return y.nodes || (y.nodes = []), y;
    }
    return p.prototype.append = function(m) {
      return m.parent = this, this.nodes.push(m), this;
    }, p.prototype.prepend = function(m) {
      return m.parent = this, this.nodes.unshift(m), this;
    }, p.prototype.at = function(m) {
      return this.nodes[m];
    }, p.prototype.index = function(m) {
      return typeof m == "number" ? m : this.nodes.indexOf(m);
    }, p.prototype.removeChild = function(m) {
      m = this.index(m), this.at(m).parent = void 0, this.nodes.splice(m, 1);
      var y = void 0;
      for (var v in this.indexes)
        y = this.indexes[v], y >= m && (this.indexes[v] = y - 1);
      return this;
    }, p.prototype.removeAll = function() {
      for (var v = this.nodes, m = Array.isArray(v), y = 0, v = m ? v : v[Symbol.iterator](); ; ) {
        var g;
        if (m) {
          if (y >= v.length)
            break;
          g = v[y++];
        } else {
          if (y = v.next(), y.done)
            break;
          g = y.value;
        }
        var b = g;
        b.parent = void 0;
      }
      return this.nodes = [], this;
    }, p.prototype.empty = function() {
      return this.removeAll();
    }, p.prototype.insertAfter = function(m, y) {
      var v = this.index(m);
      this.nodes.splice(v + 1, 0, y);
      var g = void 0;
      for (var b in this.indexes)
        g = this.indexes[b], v <= g && (this.indexes[b] = g + this.nodes.length);
      return this;
    }, p.prototype.insertBefore = function(m, y) {
      var v = this.index(m);
      this.nodes.splice(v, 0, y);
      var g = void 0;
      for (var b in this.indexes)
        g = this.indexes[b], v <= g && (this.indexes[b] = g + this.nodes.length);
      return this;
    }, p.prototype.each = function(m) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var y = this.lastEach;
      if (this.indexes[y] = 0, !!this.length) {
        for (var v = void 0, g = void 0; this.indexes[y] < this.length && (v = this.indexes[y], g = m(this.at(v), v), g !== !1); )
          this.indexes[y] += 1;
        if (delete this.indexes[y], g === !1)
          return !1;
      }
    }, p.prototype.walk = function(m) {
      return this.each(function(y, v) {
        var g = m(y, v);
        if (g !== !1 && y.length && (g = y.walk(m)), g === !1)
          return !1;
      });
    }, p.prototype.walkAttributes = function(m) {
      var y = this;
      return this.walk(function(v) {
        if (v.type === o.ATTRIBUTE)
          return m.call(y, v);
      });
    }, p.prototype.walkClasses = function(m) {
      var y = this;
      return this.walk(function(v) {
        if (v.type === o.CLASS)
          return m.call(y, v);
      });
    }, p.prototype.walkCombinators = function(m) {
      var y = this;
      return this.walk(function(v) {
        if (v.type === o.COMBINATOR)
          return m.call(y, v);
      });
    }, p.prototype.walkComments = function(m) {
      var y = this;
      return this.walk(function(v) {
        if (v.type === o.COMMENT)
          return m.call(y, v);
      });
    }, p.prototype.walkIds = function(m) {
      var y = this;
      return this.walk(function(v) {
        if (v.type === o.ID)
          return m.call(y, v);
      });
    }, p.prototype.walkNesting = function(m) {
      var y = this;
      return this.walk(function(v) {
        if (v.type === o.NESTING)
          return m.call(y, v);
      });
    }, p.prototype.walkPseudos = function(m) {
      var y = this;
      return this.walk(function(v) {
        if (v.type === o.PSEUDO)
          return m.call(y, v);
      });
    }, p.prototype.walkTags = function(m) {
      var y = this;
      return this.walk(function(v) {
        if (v.type === o.TAG)
          return m.call(y, v);
      });
    }, p.prototype.walkUniversals = function(m) {
      var y = this;
      return this.walk(function(v) {
        if (v.type === o.UNIVERSAL)
          return m.call(y, v);
      });
    }, p.prototype.split = function(m) {
      var y = this, v = [];
      return this.reduce(function(g, b, w) {
        var D = m.call(y, b);
        return v.push(b), D ? (g.push(v), v = []) : w === y.length - 1 && g.push(v), g;
      }, []);
    }, p.prototype.map = function(m) {
      return this.nodes.map(m);
    }, p.prototype.reduce = function(m, y) {
      return this.nodes.reduce(m, y);
    }, p.prototype.every = function(m) {
      return this.nodes.every(m);
    }, p.prototype.some = function(m) {
      return this.nodes.some(m);
    }, p.prototype.filter = function(m) {
      return this.nodes.filter(m);
    }, p.prototype.sort = function(m) {
      return this.nodes.sort(m);
    }, p.prototype.toString = function() {
      return this.map(String).join("");
    }, r(p, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), p;
  }(i.default);
  t.default = f, e.exports = t.default;
}), HS = R((t, e) => {
  t.__esModule = !0;
  var r = ch(), n = s(r), i = ot();
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(u, h) {
    if (!u)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return h && (typeof h == "object" || typeof h == "function") ? h : u;
  }
  function l(u, h) {
    if (typeof h != "function" && h !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof h);
    u.prototype = Object.create(h && h.prototype, { constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 } }), h && (Object.setPrototypeOf ? Object.setPrototypeOf(u, h) : u.__proto__ = h);
  }
  var c = function(u) {
    l(h, u);
    function h(f) {
      o(this, h);
      var d = a(this, u.call(this, f));
      return d.type = i.ROOT, d;
    }
    return h.prototype.toString = function() {
      var f = this.reduce(function(d, p) {
        var m = String(p);
        return m ? d + m + "," : "";
      }, "").slice(0, -1);
      return this.trailingComma ? f + "," : f;
    }, h;
  }(n.default);
  t.default = c, e.exports = t.default;
}), VS = R((t, e) => {
  t.__esModule = !0;
  var r = ch(), n = s(r), i = ot();
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(u, h) {
    if (!u)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return h && (typeof h == "object" || typeof h == "function") ? h : u;
  }
  function l(u, h) {
    if (typeof h != "function" && h !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof h);
    u.prototype = Object.create(h && h.prototype, { constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 } }), h && (Object.setPrototypeOf ? Object.setPrototypeOf(u, h) : u.__proto__ = h);
  }
  var c = function(u) {
    l(h, u);
    function h(f) {
      o(this, h);
      var d = a(this, u.call(this, f));
      return d.type = i.SELECTOR, d;
    }
    return h;
  }(n.default);
  t.default = c, e.exports = t.default;
}), Os = R((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function u(h, f) {
      for (var d = 0; d < f.length; d++) {
        var p = f[d];
        p.enumerable = p.enumerable || !1, p.configurable = !0, "value" in p && (p.writable = !0), Object.defineProperty(h, p.key, p);
      }
    }
    return function(h, f, d) {
      return f && u(h.prototype, f), d && u(h, d), h;
    };
  }(), n = vi(), i = s(n);
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(u, h) {
    if (!u)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return h && (typeof h == "object" || typeof h == "function") ? h : u;
  }
  function l(u, h) {
    if (typeof h != "function" && h !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof h);
    u.prototype = Object.create(h && h.prototype, { constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 } }), h && (Object.setPrototypeOf ? Object.setPrototypeOf(u, h) : u.__proto__ = h);
  }
  var c = function(u) {
    l(h, u);
    function h() {
      return o(this, h), a(this, u.apply(this, arguments));
    }
    return h.prototype.toString = function() {
      return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
    }, r(h, [{ key: "ns", get: function() {
      var f = this.namespace;
      return f ? (typeof f == "string" ? f : "") + "|" : "";
    } }]), h;
  }(i.default);
  t.default = c, e.exports = t.default;
}), zS = R((t, e) => {
  t.__esModule = !0;
  var r = Os(), n = s(r), i = ot();
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(u, h) {
    if (!u)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return h && (typeof h == "object" || typeof h == "function") ? h : u;
  }
  function l(u, h) {
    if (typeof h != "function" && h !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof h);
    u.prototype = Object.create(h && h.prototype, { constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 } }), h && (Object.setPrototypeOf ? Object.setPrototypeOf(u, h) : u.__proto__ = h);
  }
  var c = function(u) {
    l(h, u);
    function h(f) {
      o(this, h);
      var d = a(this, u.call(this, f));
      return d.type = i.CLASS, d;
    }
    return h.prototype.toString = function() {
      return [this.spaces.before, this.ns, "." + this.value, this.spaces.after].join("");
    }, h;
  }(n.default);
  t.default = c, e.exports = t.default;
}), US = R((t, e) => {
  t.__esModule = !0;
  var r = vi(), n = s(r), i = ot();
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(u, h) {
    if (!u)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return h && (typeof h == "object" || typeof h == "function") ? h : u;
  }
  function l(u, h) {
    if (typeof h != "function" && h !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof h);
    u.prototype = Object.create(h && h.prototype, { constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 } }), h && (Object.setPrototypeOf ? Object.setPrototypeOf(u, h) : u.__proto__ = h);
  }
  var c = function(u) {
    l(h, u);
    function h(f) {
      o(this, h);
      var d = a(this, u.call(this, f));
      return d.type = i.COMMENT, d;
    }
    return h;
  }(n.default);
  t.default = c, e.exports = t.default;
}), GS = R((t, e) => {
  t.__esModule = !0;
  var r = Os(), n = s(r), i = ot();
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(u, h) {
    if (!u)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return h && (typeof h == "object" || typeof h == "function") ? h : u;
  }
  function l(u, h) {
    if (typeof h != "function" && h !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof h);
    u.prototype = Object.create(h && h.prototype, { constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 } }), h && (Object.setPrototypeOf ? Object.setPrototypeOf(u, h) : u.__proto__ = h);
  }
  var c = function(u) {
    l(h, u);
    function h(f) {
      o(this, h);
      var d = a(this, u.call(this, f));
      return d.type = i.ID, d;
    }
    return h.prototype.toString = function() {
      return [this.spaces.before, this.ns, "#" + this.value, this.spaces.after].join("");
    }, h;
  }(n.default);
  t.default = c, e.exports = t.default;
}), KS = R((t, e) => {
  t.__esModule = !0;
  var r = Os(), n = s(r), i = ot();
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(u, h) {
    if (!u)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return h && (typeof h == "object" || typeof h == "function") ? h : u;
  }
  function l(u, h) {
    if (typeof h != "function" && h !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof h);
    u.prototype = Object.create(h && h.prototype, { constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 } }), h && (Object.setPrototypeOf ? Object.setPrototypeOf(u, h) : u.__proto__ = h);
  }
  var c = function(u) {
    l(h, u);
    function h(f) {
      o(this, h);
      var d = a(this, u.call(this, f));
      return d.type = i.TAG, d;
    }
    return h;
  }(n.default);
  t.default = c, e.exports = t.default;
}), YS = R((t, e) => {
  t.__esModule = !0;
  var r = vi(), n = s(r), i = ot();
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(u, h) {
    if (!u)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return h && (typeof h == "object" || typeof h == "function") ? h : u;
  }
  function l(u, h) {
    if (typeof h != "function" && h !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof h);
    u.prototype = Object.create(h && h.prototype, { constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 } }), h && (Object.setPrototypeOf ? Object.setPrototypeOf(u, h) : u.__proto__ = h);
  }
  var c = function(u) {
    l(h, u);
    function h(f) {
      o(this, h);
      var d = a(this, u.call(this, f));
      return d.type = i.STRING, d;
    }
    return h;
  }(n.default);
  t.default = c, e.exports = t.default;
}), JS = R((t, e) => {
  t.__esModule = !0;
  var r = ch(), n = s(r), i = ot();
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(u, h) {
    if (!u)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return h && (typeof h == "object" || typeof h == "function") ? h : u;
  }
  function l(u, h) {
    if (typeof h != "function" && h !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof h);
    u.prototype = Object.create(h && h.prototype, { constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 } }), h && (Object.setPrototypeOf ? Object.setPrototypeOf(u, h) : u.__proto__ = h);
  }
  var c = function(u) {
    l(h, u);
    function h(f) {
      o(this, h);
      var d = a(this, u.call(this, f));
      return d.type = i.PSEUDO, d;
    }
    return h.prototype.toString = function() {
      var f = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.spaces.before, String(this.value), f, this.spaces.after].join("");
    }, h;
  }(n.default);
  t.default = c, e.exports = t.default;
}), XS = R((t, e) => {
  t.__esModule = !0;
  var r = Os(), n = s(r), i = ot();
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(u, h) {
    if (!u)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return h && (typeof h == "object" || typeof h == "function") ? h : u;
  }
  function l(u, h) {
    if (typeof h != "function" && h !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof h);
    u.prototype = Object.create(h && h.prototype, { constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 } }), h && (Object.setPrototypeOf ? Object.setPrototypeOf(u, h) : u.__proto__ = h);
  }
  var c = function(u) {
    l(h, u);
    function h(f) {
      o(this, h);
      var d = a(this, u.call(this, f));
      return d.type = i.ATTRIBUTE, d.raws = {}, d;
    }
    return h.prototype.toString = function() {
      var f = [this.spaces.before, "[", this.ns, this.attribute];
      return this.operator && f.push(this.operator), this.value && f.push(this.value), this.raws.insensitive ? f.push(this.raws.insensitive) : this.insensitive && f.push(" i"), f.push("]"), f.concat(this.spaces.after).join("");
    }, h;
  }(n.default);
  t.default = c, e.exports = t.default;
}), QS = R((t, e) => {
  t.__esModule = !0;
  var r = Os(), n = s(r), i = ot();
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(u, h) {
    if (!u)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return h && (typeof h == "object" || typeof h == "function") ? h : u;
  }
  function l(u, h) {
    if (typeof h != "function" && h !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof h);
    u.prototype = Object.create(h && h.prototype, { constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 } }), h && (Object.setPrototypeOf ? Object.setPrototypeOf(u, h) : u.__proto__ = h);
  }
  var c = function(u) {
    l(h, u);
    function h(f) {
      o(this, h);
      var d = a(this, u.call(this, f));
      return d.type = i.UNIVERSAL, d.value = "*", d;
    }
    return h;
  }(n.default);
  t.default = c, e.exports = t.default;
}), ZS = R((t, e) => {
  t.__esModule = !0;
  var r = vi(), n = s(r), i = ot();
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(u, h) {
    if (!u)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return h && (typeof h == "object" || typeof h == "function") ? h : u;
  }
  function l(u, h) {
    if (typeof h != "function" && h !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof h);
    u.prototype = Object.create(h && h.prototype, { constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 } }), h && (Object.setPrototypeOf ? Object.setPrototypeOf(u, h) : u.__proto__ = h);
  }
  var c = function(u) {
    l(h, u);
    function h(f) {
      o(this, h);
      var d = a(this, u.call(this, f));
      return d.type = i.COMBINATOR, d;
    }
    return h;
  }(n.default);
  t.default = c, e.exports = t.default;
}), eE = R((t, e) => {
  t.__esModule = !0;
  var r = vi(), n = s(r), i = ot();
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function o(u, h) {
    if (!(u instanceof h))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(u, h) {
    if (!u)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return h && (typeof h == "object" || typeof h == "function") ? h : u;
  }
  function l(u, h) {
    if (typeof h != "function" && h !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof h);
    u.prototype = Object.create(h && h.prototype, { constructor: { value: u, enumerable: !1, writable: !0, configurable: !0 } }), h && (Object.setPrototypeOf ? Object.setPrototypeOf(u, h) : u.__proto__ = h);
  }
  var c = function(u) {
    l(h, u);
    function h(f) {
      o(this, h);
      var d = a(this, u.call(this, f));
      return d.type = i.NESTING, d.value = "&", d;
    }
    return h;
  }(n.default);
  t.default = c, e.exports = t.default;
}), tE = R((t, e) => {
  t.__esModule = !0, t.default = r;
  function r(n) {
    return n.sort(function(i, s) {
      return i - s;
    });
  }
  e.exports = t.default;
}), rE = R((t, e) => {
  t.__esModule = !0, t.default = _;
  var r = 39, n = 34, i = 92, s = 47, o = 10, a = 32, l = 12, c = 9, u = 13, h = 43, f = 62, d = 126, p = 124, m = 44, y = 40, v = 41, g = 91, b = 93, w = 59, D = 42, x = 58, C = 38, k = 64, S = /[ \n\t\r\{\(\)'"\\;/]/g, A = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
  function _(N) {
    for (var $ = [], L = N.css.valueOf(), I = void 0, P = void 0, G = void 0, re = void 0, oe = void 0, ue = void 0, pe = void 0, ke = void 0, qe = void 0, se = void 0, at = void 0, qt = L.length, q = -1, F = 1, O = 0, X = function(ae, ve) {
      if (N.safe)
        L += ve, P = L.length - 1;
      else
        throw N.error("Unclosed " + ae, F, O - q, O);
    }; O < qt; ) {
      switch (I = L.charCodeAt(O), I === o && (q = O, F += 1), I) {
        case o:
        case a:
        case c:
        case u:
        case l:
          P = O;
          do
            P += 1, I = L.charCodeAt(P), I === o && (q = P, F += 1);
          while (I === a || I === o || I === c || I === u || I === l);
          $.push(["space", L.slice(O, P), F, O - q, O]), O = P - 1;
          break;
        case h:
        case f:
        case d:
        case p:
          P = O;
          do
            P += 1, I = L.charCodeAt(P);
          while (I === h || I === f || I === d || I === p);
          $.push(["combinator", L.slice(O, P), F, O - q, O]), O = P - 1;
          break;
        case D:
          $.push(["*", "*", F, O - q, O]);
          break;
        case C:
          $.push(["&", "&", F, O - q, O]);
          break;
        case m:
          $.push([",", ",", F, O - q, O]);
          break;
        case g:
          $.push(["[", "[", F, O - q, O]);
          break;
        case b:
          $.push(["]", "]", F, O - q, O]);
          break;
        case x:
          $.push([":", ":", F, O - q, O]);
          break;
        case w:
          $.push([";", ";", F, O - q, O]);
          break;
        case y:
          $.push(["(", "(", F, O - q, O]);
          break;
        case v:
          $.push([")", ")", F, O - q, O]);
          break;
        case r:
        case n:
          G = I === r ? "'" : '"', P = O;
          do
            for (se = !1, P = L.indexOf(G, P + 1), P === -1 && X("quote", G), at = P; L.charCodeAt(at - 1) === i; )
              at -= 1, se = !se;
          while (se);
          $.push(["string", L.slice(O, P + 1), F, O - q, F, P - q, O]), O = P;
          break;
        case k:
          S.lastIndex = O + 1, S.test(L), S.lastIndex === 0 ? P = L.length - 1 : P = S.lastIndex - 2, $.push(["at-word", L.slice(O, P + 1), F, O - q, F, P - q, O]), O = P;
          break;
        case i:
          for (P = O, pe = !0; L.charCodeAt(P + 1) === i; )
            P += 1, pe = !pe;
          I = L.charCodeAt(P + 1), pe && I !== s && I !== a && I !== o && I !== c && I !== u && I !== l && (P += 1), $.push(["word", L.slice(O, P + 1), F, O - q, F, P - q, O]), O = P;
          break;
        default:
          I === s && L.charCodeAt(O + 1) === D ? (P = L.indexOf("*/", O + 2) + 1, P === 0 && X("comment", "*/"), ue = L.slice(O, P + 1), re = ue.split(`
`), oe = re.length - 1, oe > 0 ? (ke = F + oe, qe = P - re[oe].length) : (ke = F, qe = q), $.push(["comment", ue, F, O - q, ke, P - qe, O]), q = qe, F = ke, O = P) : (A.lastIndex = O + 1, A.test(L), A.lastIndex === 0 ? P = L.length - 1 : P = A.lastIndex - 2, $.push(["word", L.slice(O, P + 1), F, O - q, F, P - q, O]), O = P);
          break;
      }
      O++;
    }
    return $;
  }
  e.exports = t.default;
}), nE = R((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function q(F, O) {
      for (var X = 0; X < O.length; X++) {
        var ae = O[X];
        ae.enumerable = ae.enumerable || !1, ae.configurable = !0, "value" in ae && (ae.writable = !0), Object.defineProperty(F, ae.key, ae);
      }
    }
    return function(F, O, X) {
      return O && q(F.prototype, O), X && q(F, X), F;
    };
  }(), n = Qg(), i = se(n), s = Zg(), o = se(s), a = e0(), l = se(a), c = HS(), u = se(c), h = VS(), f = se(h), d = zS(), p = se(d), m = US(), y = se(m), v = GS(), g = se(v), b = KS(), w = se(b), D = YS(), x = se(D), C = JS(), k = se(C), S = XS(), A = se(S), _ = QS(), N = se(_), $ = ZS(), L = se($), I = eE(), P = se(I), G = tE(), re = se(G), oe = rE(), ue = se(oe), pe = ot(), ke = qe(pe);
  function qe(q) {
    if (q && q.__esModule)
      return q;
    var F = {};
    if (q != null)
      for (var O in q)
        Object.prototype.hasOwnProperty.call(q, O) && (F[O] = q[O]);
    return F.default = q, F;
  }
  function se(q) {
    return q && q.__esModule ? q : { default: q };
  }
  function at(q, F) {
    if (!(q instanceof F))
      throw new TypeError("Cannot call a class as a function");
  }
  var qt = function() {
    function q(F) {
      at(this, q), this.input = F, this.lossy = F.options.lossless === !1, this.position = 0, this.root = new u.default();
      var O = new f.default();
      return this.root.append(O), this.current = O, this.lossy ? this.tokens = (0, ue.default)({ safe: F.safe, css: F.css.trim() }) : this.tokens = (0, ue.default)(F), this.loop();
    }
    return q.prototype.attribute = function() {
      var F = "", O = void 0, X = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; )
        F += this.tokens[this.position][1], this.position++;
      this.position === this.tokens.length && !~F.indexOf("]") && this.error("Expected a closing square bracket.");
      var ae = F.split(/((?:[*~^$|]?=))([^]*)/), ve = ae[0].split(/(\|)/g), Dt = { operator: ae[1], value: ae[2], source: { start: { line: X[2], column: X[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: X[4] };
      if (ve.length > 1 ? (ve[0] === "" && (ve[0] = !0), Dt.attribute = this.parseValue(ve[2]), Dt.namespace = this.parseNamespace(ve[0])) : Dt.attribute = this.parseValue(ae[0]), O = new A.default(Dt), ae[2]) {
        var wt = ae[2].split(/(\s+i\s*?)$/), Je = wt[0].trim();
        O.value = this.lossy ? Je : wt[0], wt[1] && (O.insensitive = !0, this.lossy || (O.raws.insensitive = wt[1])), O.quoted = Je[0] === "'" || Je[0] === '"', O.raws.unquoted = O.quoted ? Je.slice(1, -1) : Je;
      }
      this.newNode(O), this.position++;
    }, q.prototype.combinator = function() {
      if (this.currToken[1] === "|")
        return this.namespace();
      for (var F = new L.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); )
        this.nextToken && this.nextToken[0] === "combinator" ? (F.spaces.before = this.parseSpace(this.currToken[1]), F.source.start.line = this.nextToken[2], F.source.start.column = this.nextToken[3], F.source.end.column = this.nextToken[3], F.source.end.line = this.nextToken[2], F.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? F.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? F.value = this.currToken[1] : this.currToken[0] === "space" && (F.value = this.parseSpace(this.currToken[1], " ")), this.position++;
      return this.newNode(F);
    }, q.prototype.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = !0, this.position++;
        return;
      }
      var F = new f.default();
      this.current.parent.append(F), this.current = F, this.position++;
    }, q.prototype.comment = function() {
      var F = new y.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
      this.newNode(F), this.position++;
    }, q.prototype.error = function(F) {
      throw new this.input.error(F);
    }, q.prototype.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.");
    }, q.prototype.missingParenthesis = function() {
      return this.error("Expected opening parenthesis.");
    }, q.prototype.missingSquareBracket = function() {
      return this.error("Expected opening square bracket.");
    }, q.prototype.namespace = function() {
      var F = this.prevToken && this.prevToken[1] || !0;
      if (this.nextToken[0] === "word")
        return this.position++, this.word(F);
      if (this.nextToken[0] === "*")
        return this.position++, this.universal(F);
    }, q.prototype.nesting = function() {
      this.newNode(new P.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
    }, q.prototype.parentheses = function() {
      var F = this.current.last;
      if (F && F.type === ke.PSEUDO) {
        var O = new f.default(), X = this.current;
        F.append(O), this.current = O;
        var ae = 1;
        for (this.position++; this.position < this.tokens.length && ae; )
          this.currToken[0] === "(" && ae++, this.currToken[0] === ")" && ae--, ae ? this.parse() : (O.parent.source.end.line = this.currToken[2], O.parent.source.end.column = this.currToken[3], this.position++);
        ae && this.error("Expected closing parenthesis."), this.current = X;
      } else {
        var ve = 1;
        for (this.position++, F.value += "("; this.position < this.tokens.length && ve; )
          this.currToken[0] === "(" && ve++, this.currToken[0] === ")" && ve--, F.value += this.parseParenthesisToken(this.currToken), this.position++;
        ve && this.error("Expected closing parenthesis.");
      }
    }, q.prototype.pseudo = function() {
      for (var F = this, O = "", X = this.currToken; this.currToken && this.currToken[0] === ":"; )
        O += this.currToken[1], this.position++;
      if (!this.currToken)
        return this.error("Expected pseudo-class or pseudo-element");
      if (this.currToken[0] === "word") {
        var ae = void 0;
        this.splitWord(!1, function(ve, Dt) {
          O += ve, ae = new k.default({ value: O, source: { start: { line: X[2], column: X[3] }, end: { line: F.currToken[4], column: F.currToken[5] } }, sourceIndex: X[4] }), F.newNode(ae), Dt > 1 && F.nextToken && F.nextToken[0] === "(" && F.error("Misplaced parenthesis.");
        });
      } else
        this.error('Unexpected "' + this.currToken[0] + '" found.');
    }, q.prototype.space = function() {
      var F = this.currToken;
      this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(F[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(F[1]), this.position++) : this.combinator();
    }, q.prototype.string = function() {
      var F = this.currToken;
      this.newNode(new x.default({ value: this.currToken[1], source: { start: { line: F[2], column: F[3] }, end: { line: F[4], column: F[5] } }, sourceIndex: F[6] })), this.position++;
    }, q.prototype.universal = function(F) {
      var O = this.nextToken;
      if (O && O[1] === "|")
        return this.position++, this.namespace();
      this.newNode(new N.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), F), this.position++;
    }, q.prototype.splitWord = function(F, O) {
      for (var X = this, ae = this.nextToken, ve = this.currToken[1]; ae && ae[0] === "word"; ) {
        this.position++;
        var Dt = this.currToken[1];
        if (ve += Dt, Dt.lastIndexOf("\\") === Dt.length - 1) {
          var wt = this.nextToken;
          wt && wt[0] === "space" && (ve += this.parseSpace(wt[1], " "), this.position++);
        }
        ae = this.nextToken;
      }
      var Je = (0, o.default)(ve, "."), Er = (0, o.default)(ve, "#"), Mn = (0, o.default)(ve, "#{");
      Mn.length && (Er = Er.filter(function(Ht) {
        return !~Mn.indexOf(Ht);
      }));
      var hr = (0, re.default)((0, l.default)((0, i.default)([[0], Je, Er])));
      hr.forEach(function(Ht, Ar) {
        var Ln = hr[Ar + 1] || ve.length, rn = ve.slice(Ht, Ln);
        if (Ar === 0 && O)
          return O.call(X, rn, hr.length);
        var nn = void 0;
        ~Je.indexOf(Ht) ? nn = new p.default({ value: rn.slice(1), source: { start: { line: X.currToken[2], column: X.currToken[3] + Ht }, end: { line: X.currToken[4], column: X.currToken[3] + (Ln - 1) } }, sourceIndex: X.currToken[6] + hr[Ar] }) : ~Er.indexOf(Ht) ? nn = new g.default({ value: rn.slice(1), source: { start: { line: X.currToken[2], column: X.currToken[3] + Ht }, end: { line: X.currToken[4], column: X.currToken[3] + (Ln - 1) } }, sourceIndex: X.currToken[6] + hr[Ar] }) : nn = new w.default({ value: rn, source: { start: { line: X.currToken[2], column: X.currToken[3] + Ht }, end: { line: X.currToken[4], column: X.currToken[3] + (Ln - 1) } }, sourceIndex: X.currToken[6] + hr[Ar] }), X.newNode(nn, F);
      }), this.position++;
    }, q.prototype.word = function(F) {
      var O = this.nextToken;
      return O && O[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(F);
    }, q.prototype.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(!0);
      return this.root;
    }, q.prototype.parse = function(F) {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parentheses();
          break;
        case ")":
          F && this.missingParenthesis();
          break;
        case "[":
          this.attribute();
          break;
        case "]":
          this.missingSquareBracket();
          break;
        case "at-word":
        case "word":
          this.word();
          break;
        case ":":
          this.pseudo();
          break;
        case ";":
          this.missingBackslash();
          break;
        case ",":
          this.comma();
          break;
        case "*":
          this.universal();
          break;
        case "&":
          this.nesting();
          break;
        case "combinator":
          this.combinator();
          break;
        case "string":
          this.string();
          break;
      }
    }, q.prototype.parseNamespace = function(F) {
      if (this.lossy && typeof F == "string") {
        var O = F.trim();
        return O.length ? O : !0;
      }
      return F;
    }, q.prototype.parseSpace = function(F, O) {
      return this.lossy ? O || "" : F;
    }, q.prototype.parseValue = function(F) {
      return this.lossy && F && typeof F == "string" ? F.trim() : F;
    }, q.prototype.parseParenthesisToken = function(F) {
      return this.lossy ? F[0] === "space" ? this.parseSpace(F[1], " ") : this.parseValue(F[1]) : F[1];
    }, q.prototype.newNode = function(F, O) {
      return O && (F.namespace = this.parseNamespace(O)), this.spaces && (F.spaces.before = this.spaces, this.spaces = ""), this.current.append(F);
    }, r(q, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), q;
  }();
  t.default = qt, e.exports = t.default;
}), iE = R((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function l(c, u) {
      for (var h = 0; h < u.length; h++) {
        var f = u[h];
        f.enumerable = f.enumerable || !1, f.configurable = !0, "value" in f && (f.writable = !0), Object.defineProperty(c, f.key, f);
      }
    }
    return function(c, u, h) {
      return u && l(c.prototype, u), h && l(c, h), c;
    };
  }(), n = nE(), i = s(n);
  function s(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function o(l, c) {
    if (!(l instanceof c))
      throw new TypeError("Cannot call a class as a function");
  }
  var a = function() {
    function l(c) {
      return o(this, l), this.func = c || function() {
      }, this;
    }
    return l.prototype.process = function(c) {
      var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, h = new i.default({ css: c, error: function(f) {
        throw new Error(f);
      }, options: u });
      return this.res = h, this.func(h), this;
    }, r(l, [{ key: "result", get: function() {
      return String(this.res);
    } }]), l;
  }();
  t.default = a, e.exports = t.default;
}), ar = R((t, e) => {
  var r = function(n, i) {
    let s = new n.constructor();
    for (let o in n) {
      if (!n.hasOwnProperty(o))
        continue;
      let a = n[o], l = typeof a;
      o === "parent" && l === "object" ? i && (s[o] = i) : o === "source" ? s[o] = a : a instanceof Array ? s[o] = a.map((c) => r(c, s)) : o !== "before" && o !== "after" && o !== "between" && o !== "semicolon" && (l === "object" && a !== null && (a = r(a)), s[o] = a);
    }
    return s;
  };
  e.exports = class {
    constructor(n) {
      n = n || {}, this.raws = { before: "", after: "" };
      for (let i in n)
        this[i] = n[i];
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    toString() {
      return [this.raws.before, String(this.value), this.raws.after].join("");
    }
    clone(n) {
      n = n || {};
      let i = r(this);
      for (let s in n)
        i[s] = n[s];
      return i;
    }
    cloneBefore(n) {
      n = n || {};
      let i = this.clone(n);
      return this.parent.insertBefore(this, i), i;
    }
    cloneAfter(n) {
      n = n || {};
      let i = this.clone(n);
      return this.parent.insertAfter(this, i), i;
    }
    replaceWith() {
      let n = Array.prototype.slice.call(arguments);
      if (this.parent) {
        for (let i of n)
          this.parent.insertBefore(this, i);
        this.remove();
      }
      return this;
    }
    moveTo(n) {
      return this.cleanRaws(this.root() === n.root()), this.remove(), n.append(this), this;
    }
    moveBefore(n) {
      return this.cleanRaws(this.root() === n.root()), this.remove(), n.parent.insertBefore(n, this), this;
    }
    moveAfter(n) {
      return this.cleanRaws(this.root() === n.root()), this.remove(), n.parent.insertAfter(n, this), this;
    }
    next() {
      let n = this.parent.index(this);
      return this.parent.nodes[n + 1];
    }
    prev() {
      let n = this.parent.index(this);
      return this.parent.nodes[n - 1];
    }
    toJSON() {
      let n = {};
      for (let i in this) {
        if (!this.hasOwnProperty(i) || i === "parent")
          continue;
        let s = this[i];
        s instanceof Array ? n[i] = s.map((o) => typeof o == "object" && o.toJSON ? o.toJSON() : o) : typeof s == "object" && s.toJSON ? n[i] = s.toJSON() : n[i] = s;
      }
      return n;
    }
    root() {
      let n = this;
      for (; n.parent; )
        n = n.parent;
      return n;
    }
    cleanRaws(n) {
      delete this.raws.before, delete this.raws.after, n || delete this.raws.between;
    }
    positionInside(n) {
      let i = this.toString(), s = this.source.start.column, o = this.source.start.line;
      for (let a = 0; a < n; a++)
        i[a] === `
` ? (s = 1, o += 1) : s += 1;
      return { line: o, column: s };
    }
    positionBy(n) {
      let i = this.source.start;
      if (Object(n).index)
        i = this.positionInside(n.index);
      else if (Object(n).word) {
        let s = this.toString().indexOf(n.word);
        s !== -1 && (i = this.positionInside(s));
      }
      return i;
    }
  };
}), bt = R((t, e) => {
  var r = ar(), n = class extends r {
    constructor(i) {
      super(i), this.nodes || (this.nodes = []);
    }
    push(i) {
      return i.parent = this, this.nodes.push(i), this;
    }
    each(i) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let s = this.lastEach, o, a;
      if (this.indexes[s] = 0, !!this.nodes) {
        for (; this.indexes[s] < this.nodes.length && (o = this.indexes[s], a = i(this.nodes[o], o), a !== !1); )
          this.indexes[s] += 1;
        return delete this.indexes[s], a;
      }
    }
    walk(i) {
      return this.each((s, o) => {
        let a = i(s, o);
        return a !== !1 && s.walk && (a = s.walk(i)), a;
      });
    }
    walkType(i, s) {
      if (!i || !s)
        throw new Error("Parameters {type} and {callback} are required.");
      let o = typeof i == "function";
      return this.walk((a, l) => {
        if (o && a instanceof i || !o && a.type === i)
          return s.call(this, a, l);
      });
    }
    append(i) {
      return i.parent = this, this.nodes.push(i), this;
    }
    prepend(i) {
      return i.parent = this, this.nodes.unshift(i), this;
    }
    cleanRaws(i) {
      if (super.cleanRaws(i), this.nodes)
        for (let s of this.nodes)
          s.cleanRaws(i);
    }
    insertAfter(i, s) {
      let o = this.index(i), a;
      this.nodes.splice(o + 1, 0, s);
      for (let l in this.indexes)
        a = this.indexes[l], o <= a && (this.indexes[l] = a + this.nodes.length);
      return this;
    }
    insertBefore(i, s) {
      let o = this.index(i), a;
      this.nodes.splice(o, 0, s);
      for (let l in this.indexes)
        a = this.indexes[l], o <= a && (this.indexes[l] = a + this.nodes.length);
      return this;
    }
    removeChild(i) {
      i = this.index(i), this.nodes[i].parent = void 0, this.nodes.splice(i, 1);
      let s;
      for (let o in this.indexes)
        s = this.indexes[o], s >= i && (this.indexes[o] = s - 1);
      return this;
    }
    removeAll() {
      for (let i of this.nodes)
        i.parent = void 0;
      return this.nodes = [], this;
    }
    every(i) {
      return this.nodes.every(i);
    }
    some(i) {
      return this.nodes.some(i);
    }
    index(i) {
      return typeof i == "number" ? i : this.nodes.indexOf(i);
    }
    get first() {
      if (this.nodes)
        return this.nodes[0];
    }
    get last() {
      if (this.nodes)
        return this.nodes[this.nodes.length - 1];
    }
    toString() {
      let i = this.nodes.map(String).join("");
      return this.value && (i = this.value + i), this.raws.before && (i = this.raws.before + i), this.raws.after && (i += this.raws.after), i;
    }
  };
  n.registerWalker = (i) => {
    let s = "walk" + i.name;
    s.lastIndexOf("s") !== s.length - 1 && (s += "s"), !n.prototype[s] && (n.prototype[s] = function(o) {
      return this.walkType(i, o);
    });
  }, e.exports = n;
}), sE = R((t, e) => {
  var r = bt();
  e.exports = class extends r {
    constructor(n) {
      super(n), this.type = "root";
    }
  };
}), oE = R((t, e) => {
  var r = bt();
  e.exports = class extends r {
    constructor(n) {
      super(n), this.type = "value", this.unbalanced = 0;
    }
  };
}), aE = R((t, e) => {
  var r = bt(), n = class extends r {
    constructor(i) {
      super(i), this.type = "atword";
    }
    toString() {
      return this.quoted && this.raws.quote, [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
    }
  };
  r.registerWalker(n), e.exports = n;
}), lE = R((t, e) => {
  var r = bt(), n = ar(), i = class extends n {
    constructor(s) {
      super(s), this.type = "colon";
    }
  };
  r.registerWalker(i), e.exports = i;
}), uE = R((t, e) => {
  var r = bt(), n = ar(), i = class extends n {
    constructor(s) {
      super(s), this.type = "comma";
    }
  };
  r.registerWalker(i), e.exports = i;
}), cE = R((t, e) => {
  var r = bt(), n = ar(), i = class extends n {
    constructor(s) {
      super(s), this.type = "comment", this.inline = Object(s).inline || !1;
    }
    toString() {
      return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
    }
  };
  r.registerWalker(i), e.exports = i;
}), hE = R((t, e) => {
  var r = bt(), n = class extends r {
    constructor(i) {
      super(i), this.type = "func", this.unbalanced = -1;
    }
  };
  r.registerWalker(n), e.exports = n;
}), fE = R((t, e) => {
  var r = bt(), n = ar(), i = class extends n {
    constructor(s) {
      super(s), this.type = "number", this.unit = Object(s).unit || "";
    }
    toString() {
      return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
    }
  };
  r.registerWalker(i), e.exports = i;
}), dE = R((t, e) => {
  var r = bt(), n = ar(), i = class extends n {
    constructor(s) {
      super(s), this.type = "operator";
    }
  };
  r.registerWalker(i), e.exports = i;
}), pE = R((t, e) => {
  var r = bt(), n = ar(), i = class extends n {
    constructor(s) {
      super(s), this.type = "paren", this.parenType = "";
    }
  };
  r.registerWalker(i), e.exports = i;
}), mE = R((t, e) => {
  var r = bt(), n = ar(), i = class extends n {
    constructor(s) {
      super(s), this.type = "string";
    }
    toString() {
      let s = this.quoted ? this.raws.quote : "";
      return [this.raws.before, s, this.value + "", s, this.raws.after].join("");
    }
  };
  r.registerWalker(i), e.exports = i;
}), gE = R((t, e) => {
  var r = bt(), n = ar(), i = class extends n {
    constructor(s) {
      super(s), this.type = "word";
    }
  };
  r.registerWalker(i), e.exports = i;
}), yE = R((t, e) => {
  var r = bt(), n = ar(), i = class extends n {
    constructor(s) {
      super(s), this.type = "unicode-range";
    }
  };
  r.registerWalker(i), e.exports = i;
}), vE = R((t, e) => {
  var r = class extends Error {
    constructor(n) {
      super(n), this.name = this.constructor.name, this.message = n || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(n).stack;
    }
  };
  e.exports = r;
}), bE = R((t, e) => {
  var r = /[ \n\t\r\{\(\)'"\\;,/]/g, n = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, i = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, s = /^[a-z0-9]/i, o = /^[a-f0-9?\-]/i, a = vE();
  e.exports = function(l, c) {
    c = c || {};
    let u = [], h = l.valueOf(), f = h.length, d = -1, p = 1, m = 0, y = 0, v = null, g, b, w, D, x, C, k, S, A, _, N;
    function $(L) {
      let I = `Unclosed ${L} at line: ${p}, column: ${m - d}, token: ${m}`;
      throw new a(I);
    }
    for (; m < f; ) {
      switch (g = h.charCodeAt(m), g === 10 && (d = m, p += 1), g) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12:
          b = m;
          do
            b += 1, g = h.charCodeAt(b), g === 10 && (d = b, p += 1);
          while (g === 32 || g === 10 || g === 9 || g === 13 || g === 12);
          u.push(["space", h.slice(m, b), p, m - d, p, b - d, m]), m = b - 1;
          break;
        case 58:
          b = m + 1, u.push(["colon", h.slice(m, b), p, m - d, p, b - d, m]), m = b - 1;
          break;
        case 44:
          b = m + 1, u.push(["comma", h.slice(m, b), p, m - d, p, b - d, m]), m = b - 1;
          break;
        case 123:
          u.push(["{", "{", p, m - d, p, b - d, m]);
          break;
        case 125:
          u.push(["}", "}", p, m - d, p, b - d, m]);
          break;
        case 40:
          y++, v = !v && y === 1 && u.length > 0 && u[u.length - 1][0] === "word" && u[u.length - 1][1] === "url", u.push(["(", "(", p, m - d, p, b - d, m]);
          break;
        case 41:
          y--, v = v && y > 0, u.push([")", ")", p, m - d, p, b - d, m]);
          break;
        case 39:
        case 34:
          w = g === 39 ? "'" : '"', b = m;
          do
            for (A = !1, b = h.indexOf(w, b + 1), b === -1 && $("quote"), _ = b; h.charCodeAt(_ - 1) === 92; )
              _ -= 1, A = !A;
          while (A);
          u.push(["string", h.slice(m, b + 1), p, m - d, p, b - d, m]), m = b;
          break;
        case 64:
          r.lastIndex = m + 1, r.test(h), r.lastIndex === 0 ? b = h.length - 1 : b = r.lastIndex - 2, u.push(["atword", h.slice(m, b + 1), p, m - d, p, b - d, m]), m = b;
          break;
        case 92:
          b = m, g = h.charCodeAt(b + 1), u.push(["word", h.slice(m, b + 1), p, m - d, p, b - d, m]), m = b;
          break;
        case 43:
        case 45:
        case 42:
          if (b = m + 1, N = h.slice(m + 1, b + 1), h.slice(m - 1, m), g === 45 && N.charCodeAt(0) === 45) {
            b++, u.push(["word", h.slice(m, b), p, m - d, p, b - d, m]), m = b - 1;
            break;
          }
          u.push(["operator", h.slice(m, b), p, m - d, p, b - d, m]), m = b - 1;
          break;
        default:
          if (g === 47 && (h.charCodeAt(m + 1) === 42 || c.loose && !v && h.charCodeAt(m + 1) === 47)) {
            if (h.charCodeAt(m + 1) === 42)
              b = h.indexOf("*/", m + 2) + 1, b === 0 && $("comment");
            else {
              let L = h.indexOf(`
`, m + 2);
              b = L !== -1 ? L - 1 : f;
            }
            C = h.slice(m, b + 1), D = C.split(`
`), x = D.length - 1, x > 0 ? (k = p + x, S = b - D[x].length) : (k = p, S = d), u.push(["comment", C, p, m - d, k, b - S, m]), d = S, p = k, m = b;
          } else if (g === 35 && !s.test(h.slice(m + 1, m + 2)))
            b = m + 1, u.push(["#", h.slice(m, b), p, m - d, p, b - d, m]), m = b - 1;
          else if ((g === 117 || g === 85) && h.charCodeAt(m + 1) === 43) {
            b = m + 2;
            do
              b += 1, g = h.charCodeAt(b);
            while (b < f && o.test(h.slice(b, b + 1)));
            u.push(["unicoderange", h.slice(m, b), p, m - d, p, b - d, m]), m = b - 1;
          } else if (g === 47)
            b = m + 1, u.push(["operator", h.slice(m, b), p, m - d, p, b - d, m]), m = b - 1;
          else {
            let L = n;
            if (g >= 48 && g <= 57 && (L = i), L.lastIndex = m + 1, L.test(h), L.lastIndex === 0 ? b = h.length - 1 : b = L.lastIndex - 2, L === i || g === 46) {
              let I = h.charCodeAt(b), P = h.charCodeAt(b + 1), G = h.charCodeAt(b + 2);
              (I === 101 || I === 69) && (P === 45 || P === 43) && G >= 48 && G <= 57 && (i.lastIndex = b + 2, i.test(h), i.lastIndex === 0 ? b = h.length - 1 : b = i.lastIndex - 2);
            }
            u.push(["word", h.slice(m, b + 1), p, m - d, p, b - d, m]), m = b;
          }
          break;
      }
      m++;
    }
    return u;
  };
}), DE = R((t, e) => {
  var r = class extends Error {
    constructor(n) {
      super(n), this.name = this.constructor.name, this.message = n || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(n).stack;
    }
  };
  e.exports = r;
}), wE = R((t, e) => {
  var r = sE(), n = oE(), i = aE(), s = lE(), o = uE(), a = cE(), l = hE(), c = fE(), u = dE(), h = pE(), f = mE(), d = gE(), p = yE(), m = bE(), y = Qg(), v = Zg(), g = e0(), b = DE();
  function w(D) {
    return D.sort((x, C) => x - C);
  }
  e.exports = class {
    constructor(D, x) {
      let C = { loose: !1 };
      this.cache = [], this.input = D, this.options = Object.assign({}, C, x), this.position = 0, this.unbalanced = 0, this.root = new r();
      let k = new n();
      this.root.append(k), this.current = k, this.tokens = m(D, this.options);
    }
    parse() {
      return this.loop();
    }
    colon() {
      let D = this.currToken;
      this.newNode(new s({ value: D[1], source: { start: { line: D[2], column: D[3] }, end: { line: D[4], column: D[5] } }, sourceIndex: D[6] })), this.position++;
    }
    comma() {
      let D = this.currToken;
      this.newNode(new o({ value: D[1], source: { start: { line: D[2], column: D[3] }, end: { line: D[4], column: D[5] } }, sourceIndex: D[6] })), this.position++;
    }
    comment() {
      let D = !1, x = this.currToken[1].replace(/\/\*|\*\//g, ""), C;
      this.options.loose && x.startsWith("//") && (x = x.substring(2), D = !0), C = new a({ value: x, inline: D, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] }), this.newNode(C), this.position++;
    }
    error(D, x) {
      throw new b(D + ` at line: ${x[2]}, column ${x[3]}`);
    }
    loop() {
      for (; this.position < this.tokens.length; )
        this.parseTokens();
      return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
    }
    operator() {
      let D = this.currToken[1], x;
      if (D === "+" || D === "-") {
        if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? this.prevToken[0] !== "space" && this.prevToken[0] !== "(" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "word" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(" && this.error("Syntax Error", this.currToken) : (this.nextToken[0] === "space" || this.nextToken[0] === "operator" || this.prevToken[0] === "operator") && this.error("Syntax Error", this.currToken)), this.options.loose) {
          if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word")
            return this.word();
        } else if (this.nextToken[0] === "word")
          return this.word();
      }
      return x = new u({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), this.position++, this.newNode(x);
    }
    parseTokens() {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "colon":
          this.colon();
          break;
        case "comma":
          this.comma();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parenOpen();
          break;
        case ")":
          this.parenClose();
          break;
        case "atword":
        case "word":
          this.word();
          break;
        case "operator":
          this.operator();
          break;
        case "string":
          this.string();
          break;
        case "unicoderange":
          this.unicodeRange();
          break;
        default:
          this.word();
          break;
      }
    }
    parenOpen() {
      let D = 1, x = this.position + 1, C = this.currToken, k;
      for (; x < this.tokens.length && D; ) {
        let S = this.tokens[x];
        S[0] === "(" && D++, S[0] === ")" && D--, x++;
      }
      if (D && this.error("Expected closing parenthesis", C), k = this.current.last, k && k.type === "func" && k.unbalanced < 0 && (k.unbalanced = 0, this.current = k), this.current.unbalanced++, this.newNode(new h({ value: C[1], source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6] })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
        let S = this.nextToken, A = this.currToken[1], _ = { line: this.currToken[2], column: this.currToken[3] };
        for (; S && S[0] !== ")" && this.current.unbalanced; )
          this.position++, A += this.currToken[1], S = this.nextToken;
        this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new d({ value: A, source: { start: _, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
      }
    }
    parenClose() {
      let D = this.currToken;
      this.newNode(new h({ value: D[1], source: { start: { line: D[2], column: D[3] }, end: { line: D[4], column: D[5] } }, sourceIndex: D[6] })), this.position++, !(this.position >= this.tokens.length - 1 && !this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", D), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
    }
    space() {
      let D = this.currToken;
      this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += D[1], this.position++) : (this.spaces = D[1], this.position++);
    }
    unicodeRange() {
      let D = this.currToken;
      this.newNode(new p({ value: D[1], source: { start: { line: D[2], column: D[3] }, end: { line: D[4], column: D[5] } }, sourceIndex: D[6] })), this.position++;
    }
    splitWord() {
      let D = this.nextToken, x = this.currToken[1], C = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/, k = /^(?!\#([a-z0-9]+))[\#\{\}]/gi, S, A;
      if (!k.test(x))
        for (; D && D[0] === "word"; ) {
          this.position++;
          let _ = this.currToken[1];
          x += _, D = this.nextToken;
        }
      S = v(x, "@"), A = w(g(y([[0], S]))), A.forEach((_, N) => {
        let $ = A[N + 1] || x.length, L = x.slice(_, $), I;
        if (~S.indexOf(_))
          I = new i({ value: L.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + _ }, end: { line: this.currToken[4], column: this.currToken[3] + ($ - 1) } }, sourceIndex: this.currToken[6] + A[N] });
        else if (C.test(this.currToken[1])) {
          let P = L.replace(C, "");
          I = new c({ value: L.replace(P, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + _ }, end: { line: this.currToken[4], column: this.currToken[3] + ($ - 1) } }, sourceIndex: this.currToken[6] + A[N], unit: P });
        } else
          I = new (D && D[0] === "(" ? l : d)({ value: L, source: { start: { line: this.currToken[2], column: this.currToken[3] + _ }, end: { line: this.currToken[4], column: this.currToken[3] + ($ - 1) } }, sourceIndex: this.currToken[6] + A[N] }), I.type === "word" ? (I.isHex = /^#(.+)/.test(L), I.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(L)) : this.cache.push(this.current);
        this.newNode(I);
      }), this.position++;
    }
    string() {
      let D = this.currToken, x = this.currToken[1], C = /^(\"|\')/, k = C.test(x), S = "", A;
      k && (S = x.match(C)[0], x = x.slice(1, x.length - 1)), A = new f({ value: x, source: { start: { line: D[2], column: D[3] }, end: { line: D[4], column: D[5] } }, sourceIndex: D[6], quoted: k }), A.raws.quote = S, this.newNode(A), this.position++;
    }
    word() {
      return this.splitWord();
    }
    newNode(D) {
      return this.spaces && (D.raws.before += this.spaces, this.spaces = ""), this.current.append(D);
    }
    get currToken() {
      return this.tokens[this.position];
    }
    get nextToken() {
      return this.tokens[this.position + 1];
    }
    get prevToken() {
      return this.tokens[this.position - 1];
    }
  };
}), t0 = {};
$g(t0, { languages: () => dF, options: () => gF, parsers: () => B0, printers: () => JF });
var xE = (t, e, r, n) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
}, Ne = xE, r0 = "string", n0 = "array", i0 = "cursor", hh = "indent", fh = "align", s0 = "trim", dh = "group", ss = "fill", Ga = "if-break", o0 = "indent-if-break", a0 = "line-suffix", l0 = "line-suffix-boundary", bi = "line", u0 = "label", ph = "break-parent", c0 = /* @__PURE__ */ new Set([i0, hh, fh, s0, dh, ss, Ga, o0, a0, l0, bi, u0, ph]);
function CE(t) {
  if (typeof t == "string")
    return r0;
  if (Array.isArray(t))
    return n0;
  if (!t)
    return;
  let { type: e } = t;
  if (c0.has(e))
    return e;
}
var h0 = CE, kE = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function SE(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (h0(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = kE([...c0].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`;
}
var EE = class extends Error {
  constructor(e) {
    super(SE(e));
    Tr(this, "name", "InvalidDocError");
    this.doc = e;
  }
}, AE = EE, FE = () => {
}, TE = FE;
function ut(t) {
  return { type: hh, contents: t };
}
function f0(t, e) {
  return { type: fh, contents: e, n: t };
}
function kt(t, e = {}) {
  return TE(e.expandedStates), { type: dh, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function _E(t) {
  return f0({ type: "root" }, t);
}
function zo(t) {
  return f0(-1, t);
}
function gu(t) {
  return { type: ss, parts: t };
}
function d0(t, e = "", r = {}) {
  return { type: Ga, breakContents: t, flatContents: e, groupId: r.groupId };
}
var mh = { type: ph }, BE = { type: bi, hard: !0 }, Xe = { type: bi }, Pt = { type: bi, soft: !0 }, Ce = [BE, mh];
function dn(t, e) {
  let r = [];
  for (let n = 0; n < e.length; n++)
    n !== 0 && r.push(t), r.push(e[n]);
  return r;
}
var OE = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, os = OE, ME = (t) => {
  if (Array.isArray(t))
    return t;
  if (t.type !== ss)
    throw new Error(`Expect doc to be 'array' or '${ss}'.`);
  return t.parts;
};
function LE(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return n(t);
  function n(s) {
    if (r.has(s))
      return r.get(s);
    let o = i(s);
    return r.set(s, o), o;
  }
  function i(s) {
    switch (h0(s)) {
      case n0:
        return e(s.map(n));
      case ss:
        return e({ ...s, parts: s.parts.map(n) });
      case Ga:
        return e({ ...s, breakContents: n(s.breakContents), flatContents: n(s.flatContents) });
      case dh: {
        let { expandedStates: o, contents: a } = s;
        return o ? (o = o.map(n), a = o[0]) : a = n(a), e({ ...s, contents: a, expandedStates: o });
      }
      case fh:
      case hh:
      case o0:
      case u0:
      case a0:
        return e({ ...s, contents: n(s.contents) });
      case r0:
      case i0:
      case s0:
      case l0:
      case bi:
      case ph:
        return e(s);
      default:
        throw new AE(s);
    }
  }
}
function PE(t) {
  return t.type === bi && !t.hard ? t.soft ? "" : " " : t.type === Ga ? t.flatContents : t;
}
function NE(t) {
  return LE(t, PE);
}
function RE(t) {
  return Array.isArray(t) && t.length > 0;
}
var Ka = RE, Ks = "'", td = '"';
function IE(t, e) {
  let r = e === !0 || e === Ks ? Ks : td, n = r === Ks ? td : Ks, i = 0, s = 0;
  for (let o of t)
    o === r ? i++ : o === n && s++;
  return i > s ? n : r;
}
var $E = IE;
function jE(t, e, r) {
  let n = e === '"' ? "'" : '"', i = Ne(!1, t, /\\(.)|(["'])/gs, (s, o, a) => o === n ? o : a === e ? "\\" + a : a || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(o) ? o : "\\" + o));
  return e + i + e;
}
var WE = jE;
function qE(t, e) {
  let r = t.slice(1, -1), n = e.parser === "json" || e.parser === "jsonc" || e.parser === "json5" && e.quoteProps === "preserve" && !e.singleQuote ? '"' : e.__isInHtmlAttribute ? "'" : $E(r, e.singleQuote);
  return WE(r, n, !(e.parser === "css" || e.parser === "less" || e.parser === "scss" || e.__embeddedInHtml));
}
var p0 = qE, HE = class extends Error {
  constructor(e, r, n = "type") {
    super(`Unexpected ${r} node ${n}: ${JSON.stringify(e[n])}.`);
    Tr(this, "name", "UnexpectedNodeError");
    this.node = e;
  }
}, VE = HE;
function zE(t) {
  return (t == null ? void 0 : t.type) === "front-matter";
}
var Uo = zE, UE = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma", "spaces"]);
function m0(t, e, r) {
  if (Uo(t) && t.lang === "yaml" && delete e.value, t.type === "css-comment" && r.type === "css-root" && r.nodes.length > 0 && ((r.nodes[0] === t || Uo(r.nodes[0]) && r.nodes[1] === t) && (delete e.text, /^\*\s*@(?:format|prettier)\s*$/.test(t.text)) || r.type === "css-root" && os(!1, r.nodes, -1) === t))
    return null;
  if (t.type === "value-root" && delete e.text, (t.type === "media-query" || t.type === "media-query-list" || t.type === "media-feature-expression") && delete e.value, t.type === "css-rule" && delete e.params, t.type === "selector-combinator" && (e.value = Ne(!1, e.value, /\s+/g, " ")), t.type === "media-feature" && (e.value = Ne(!1, e.value, " ", "")), (t.type === "value-word" && (t.isColor && t.isHex || ["initial", "inherit", "unset", "revert"].includes(e.value.toLowerCase())) || t.type === "media-feature" || t.type === "selector-root-invalid" || t.type === "selector-pseudo") && (e.value = e.value.toLowerCase()), t.type === "css-decl" && (e.prop = e.prop.toLowerCase()), (t.type === "css-atrule" || t.type === "css-import") && (e.name = e.name.toLowerCase()), t.type === "value-number" && (e.unit = e.unit.toLowerCase()), t.type === "value-unknown" && (e.value = Ne(!1, e.value, /;$/g, "")), (t.type === "media-feature" || t.type === "media-keyword" || t.type === "media-type" || t.type === "media-unknown" || t.type === "media-url" || t.type === "media-value" || t.type === "selector-attribute" || t.type === "selector-string" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "value-string") && e.value && (e.value = GE(e.value)), t.type === "selector-attribute" && (e.attribute = e.attribute.trim(), e.namespace && typeof e.namespace == "string" && (e.namespace = e.namespace.trim(), e.namespace.length === 0 && (e.namespace = !0)), e.value && (e.value = Ne(!1, e.value.trim(), /^["']|["']$/g, ""), delete e.quoted)), (t.type === "media-value" || t.type === "media-type" || t.type === "value-number" || t.type === "selector-root-invalid" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "selector-tag") && e.value && (e.value = Ne(!1, e.value, /([\d+.e-]+)([a-z]*)/gi, (n, i, s) => {
    let o = Number(i);
    return Number.isNaN(o) ? n : o + s.toLowerCase();
  })), t.type === "selector-tag") {
    let n = t.value.toLowerCase();
    ["from", "to"].includes(n) && (e.value = n);
  }
  if (t.type === "css-atrule" && t.name.toLowerCase() === "supports" && delete e.value, t.type === "selector-unknown" && delete e.value, t.type === "value-comma_group") {
    let n = t.groups.findIndex((i) => i.type === "value-number" && i.unit === "...");
    n !== -1 && (e.groups[n].unit = "", e.groups.splice(n + 1, 0, { type: "value-word", value: "...", isColor: !1, isHex: !1 }));
  }
  if (t.type === "value-comma_group" && t.groups.some((n) => n.type === "value-atword" && n.value.endsWith("[") || n.type === "value-word" && n.value.startsWith("]")))
    return { type: "value-atword", value: t.groups.map((n) => n.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
}
m0.ignoredProperties = UE;
function GE(t) {
  return Ne(!1, Ne(!1, t, "'", '"'), /\\([^\da-f])/gi, "$1");
}
var KE = m0;
async function YE(t, e) {
  if (t.lang === "yaml") {
    let r = t.value.trim(), n = r ? await e(r, { parser: "yaml" }) : "";
    return _E([t.startDelimiter, Ce, n, n ? Ce : "", t.endDelimiter]);
  }
}
var JE = YE;
function g0(t) {
  let { node: e } = t;
  if (e.type === "front-matter")
    return async (r) => {
      let n = await JE(e, r);
      return n ? [n, Ce] : void 0;
    };
}
g0.getVisitorKeys = (t) => t.type === "css-root" ? ["frontMatter"] : [];
var XE = g0, Fi = null;
function Ji(t) {
  if (Fi !== null && typeof Fi.property) {
    let e = Fi;
    return Fi = Ji.prototype = null, e;
  }
  return Fi = Ji.prototype = t ?? /* @__PURE__ */ Object.create(null), new Ji();
}
var QE = 10;
for (let t = 0; t <= QE; t++)
  Ji();
function ZE(t) {
  return Ji(t);
}
function eA(t, e = "type") {
  ZE(t);
  function r(n) {
    let i = n[e], s = t[i];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: n });
    return s;
  }
  return r;
}
var tA = eA, rA = { "front-matter": [], "css-root": ["frontMatter", "nodes"], "css-comment": [], "css-rule": ["selector", "nodes"], "css-decl": ["value", "selector", "nodes"], "css-atrule": ["selector", "params", "value", "nodes"], "media-query-list": ["nodes"], "media-query": ["nodes"], "media-type": [], "media-feature-expression": ["nodes"], "media-feature": [], "media-colon": [], "media-value": [], "media-keyword": [], "media-url": [], "media-unknown": [], "selector-root": ["nodes"], "selector-selector": ["nodes"], "selector-comment": [], "selector-string": [], "selector-tag": [], "selector-id": [], "selector-class": [], "selector-attribute": [], "selector-combinator": ["nodes"], "selector-universal": [], "selector-pseudo": ["nodes"], "selector-nesting": [], "selector-unknown": [], "value-value": ["group"], "value-root": ["group"], "value-comment": [], "value-comma_group": ["groups"], "value-paren_group": ["open", "groups", "close"], "value-func": ["group"], "value-paren": [], "value-number": [], "value-operator": [], "value-word": [], "value-colon": [], "value-comma": [], "value-string": [], "value-atword": [], "value-unicode-range": [], "value-unknown": [] }, nA = rA, iA = tA(nA), sA = iA;
function oA(t, e) {
  let r = 0;
  for (let n = 0; n < t.line - 1; ++n)
    r = e.indexOf(`
`, r) + 1;
  return r + t.column;
}
var y0 = oA;
function gh(t) {
  return (e, r, n) => {
    let i = !!(n != null && n.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, o = r;
    for (; o >= 0 && o < s; ) {
      let a = e.charAt(o);
      if (t instanceof RegExp) {
        if (!t.test(a))
          return o;
      } else if (!t.includes(a))
        return o;
      i ? o-- : o++;
    }
    return o === -1 || o === s ? o : !1;
  };
}
var v0 = gh(" 	"), aA = gh(",; 	"), b0 = gh(/[^\n\r]/);
function D0(t, e) {
  var r, n, i;
  if (typeof ((n = (r = t.source) == null ? void 0 : r.start) == null ? void 0 : n.offset) == "number")
    return t.source.start.offset;
  if (typeof t.sourceIndex == "number")
    return t.sourceIndex;
  if ((i = t.source) != null && i.start)
    return y0(t.source.start, e);
  throw Object.assign(new Error("Can not locate node."), { node: t });
}
function yh(t, e) {
  var r, n;
  if (t.type === "css-comment" && t.inline)
    return b0(e, t.source.startOffset);
  if (typeof ((n = (r = t.source) == null ? void 0 : r.end) == null ? void 0 : n.offset) == "number")
    return t.source.end.offset;
  if (t.source) {
    if (t.source.end)
      return y0(t.source.end, e);
    if (Ka(t.nodes))
      return yh(os(!1, t.nodes, -1), e);
  }
  return null;
}
function w0(t, e) {
  t.source && (t.source.startOffset = D0(t, e), t.source.endOffset = yh(t, e));
  for (let r in t) {
    let n = t[r];
    r === "source" || !n || typeof n != "object" || (n.type === "value-root" || n.type === "value-unknown" ? x0(n, lA(t), n.text || n.value) : w0(n, e));
  }
}
function x0(t, e, r) {
  t.source && (t.source.startOffset = D0(t, r) + e, t.source.endOffset = yh(t, r) + e);
  for (let n in t) {
    let i = t[n];
    n === "source" || !i || typeof i != "object" || x0(i, e, r);
  }
}
function lA(t) {
  var e;
  let r = t.source.startOffset;
  return typeof t.prop == "string" && (r += t.prop.length), t.type === "css-atrule" && typeof t.name == "string" && (r += 1 + t.name.length + t.raws.afterName.match(/^\s*:?\s*/)[0].length), t.type !== "css-atrule" && typeof ((e = t.raws) == null ? void 0 : e.between) == "string" && (r += t.raws.between.length), r;
}
function uA(t) {
  let e = "initial", r = "initial", n, i = !1, s = [];
  for (let o = 0; o < t.length; o++) {
    let a = t[o];
    switch (e) {
      case "initial":
        if (a === "'") {
          e = "single-quotes";
          continue;
        }
        if (a === '"') {
          e = "double-quotes";
          continue;
        }
        if ((a === "u" || a === "U") && t.slice(o, o + 4).toLowerCase() === "url(") {
          e = "url", o += 3;
          continue;
        }
        if (a === "*" && t[o - 1] === "/") {
          e = "comment-block";
          continue;
        }
        if (a === "/" && t[o - 1] === "/") {
          e = "comment-inline", n = o - 1;
          continue;
        }
        continue;
      case "single-quotes":
        if (a === "'" && t[o - 1] !== "\\" && (e = r, r = "initial"), a === `
` || a === "\r")
          return t;
        continue;
      case "double-quotes":
        if (a === '"' && t[o - 1] !== "\\" && (e = r, r = "initial"), a === `
` || a === "\r")
          return t;
        continue;
      case "url":
        if (a === ")" && (e = "initial"), a === `
` || a === "\r")
          return t;
        if (a === "'") {
          e = "single-quotes", r = "url";
          continue;
        }
        if (a === '"') {
          e = "double-quotes", r = "url";
          continue;
        }
        continue;
      case "comment-block":
        a === "/" && t[o - 1] === "*" && (e = "initial");
        continue;
      case "comment-inline":
        (a === '"' || a === "'" || a === "*") && (i = !0), (a === `
` || a === "\r") && (i && s.push([n, o]), e = "initial", i = !1);
        continue;
    }
  }
  for (let [o, a] of s)
    t = t.slice(0, o) + Ne(!1, t.slice(o, a), /["'*]/g, " ") + t.slice(a);
  return t;
}
function pt(t) {
  var e;
  return (e = t.source) == null ? void 0 : e.startOffset;
}
function ft(t) {
  var e;
  return (e = t.source) == null ? void 0 : e.endOffset;
}
var Go = Bn(xS(), 1);
function cA(t) {
  if (!t.startsWith("#!"))
    return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var hA = cA;
function C0(t) {
  let e = hA(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, Go.extract)(t), { pragmas: n, comments: i } = (0, Go.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: n, comments: i };
}
function fA(t) {
  let { pragmas: e } = C0(t);
  return Object.prototype.hasOwnProperty.call(e, "prettier") || Object.prototype.hasOwnProperty.call(e, "format");
}
function dA(t) {
  let { shebang: e, text: r, pragmas: n, comments: i } = C0(t), s = (0, Go.strip)(r), o = (0, Go.print)({ pragmas: { format: "", ...n }, comments: i.trimStart() });
  return (e ? `${e}
` : "") + o + (s.startsWith(`
`) ? `
` : `

`) + s;
}
var pA = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
function mA(t) {
  let e = t.match(pA);
  if (!e)
    return { content: t };
  let { startDelimiter: r, language: n, value: i = "", endDelimiter: s } = e.groups, o = n.trim() || "yaml";
  if (r === "+++" && (o = "toml"), o !== "yaml" && r !== s)
    return { content: t };
  let [a] = e;
  return { frontMatter: { type: "front-matter", lang: o, value: i, startDelimiter: r, endDelimiter: s, raw: a.replace(/\n$/, "") }, content: Ne(!1, a, /[^\n]/g, " ") + t.slice(a.length) };
}
var vh = mA;
function gA(t) {
  return fA(vh(t).content);
}
function yA(t) {
  let { frontMatter: e, content: r } = vh(t);
  return (e ? e.raw + `

` : "") + dA(r);
}
var vA = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
function bA(t) {
  var e, r;
  return (r = (e = t.findAncestor((n) => n.type === "css-decl")) == null ? void 0 : e.prop) == null ? void 0 : r.toLowerCase();
}
var DA = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
function wA(t) {
  return DA.has(t.toLowerCase());
}
function xA(t, e) {
  var r;
  let n = t.findAncestor((i) => i.type === "css-atrule");
  return ((r = n == null ? void 0 : n.name) == null ? void 0 : r.toLowerCase().endsWith("keyframes")) && ["from", "to"].includes(e.toLowerCase());
}
function Hn(t) {
  return t.includes("$") || t.includes("@") || t.includes("#") || t.startsWith("%") || t.startsWith("--") || t.startsWith(":--") || t.includes("(") && t.includes(")") ? t : t.toLowerCase();
}
function Eo(t, e) {
  var r;
  let n = t.findAncestor((i) => i.type === "value-func");
  return ((r = n == null ? void 0 : n.value) == null ? void 0 : r.toLowerCase()) === e;
}
function CA(t) {
  var e;
  let r = t.findAncestor((i) => i.type === "css-rule"), n = (e = r == null ? void 0 : r.raws) == null ? void 0 : e.selector;
  return n && (n.startsWith(":import") || n.startsWith(":export"));
}
function Ao(t, e) {
  let r = Array.isArray(e) ? e : [e], n = t.findAncestor((i) => i.type === "css-atrule");
  return n && r.includes(n.name.toLowerCase());
}
function kA(t) {
  var e;
  let { node: r } = t;
  return r.groups[0].value === "url" && r.groups.length === 2 && ((e = t.findAncestor((n) => n.type === "css-atrule")) == null ? void 0 : e.name) === "import";
}
function SA(t) {
  return t.type === "value-func" && t.value.toLowerCase() === "url";
}
function EA(t) {
  return t.type === "value-func" && t.value.toLowerCase() === "var";
}
function kl(t, e) {
  var r;
  let n = (r = t.parent) == null ? void 0 : r.nodes;
  return n && n.indexOf(e) === n.length - 1;
}
function AA(t) {
  let { selector: e } = t;
  return e ? typeof e == "string" && /^@.+:.*$/.test(e) || e.value && /^@.+:.*$/.test(e.value) : !1;
}
function FA(t) {
  return t.type === "value-word" && ["from", "through", "end"].includes(t.value);
}
function TA(t) {
  return t.type === "value-word" && ["and", "or", "not"].includes(t.value);
}
function _A(t) {
  return t.type === "value-word" && t.value === "in";
}
function yu(t) {
  return t.type === "value-operator" && t.value === "*";
}
function Fo(t) {
  return t.type === "value-operator" && t.value === "/";
}
function Or(t) {
  return t.type === "value-operator" && t.value === "+";
}
function Vn(t) {
  return t.type === "value-operator" && t.value === "-";
}
function BA(t) {
  return t.type === "value-operator" && t.value === "%";
}
function Sl(t) {
  return yu(t) || Fo(t) || Or(t) || Vn(t) || BA(t);
}
function OA(t) {
  return t.type === "value-word" && ["==", "!="].includes(t.value);
}
function MA(t) {
  return t.type === "value-word" && ["<", ">", "<=", ">="].includes(t.value);
}
function vu(t, e) {
  return e.parser === "scss" && t.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(t.name);
}
function rd(t) {
  var e;
  return ((e = t.raws) == null ? void 0 : e.params) && /^\(\s*\)$/.test(t.raws.params);
}
function El(t) {
  return t.name.startsWith("prettier-placeholder");
}
function LA(t) {
  return t.prop.startsWith("@prettier-placeholder");
}
function PA(t, e) {
  return t.value === "$$" && t.type === "value-func" && (e == null ? void 0 : e.type) === "value-word" && !e.raws.before;
}
function NA(t) {
  var e, r;
  return ((e = t.value) == null ? void 0 : e.type) === "value-root" && ((r = t.value.group) == null ? void 0 : r.type) === "value-value" && t.prop.toLowerCase() === "composes";
}
function RA(t) {
  var e, r, n;
  return ((n = (r = (e = t.value) == null ? void 0 : e.group) == null ? void 0 : r.group) == null ? void 0 : n.type) === "value-paren_group" && t.value.group.group.open !== null && t.value.group.group.close !== null;
}
function $n(t) {
  var e;
  return ((e = t.raws) == null ? void 0 : e.before) === "";
}
function bh(t) {
  var e, r;
  return t.type === "value-comma_group" && ((r = (e = t.groups) == null ? void 0 : e[1]) == null ? void 0 : r.type) === "value-colon";
}
function Al(t) {
  var e;
  return t.type === "value-paren_group" && ((e = t.groups) == null ? void 0 : e[0]) && bh(t.groups[0]);
}
function k0(t, e) {
  var r;
  if (e.parser !== "scss")
    return !1;
  let { node: n } = t;
  if (n.groups.length === 0)
    return !1;
  let i = t.grandparent;
  if (!Al(n) && !(i && Al(i)))
    return !1;
  let s = t.findAncestor((o) => o.type === "css-decl");
  return !!((r = s == null ? void 0 : s.prop) != null && r.startsWith("$") || Al(i) || i.type === "value-func");
}
function nd(t) {
  return t.type === "value-comment" && t.inline;
}
function Fl(t) {
  return t.type === "value-word" && t.value === "#";
}
function id(t) {
  return t.type === "value-word" && t.value === "{";
}
function Tl(t) {
  return t.type === "value-word" && t.value === "}";
}
function Ys(t) {
  return ["value-word", "value-atword"].includes(t.type);
}
function bu(t) {
  return (t == null ? void 0 : t.type) === "value-colon";
}
function IA(t, e) {
  if (!bh(e))
    return !1;
  let { groups: r } = e, n = r.indexOf(t);
  return n === -1 ? !1 : bu(r[n + 1]);
}
function $A(t) {
  return t.value && ["not", "and", "or"].includes(t.value.toLowerCase());
}
function jA(t) {
  return t.type !== "value-func" ? !1 : vA.has(t.value.toLowerCase());
}
function Ti(t) {
  return /\/\//.test(t.split(/[\n\r]/).pop());
}
function Js(t) {
  return (t == null ? void 0 : t.type) === "value-atword" && t.value.startsWith("prettier-placeholder-");
}
function WA(t, e) {
  var r, n;
  if (((r = t.open) == null ? void 0 : r.value) !== "(" || ((n = t.close) == null ? void 0 : n.value) !== ")" || t.groups.some((i) => i.type !== "value-comma_group"))
    return !1;
  if (e.type === "value-comma_group") {
    let i = e.groups.indexOf(t) - 1, s = e.groups[i];
    if ((s == null ? void 0 : s.type) === "value-word" && s.value === "with")
      return !0;
  }
  return !1;
}
function Xs(t) {
  var e, r;
  return t.type === "value-paren_group" && ((e = t.open) == null ? void 0 : e.value) === "(" && ((r = t.close) == null ? void 0 : r.value) === ")";
}
function qA(t, e, r) {
  var n;
  let { node: i } = t, s = t.parent, o = t.grandparent, a = bA(t), l = a && s.type === "value-value" && (a === "grid" || a.startsWith("grid-template")), c = t.findAncestor((v) => v.type === "css-atrule"), u = c && vu(c, e), h = i.groups.some((v) => nd(v)), f = t.map(r, "groups"), d = [], p = Eo(t, "url"), m = !1, y = !1;
  for (let v = 0; v < i.groups.length; ++v) {
    d.push(f[v]);
    let g = i.groups[v - 1], b = i.groups[v], w = i.groups[v + 1], D = i.groups[v + 2];
    if (p) {
      (w && Or(w) || Or(b)) && d.push(" ");
      continue;
    }
    if (Ao(t, "forward") && b.type === "value-word" && b.value && g !== void 0 && g.type === "value-word" && g.value === "as" && w.type === "value-operator" && w.value === "*" || !w || b.type === "value-word" && b.value.endsWith("-") && Js(w))
      continue;
    if (b.type === "value-string" && b.quoted) {
      let _ = b.value.lastIndexOf("#{"), N = b.value.lastIndexOf("}");
      _ !== -1 && N !== -1 ? m = _ > N : _ !== -1 ? m = !0 : N !== -1 && (m = !1);
    }
    if (m || bu(b) || bu(w) || b.type === "value-atword" && (b.value === "" || b.value.endsWith("[")) || w.type === "value-word" && w.value.startsWith("]") || b.value === "~" || b.type !== "value-string" && b.value && b.value.includes("\\") && w && w.type !== "value-comment" || g != null && g.value && g.value.indexOf("\\") === g.value.length - 1 && b.type === "value-operator" && b.value === "/" || b.value === "\\" || PA(b, w) || Fl(b) || id(b) || Tl(w) || id(w) && $n(w) || Tl(b) && $n(w) || b.value === "--" && Fl(w))
      continue;
    let x = Sl(b), C = Sl(w);
    if ((x && Fl(w) || C && Tl(b)) && $n(w) || !g && Fo(b) || Eo(t, "calc") && (Or(b) || Or(w) || Vn(b) || Vn(w)) && $n(w))
      continue;
    let k = (Or(b) || Vn(b)) && v === 0 && (w.type === "value-number" || w.isHex) && o && jA(o) && !$n(w), S = (D == null ? void 0 : D.type) === "value-func" || D && Ys(D) || b.type === "value-func" || Ys(b), A = w.type === "value-func" || Ys(w) || (g == null ? void 0 : g.type) === "value-func" || g && Ys(g);
    if (e.parser === "scss" && x && b.value === "-" && w.type === "value-func" && ft(b) !== pt(w)) {
      d.push(" ");
      continue;
    }
    if (!(!(yu(w) || yu(b)) && !Eo(t, "calc") && !k && (Fo(w) && !S || Fo(b) && !A || Or(w) && !S || Or(b) && !A || Vn(w) || Vn(b)) && ($n(w) || x && (!g || g && Sl(g)))) && !((e.parser === "scss" || e.parser === "less") && x && b.value === "-" && Xs(w) && ft(b) === pt(w.open) && w.open.value === "(")) {
      if (nd(b)) {
        if (s.type === "value-paren_group") {
          d.push(zo(Ce));
          continue;
        }
        d.push(Ce);
        continue;
      }
      if (u && (OA(w) || MA(w) || TA(w) || _A(b) || FA(b))) {
        d.push(" ");
        continue;
      }
      if (c && c.name.toLowerCase() === "namespace") {
        d.push(" ");
        continue;
      }
      if (l) {
        b.source && w.source && b.source.start.line !== w.source.start.line ? (d.push(Ce), y = !0) : d.push(" ");
        continue;
      }
      if (C) {
        d.push(" ");
        continue;
      }
      if ((w == null ? void 0 : w.value) !== "..." && !(Js(b) && Js(w) && ft(b) === pt(w))) {
        if (Js(b) && Xs(w) && ft(b) === pt(w.open)) {
          d.push(Pt);
          continue;
        }
        if (b.value === "with" && Xs(w)) {
          d.push(" ");
          continue;
        }
        (n = b.value) != null && n.endsWith("#") && w.value === "{" && Xs(w.group) || d.push(Xe);
      }
    }
  }
  return h && d.push(mh), y && d.unshift(Ce), u ? kt(ut(d)) : kA(t) ? kt(gu(d)) : kt(ut(gu(d)));
}
var HA = qA;
function VA(t) {
  return t.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
}
var zA = VA, sd = /* @__PURE__ */ new Map([["em", "em"], ["rem", "rem"], ["ex", "ex"], ["rex", "rex"], ["cap", "cap"], ["rcap", "rcap"], ["ch", "ch"], ["rch", "rch"], ["ic", "ic"], ["ric", "ric"], ["lh", "lh"], ["rlh", "rlh"], ["vw", "vw"], ["svw", "svw"], ["lvw", "lvw"], ["dvw", "dvw"], ["vh", "vh"], ["svh", "svh"], ["lvh", "lvh"], ["dvh", "dvh"], ["vi", "vi"], ["svi", "svi"], ["lvi", "lvi"], ["dvi", "dvi"], ["vb", "vb"], ["svb", "svb"], ["lvb", "lvb"], ["dvb", "dvb"], ["vmin", "vmin"], ["svmin", "svmin"], ["lvmin", "lvmin"], ["dvmin", "dvmin"], ["vmax", "vmax"], ["svmax", "svmax"], ["lvmax", "lvmax"], ["dvmax", "dvmax"], ["cm", "cm"], ["mm", "mm"], ["q", "Q"], ["in", "in"], ["pt", "pt"], ["pc", "pc"], ["px", "px"], ["deg", "deg"], ["grad", "grad"], ["rad", "rad"], ["turn", "turn"], ["s", "s"], ["ms", "ms"], ["hz", "Hz"], ["khz", "kHz"], ["dpi", "dpi"], ["dpcm", "dpcm"], ["dppx", "dppx"], ["x", "x"], ["cqw", "cqw"], ["cqh", "cqh"], ["cqi", "cqi"], ["cqb", "cqb"], ["cqmin", "cqmin"], ["cqmax", "cqmax"]]);
function UA(t) {
  let e = t.toLowerCase();
  return sd.has(e) ? sd.get(e) : t;
}
var S0 = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, GA = /(?:\d*\.\d+|\d+\.?)(?:e[+-]?\d+)?/gi, KA = /[a-z]+/gi, YA = /[$@]?[_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/gi, JA = new RegExp(S0.source + `|(${YA.source})?(${GA.source})(${KA.source})?`, "gi");
function zt(t, e) {
  return Ne(!1, t, S0, (r) => p0(r, e));
}
function XA(t, e) {
  let r = e.singleQuote ? "'" : '"';
  return t.includes('"') || t.includes("'") ? t : r + t + r;
}
function jn(t) {
  return Ne(!1, t, JA, (e, r, n, i, s) => !n && i ? E0(i) + Hn(s || "") : e);
}
function E0(t) {
  return zA(t).replace(/\.0(?=$|e)/, "");
}
function QA(t) {
  return t.trailingComma === "es5" || t.trailingComma === "all";
}
function ZA(t, e, r) {
  let n = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let i = t.charAt(e);
  if (n) {
    if (t.charAt(e - 1) === "\r" && i === `
`)
      return e - 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e - 1;
  } else {
    if (i === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e + 1;
  }
  return e;
}
var A0 = ZA;
function eF(t, e, r = {}) {
  let n = v0(t, r.backwards ? e - 1 : e, r), i = A0(t, n, r);
  return n !== i;
}
var F0 = eF;
function tF(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var rF = tF;
function nF(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? b0(t, e) : e;
}
var iF = nF;
function sF(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = aA(t, n), n = rF(t, n), n = v0(t, n);
  return n = iF(t, n), n = A0(t, n), n !== !1 && F0(t, n);
}
var T0 = sF;
function oF({ node: t, parent: e }, r) {
  return !!(t.source && r.originalText.slice(pt(t), pt(e.close)).trimEnd().endsWith(","));
}
function aF(t, e) {
  return EA(t.grandparent) && oF(t, e) ? "," : t.node.type !== "value-comment" && !(t.node.type === "value-comma_group" && t.node.groups.every((r) => r.type === "value-comment")) && QA(e) && t.callParent(() => k0(t, e)) ? d0(",") : "";
}
function lF(t, e, r) {
  let { node: n, parent: i } = t, s = t.map(({ node: d }) => typeof d == "string" ? d : r(), "groups");
  if (i && SA(i) && (n.groups.length === 1 || n.groups.length > 0 && n.groups[0].type === "value-comma_group" && n.groups[0].groups.length > 0 && n.groups[0].groups[0].type === "value-word" && n.groups[0].groups[0].value.startsWith("data:")))
    return [n.open ? r("open") : "", dn(",", s), n.close ? r("close") : ""];
  if (!n.open) {
    let d = _0(t), p = dn([",", d ? Ce : Xe], s);
    return ut(d ? [Ce, p] : kt(gu(p)));
  }
  let o = t.map(({ node: d, isLast: p, index: m }) => {
    var y;
    let v = s[m];
    if (bh(d) && d.type === "value-comma_group" && d.groups && d.groups[0].type !== "value-paren_group" && ((y = d.groups[2]) == null ? void 0 : y.type) === "value-paren_group") {
      let b = ME(v.contents.contents);
      b[1] = kt(b[1]), v = kt(zo(v));
    }
    let g = [v, p ? aF(t, e) : ","];
    if (!p && d.type === "value-comma_group" && Ka(d.groups)) {
      let b = os(!1, d.groups, -1);
      !b.source && b.close && (b = b.close), b.source && T0(e.originalText, ft(b)) && g.push(Ce);
    }
    return g;
  }, "groups"), a = IA(n, i), l = WA(n, i), c = k0(t, e), u = l || c && !a, h = l || a, f = kt([n.open ? r("open") : "", ut([Pt, dn(Xe, o)]), Pt, n.close ? r("close") : ""], { shouldBreak: u });
  return h ? zo(f) : f;
}
function _0(t) {
  return t.match((e) => e.type === "value-paren_group" && !e.open && e.groups.some((r) => r.type === "value-comma_group"), (e, r) => r === "group" && e.type === "value-value", (e, r) => r === "group" && e.type === "value-root", (e, r) => r === "value" && (e.type === "css-decl" && !e.prop.startsWith("--") || e.type === "css-atrule" && e.variable));
}
function uF(t, e, r) {
  let n = [];
  return t.each(() => {
    let { node: i, previous: s } = t;
    if ((s == null ? void 0 : s.type) === "css-comment" && s.text.trim() === "prettier-ignore" ? n.push(e.originalText.slice(pt(i), ft(i))) : n.push(r()), t.isLast)
      return;
    let { next: o } = t;
    o.type === "css-comment" && !F0(e.originalText, pt(o), { backwards: !0 }) && !Uo(i) || o.type === "css-atrule" && o.name === "else" && i.type !== "css-comment" ? n.push(" ") : (n.push(e.__isHTMLStyleAttribute ? Xe : Ce), T0(e.originalText, ft(i)) && !Uo(i) && n.push(Ce));
  }, "nodes"), n;
}
var _i = uF;
function cF(t, e, r) {
  var n, i, s, o, a, l;
  let { node: c } = t;
  switch (c.type) {
    case "front-matter":
      return [c.raw, Ce];
    case "css-root": {
      let u = _i(t, e, r), h = c.raws.after.trim();
      return h.startsWith(";") && (h = h.slice(1).trim()), [c.frontMatter ? [r("frontMatter"), Ce] : "", u, h ? ` ${h}` : "", c.nodes.length > 0 ? Ce : ""];
    }
    case "css-comment": {
      let u = c.inline || c.raws.inline, h = e.originalText.slice(pt(c), ft(c));
      return u ? h.trimEnd() : h;
    }
    case "css-rule":
      return [r("selector"), c.important ? " !important" : "", c.nodes ? [((n = c.selector) == null ? void 0 : n.type) === "selector-unknown" && Ti(c.selector.value) ? Xe : c.selector ? " " : "", "{", c.nodes.length > 0 ? ut([Ce, _i(t, e, r)]) : "", Ce, "}", AA(c) ? ";" : ""] : ";"];
    case "css-decl": {
      let u = t.parent, { between: h } = c.raws, f = h.trim(), d = f === ":", p = typeof c.value == "string" && /^ *$/.test(c.value), m = typeof c.value == "string" ? c.value : r("value");
      return m = NA(c) ? NE(m) : m, !d && Ti(f) && !((s = (i = c.value) == null ? void 0 : i.group) != null && s.group && t.call(() => _0(t), "value", "group", "group")) && (m = ut([Ce, zo(m)])), [Ne(!1, c.raws.before, /[\s;]/g, ""), u.type === "css-atrule" && u.variable || CA(t) ? c.prop : Hn(c.prop), f.startsWith("//") ? " " : "", f, c.extend || p ? "" : " ", e.parser === "less" && c.extend && c.selector ? ["extend(", r("selector"), ")"] : "", m, c.raws.important ? c.raws.important.replace(/\s*!\s*important/i, " !important") : c.important ? " !important" : "", c.raws.scssDefault ? c.raws.scssDefault.replace(/\s*!default/i, " !default") : c.scssDefault ? " !default" : "", c.raws.scssGlobal ? c.raws.scssGlobal.replace(/\s*!global/i, " !global") : c.scssGlobal ? " !global" : "", c.nodes ? [" {", ut([Pt, _i(t, e, r)]), Pt, "}"] : LA(c) && !u.raws.semicolon && e.originalText[ft(c) - 1] !== ";" ? "" : e.__isHTMLStyleAttribute && kl(t, c) ? d0(";") : ";"];
    }
    case "css-atrule": {
      let u = t.parent, h = El(c) && !u.raws.semicolon && e.originalText[ft(c) - 1] !== ";";
      if (e.parser === "less") {
        if (c.mixin)
          return [r("selector"), c.important ? " !important" : "", h ? "" : ";"];
        if (c.function)
          return [c.name, typeof c.params == "string" ? c.params : r("params"), h ? "" : ";"];
        if (c.variable)
          return ["@", c.name, ": ", c.value ? r("value") : "", c.raws.between.trim() ? c.raws.between.trim() + " " : "", c.nodes ? ["{", ut([c.nodes.length > 0 ? Pt : "", _i(t, e, r)]), Pt, "}"] : "", h ? "" : ";"];
      }
      let f = c.name === "import" && ((o = c.params) == null ? void 0 : o.type) === "value-unknown" && c.params.value.endsWith(";");
      return ["@", rd(c) || c.name.endsWith(":") || El(c) ? c.name : Hn(c.name), c.params ? [rd(c) ? "" : El(c) ? c.raws.afterName === "" ? "" : c.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(c.raws.afterName) ? [Ce, Ce] : /^\s*\n/.test(c.raws.afterName) ? Ce : " " : " ", typeof c.params == "string" ? c.params : r("params")] : "", c.selector ? ut([" ", r("selector")]) : "", c.value ? kt([" ", r("value"), vu(c, e) ? RA(c) ? " " : Xe : ""]) : c.name === "else" ? " " : "", c.nodes ? [vu(c, e) ? "" : c.selector && !c.selector.nodes && typeof c.selector.value == "string" && Ti(c.selector.value) || !c.selector && typeof c.params == "string" && Ti(c.params) ? Xe : " ", "{", ut([c.nodes.length > 0 ? Pt : "", _i(t, e, r)]), Pt, "}"] : h || f ? "" : ";"];
    }
    case "media-query-list": {
      let u = [];
      return t.each(({ node: h }) => {
        h.type === "media-query" && h.value === "" || u.push(r());
      }, "nodes"), kt(ut(dn(Xe, u)));
    }
    case "media-query":
      return [dn(" ", t.map(r, "nodes")), kl(t, c) ? "" : ","];
    case "media-type":
      return jn(zt(c.value, e));
    case "media-feature-expression":
      return c.nodes ? ["(", ...t.map(r, "nodes"), ")"] : c.value;
    case "media-feature":
      return Hn(zt(Ne(!1, c.value, / +/g, " "), e));
    case "media-colon":
      return [c.value, " "];
    case "media-value":
      return jn(zt(c.value, e));
    case "media-keyword":
      return zt(c.value, e);
    case "media-url":
      return zt(Ne(!1, Ne(!1, c.value, /^url\(\s+/gi, "url("), /\s+\)$/g, ")"), e);
    case "media-unknown":
      return c.value;
    case "selector-root":
      return kt([Ao(t, "custom-selector") ? [t.findAncestor((u) => u.type === "css-atrule").customSelector, Xe] : "", dn([",", Ao(t, ["extend", "custom-selector", "nest"]) ? Xe : Ce], t.map(r, "nodes"))]);
    case "selector-selector":
      return kt(ut(t.map(r, "nodes")));
    case "selector-comment":
      return c.value;
    case "selector-string":
      return zt(c.value, e);
    case "selector-tag":
      return [c.namespace ? [c.namespace === !0 ? "" : c.namespace.trim(), "|"] : "", ((a = t.previous) == null ? void 0 : a.type) === "selector-nesting" ? c.value : jn(xA(t, c.value) ? c.value.toLowerCase() : c.value)];
    case "selector-id":
      return ["#", c.value];
    case "selector-class":
      return [".", jn(zt(c.value, e))];
    case "selector-attribute":
      return ["[", c.namespace ? [c.namespace === !0 ? "" : c.namespace.trim(), "|"] : "", c.attribute.trim(), c.operator ?? "", c.value ? XA(zt(c.value.trim(), e), e) : "", c.insensitive ? " i" : "", "]"];
    case "selector-combinator": {
      if (c.value === "+" || c.value === ">" || c.value === "~" || c.value === ">>>") {
        let f = t.parent;
        return [f.type === "selector-selector" && f.nodes[0] === c ? "" : Xe, c.value, kl(t, c) ? "" : " "];
      }
      let u = c.value.trim().startsWith("(") ? Xe : "", h = jn(zt(c.value.trim(), e)) || Xe;
      return [u, h];
    }
    case "selector-universal":
      return [c.namespace ? [c.namespace === !0 ? "" : c.namespace.trim(), "|"] : "", c.value];
    case "selector-pseudo":
      return [Hn(c.value), Ka(c.nodes) ? kt(["(", ut([Pt, dn([",", Xe], t.map(r, "nodes"))]), Pt, ")"]) : ""];
    case "selector-nesting":
      return c.value;
    case "selector-unknown": {
      let u = t.findAncestor((d) => d.type === "css-rule");
      if (u != null && u.isSCSSNesterProperty)
        return jn(zt(Hn(c.value), e));
      let h = t.parent;
      if ((l = h.raws) != null && l.selector) {
        let d = pt(h), p = d + h.raws.selector.length;
        return e.originalText.slice(d, p).trim();
      }
      let f = t.grandparent;
      if (h.type === "value-paren_group" && (f == null ? void 0 : f.type) === "value-func" && f.value === "selector") {
        let d = ft(h.open) + 1, p = pt(h.close), m = e.originalText.slice(d, p).trim();
        return Ti(m) ? [mh, m] : m;
      }
      return c.value;
    }
    case "value-value":
    case "value-root":
      return r("group");
    case "value-comment":
      return e.originalText.slice(pt(c), ft(c));
    case "value-comma_group":
      return HA(t, e, r);
    case "value-paren_group":
      return lF(t, e, r);
    case "value-func":
      return [c.value, Ao(t, "supports") && $A(c) ? " " : "", r("group")];
    case "value-paren":
      return c.value;
    case "value-number":
      return [E0(c.value), UA(c.unit)];
    case "value-operator":
      return c.value;
    case "value-word":
      return c.isColor && c.isHex || wA(c.value) ? c.value.toLowerCase() : c.value;
    case "value-colon": {
      let { previous: u } = t;
      return [c.value, typeof (u == null ? void 0 : u.value) == "string" && u.value.endsWith("\\") || Eo(t, "url") ? "" : Xe];
    }
    case "value-string":
      return p0(c.raws.quote + c.value + c.raws.quote, e);
    case "value-atword":
      return ["@", c.value];
    case "value-unicode-range":
      return c.value;
    case "value-unknown":
      return c.value;
    case "value-comma":
    default:
      throw new VE(c, "PostCSS");
  }
}
var hF = { print: cF, embed: XE, insertPragma: yA, massageAstNode: KE, getVisitorKeys: sA }, fF = hF, dF = [{ linguistLanguageId: 50, name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css", ".wxss"], parsers: ["css"], vscodeLanguageIds: ["css"] }, { linguistLanguageId: 262764437, name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", parsers: ["css"], vscodeLanguageIds: ["postcss"] }, { linguistLanguageId: 198, name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", parsers: ["less"], vscodeLanguageIds: ["less"] }, { linguistLanguageId: 329, name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], parsers: ["scss"], vscodeLanguageIds: ["scss"] }], pF = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, mF = { singleQuote: pF.singleQuote }, gF = mF, B0 = {};
$g(B0, { css: () => GF, less: () => KF, scss: () => YF });
var yF = Bn(Ua(), 1), vF = Bn(MS(), 1), bF = Bn(jS(), 1);
function DF(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var wF = DF, xF = Bn(qS(), 1);
function Ms(t, e, r) {
  if (t && typeof t == "object") {
    delete t.parent;
    for (let n in t)
      Ms(t[n], e, r), n === "type" && typeof t[n] == "string" && !t[n].startsWith(e) && (!r || !r.test(t[n])) && (t[n] = e + t[n]);
  }
  return t;
}
function O0(t) {
  if (t && typeof t == "object") {
    delete t.parent;
    for (let e in t)
      O0(t[e]);
    !Array.isArray(t) && t.value && !t.type && (t.type = "unknown");
  }
  return t;
}
var CF = xF.default.default;
function kF(t) {
  let e;
  try {
    e = CF(t);
  } catch {
    return { type: "selector-unknown", value: t };
  }
  return Ms(O0(e), "media-");
}
var SF = kF, EF = Bn(iE(), 1);
function AF(t) {
  if (/\/\/|\/\*/.test(t))
    return { type: "selector-unknown", value: t.trim() };
  let e;
  try {
    new EF.default((r) => {
      e = r;
    }).process(t);
  } catch {
    return { type: "selector-unknown", value: t };
  }
  return Ms(e, "selector-");
}
var ln = AF, FF = Bn(wE(), 1), TF = (t) => {
  for (; t.parent; )
    t = t.parent;
  return t;
}, M0 = TF;
function _F(t) {
  return M0(t).text.slice(t.group.open.sourceIndex + 1, t.group.close.sourceIndex).trim();
}
var BF = _F;
function OF(t) {
  if (Ka(t)) {
    for (let e = t.length - 1; e > 0; e--)
      if (t[e].type === "word" && t[e].value === "{" && t[e - 1].type === "word" && t[e - 1].value.endsWith("#"))
        return !0;
  }
  return !1;
}
var MF = OF;
function LF(t) {
  return t.some((e) => e.type === "string" || e.type === "func" && !e.value.endsWith("\\"));
}
var PF = LF;
function NF(t, e) {
  return !!(e.parser === "scss" && (t == null ? void 0 : t.type) === "word" && t.value.startsWith("$"));
}
var RF = NF;
function IF(t, e) {
  var r;
  let { nodes: n } = t, i = { open: null, close: null, groups: [], type: "paren_group" }, s = [i], o = i, a = { groups: [], type: "comma_group" }, l = [a];
  for (let c = 0; c < n.length; ++c) {
    let u = n[c];
    if (e.parser === "scss" && u.type === "number" && u.unit === ".." && u.value.endsWith(".") && (u.value = u.value.slice(0, -1), u.unit = "..."), u.type === "func" && u.value === "selector" && (u.group.groups = [ln(M0(t).text.slice(u.group.open.sourceIndex + 1, u.group.close.sourceIndex))]), u.type === "func" && u.value === "url") {
      let h = ((r = u.group) == null ? void 0 : r.groups) ?? [], f = [];
      for (let d = 0; d < h.length; d++) {
        let p = h[d];
        p.type === "comma_group" ? f = [...f, ...p.groups] : f.push(p);
      }
      (MF(f) || !PF(f) && !RF(f[0], e)) && (u.group.groups = [BF(u)]);
    }
    if (u.type === "paren" && u.value === "(")
      i = { open: u, close: null, groups: [], type: "paren_group" }, s.push(i), a = { groups: [], type: "comma_group" }, l.push(a);
    else if (u.type === "paren" && u.value === ")") {
      if (a.groups.length > 0 && i.groups.push(a), i.close = u, l.length === 1)
        throw new Error("Unbalanced parenthesis");
      l.pop(), a = os(!1, l, -1), a.groups.push(i), s.pop(), i = os(!1, s, -1);
    } else
      u.type === "comma" ? (i.groups.push(a), a = { groups: [], type: "comma_group" }, l[l.length - 1] = a) : a.groups.push(u);
  }
  return a.groups.length > 0 && i.groups.push(a), o;
}
function Du(t) {
  return t.type === "paren_group" && !t.open && !t.close && t.groups.length === 1 || t.type === "comma_group" && t.groups.length === 1 ? Du(t.groups[0]) : t.type === "paren_group" || t.type === "comma_group" ? { ...t, groups: t.groups.map(Du) } : t;
}
function L0(t, e) {
  if (t && typeof t == "object")
    for (let r in t)
      r !== "parent" && (L0(t[r], e), r === "nodes" && (t.group = Du(IF(t, e)), delete t[r]));
  return t;
}
function $F(t, e) {
  if (e.parser === "less" && t.startsWith("~`"))
    return { type: "value-unknown", value: t };
  let r = null;
  try {
    r = new FF.default(t, { loose: !0 }).parse();
  } catch {
    return { type: "value-unknown", value: t };
  }
  r.text = t;
  let n = L0(r, e);
  return Ms(n, "value-", /^selector-/);
}
var sn = $F, jF = /* @__PURE__ */ new Set(["import", "use", "forward"]);
function WF(t) {
  return jF.has(t);
}
var qF = WF;
function HF(t, e) {
  return e.parser !== "scss" || !t.selector ? !1 : t.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*\n/, "").trim().endsWith(":");
}
var VF = HF, zF = /(\s*)(!default).*$/, UF = /(\s*)(!global).*$/;
function P0(t, e) {
  var r, n;
  if (t && typeof t == "object") {
    delete t.parent;
    for (let a in t)
      P0(t[a], e);
    if (!t.type)
      return t;
    if (t.raws ?? (t.raws = {}), t.type === "css-decl" && typeof t.prop == "string" && t.prop.startsWith("--") && typeof t.value == "string" && t.value.startsWith("{")) {
      let a;
      if (t.value.trimEnd().endsWith("}")) {
        let l = e.originalText.slice(0, t.source.start.offset), c = "a".repeat(t.prop.length) + e.originalText.slice(t.source.start.offset + t.prop.length, t.source.end.offset), u = Ne(!1, l, /[^\n]/g, " ") + c, h;
        e.parser === "scss" ? h = I0 : e.parser === "less" ? h = R0 : h = N0;
        let f;
        try {
          f = h(u, { ...e });
        } catch {
        }
        ((r = f == null ? void 0 : f.nodes) == null ? void 0 : r.length) === 1 && f.nodes[0].type === "css-rule" && (a = f.nodes[0].nodes);
      }
      return a ? t.value = { type: "css-rule", nodes: a } : t.value = { type: "value-unknown", value: t.raws.value.raw }, t;
    }
    let i = "";
    typeof t.selector == "string" && (i = t.raws.selector ? t.raws.selector.scss ?? t.raws.selector.raw : t.selector, t.raws.between && t.raws.between.trim().length > 0 && (i += t.raws.between), t.raws.selector = i);
    let s = "";
    typeof t.value == "string" && (s = t.raws.value ? t.raws.value.scss ?? t.raws.value.raw : t.value, s = s.trim(), t.raws.value = s);
    let o = "";
    if (typeof t.params == "string" && (o = t.raws.params ? t.raws.params.scss ?? t.raws.params.raw : t.params, t.raws.afterName && t.raws.afterName.trim().length > 0 && (o = t.raws.afterName + o), t.raws.between && t.raws.between.trim().length > 0 && (o = o + t.raws.between), o = o.trim(), t.raws.params = o), i.trim().length > 0)
      return i.startsWith("@") && i.endsWith(":") ? t : t.mixin ? (t.selector = sn(i, e), t) : (VF(t, e) && (t.isSCSSNesterProperty = !0), t.selector = ln(i), t);
    if (s.length > 0) {
      let a = s.match(zF);
      a && (s = s.slice(0, a.index), t.scssDefault = !0, a[0].trim() !== "!default" && (t.raws.scssDefault = a[0]));
      let l = s.match(UF);
      if (l && (s = s.slice(0, l.index), t.scssGlobal = !0, l[0].trim() !== "!global" && (t.raws.scssGlobal = l[0])), s.startsWith("progid:"))
        return { type: "value-unknown", value: s };
      t.value = sn(s, e);
    }
    if (e.parser === "less" && t.type === "css-decl" && s.startsWith("extend(") && (t.extend || (t.extend = t.raws.between === ":"), t.extend && !t.selector && (delete t.value, t.selector = ln(s.slice(7, -1)))), t.type === "css-atrule") {
      if (e.parser === "less") {
        if (t.mixin) {
          let a = t.raws.identifier + t.name + t.raws.afterName + t.raws.params;
          return t.selector = ln(a), delete t.params, t;
        }
        if (t.function)
          return t;
      }
      if (e.parser === "css" && t.name === "custom-selector") {
        let a = t.params.match(/:--\S+\s+/)[0].trim();
        return t.customSelector = a, t.selector = ln(t.params.slice(a.length).trim()), delete t.params, t;
      }
      if (e.parser === "less") {
        if (t.name.includes(":") && !t.params) {
          t.variable = !0;
          let a = t.name.split(":");
          t.name = a[0], t.value = sn(a.slice(1).join(":"), e);
        }
        if (!["page", "nest", "keyframes"].includes(t.name) && ((n = t.params) == null ? void 0 : n[0]) === ":") {
          t.variable = !0;
          let a = t.params.slice(1);
          a && (t.value = sn(a, e)), t.raws.afterName += ":";
        }
        if (t.variable)
          return delete t.params, t.value || delete t.value, t;
      }
    }
    if (t.type === "css-atrule" && o.length > 0) {
      let { name: a } = t, l = t.name.toLowerCase();
      return a === "warn" || a === "error" ? (t.params = { type: "media-unknown", value: o }, t) : a === "extend" || a === "nest" ? (t.selector = ln(o), delete t.params, t) : a === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(o) ? t.params = sn(o, e) : (t.selector = ln(o), delete t.params), t) : qF(l) ? (t.import = !0, delete t.filename, t.params = sn(o, e), t) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(a) ? (o = o.replace(/(\$\S+?)(\s+)?\.{3}/, "$1...$2"), o = o.replace(/^(?!if)(\S+)(\s+)\(/, "$1($2"), t.value = sn(o, e), delete t.params, t) : ["media", "custom-media"].includes(l) ? o.includes("#{") ? { type: "media-unknown", value: o } : (t.params = SF(o), t) : (t.params = o, t);
    }
  }
  return t;
}
function Dh(t, e, r) {
  let n = vh(e), { frontMatter: i } = n;
  e = n.content;
  let s;
  try {
    s = t(e, { map: !1 });
  } catch (o) {
    let { name: a, reason: l, line: c, column: u } = o;
    throw typeof c != "number" ? o : wF(`${a}: ${l}`, { loc: { start: { line: c, column: u } }, cause: o });
  }
  return r.originalText = e, s = P0(Ms(s, "css-"), r), w0(s, e), i && (i.source = { startOffset: 0, endOffset: i.raw.length }, s.frontMatter = i), s;
}
function N0(t, e = {}) {
  return Dh(yF.default.default, t, e);
}
function R0(t, e = {}) {
  return Dh((r) => vF.default.parse(uA(r)), t, e);
}
function I0(t, e = {}) {
  return Dh(bF.default, t, e);
}
var wh = { astFormat: "postcss", hasPragma: gA, locStart: pt, locEnd: ft }, GF = { ...wh, parse: N0 }, KF = { ...wh, parse: R0 }, YF = { ...wh, parse: I0 }, JF = { postcss: fF }, XF = t0;
const QF = async (t, e) => e !== "html" && e !== "css" ? t : await bw.format(t, {
  parser: e,
  plugins: [XF, mS],
  tabWidth: 2,
  htmlWhitespaceSensitivity: "ignore"
}), $0 = (t, e = { mustBeOpen: !0 }) => Object.values(t).filter((r) => !e.mustBeOpen || r.open && e.mustBeOpen).sort((r, n) => r.name.localeCompare(n.name)), fe = {
  REPLACE_PROJECT: "REPLACE_PROJECT",
  NEW_FILE: "NEW_FILE",
  RENAME_FILE: "RENAME_FILE",
  SAVE_FILE: "SAVE_FILE",
  OPEN_FILE: "OPEN_FILE",
  ACTIVATE_FILE: "ACTIVATE_FILE",
  MOVE_FILE: "MOVE_FILE",
  CLOSE_FILE: "CLOSE_FILE",
  DELETE_FILE: "DELETE_FILE",
  NEW_FOLDER: "NEW_FOLDER",
  TOGGLE_OPEN_FOLDER: "TOGGLE_OPEN_FOLDER",
  DELETE_FOLDER: "DELETE_FOLDER",
  RENAME_FOLDER: "RENAME_FOLDER"
}, ZF = "Add your changes to ${fileName}", eT = (t) => String(Math.max(...t.map((e) => Number(e.id))) + 1), tT = (t) => String(Math.max(...t.map((e) => Number(e.id))) + 1), xh = (t, e) => e.reduce((r, n) => (n.parentId === t && r.push(n.id, ...xh(n.id, e)), r), []), rT = (t, e, r) => {
  const n = new Set(
    r ? [t, ...xh(t, r)] : [t]
  );
  return e.reduce((i, s) => (n.has(s.folderId) && i.push(s.id), i), []);
}, nT = (t) => Jp(() => {
  const e = {
    replaceProject: (r) => {
      t({
        type: fe.REPLACE_PROJECT,
        payload: { project: r }
      });
    },
    newFile: ({
      fileId: r,
      fileName: n,
      folderId: i = gn,
      contents: s = ZF
    }) => {
      t({
        type: fe.NEW_FILE,
        payload: {
          fileId: r,
          fileName: n,
          folderId: i,
          contents: s.replace(/\${fileName}/g, n)
        }
      }), e.setActiveFile(r);
    },
    renameFile: (r, n) => {
      t({
        type: fe.RENAME_FILE,
        payload: { fileId: r, newName: n }
      });
    },
    saveFile: (r, n) => {
      t({
        type: fe.SAVE_FILE,
        payload: { fileId: r, contents: n }
      });
    },
    openFile: (r) => {
      t({
        type: fe.OPEN_FILE,
        payload: { fileId: r }
      });
    },
    closeFile: (r) => {
      t({
        type: fe.CLOSE_FILE,
        payload: { fileId: r }
      });
    },
    deleteFile: (r) => {
      t({
        type: fe.DELETE_FILE,
        payload: { fileId: r }
      });
    },
    setActiveFile: (r) => {
      t({
        type: fe.ACTIVATE_FILE,
        payload: { fileId: r }
      });
    },
    moveFile: (r, n) => {
      t({
        type: fe.MOVE_FILE,
        payload: { fileId: r, folderId: n }
      });
    },
    newFolder: ({
      folderId: r,
      folderName: n,
      parentId: i = gn
    }) => {
      t({
        type: fe.NEW_FOLDER,
        payload: { folderId: r, folderName: n, parentId: i }
      });
    },
    renameFolder: (r, n) => {
      t({
        type: fe.RENAME_FOLDER,
        payload: { folderId: r, newName: n }
      });
    },
    toggleOpenFolder: (r) => {
      t({
        type: fe.TOGGLE_OPEN_FOLDER,
        payload: { folderId: r }
      });
    },
    deleteFolder: (r) => {
      t({
        type: fe.DELETE_FOLDER,
        payload: { folderId: r }
      });
    }
  };
  return e;
}, [t]), iT = (t, e) => {
  var r;
  switch (e.type) {
    case fe.REPLACE_PROJECT: {
      const { project: n } = e.payload;
      return n;
    }
    case fe.NEW_FILE: {
      const { fileId: n, fileName: i, folderId: s, contents: o = "" } = e.payload, a = { ...t, files: { ...t.files } }, [l, c] = i.split(".");
      return a.files[n] = {
        id: n,
        name: i,
        language: c || "html",
        contents: o,
        folderId: s
      }, a;
    }
    case fe.RENAME_FILE: {
      const { fileId: n, newName: i } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], name: i }
        }
      };
    }
    case fe.SAVE_FILE: {
      const { fileId: n, contents: i } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], contents: i }
        }
      };
    }
    case fe.OPEN_FILE:
    case fe.ACTIVATE_FILE: {
      const { fileId: n } = e.payload, i = (r = Object.values(t.files).filter(
        (o) => o.active
      )) == null ? void 0 : r[0];
      if ((i == null ? void 0 : i.id) === n)
        return t;
      const s = {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], active: !0, open: !0 }
        }
      };
      return i && (s.files[i.id].active = !1), s;
    }
    case fe.CLOSE_FILE: {
      const { fileId: n } = e.payload, i = t.files[n], s = {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], open: !1, active: !1 }
        }
      };
      if (i.active) {
        const o = $0(t.files, {
          mustBeOpen: !0
        }), a = o.findIndex((c) => c.id === i.id);
        let l;
        a > 0 ? l = o[a - 1].id : a < o.length - 1 && (l = o[a + 1].id), l && (s.files[l] = {
          ...s.files[l],
          active: !0
        });
      }
      return s;
    }
    case fe.DELETE_FILE: {
      const { fileId: n } = e.payload, i = {
        ...t,
        files: {
          ...t.files
        }
      };
      return delete i.files[n], i;
    }
    case fe.MOVE_FILE: {
      const { fileId: n, folderId: i } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], folderId: i }
        }
      };
    }
    case fe.NEW_FOLDER: {
      const { folderId: n, folderName: i, parentId: s } = e.payload, o = { ...t, folders: { ...t.folders } };
      return o.folders[n] = {
        id: n,
        name: i,
        parentId: s
      }, o;
    }
    case fe.TOGGLE_OPEN_FOLDER: {
      const { folderId: n } = e.payload;
      return {
        ...t,
        folders: {
          ...t.folders,
          [n]: {
            ...t.folders[n],
            open: !t.folders[n].open
          }
        }
      };
    }
    case fe.DELETE_FOLDER: {
      const { folderId: n } = e.payload, i = {
        ...t,
        folders: {
          ...t.folders
        }
      }, s = new Set(
        xh(n, Object.values(t.folders))
      ), o = new Set(
        rT(
          n,
          Object.values(t.files),
          Object.values(t.folders)
        )
      );
      return delete i.folders[n], Object.values(i.folders).filter((a) => s.has(a.id)).forEach((a) => delete i.folders[a.id]), o.size && (i.files = { ...i.files }, Object.values(i.files).filter((a) => o.has(a.id)).forEach((a) => delete i.files[a.id])), i;
    }
    case fe.RENAME_FOLDER: {
      const { folderId: n, newName: i } = e.payload;
      return {
        ...t,
        folders: {
          ...t.folders,
          [n]: { ...t.folders[n], name: i }
        }
      };
    }
    default:
      return t;
  }
}, sT = ({ setActivePane: t, activePane: e }) => {
  const {
    config: { leftNav: r }
  } = vt();
  return /* @__PURE__ */ M.jsx("div", { className: "nav-bar", children: r.map((n) => /* @__PURE__ */ M.jsx(
    "div",
    {
      onClick: () => t(n.component),
      style: {
        cursor: "pointer",
        backgroundColor: n.component === e ? "#666" : ""
      },
      children: /* @__PURE__ */ M.jsx("i", { className: `fa-regular fa-2xl ${n.icon}` })
    },
    n.icon
  )) });
}, oT = () => {
  const {
    config: { sideBar: t }
  } = vt();
  return /* @__PURE__ */ M.jsx("div", { className: "left-side-bar", children: t.map((e) => /* @__PURE__ */ M.jsx(
    "div",
    {
      onClick: () => alert("not implemented"),
      style: { cursor: "pointer" },
      children: /* @__PURE__ */ M.jsx("i", { className: `fa-regular fa-2xl ${e}` })
    },
    e
  )) });
}, j0 = ({
  parentId: t,
  folders: e,
  files: r,
  newFolderPrompt: n,
  newFilePrompt: i,
  moveFilePrompt: s,
  renameFilePrompt: o,
  renameFolderPrompt: a
}) => {
  const {
    openFile: l,
    deleteFile: c,
    toggleOpenFolder: u,
    deleteFolder: h
  } = vt();
  return /* @__PURE__ */ M.jsxs(M.Fragment, { children: [
    Object.values(e).filter((f) => f.parentId === t).sort((f, d) => f.name.localeCompare(d.name)).map((f) => {
      const d = /* @__PURE__ */ M.jsx(
        "i",
        {
          className: f.open ? "fa-solid fa-caret-down" : "fa-solid fa-caret-right"
        }
      );
      return /* @__PURE__ */ M.jsxs("li", { children: [
        /* @__PURE__ */ M.jsxs("span", { className: "label", children: [
          /* @__PURE__ */ M.jsxs("span", { className: "title", children: [
            /* @__PURE__ */ M.jsx(
              "span",
              {
                className: "caret-container",
                onClick: () => u(f.id),
                children: d
              }
            ),
            /* @__PURE__ */ M.jsx("span", { children: f.name })
          ] }),
          /* @__PURE__ */ M.jsxs("span", { className: "button-bar", children: [
            /* @__PURE__ */ M.jsx("span", { onClick: () => a(f.id), children: /* @__PURE__ */ M.jsx("i", { className: "fa-solid fa-pencil" }) }),
            /* @__PURE__ */ M.jsx("span", { onClick: () => n(f.id), children: /* @__PURE__ */ M.jsx("i", { className: "fa-solid fa-folder-plus" }) }),
            /* @__PURE__ */ M.jsx("span", { onClick: () => i(f.id), children: /* @__PURE__ */ M.jsx("i", { className: "fa-solid fa-plus" }) }),
            /* @__PURE__ */ M.jsx("span", { onClick: () => h(f.id), children: /* @__PURE__ */ M.jsx("i", { className: "fa-solid fa-trash" }) })
          ] })
        ] }),
        f.open && /* @__PURE__ */ M.jsx("ul", { children: /* @__PURE__ */ M.jsx(
          j0,
          {
            folders: e,
            newFolderPrompt: n,
            parentId: f.id,
            files: r,
            newFilePrompt: i,
            moveFilePrompt: s,
            renameFilePrompt: o,
            renameFolderPrompt: a
          }
        ) })
      ] }, f.id + f.open);
    }),
    Object.values(r).filter((f) => f.folderId === t).sort((f, d) => f.name.localeCompare(d.name)).map((f) => /* @__PURE__ */ M.jsx("li", { children: /* @__PURE__ */ M.jsxs("span", { className: "label", children: [
      /* @__PURE__ */ M.jsx("span", { onClick: () => l(f.id), children: f.name }),
      /* @__PURE__ */ M.jsxs("span", { className: "button-bar", children: [
        /* @__PURE__ */ M.jsx("span", { onClick: () => s(f.id), children: /* @__PURE__ */ M.jsx("i", { className: "fa-solid fa-arrow-right" }) }),
        /* @__PURE__ */ M.jsx("span", { onClick: () => o(f.id), children: /* @__PURE__ */ M.jsx("i", { className: "fa-solid fa-pencil" }) }),
        /* @__PURE__ */ M.jsx("span", { onClick: () => c(f.id), children: /* @__PURE__ */ M.jsx("i", { className: "fa-solid fa-trash" }) })
      ] })
    ] }) }, f.id))
  ] });
}, aT = () => {
  const {
    project: t,
    newFile: e,
    renameFile: r,
    moveFile: n,
    renameFolder: i,
    newFolder: s
  } = vt(), o = (h = gn) => {
    const f = tT(Object.values(t.folders)), d = window.prompt("Please name your new folder");
    if (!d)
      return;
    if (Object.values(t.folders).some(
      (m) => m.name === d && m.parentId === h
    )) {
      alert("Folder already exists");
      return;
    }
    s({ parentId: h, folderName: d, folderId: f });
  }, a = (h = gn) => {
    var v;
    const f = (v = window.prompt("Please name your new file")) == null ? void 0 : v.replace(/[^\w.]+/g, "");
    if (!f)
      return;
    if (Object.values(t.files).some(
      (g) => g.name === f && g.folderId === h
    )) {
      alert("File already exists");
      return;
    }
    const [p, m] = f.split(".");
    if (!m) {
      window.alert("Files must have extensions");
      return;
    }
    const y = eT(Object.values(t.files));
    e({
      fileId: y,
      fileName: f,
      folderId: h
    });
  }, l = (h) => {
    const f = t.files[h], d = window.prompt("Please enter your destination folder") ?? "";
    try {
      const p = Qp(d.split("/"), {
        folders: Object.values(t.folders),
        required: !0
      });
      if (Object.values(t.files).some(
        (y) => y.name === f.name && y.folderId === p
      )) {
        alert("File already exists");
        return;
      }
      n(h, p);
    } catch (p) {
      window.alert(Zp(p));
    }
  }, c = (h) => {
    const f = t.files[h], d = window.prompt("Rename file", f.name);
    if (d === null || d === f.name)
      return;
    if (Object.values(t.files).some(
      (m) => m.name === d && m.folderId === f.folderId
    )) {
      alert("File already exists");
      return;
    }
    r(h, d);
  }, u = (h) => {
    const f = t.folders[h], d = window.prompt("Rename folder", f.name);
    if (d === null || d === f.name)
      return;
    if (Object.values(t.folders).some(
      (m) => m.name === d && m.parentId === f.parentId
    )) {
      alert("Folder already exists");
      return;
    }
    i(f.id, d);
  };
  return /* @__PURE__ */ M.jsxs("div", { children: [
    /* @__PURE__ */ M.jsxs("div", { className: "files-toolbar", children: [
      /* @__PURE__ */ M.jsx("button", { type: "button", onClick: () => o(), children: "New Folder" }),
      /* @__PURE__ */ M.jsx("button", { type: "button", onClick: () => a(), children: "New File" })
    ] }),
    /* @__PURE__ */ M.jsx("ul", { children: /* @__PURE__ */ M.jsx(
      j0,
      {
        parentId: gn,
        folders: t.folders,
        newFolderPrompt: o,
        files: t.files,
        newFilePrompt: a,
        moveFilePrompt: l,
        renameFilePrompt: c,
        renameFolderPrompt: u
      }
    ) })
  ] });
}, lT = () => {
  const {
    config: { instructions: t }
  } = vt();
  return /* @__PURE__ */ M.jsx("div", { className: "instructions", children: t });
}, uT = () => /* @__PURE__ */ M.jsx("div", { children: "Search is not yet implemented. Sorry." }), cT = {
  Instructions: lT,
  Files: aT,
  Search: uT
}, hT = () => {
  const { config: t } = vt(), [e, r] = jr(
    t.activeLeftNav || t.leftNav[0].component
  ), n = cT[e];
  return /* @__PURE__ */ M.jsxs(
    "div",
    {
      className: "left-pane-outer",
      style: { gridTemplateColumns: t.showSideBar ? "1fr 9fr" : "1fr" },
      children: [
        t.showSideBar && /* @__PURE__ */ M.jsx(oT, {}),
        /* @__PURE__ */ M.jsxs("div", { className: "left-pane-inner", children: [
          /* @__PURE__ */ M.jsx("div", { className: "left-nav", children: /* @__PURE__ */ M.jsx(sT, { setActivePane: r, activePane: e }) }),
          /* @__PURE__ */ M.jsx("div", { className: "left-main", children: /* @__PURE__ */ M.jsx(n, {}) })
        ] })
      ]
    }
  );
}, fT = () => {
  const { project: t, closeFile: e, setActiveFile: r } = vt(), n = $0(t.files, { mustBeOpen: !0 });
  return /* @__PURE__ */ M.jsx("div", { className: "files-nav-bar", children: n.map((i) => /* @__PURE__ */ M.jsxs("div", { className: "file-tab", style: { cursor: "pointer" }, children: [
    /* @__PURE__ */ M.jsx(
      "span",
      {
        onClick: () => r(i.id),
        style: { fontWeight: i.active ? "bold" : "normal" },
        children: i.name
      }
    ),
    /* @__PURE__ */ M.jsx("span", { onClick: () => e(i.id), children: "X" })
  ] }, i.id)) });
};
function wu() {
  return wu = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, wu.apply(this, arguments);
}
function dT(t, e) {
  if (t == null)
    return {};
  var r = {}, n = Object.keys(t), i, s;
  for (s = 0; s < n.length; s++)
    i = n[s], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
  return r;
}
class le {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, r, n) {
    [e, r] = li(this, e, r);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), n.length && n.decompose(
      0,
      n.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      r,
      this.length,
      i,
      1
      /* Open.From */
    ), Qt.from(i, this.length - (r - e) + n.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, r = this.length) {
    [e, r] = li(this, e, r);
    let n = [];
    return this.decompose(e, r, n, 0), Qt.from(n, r - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let r = this.scanIdentical(e, 1), n = this.length - this.scanIdentical(e, -1), i = new Xi(this), s = new Xi(e);
    for (let o = r, a = r; ; ) {
      if (i.next(o), s.next(o), o = 0, i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)
        return !1;
      if (a += i.value.length, i.done || a >= n)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Xi(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, r = this.length) {
    return new W0(this, e, r);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, r) {
    let n;
    if (e == null)
      n = this.iter();
    else {
      r == null && (r = this.lines + 1);
      let i = this.line(e).from;
      n = this.iterRange(i, Math.max(i, r == this.lines + 1 ? this.length : r <= 1 ? 0 : this.line(r - 1).to));
    }
    return new q0(n);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? le.empty : e.length <= 32 ? new Se(e) : Qt.from(Se.split(e, []));
  }
}
class Se extends le {
  constructor(e, r = pT(e)) {
    super(), this.text = e, this.length = r;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, r, n, i) {
    for (let s = 0; ; s++) {
      let o = this.text[s], a = i + o.length;
      if ((r ? n : a) >= e)
        return new mT(i, a, n, o);
      i = a + 1, n++;
    }
  }
  decompose(e, r, n, i) {
    let s = e <= 0 && r >= this.length ? this : new Se(od(this.text, e, r), Math.min(r, this.length) - Math.max(0, e));
    if (i & 1) {
      let o = n.pop(), a = To(s.text, o.text.slice(), 0, s.length);
      if (a.length <= 32)
        n.push(new Se(a, o.length + s.length));
      else {
        let l = a.length >> 1;
        n.push(new Se(a.slice(0, l)), new Se(a.slice(l)));
      }
    } else
      n.push(s);
  }
  replace(e, r, n) {
    if (!(n instanceof Se))
      return super.replace(e, r, n);
    [e, r] = li(this, e, r);
    let i = To(this.text, To(n.text, od(this.text, 0, e)), r), s = this.length + n.length - (r - e);
    return i.length <= 32 ? new Se(i, s) : Qt.from(Se.split(i, []), s);
  }
  sliceString(e, r = this.length, n = `
`) {
    [e, r] = li(this, e, r);
    let i = "";
    for (let s = 0, o = 0; s <= r && o < this.text.length; o++) {
      let a = this.text[o], l = s + a.length;
      s > e && o && (i += n), e < l && r > s && (i += a.slice(Math.max(0, e - s), r - s)), s = l + 1;
    }
    return i;
  }
  flatten(e) {
    for (let r of this.text)
      e.push(r);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, r) {
    let n = [], i = -1;
    for (let s of e)
      n.push(s), i += s.length + 1, n.length == 32 && (r.push(new Se(n, i)), n = [], i = -1);
    return i > -1 && r.push(new Se(n, i)), r;
  }
}
class Qt extends le {
  constructor(e, r) {
    super(), this.children = e, this.length = r, this.lines = 0;
    for (let n of e)
      this.lines += n.lines;
  }
  lineInner(e, r, n, i) {
    for (let s = 0; ; s++) {
      let o = this.children[s], a = i + o.length, l = n + o.lines - 1;
      if ((r ? l : a) >= e)
        return o.lineInner(e, r, n, i);
      i = a + 1, n = l + 1;
    }
  }
  decompose(e, r, n, i) {
    for (let s = 0, o = 0; o <= r && s < this.children.length; s++) {
      let a = this.children[s], l = o + a.length;
      if (e <= l && r >= o) {
        let c = i & ((o <= e ? 1 : 0) | (l >= r ? 2 : 0));
        o >= e && l <= r && !c ? n.push(a) : a.decompose(e - o, r - o, n, c);
      }
      o = l + 1;
    }
  }
  replace(e, r, n) {
    if ([e, r] = li(this, e, r), n.lines < this.lines)
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let o = this.children[i], a = s + o.length;
        if (e >= s && r <= a) {
          let l = o.replace(e - s, r - s, n), c = this.lines - o.lines + l.lines;
          if (l.lines < c >> 4 && l.lines > c >> 6) {
            let u = this.children.slice();
            return u[i] = l, new Qt(u, this.length - (r - e) + n.length);
          }
          return super.replace(s, a, l);
        }
        s = a + 1;
      }
    return super.replace(e, r, n);
  }
  sliceString(e, r = this.length, n = `
`) {
    [e, r] = li(this, e, r);
    let i = "";
    for (let s = 0, o = 0; s < this.children.length && o <= r; s++) {
      let a = this.children[s], l = o + a.length;
      o > e && s && (i += n), e < l && r > o && (i += a.sliceString(e - o, r - o, n)), o = l + 1;
    }
    return i;
  }
  flatten(e) {
    for (let r of this.children)
      r.flatten(e);
  }
  scanIdentical(e, r) {
    if (!(e instanceof Qt))
      return 0;
    let n = 0, [i, s, o, a] = r > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += r, s += r) {
      if (i == o || s == a)
        return n;
      let l = this.children[i], c = e.children[s];
      if (l != c)
        return n + l.scanIdentical(c, r);
      n += l.length + 1;
    }
  }
  static from(e, r = e.reduce((n, i) => n + i.length + 1, -1)) {
    let n = 0;
    for (let d of e)
      n += d.lines;
    if (n < 32) {
      let d = [];
      for (let p of e)
        p.flatten(d);
      return new Se(d, r);
    }
    let i = Math.max(
      32,
      n >> 5
      /* Tree.BranchShift */
    ), s = i << 1, o = i >> 1, a = [], l = 0, c = -1, u = [];
    function h(d) {
      let p;
      if (d.lines > s && d instanceof Qt)
        for (let m of d.children)
          h(m);
      else
        d.lines > o && (l > o || !l) ? (f(), a.push(d)) : d instanceof Se && l && (p = u[u.length - 1]) instanceof Se && d.lines + p.lines <= 32 ? (l += d.lines, c += d.length + 1, u[u.length - 1] = new Se(p.text.concat(d.text), p.length + 1 + d.length)) : (l + d.lines > i && f(), l += d.lines, c += d.length + 1, u.push(d));
    }
    function f() {
      l != 0 && (a.push(u.length == 1 ? u[0] : Qt.from(u, c)), c = -1, l = u.length = 0);
    }
    for (let d of e)
      h(d);
    return f(), a.length == 1 ? a[0] : new Qt(a, r);
  }
}
le.empty = /* @__PURE__ */ new Se([""], 0);
function pT(t) {
  let e = -1;
  for (let r of t)
    e += r.length + 1;
  return e;
}
function To(t, e, r = 0, n = 1e9) {
  for (let i = 0, s = 0, o = !0; s < t.length && i <= n; s++) {
    let a = t[s], l = i + a.length;
    l >= r && (l > n && (a = a.slice(0, n - i)), i < r && (a = a.slice(r - i)), o ? (e[e.length - 1] += a, o = !1) : e.push(a)), i = l + 1;
  }
  return e;
}
function od(t, e, r) {
  return To(t, [""], e, r);
}
class Xi {
  constructor(e, r = 1) {
    this.dir = r, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [r > 0 ? 1 : (e instanceof Se ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, r) {
    for (this.done = this.lineBreak = !1; ; ) {
      let n = this.nodes.length - 1, i = this.nodes[n], s = this.offsets[n], o = s >> 1, a = i instanceof Se ? i.text.length : i.children.length;
      if (o == (r > 0 ? a : 0)) {
        if (n == 0)
          return this.done = !0, this.value = "", this;
        r > 0 && this.offsets[n - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (r > 0 ? 0 : 1)) {
        if (this.offsets[n] += r, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof Se) {
        let l = i.text[o + (r < 0 ? -1 : 0)];
        if (this.offsets[n] += r, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : r > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = i.children[o + (r < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[n] += r) : (r < 0 && this.offsets[n]--, this.nodes.push(l), this.offsets.push(r > 0 ? 1 : (l instanceof Se ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class W0 {
  constructor(e, r, n) {
    this.value = "", this.done = !1, this.cursor = new Xi(e, r > n ? -1 : 1), this.pos = r > n ? e.length : 0, this.from = Math.min(r, n), this.to = Math.max(r, n);
  }
  nextInner(e, r) {
    if (r < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, r < 0 ? this.pos - this.to : this.from - this.pos);
    let n = r < 0 ? this.pos - this.from : this.to - this.pos;
    e > n && (e = n), n -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * r, this.value = i.length <= n ? i : r < 0 ? i.slice(i.length - n) : i.slice(0, n), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class q0 {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: r, lineBreak: n, value: i } = this.inner.next(e);
    return r && this.afterBreak ? (this.value = "", this.afterBreak = !1) : r ? (this.done = !0, this.value = "") : n ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (le.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Xi.prototype[Symbol.iterator] = W0.prototype[Symbol.iterator] = q0.prototype[Symbol.iterator] = function() {
  return this;
});
class mT {
  /**
  @internal
  */
  constructor(e, r, n, i) {
    this.from = e, this.to = r, this.number = n, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function li(t, e, r) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, r))];
}
let Zn = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
for (let t = 1; t < Zn.length; t++)
  Zn[t] += Zn[t - 1];
function gT(t) {
  for (let e = 1; e < Zn.length; e += 2)
    if (Zn[e] > t)
      return Zn[e - 1] <= t;
  return !1;
}
function ad(t) {
  return t >= 127462 && t <= 127487;
}
const ld = 8205;
function Ie(t, e, r = !0, n = !0) {
  return (r ? H0 : yT)(t, e, n);
}
function H0(t, e, r) {
  if (e == t.length)
    return e;
  e && V0(t.charCodeAt(e)) && z0(t.charCodeAt(e - 1)) && e--;
  let n = Me(t, e);
  for (e += St(n); e < t.length; ) {
    let i = Me(t, e);
    if (n == ld || i == ld || r && gT(i))
      e += St(i), n = i;
    else if (ad(i)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && ad(Me(t, o)); )
        s++, o -= 2;
      if (s % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function yT(t, e, r) {
  for (; e > 0; ) {
    let n = H0(t, e - 2, r);
    if (n < e)
      return n;
    e--;
  }
  return 0;
}
function V0(t) {
  return t >= 56320 && t < 57344;
}
function z0(t) {
  return t >= 55296 && t < 56320;
}
function Me(t, e) {
  let r = t.charCodeAt(e);
  if (!z0(r) || e + 1 == t.length)
    return r;
  let n = t.charCodeAt(e + 1);
  return V0(n) ? (r - 55296 << 10) + (n - 56320) + 65536 : r;
}
function Ch(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function St(t) {
  return t < 65536 ? 1 : 2;
}
const xu = /\r\n?|\n/;
var Qe = /* @__PURE__ */ function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
}(Qe || (Qe = {}));
class nr {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2)
      e += this.sections[r];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2) {
      let n = this.sections[r + 1];
      e += n < 0 ? this.sections[r] : n;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let r = 0, n = 0, i = 0; r < this.sections.length; ) {
      let s = this.sections[r++], o = this.sections[r++];
      o < 0 ? (e(n, i, s), i += s) : i += o, n += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, r = !1) {
    Cu(this, e, r);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let r = 0; r < this.sections.length; ) {
      let n = this.sections[r++], i = this.sections[r++];
      i < 0 ? e.push(n, i) : e.push(i, n);
    }
    return new nr(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : U0(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, r = !1) {
    return e.empty ? this : ku(this, e, r);
  }
  mapPos(e, r = -1, n = Qe.Simple) {
    let i = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let a = this.sections[o++], l = this.sections[o++], c = i + a;
      if (l < 0) {
        if (c > e)
          return s + (e - i);
        s += a;
      } else {
        if (n != Qe.Simple && c >= e && (n == Qe.TrackDel && i < e && c > e || n == Qe.TrackBefore && i < e || n == Qe.TrackAfter && c > e))
          return null;
        if (c > e || c == e && r < 0 && !a)
          return e == i || r < 0 ? s : s + l;
        s += l;
      }
      i = c;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, r = e) {
    for (let n = 0, i = 0; n < this.sections.length && i <= r; ) {
      let s = this.sections[n++], o = this.sections[n++], a = i + s;
      if (o >= 0 && i <= r && a >= e)
        return i < e && a > r ? "cover" : !0;
      i = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let r = 0; r < this.sections.length; ) {
      let n = this.sections[r++], i = this.sections[r++];
      e += (e ? " " : "") + n + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((r) => typeof r != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new nr(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new nr(e);
  }
}
class Fe extends nr {
  constructor(e, r) {
    super(e), this.inserted = r;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Cu(this, (r, n, i, s, o) => e = e.replace(i, i + (n - r), o), !1), e;
  }
  mapDesc(e, r = !1) {
    return ku(this, e, r, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let r = this.sections.slice(), n = [];
    for (let i = 0, s = 0; i < r.length; i += 2) {
      let o = r[i], a = r[i + 1];
      if (a >= 0) {
        r[i] = a, r[i + 1] = o;
        let l = i >> 1;
        for (; n.length < l; )
          n.push(le.empty);
        n.push(o ? e.slice(s, s + o) : le.empty);
      }
      s += o;
    }
    return new Fe(r, n);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : U0(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, r = !1) {
    return e.empty ? this : ku(this, e, r, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, r = !1) {
    Cu(this, e, r);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return nr.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let r = [], n = [], i = [], s = new as(this);
    e:
      for (let o = 0, a = 0; ; ) {
        let l = o == e.length ? 1e9 : e[o++];
        for (; a < l || a == l && s.len == 0; ) {
          if (s.done)
            break e;
          let u = Math.min(s.len, l - a);
          He(i, u, -1);
          let h = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
          He(r, u, h), h > 0 && Nr(n, r, s.text), s.forward(u), a += u;
        }
        let c = e[o++];
        for (; a < c; ) {
          if (s.done)
            break e;
          let u = Math.min(s.len, c - a);
          He(r, u, -1), He(i, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(u), a += u;
        }
      }
    return {
      changes: new Fe(r, n),
      filtered: nr.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let r = 0; r < this.sections.length; r += 2) {
      let n = this.sections[r], i = this.sections[r + 1];
      i < 0 ? e.push(n) : i == 0 ? e.push([n]) : e.push([n].concat(this.inserted[r >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, r, n) {
    let i = [], s = [], o = 0, a = null;
    function l(u = !1) {
      if (!u && !i.length)
        return;
      o < r && He(i, r - o, -1);
      let h = new Fe(i, s);
      a = a ? a.compose(h.map(a)) : h, i = [], s = [], o = 0;
    }
    function c(u) {
      if (Array.isArray(u))
        for (let h of u)
          c(h);
      else if (u instanceof Fe) {
        if (u.length != r)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${r})`);
        l(), a = a ? a.compose(u.map(a)) : u;
      } else {
        let { from: h, to: f = h, insert: d } = u;
        if (h > f || h < 0 || f > r)
          throw new RangeError(`Invalid change range ${h} to ${f} (in doc of length ${r})`);
        let p = d ? typeof d == "string" ? le.of(d.split(n || xu)) : d : le.empty, m = p.length;
        if (h == f && m == 0)
          return;
        h < o && l(), h > o && He(i, h - o, -1), He(i, f - h, m), Nr(s, i, p), o = f;
      }
    }
    return c(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new Fe(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let r = [], n = [];
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (typeof s == "number")
        r.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, a) => a && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          r.push(s[0], 0);
        else {
          for (; n.length < i; )
            n.push(le.empty);
          n[i] = le.of(s.slice(1)), r.push(s[0], n[i].length);
        }
      }
    }
    return new Fe(r, n);
  }
  /**
  @internal
  */
  static createSet(e, r) {
    return new Fe(e, r);
  }
}
function He(t, e, r, n = !1) {
  if (e == 0 && r <= 0)
    return;
  let i = t.length - 2;
  i >= 0 && r <= 0 && r == t[i + 1] ? t[i] += e : e == 0 && t[i] == 0 ? t[i + 1] += r : n ? (t[i] += e, t[i + 1] += r) : t.push(e, r);
}
function Nr(t, e, r) {
  if (r.length == 0)
    return;
  let n = e.length - 2 >> 1;
  if (n < t.length)
    t[t.length - 1] = t[t.length - 1].append(r);
  else {
    for (; t.length < n; )
      t.push(le.empty);
    t.push(r);
  }
}
function Cu(t, e, r) {
  let n = t.inserted;
  for (let i = 0, s = 0, o = 0; o < t.sections.length; ) {
    let a = t.sections[o++], l = t.sections[o++];
    if (l < 0)
      i += a, s += a;
    else {
      let c = i, u = s, h = le.empty;
      for (; c += a, u += l, l && n && (h = h.append(n[o - 2 >> 1])), !(r || o == t.sections.length || t.sections[o + 1] < 0); )
        a = t.sections[o++], l = t.sections[o++];
      e(i, c, s, u, h), i = c, s = u;
    }
  }
}
function ku(t, e, r, n = !1) {
  let i = [], s = n ? [] : null, o = new as(t), a = new as(e);
  for (let l = -1; ; )
    if (o.ins == -1 && a.ins == -1) {
      let c = Math.min(o.len, a.len);
      He(i, c, -1), o.forward(c), a.forward(c);
    } else if (a.ins >= 0 && (o.ins < 0 || l == o.i || o.off == 0 && (a.len < o.len || a.len == o.len && !r))) {
      let c = a.len;
      for (He(i, a.ins, -1); c; ) {
        let u = Math.min(o.len, c);
        o.ins >= 0 && l < o.i && o.len <= u && (He(i, 0, o.ins), s && Nr(s, i, o.text), l = o.i), o.forward(u), c -= u;
      }
      a.next();
    } else if (o.ins >= 0) {
      let c = 0, u = o.len;
      for (; u; )
        if (a.ins == -1) {
          let h = Math.min(u, a.len);
          c += h, u -= h, a.forward(h);
        } else if (a.ins == 0 && a.len < u)
          u -= a.len, a.next();
        else
          break;
      He(i, c, l < o.i ? o.ins : 0), s && l < o.i && Nr(s, i, o.text), l = o.i, o.forward(o.len - u);
    } else {
      if (o.done && a.done)
        return s ? Fe.createSet(i, s) : nr.create(i);
      throw new Error("Mismatched change set lengths");
    }
}
function U0(t, e, r = !1) {
  let n = [], i = r ? [] : null, s = new as(t), o = new as(e);
  for (let a = !1; ; ) {
    if (s.done && o.done)
      return i ? Fe.createSet(n, i) : nr.create(n);
    if (s.ins == 0)
      He(n, s.len, 0, a), s.next();
    else if (o.len == 0 && !o.done)
      He(n, 0, o.ins, a), i && Nr(i, n, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(s.len2, o.len), c = n.length;
        if (s.ins == -1) {
          let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          He(n, l, u, a), i && u && Nr(i, n, o.text);
        } else
          o.ins == -1 ? (He(n, s.off ? 0 : s.len, l, a), i && Nr(i, n, s.textBit(l))) : (He(n, s.off ? 0 : s.len, o.off ? 0 : o.ins, a), i && !o.off && Nr(i, n, o.text));
        a = (s.ins > l || o.ins >= 0 && o.len > l) && (a || n.length > c), s.forward2(l), o.forward(l);
      }
    }
  }
}
class as {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, r = this.i - 2 >> 1;
    return r >= e.length ? le.empty : e[r];
  }
  textBit(e) {
    let { inserted: r } = this.set, n = this.i - 2 >> 1;
    return n >= r.length && !e ? le.empty : r[n].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class pn {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.flags = n;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, r = -1) {
    let n, i;
    return this.empty ? n = i = e.mapPos(this.from, r) : (n = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), n == this.from && i == this.to ? this : new pn(n, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, r = e) {
    if (e <= this.anchor && r >= this.anchor)
      return B.range(e, r);
    let n = Math.abs(e - this.anchor) > Math.abs(r - this.anchor) ? e : r;
    return B.range(this.anchor, n);
  }
  /**
  Compare this range to another range.
  */
  eq(e, r = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!r || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return B.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new pn(e, r, n);
  }
}
class B {
  constructor(e, r) {
    this.ranges = e, this.mainIndex = r;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, r = -1) {
    return e.empty ? this : B.create(this.ranges.map((n) => n.map(e, r)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, r = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let n = 0; n < this.ranges.length; n++)
      if (!this.ranges[n].eq(e.ranges[n], r))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new B([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, r = !0) {
    return B.create([e].concat(this.ranges), r ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, r = this.mainIndex) {
    let n = this.ranges.slice();
    return n[r] = e, B.create(n, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new B(e.ranges.map((r) => pn.fromJSON(r)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, r = e) {
    return new B([B.range(e, r)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, r = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let n = 0, i = 0; i < e.length; i++) {
      let s = e[i];
      if (s.empty ? s.from <= n : s.from < n)
        return B.normalized(e.slice(), r);
      n = s.to;
    }
    return new B(e, r);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, r = 0, n, i) {
    return pn.create(e, e, (r == 0 ? 0 : r < 0 ? 8 : 16) | (n == null ? 7 : Math.min(6, n)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, r, n, i) {
    let s = (n ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return r < e ? pn.create(r, e, 48 | s) : pn.create(e, r, (r > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, r = 0) {
    let n = e[r];
    e.sort((i, s) => i.from - s.from), r = e.indexOf(n);
    for (let i = 1; i < e.length; i++) {
      let s = e[i], o = e[i - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let a = o.from, l = Math.max(s.to, o.to);
        i <= r && r--, e.splice(--i, 2, s.anchor > s.head ? B.range(l, a) : B.range(a, l));
      }
    }
    return new B(e, r);
  }
}
function G0(t, e) {
  for (let r of t.ranges)
    if (r.to > e)
      throw new RangeError("Selection points outside of document");
}
let kh = 0;
class z {
  constructor(e, r, n, i, s) {
    this.combine = e, this.compareInput = r, this.compare = n, this.isStatic = i, this.id = kh++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new z(e.combine || ((r) => r), e.compareInput || ((r, n) => r === n), e.compare || (e.combine ? (r, n) => r === n : Sh), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new _o([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new _o(e, this, 1, r);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new _o(e, this, 2, r);
  }
  from(e, r) {
    return r || (r = (n) => n), this.compute([e], (n) => r(n.field(e)));
  }
}
function Sh(t, e) {
  return t == e || t.length == e.length && t.every((r, n) => r === e[n]);
}
class _o {
  constructor(e, r, n, i) {
    this.dependencies = e, this.facet = r, this.type = n, this.value = i, this.id = kh++;
  }
  dynamicSlot(e) {
    var r;
    let n = this.value, i = this.facet.compareInput, s = this.id, o = e[s] >> 1, a = this.type == 2, l = !1, c = !1, u = [];
    for (let h of this.dependencies)
      h == "doc" ? l = !0 : h == "selection" ? c = !0 : ((r = e[h.id]) !== null && r !== void 0 ? r : 1) & 1 || u.push(e[h.id]);
    return {
      create(h) {
        return h.values[o] = n(h), 1;
      },
      update(h, f) {
        if (l && f.docChanged || c && (f.docChanged || f.selection) || Su(h, u)) {
          let d = n(h);
          if (a ? !ud(d, h.values[o], i) : !i(d, h.values[o]))
            return h.values[o] = d, 1;
        }
        return 0;
      },
      reconfigure: (h, f) => {
        let d, p = f.config.address[s];
        if (p != null) {
          let m = Yo(f, p);
          if (this.dependencies.every((y) => y instanceof z ? f.facet(y) === h.facet(y) : y instanceof We ? f.field(y, !1) == h.field(y, !1) : !0) || (a ? ud(d = n(h), m, i) : i(d = n(h), m)))
            return h.values[o] = m, 0;
        } else
          d = n(h);
        return h.values[o] = d, 1;
      }
    };
  }
}
function ud(t, e, r) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!r(t[n], e[n]))
      return !1;
  return !0;
}
function Su(t, e) {
  let r = !1;
  for (let n of e)
    Qi(t, n) & 1 && (r = !0);
  return r;
}
function vT(t, e, r) {
  let n = r.map((l) => t[l.id]), i = r.map((l) => l.type), s = n.filter((l) => !(l & 1)), o = t[e.id] >> 1;
  function a(l) {
    let c = [];
    for (let u = 0; u < n.length; u++) {
      let h = Yo(l, n[u]);
      if (i[u] == 2)
        for (let f of h)
          c.push(f);
      else
        c.push(h);
    }
    return e.combine(c);
  }
  return {
    create(l) {
      for (let c of n)
        Qi(l, c);
      return l.values[o] = a(l), 1;
    },
    update(l, c) {
      if (!Su(l, s))
        return 0;
      let u = a(l);
      return e.compare(u, l.values[o]) ? 0 : (l.values[o] = u, 1);
    },
    reconfigure(l, c) {
      let u = Su(l, n), h = c.config.facets[e.id], f = c.facet(e);
      if (h && !u && Sh(r, h))
        return l.values[o] = f, 0;
      let d = a(l);
      return e.compare(d, f) ? (l.values[o] = f, 0) : (l.values[o] = d, 1);
    }
  };
}
const cd = /* @__PURE__ */ z.define({ static: !0 });
class We {
  constructor(e, r, n, i, s) {
    this.id = e, this.createF = r, this.updateF = n, this.compareF = i, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let r = new We(kh++, e.create, e.update, e.compare || ((n, i) => n === i), e);
    return e.provide && (r.provides = e.provide(r)), r;
  }
  create(e) {
    let r = e.facet(cd).find((n) => n.field == this);
    return ((r == null ? void 0 : r.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let r = e[this.id] >> 1;
    return {
      create: (n) => (n.values[r] = this.create(n), 1),
      update: (n, i) => {
        let s = n.values[r], o = this.updateF(s, i);
        return this.compareF(s, o) ? 0 : (n.values[r] = o, 1);
      },
      reconfigure: (n, i) => i.config.address[this.id] != null ? (n.values[r] = i.field(this), 0) : (n.values[r] = this.create(n), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, cd.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const cn = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Bi(t) {
  return (e) => new K0(e, t);
}
const Di = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Bi(cn.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Bi(cn.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Bi(cn.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Bi(cn.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Bi(cn.lowest)
};
class K0 {
  constructor(e, r) {
    this.inner = e, this.prec = r;
  }
}
class Ya {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new Eu(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Ya.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class Eu {
  constructor(e, r) {
    this.compartment = e, this.inner = r;
  }
}
class Ko {
  constructor(e, r, n, i, s, o) {
    for (this.base = e, this.compartments = r, this.dynamicSlots = n, this.address = i, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < n.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let r = this.address[e.id];
    return r == null ? e.default : this.staticValues[r >> 1];
  }
  static resolve(e, r, n) {
    let i = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let f of bT(e, r, o))
      f instanceof We ? i.push(f) : (s[f.facet.id] || (s[f.facet.id] = [])).push(f);
    let a = /* @__PURE__ */ Object.create(null), l = [], c = [];
    for (let f of i)
      a[f.id] = c.length << 1, c.push((d) => f.slot(d));
    let u = n == null ? void 0 : n.config.facets;
    for (let f in s) {
      let d = s[f], p = d[0].facet, m = u && u[f] || [];
      if (d.every(
        (y) => y.type == 0
        /* Provider.Static */
      ))
        if (a[p.id] = l.length << 1 | 1, Sh(m, d))
          l.push(n.facet(p));
        else {
          let y = p.combine(d.map((v) => v.value));
          l.push(n && p.compare(y, n.facet(p)) ? n.facet(p) : y);
        }
      else {
        for (let y of d)
          y.type == 0 ? (a[y.id] = l.length << 1 | 1, l.push(y.value)) : (a[y.id] = c.length << 1, c.push((v) => y.dynamicSlot(v)));
        a[p.id] = c.length << 1, c.push((y) => vT(y, p, d));
      }
    }
    let h = c.map((f) => f(a));
    return new Ko(e, o, h, a, l, s);
  }
}
function bT(t, e, r) {
  let n = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function s(o, a) {
    let l = i.get(o);
    if (l != null) {
      if (l <= a)
        return;
      let c = n[l].indexOf(o);
      c > -1 && n[l].splice(c, 1), o instanceof Eu && r.delete(o.compartment);
    }
    if (i.set(o, a), Array.isArray(o))
      for (let c of o)
        s(c, a);
    else if (o instanceof Eu) {
      if (r.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      r.set(o.compartment, c), s(c, a);
    } else if (o instanceof K0)
      s(o.inner, o.prec);
    else if (o instanceof We)
      n[a].push(o), o.provides && s(o.provides, a);
    else if (o instanceof _o)
      n[a].push(o), o.facet.extensions && s(o.facet.extensions, cn.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(c, a);
    }
  }
  return s(t, cn.default), n.reduce((o, a) => o.concat(a));
}
function Qi(t, e) {
  if (e & 1)
    return 2;
  let r = e >> 1, n = t.status[r];
  if (n == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (n & 2)
    return n;
  t.status[r] = 4;
  let i = t.computeSlot(t, t.config.dynamicSlots[r]);
  return t.status[r] = 2 | i;
}
function Yo(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const Y0 = /* @__PURE__ */ z.define(), Au = /* @__PURE__ */ z.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), J0 = /* @__PURE__ */ z.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), X0 = /* @__PURE__ */ z.define(), Q0 = /* @__PURE__ */ z.define(), Z0 = /* @__PURE__ */ z.define(), ey = /* @__PURE__ */ z.define({
  combine: (t) => t.length ? t[0] : !1
});
class lr {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new DT();
  }
}
class DT {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new lr(this, e);
  }
}
class wT {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new J(this, e);
  }
}
class J {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let r = this.type.map(this.value, e);
    return r === void 0 ? void 0 : r == this.value ? this : new J(this.type, r);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new wT(e.map || ((r) => r));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, r) {
    if (!e.length)
      return e;
    let n = [];
    for (let i of e) {
      let s = i.map(r);
      s && n.push(s);
    }
    return n;
  }
}
J.reconfigure = /* @__PURE__ */ J.define();
J.appendConfig = /* @__PURE__ */ J.define();
class Te {
  constructor(e, r, n, i, s, o) {
    this.startState = e, this.changes = r, this.selection = n, this.effects = i, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, n && G0(n, r.newLength), s.some((a) => a.type == Te.time) || (this.annotations = s.concat(Te.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, r, n, i, s, o) {
    return new Te(e, r, n, i, s, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let r of this.annotations)
      if (r.type == e)
        return r.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let r = this.annotation(Te.userEvent);
    return !!(r && (r == e || r.length > e.length && r.slice(0, e.length) == e && r[e.length] == "."));
  }
}
Te.time = /* @__PURE__ */ lr.define();
Te.userEvent = /* @__PURE__ */ lr.define();
Te.addToHistory = /* @__PURE__ */ lr.define();
Te.remote = /* @__PURE__ */ lr.define();
function xT(t, e) {
  let r = [];
  for (let n = 0, i = 0; ; ) {
    let s, o;
    if (n < t.length && (i == e.length || e[i] >= t[n]))
      s = t[n++], o = t[n++];
    else if (i < e.length)
      s = e[i++], o = e[i++];
    else
      return r;
    !r.length || r[r.length - 1] < s ? r.push(s, o) : r[r.length - 1] < o && (r[r.length - 1] = o);
  }
}
function ty(t, e, r) {
  var n;
  let i, s, o;
  return r ? (i = e.changes, s = Fe.empty(e.changes.length), o = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes), s = t.changes.mapDesc(e.changes, !0), o = t.changes.compose(i)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (n = t.selection) === null || n === void 0 ? void 0 : n.map(i),
    effects: J.mapEffects(t.effects, i).concat(J.mapEffects(e.effects, s)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function Fu(t, e, r) {
  let n = e.selection, i = ei(e.annotations);
  return e.userEvent && (i = i.concat(Te.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Fe ? e.changes : Fe.of(e.changes || [], r, t.facet(J0)),
    selection: n && (n instanceof B ? n : B.single(n.anchor, n.head)),
    effects: ei(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function ry(t, e, r) {
  let n = Fu(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (r = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (r = !1);
    let o = !!e[s].sequential;
    n = ty(n, Fu(t, e[s], o ? n.changes.newLength : t.doc.length), o);
  }
  let i = Te.create(t, n.changes, n.selection, n.effects, n.annotations, n.scrollIntoView);
  return kT(r ? CT(i) : i);
}
function CT(t) {
  let e = t.startState, r = !0;
  for (let i of e.facet(X0)) {
    let s = i(t);
    if (s === !1) {
      r = !1;
      break;
    }
    Array.isArray(s) && (r = r === !0 ? s : xT(r, s));
  }
  if (r !== !0) {
    let i, s;
    if (r === !1)
      s = t.changes.invertedDesc, i = Fe.empty(e.doc.length);
    else {
      let o = t.changes.filter(r);
      i = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    t = Te.create(e, i, t.selection && t.selection.map(s), J.mapEffects(t.effects, s), t.annotations, t.scrollIntoView);
  }
  let n = e.facet(Q0);
  for (let i = n.length - 1; i >= 0; i--) {
    let s = n[i](t);
    s instanceof Te ? t = s : Array.isArray(s) && s.length == 1 && s[0] instanceof Te ? t = s[0] : t = ry(e, ei(s), !1);
  }
  return t;
}
function kT(t) {
  let e = t.startState, r = e.facet(Z0), n = t;
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](t);
    s && Object.keys(s).length && (n = ty(n, Fu(e, s, t.changes.newLength), !0));
  }
  return n == t ? t : Te.create(e, t.changes, t.selection, n.effects, n.annotations, n.scrollIntoView);
}
const ST = [];
function ei(t) {
  return t == null ? ST : Array.isArray(t) ? t : [t];
}
var xe = /* @__PURE__ */ function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
}(xe || (xe = {}));
const ET = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Tu;
try {
  Tu = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function AT(t) {
  if (Tu)
    return Tu.test(t);
  for (let e = 0; e < t.length; e++) {
    let r = t[e];
    if (/\w/.test(r) || r > "" && (r.toUpperCase() != r.toLowerCase() || ET.test(r)))
      return !0;
  }
  return !1;
}
function FT(t) {
  return (e) => {
    if (!/\S/.test(e))
      return xe.Space;
    if (AT(e))
      return xe.Word;
    for (let r = 0; r < t.length; r++)
      if (e.indexOf(t[r]) > -1)
        return xe.Word;
    return xe.Other;
  };
}
class ee {
  constructor(e, r, n, i, s, o) {
    this.config = e, this.doc = r, this.selection = n, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      Qi(this, a << 1);
    this.computeSlot = null;
  }
  field(e, r = !0) {
    let n = this.config.address[e.id];
    if (n == null) {
      if (r)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Qi(this, n), Yo(this, n);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return ry(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let r = this.config, { base: n, compartments: i } = r;
    for (let a of e.effects)
      a.is(Ya.reconfigure) ? (r && (i = /* @__PURE__ */ new Map(), r.compartments.forEach((l, c) => i.set(c, l)), r = null), i.set(a.value.compartment, a.value.extension)) : a.is(J.reconfigure) ? (r = null, n = a.value) : a.is(J.appendConfig) && (r = null, n = ei(n).concat(a.value));
    let s;
    r ? s = e.startState.values.slice() : (r = Ko.resolve(n, i, this), s = new ee(r, this.doc, this.selection, r.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
    let o = e.startState.facet(Au) ? e.newSelection : e.newSelection.asSingle();
    new ee(r, e.newDoc, o, s, (a, l) => l.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((r) => ({
      changes: { from: r.from, to: r.to, insert: e },
      range: B.cursor(r.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let r = this.selection, n = e(r.ranges[0]), i = this.changes(n.changes), s = [n.range], o = ei(n.effects);
    for (let a = 1; a < r.ranges.length; a++) {
      let l = e(r.ranges[a]), c = this.changes(l.changes), u = c.map(i);
      for (let f = 0; f < a; f++)
        s[f] = s[f].map(u);
      let h = i.mapDesc(c, !0);
      s.push(l.range.map(h)), i = i.compose(u), o = J.mapEffects(o, u).concat(J.mapEffects(ei(l.effects), h));
    }
    return {
      changes: i,
      selection: B.create(s, r.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof Fe ? e : Fe.of(e, this.doc.length, this.facet(ee.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return le.of(e.split(this.facet(ee.lineSeparator) || xu));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, r = this.doc.length) {
    return this.doc.sliceString(e, r, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let r = this.config.address[e.id];
    return r == null ? e.default : (Qi(this, r), Yo(this, r));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let r = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let n in e) {
        let i = e[n];
        i instanceof We && this.config.address[i.id] != null && (r[n] = i.spec.toJSON(this.field(e[n]), this));
      }
    return r;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, r = {}, n) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (n) {
      for (let s in n)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = n[s], a = e[s];
          i.push(o.init((l) => o.spec.fromJSON(a, l)));
        }
    }
    return ee.create({
      doc: e.doc,
      selection: B.fromJSON(e.selection),
      extensions: r.extensions ? i.concat([r.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let r = Ko.resolve(e.extensions || [], /* @__PURE__ */ new Map()), n = e.doc instanceof le ? e.doc : le.of((e.doc || "").split(r.staticFacet(ee.lineSeparator) || xu)), i = e.selection ? e.selection instanceof B ? e.selection : B.single(e.selection.anchor, e.selection.head) : B.single(0);
    return G0(i, n.length), r.staticFacet(Au) || (i = i.asSingle()), new ee(r, n, i, r.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(ee.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(ee.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(ey);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...r) {
    for (let n of this.facet(ee.phrases))
      if (Object.prototype.hasOwnProperty.call(n, e)) {
        e = n[e];
        break;
      }
    return r.length && (e = e.replace(/\$(\$|\d*)/g, (n, i) => {
      if (i == "$")
        return "$";
      let s = +(i || 1);
      return !s || s > r.length ? n : r[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, r, n = -1) {
    let i = [];
    for (let s of this.facet(Y0))
      for (let o of s(this, r, n))
        Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return FT(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: r, from: n, length: i } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - n, a = e - n;
    for (; o > 0; ) {
      let l = Ie(r, o, !1);
      if (s(r.slice(l, o)) != xe.Word)
        break;
      o = l;
    }
    for (; a < i; ) {
      let l = Ie(r, a);
      if (s(r.slice(a, l)) != xe.Word)
        break;
      a = l;
    }
    return o == a ? null : B.range(o + n, a + n);
  }
}
ee.allowMultipleSelections = Au;
ee.tabSize = /* @__PURE__ */ z.define({
  combine: (t) => t.length ? t[0] : 4
});
ee.lineSeparator = J0;
ee.readOnly = ey;
ee.phrases = /* @__PURE__ */ z.define({
  compare(t, e) {
    let r = Object.keys(t), n = Object.keys(e);
    return r.length == n.length && r.every((i) => t[i] == e[i]);
  }
});
ee.languageData = Y0;
ee.changeFilter = X0;
ee.transactionFilter = Q0;
ee.transactionExtender = Z0;
Ya.reconfigure = /* @__PURE__ */ J.define();
function ur(t, e, r = {}) {
  let n = {};
  for (let i of t)
    for (let s of Object.keys(i)) {
      let o = i[s], a = n[s];
      if (a === void 0)
        n[s] = o;
      else if (!(a === o || o === void 0))
        if (Object.hasOwnProperty.call(r, s))
          n[s] = r[s](a, o);
        else
          throw new Error("Config merge conflict for field " + s);
    }
  for (let i in e)
    n[i] === void 0 && (n[i] = e[i]);
  return n;
}
class Cn {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, r = e) {
    return _u.create(e, r, this);
  }
}
Cn.prototype.startSide = Cn.prototype.endSide = 0;
Cn.prototype.point = !1;
Cn.prototype.mapMode = Qe.TrackDel;
let _u = class ny {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.value = n;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new ny(e, r, n);
  }
};
function Bu(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class Eh {
  constructor(e, r, n, i) {
    this.from = e, this.to = r, this.value = n, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, r, n, i = 0) {
    let s = n ? this.to : this.from;
    for (let o = i, a = s.length; ; ) {
      if (o == a)
        return o;
      let l = o + a >> 1, c = s[l] - e || (n ? this.value[l].endSide : this.value[l].startSide) - r;
      if (l == o)
        return c >= 0 ? o : a;
      c >= 0 ? a = l : o = l + 1;
    }
  }
  between(e, r, n, i) {
    for (let s = this.findIndex(r, -1e9, !0), o = this.findIndex(n, 1e9, !1, s); s < o; s++)
      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, r) {
    let n = [], i = [], s = [], o = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l], u = this.from[l] + e, h = this.to[l] + e, f, d;
      if (u == h) {
        let p = r.mapPos(u, c.startSide, c.mapMode);
        if (p == null || (f = d = p, c.startSide != c.endSide && (d = r.mapPos(u, c.endSide), d < f)))
          continue;
      } else if (f = r.mapPos(u, c.startSide), d = r.mapPos(h, c.endSide), f > d || f == d && c.startSide > 0 && c.endSide <= 0)
        continue;
      (d - f || c.endSide - c.startSide) < 0 || (o < 0 && (o = f), c.point && (a = Math.max(a, d - f)), n.push(c), i.push(f - o), s.push(d - o));
    }
    return { mapped: n.length ? new Eh(i, s, n, a) : null, pos: o };
  }
}
class ie {
  constructor(e, r, n, i) {
    this.chunkPos = e, this.chunk = r, this.nextLayer = n, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, r, n, i) {
    return new ie(e, r, n, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let r of this.chunk)
      e += r.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: r = [], sort: n = !1, filterFrom: i = 0, filterTo: s = this.length } = e, o = e.filter;
    if (r.length == 0 && !o)
      return this;
    if (n && (r = r.slice().sort(Bu)), this.isEmpty)
      return r.length ? ie.of(r) : this;
    let a = new iy(this, null, -1).goto(0), l = 0, c = [], u = new Gr();
    for (; a.value || l < r.length; )
      if (l < r.length && (a.from - r[l].from || a.startSide - r[l].value.startSide) >= 0) {
        let h = r[l++];
        u.addInner(h.from, h.to, h.value) || c.push(h);
      } else
        a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == r.length || this.chunkEnd(a.chunkIndex) < r[l].from) && (!o || i > this.chunkEnd(a.chunkIndex) || s < this.chunkPos[a.chunkIndex]) && u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!o || i > a.to || s < a.from || o(a.from, a.to, a.value)) && (u.addInner(a.from, a.to, a.value) || c.push(_u.create(a.from, a.to, a.value))), a.next());
    return u.finishInner(this.nextLayer.isEmpty && !c.length ? ie.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: i, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let r = [], n = [], i = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let a = this.chunkPos[o], l = this.chunk[o], c = e.touchesRange(a, a + l.length);
      if (c === !1)
        i = Math.max(i, l.maxPoint), r.push(l), n.push(e.mapPos(a));
      else if (c === !0) {
        let { mapped: u, pos: h } = l.map(a, e);
        u && (i = Math.max(i, u.maxPoint), r.push(u), n.push(h));
      }
    }
    let s = this.nextLayer.map(e);
    return r.length == 0 ? s : new ie(n, r, s || ie.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, r, n) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i], o = this.chunk[i];
        if (r >= s && e <= s + o.length && o.between(s, e - s, r - s, n) === !1)
          return;
      }
      this.nextLayer.between(e, r, n);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return ls.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, r = 0) {
    return ls.from(e).goto(r);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, r, n, i, s = -1) {
    let o = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s), a = r.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s), l = hd(o, a, n), c = new Oi(o, l, s), u = new Oi(a, l, s);
    n.iterGaps((h, f, d) => fd(c, h, u, f, d, i)), n.empty && n.length == 0 && fd(c, 0, u, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, r, n = 0, i) {
    i == null && (i = 999999999);
    let s = e.filter((u) => !u.isEmpty && r.indexOf(u) < 0), o = r.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let a = hd(s, o), l = new Oi(s, a, 0).goto(n), c = new Oi(o, a, 0).goto(n);
    for (; ; ) {
      if (l.to != c.to || !Ou(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
        return !1;
      if (l.to > i)
        return !0;
      l.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, r, n, i, s = -1) {
    let o = new Oi(e, null, s).goto(r), a = r, l = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, n);
      if (o.point) {
        let u = o.activeForPoint(o.to), h = o.pointFrom < r ? u.length + 1 : Math.min(u.length, l);
        i.point(a, c, o.point, u, h, o.pointRank), l = Math.min(o.openEnd(c), u.length);
      } else
        c > a && (i.span(a, c, o.active, l), l = o.openEnd(c));
      if (o.to > n)
        return l + (o.point && o.to > n ? 1 : 0);
      a = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, r = !1) {
    let n = new Gr();
    for (let i of e instanceof _u ? [e] : r ? TT(e) : e)
      n.add(i.from, i.to, i.value);
    return n.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return ie.empty;
    let r = e[e.length - 1];
    for (let n = e.length - 2; n >= 0; n--)
      for (let i = e[n]; i != ie.empty; i = i.nextLayer)
        r = new ie(i.chunkPos, i.chunk, r, Math.max(i.maxPoint, r.maxPoint));
    return r;
  }
}
ie.empty = /* @__PURE__ */ new ie([], [], null, -1);
function TT(t) {
  if (t.length > 1)
    for (let e = t[0], r = 1; r < t.length; r++) {
      let n = t[r];
      if (Bu(e, n) > 0)
        return t.slice().sort(Bu);
      e = n;
    }
  return t;
}
ie.empty.nextLayer = ie.empty;
class Gr {
  finishChunk(e) {
    this.chunks.push(new Eh(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, r, n) {
    this.addInner(e, r, n) || (this.nextLayer || (this.nextLayer = new Gr())).add(e, r, n);
  }
  /**
  @internal
  */
  addInner(e, r, n) {
    let i = e - this.lastTo || n.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || n.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(r - this.chunkStart), this.last = n, this.lastFrom = e, this.lastTo = r, this.value.push(n), n.point && (this.maxPoint = Math.max(this.maxPoint, r - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, r) {
    if ((e - this.lastTo || r.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, r.maxPoint), this.chunks.push(r), this.chunkPos.push(e);
    let n = r.value.length - 1;
    return this.last = r.value[n], this.lastFrom = r.from[n] + e, this.lastTo = r.to[n] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(ie.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let r = ie.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, r;
  }
}
function hd(t, e, r) {
  let n = /* @__PURE__ */ new Map();
  for (let s of t)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && n.set(s.chunk[o], s.chunkPos[o]);
  let i = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let a = n.get(s.chunk[o]);
      a != null && (r ? r.mapPos(a) : a) == s.chunkPos[o] && !(r != null && r.touchesRange(a, a + s.chunk[o].length)) && i.add(s.chunk[o]);
    }
  return i;
}
class iy {
  constructor(e, r, n, i = 0) {
    this.layer = e, this.skip = r, this.minPoint = n, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, r = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, r, !1), this;
  }
  gotoInner(e, r, n) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, n = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], r, !0);
      (!n || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, r) {
    (this.to - e || this.endSide - r) < 0 && this.gotoInner(e, r, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], r = this.layer.chunk[this.chunkIndex], n = e + r.from[this.rangeIndex];
        if (this.from = n, this.to = e + r.to[this.rangeIndex], this.value = r.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class ls {
  constructor(e) {
    this.heap = e;
  }
  static from(e, r = null, n = -1) {
    let i = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= n && i.push(new iy(o, r, n, s));
    return i.length == 1 ? i[0] : new ls(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, r = -1e9) {
    for (let n of this.heap)
      n.goto(e, r);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      _l(this.heap, n);
    return this.next(), this;
  }
  forward(e, r) {
    for (let n of this.heap)
      n.forward(e, r);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      _l(this.heap, n);
    (this.to - e || this.value.endSide - r) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), _l(this.heap, 0);
    }
  }
}
function _l(t, e) {
  for (let r = t[e]; ; ) {
    let n = (e << 1) + 1;
    if (n >= t.length)
      break;
    let i = t[n];
    if (n + 1 < t.length && i.compare(t[n + 1]) >= 0 && (i = t[n + 1], n++), r.compare(i) < 0)
      break;
    t[n] = r, t[e] = i, e = n;
  }
}
class Oi {
  constructor(e, r, n) {
    this.minPoint = n, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = ls.from(e, r, n);
  }
  goto(e, r = -1e9) {
    return this.cursor.goto(e, r), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = r, this.openStart = -1, this.next(), this;
  }
  forward(e, r) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - r) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, r);
  }
  removeActive(e) {
    Qs(this.active, e), Qs(this.activeTo, e), Qs(this.activeRank, e), this.minActive = dd(this.active, this.activeTo);
  }
  addActive(e) {
    let r = 0, { value: n, to: i, rank: s } = this.cursor;
    for (; r < this.activeRank.length && (s - this.activeRank[r] || i - this.activeTo[r]) > 0; )
      r++;
    Zs(this.active, r, n), Zs(this.activeTo, r, i), Zs(this.activeRank, r, s), e && Zs(e, r, this.cursor.from), this.minActive = dd(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, r = this.point;
    this.point = null;
    let n = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), n && Qs(n, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(n), this.cursor.next();
          else if (r && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (n) {
      this.openStart = 0;
      for (let i = n.length - 1; i >= 0 && n[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let r = [];
    for (let n = this.active.length - 1; n >= 0 && !(this.activeRank[n] < this.pointRank); n--)
      (this.activeTo[n] > e || this.activeTo[n] == e && this.active[n].endSide >= this.point.endSide) && r.push(this.active[n]);
    return r.reverse();
  }
  openEnd(e) {
    let r = 0;
    for (let n = this.activeTo.length - 1; n >= 0 && this.activeTo[n] > e; n--)
      r++;
    return r;
  }
}
function fd(t, e, r, n, i, s) {
  t.goto(e), r.goto(n);
  let o = n + i, a = n, l = n - e;
  for (; ; ) {
    let c = t.to + l - r.to || t.endSide - r.endSide, u = c < 0 ? t.to + l : r.to, h = Math.min(u, o);
    if (t.point || r.point ? t.point && r.point && (t.point == r.point || t.point.eq(r.point)) && Ou(t.activeForPoint(t.to), r.activeForPoint(r.to)) || s.comparePoint(a, h, t.point, r.point) : h > a && !Ou(t.active, r.active) && s.compareRange(a, h, t.active, r.active), u > o)
      break;
    a = u, c <= 0 && t.next(), c >= 0 && r.next();
  }
}
function Ou(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (t[r] != e[r] && !t[r].eq(e[r]))
      return !1;
  return !0;
}
function Qs(t, e) {
  for (let r = e, n = t.length - 1; r < n; r++)
    t[r] = t[r + 1];
  t.pop();
}
function Zs(t, e, r) {
  for (let n = t.length - 1; n >= e; n--)
    t[n + 1] = t[n];
  t[e] = r;
}
function dd(t, e) {
  let r = -1, n = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - n || t[i].endSide - t[r].endSide) < 0 && (r = i, n = e[i]);
  return r;
}
function wi(t, e, r = t.length) {
  let n = 0;
  for (let i = 0; i < r; )
    t.charCodeAt(i) == 9 ? (n += e - n % e, i++) : (n++, i = Ie(t, i));
  return n;
}
function Mu(t, e, r, n) {
  for (let i = 0, s = 0; ; ) {
    if (s >= e)
      return i;
    if (i == t.length)
      break;
    s += t.charCodeAt(i) == 9 ? r - s % r : 1, i = Ie(t, i);
  }
  return n === !0 ? -1 : t.length;
}
const Lu = "ͼ", pd = typeof Symbol > "u" ? "__" + Lu : Symbol.for(Lu), Pu = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), md = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Kr {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, r) {
    this.rules = [];
    let { finish: n } = r || {};
    function i(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, a, l, c) {
      let u = [], h = /^@(\w+)\b/.exec(o[0]), f = h && h[1] == "keyframes";
      if (h && a == null)
        return l.push(o[0] + ";");
      for (let d in a) {
        let p = a[d];
        if (/&/.test(d))
          s(
            d.split(/,\s*/).map((m) => o.map((y) => m.replace(/&/, y))).reduce((m, y) => m.concat(y)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!h)
            throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          s(i(d), p, u, f);
        } else
          p != null && u.push(d.replace(/_.*/, "").replace(/[A-Z]/g, (m) => "-" + m.toLowerCase()) + ": " + p + ";");
      }
      (u.length || f) && l.push((n && !h && !c ? o.map(n) : o).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let o in e)
      s(i(o), e[o], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = md[pd] || 1;
    return md[pd] = e + 1, Lu + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, r, n) {
    let i = e[Pu], s = n && n.nonce;
    i ? s && i.setNonce(s) : i = new _T(e, s), i.mount(Array.isArray(r) ? r : [r]);
  }
}
let gd = /* @__PURE__ */ new Map();
class _T {
  constructor(e, r) {
    let n = e.ownerDocument || e, i = n.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = gd.get(n);
      if (s)
        return e.adoptedStyleSheets = [s.sheet, ...e.adoptedStyleSheets], e[Pu] = s;
      this.sheet = new i.CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets], gd.set(n, this);
    } else {
      this.styleTag = n.createElement("style"), r && this.styleTag.setAttribute("nonce", r);
      let s = e.head || e;
      s.insertBefore(this.styleTag, s.firstChild);
    }
    this.modules = [], e[Pu] = this;
  }
  mount(e) {
    let r = this.sheet, n = 0, i = 0;
    for (let s = 0; s < e.length; s++) {
      let o = e[s], a = this.modules.indexOf(o);
      if (a < i && a > -1 && (this.modules.splice(a, 1), i--, a = -1), a == -1) {
        if (this.modules.splice(i++, 0, o), r)
          for (let l = 0; l < o.rules.length; l++)
            r.insertRule(o.rules[l], n++);
      } else {
        for (; i < a; )
          n += this.modules[i++].rules.length;
        n += o.rules.length, i++;
      }
    }
    if (!r) {
      let s = "";
      for (let o = 0; o < this.modules.length; o++)
        s += this.modules[o].getRules() + `
`;
      this.styleTag.textContent = s;
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var Yr = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, us = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, BT = typeof navigator < "u" && /Mac/.test(navigator.platform), OT = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Le = 0; Le < 10; Le++)
  Yr[48 + Le] = Yr[96 + Le] = String(Le);
for (var Le = 1; Le <= 24; Le++)
  Yr[Le + 111] = "F" + Le;
for (var Le = 65; Le <= 90; Le++)
  Yr[Le] = String.fromCharCode(Le + 32), us[Le] = String.fromCharCode(Le);
for (var Bl in Yr)
  us.hasOwnProperty(Bl) || (us[Bl] = Yr[Bl]);
function MT(t) {
  var e = BT && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || OT && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", r = !e && t.key || (t.shiftKey ? us : Yr)[t.keyCode] || t.key || "Unidentified";
  return r == "Esc" && (r = "Escape"), r == "Del" && (r = "Delete"), r == "Left" && (r = "ArrowLeft"), r == "Up" && (r = "ArrowUp"), r == "Right" && (r = "ArrowRight"), r == "Down" && (r = "ArrowDown"), r;
}
function Jo(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function Nu(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function LT(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function Bo(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return Nu(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function ui(t) {
  return t.nodeType == 3 ? kn(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function Zi(t, e, r, n) {
  return r ? yd(t, e, r, n, -1) || yd(t, e, r, n, 1) : !1;
}
function cs(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function yd(t, e, r, n, i) {
  for (; ; ) {
    if (t == r && e == n)
      return !0;
    if (e == (i < 0 ? 0 : pr(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let s = t.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = cs(t) + (i < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = i < 0 ? pr(t) : 0;
    } else
      return !1;
  }
}
function pr(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Ja(t, e) {
  let r = e ? t.left : t.right;
  return { left: r, right: r, top: t.top, bottom: t.bottom };
}
function PT(t) {
  return {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function sy(t, e) {
  let r = e.width / t.offsetWidth, n = e.height / t.offsetHeight;
  return (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.width - t.offsetWidth) < 1) && (r = 1), (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.height - t.offsetHeight) < 1) && (n = 1), { scaleX: r, scaleY: n };
}
function NT(t, e, r, n, i, s, o, a) {
  let l = t.ownerDocument, c = l.defaultView || window;
  for (let u = t, h = !1; u && !h; )
    if (u.nodeType == 1) {
      let f, d = u == l.body, p = 1, m = 1;
      if (d)
        f = PT(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (h = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let g = u.getBoundingClientRect();
        ({ scaleX: p, scaleY: m } = sy(u, g)), f = {
          left: g.left,
          right: g.left + u.clientWidth * p,
          top: g.top,
          bottom: g.top + u.clientHeight * m
        };
      }
      let y = 0, v = 0;
      if (i == "nearest")
        e.top < f.top ? (v = -(f.top - e.top + o), r > 0 && e.bottom > f.bottom + v && (v = e.bottom - f.bottom + v + o)) : e.bottom > f.bottom && (v = e.bottom - f.bottom + o, r < 0 && e.top - v < f.top && (v = -(f.top + v - e.top + o)));
      else {
        let g = e.bottom - e.top, b = f.bottom - f.top;
        v = (i == "center" && g <= b ? e.top + g / 2 - b / 2 : i == "start" || i == "center" && r < 0 ? e.top - o : e.bottom - b + o) - f.top;
      }
      if (n == "nearest" ? e.left < f.left ? (y = -(f.left - e.left + s), r > 0 && e.right > f.right + y && (y = e.right - f.right + y + s)) : e.right > f.right && (y = e.right - f.right + s, r < 0 && e.left < f.left + y && (y = -(f.left + y - e.left + s))) : y = (n == "center" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : n == "start" == a ? e.left - s : e.right - (f.right - f.left) + s) - f.left, y || v)
        if (d)
          c.scrollBy(y, v);
        else {
          let g = 0, b = 0;
          if (v) {
            let w = u.scrollTop;
            u.scrollTop += v / m, b = (u.scrollTop - w) * m;
          }
          if (y) {
            let w = u.scrollLeft;
            u.scrollLeft += y / p, g = (u.scrollLeft - w) * p;
          }
          e = {
            left: e.left - g,
            top: e.top - b,
            right: e.right - g,
            bottom: e.bottom - b
          }, g && Math.abs(g - y) < 1 && (n = "nearest"), b && Math.abs(b - v) < 1 && (i = "nearest");
        }
      if (d)
        break;
      u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
function RT(t) {
  let e = t.ownerDocument;
  for (let r = t.parentNode; r && r != e.body; )
    if (r.nodeType == 1) {
      if (r.scrollHeight > r.clientHeight || r.scrollWidth > r.clientWidth)
        return r;
      r = r.assignedSlot || r.parentNode;
    } else if (r.nodeType == 11)
      r = r.host;
    else
      break;
  return null;
}
class IT {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: r, focusNode: n } = e;
    this.set(r, Math.min(e.anchorOffset, r ? pr(r) : 0), n, Math.min(e.focusOffset, n ? pr(n) : 0));
  }
  set(e, r, n, i) {
    this.anchorNode = e, this.anchorOffset = r, this.focusNode = n, this.focusOffset = i;
  }
}
let Wn = null;
function oy(t) {
  if (t.setActive)
    return t.setActive();
  if (Wn)
    return t.focus(Wn);
  let e = [];
  for (let r = t; r && (e.push(r, r.scrollTop, r.scrollLeft), r != r.ownerDocument); r = r.parentNode)
    ;
  if (t.focus(Wn == null ? {
    get preventScroll() {
      return Wn = { preventScroll: !0 }, !0;
    }
  } : void 0), !Wn) {
    Wn = !1;
    for (let r = 0; r < e.length; ) {
      let n = e[r++], i = e[r++], s = e[r++];
      n.scrollTop != i && (n.scrollTop = i), n.scrollLeft != s && (n.scrollLeft = s);
    }
  }
}
let vd;
function kn(t, e, r = e) {
  let n = vd || (vd = document.createRange());
  return n.setEnd(t, r), n.setStart(t, e), n;
}
function ti(t, e, r) {
  let n = { key: e, code: e, keyCode: r, which: r, cancelable: !0 }, i = new KeyboardEvent("keydown", n);
  i.synthetic = !0, t.dispatchEvent(i);
  let s = new KeyboardEvent("keyup", n);
  return s.synthetic = !0, t.dispatchEvent(s), i.defaultPrevented || s.defaultPrevented;
}
function $T(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function ay(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function jT(t, e) {
  let r = e.focusNode, n = e.focusOffset;
  if (!r || e.anchorNode != r || e.anchorOffset != n)
    return !1;
  for (n = Math.min(n, pr(r)); ; )
    if (n) {
      if (r.nodeType != 1)
        return !1;
      let i = r.childNodes[n - 1];
      i.contentEditable == "false" ? n-- : (r = i, n = pr(r));
    } else {
      if (r == t)
        return !0;
      n = cs(r), r = r.parentNode;
    }
}
function ly(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
class ze {
  constructor(e, r, n = !0) {
    this.node = e, this.offset = r, this.precise = n;
  }
  static before(e, r) {
    return new ze(e.parentNode, cs(e), r);
  }
  static after(e, r) {
    return new ze(e.parentNode, cs(e) + 1, r);
  }
}
const Ah = [];
class ge {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let r = this.posAtStart;
    for (let n of this.children) {
      if (n == e)
        return r;
      r += n.length + n.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, r) {
    if (this.flags & 2) {
      let n = this.dom, i = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = i ? i.nextSibling : n.firstChild)) {
            let a = ge.get(s);
            (!a || !a.parent && a.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, r), o.flags &= -8;
        }
        if (s = i ? i.nextSibling : n.firstChild, r && !r.written && r.node == n && s != o.dom && (r.written = !0), o.dom.parentNode == n)
          for (; s && s != o.dom; )
            s = bd(s);
        else
          n.insertBefore(o.dom, s);
        i = o.dom;
      }
      for (s = i ? i.nextSibling : n.firstChild, s && r && r.node == n && (r.written = !0); s; )
        s = bd(s);
    } else if (this.flags & 1)
      for (let n of this.children)
        n.flags & 7 && (n.sync(e, r), n.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, r) {
    let n;
    if (e == this.dom)
      n = this.dom.childNodes[r];
    else {
      let i = pr(e) == 0 ? 0 : r == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? i = -1 : i = 1), e = s;
      }
      i < 0 ? n = e : n = e.nextSibling;
    }
    if (n == this.dom.firstChild)
      return 0;
    for (; n && !ge.get(n); )
      n = n.nextSibling;
    if (!n)
      return this.length;
    for (let i = 0, s = 0; ; i++) {
      let o = this.children[i];
      if (o.dom == n)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, r, n = 0) {
    let i = -1, s = -1, o = -1, a = -1;
    for (let l = 0, c = n, u = n; l < this.children.length; l++) {
      let h = this.children[l], f = c + h.length;
      if (c < e && f > r)
        return h.domBoundsAround(e, r, c);
      if (f >= e && i == -1 && (i = l, s = c), c > r && h.dom.parentNode == this.dom) {
        o = l, a = u;
        break;
      }
      u = f, c = f + h.breakAfter;
    }
    return {
      from: s,
      to: a < 0 ? n + this.length : a,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let r = this.parent; r; r = r.parent) {
      if (e && (r.flags |= 2), r.flags & 1)
        return;
      r.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let r = e.parent;
      if (!r)
        return e;
      e = r;
    }
  }
  replaceChildren(e, r, n = Ah) {
    this.markDirty();
    for (let i = e; i < r; i++) {
      let s = this.children[i];
      s.parent == this && n.indexOf(s) < 0 && s.destroy();
    }
    this.children.splice(e, r - e, ...n);
    for (let i = 0; i < n.length; i++)
      n[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new uy(this.children, e, this.children.length);
  }
  childPos(e, r = 1) {
    return this.childCursor().findPos(e, r);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, r, n, i, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
ge.prototype.breakAfter = 0;
function bd(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class uy {
  constructor(e, r, n) {
    this.children = e, this.pos = r, this.i = n, this.off = 0;
  }
  findPos(e, r = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (r > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let n = this.children[--this.i];
      this.pos -= n.length + n.breakAfter;
    }
  }
}
function cy(t, e, r, n, i, s, o, a, l) {
  let { children: c } = t, u = c.length ? c[e] : null, h = s.length ? s[s.length - 1] : null, f = h ? h.breakAfter : o;
  if (!(e == n && u && !o && !f && s.length < 2 && u.merge(r, i, s.length ? h : null, r == 0, a, l))) {
    if (n < c.length) {
      let d = c[n];
      d && (i < d.length || d.breakAfter && (h != null && h.breakAfter)) ? (e == n && (d = d.split(i), i = 0), !f && h && d.merge(0, i, h, !0, 0, l) ? s[s.length - 1] = d : ((i || d.children.length && !d.children[0].length) && d.merge(0, i, null, !1, 0, l), s.push(d))) : d != null && d.breakAfter && (h ? h.breakAfter = 1 : o = 1), n++;
    }
    for (u && (u.breakAfter = o, r > 0 && (!o && s.length && u.merge(r, u.length, s[0], !1, a, 0) ? u.breakAfter = s.shift().breakAfter : (r < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(r, u.length, null, !1, a, 0), e++)); e < n && s.length; )
      if (c[n - 1].become(s[s.length - 1]))
        n--, s.pop(), l = s.length ? 0 : a;
      else if (c[e].become(s[0]))
        e++, s.shift(), a = s.length ? 0 : l;
      else
        break;
    !s.length && e && n < c.length && !c[e - 1].breakAfter && c[n].merge(0, 0, c[e - 1], !1, a, l) && e--, (e < n || s.length) && t.replaceChildren(e, n, s);
  }
}
function hy(t, e, r, n, i, s) {
  let o = t.childCursor(), { i: a, off: l } = o.findPos(r, 1), { i: c, off: u } = o.findPos(e, -1), h = e - r;
  for (let f of n)
    h += f.length;
  t.length += h, cy(t, c, u, a, l, n, 0, i, s);
}
let dt = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Ru = typeof document < "u" ? document : { documentElement: { style: {} } };
const Iu = /* @__PURE__ */ /Edge\/(\d+)/.exec(dt.userAgent), fy = /* @__PURE__ */ /MSIE \d/.test(dt.userAgent), $u = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(dt.userAgent), Xa = !!(fy || $u || Iu), Dd = !Xa && /* @__PURE__ */ /gecko\/(\d+)/i.test(dt.userAgent), Ol = !Xa && /* @__PURE__ */ /Chrome\/(\d+)/.exec(dt.userAgent), wd = "webkitFontSmoothing" in Ru.documentElement.style, dy = !Xa && /* @__PURE__ */ /Apple Computer/.test(dt.vendor), xd = dy && (/* @__PURE__ */ /Mobile\/\w+/.test(dt.userAgent) || dt.maxTouchPoints > 2);
var V = {
  mac: xd || /* @__PURE__ */ /Mac/.test(dt.platform),
  windows: /* @__PURE__ */ /Win/.test(dt.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(dt.platform),
  ie: Xa,
  ie_version: fy ? Ru.documentMode || 6 : $u ? +$u[1] : Iu ? +Iu[1] : 0,
  gecko: Dd,
  gecko_version: Dd ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(dt.userAgent) || [0, 0])[1] : 0,
  chrome: !!Ol,
  chrome_version: Ol ? +Ol[1] : 0,
  ios: xd,
  android: /* @__PURE__ */ /Android\b/.test(dt.userAgent),
  webkit: wd,
  safari: dy,
  webkit_version: wd ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: Ru.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const WT = 256;
class mr extends ge {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, r) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (r && r.node == this.dom && (r.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, r, n) {
    return this.flags & 8 || n && (!(n instanceof mr) || this.length - (r - e) + n.length > WT || n.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (n ? n.text : "") + this.text.slice(r), this.markDirty(), !0);
  }
  split(e) {
    let r = new mr(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), r.flags |= this.flags & 8, r;
  }
  localPosFromDOM(e, r) {
    return e == this.dom ? r : r ? this.text.length : 0;
  }
  domAtPos(e) {
    return new ze(this.dom, e);
  }
  domBoundsAround(e, r, n) {
    return { from: n, to: n + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, r) {
    return qT(this.dom, e, r);
  }
}
class gr extends ge {
  constructor(e, r = [], n = 0) {
    super(), this.mark = e, this.children = r, this.length = n;
    for (let i of r)
      i.setParent(this);
  }
  setAttrs(e) {
    if (ay(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let r in this.mark.attrs)
        e.setAttribute(r, this.mark.attrs[r]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, r);
  }
  merge(e, r, n, i, s, o) {
    return n && (!(n instanceof gr && n.mark.eq(this.mark)) || e && s <= 0 || r < this.length && o <= 0) ? !1 : (hy(this, e, r, n ? n.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let r = [], n = 0, i = -1, s = 0;
    for (let a of this.children) {
      let l = n + a.length;
      l > e && r.push(n < e ? a.split(e - n) : a), i < 0 && n >= e && (i = s), n = l, s++;
    }
    let o = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new gr(this.mark, r, o);
  }
  domAtPos(e) {
    return py(this, e);
  }
  coordsAt(e, r) {
    return gy(this, e, r);
  }
}
function qT(t, e, r) {
  let n = t.nodeValue.length;
  e > n && (e = n);
  let i = e, s = e, o = 0;
  e == 0 && r < 0 || e == n && r >= 0 ? V.chrome || V.gecko || (e ? (i--, o = 1) : s < n && (s++, o = -1)) : r < 0 ? i-- : s < n && s++;
  let a = kn(t, i, s).getClientRects();
  if (!a.length)
    return null;
  let l = a[(o ? o < 0 : r >= 0) ? 0 : a.length - 1];
  return V.safari && !o && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), o ? Ja(l, o < 0) : l || null;
}
class Rr extends ge {
  static create(e, r, n) {
    return new Rr(e, r, n);
  }
  constructor(e, r, n) {
    super(), this.widget = e, this.length = r, this.side = n, this.prevWidget = null;
  }
  split(e) {
    let r = Rr.create(this.widget, this.length - e, this.side);
    return this.length -= e, r;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, r, n, i, s, o) {
    return n && (!(n instanceof Rr) || !this.widget.compare(n.widget) || e > 0 && s <= 0 || r < this.length && o <= 0) ? !1 : (this.length = e + (n ? n.length : 0) + (this.length - r), !0);
  }
  become(e) {
    return e instanceof Rr && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return le.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: r } = e, n = r && r.state.doc, i = this.posAtStart;
    return n ? n.slice(i, i + this.length) : le.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? ze.before(this.dom) : ze.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, r) {
    let n = this.widget.coordsAt(this.dom, e, r);
    if (n)
      return n;
    let i = this.dom.getClientRects(), s = null;
    if (!i.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let a = o ? i.length - 1 : 0; s = i[a], !(e > 0 ? a == 0 : a == i.length - 1 || s.top < s.bottom); a += o ? -1 : 1)
      ;
    return Ja(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class ci extends ge {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof ci && e.side == this.side;
  }
  split() {
    return new ci(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? ze.before(this.dom) : ze.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return le.empty;
  }
  get isHidden() {
    return !0;
  }
}
mr.prototype.children = Rr.prototype.children = ci.prototype.children = Ah;
function py(t, e) {
  let r = t.dom, { children: n } = t, i = 0;
  for (let s = 0; i < n.length; i++) {
    let o = n[i], a = s + o.length;
    if (!(a == s && o.getSide() <= 0)) {
      if (e > s && e < a && o.dom.parentNode == r)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = a;
    }
  }
  for (let s = i; s > 0; s--) {
    let o = n[s - 1];
    if (o.dom.parentNode == r)
      return o.domAtPos(o.length);
  }
  for (let s = i; s < n.length; s++) {
    let o = n[s];
    if (o.dom.parentNode == r)
      return o.domAtPos(0);
  }
  return new ze(r, 0);
}
function my(t, e, r) {
  let n, { children: i } = t;
  r > 0 && e instanceof gr && i.length && (n = i[i.length - 1]) instanceof gr && n.mark.eq(e.mark) ? my(n, e.children[0], r - 1) : (i.push(e), e.setParent(t)), t.length += e.length;
}
function gy(t, e, r) {
  let n = null, i = -1, s = null, o = -1;
  function a(c, u) {
    for (let h = 0, f = 0; h < c.children.length && f <= u; h++) {
      let d = c.children[h], p = f + d.length;
      p >= u && (d.children.length ? a(d, u - f) : (!s || s.isHidden && r > 0) && (p > u || f == p && d.getSide() > 0) ? (s = d, o = u - f) : (f < u || f == p && d.getSide() < 0 && !d.isHidden) && (n = d, i = u - f)), f = p;
    }
  }
  a(t, e);
  let l = (r < 0 ? n : s) || n || s;
  return l ? l.coordsAt(Math.max(0, l == n ? i : o), r) : HT(t);
}
function HT(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let r = ui(e);
  return r[r.length - 1] || null;
}
function ju(t, e) {
  for (let r in t)
    r == "class" && e.class ? e.class += " " + t.class : r == "style" && e.style ? e.style += ";" + t.style : e[r] = t[r];
  return e;
}
const Cd = /* @__PURE__ */ Object.create(null);
function Fh(t, e, r) {
  if (t == e)
    return !0;
  t || (t = Cd), e || (e = Cd);
  let n = Object.keys(t), i = Object.keys(e);
  if (n.length - (r && n.indexOf(r) > -1 ? 1 : 0) != i.length - (r && i.indexOf(r) > -1 ? 1 : 0))
    return !1;
  for (let s of n)
    if (s != r && (i.indexOf(s) == -1 || t[s] !== e[s]))
      return !1;
  return !0;
}
function Wu(t, e, r) {
  let n = !1;
  if (e)
    for (let i in e)
      r && i in r || (n = !0, i == "style" ? t.style.cssText = "" : t.removeAttribute(i));
  if (r)
    for (let i in r)
      e && e[i] == r[i] || (n = !0, i == "style" ? t.style.cssText = r[i] : t.setAttribute(i, r[i]));
  return n;
}
function VT(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r = 0; r < t.attributes.length; r++) {
    let n = t.attributes[r];
    e[n.name] = n.value;
  }
  return e;
}
class Ae extends ge {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, r, n, i, s, o) {
    if (n) {
      if (!(n instanceof Ae))
        return !1;
      this.dom || n.transferDOM(this);
    }
    return i && this.setDeco(n ? n.attrs : null), hy(this, e, r, n ? n.children.slice() : [], s, o), !0;
  }
  split(e) {
    let r = new Ae();
    if (r.breakAfter = this.breakAfter, this.length == 0)
      return r;
    let { i: n, off: i } = this.childPos(e);
    i && (r.append(this.children[n].split(i), 0), this.children[n].merge(i, this.children[n].length, null, !1, 0, 0), n++);
    for (let s = n; s < this.children.length; s++)
      r.append(this.children[s], 0);
    for (; n > 0 && this.children[n - 1].length == 0; )
      this.children[--n].destroy();
    return this.children.length = n, this.markDirty(), this.length = e, r;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Fh(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, r) {
    my(this, e, r);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let r = e.spec.attributes, n = e.spec.class;
    r && (this.attrs = ju(r, this.attrs || {})), n && (this.attrs = ju({ class: n }, this.attrs || {}));
  }
  domAtPos(e) {
    return py(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    var n;
    this.dom ? this.flags & 4 && (ay(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Wu(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, r);
    let i = this.dom.lastChild;
    for (; i && ge.get(i) instanceof gr; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((n = ge.get(i)) === null || n === void 0 ? void 0 : n.isEditable) == !1 && (!V.ios || !this.children.some((s) => s instanceof mr))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, r;
    for (let n of this.children) {
      if (!(n instanceof mr) || /[^ -~]/.test(n.text))
        return null;
      let i = ui(n.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, r = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: r
    } : null;
  }
  coordsAt(e, r) {
    let n = gy(this, e, r);
    if (!this.children.length && n && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, s = n.bottom - n.top;
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let o = (s - i.textHeight) / 2;
        return { top: n.top + o, bottom: n.bottom - o, left: n.left, right: n.left };
      }
    }
    return n;
  }
  become(e) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(e, r) {
    for (let n = 0, i = 0; n < e.children.length; n++) {
      let s = e.children[n], o = i + s.length;
      if (o >= r) {
        if (s instanceof Ae)
          return s;
        if (o > r)
          break;
      }
      i = o + s.breakAfter;
    }
    return null;
  }
}
class qr extends ge {
  constructor(e, r, n) {
    super(), this.widget = e, this.length = r, this.deco = n, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, r, n, i, s, o) {
    return n && (!(n instanceof qr) || !this.widget.compare(n.widget) || e > 0 && s <= 0 || r < this.length && o <= 0) ? !1 : (this.length = e + (n ? n.length : 0) + (this.length - r), !0);
  }
  domAtPos(e) {
    return e == 0 ? ze.before(this.dom) : ze.after(this.dom, e == this.length);
  }
  split(e) {
    let r = this.length - e;
    this.length = e;
    let n = new qr(this.widget, r, this.deco);
    return n.breakAfter = this.breakAfter, n;
  }
  get children() {
    return Ah;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : le.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof qr && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, r) {
    return this.widget.coordsAt(this.dom, e, r);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: r, endSide: n } = this.deco;
    return r == n ? !1 : e < 0 ? r < 0 : n > 0;
  }
}
class Sr {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, r) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, r, n) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Ze = /* @__PURE__ */ function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
}(Ze || (Ze = {}));
class K extends Cn {
  constructor(e, r, n, i) {
    super(), this.startSide = e, this.endSide = r, this.widget = n, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Ls(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let r = Math.max(-1e4, Math.min(1e4, e.side || 0)), n = !!e.block;
    return r += n && !e.inlineOrder ? r > 0 ? 3e8 : -4e8 : r > 0 ? 1e8 : -1e8, new Jr(e, r, r, n, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let r = !!e.block, n, i;
    if (e.isBlockGap)
      n = -5e8, i = 4e8;
    else {
      let { start: s, end: o } = yy(e, r);
      n = (s ? r ? -3e8 : -1 : 5e8) - 1, i = (o ? r ? 2e8 : 1 : -6e8) + 1;
    }
    return new Jr(e, n, i, r, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Ps(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, r = !1) {
    return ie.of(e, r);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
K.none = ie.empty;
class Ls extends K {
  constructor(e) {
    let { start: r, end: n } = yy(e);
    super(r ? -1 : 5e8, n ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var r, n;
    return this == e || e instanceof Ls && this.tagName == e.tagName && (this.class || ((r = this.attrs) === null || r === void 0 ? void 0 : r.class)) == (e.class || ((n = e.attrs) === null || n === void 0 ? void 0 : n.class)) && Fh(this.attrs, e.attrs, "class");
  }
  range(e, r = e) {
    if (e >= r)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, r);
  }
}
Ls.prototype.point = !1;
class Ps extends K {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Ps && this.spec.class == e.spec.class && Fh(this.spec.attributes, e.spec.attributes);
  }
  range(e, r = e) {
    if (r != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, r);
  }
}
Ps.prototype.mapMode = Qe.TrackBefore;
Ps.prototype.point = !0;
class Jr extends K {
  constructor(e, r, n, i, s, o) {
    super(r, n, s, e), this.block = i, this.isReplace = o, this.mapMode = i ? r <= 0 ? Qe.TrackBefore : Qe.TrackAfter : Qe.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Ze.WidgetRange : this.startSide <= 0 ? Ze.WidgetBefore : Ze.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Jr && zT(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, r = e) {
    if (this.isReplace && (e > r || e == r && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && r != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, r);
  }
}
Jr.prototype.point = !0;
function yy(t, e = !1) {
  let { inclusiveStart: r, inclusiveEnd: n } = t;
  return r == null && (r = t.inclusive), n == null && (n = t.inclusive), { start: r ?? e, end: n ?? e };
}
function zT(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function qu(t, e, r, n = 0) {
  let i = r.length - 1;
  i >= 0 && r[i] + n >= t ? r[i] = Math.max(r[i], e) : r.push(t, e);
}
class es {
  constructor(e, r, n, i) {
    this.doc = e, this.pos = r, this.end = n, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = r;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof qr && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Ae()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(eo(new ci(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof qr) && this.getLine();
  }
  buildText(e, r, n) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let i = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(r.slice(r.length - n)), this.getLine().append(eo(new mr(this.text.slice(this.textOff, this.textOff + i)), r), n), this.atCursorPos = !0, this.textOff += i, e -= i, n = 0;
    }
  }
  span(e, r, n, i) {
    this.buildText(r - e, n, i), this.pos = r, this.openStart < 0 && (this.openStart = i);
  }
  point(e, r, n, i, s, o) {
    if (this.disallowBlockEffectsFor[o] && n instanceof Jr) {
      if (n.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (r > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = r - e;
    if (n instanceof Jr)
      if (n.block)
        n.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new qr(n.widget || new kd("div"), a, n));
      else {
        let l = Rr.create(n.widget || new kd("span"), a, a ? 0 : n.startSide), c = this.atCursorPos && !l.isEditable && s <= i.length && (e < r || n.startSide > 0), u = !l.isEditable && (e < r || s > i.length || n.startSide <= 0), h = this.getLine();
        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), c && (h.append(eo(new ci(1), i), s), s = i.length + Math.max(0, s - i.length)), h.append(eo(l, i), s), this.atCursorPos = u, this.pendingBuffer = u ? e < r || s > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(n);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = r), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, r, n, i, s) {
    let o = new es(e, r, n, s);
    return o.openEnd = ie.spans(i, r, n, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function eo(t, e) {
  for (let r of e)
    t = new gr(r, [t], t.length);
  return t;
}
class kd extends Sr {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
var ye = /* @__PURE__ */ function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
}(ye || (ye = {}));
const Sn = ye.LTR, Th = ye.RTL;
function vy(t) {
  let e = [];
  for (let r = 0; r < t.length; r++)
    e.push(1 << +t[r]);
  return e;
}
const UT = /* @__PURE__ */ vy("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), GT = /* @__PURE__ */ vy("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Hu = /* @__PURE__ */ Object.create(null), Ut = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), r = /* @__PURE__ */ t.charCodeAt(1);
  Hu[e] = r, Hu[r] = -e;
}
function by(t) {
  return t <= 247 ? UT[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? GT[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const KT = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Ir {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? Th : Sn;
  }
  /**
  @internal
  */
  constructor(e, r, n) {
    this.from = e, this.to = r, this.level = n;
  }
  /**
  @internal
  */
  side(e, r) {
    return this.dir == r == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, r) {
    return e == (this.dir == r);
  }
  /**
  @internal
  */
  static find(e, r, n, i) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      if (a.from <= r && a.to >= r) {
        if (a.level == n)
          return o;
        (s < 0 || (i != 0 ? i < 0 ? a.from < r : a.to > r : e[s].level > a.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function Dy(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++) {
    let n = t[r], i = e[r];
    if (n.from != i.from || n.to != i.to || n.direction != i.direction || !Dy(n.inner, i.inner))
      return !1;
  }
  return !0;
}
const he = [];
function YT(t, e, r, n, i) {
  for (let s = 0; s <= n.length; s++) {
    let o = s ? n[s - 1].to : e, a = s < n.length ? n[s].from : r, l = s ? 256 : i;
    for (let c = o, u = l, h = l; c < a; c++) {
      let f = by(t.charCodeAt(c));
      f == 512 ? f = u : f == 8 && h == 4 && (f = 16), he[c] = f == 4 ? 2 : f, f & 7 && (h = f), u = f;
    }
    for (let c = o, u = l, h = l; c < a; c++) {
      let f = he[c];
      if (f == 128)
        c < a - 1 && u == he[c + 1] && u & 24 ? f = he[c] = u : he[c] = 256;
      else if (f == 64) {
        let d = c + 1;
        for (; d < a && he[d] == 64; )
          d++;
        let p = c && u == 8 || d < r && he[d] == 8 ? h == 1 ? 1 : 8 : 256;
        for (let m = c; m < d; m++)
          he[m] = p;
        c = d - 1;
      } else
        f == 8 && h == 1 && (he[c] = 1);
      u = f, f & 7 && (h = f);
    }
  }
}
function JT(t, e, r, n, i) {
  let s = i == 1 ? 2 : 1;
  for (let o = 0, a = 0, l = 0; o <= n.length; o++) {
    let c = o ? n[o - 1].to : e, u = o < n.length ? n[o].from : r;
    for (let h = c, f, d, p; h < u; h++)
      if (d = Hu[f = t.charCodeAt(h)])
        if (d < 0) {
          for (let m = a - 3; m >= 0; m -= 3)
            if (Ut[m + 1] == -d) {
              let y = Ut[m + 2], v = y & 2 ? i : y & 4 ? y & 1 ? s : i : 0;
              v && (he[h] = he[Ut[m]] = v), a = m;
              break;
            }
        } else {
          if (Ut.length == 189)
            break;
          Ut[a++] = h, Ut[a++] = f, Ut[a++] = l;
        }
      else if ((p = he[h]) == 2 || p == 1) {
        let m = p == i;
        l = m ? 0 : 1;
        for (let y = a - 3; y >= 0; y -= 3) {
          let v = Ut[y + 2];
          if (v & 2)
            break;
          if (m)
            Ut[y + 2] |= 2;
          else {
            if (v & 4)
              break;
            Ut[y + 2] |= 4;
          }
        }
      }
  }
}
function XT(t, e, r, n) {
  for (let i = 0, s = n; i <= r.length; i++) {
    let o = i ? r[i - 1].to : t, a = i < r.length ? r[i].from : e;
    for (let l = o; l < a; ) {
      let c = he[l];
      if (c == 256) {
        let u = l + 1;
        for (; ; )
          if (u == a) {
            if (i == r.length)
              break;
            u = r[i++].to, a = i < r.length ? r[i].from : e;
          } else if (he[u] == 256)
            u++;
          else
            break;
        let h = s == 1, f = (u < e ? he[u] : n) == 1, d = h == f ? h ? 1 : 2 : n;
        for (let p = u, m = i, y = m ? r[m - 1].to : t; p > l; )
          p == y && (p = r[--m].from, y = m ? r[m - 1].to : t), he[--p] = d;
        l = u;
      } else
        s = c, l++;
    }
  }
}
function Vu(t, e, r, n, i, s, o) {
  let a = n % 2 ? 2 : 1;
  if (n % 2 == i % 2)
    for (let l = e, c = 0; l < r; ) {
      let u = !0, h = !1;
      if (c == s.length || l < s[c].from) {
        let m = he[l];
        m != a && (u = !1, h = m == 16);
      }
      let f = !u && a == 1 ? [] : null, d = u ? n : n + 1, p = l;
      e:
        for (; ; )
          if (c < s.length && p == s[c].from) {
            if (h)
              break e;
            let m = s[c];
            if (!u)
              for (let y = m.to, v = c + 1; ; ) {
                if (y == r)
                  break e;
                if (v < s.length && s[v].from == y)
                  y = s[v++].to;
                else {
                  if (he[y] == a)
                    break e;
                  break;
                }
              }
            if (c++, f)
              f.push(m);
            else {
              m.from > l && o.push(new Ir(l, m.from, d));
              let y = m.direction == Sn != !(d % 2);
              zu(t, y ? n + 1 : n, i, m.inner, m.from, m.to, o), l = m.to;
            }
            p = m.to;
          } else {
            if (p == r || (u ? he[p] != a : he[p] == a))
              break;
            p++;
          }
      f ? Vu(t, l, p, n + 1, i, f, o) : l < p && o.push(new Ir(l, p, d)), l = p;
    }
  else
    for (let l = r, c = s.length; l > e; ) {
      let u = !0, h = !1;
      if (!c || l > s[c - 1].to) {
        let m = he[l - 1];
        m != a && (u = !1, h = m == 16);
      }
      let f = !u && a == 1 ? [] : null, d = u ? n : n + 1, p = l;
      e:
        for (; ; )
          if (c && p == s[c - 1].to) {
            if (h)
              break e;
            let m = s[--c];
            if (!u)
              for (let y = m.from, v = c; ; ) {
                if (y == e)
                  break e;
                if (v && s[v - 1].to == y)
                  y = s[--v].from;
                else {
                  if (he[y - 1] == a)
                    break e;
                  break;
                }
              }
            if (f)
              f.push(m);
            else {
              m.to < l && o.push(new Ir(m.to, l, d));
              let y = m.direction == Sn != !(d % 2);
              zu(t, y ? n + 1 : n, i, m.inner, m.from, m.to, o), l = m.from;
            }
            p = m.from;
          } else {
            if (p == e || (u ? he[p - 1] != a : he[p - 1] == a))
              break;
            p--;
          }
      f ? Vu(t, p, l, n + 1, i, f, o) : p < l && o.push(new Ir(p, l, d)), l = p;
    }
}
function zu(t, e, r, n, i, s, o) {
  let a = e % 2 ? 2 : 1;
  YT(t, i, s, n, a), JT(t, i, s, n, a), XT(i, s, n, a), Vu(t, i, s, e, r, n, o);
}
function QT(t, e, r) {
  if (!t)
    return [new Ir(0, 0, e == Th ? 1 : 0)];
  if (e == Sn && !r.length && !KT.test(t))
    return wy(t.length);
  if (r.length)
    for (; t.length > he.length; )
      he[he.length] = 256;
  let n = [], i = e == Sn ? 0 : 1;
  return zu(t, i, i, r, 0, t.length, n), n;
}
function wy(t) {
  return [new Ir(0, t, 0)];
}
let xy = "";
function ZT(t, e, r, n, i) {
  var s;
  let o = n.head - t.from, a = Ir.find(e, o, (s = n.bidiLevel) !== null && s !== void 0 ? s : -1, n.assoc), l = e[a], c = l.side(i, r);
  if (o == c) {
    let f = a += i ? 1 : -1;
    if (f < 0 || f >= e.length)
      return null;
    l = e[a = f], o = l.side(!i, r), c = l.side(i, r);
  }
  let u = Ie(t.text, o, l.forward(i, r));
  (u < l.from || u > l.to) && (u = c), xy = t.text.slice(Math.min(o, u), Math.max(o, u));
  let h = a == (i ? e.length - 1 : 0) ? null : e[a + (i ? 1 : -1)];
  return h && u == c && h.level + (i ? 0 : 1) < l.level ? B.cursor(h.side(!i, r) + t.from, h.forward(i, r) ? 1 : -1, h.level) : B.cursor(u + t.from, l.forward(i, r) ? -1 : 1, l.level);
}
function e_(t, e, r) {
  for (let n = e; n < r; n++) {
    let i = by(t.charCodeAt(n));
    if (i == 1)
      return Sn;
    if (i == 2 || i == 4)
      return Th;
  }
  return Sn;
}
const Cy = /* @__PURE__ */ z.define(), ky = /* @__PURE__ */ z.define(), Sy = /* @__PURE__ */ z.define(), Ey = /* @__PURE__ */ z.define(), Uu = /* @__PURE__ */ z.define(), Ay = /* @__PURE__ */ z.define(), Fy = /* @__PURE__ */ z.define(), Ty = /* @__PURE__ */ z.define({
  combine: (t) => t.some((e) => e)
}), _y = /* @__PURE__ */ z.define({
  combine: (t) => t.some((e) => e)
});
class ri {
  constructor(e, r = "nearest", n = "nearest", i = 5, s = 5, o = !1) {
    this.range = e, this.y = r, this.x = n, this.yMargin = i, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new ri(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new ri(B.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const to = /* @__PURE__ */ J.define({ map: (t, e) => t.map(e) });
function At(t, e, r) {
  let n = t.facet(Ey);
  n.length ? n[0](e) : window.onerror ? window.onerror(String(e), r, void 0, void 0, e) : r ? console.error(r + ":", e) : console.error(e);
}
const Qa = /* @__PURE__ */ z.define({ combine: (t) => t.length ? t[0] : !0 });
let t_ = 0;
const $i = /* @__PURE__ */ z.define();
class Ee {
  constructor(e, r, n, i, s) {
    this.id = e, this.create = r, this.domEventHandlers = n, this.domEventObservers = i, this.extension = s(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, r) {
    const { eventHandlers: n, eventObservers: i, provide: s, decorations: o } = r || {};
    return new Ee(t_++, e, n, i, (a) => {
      let l = [$i.of(a)];
      return o && l.push(hs.of((c) => {
        let u = c.plugin(a);
        return u ? o(u) : K.none;
      })), s && l.push(s(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, r) {
    return Ee.define((n) => new e(n), r);
  }
}
class Ml {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let r = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(r);
          } catch (n) {
            if (At(r.state, n, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (r) {
        At(e.state, r, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var r;
    if (!((r = this.value) === null || r === void 0) && r.destroy)
      try {
        this.value.destroy();
      } catch (n) {
        At(e.state, n, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const By = /* @__PURE__ */ z.define(), _h = /* @__PURE__ */ z.define(), hs = /* @__PURE__ */ z.define(), Oy = /* @__PURE__ */ z.define(), Bh = /* @__PURE__ */ z.define(), My = /* @__PURE__ */ z.define();
function Sd(t, e) {
  let r = t.state.facet(My);
  if (!r.length)
    return r;
  let n = r.map((s) => s instanceof Function ? s(t) : s), i = [];
  return ie.spans(n, e.from, e.to, {
    point() {
    },
    span(s, o, a, l) {
      let c = s - e.from, u = o - e.from, h = i;
      for (let f = a.length - 1; f >= 0; f--, l--) {
        let d = a[f].spec.bidiIsolate, p;
        if (d == null && (d = e_(e.text, c, u)), l > 0 && h.length && (p = h[h.length - 1]).to == c && p.direction == d)
          p.to = u, h = p.inner;
        else {
          let m = { from: c, to: u, direction: d, inner: [] };
          h.push(m), h = m.inner;
        }
      }
    }
  }), i;
}
const Ly = /* @__PURE__ */ z.define();
function Py(t) {
  let e = 0, r = 0, n = 0, i = 0;
  for (let s of t.state.facet(Ly)) {
    let o = s(t);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (r = Math.max(r, o.right)), o.top != null && (n = Math.max(n, o.top)), o.bottom != null && (i = Math.max(i, o.bottom)));
  }
  return { left: e, right: r, top: n, bottom: i };
}
const ji = /* @__PURE__ */ z.define();
class Ft {
  constructor(e, r, n, i) {
    this.fromA = e, this.toA = r, this.fromB = n, this.toB = i;
  }
  join(e) {
    return new Ft(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let r = e.length, n = this;
    for (; r > 0; r--) {
      let i = e[r - 1];
      if (!(i.fromA > n.toA)) {
        if (i.toA < n.fromA)
          break;
        n = n.join(i), e.splice(r - 1, 1);
      }
    }
    return e.splice(r, 0, n), e;
  }
  static extendWithRanges(e, r) {
    if (r.length == 0)
      return e;
    let n = [];
    for (let i = 0, s = 0, o = 0, a = 0; ; i++) {
      let l = i == e.length ? null : e[i], c = o - a, u = l ? l.fromB : 1e9;
      for (; s < r.length && r[s] < u; ) {
        let h = r[s], f = r[s + 1], d = Math.max(a, h), p = Math.min(u, f);
        if (d <= p && new Ft(d + c, p + c, d, p).addToSet(n), f > u)
          break;
        s += 2;
      }
      if (!l)
        return n;
      new Ft(l.fromA, l.toA, l.fromB, l.toB).addToSet(n), o = l.toA, a = l.toB;
    }
  }
}
class Xo {
  constructor(e, r, n) {
    this.view = e, this.state = r, this.transactions = n, this.flags = 0, this.startState = e.state, this.changes = Fe.empty(this.startState.doc.length);
    for (let s of n)
      this.changes = this.changes.compose(s.changes);
    let i = [];
    this.changes.iterChangedRanges((s, o, a, l) => i.push(new Ft(s, o, a, l))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new Xo(e, r, n);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class Ed extends ge {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Ae()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Ft(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var r;
    let n = e.changedRanges;
    this.minWidth > 0 && n.length && (n.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let i = -1;
    this.view.inputState.composing >= 0 && (!((r = this.domChanged) === null || r === void 0) && r.newSel ? i = this.domChanged.newSel.head : !l_(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let s = i > -1 ? n_(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: u } = this.hasComposition;
      n = new Ft(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(n.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (V.ie || V.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, a = this.updateDeco(), l = o_(o, a, e.changes);
    return n = Ft.extendWithRanges(n, l), !(this.flags & 7) && n.length == 0 ? !1 : (this.updateInner(n, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, r, n) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, r, n);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = V.chrome || V.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof qr && o.widget instanceof Ad && s.push(o.dom);
    i.updateGaps(s);
  }
  updateChildren(e, r, n) {
    let i = n ? n.range.addToSet(e.slice()) : e, s = this.childCursor(r);
    for (let o = i.length - 1; ; o--) {
      let a = o >= 0 ? i[o] : null;
      if (!a)
        break;
      let { fromA: l, toA: c, fromB: u, toB: h } = a, f, d, p, m;
      if (n && n.range.fromB < h && n.range.toB > u) {
        let w = es.build(this.view.state.doc, u, n.range.fromB, this.decorations, this.dynamicDecorationMap), D = es.build(this.view.state.doc, n.range.toB, h, this.decorations, this.dynamicDecorationMap);
        d = w.breakAtStart, p = w.openStart, m = D.openEnd;
        let x = this.compositionView(n);
        D.breakAtStart ? x.breakAfter = 1 : D.content.length && x.merge(x.length, x.length, D.content[0], !1, D.openStart, 0) && (x.breakAfter = D.content[0].breakAfter, D.content.shift()), w.content.length && x.merge(0, 0, w.content[w.content.length - 1], !0, 0, w.openEnd) && w.content.pop(), f = w.content.concat(x).concat(D.content);
      } else
        ({ content: f, breakAtStart: d, openStart: p, openEnd: m } = es.build(this.view.state.doc, u, h, this.decorations, this.dynamicDecorationMap));
      let { i: y, off: v } = s.findPos(c, 1), { i: g, off: b } = s.findPos(l, -1);
      cy(this, g, b, y, v, f, d, p, m);
    }
    n && this.fixCompositionDOM(n);
  }
  compositionView(e) {
    let r = new mr(e.text.nodeValue);
    r.flags |= 8;
    for (let { deco: i } of e.marks)
      r = new gr(i, [r], r.length);
    let n = new Ae();
    return n.append(r, 0), n;
  }
  fixCompositionDOM(e) {
    let r = (s, o) => {
      o.flags |= 8 | (o.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let a = ge.get(s);
      a && a != o && (a.dom = null), o.setDOM(s);
    }, n = this.childPos(e.range.fromB, 1), i = this.children[n.i];
    r(e.line, i);
    for (let s = e.marks.length - 1; s >= -1; s--)
      n = i.childPos(n.off, 1), i = i.children[n.i], r(s >= 0 ? e.marks[s].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, r = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let n = this.view.root.activeElement, i = n == this.dom, s = !i && Bo(this.dom, this.view.observer.selectionRange) && !(n && this.dom.contains(n));
    if (!(i || r || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (V.gecko && a.empty && !this.hasComposition && r_(l)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(h, l.node.childNodes[l.offset] || null)), l = c = new ze(h, 0), o = !0;
    }
    let u = this.view.observer.selectionRange;
    (o || !u.focusNode || (!Zi(l.node, l.offset, u.anchorNode, u.anchorOffset) || !Zi(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, a)) && (this.view.observer.ignore(() => {
      V.android && V.chrome && this.dom.contains(u.focusNode) && a_(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let h = Jo(this.view.root);
      if (h)
        if (a.empty) {
          if (V.gecko) {
            let f = i_(l.node, l.offset);
            if (f && f != 3) {
              let d = Ry(l.node, l.offset, f == 1 ? 1 : -1);
              d && (l = new ze(d.node, d.offset));
            }
          }
          h.collapse(l.node, l.offset), a.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = a.bidiLevel);
        } else if (h.extend) {
          h.collapse(l.node, l.offset);
          try {
            h.extend(c.node, c.offset);
          } catch {
          }
        } else {
          let f = document.createRange();
          a.anchor > a.head && ([l, c] = [c, l]), f.setEnd(c.node, c.offset), f.setStart(l.node, l.offset), h.removeAllRanges(), h.addRange(f);
        }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), n && n.focus());
    }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new ze(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new ze(u.focusNode, u.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, r) {
    return this.hasComposition && r.empty && Zi(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == r.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, r = e.state.selection.main, n = Jo(e.root), { anchorNode: i, anchorOffset: s } = e.observer.selectionRange;
    if (!n || !r.empty || !r.assoc || !n.modify)
      return;
    let o = Ae.find(this, r.head);
    if (!o)
      return;
    let a = o.posAtStart;
    if (r.head == a || r.head == a + o.length)
      return;
    let l = this.coordsAt(r.head, -1), c = this.coordsAt(r.head, 1);
    if (!l || !c || l.bottom > c.top)
      return;
    let u = this.domAtPos(r.head + r.assoc);
    n.collapse(u.node, u.offset), n.modify("move", r.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != r.from && n.collapse(i, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let r = this.dom, n;
    if (e.node != r)
      return e;
    for (let i = e.offset; !n && i < r.childNodes.length; i++) {
      let s = ge.get(r.childNodes[i]);
      s instanceof Ae && (n = s.domAtPos(0));
    }
    for (let i = e.offset - 1; !n && i >= 0; i--) {
      let s = ge.get(r.childNodes[i]);
      s instanceof Ae && (n = s.domAtPos(s.length));
    }
    return n ? new ze(n.node, n.offset, !0) : e;
  }
  nearest(e) {
    for (let r = e; r; ) {
      let n = ge.get(r);
      if (n && n.rootView == this)
        return n;
      r = r.parentNode;
    }
    return null;
  }
  posFromDOM(e, r) {
    let n = this.nearest(e);
    if (!n)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return n.localPosFromDOM(e, r) + n.posAtStart;
  }
  domAtPos(e) {
    let { i: r, off: n } = this.childCursor().findPos(e, -1);
    for (; r < this.children.length - 1; ) {
      let i = this.children[r];
      if (n < i.length || i instanceof Ae)
        break;
      r++, n = 0;
    }
    return this.children[r].domAtPos(n);
  }
  coordsAt(e, r) {
    let n = null, i = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let a = this.children[o], l = s - a.breakAfter, c = l - a.length;
      if (l < e)
        break;
      c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!n || a instanceof Ae && !(n instanceof Ae && r >= 0)) && (n = a, i = c), s = c;
    }
    return n ? n.coordsAt(e - i, r) : null;
  }
  coordsForChar(e) {
    let { i: r, off: n } = this.childPos(e, 1), i = this.children[r];
    if (!(i instanceof Ae))
      return null;
    for (; i.children.length; ) {
      let { i: a, off: l } = i.childPos(n, 1);
      for (; ; a++) {
        if (a == i.children.length)
          return null;
        if ((i = i.children[a]).length)
          break;
      }
      n = l;
    }
    if (!(i instanceof mr))
      return null;
    let s = Ie(i.text, n);
    if (s == n)
      return null;
    let o = kn(i.dom, n, s).getClientRects();
    for (let a = 0; a < o.length; a++) {
      let l = o[a];
      if (a == o.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let r = [], { from: n, to: i } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == ye.LTR;
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let h = this.children[u], f = c + h.length;
      if (f > i)
        break;
      if (c >= n) {
        let d = h.dom.getBoundingClientRect();
        if (r.push(d.height), o) {
          let p = h.dom.lastChild, m = p ? ui(p) : [];
          if (m.length) {
            let y = m[m.length - 1], v = l ? y.right - d.left : d.right - y.left;
            v > a && (a = v, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = f);
          }
        }
      }
      c = f + h.breakAfter;
    }
    return r;
  }
  textDirectionAt(e) {
    let { i: r } = this.childPos(e, 1);
    return getComputedStyle(this.children[r].dom).direction == "rtl" ? ye.RTL : ye.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof Ae) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), r, n, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = ui(e.firstChild)[0];
      r = e.getBoundingClientRect().height, n = s ? s.width / 27 : 7, i = s ? s.height : r, e.remove();
    }), { lineHeight: r, charWidth: n, textHeight: i };
  }
  childCursor(e = this.length) {
    let r = this.children.length;
    return r && (e -= this.children[--r].length), new uy(this.children, e, r);
  }
  computeBlockGapDeco() {
    let e = [], r = this.view.viewState;
    for (let n = 0, i = 0; ; i++) {
      let s = i == r.viewports.length ? null : r.viewports[i], o = s ? s.from - 1 : this.length;
      if (o > n) {
        let a = (r.lineBlockAt(o).bottom - r.lineBlockAt(n).top) / this.view.scaleY;
        e.push(K.replace({
          widget: new Ad(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(n, o));
      }
      if (!s)
        break;
      n = s.to + 1;
    }
    return K.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(hs).map((i, s) => (this.dynamicDecorationMap[s] = typeof i == "function") ? i(this.view) : i), r = !1, n = this.view.state.facet(Oy).map((i, s) => {
      let o = typeof i == "function";
      return o && (r = !0), o ? i(this.view) : i;
    });
    n.length && (this.dynamicDecorationMap[e.length] = r, e.push(ie.join(n)));
    for (let i = e.length; i < e.length + 3; i++)
      this.dynamicDecorationMap[i] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    let { range: r } = e, n = this.coordsAt(r.head, r.empty ? r.assoc : r.head > r.anchor ? -1 : 1), i;
    if (!n)
      return;
    !r.empty && (i = this.coordsAt(r.anchor, r.anchor > r.head ? -1 : 1)) && (n = {
      left: Math.min(n.left, i.left),
      top: Math.min(n.top, i.top),
      right: Math.max(n.right, i.right),
      bottom: Math.max(n.bottom, i.bottom)
    });
    let s = Py(this.view), o = {
      left: n.left - s.left,
      top: n.top - s.top,
      right: n.right + s.right,
      bottom: n.bottom + s.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    NT(this.view.scrollDOM, o, r.head < r.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == ye.LTR);
  }
}
function r_(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
class Ad extends Sr {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
function Ny(t, e) {
  let r = t.observer.selectionRange, n = r.focusNode && Ry(r.focusNode, r.focusOffset, 0);
  if (!n)
    return null;
  let i = e - n.offset;
  return { from: i, to: i + n.node.nodeValue.length, node: n.node };
}
function n_(t, e, r) {
  let n = Ny(t, r);
  if (!n)
    return null;
  let { node: i, from: s, to: o } = n, a = i.nodeValue;
  if (/[\n\r]/.test(a) || t.state.doc.sliceString(n.from, n.to) != a)
    return null;
  let l = e.invertedDesc, c = new Ft(l.mapPos(s), l.mapPos(o), s, o), u = [];
  for (let h = i.parentNode; ; h = h.parentNode) {
    let f = ge.get(h);
    if (f instanceof gr)
      u.push({ node: h, deco: f.mark });
    else {
      if (f instanceof Ae || h.nodeName == "DIV" && h.parentNode == t.contentDOM)
        return { range: c, text: i, marks: u, line: h };
      if (h != t.contentDOM)
        u.push({ node: h, deco: new Ls({
          inclusive: !0,
          attributes: VT(h),
          tagName: h.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function Ry(t, e, r) {
  if (r <= 0)
    for (let n = t, i = e; ; ) {
      if (n.nodeType == 3)
        return { node: n, offset: i };
      if (n.nodeType == 1 && i > 0)
        n = n.childNodes[i - 1], i = pr(n);
      else
        break;
    }
  if (r >= 0)
    for (let n = t, i = e; ; ) {
      if (n.nodeType == 3)
        return { node: n, offset: i };
      if (n.nodeType == 1 && i < n.childNodes.length && r >= 0)
        n = n.childNodes[i], i = 0;
      else
        break;
    }
  return null;
}
function i_(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let s_ = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, r) {
    qu(e, r, this.changes);
  }
  comparePoint(e, r) {
    qu(e, r, this.changes);
  }
};
function o_(t, e, r) {
  let n = new s_();
  return ie.compare(t, e, r, n), n.changes;
}
function a_(t, e) {
  for (let r = t; r && r != e; r = r.assignedSlot || r.parentNode)
    if (r.nodeType == 1 && r.contentEditable == "false")
      return !0;
  return !1;
}
function l_(t, e) {
  let r = !1;
  return e && t.iterChangedRanges((n, i) => {
    n < e.to && i > e.from && (r = !0);
  }), r;
}
function u_(t, e, r = 1) {
  let n = t.charCategorizer(e), i = t.doc.lineAt(e), s = e - i.from;
  if (i.length == 0)
    return B.cursor(e);
  s == 0 ? r = 1 : s == i.length && (r = -1);
  let o = s, a = s;
  r < 0 ? o = Ie(i.text, s, !1) : a = Ie(i.text, s);
  let l = n(i.text.slice(o, a));
  for (; o > 0; ) {
    let c = Ie(i.text, o, !1);
    if (n(i.text.slice(c, o)) != l)
      break;
    o = c;
  }
  for (; a < i.length; ) {
    let c = Ie(i.text, a);
    if (n(i.text.slice(a, c)) != l)
      break;
    a = c;
  }
  return B.range(o + i.from, a + i.from);
}
function c_(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function h_(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function Ll(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function Fd(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function Td(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function Gu(t, e, r) {
  let n, i, s, o, a = !1, l, c, u, h;
  for (let p = t.firstChild; p; p = p.nextSibling) {
    let m = ui(p);
    for (let y = 0; y < m.length; y++) {
      let v = m[y];
      i && Ll(i, v) && (v = Fd(Td(v, i.bottom), i.top));
      let g = c_(e, v), b = h_(r, v);
      if (g == 0 && b == 0)
        return p.nodeType == 3 ? _d(p, e, r) : Gu(p, e, r);
      if (!n || o > b || o == b && s > g) {
        n = p, i = v, s = g, o = b;
        let w = b ? r < v.top ? -1 : 1 : g ? e < v.left ? -1 : 1 : 0;
        a = !w || (w > 0 ? y < m.length - 1 : y > 0);
      }
      g == 0 ? r > v.bottom && (!u || u.bottom < v.bottom) ? (l = p, u = v) : r < v.top && (!h || h.top > v.top) && (c = p, h = v) : u && Ll(u, v) ? u = Td(u, v.bottom) : h && Ll(h, v) && (h = Fd(h, v.top));
    }
  }
  if (u && u.bottom >= r ? (n = l, i = u) : h && h.top <= r && (n = c, i = h), !n)
    return { node: t, offset: 0 };
  let f = Math.max(i.left, Math.min(i.right, e));
  if (n.nodeType == 3)
    return _d(n, f, r);
  if (a && n.contentEditable != "false")
    return Gu(n, f, r);
  let d = Array.prototype.indexOf.call(t.childNodes, n) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: t, offset: d };
}
function _d(t, e, r) {
  let n = t.nodeValue.length, i = -1, s = 1e9, o = 0;
  for (let a = 0; a < n; a++) {
    let l = kn(t, a, a + 1).getClientRects();
    for (let c = 0; c < l.length; c++) {
      let u = l[c];
      if (u.top == u.bottom)
        continue;
      o || (o = e - u.left);
      let h = (u.top > r ? u.top - r : r - u.bottom) - 1;
      if (u.left - 1 <= e && u.right + 1 >= e && h < s) {
        let f = e >= (u.left + u.right) / 2, d = f;
        if ((V.chrome || V.gecko) && kn(t, a).getBoundingClientRect().left == u.right && (d = !f), h <= 0)
          return { node: t, offset: a + (d ? 1 : 0) };
        i = a + (d ? 1 : 0), s = h;
      }
    }
  }
  return { node: t, offset: i > -1 ? i : o > 0 ? t.nodeValue.length : 0 };
}
function Iy(t, e, r, n = -1) {
  var i, s;
  let o = t.contentDOM.getBoundingClientRect(), a = o.top + t.viewState.paddingTop, l, { docHeight: c } = t.viewState, { x: u, y: h } = e, f = h - a;
  if (f < 0)
    return 0;
  if (f > c)
    return t.state.doc.length;
  for (let w = t.viewState.heightOracle.textHeight / 2, D = !1; l = t.elementAtHeight(f), l.type != Ze.Text; )
    for (; f = n > 0 ? l.bottom + w : l.top - w, !(f >= 0 && f <= c); ) {
      if (D)
        return r ? null : 0;
      D = !0, n = -n;
    }
  h = a + f;
  let d = l.from;
  if (d < t.viewport.from)
    return t.viewport.from == 0 ? 0 : r ? null : Bd(t, o, l, u, h);
  if (d > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : r ? null : Bd(t, o, l, u, h);
  let p = t.dom.ownerDocument, m = t.root.elementFromPoint ? t.root : p, y = m.elementFromPoint(u, h);
  y && !t.contentDOM.contains(y) && (y = null), y || (u = Math.max(o.left + 1, Math.min(o.right - 1, u)), y = m.elementFromPoint(u, h), y && !t.contentDOM.contains(y) && (y = null));
  let v, g = -1;
  if (y && ((i = t.docView.nearest(y)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let w = p.caretPositionFromPoint(u, h);
      w && ({ offsetNode: v, offset: g } = w);
    } else if (p.caretRangeFromPoint) {
      let w = p.caretRangeFromPoint(u, h);
      w && ({ startContainer: v, startOffset: g } = w, (!t.contentDOM.contains(v) || V.safari && f_(v, g, u) || V.chrome && d_(v, g, u)) && (v = void 0));
    }
  }
  if (!v || !t.docView.dom.contains(v)) {
    let w = Ae.find(t.docView, d);
    if (!w)
      return f > l.top + l.height / 2 ? l.to : l.from;
    ({ node: v, offset: g } = Gu(w.dom, u, h));
  }
  let b = t.docView.nearest(v);
  if (!b)
    return null;
  if (b.isWidget && ((s = b.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let w = b.dom.getBoundingClientRect();
    return e.y < w.top || e.y <= w.bottom && e.x <= (w.left + w.right) / 2 ? b.posAtStart : b.posAtEnd;
  } else
    return b.localPosFromDOM(v, g) + b.posAtStart;
}
function Bd(t, e, r, n, i) {
  let s = Math.round((n - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && r.height > t.defaultLineHeight * 1.5) {
    let a = t.viewState.heightOracle.textHeight, l = Math.floor((i - r.top - (t.defaultLineHeight - a) * 0.5) / a);
    s += l * t.viewState.heightOracle.lineLength;
  }
  let o = t.state.sliceDoc(r.from, r.to);
  return r.from + Mu(o, s, t.state.tabSize);
}
function f_(t, e, r) {
  let n;
  if (t.nodeType != 3 || e != (n = t.nodeValue.length))
    return !1;
  for (let i = t.nextSibling; i; i = i.nextSibling)
    if (i.nodeType != 1 || i.nodeName != "BR")
      return !1;
  return kn(t, n - 1, n).getBoundingClientRect().left > r;
}
function d_(t, e, r) {
  if (e != 0)
    return !1;
  for (let i = t; ; ) {
    let s = i.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != i)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    i = s;
  }
  let n = t.nodeType == 1 ? t.getBoundingClientRect() : kn(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return r - n.left > 5;
}
function Ku(t, e) {
  let r = t.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    for (let n of r.type)
      if (n.to > e || n.to == e && (n.to == r.to || n.type == Ze.Text))
        return n;
  }
  return r;
}
function p_(t, e, r, n) {
  let i = Ku(t, e.head), s = !n || i.type != Ze.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (s) {
    let o = t.dom.getBoundingClientRect(), a = t.textDirectionAt(i.from), l = t.posAtCoords({
      x: r == (a == ye.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (l != null)
      return B.cursor(l, r ? -1 : 1);
  }
  return B.cursor(r ? i.to : i.from, r ? -1 : 1);
}
function Od(t, e, r, n) {
  let i = t.state.doc.lineAt(e.head), s = t.bidiSpans(i), o = t.textDirectionAt(i.from);
  for (let a = e, l = null; ; ) {
    let c = ZT(i, s, o, a, r), u = xy;
    if (!c) {
      if (i.number == (r ? t.state.doc.lines : 1))
        return a;
      u = `
`, i = t.state.doc.line(i.number + (r ? 1 : -1)), s = t.bidiSpans(i), c = t.visualLineSide(i, !r);
    }
    if (l) {
      if (!l(u))
        return a;
    } else {
      if (!n)
        return c;
      l = n(u);
    }
    a = c;
  }
}
function m_(t, e, r) {
  let n = t.state.charCategorizer(e), i = n(r);
  return (s) => {
    let o = n(s);
    return i == xe.Space && (i = o), i == o;
  };
}
function g_(t, e, r, n) {
  let i = e.head, s = r ? 1 : -1;
  if (i == (r ? t.state.doc.length : 0))
    return B.cursor(i, e.assoc);
  let o = e.goalColumn, a, l = t.contentDOM.getBoundingClientRect(), c = t.coordsAtPos(i, e.assoc || -1), u = t.documentTop;
  if (c)
    o == null && (o = c.left - l.left), a = s < 0 ? c.top : c.bottom;
  else {
    let d = t.viewState.lineBlockAt(i);
    o == null && (o = Math.min(l.right - l.left, t.defaultCharacterWidth * (i - d.from))), a = (s < 0 ? d.top : d.bottom) + u;
  }
  let h = l.left + o, f = n ?? t.viewState.heightOracle.textHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = a + (f + d) * s, m = Iy(t, { x: h, y: p }, !1, s);
    if (p < l.top || p > l.bottom || (s < 0 ? m < i : m > i)) {
      let y = t.docView.coordsForChar(m), v = !y || p < y.top ? -1 : 1;
      return B.cursor(m, v, void 0, o);
    }
  }
}
function Oo(t, e, r) {
  for (; ; ) {
    let n = 0;
    for (let i of t)
      i.between(e - 1, e + 1, (s, o, a) => {
        if (e > s && e < o) {
          let l = n || r || (e - s < o - e ? -1 : 1);
          e = l < 0 ? s : o, n = l;
        }
      });
    if (!n)
      return e;
  }
}
function Pl(t, e, r) {
  let n = Oo(t.state.facet(Bh).map((i) => i(t)), r.from, e.head > r.from ? -1 : 1);
  return n == r.from ? r : B.cursor(n, n < r.from ? 1 : -1);
}
class y_ {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, V.safari && e.contentDOM.addEventListener("input", () => null), V.gecko && M_(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !S_(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, r) {
    let n = this.handlers[e];
    if (n) {
      for (let i of n.observers)
        i(this.view, r);
      for (let i of n.handlers) {
        if (r.defaultPrevented)
          break;
        if (i(this.view, r)) {
          r.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let r = v_(e), n = this.handlers, i = this.view.contentDOM;
    for (let s in r)
      if (s != "scroll") {
        let o = !r[s].handlers.length, a = n[s];
        a && o != !a.handlers.length && (i.removeEventListener(s, this.handleEvent), a = null), a || i.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in n)
      s != "scroll" && !r[s] && i.removeEventListener(s, this.handleEvent);
    this.handlers = r;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (e.keyCode != 27 && jy.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), V.android && V.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let r;
    return V.ios && !e.synthetic && !e.altKey && !e.metaKey && ((r = $y.find((n) => n.keyCode == e.keyCode)) && !e.ctrlKey || b_.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = r || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let e = this.pendingIOSKey;
    return e ? (this.pendingIOSKey = void 0, ti(this.view.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : V.safari && !V.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function Md(t, e) {
  return (r, n) => {
    try {
      return e.call(t, n, r);
    } catch (i) {
      At(r.state, i);
    }
  };
}
function v_(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function r(n) {
    return e[n] || (e[n] = { observers: [], handlers: [] });
  }
  for (let n of t) {
    let i = n.spec;
    if (i && i.domEventHandlers)
      for (let s in i.domEventHandlers) {
        let o = i.domEventHandlers[s];
        o && r(s).handlers.push(Md(n.value, o));
      }
    if (i && i.domEventObservers)
      for (let s in i.domEventObservers) {
        let o = i.domEventObservers[s];
        o && r(s).observers.push(Md(n.value, o));
      }
  }
  for (let n in $t)
    r(n).handlers.push($t[n]);
  for (let n in jt)
    r(n).observers.push(jt[n]);
  return e;
}
const $y = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], b_ = "dthko", jy = [16, 17, 18, 20, 91, 92, 224, 225], ro = 6;
function no(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function D_(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class w_ {
  constructor(e, r, n, i) {
    this.view = e, this.startEvent = r, this.style = n, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = r, this.scrollParent = RT(e.contentDOM), this.atoms = e.state.facet(Bh).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = r.shiftKey, this.multiple = e.state.facet(ee.allowMultipleSelections) && x_(e, r), this.dragging = k_(e, r) && Vy(r) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var r;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && D_(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let n = 0, i = 0, s = ((r = this.scrollParent) === null || r === void 0 ? void 0 : r.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, o = Py(this.view);
    e.clientX - o.left <= s.left + ro ? n = -no(s.left - e.clientX) : e.clientX + o.right >= s.right - ro && (n = no(e.clientX - s.right)), e.clientY - o.top <= s.top + ro ? i = -no(s.top - e.clientY) : e.clientY + o.bottom >= s.bottom - ro && (i = no(e.clientY - s.bottom)), this.setScrollSpeed(n, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, r) {
    this.scrollSpeed = { x: e, y: r }, e || r ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let r = null;
    for (let n = 0; n < e.ranges.length; n++) {
      let i = e.ranges[n], s = null;
      if (i.empty) {
        let o = Oo(this.atoms, i.from, 0);
        o != i.from && (s = B.cursor(o, -1));
      } else {
        let o = Oo(this.atoms, i.from, -1), a = Oo(this.atoms, i.to, 1);
        (o != i.from || a != i.to) && (s = B.range(i.from == i.anchor ? o : a, i.from == i.head ? o : a));
      }
      s && (r || (r = e.ranges.slice()), r[n] = s);
    }
    return r ? B.create(r, e.mainIndex) : e;
  }
  select(e) {
    let { view: r } = this, n = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !n.eq(r.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: n,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function x_(t, e) {
  let r = t.state.facet(Cy);
  return r.length ? r[0](e) : V.mac ? e.metaKey : e.ctrlKey;
}
function C_(t, e) {
  let r = t.state.facet(ky);
  return r.length ? r[0](e) : V.mac ? !e.altKey : !e.ctrlKey;
}
function k_(t, e) {
  let { main: r } = t.state.selection;
  if (r.empty)
    return !1;
  let n = Jo(t.root);
  if (!n || n.rangeCount == 0)
    return !0;
  let i = n.getRangeAt(0).getClientRects();
  for (let s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function S_(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let r = e.target, n; r != t.contentDOM; r = r.parentNode)
    if (!r || r.nodeType == 11 || (n = ge.get(r)) && n.ignoreEvent(e))
      return !1;
  return !0;
}
const $t = /* @__PURE__ */ Object.create(null), jt = /* @__PURE__ */ Object.create(null), Wy = V.ie && V.ie_version < 15 || V.ios && V.webkit_version < 604;
function E_(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let r = e.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(), setTimeout(() => {
    t.focus(), r.remove(), qy(t, r.value);
  }, 50);
}
function qy(t, e) {
  let { state: r } = t, n, i = 1, s = r.toText(e), o = s.lines == r.selection.ranges.length;
  if (Yu != null && r.selection.ranges.every((l) => l.empty) && Yu == s.toString()) {
    let l = -1;
    n = r.changeByRange((c) => {
      let u = r.doc.lineAt(c.from);
      if (u.from == l)
        return { range: c };
      l = u.from;
      let h = r.toText((o ? s.line(i++).text : e) + r.lineBreak);
      return {
        changes: { from: u.from, insert: h },
        range: B.cursor(c.from + h.length)
      };
    });
  } else
    o ? n = r.changeByRange((l) => {
      let c = s.line(i++);
      return {
        changes: { from: l.from, to: l.to, insert: c.text },
        range: B.cursor(l.from + c.length)
      };
    }) : n = r.replaceSelection(s);
  t.dispatch(n, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
jt.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
$t.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (t.inputState.lastEscPress = Date.now()), !1);
jt.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
jt.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
$t.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let r = null;
  for (let n of t.state.facet(Sy))
    if (r = n(t, e), r)
      break;
  if (!r && e.button == 0 && (r = T_(t, e)), r) {
    let n = !t.hasFocus;
    t.inputState.startMouseSelection(new w_(t, e, r, n)), n && t.observer.ignore(() => oy(t.contentDOM));
    let i = t.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  }
  return !1;
};
function Ld(t, e, r, n) {
  if (n == 1)
    return B.cursor(e, r);
  if (n == 2)
    return u_(t.state, e, r);
  {
    let i = Ae.find(t.docView, e), s = t.state.doc.lineAt(i ? i.posAtEnd : e), o = i ? i.posAtStart : s.from, a = i ? i.posAtEnd : s.to;
    return a < t.state.doc.length && a == s.to && a++, B.range(o, a);
  }
}
let Hy = (t, e) => t >= e.top && t <= e.bottom, Pd = (t, e, r) => Hy(e, r) && t >= r.left && t <= r.right;
function A_(t, e, r, n) {
  let i = Ae.find(t.docView, e);
  if (!i)
    return 1;
  let s = e - i.posAtStart;
  if (s == 0)
    return 1;
  if (s == i.length)
    return -1;
  let o = i.coordsAt(s, -1);
  if (o && Pd(r, n, o))
    return -1;
  let a = i.coordsAt(s, 1);
  return a && Pd(r, n, a) ? 1 : o && Hy(n, o) ? -1 : 1;
}
function Nd(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: r, bias: A_(t, r, e.clientX, e.clientY) };
}
const F_ = V.ie && V.ie_version <= 11;
let Rd = null, Id = 0, $d = 0;
function Vy(t) {
  if (!F_)
    return t.detail;
  let e = Rd, r = $d;
  return Rd = t, $d = Date.now(), Id = !e || r > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (Id + 1) % 3 : 1;
}
function T_(t, e) {
  let r = Nd(t, e), n = Vy(e), i = t.state.selection;
  return {
    update(s) {
      s.docChanged && (r.pos = s.changes.mapPos(r.pos), i = i.map(s.changes));
    },
    get(s, o, a) {
      let l = Nd(t, s), c, u = Ld(t, l.pos, l.bias, n);
      if (r.pos != l.pos && !o) {
        let h = Ld(t, r.pos, r.bias, n), f = Math.min(h.from, u.from), d = Math.max(h.to, u.to);
        u = f < u.from ? B.range(f, d) : B.range(d, f);
      }
      return o ? i.replaceRange(i.main.extend(u.from, u.to)) : a && n == 1 && i.ranges.length > 1 && (c = __(i, l.pos)) ? c : a ? i.addRange(u) : B.create([u]);
    }
  };
}
function __(t, e) {
  for (let r = 0; r < t.ranges.length; r++) {
    let { from: n, to: i } = t.ranges[r];
    if (n <= e && i >= e)
      return B.create(t.ranges.slice(0, r).concat(t.ranges.slice(r + 1)), t.mainIndex == r ? 0 : t.mainIndex - (t.mainIndex > r ? 1 : 0));
  }
  return null;
}
$t.dragstart = (t, e) => {
  let { selection: { main: r } } = t.state;
  if (e.target.draggable) {
    let i = t.docView.nearest(e.target);
    if (i && i.isWidget) {
      let s = i.posAtStart, o = s + i.length;
      (s >= r.to || o <= r.from) && (r = B.range(s, o));
    }
  }
  let { inputState: n } = t;
  return n.mouseSelection && (n.mouseSelection.dragging = !0), n.draggedContent = r, e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(r.from, r.to)), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
$t.dragend = (t) => (t.inputState.draggedContent = null, !1);
function jd(t, e, r, n) {
  if (!r)
    return;
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = t.inputState, o = n && s && C_(t, e) ? { from: s.from, to: s.to } : null, a = { from: i, insert: r }, l = t.state.changes(o ? [o, a] : a);
  t.focus(), t.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(i, -1), head: l.mapPos(i, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
$t.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let r = e.dataTransfer.files;
  if (r && r.length) {
    let n = Array(r.length), i = 0, s = () => {
      ++i == r.length && jd(t, e, n.filter((o) => o != null).join(t.state.lineBreak), !1);
    };
    for (let o = 0; o < r.length; o++) {
      let a = new FileReader();
      a.onerror = s, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (n[o] = a.result), s();
      }, a.readAsText(r[o]);
    }
    return !0;
  } else {
    let n = e.dataTransfer.getData("Text");
    if (n)
      return jd(t, e, n, !0), !0;
  }
  return !1;
};
$t.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let r = Wy ? null : e.clipboardData;
  return r ? (qy(t, r.getData("text/plain") || r.getData("text/uri-text")), !0) : (E_(t), !1);
};
function B_(t, e) {
  let r = t.dom.parentNode;
  if (!r)
    return;
  let n = r.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.value = e, n.focus(), n.selectionEnd = e.length, n.selectionStart = 0, setTimeout(() => {
    n.remove(), t.focus();
  }, 50);
}
function O_(t) {
  let e = [], r = [], n = !1;
  for (let i of t.selection.ranges)
    i.empty || (e.push(t.sliceDoc(i.from, i.to)), r.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: s } of t.selection.ranges) {
      let o = t.doc.lineAt(s);
      o.number > i && (e.push(o.text), r.push({ from: o.from, to: Math.min(t.doc.length, o.to + 1) })), i = o.number;
    }
    n = !0;
  }
  return { text: e.join(t.lineBreak), ranges: r, linewise: n };
}
let Yu = null;
$t.copy = $t.cut = (t, e) => {
  let { text: r, ranges: n, linewise: i } = O_(t.state);
  if (!r && !i)
    return !1;
  Yu = i ? r : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: n,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = Wy ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", r), !0) : (B_(t, r), !1);
};
const zy = /* @__PURE__ */ lr.define();
function Uy(t, e) {
  let r = [];
  for (let n of t.facet(Fy)) {
    let i = n(t, e);
    i && r.push(i);
  }
  return r ? t.update({ effects: r, annotations: zy.of(!0) }) : null;
}
function Gy(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let r = Uy(t.state, e);
      r ? t.dispatch(r) : t.update([]);
    }
  }, 10);
}
jt.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), Gy(t);
};
jt.blur = (t) => {
  t.observer.clearSelectionRange(), Gy(t);
};
jt.compositionstart = jt.compositionupdate = (t) => {
  t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0);
};
jt.compositionend = (t) => {
  t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, V.chrome && V.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50);
};
jt.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
$t.beforeinput = (t, e) => {
  var r;
  let n;
  if (V.chrome && V.android && (n = $y.find((i) => i.inputType == e.inputType)) && (t.observer.delayAndroidKey(n.key, n.keyCode), n.key == "Backspace" || n.key == "Delete")) {
    let i = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > i + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return !1;
};
const Wd = /* @__PURE__ */ new Set();
function M_(t) {
  Wd.has(t) || (Wd.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const qd = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class L_ {
  constructor(e) {
    this.lineWrapping = e, this.doc = le.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, r) {
    let n = this.doc.lineAt(r).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (n += Math.max(0, Math.ceil((r - e - n * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * n;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return qd.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let r = !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n];
      i < 0 ? n++ : this.heightSamples[Math.floor(i * 10)] || (r = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return r;
  }
  refresh(e, r, n, i, s, o) {
    let a = qd.indexOf(e) > -1, l = Math.round(r) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = r, this.charWidth = n, this.textHeight = i, this.lineLength = s, l) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let u = o[c];
        u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return l;
  }
}
class P_ {
  constructor(e, r) {
    this.from = e, this.heights = r, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Zt {
  /**
  @internal
  */
  constructor(e, r, n, i, s) {
    this.from = e, this.length = r, this.top = n, this.height = i, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Ze.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Jr ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let r = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new Zt(this.from, this.length + e.length, this.top, this.height + e.height, r);
  }
}
var me = /* @__PURE__ */ function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
}(me || (me = {}));
const Mo = 1e-3;
class et {
  constructor(e, r, n = 2) {
    this.length = e, this.height = r, this.flags = n;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, r) {
    this.height != r && (Math.abs(this.height - r) > Mo && (e.heightChanged = !0), this.height = r);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, r, n) {
    return et.of(n);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, r) {
    r.push(this);
  }
  decomposeRight(e, r) {
    r.push(this);
  }
  applyChanges(e, r, n, i) {
    let s = this, o = n.doc;
    for (let a = i.length - 1; a >= 0; a--) {
      let { fromA: l, toA: c, fromB: u, toB: h } = i[a], f = s.lineAt(l, me.ByPosNoHeight, n.setDoc(r), 0, 0), d = f.to >= c ? f : s.lineAt(c, me.ByPosNoHeight, n, 0, 0);
      for (h += d.to - c, c = d.to; a > 0 && f.from <= i[a - 1].toA; )
        l = i[a - 1].fromA, u = i[a - 1].fromB, a--, l < f.from && (f = s.lineAt(l, me.ByPosNoHeight, n, 0, 0));
      u += f.from - l, l = f.from;
      let p = Oh.build(n.setDoc(o), e, u, h);
      s = s.replace(l, c, p);
    }
    return s.updateHeight(n, 0);
  }
  static empty() {
    return new ct(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let r = 0, n = e.length, i = 0, s = 0;
    for (; ; )
      if (r == n)
        if (i > s * 2) {
          let a = e[r - 1];
          a.break ? e.splice(--r, 1, a.left, null, a.right) : e.splice(--r, 1, a.left, a.right), n += 1 + a.break, i -= a.size;
        } else if (s > i * 2) {
          let a = e[n];
          a.break ? e.splice(n, 1, a.left, null, a.right) : e.splice(n, 1, a.left, a.right), n += 2 + a.break, s -= a.size;
        } else
          break;
      else if (i < s) {
        let a = e[r++];
        a && (i += a.size);
      } else {
        let a = e[--n];
        a && (s += a.size);
      }
    let o = 0;
    return e[r - 1] == null ? (o = 1, r--) : e[r] == null && (o = 1, n++), new N_(et.of(e.slice(0, r)), o, et.of(e.slice(n)));
  }
}
et.prototype.size = 1;
class Ky extends et {
  constructor(e, r, n) {
    super(e, r), this.deco = n;
  }
  blockAt(e, r, n, i) {
    return new Zt(i, this.length, n, this.height, this.deco || 0);
  }
  lineAt(e, r, n, i, s) {
    return this.blockAt(0, n, i, s);
  }
  forEachLine(e, r, n, i, s, o) {
    e <= s + this.length && r >= s && o(this.blockAt(0, n, i, s));
  }
  updateHeight(e, r = 0, n = !1, i) {
    return i && i.from <= r && i.more && this.setHeight(e, i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class ct extends Ky {
  constructor(e, r) {
    super(e, r, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, r, n, i) {
    return new Zt(i, this.length, n, this.height, this.breaks);
  }
  replace(e, r, n) {
    let i = n[0];
    return n.length == 1 && (i instanceof ct || i instanceof Oe && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof Oe ? i = new ct(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : et.of(n);
  }
  updateHeight(e, r = 0, n = !1, i) {
    return i && i.from <= r && i.more ? this.setHeight(e, i.heights[i.index++]) : (n || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Oe extends et {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, r) {
    let n = e.doc.lineAt(r).number, i = e.doc.lineAt(r + this.length).number, s = i - n + 1, o, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * s);
      o = l / s, this.length > s + 1 && (a = (this.height - l) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: n, lastLine: i, perLine: o, perChar: a };
  }
  blockAt(e, r, n, i) {
    let { firstLine: s, lastLine: o, perLine: a, perChar: l } = this.heightMetrics(r, i);
    if (r.lineWrapping) {
      let c = i + Math.round(Math.max(0, Math.min(1, (e - n) / this.height)) * this.length), u = r.doc.lineAt(c), h = a + u.length * l, f = Math.max(n, e - h / 2);
      return new Zt(u.from, u.length, f, h, 0);
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - n) / a))), { from: u, length: h } = r.doc.line(s + c);
      return new Zt(u, h, n + a * c, a, 0);
    }
  }
  lineAt(e, r, n, i, s) {
    if (r == me.ByHeight)
      return this.blockAt(e, n, i, s);
    if (r == me.ByPosNoHeight) {
      let { from: d, to: p } = n.doc.lineAt(e);
      return new Zt(d, p - d, 0, 0, 0);
    }
    let { firstLine: o, perLine: a, perChar: l } = this.heightMetrics(n, s), c = n.doc.lineAt(e), u = a + c.length * l, h = c.number - o, f = i + a * h + l * (c.from - s - h);
    return new Zt(c.from, c.length, Math.max(i, Math.min(f, i + this.height - u)), u, 0);
  }
  forEachLine(e, r, n, i, s, o) {
    e = Math.max(e, s), r = Math.min(r, s + this.length);
    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(n, s);
    for (let u = e, h = i; u <= r; ) {
      let f = n.doc.lineAt(u);
      if (u == e) {
        let p = f.number - a;
        h += l * p + c * (e - s - p);
      }
      let d = l + c * f.length;
      o(new Zt(f.from, f.length, h, d, 0)), h += d, u = f.to + 1;
    }
  }
  replace(e, r, n) {
    let i = this.length - r;
    if (i > 0) {
      let s = n[n.length - 1];
      s instanceof Oe ? n[n.length - 1] = new Oe(s.length + i) : n.push(null, new Oe(i - 1));
    }
    if (e > 0) {
      let s = n[0];
      s instanceof Oe ? n[0] = new Oe(e + s.length) : n.unshift(new Oe(e - 1), null);
    }
    return et.of(n);
  }
  decomposeLeft(e, r) {
    r.push(new Oe(e - 1), null);
  }
  decomposeRight(e, r) {
    r.push(null, new Oe(this.length - e - 1));
  }
  updateHeight(e, r = 0, n = !1, i) {
    let s = r + this.length;
    if (i && i.from <= r + this.length && i.more) {
      let o = [], a = Math.max(r, i.from), l = -1;
      for (i.from > r && o.push(new Oe(i.from - r - 1).updateHeight(e, r)); a <= s && i.more; ) {
        let u = e.doc.lineAt(a).length;
        o.length && o.push(null);
        let h = i.heights[i.index++];
        l == -1 ? l = h : Math.abs(h - l) >= Mo && (l = -2);
        let f = new ct(u, h);
        f.outdated = !1, o.push(f), a += u + 1;
      }
      a <= s && o.push(null, new Oe(s - a).updateHeight(e, a));
      let c = et.of(o);
      return (l < 0 || Math.abs(c.height - this.height) >= Mo || Math.abs(l - this.heightMetrics(e, r).perLine) >= Mo) && (e.heightChanged = !0), c;
    } else
      (n || this.outdated) && (this.setHeight(e, e.heightForGap(r, r + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class N_ extends et {
  constructor(e, r, n) {
    super(e.length + r + n.length, e.height + n.height, r | (e.outdated || n.outdated ? 2 : 0)), this.left = e, this.right = n, this.size = e.size + n.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, r, n, i) {
    let s = n + this.left.height;
    return e < s ? this.left.blockAt(e, r, n, i) : this.right.blockAt(e, r, s, i + this.left.length + this.break);
  }
  lineAt(e, r, n, i, s) {
    let o = i + this.left.height, a = s + this.left.length + this.break, l = r == me.ByHeight ? e < o : e < a, c = l ? this.left.lineAt(e, r, n, i, s) : this.right.lineAt(e, r, n, o, a);
    if (this.break || (l ? c.to < a : c.from > a))
      return c;
    let u = r == me.ByPosNoHeight ? me.ByPosNoHeight : me.ByPos;
    return l ? c.join(this.right.lineAt(a, u, n, o, a)) : this.left.lineAt(a, u, n, i, s).join(c);
  }
  forEachLine(e, r, n, i, s, o) {
    let a = i + this.left.height, l = s + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, r, n, i, s, o), r >= l && this.right.forEachLine(e, r, n, a, l, o);
    else {
      let c = this.lineAt(l, me.ByPos, n, i, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, n, i, s, o), c.to >= e && c.from <= r && o(c), r > c.to && this.right.forEachLine(c.to + 1, r, n, a, l, o);
    }
  }
  replace(e, r, n) {
    let i = this.left.length + this.break;
    if (r < i)
      return this.balanced(this.left.replace(e, r, n), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, r - i, n));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let a of n)
      s.push(a);
    if (e > 0 && Hd(s, o - 1), r < this.length) {
      let a = s.length;
      this.decomposeRight(r, s), Hd(s, a);
    }
    return et.of(s);
  }
  decomposeLeft(e, r) {
    let n = this.left.length;
    if (e <= n)
      return this.left.decomposeLeft(e, r);
    r.push(this.left), this.break && (n++, e >= n && r.push(null)), e > n && this.right.decomposeLeft(e - n, r);
  }
  decomposeRight(e, r) {
    let n = this.left.length, i = n + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, r);
    e < n && this.left.decomposeRight(e, r), this.break && e < i && r.push(null), r.push(this.right);
  }
  balanced(e, r) {
    return e.size > 2 * r.size || r.size > 2 * e.size ? et.of(this.break ? [e, null, r] : [e, r]) : (this.left = e, this.right = r, this.height = e.height + r.height, this.outdated = e.outdated || r.outdated, this.size = e.size + r.size, this.length = e.length + this.break + r.length, this);
  }
  updateHeight(e, r = 0, n = !1, i) {
    let { left: s, right: o } = this, a = r + s.length + this.break, l = null;
    return i && i.from <= r + s.length && i.more ? l = s = s.updateHeight(e, r, n, i) : s.updateHeight(e, r, n), i && i.from <= a + o.length && i.more ? l = o = o.updateHeight(e, a, n, i) : o.updateHeight(e, a, n), l ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function Hd(t, e) {
  let r, n;
  t[e] == null && (r = t[e - 1]) instanceof Oe && (n = t[e + 1]) instanceof Oe && t.splice(e - 1, 3, new Oe(r.length + 1 + n.length));
}
const R_ = 5;
class Oh {
  constructor(e, r) {
    this.pos = e, this.oracle = r, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, r) {
    if (this.lineStart > -1) {
      let n = Math.min(r, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof ct ? i.length += n - this.pos : (n > this.pos || !this.isCovered) && this.nodes.push(new ct(n - this.pos, -1)), this.writtenTo = n, r > n && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = r;
  }
  point(e, r, n) {
    if (e < r || n.heightRelevant) {
      let i = n.widget ? n.widget.estimatedHeight : 0, s = n.widget ? n.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let o = r - e;
      n.block ? this.addBlock(new Ky(o, i, n)) : (o || s || i >= R_) && this.addLineDeco(i, s, o);
    } else
      r > e && this.span(e, r);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: r } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = r, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new ct(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, r) {
    let n = new Oe(r - e);
    return this.oracle.doc.lineAt(e).to == r && (n.flags |= 4), n;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof ct)
      return e;
    let r = new ct(0, -1);
    return this.nodes.push(r), r;
  }
  addBlock(e) {
    this.enterLine();
    let r = e.deco;
    r && r.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, r && r.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, r, n) {
    let i = this.ensureLine();
    i.length += n, i.collapsed += n, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += r, this.writtenTo = this.pos = this.pos + n;
  }
  finish(e) {
    let r = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(r instanceof ct) && !this.isCovered ? this.nodes.push(new ct(0, -1)) : (this.writtenTo < this.pos || r == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let n = e;
    for (let i of this.nodes)
      i instanceof ct && i.updateHeight(this.oracle, n), n += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, r, n, i) {
    let s = new Oh(n, e);
    return ie.spans(r, n, i, s, 0), s.finish(n);
  }
}
function I_(t, e, r) {
  let n = new $_();
  return ie.compare(t, e, r, n, 0), n.changes;
}
class $_ {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, r, n, i) {
    (e < r || n && n.heightRelevant || i && i.heightRelevant) && qu(e, r, this.changes, 5);
  }
}
function j_(t, e) {
  let r = t.getBoundingClientRect(), n = t.ownerDocument, i = n.defaultView || window, s = Math.max(0, r.left), o = Math.min(i.innerWidth, r.right), a = Math.max(0, r.top), l = Math.min(i.innerHeight, r.bottom);
  for (let c = t.parentNode; c && c != n.body; )
    if (c.nodeType == 1) {
      let u = c, h = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && h.overflow != "visible") {
        let f = u.getBoundingClientRect();
        s = Math.max(s, f.left), o = Math.min(o, f.right), a = Math.max(a, f.top), l = c == t.parentNode ? f.bottom : Math.min(l, f.bottom);
      }
      c = h.position == "absolute" || h.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - r.left,
    right: Math.max(s, o) - r.left,
    top: a - (r.top + e),
    bottom: Math.max(a, l) - (r.top + e)
  };
}
function W_(t, e) {
  let r = t.getBoundingClientRect();
  return {
    left: 0,
    right: r.right - r.left,
    top: e,
    bottom: r.bottom - (r.top + e)
  };
}
class Nl {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.size = n;
  }
  static same(e, r) {
    if (e.length != r.length)
      return !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n], s = r[n];
      if (i.from != s.from || i.to != s.to || i.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, r) {
    return K.replace({
      widget: new q_(this.size * (r ? e.scaleY : e.scaleX), r)
    }).range(this.from, this.to);
  }
}
class q_ extends Sr {
  constructor(e, r) {
    super(), this.size = e, this.vertical = r;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class Vd {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = zd, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = ye.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let r = e.facet(_h).some((n) => typeof n != "function" && n.class == "cm-lineWrapping");
    this.heightOracle = new L_(r), this.stateDeco = e.facet(hs).filter((n) => typeof n != "function"), this.heightMap = et.empty().applyChanges(this.stateDeco, le.empty, this.heightOracle.setDoc(e.doc), [new Ft(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = K.set(this.lineGaps.map((n) => n.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: r } = this.state.selection;
    for (let n = 0; n <= 1; n++) {
      let i = n ? r.head : r.anchor;
      if (!e.some(({ from: s, to: o }) => i >= s && i <= o)) {
        let { from: s, to: o } = this.lineBlockAt(i);
        e.push(new io(s, o));
      }
    }
    this.viewports = e.sort((n, i) => n.from - i.from), this.scaler = this.heightMap.height <= 7e6 ? zd : new z_(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : Wi(e, this.scaler));
    });
  }
  update(e, r = null) {
    this.state = e.state;
    let n = this.stateDeco;
    this.stateDeco = this.state.facet(hs).filter((u) => typeof u != "function");
    let i = e.changedRanges, s = Ft.extendWithRanges(i, I_(n, this.stateDeco, e ? e.changes : Fe.empty(this.state.doc.length))), o = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != o && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (r && (r.range.head < l.from || r.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, r));
    let c = !e.changes.empty || e.flags & 2 || l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, this.updateForViewport(), c && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), r && (this.scrollTarget = r), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(_y) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let r = e.contentDOM, n = window.getComputedStyle(r), i = this.heightOracle, s = n.whiteSpace;
    this.defaultTextDirection = n.direction == "rtl" ? ye.RTL : ye.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), a = r.getBoundingClientRect(), l = o || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let c = 0, u = 0;
    if (a.width && a.height) {
      let { scaleX: w, scaleY: D } = sy(r, a);
      (this.scaleX != w || this.scaleY != D) && (this.scaleX = w, this.scaleY = D, c |= 8, o = l = !0);
    }
    let h = (parseInt(n.paddingTop) || 0) * this.scaleY, f = (parseInt(n.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != h || this.paddingBottom != f) && (this.paddingTop = h, this.paddingBottom = f, c |= 10), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 8);
    let d = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != d && (this.scrollAnchorHeight = -1, this.scrollTop = d), this.scrolledToBottom = ly(e.scrollDOM);
    let p = (this.printing ? W_ : j_)(r, this.paddingTop), m = p.top - this.pixelViewport.top, y = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let v = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (v != this.inView && (this.inView = v, v && (l = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let g = a.width;
    if ((this.contentDOMWidth != g || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 8), l) {
      let w = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(w) && (o = !0), o || i.lineWrapping && Math.abs(g - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: D, charWidth: x, textHeight: C } = e.docView.measureTextSize();
        o = D > 0 && i.refresh(s, D, x, C, g / x, w), o && (e.docView.minWidth = 0, c |= 8);
      }
      m > 0 && y > 0 ? u = Math.max(m, y) : m < 0 && y < 0 && (u = Math.min(m, y)), i.heightChanged = !1;
      for (let D of this.viewports) {
        let x = D.from == this.viewport.from ? w : e.docView.measureVisibleLineHeights(D);
        this.heightMap = (o ? et.empty().applyChanges(this.stateDeco, le.empty, this.heightOracle, [new Ft(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, o, new P_(D.from, x));
      }
      i.heightChanged && (c |= 2);
    }
    let b = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return b && (this.viewport = this.getViewport(u, this.scrollTarget)), this.updateForViewport(), (c & 2 || b) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, r) {
    let n = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: a } = this, l = new io(i.lineAt(o - n * 1e3, me.ByHeight, s, 0, 0).from, i.lineAt(a + (1 - n) * 1e3, me.ByHeight, s, 0, 0).to);
    if (r) {
      let { head: c } = r.range;
      if (c < l.from || c > l.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = i.lineAt(c, me.ByPos, s, 0, 0), f;
        r.y == "center" ? f = (h.top + h.bottom) / 2 - u / 2 : r.y == "start" || r.y == "nearest" && c < l.from ? f = h.top : f = h.bottom - u, l = new io(i.lineAt(f - 1e3 / 2, me.ByHeight, s, 0, 0).from, i.lineAt(f + u + 1e3 / 2, me.ByHeight, s, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, r) {
    let n = r.mapPos(e.from, -1), i = r.mapPos(e.to, 1);
    return new io(this.heightMap.lineAt(n, me.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, me.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: r }, n = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, me.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(r, me.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: a } = this;
    return (e == 0 || i <= o - Math.max(10, Math.min(
      -n,
      250
      /* VP.MaxCoverMargin */
    ))) && (r == this.state.doc.length || s >= a + Math.max(10, Math.min(
      n,
      250
      /* VP.MaxCoverMargin */
    ))) && i > o - 2 * 1e3 && s < a + 2 * 1e3;
  }
  mapLineGaps(e, r) {
    if (!e.length || r.empty)
      return e;
    let n = [];
    for (let i of e)
      r.touchesRange(i.from, i.to) || n.push(new Nl(r.mapPos(i.from), r.mapPos(i.to), i.size));
    return n;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, r) {
    let n = this.heightOracle.lineWrapping, i = n ? 1e4 : 2e3, s = i >> 1, o = i << 1;
    if (this.defaultTextDirection != ye.LTR && !n)
      return [];
    let a = [], l = (c, u, h, f) => {
      if (u - c < s)
        return;
      let d = this.state.selection.main, p = [d.from];
      d.empty || p.push(d.to);
      for (let y of p)
        if (y > c && y < u) {
          l(c, y - 10, h, f), l(y + 10, u, h, f);
          return;
        }
      let m = V_(e, (y) => y.from >= h.from && y.to <= h.to && Math.abs(y.from - c) < s && Math.abs(y.to - u) < s && !p.some((v) => y.from < v && y.to > v));
      if (!m) {
        if (u < h.to && r && n && r.visibleRanges.some((y) => y.from <= u && y.to >= u)) {
          let y = r.moveToLineBoundary(B.cursor(u), !1, !0).head;
          y > c && (u = y);
        }
        m = new Nl(c, u, this.gapSize(h, c, u, f));
      }
      a.push(m);
    };
    for (let c of this.viewportLines) {
      if (c.length < o)
        continue;
      let u = H_(c.from, c.to, this.stateDeco);
      if (u.total < o)
        continue;
      let h = this.scrollTarget ? this.scrollTarget.range.head : null, f, d;
      if (n) {
        let p = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, m, y;
        if (h != null) {
          let v = oo(u, h), g = ((this.visibleBottom - this.visibleTop) / 2 + p) / c.height;
          m = v - g, y = v + g;
        } else
          m = (this.visibleTop - c.top - p) / c.height, y = (this.visibleBottom - c.top + p) / c.height;
        f = so(u, m), d = so(u, y);
      } else {
        let p = u.total * this.heightOracle.charWidth, m = i * this.heightOracle.charWidth, y, v;
        if (h != null) {
          let g = oo(u, h), b = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + m) / p;
          y = g - b, v = g + b;
        } else
          y = (this.pixelViewport.left - m) / p, v = (this.pixelViewport.right + m) / p;
        f = so(u, y), d = so(u, v);
      }
      f > c.from && l(c.from, f, c, u), d < c.to && l(d, c.to, c, u);
    }
    return a;
  }
  gapSize(e, r, n, i) {
    let s = oo(i, n) - oo(i, r);
    return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    Nl.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = K.set(e.map((r) => r.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let r = [];
    ie.spans(e, this.viewport.from, this.viewport.to, {
      span(i, s) {
        r.push({ from: i, to: s });
      },
      point() {
      }
    }, 20);
    let n = r.length != this.visibleRanges.length || this.visibleRanges.some((i, s) => i.from != r[s].from || i.to != r[s].to);
    return this.visibleRanges = r, n ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((r) => r.from <= e && r.to >= e) || Wi(this.heightMap.lineAt(e, me.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return Wi(this.heightMap.lineAt(this.scaler.fromDOM(e), me.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let r = this.lineBlockAtHeight(e + 8);
    return r.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? r : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return Wi(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class io {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
function H_(t, e, r) {
  let n = [], i = t, s = 0;
  return ie.spans(r, t, e, {
    span() {
    },
    point(o, a) {
      o > i && (n.push({ from: i, to: o }), s += o - i), i = a;
    }
  }, 20), i < e && (n.push({ from: i, to: e }), s += e - i), { total: s, ranges: n };
}
function so({ total: t, ranges: e }, r) {
  if (r <= 0)
    return e[0].from;
  if (r >= 1)
    return e[e.length - 1].to;
  let n = Math.floor(t * r);
  for (let i = 0; ; i++) {
    let { from: s, to: o } = e[i], a = o - s;
    if (n <= a)
      return s + n;
    n -= a;
  }
}
function oo(t, e) {
  let r = 0;
  for (let { from: n, to: i } of t.ranges) {
    if (e <= i) {
      r += e - n;
      break;
    }
    r += i - n;
  }
  return r / t.total;
}
function V_(t, e) {
  for (let r of t)
    if (e(r))
      return r;
}
const zd = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1
};
class z_ {
  constructor(e, r, n) {
    let i = 0, s = 0, o = 0;
    this.viewports = n.map(({ from: a, to: l }) => {
      let c = r.lineAt(a, me.ByPos, e, 0, 0).top, u = r.lineAt(l, me.ByPos, e, 0, 0).bottom;
      return i += u - c, { from: a, to: l, top: c, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (r.height - i);
    for (let a of this.viewports)
      a.domTop = o + (a.top - s) * this.scale, o = a.domBottom = a.domTop + (a.bottom - a.top), s = a.bottom;
  }
  toDOM(e) {
    for (let r = 0, n = 0, i = 0; ; r++) {
      let s = r < this.viewports.length ? this.viewports[r] : null;
      if (!s || e < s.top)
        return i + (e - n) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      n = s.bottom, i = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let r = 0, n = 0, i = 0; ; r++) {
      let s = r < this.viewports.length ? this.viewports[r] : null;
      if (!s || e < s.domTop)
        return n + (e - i) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      n = s.bottom, i = s.domBottom;
    }
  }
}
function Wi(t, e) {
  if (e.scale == 1)
    return t;
  let r = e.toDOM(t.top), n = e.toDOM(t.bottom);
  return new Zt(t.from, t.length, r, n - r, Array.isArray(t._content) ? t._content.map((i) => Wi(i, e)) : t._content);
}
const ao = /* @__PURE__ */ z.define({ combine: (t) => t.join(" ") }), Ju = /* @__PURE__ */ z.define({ combine: (t) => t.indexOf(!0) > -1 }), Xu = /* @__PURE__ */ Kr.newName(), Yy = /* @__PURE__ */ Kr.newName(), Jy = /* @__PURE__ */ Kr.newName(), Xy = { "&light": "." + Yy, "&dark": "." + Jy };
function Qu(t, e, r) {
  return new Kr(e, {
    finish(n) {
      return /&/.test(n) ? n.replace(/&\w*/, (i) => {
        if (i == "&")
          return t;
        if (!r || !r[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return r[i];
      }) : t + " " + n;
    }
  });
}
const U_ = /* @__PURE__ */ Qu("." + Xu, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, Xy), qi = "￿";
class G_ {
  constructor(e, r) {
    this.points = e, this.text = "", this.lineSeparator = r.facet(ee.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += qi;
  }
  readRange(e, r) {
    if (!e)
      return this;
    let n = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(n, i);
      let s = this.text.length;
      this.readNode(i);
      let o = i.nextSibling;
      if (o == r)
        break;
      let a = ge.get(i), l = ge.get(o);
      (a && l ? a.breakAfter : (a ? a.breakAfter : Ud(i)) || Ud(o) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > s) && this.lineBreak(), i = o;
    }
    return this.findPointBefore(n, r), this;
  }
  readTextNode(e) {
    let r = e.nodeValue;
    for (let n of this.points)
      n.node == e && (n.pos = this.text.length + Math.min(n.offset, r.length));
    for (let n = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, a;
      if (this.lineSeparator ? (s = r.indexOf(this.lineSeparator, n), o = this.lineSeparator.length) : (a = i.exec(r)) && (s = a.index, o = a[0].length), this.append(r.slice(n, s < 0 ? r.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= o - 1);
      n = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let r = ge.get(e), n = r && r.overrideDOMText;
    if (n != null) {
      this.findPointInside(e, n.length);
      for (let i = n.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, r) {
    for (let n of this.points)
      n.node == e && e.childNodes[n.offset] == r && (n.pos = this.text.length);
  }
  findPointInside(e, r) {
    for (let n of this.points)
      (e.nodeType == 3 ? n.node == e : e.contains(n.node)) && (n.pos = this.text.length + (K_(e, n.node, n.offset) ? r : 0));
  }
}
function K_(t, e, r) {
  for (; ; ) {
    if (!e || r < pr(e))
      return !1;
    if (e == t)
      return !0;
    r = cs(e) + 1, e = e.parentNode;
  }
}
function Ud(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
class Gd {
  constructor(e, r) {
    this.node = e, this.offset = r, this.pos = -1;
  }
}
class Y_ {
  constructor(e, r, n, i) {
    this.typeOver = i, this.bounds = null, this.text = "";
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && r > -1)
      this.newSel = null;
    else if (r > -1 && (this.bounds = e.docView.domBoundsAround(r, n, 0))) {
      let a = s || o ? [] : Q_(e), l = new G_(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = Z_(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = s && s.node == a.focusNode && s.offset == a.focusOffset || !Nu(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = o && o.node == a.anchorNode && o.offset == a.anchorOffset || !Nu(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), u = e.viewport;
      if ((V.ios || V.chrome) && e.state.selection.main.empty && l != c && (u.from > 0 || u.to < e.state.doc.length)) {
        let h = Math.min(l, c), f = Math.max(l, c), d = u.from - h, p = u.to - f;
        (d == 0 || d == 1 || h == 0) && (p == 0 || p == -1 || f == e.state.doc.length) && (l = 0, c = e.state.doc.length);
      }
      this.newSel = B.single(c, l);
    }
  }
}
function Qy(t, e) {
  let r, { newSel: n } = e, i = t.state.selection.main, s = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: a } = e.bounds, l = i.from, c = null;
    (s === 8 || V.android && e.text.length < a - o) && (l = i.to, c = "end");
    let u = X_(t.state.doc.sliceString(o, a, qi), e.text, l - o, c);
    u && (V.chrome && s == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == qi + qi && u.toB--, r = {
      from: o + u.from,
      to: o + u.toA,
      insert: le.of(e.text.slice(u.from, u.toB).split(qi))
    });
  } else
    n && (!t.hasFocus && t.state.facet(Qa) || n.main.eq(i)) && (n = null);
  if (!r && !n)
    return !1;
  if (!r && e.typeOver && !i.empty && n && n.main.empty ? r = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, i.to) } : r && r.from >= i.from && r.to <= i.to && (r.from != i.from || r.to != i.to) && i.to - i.from - (r.to - r.from) <= 4 ? r = {
    from: i.from,
    to: i.to,
    insert: t.state.doc.slice(i.from, r.from).append(r.insert).append(t.state.doc.slice(r.to, i.to))
  } : (V.mac || V.android) && r && r.from == r.to && r.from == i.head - 1 && /^\. ?$/.test(r.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (n && r.insert.length == 2 && (n = B.single(n.main.anchor - 1, n.main.head - 1)), r = { from: i.from, to: i.to, insert: le.of([" "]) }) : V.chrome && r && r.from == r.to && r.from == i.head && r.insert.toString() == `
 ` && t.lineWrapping && (n && (n = B.single(n.main.anchor - 1, n.main.head - 1)), r = { from: i.from, to: i.to, insert: le.of([" "]) }), r) {
    if (V.ios && t.inputState.flushIOSKey() || V.android && (r.from == i.from && r.to == i.to && r.insert.length == 1 && r.insert.lines == 2 && ti(t.contentDOM, "Enter", 13) || (r.from == i.from - 1 && r.to == i.to && r.insert.length == 0 || s == 8 && r.insert.length < r.to - r.from && r.to > i.head) && ti(t.contentDOM, "Backspace", 8) || r.from == i.from && r.to == i.to + 1 && r.insert.length == 0 && ti(t.contentDOM, "Delete", 46)))
      return !0;
    let o = r.insert.toString();
    t.inputState.composing >= 0 && t.inputState.composing++;
    let a, l = () => a || (a = J_(t, r, n));
    return t.state.facet(Ay).some((c) => c(t, r.from, r.to, o, l)) || t.dispatch(l()), !0;
  } else if (n && !n.main.eq(i)) {
    let o = !1, a = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (o = !0), a = t.inputState.lastSelectionOrigin), t.dispatch({ selection: n, scrollIntoView: o, userEvent: a }), !0;
  } else
    return !1;
}
function J_(t, e, r) {
  let n, i = t.state, s = i.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!r || r.main.empty && r.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let a = s.from < e.from ? i.sliceDoc(s.from, e.from) : "", l = s.to > e.to ? i.sliceDoc(e.to, s.to) : "";
    n = i.replaceSelection(t.state.toText(a + e.insert.sliceString(0, void 0, t.state.lineBreak) + l));
  } else {
    let a = i.changes(e), l = r && r.main.to <= a.newLength ? r.main : void 0;
    if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let c = t.state.sliceDoc(e.from, e.to), u, h = r && Ny(t, r.main.head);
      if (h) {
        let p = e.insert.length - (e.to - e.from);
        u = { from: h.from, to: h.to - p };
      } else
        u = t.state.doc.lineAt(s.head);
      let f = s.to - e.to, d = s.to - s.from;
      n = i.changeByRange((p) => {
        if (p.from == s.from && p.to == s.to)
          return { changes: a, range: l || p.map(a) };
        let m = p.to - f, y = m - c.length;
        if (p.to - p.from != d || t.state.sliceDoc(y, m) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        p.to >= u.from && p.from <= u.to)
          return { range: p };
        let v = i.changes({ from: y, to: m, insert: e.insert }), g = p.to - s.to;
        return {
          changes: v,
          range: l ? B.range(Math.max(0, l.anchor + g), Math.max(0, l.head + g)) : p.map(v)
        };
      });
    } else
      n = {
        changes: a,
        selection: l && i.selection.replaceRange(l)
      };
  }
  let o = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, o += ".compose", t.inputState.compositionFirstChange && (o += ".start", t.inputState.compositionFirstChange = !1)), i.update(n, { userEvent: o, scrollIntoView: !0 });
}
function X_(t, e, r, n) {
  let i = Math.min(t.length, e.length), s = 0;
  for (; s < i && t.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == i && t.length == e.length)
    return null;
  let o = t.length, a = e.length;
  for (; o > 0 && a > 0 && t.charCodeAt(o - 1) == e.charCodeAt(a - 1); )
    o--, a--;
  if (n == "end") {
    let l = Math.max(0, s - Math.min(o, a));
    r -= o + l - s;
  }
  if (o < s && t.length < e.length) {
    let l = r <= s && r >= o ? s - r : 0;
    s -= l, a = s + (a - o), o = s;
  } else if (a < s) {
    let l = r <= s && r >= a ? s - r : 0;
    s -= l, o = s + (o - a), a = s;
  }
  return { from: s, toA: o, toB: a };
}
function Q_(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: r, anchorOffset: n, focusNode: i, focusOffset: s } = t.observer.selectionRange;
  return r && (e.push(new Gd(r, n)), (i != r || s != n) && e.push(new Gd(i, s))), e;
}
function Z_(t, e) {
  if (t.length == 0)
    return null;
  let r = t[0].pos, n = t.length == 2 ? t[1].pos : r;
  return r > -1 && n > -1 ? B.single(r + e, n + e) : null;
}
const eB = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Rl = V.ie && V.ie_version <= 11;
class tB {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new IT(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((r) => {
      for (let n of r)
        this.queue.push(n);
      (V.ie && V.ie_version <= 11 || V.ios && e.composing) && r.some((n) => n.type == "childList" && n.removedNodes.length || n.type == "characterData" && n.oldValue.length > n.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Rl && (this.onCharData = (r) => {
      this.queue.push({
        target: r.target,
        type: "characterData",
        oldValue: r.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var r;
      ((r = this.view.docView) === null || r === void 0 ? void 0 : r.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((r) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), r.length > 0 && r[r.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((r) => {
      r.length > 0 && r[r.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((r, n) => r != e[n]))) {
      this.gapIntersection.disconnect();
      for (let r of e)
        this.gapIntersection.observe(r);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let r = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: n } = this, i = this.selectionRange;
    if (n.state.facet(Qa) ? n.root.activeElement != this.dom : !Bo(n.dom, i))
      return;
    let s = i.anchorNode && n.docView.nearest(i.anchorNode);
    if (s && s.ignoreEvent(e)) {
      r || (this.selectionChanged = !1);
      return;
    }
    (V.ie && V.ie_version <= 11 || V.android && V.chrome) && !n.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && Zi(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, r = V.safari && e.root.nodeType == 11 && LT(this.dom.ownerDocument) == this.dom && rB(this.view) || Jo(e.root);
    if (!r || this.selectionRange.eq(r))
      return !1;
    let n = Bo(this.dom, r);
    return n && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && jT(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), n && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, r) {
    this.selectionRange.set(e.node, e.offset, r.node, r.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, r = null;
    for (let n = this.dom; n; )
      if (n.nodeType == 1)
        !r && e < this.scrollTargets.length && this.scrollTargets[e] == n ? e++ : r || (r = this.scrollTargets.slice(0, e)), r && r.push(n), n = n.assignedSlot || n.parentNode;
      else if (n.nodeType == 11)
        n = n.host;
      else
        break;
    if (e < this.scrollTargets.length && !r && (r = this.scrollTargets.slice(0, e)), r) {
      for (let n of this.scrollTargets)
        n.removeEventListener("scroll", this.onScroll);
      for (let n of this.scrollTargets = r)
        n.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, eB), Rl && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Rl && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, r) {
    var n;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && ti(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: r,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((n = this.delayedAndroidKey) === null || n === void 0) && n.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let r = -1, n = -1, i = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o && (o.typeOver && (i = !0), r == -1 ? { from: r, to: n } = o : (r = Math.min(o.from, r), n = Math.max(o.to, n)));
    }
    return { from: r, to: n, typeOver: i };
  }
  readChange() {
    let { from: e, to: r, typeOver: n } = this.processRecords(), i = this.selectionChanged && Bo(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new Y_(this.view, e, r, n);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let r = this.readChange();
    if (!r)
      return this.view.requestMeasure(), !1;
    let n = this.view.state, i = Qy(this.view, r);
    return this.view.state == n && this.view.update([]), i;
  }
  readMutation(e) {
    let r = this.view.docView.nearest(e.target);
    if (!r || r.ignoreMutation(e))
      return null;
    if (r.markDirty(e.type == "attributes"), e.type == "attributes" && (r.flags |= 4), e.type == "childList") {
      let n = Kd(r, e.previousSibling || e.target.previousSibling, -1), i = Kd(r, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: n ? r.posAfter(n) : r.posAtStart,
        to: i ? r.posBefore(i) : r.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, r, n;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (r = this.gapIntersection) === null || r === void 0 || r.disconnect(), (n = this.resizeScroll) === null || n === void 0 || n.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function Kd(t, e, r) {
  for (; e; ) {
    let n = ge.get(e);
    if (n && n.parent == t)
      return n;
    let i = e.parentNode;
    e = i != t.dom ? i : r > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function rB(t) {
  let e = null;
  function r(l) {
    l.preventDefault(), l.stopImmediatePropagation(), e = l.getTargetRanges()[0];
  }
  if (t.contentDOM.addEventListener("beforeinput", r, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", r, !0), !e)
    return null;
  let n = e.startContainer, i = e.startOffset, s = e.endContainer, o = e.endOffset, a = t.docView.domAtPos(t.state.selection.main.anchor);
  return Zi(a.node, a.offset, s, o) && ([n, i, s, o] = [s, o, n, i]), { anchorNode: n, anchorOffset: i, focusNode: s, focusOffset: o };
}
class H {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((n) => n.forEach((i) => r(i, this))) || ((n) => this.update(n)), this.dispatch = this.dispatch.bind(this), this._root = e.root || $T(e.parent) || document, this.viewState = new Vd(e.state || ee.create(e)), e.scrollTo && e.scrollTo.is(to) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet($i).map((n) => new Ml(n));
    for (let n of this.plugins)
      n.update(this);
    this.observer = new tB(this), this.inputState = new y_(this), this.inputState.ensureHandlers(this.plugins), this.docView = new Ed(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...e) {
    let r = e.length == 1 && e[0] instanceof Te ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(r, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let r = !1, n = !1, i, s = this.state;
    for (let f of e) {
      if (f.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, a = 0, l = null;
    e.some((f) => f.annotation(zy)) ? (this.inputState.notifiedFocused = o, a = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, l = Uy(s, o), l || (a = 1));
    let c = this.observer.delayedAndroidKey, u = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (u = null)) : this.observer.clear(), s.facet(ee.phrases) != this.state.facet(ee.phrases))
      return this.setState(s);
    i = Xo.create(this, s, e), i.flags |= a;
    let h = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if (h && (h = h.map(f.changes)), f.scrollIntoView) {
          let { main: d } = f.state.selection;
          h = new ri(d.empty ? d : B.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of f.effects)
          d.is(to) && (h = d.value.clip(this.state));
      }
      this.viewState.update(i, h), this.bidiCache = Qo.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), r = this.docView.update(i), this.state.facet(ji) != this.styleModules && this.mountStyles(), n = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(r, e.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(ao) != i.state.facet(ao) && (this.viewState.mustMeasureContent = !0), (r || n || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !i.empty)
      for (let f of this.state.facet(Uu))
        try {
          f(i);
        } catch (d) {
          At(this.state, d, "update listener");
        }
    (l || u) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), u && !Qy(this, u) && c.force && ti(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let r = this.hasFocus;
    try {
      for (let n of this.plugins)
        n.destroy(this);
      this.viewState = new Vd(e), this.plugins = e.facet($i).map((n) => new Ml(n)), this.pluginMap.clear();
      for (let n of this.plugins)
        n.update(this);
      this.docView.destroy(), this.docView = new Ed(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    r && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let r = e.startState.facet($i), n = e.state.facet($i);
    if (r != n) {
      let i = [];
      for (let s of n) {
        let o = r.indexOf(s);
        if (o < 0)
          i.push(new Ml(s));
        else {
          let a = this.plugins[o];
          a.mustUpdate = e, i.push(a);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    r != n && this.inputState.ensureHandlers(this.plugins);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let r = null, n = this.scrollDOM, i = n.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (o < 0)
          if (ly(n))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let d = this.viewState.scrollAnchorAt(i);
            s = d.from, o = d.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let u = c.map((d) => {
          try {
            return d.read(this);
          } catch (p) {
            return At(this.state, p), Yd;
          }
        }), h = Xo.create(this, this.state, []), f = !1;
        h.flags |= l, r ? r.flags |= l : r = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), f = this.docView.update(h));
        for (let d = 0; d < c.length; d++)
          if (u[d] != Yd)
            try {
              let p = c[d];
              p.write && p.write(u[d], this);
            } catch (p) {
              At(this.state, p);
            }
        if (f && this.docView.updateSelection(!0), !h.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let p = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (p > 1 || p < -1) {
                i = i + p, n.scrollTop = i / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (r && !r.empty)
      for (let a of this.state.facet(Uu))
        a(r);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Xu + " " + (this.state.facet(Ju) ? Jy : Yy) + " " + this.state.facet(ao);
  }
  updateAttrs() {
    let e = Jd(this, By, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), r = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(Qa) ? "true" : "false",
      class: "cm-content",
      style: `${V.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (r["aria-readonly"] = "true"), Jd(this, _h, r);
    let n = this.observer.ignore(() => {
      let i = Wu(this.contentDOM, this.contentAttrs, r), s = Wu(this.dom, this.editorAttrs, e);
      return i || s;
    });
    return this.editorAttrs = e, this.contentAttrs = r, n;
  }
  showAnnouncements(e) {
    let r = !0;
    for (let n of e)
      for (let i of n.effects)
        if (i.is(H.announce)) {
          r && (this.announceDOM.textContent = ""), r = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(ji);
    let e = this.state.facet(H.cspNonce);
    Kr.mount(this.root, this.styleModules.concat(U_).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let r = 0; r < this.measureRequests.length; r++)
          if (this.measureRequests[r].key === e.key) {
            this.measureRequests[r] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let r = this.pluginMap.get(e);
    return (r === void 0 || r && r.spec != e) && this.pluginMap.set(e, r = this.plugins.find((n) => n.spec == e) || null), r && r.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, r, n) {
    return Pl(this, e, Od(this, e, r, n));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, r) {
    return Pl(this, e, Od(this, e, r, (n) => m_(this, e.head, n)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, r) {
    let n = this.bidiSpans(e), i = this.textDirectionAt(e.from), s = n[r ? n.length - 1 : 0];
    return B.cursor(s.side(r, i) + e.from, s.forward(!r, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, r, n = !0) {
    return p_(this, e, r, n);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, r, n) {
    return Pl(this, e, g_(this, e, r, n));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, r = 0) {
    return this.docView.posFromDOM(e, r);
  }
  posAtCoords(e, r = !0) {
    return this.readMeasured(), Iy(this, e, r);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, r = 1) {
    this.readMeasured();
    let n = this.docView.coordsAt(e, r);
    if (!n || n.left == n.right)
      return n;
    let i = this.state.doc.lineAt(e), s = this.bidiSpans(i), o = s[Ir.find(s, e - i.from, -1, r)];
    return Ja(n, o.dir == ye.LTR == r > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(Ty) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > nB)
      return wy(e.length);
    let r = this.textDirectionAt(e.from), n;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == r && (s.fresh || Dy(s.isolates, n = Sd(this, e))))
        return s.order;
    n || (n = Sd(this, e));
    let i = QT(e.text, r, n);
    return this.bidiCache.push(new Qo(e.from, e.to, r, n, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || V.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      oy(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, r = {}) {
    return to.of(new ri(typeof e == "number" ? B.cursor(e) : e, r.y, r.x, r.yMargin, r.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: r } = this.scrollDOM, n = this.viewState.scrollAnchorAt(e);
    return to.of(new ri(B.cursor(n.from), "start", "start", n.top - e, r, !0));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Ee.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return Ee.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, r) {
    let n = Kr.newName(), i = [ao.of(n), ji.of(Qu(`.${n}`, e))];
    return r && r.dark && i.push(Ju.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return Di.lowest(ji.of(Qu("." + Xu, e, Xy)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var r;
    let n = e.querySelector(".cm-content"), i = n && ge.get(n) || ge.get(e);
    return ((r = i == null ? void 0 : i.rootView) === null || r === void 0 ? void 0 : r.view) || null;
  }
}
H.styleModule = ji;
H.inputHandler = Ay;
H.focusChangeEffect = Fy;
H.perLineTextDirection = Ty;
H.exceptionSink = Ey;
H.updateListener = Uu;
H.editable = Qa;
H.mouseSelectionStyle = Sy;
H.dragMovesSelection = ky;
H.clickAddsSelectionRange = Cy;
H.decorations = hs;
H.outerDecorations = Oy;
H.atomicRanges = Bh;
H.bidiIsolatedRanges = My;
H.scrollMargins = Ly;
H.darkTheme = Ju;
H.cspNonce = /* @__PURE__ */ z.define({ combine: (t) => t.length ? t[0] : "" });
H.contentAttributes = _h;
H.editorAttributes = By;
H.lineWrapping = /* @__PURE__ */ H.contentAttributes.of({ class: "cm-lineWrapping" });
H.announce = /* @__PURE__ */ J.define();
const nB = 4096, Yd = {};
class Qo {
  constructor(e, r, n, i, s, o) {
    this.from = e, this.to = r, this.dir = n, this.isolates = i, this.fresh = s, this.order = o;
  }
  static update(e, r) {
    if (r.empty && !e.some((s) => s.fresh))
      return e;
    let n = [], i = e.length ? e[e.length - 1].dir : ye.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == i && !r.touchesRange(o.from, o.to) && n.push(new Qo(r.mapPos(o.from, 1), r.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return n;
  }
}
function Jd(t, e, r) {
  for (let n = t.state.facet(e), i = n.length - 1; i >= 0; i--) {
    let s = n[i], o = typeof s == "function" ? s(t) : s;
    o && ju(o, r);
  }
  return r;
}
const iB = V.mac ? "mac" : V.windows ? "win" : V.linux ? "linux" : "key";
function sB(t, e) {
  const r = t.split(/-(?!$)/);
  let n = r[r.length - 1];
  n == "Space" && (n = " ");
  let i, s, o, a;
  for (let l = 0; l < r.length - 1; ++l) {
    const c = r[l];
    if (/^(cmd|meta|m)$/i.test(c))
      a = !0;
    else if (/^a(lt)?$/i.test(c))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? a = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return i && (n = "Alt-" + n), s && (n = "Ctrl-" + n), a && (n = "Meta-" + n), o && (n = "Shift-" + n), n;
}
function lo(t, e, r) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), r !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const oB = /* @__PURE__ */ Di.default(/* @__PURE__ */ H.domEventHandlers({
  keydown(t, e) {
    return e1(Zy(e.state), t, e, "editor");
  }
})), Za = /* @__PURE__ */ z.define({ enables: oB }), Xd = /* @__PURE__ */ new WeakMap();
function Zy(t) {
  let e = t.facet(Za), r = Xd.get(e);
  return r || Xd.set(e, r = uB(e.reduce((n, i) => n.concat(i), []))), r;
}
function aB(t, e, r) {
  return e1(Zy(t.state), e, t, r);
}
let Pr = null;
const lB = 4e3;
function uB(t, e = iB) {
  let r = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), i = (o, a) => {
    let l = n[o];
    if (l == null)
      n[o] = a;
    else if (l != a)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, a, l, c, u) => {
    var h, f;
    let d = r[o] || (r[o] = /* @__PURE__ */ Object.create(null)), p = a.split(/ (?!$)/).map((v) => sB(v, e));
    for (let v = 1; v < p.length; v++) {
      let g = p.slice(0, v).join(" ");
      i(g, !0), d[g] || (d[g] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(b) => {
          let w = Pr = { view: b, prefix: g, scope: o };
          return setTimeout(() => {
            Pr == w && (Pr = null);
          }, lB), !0;
        }]
      });
    }
    let m = p.join(" ");
    i(m, !1);
    let y = d[m] || (d[m] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (h = d._any) === null || h === void 0 ? void 0 : h.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    l && y.run.push(l), c && (y.preventDefault = !0), u && (y.stopPropagation = !0);
  };
  for (let o of t) {
    let a = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of a) {
        let u = r[c] || (r[c] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let h in u)
          u[h].run.push(o.any);
      }
    let l = o[e] || o.key;
    if (l)
      for (let c of a)
        s(c, l, o.run, o.preventDefault, o.stopPropagation), o.shift && s(c, "Shift-" + l, o.shift, o.preventDefault, o.stopPropagation);
  }
  return r;
}
function e1(t, e, r, n) {
  let i = MT(e), s = Me(i, 0), o = St(s) == i.length && i != " ", a = "", l = !1, c = !1, u = !1;
  Pr && Pr.view == r && Pr.scope == n && (a = Pr.prefix + " ", jy.indexOf(e.keyCode) < 0 && (c = !0, Pr = null));
  let h = /* @__PURE__ */ new Set(), f = (y) => {
    if (y) {
      for (let v of y.run)
        if (!h.has(v) && (h.add(v), v(r, e)))
          return y.stopPropagation && (u = !0), !0;
      y.preventDefault && (y.stopPropagation && (u = !0), c = !0);
    }
    return !1;
  }, d = t[n], p, m;
  return d && (f(d[a + lo(i, e, !o)]) ? l = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(V.windows && e.ctrlKey && e.altKey) && (p = Yr[e.keyCode]) && p != i ? (f(d[a + lo(p, e, !0)]) || e.shiftKey && (m = us[e.keyCode]) != i && m != p && f(d[a + lo(m, e, !1)])) && (l = !0) : o && e.shiftKey && f(d[a + lo(i, e, !0)]) && (l = !0), !l && f(d._any) && (l = !0)), c && (l = !0), l && u && e.stopPropagation(), l;
}
class Ns {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, r, n, i, s) {
    this.className = e, this.left = r, this.top = n, this.width = i, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, r) {
    return r.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, r, n) {
    if (n.empty) {
      let i = e.coordsAtPos(n.head, n.assoc || 1);
      if (!i)
        return [];
      let s = t1(e);
      return [new Ns(r, i.left - s.left, i.top - s.top, null, i.bottom - i.top)];
    } else
      return cB(e, r, n);
  }
}
function t1(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == ye.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function Qd(t, e, r) {
  let n = B.cursor(e);
  return {
    from: Math.max(r.from, t.moveToLineBoundary(n, !1, !0).from),
    to: Math.min(r.to, t.moveToLineBoundary(n, !0, !0).from),
    type: Ze.Text
  };
}
function cB(t, e, r) {
  if (r.to <= t.viewport.from || r.from >= t.viewport.to)
    return [];
  let n = Math.max(r.from, t.viewport.from), i = Math.min(r.to, t.viewport.to), s = t.textDirection == ye.LTR, o = t.contentDOM, a = o.getBoundingClientRect(), l = t1(t), c = o.querySelector(".cm-line"), u = c && window.getComputedStyle(c), h = a.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), f = a.right - (u ? parseInt(u.paddingRight) : 0), d = Ku(t, n), p = Ku(t, i), m = d.type == Ze.Text ? d : null, y = p.type == Ze.Text ? p : null;
  if (m && (t.lineWrapping || d.widgetLineBreaks) && (m = Qd(t, n, m)), y && (t.lineWrapping || p.widgetLineBreaks) && (y = Qd(t, i, y)), m && y && m.from == y.from)
    return g(b(r.from, r.to, m));
  {
    let D = m ? b(r.from, null, m) : w(d, !1), x = y ? b(null, r.to, y) : w(p, !0), C = [];
    return (m || d).to < (y || p).from - (m && y ? 1 : 0) || d.widgetLineBreaks > 1 && D.bottom + t.defaultLineHeight / 2 < x.top ? C.push(v(h, D.bottom, f, x.top)) : D.bottom < x.top && t.elementAtHeight((D.bottom + x.top) / 2).type == Ze.Text && (D.bottom = x.top = (D.bottom + x.top) / 2), g(D).concat(C).concat(g(x));
  }
  function v(D, x, C, k) {
    return new Ns(
      e,
      D - l.left,
      x - l.top - 0.01,
      C - D,
      k - x + 0.01
      /* C.Epsilon */
    );
  }
  function g({ top: D, bottom: x, horizontal: C }) {
    let k = [];
    for (let S = 0; S < C.length; S += 2)
      k.push(v(C[S], D, C[S + 1], x));
    return k;
  }
  function b(D, x, C) {
    let k = 1e9, S = -1e9, A = [];
    function _(L, I, P, G, re) {
      let oe = t.coordsAtPos(L, L == C.to ? -2 : 2), ue = t.coordsAtPos(P, P == C.from ? 2 : -2);
      !oe || !ue || (k = Math.min(oe.top, ue.top, k), S = Math.max(oe.bottom, ue.bottom, S), re == ye.LTR ? A.push(s && I ? h : oe.left, s && G ? f : ue.right) : A.push(!s && G ? h : ue.left, !s && I ? f : oe.right));
    }
    let N = D ?? C.from, $ = x ?? C.to;
    for (let L of t.visibleRanges)
      if (L.to > N && L.from < $)
        for (let I = Math.max(L.from, N), P = Math.min(L.to, $); ; ) {
          let G = t.state.doc.lineAt(I);
          for (let re of t.bidiSpans(G)) {
            let oe = re.from + G.from, ue = re.to + G.from;
            if (oe >= P)
              break;
            ue > I && _(Math.max(oe, I), D == null && oe <= N, Math.min(ue, P), x == null && ue >= $, re.dir);
          }
          if (I = G.to + 1, I >= P)
            break;
        }
    return A.length == 0 && _(N, D == null, $, x == null, t.textDirection), { top: k, bottom: S, horizontal: A };
  }
  function w(D, x) {
    let C = a.top + (x ? D.top : D.bottom);
    return { top: C, bottom: C, horizontal: [] };
  }
}
function hB(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class fB {
  constructor(e, r) {
    this.view = e, this.layer = r, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), r.above && this.dom.classList.add("cm-layer-above"), r.class && this.dom.classList.add(r.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), r.mount && r.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Lo) != e.state.facet(Lo) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  setOrder(e) {
    let r = 0, n = e.facet(Lo);
    for (; r < n.length && n[r] != this.layer; )
      r++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - r);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: r } = this.view;
    (e != this.scaleX || r != this.scaleY) && (this.scaleX = e, this.scaleY = r, this.dom.style.transform = `scale(${1 / e}, ${1 / r})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((r, n) => !hB(r, this.drawn[n]))) {
      let r = this.dom.firstChild, n = 0;
      for (let i of e)
        i.update && r && i.constructor && this.drawn[n].constructor && i.update(r, this.drawn[n]) ? (r = r.nextSibling, n++) : this.dom.insertBefore(i.draw(), r);
      for (; r; ) {
        let i = r.nextSibling;
        r.remove(), r = i;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Lo = /* @__PURE__ */ z.define();
function r1(t) {
  return [
    Ee.define((e) => new fB(e, t)),
    Lo.of(t)
  ];
}
const n1 = !V.ios, fs = /* @__PURE__ */ z.define({
  combine(t) {
    return ur(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, r) => Math.min(e, r),
      drawRangeCursor: (e, r) => e || r
    });
  }
});
function dB(t = {}) {
  return [
    fs.of(t),
    pB,
    mB,
    gB,
    _y.of(!0)
  ];
}
function i1(t) {
  return t.startState.facet(fs) != t.state.facet(fs);
}
const pB = /* @__PURE__ */ r1({
  above: !0,
  markers(t) {
    let { state: e } = t, r = e.facet(fs), n = [];
    for (let i of e.selection.ranges) {
      let s = i == e.selection.main;
      if (i.empty ? !s || n1 : r.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = i.empty ? i : B.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let l of Ns.forRange(t, o, a))
          n.push(l);
      }
    }
    return n;
  },
  update(t, e) {
    t.transactions.some((n) => n.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let r = i1(t);
    return r && Zd(t.state, e), t.docChanged || t.selectionSet || r;
  },
  mount(t, e) {
    Zd(e.state, t);
  },
  class: "cm-cursorLayer"
});
function Zd(t, e) {
  e.style.animationDuration = t.facet(fs).cursorBlinkRate + "ms";
}
const mB = /* @__PURE__ */ r1({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : Ns.forRange(t, "cm-selectionBackground", e)).reduce((e, r) => e.concat(r));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || i1(t);
  },
  class: "cm-selectionLayer"
}), Zu = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
n1 && (Zu[".cm-line"].caretColor = "transparent !important", Zu[".cm-content"] = { caretColor: "transparent !important" });
const gB = /* @__PURE__ */ Di.highest(/* @__PURE__ */ H.theme(Zu)), s1 = /* @__PURE__ */ J.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), Hi = /* @__PURE__ */ We.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((r, n) => n.is(s1) ? n.value : r, t);
  }
}), yB = /* @__PURE__ */ Ee.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let r = t.state.field(Hi);
    r == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(Hi) != r || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(Hi), r = e != null && t.coordsAtPos(e);
    if (!r)
      return null;
    let n = t.scrollDOM.getBoundingClientRect();
    return {
      left: r.left - n.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: r.top - n.top + t.scrollDOM.scrollTop * t.scaleY,
      height: r.bottom - r.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: r } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / r + "px", this.cursor.style.height = t.height / r + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(Hi) != t && this.view.dispatch({ effects: s1.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function vB() {
  return [Hi, yB];
}
function ep(t, e, r, n, i) {
  e.lastIndex = 0;
  for (let s = t.iterRange(r, n), o = r, a; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; a = e.exec(s.value); )
        i(o + a.index, a);
}
function bB(t, e) {
  let r = t.visibleRanges;
  if (r.length == 1 && r[0].from == t.viewport.from && r[0].to == t.viewport.to)
    return r;
  let n = [];
  for (let { from: i, to: s } of r)
    i = Math.max(t.state.doc.lineAt(i).from, i - e), s = Math.min(t.state.doc.lineAt(s).to, s + e), n.length && n[n.length - 1].to >= i ? n[n.length - 1].to = s : n.push({ from: i, to: s });
  return n;
}
class DB {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: r, decoration: n, decorate: i, boundary: s, maxLength: o = 1e3 } = e;
    if (!r.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = r, i)
      this.addMatch = (a, l, c, u) => i(u, c, c + a[0].length, a, l);
    else if (typeof n == "function")
      this.addMatch = (a, l, c, u) => {
        let h = n(a, l, c);
        h && u(c, c + a[0].length, h);
      };
    else if (n)
      this.addMatch = (a, l, c, u) => u(c, c + a[0].length, n);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let r = new Gr(), n = r.add.bind(r);
    for (let { from: i, to: s } of bB(e, this.maxLength))
      ep(e.state.doc, this.regexp, i, s, (o, a) => this.addMatch(a, e, o, n));
    return r.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, r) {
    let n = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((s, o, a, l) => {
      l > e.view.viewport.from && a < e.view.viewport.to && (n = Math.min(a, n), i = Math.max(l, i));
    }), e.viewportChanged || i - n > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, r.map(e.changes), n, i) : r;
  }
  updateRange(e, r, n, i) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, n), a = Math.min(s.to, i);
      if (a > o) {
        let l = e.state.doc.lineAt(o), c = l.to < a ? e.state.doc.lineAt(a) : l, u = Math.max(s.from, l.from), h = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; o > l.from; o--)
            if (this.boundary.test(l.text[o - 1 - l.from])) {
              u = o;
              break;
            }
          for (; a < c.to; a++)
            if (this.boundary.test(c.text[a - c.from])) {
              h = a;
              break;
            }
        }
        let f = [], d, p = (m, y, v) => f.push(v.range(m, y));
        if (l == c)
          for (this.regexp.lastIndex = u - l.from; (d = this.regexp.exec(l.text)) && d.index < h - l.from; )
            this.addMatch(d, e, d.index + l.from, p);
        else
          ep(e.state.doc, this.regexp, u, h, (m, y) => this.addMatch(y, e, m, p));
        r = r.update({ filterFrom: u, filterTo: h, filter: (m, y) => m < u || y > h, add: f });
      }
    }
    return r;
  }
}
const ec = /x/.unicode != null ? "gu" : "g", wB = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, ec), xB = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let Il = null;
function CB() {
  var t;
  if (Il == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    Il = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return Il || !1;
}
const Po = /* @__PURE__ */ z.define({
  combine(t) {
    let e = ur(t, {
      render: null,
      specialChars: wB,
      addSpecialChars: null
    });
    return (e.replaceTabs = !CB()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, ec)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, ec)), e;
  }
});
function kB(t = {}) {
  return [Po.of(t), SB()];
}
let tp = null;
function SB() {
  return tp || (tp = Ee.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = K.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(Po)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new DB({
        regexp: t.specialChars,
        decoration: (e, r, n) => {
          let { doc: i } = r.state, s = Me(e[0], 0);
          if (s == 9) {
            let o = i.lineAt(n), a = r.state.tabSize, l = wi(o.text, a, n - o.from);
            return K.replace({
              widget: new TB((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = K.replace({ widget: new FB(t, s) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(Po);
      t.startState.facet(Po) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const EB = "•";
function AB(t) {
  return t >= 32 ? EB : t == 10 ? "␤" : String.fromCharCode(9216 + t);
}
class FB extends Sr {
  constructor(e, r) {
    super(), this.options = e, this.code = r;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let r = AB(this.code), n = e.state.phrase("Control character") + " " + (xB[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, n, r);
    if (i)
      return i;
    let s = document.createElement("span");
    return s.textContent = r, s.title = n, s.setAttribute("aria-label", n), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class TB extends Sr {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function _B() {
  return OB;
}
const BB = /* @__PURE__ */ K.line({ class: "cm-activeLine" }), OB = /* @__PURE__ */ Ee.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, r = [];
    for (let n of t.state.selection.ranges) {
      let i = t.lineBlockAt(n.head);
      i.from > e && (r.push(BB.range(i.from)), e = i.from);
    }
    return K.set(r);
  }
}, {
  decorations: (t) => t.decorations
});
class MB extends Sr {
  constructor(e) {
    super(), this.content = e;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content), typeof this.content == "string" ? e.setAttribute("aria-label", "placeholder " + this.content) : e.setAttribute("aria-hidden", "true"), e;
  }
  coordsAt(e) {
    let r = e.firstChild ? ui(e.firstChild) : [];
    if (!r.length)
      return null;
    let n = window.getComputedStyle(e.parentNode), i = Ja(r[0], n.direction != "rtl"), s = parseInt(n.lineHeight);
    return i.bottom - i.top > s * 1.5 ? { left: i.left, right: i.right, top: i.top, bottom: i.top + s } : i;
  }
  ignoreEvent() {
    return !1;
  }
}
function LB(t) {
  return Ee.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = t ? K.set([K.widget({ widget: new MB(t), side: 1 }).range(0)]) : K.none;
    }
    get decorations() {
      return this.view.state.doc.length ? K.none : this.placeholder;
    }
  }, { decorations: (e) => e.decorations });
}
const tc = 2e3;
function PB(t, e, r) {
  let n = Math.min(e.line, r.line), i = Math.max(e.line, r.line), s = [];
  if (e.off > tc || r.off > tc || e.col < 0 || r.col < 0) {
    let o = Math.min(e.off, r.off), a = Math.max(e.off, r.off);
    for (let l = n; l <= i; l++) {
      let c = t.doc.line(l);
      c.length <= a && s.push(B.range(c.from + o, c.to + a));
    }
  } else {
    let o = Math.min(e.col, r.col), a = Math.max(e.col, r.col);
    for (let l = n; l <= i; l++) {
      let c = t.doc.line(l), u = Mu(c.text, o, t.tabSize, !0);
      if (u < 0)
        s.push(B.cursor(c.to));
      else {
        let h = Mu(c.text, a, t.tabSize);
        s.push(B.range(c.from + u, c.from + h));
      }
    }
  }
  return s;
}
function NB(t, e) {
  let r = t.coordsAtPos(t.viewport.from);
  return r ? Math.round(Math.abs((r.left - e) / t.defaultCharacterWidth)) : -1;
}
function rp(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), n = t.state.doc.lineAt(r), i = r - n.from, s = i > tc ? -1 : i == n.length ? NB(t, e.clientX) : wi(n.text, t.state.tabSize, r - n.from);
  return { line: n.number, col: s, off: i };
}
function RB(t, e) {
  let r = rp(t, e), n = t.state.selection;
  return r ? {
    update(i) {
      if (i.docChanged) {
        let s = i.changes.mapPos(i.startState.doc.line(r.line).from), o = i.state.doc.lineAt(s);
        r = { line: o.number, col: r.col, off: Math.min(r.off, o.length) }, n = n.map(i.changes);
      }
    },
    get(i, s, o) {
      let a = rp(t, i);
      if (!a)
        return n;
      let l = PB(t.state, r, a);
      return l.length ? o ? B.create(l.concat(n.ranges)) : B.create(l) : n;
    }
  } : null;
}
function IB(t) {
  let e = (t == null ? void 0 : t.eventFilter) || ((r) => r.altKey && r.button == 0);
  return H.mouseSelectionStyle.of((r, n) => e(n) ? RB(r, n) : null);
}
const $B = {
  Alt: [18, (t) => !!t.altKey],
  Control: [17, (t) => !!t.ctrlKey],
  Shift: [16, (t) => !!t.shiftKey],
  Meta: [91, (t) => !!t.metaKey]
}, jB = { style: "cursor: crosshair" };
function WB(t = {}) {
  let [e, r] = $B[t.key || "Alt"], n = Ee.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || r(i));
      },
      keyup(i) {
        (i.keyCode == e || !r(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(r(i));
      }
    }
  });
  return [
    n,
    H.contentAttributes.of((i) => {
      var s;
      return !((s = i.plugin(n)) === null || s === void 0) && s.isDown ? jB : null;
    })
  ];
}
const Mi = "-10000px";
class o1 {
  constructor(e, r, n, i) {
    this.facet = r, this.createTooltipView = n, this.removeTooltipView = i, this.input = e.state.facet(r), this.tooltips = this.input.filter((o) => o);
    let s = null;
    this.tooltipViews = this.tooltips.map((o) => s = n(o, s));
  }
  update(e, r) {
    var n;
    let i = e.state.facet(this.facet), s = i.filter((l) => l);
    if (i === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let o = [], a = r ? [] : null;
    for (let l = 0; l < s.length; l++) {
      let c = s[l], u = -1;
      if (c) {
        for (let h = 0; h < this.tooltips.length; h++) {
          let f = this.tooltips[h];
          f && f.create == c.create && (u = h);
        }
        if (u < 0)
          o[l] = this.createTooltipView(c, l ? o[l - 1] : null), a && (a[l] = !!c.above);
        else {
          let h = o[l] = this.tooltipViews[u];
          a && (a[l] = r[u]), h.update && h.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      o.indexOf(l) < 0 && (this.removeTooltipView(l), (n = l.destroy) === null || n === void 0 || n.call(l));
    return r && (a.forEach((l, c) => r[c] = l), r.length = a.length), this.input = i, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function qB(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const $l = /* @__PURE__ */ z.define({
  combine: (t) => {
    var e, r, n;
    return {
      position: V.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((r = t.find((i) => i.parent)) === null || r === void 0 ? void 0 : r.parent) || null,
      tooltipSpace: ((n = t.find((i) => i.tooltipSpace)) === null || n === void 0 ? void 0 : n.tooltipSpace) || qB
    };
  }
}), np = /* @__PURE__ */ new WeakMap(), Mh = /* @__PURE__ */ Ee.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet($l);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new o1(t, Lh, (r, n) => this.createTooltip(r, n), (r) => {
      this.resizeObserver && this.resizeObserver.unobserve(r.dom), r.dom.remove();
    }), this.above = this.manager.tooltips.map((r) => !!r.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((r) => {
      Date.now() > this.lastTransaction - 50 && r.length > 0 && r[r.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let r = e || t.geometryChanged, n = t.state.facet($l);
    if (n.position != this.position && !this.madeAbsolute) {
      this.position = n.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      r = !0;
    }
    if (n.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = n.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      r = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    r && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let r = t.create(this.view), n = e ? e.dom : null;
    if (r.dom.classList.add("cm-tooltip"), t.arrow && !r.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", r.dom.insertBefore(i, n);
    }
    return r.dom.style.position = this.position, r.dom.style.top = Mi, r.dom.style.left = "0px", this.container.insertBefore(r.dom, n), r.mount && r.mount(this.view), this.resizeObserver && this.resizeObserver.observe(r.dom), r;
  }
  destroy() {
    var t, e, r;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let n of this.manager.tooltipViews)
      n.dom.remove(), (t = n.destroy) === null || t === void 0 || t.call(n);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (r = this.intersectionObserver) === null || r === void 0 || r.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = this.view.dom.getBoundingClientRect(), e = 1, r = 1, n = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: i } = this.manager.tooltipViews[0];
      if (V.gecko)
        n = i.offsetParent != this.container.ownerDocument.body;
      else if (i.style.top == Mi && i.style.left == "0px") {
        let s = i.getBoundingClientRect();
        n = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (n || this.position == "absolute")
      if (this.parent) {
        let i = this.parent.getBoundingClientRect();
        i.width && i.height && (e = i.width / this.parent.offsetWidth, r = i.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: r } = this.view.viewState);
    return {
      editor: t,
      parent: this.parent ? this.container.getBoundingClientRect() : t,
      pos: this.manager.tooltips.map((i, s) => {
        let o = this.manager.tooltipViews[s];
        return o.getCoords ? o.getCoords(i.pos) : this.view.coordsAtPos(i.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: i }) => i.getBoundingClientRect()),
      space: this.view.state.facet($l).tooltipSpace(this.view),
      scaleX: e,
      scaleY: r,
      makeAbsolute: n
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { editor: r, space: n, scaleX: i, scaleY: s } = t, o = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: u } = c, h = t.pos[a], f = t.size[a];
      if (!h || h.bottom <= Math.max(r.top, n.top) || h.top >= Math.min(r.bottom, n.bottom) || h.right < Math.max(r.left, n.left) - 0.1 || h.left > Math.min(r.right, n.right) + 0.1) {
        u.style.top = Mi;
        continue;
      }
      let d = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, p = d ? 7 : 0, m = f.right - f.left, y = (e = np.get(c)) !== null && e !== void 0 ? e : f.bottom - f.top, v = c.offset || VB, g = this.view.textDirection == ye.LTR, b = f.width > n.right - n.left ? g ? n.left : n.right - f.width : g ? Math.min(h.left - (d ? 14 : 0) + v.x, n.right - m) : Math.max(n.left, h.left - m + (d ? 14 : 0) - v.x), w = this.above[a];
      !l.strictSide && (w ? h.top - (f.bottom - f.top) - v.y < n.top : h.bottom + (f.bottom - f.top) + v.y > n.bottom) && w == n.bottom - h.bottom > h.top - n.top && (w = this.above[a] = !w);
      let D = (w ? h.top - n.top : n.bottom - h.bottom) - p;
      if (D < y && c.resize !== !1) {
        if (D < this.view.defaultLineHeight) {
          u.style.top = Mi;
          continue;
        }
        np.set(c, y), u.style.height = (y = D) / s + "px";
      } else
        u.style.height && (u.style.height = "");
      let x = w ? h.top - y - p - v.y : h.bottom + p + v.y, C = b + m;
      if (c.overlap !== !0)
        for (let k of o)
          k.left < C && k.right > b && k.top < x + y && k.bottom > x && (x = w ? k.top - y - 2 - p : k.bottom + p + 2);
      if (this.position == "absolute" ? (u.style.top = (x - t.parent.top) / s + "px", u.style.left = (b - t.parent.left) / i + "px") : (u.style.top = x / s + "px", u.style.left = b / i + "px"), d) {
        let k = h.left + (g ? v.x : -v.x) - (b + 14 - 7);
        d.style.left = k / i + "px";
      }
      c.overlap !== !0 && o.push({ left: b, top: x, right: C, bottom: x + y }), u.classList.toggle("cm-tooltip-above", w), u.classList.toggle("cm-tooltip-below", !w), c.positioned && c.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = Mi;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), HB = /* @__PURE__ */ H.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), VB = { x: 0, y: 0 }, Lh = /* @__PURE__ */ z.define({
  enables: [Mh, HB]
}), Zo = /* @__PURE__ */ z.define({
  combine: (t) => t.reduce((e, r) => e.concat(r), [])
});
class el {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new el(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new o1(e, Zo, (r, n) => this.createHostedView(r, n), (r) => r.dom.remove());
  }
  createHostedView(e, r) {
    let n = e.create(this.view);
    return n.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(n.dom, r ? r.dom.nextSibling : this.dom.firstChild), this.mounted && n.mount && n.mount(this.view), n;
  }
  mount(e) {
    for (let r of this.manager.tooltipViews)
      r.mount && r.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let r of this.manager.tooltipViews)
      r.positioned && r.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let r of this.manager.tooltipViews)
      (e = r.destroy) === null || e === void 0 || e.call(r);
  }
  passProp(e) {
    let r;
    for (let n of this.manager.tooltipViews) {
      let i = n[e];
      if (i !== void 0) {
        if (r === void 0)
          r = i;
        else if (r !== i)
          return;
      }
    }
    return r;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const zB = /* @__PURE__ */ Lh.compute([Zo], (t) => {
  let e = t.facet(Zo);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((r) => r.pos)),
    end: Math.max(...e.map((r) => {
      var n;
      return (n = r.end) !== null && n !== void 0 ? n : r.pos;
    })),
    create: el.create,
    above: e[0].above,
    arrow: e.some((r) => r.arrow)
  };
});
class UB {
  constructor(e, r, n, i, s) {
    this.view = e, this.source = r, this.field = n, this.setHover = i, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: r } = this, n = e.docView.nearest(r.target);
    if (!n)
      return;
    let i, s = 1;
    if (n instanceof Rr)
      i = n.posAtStart;
    else {
      if (i = e.posAtCoords(r), i == null)
        return;
      let a = e.coordsAtPos(i);
      if (!a || r.y < a.top || r.y > a.bottom || r.x < a.left - e.defaultCharacterWidth || r.x > a.right + e.defaultCharacterWidth)
        return;
      let l = e.bidiSpans(e.state.doc.lineAt(i)).find((u) => u.from <= i && u.to >= i), c = l && l.dir == ye.RTL ? -1 : 1;
      s = r.x < a.left ? -c : c;
    }
    let o = this.source(e, i, s);
    if (o != null && o.then) {
      let a = this.pending = { pos: i };
      o.then((l) => {
        this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
      }, (l) => At(e.state, l, "hover tooltip"));
    } else
      o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let e = this.view.plugin(Mh), r = e ? e.manager.tooltips.findIndex((n) => n.create == el.create) : -1;
    return r > -1 ? e.manager.tooltipViews[r] : null;
  }
  mousemove(e) {
    var r, n;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: s } = this;
    if (i.length && s && !GB(s.dom, e) || this.pending) {
      let { pos: o } = i[0] || this.pending, a = (n = (r = i[0]) === null || r === void 0 ? void 0 : r.end) !== null && n !== void 0 ? n : o;
      (o == a ? this.view.posAtCoords(this.lastMove) != o : !KB(this.view, o, a, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: r } = this;
    if (r.length) {
      let { tooltip: n } = this;
      n && n.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(n.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let r = (n) => {
      e.removeEventListener("mouseleave", r), this.active.length && !this.view.dom.contains(n.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", r);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const uo = 4;
function GB(t, e) {
  let r = t.getBoundingClientRect();
  return e.clientX >= r.left - uo && e.clientX <= r.right + uo && e.clientY >= r.top - uo && e.clientY <= r.bottom + uo;
}
function KB(t, e, r, n, i, s) {
  let o = t.scrollDOM.getBoundingClientRect(), a = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (o.left > n || o.right < n || o.top > i || Math.min(o.bottom, a) < i)
    return !1;
  let l = t.posAtCoords({ x: n, y: i }, !1);
  return l >= e && l <= r;
}
function YB(t, e = {}) {
  let r = J.define(), n = We.define({
    create() {
      return [];
    },
    update(i, s) {
      if (i.length && (e.hideOnChange && (s.docChanged || s.selection) ? i = [] : e.hideOn && (i = i.filter((o) => !e.hideOn(s, o))), s.docChanged))
        for (let o of i) {
          let a = s.changes.mapPos(o.pos, -1, Qe.TrackDel);
          if (a != null) {
            let l = Object.assign(/* @__PURE__ */ Object.create(null), o);
            l.pos = a, l.end != null && (l.end = s.changes.mapPos(l.end));
          }
        }
      for (let o of s.effects)
        o.is(r) && (i = o.value), o.is(JB) && (i = []);
      return i;
    },
    provide: (i) => Zo.from(i)
  });
  return [
    n,
    Ee.define((i) => new UB(
      i,
      t,
      n,
      r,
      e.hoverTime || 300
      /* Hover.Time */
    )),
    zB
  ];
}
function a1(t, e) {
  let r = t.plugin(Mh);
  if (!r)
    return null;
  let n = r.manager.tooltips.indexOf(e);
  return n < 0 ? null : r.manager.tooltipViews[n];
}
const JB = /* @__PURE__ */ J.define(), ip = /* @__PURE__ */ z.define({
  combine(t) {
    let e, r;
    for (let n of t)
      e = e || n.topContainer, r = r || n.bottomContainer;
    return { topContainer: e, bottomContainer: r };
  }
});
function ds(t, e) {
  let r = t.plugin(l1), n = r ? r.specs.indexOf(e) : -1;
  return n > -1 ? r.panels[n] : null;
}
const l1 = /* @__PURE__ */ Ee.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(ps), this.specs = this.input.filter((r) => r), this.panels = this.specs.map((r) => r(t));
    let e = t.state.facet(ip);
    this.top = new co(t, !0, e.topContainer), this.bottom = new co(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((r) => r.top)), this.bottom.sync(this.panels.filter((r) => !r.top));
    for (let r of this.panels)
      r.dom.classList.add("cm-panel"), r.mount && r.mount();
  }
  update(t) {
    let e = t.state.facet(ip);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new co(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new co(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let r = t.state.facet(ps);
    if (r != this.input) {
      let n = r.filter((l) => l), i = [], s = [], o = [], a = [];
      for (let l of n) {
        let c = this.specs.indexOf(l), u;
        c < 0 ? (u = l(t.view), a.push(u)) : (u = this.panels[c], u.update && u.update(t)), i.push(u), (u.top ? s : o).push(u);
      }
      this.specs = n, this.panels = i, this.top.sync(s), this.bottom.sync(o);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let n of this.panels)
        n.update && n.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => H.scrollMargins.of((e) => {
    let r = e.plugin(t);
    return r && { top: r.top.scrollMargin(), bottom: r.bottom.scrollMargin() };
  })
});
class co {
  constructor(e, r, n) {
    this.view = e, this.top = r, this.container = n, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let r of this.panels)
      r.destroy && e.indexOf(r) < 0 && r.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let r = this.container || this.view.dom;
      r.insertBefore(this.dom, this.top ? r.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let r of this.panels)
      if (r.dom.parentNode == this.dom) {
        for (; e != r.dom; )
          e = sp(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(r.dom, e);
    for (; e; )
      e = sp(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function sp(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const ps = /* @__PURE__ */ z.define({
  enables: l1
});
class yr extends Cn {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
yr.prototype.elementClass = "";
yr.prototype.toDOM = void 0;
yr.prototype.mapMode = Qe.TrackBefore;
yr.prototype.startSide = yr.prototype.endSide = -1;
yr.prototype.point = !0;
const No = /* @__PURE__ */ z.define(), XB = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => ie.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, ts = /* @__PURE__ */ z.define();
function QB(t) {
  return [u1(), ts.of(Object.assign(Object.assign({}, XB), t))];
}
const rc = /* @__PURE__ */ z.define({
  combine: (t) => t.some((e) => e)
});
function u1(t) {
  let e = [
    ZB
  ];
  return t && t.fixed === !1 && e.push(rc.of(!0)), e;
}
const ZB = /* @__PURE__ */ Ee.fromClass(class {
  constructor(t) {
    this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(ts).map((e) => new ap(t, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !t.state.facet(rc), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, r = t.view.viewport, n = Math.min(e.to, r.to) - Math.max(e.from, r.from);
      this.syncGutters(n < (r.to - r.from) * 0.8);
    }
    t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(rc) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && this.dom.remove();
    let r = ie.iter(this.view.state.facet(No), this.view.viewport.from), n = [], i = this.gutters.map((s) => new eO(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (n.length && (n = []), Array.isArray(s.type)) {
        let o = !0;
        for (let a of s.type)
          if (a.type == Ze.Text && o) {
            nc(r, n, a.from);
            for (let l of i)
              l.line(this.view, a, n);
            o = !1;
          } else if (a.widget)
            for (let l of i)
              l.widget(this.view, a);
      } else if (s.type == Ze.Text) {
        nc(r, n, s.from);
        for (let o of i)
          o.line(this.view, s, n);
      } else if (s.widget)
        for (let o of i)
          o.widget(this.view, s);
    for (let s of i)
      s.finish();
    t && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(t) {
    let e = t.startState.facet(ts), r = t.state.facet(ts), n = t.docChanged || t.heightChanged || t.viewportChanged || !ie.eq(t.startState.facet(No), t.state.facet(No), t.view.viewport.from, t.view.viewport.to);
    if (e == r)
      for (let i of this.gutters)
        i.update(t) && (n = !0);
    else {
      n = !0;
      let i = [];
      for (let s of r) {
        let o = e.indexOf(s);
        o < 0 ? i.push(new ap(this.view, s)) : (this.gutters[o].update(t), i.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), i.indexOf(s) < 0 && s.destroy();
      for (let s of i)
        this.dom.appendChild(s.dom);
      this.gutters = i;
    }
    return n;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove();
  }
}, {
  provide: (t) => H.scrollMargins.of((e) => {
    let r = e.plugin(t);
    return !r || r.gutters.length == 0 || !r.fixed ? null : e.textDirection == ye.LTR ? { left: r.dom.offsetWidth * e.scaleX } : { right: r.dom.offsetWidth * e.scaleX };
  })
});
function op(t) {
  return Array.isArray(t) ? t : [t];
}
function nc(t, e, r) {
  for (; t.value && t.from <= r; )
    t.from == r && e.push(t.value), t.next();
}
class eO {
  constructor(e, r, n) {
    this.gutter = e, this.height = n, this.i = 0, this.cursor = ie.iter(e.markers, r.from);
  }
  addElement(e, r, n) {
    let { gutter: i } = this, s = (r.top - this.height) / e.scaleY, o = r.height / e.scaleY;
    if (this.i == i.elements.length) {
      let a = new c1(e, o, s, n);
      i.elements.push(a), i.dom.appendChild(a.dom);
    } else
      i.elements[this.i].update(e, o, s, n);
    this.height = r.bottom, this.i++;
  }
  line(e, r, n) {
    let i = [];
    nc(this.cursor, i, r.from), n.length && (i = i.concat(n));
    let s = this.gutter.config.lineMarker(e, r, i);
    s && i.unshift(s);
    let o = this.gutter;
    i.length == 0 && !o.config.renderEmptyElements || this.addElement(e, r, i);
  }
  widget(e, r) {
    let n = this.gutter.config.widgetMarker(e, r.widget, r);
    n && this.addElement(e, r, [n]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let r = e.elements.pop();
      e.dom.removeChild(r.dom), r.destroy();
    }
  }
}
class ap {
  constructor(e, r) {
    this.view = e, this.config = r, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let n in r.domEventHandlers)
      this.dom.addEventListener(n, (i) => {
        let s = i.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let l = s.getBoundingClientRect();
          o = (l.top + l.bottom) / 2;
        } else
          o = i.clientY;
        let a = e.lineBlockAtHeight(o - e.documentTop);
        r.domEventHandlers[n](e, a, i) && i.preventDefault();
      });
    this.markers = op(r.markers(e)), r.initialSpacer && (this.spacer = new c1(e, 0, 0, [r.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let r = this.markers;
    if (this.markers = op(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let n = e.view.viewport;
    return !ie.eq(this.markers, r, n.from, n.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class c1 {
  constructor(e, r, n, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, r, n, i);
  }
  update(e, r, n, i) {
    this.height != r && (this.height = r, this.dom.style.height = r + "px"), this.above != n && (this.dom.style.marginTop = (this.above = n) ? n + "px" : ""), tO(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, r) {
    let n = "cm-gutterElement", i = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let a = o, l = s < r.length ? r[s++] : null, c = !1;
      if (l) {
        let u = l.elementClass;
        u && (n += " " + u);
        for (let h = o; h < this.markers.length; h++)
          if (this.markers[h].compare(l)) {
            a = h, c = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; o < a; ) {
        let u = this.markers[o++];
        if (u.toDOM) {
          u.destroy(i);
          let h = i.nextSibling;
          i.remove(), i = h;
        }
      }
      if (!l)
        break;
      l.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(l.toDOM(e), i)), c && o++;
    }
    this.dom.className = n, this.markers = r;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function tO(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!t[r].compare(e[r]))
      return !1;
  return !0;
}
const rO = /* @__PURE__ */ z.define(), Xn = /* @__PURE__ */ z.define({
  combine(t) {
    return ur(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, r) {
        let n = Object.assign({}, e);
        for (let i in r) {
          let s = n[i], o = r[i];
          n[i] = s ? (a, l, c) => s(a, l, c) || o(a, l, c) : o;
        }
        return n;
      }
    });
  }
});
class jl extends yr {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Wl(t, e) {
  return t.state.facet(Xn).formatNumber(e, t.state);
}
const nO = /* @__PURE__ */ ts.compute([Xn], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(rO);
  },
  lineMarker(e, r, n) {
    return n.some((i) => i.toDOM) ? null : new jl(Wl(e, e.state.doc.lineAt(r.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(Xn) != e.state.facet(Xn),
  initialSpacer(e) {
    return new jl(Wl(e, lp(e.state.doc.lines)));
  },
  updateSpacer(e, r) {
    let n = Wl(r.view, lp(r.view.state.doc.lines));
    return n == e.number ? e : new jl(n);
  },
  domEventHandlers: t.facet(Xn).domEventHandlers
}));
function iO(t = {}) {
  return [
    Xn.of(t),
    u1(),
    nO
  ];
}
function lp(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const sO = /* @__PURE__ */ new class extends yr {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), oO = /* @__PURE__ */ No.compute(["selection"], (t) => {
  let e = [], r = -1;
  for (let n of t.selection.ranges) {
    let i = t.doc.lineAt(n.head).from;
    i > r && (r = i, e.push(sO.range(i)));
  }
  return ie.of(e);
});
function aO() {
  return oO;
}
const lO = 1024;
let uO = 0;
class ql {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
class te {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = uO++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Ot.match(e)), (r) => {
      let n = e(r);
      return n === void 0 ? null : [this, n];
    };
  }
}
te.closedBy = new te({ deserialize: (t) => t.split(" ") });
te.openedBy = new te({ deserialize: (t) => t.split(" ") });
te.group = new te({ deserialize: (t) => t.split(" ") });
te.isolate = new te({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
te.contextHash = new te({ perNode: !0 });
te.lookAhead = new te({ perNode: !0 });
te.mounted = new te({ perNode: !0 });
class ea {
  constructor(e, r, n) {
    this.tree = e, this.overlay = r, this.parser = n;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[te.mounted.id];
  }
}
const cO = /* @__PURE__ */ Object.create(null);
class Ot {
  /**
  @internal
  */
  constructor(e, r, n, i = 0) {
    this.name = e, this.props = r, this.id = n, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let r = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : cO, n = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new Ot(e.name || "", r, e.id, n);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(i)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          r[s[0].id] = s[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let r = this.prop(te.group);
      return r ? r.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let n in e)
      for (let i of n.split(" "))
        r[i] = e[n];
    return (n) => {
      for (let i = n.prop(te.group), s = -1; s < (i ? i.length : 0); s++) {
        let o = r[s < 0 ? n.name : i[s]];
        if (o)
          return o;
      }
    };
  }
}
Ot.none = new Ot(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
const ho = /* @__PURE__ */ new WeakMap(), up = /* @__PURE__ */ new WeakMap();
var Pe;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Pe || (Pe = {}));
class Ue {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, r, n, i, s) {
    if (this.type = e, this.children = r, this.positions = n, this.length = i, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, a] of s)
        this.props[typeof o == "number" ? o : o.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = ea.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let r = "";
    for (let n of this.children) {
      let i = n.toString();
      i && (r && (r += ","), r += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (r.length ? "(" + r + ")" : "") : r;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new sc(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, r = 0, n = 0) {
    let i = ho.get(this) || this.topNode, s = new sc(i);
    return s.moveTo(e, r), ho.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Tt(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, r = 0) {
    let n = ms(ho.get(this) || this.topNode, e, r, !1);
    return ho.set(this, n), n;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, r = 0) {
    let n = ms(up.get(this) || this.topNode, e, r, !0);
    return up.set(this, n), n;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, r = 0) {
    return dO(this, e, r);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: r, leave: n, from: i = 0, to: s = this.length } = e, o = e.mode || 0, a = (o & Pe.IncludeAnonymous) > 0;
    for (let l = this.cursor(o | Pe.IncludeAnonymous); ; ) {
      let c = !1;
      if (l.from <= s && l.to >= i && (!a && l.type.isAnonymous || r(l) !== !1)) {
        if (l.firstChild())
          continue;
        c = !0;
      }
      for (; c && n && (a || !l.type.isAnonymous) && n(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let r in this.props)
        e.push([+r, this.props[r]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : Rh(Ot.none, this.children, this.positions, 0, this.children.length, 0, this.length, (r, n, i) => new Ue(this.type, r, n, i, this.propValues), e.makeTree || ((r, n, i) => new Ue(Ot.none, r, n, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return pO(e);
  }
}
Ue.empty = new Ue(Ot.none, [], [], 0);
class Ph {
  constructor(e, r) {
    this.buffer = e, this.index = r;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Ph(this.buffer, this.index);
  }
}
class Xr {
  /**
  Create a tree buffer.
  */
  constructor(e, r, n) {
    this.buffer = e, this.length = r, this.set = n;
  }
  /**
  @internal
  */
  get type() {
    return Ot.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let r = 0; r < this.buffer.length; )
      e.push(this.childString(r)), r = this.buffer[r + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let r = this.buffer[e], n = this.buffer[e + 3], i = this.set.types[r], s = i.name;
    if (/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), e += 4, n == e)
      return s;
    let o = [];
    for (; e < n; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, r, n, i, s) {
    let { buffer: o } = this, a = -1;
    for (let l = e; l != r && !(h1(s, i, o[l + 1], o[l + 2]) && (a = l, n > 0)); l = o[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, r, n) {
    let i = this.buffer, s = new Uint16Array(r - e), o = 0;
    for (let a = e, l = 0; a < r; ) {
      s[l++] = i[a++], s[l++] = i[a++] - n;
      let c = s[l++] = i[a++] - n;
      s[l++] = i[a++] - e, o = Math.max(o, c);
    }
    return new Xr(s, o, this.set);
  }
}
function h1(t, e, r, n) {
  switch (t) {
    case -2:
      return r < e;
    case -1:
      return n >= e && r < e;
    case 0:
      return r < e && n > e;
    case 1:
      return r <= e && n > e;
    case 2:
      return n > e;
    case 4:
      return !0;
  }
}
function ms(t, e, r, n) {
  for (var i; t.from == t.to || (r < 1 ? t.from >= e : t.from > e) || (r > -1 ? t.to <= e : t.to < e); ) {
    let o = !n && t instanceof Tt && t.index < 0 ? null : t.parent;
    if (!o)
      return t;
    t = o;
  }
  let s = n ? 0 : Pe.IgnoreOverlays;
  if (n)
    for (let o = t, a = o.parent; a; o = a, a = o.parent)
      o instanceof Tt && o.index < 0 && ((i = a.enter(e, r, s)) === null || i === void 0 ? void 0 : i.from) != o.from && (t = a);
  for (; ; ) {
    let o = t.enter(e, r, s);
    if (!o)
      return t;
    t = o;
  }
}
class f1 {
  cursor(e = 0) {
    return new sc(this, e);
  }
  getChild(e, r = null, n = null) {
    let i = cp(this, e, r, n);
    return i.length ? i[0] : null;
  }
  getChildren(e, r = null, n = null) {
    return cp(this, e, r, n);
  }
  resolve(e, r = 0) {
    return ms(this, e, r, !1);
  }
  resolveInner(e, r = 0) {
    return ms(this, e, r, !0);
  }
  matchContext(e) {
    return ic(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let r = this.childBefore(e), n = this;
    for (; r; ) {
      let i = r.lastChild;
      if (!i || i.to != r.to)
        break;
      i.type.isError && i.from == i.to ? (n = r, r = i.prevSibling) : r = i;
    }
    return n;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Tt extends f1 {
  constructor(e, r, n, i) {
    super(), this._tree = e, this.from = r, this.index = n, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, r, n, i, s = 0) {
    for (let o = this; ; ) {
      for (let { children: a, positions: l } = o._tree, c = r > 0 ? a.length : -1; e != c; e += r) {
        let u = a[e], h = l[e] + o.from;
        if (h1(i, n, h, h + u.length)) {
          if (u instanceof Xr) {
            if (s & Pe.ExcludeBuffers)
              continue;
            let f = u.findChild(0, u.buffer.length, r, n - h, i);
            if (f > -1)
              return new $r(new hO(o, u, e, h), null, f);
          } else if (s & Pe.IncludeAnonymous || !u.type.isAnonymous || Nh(u)) {
            let f;
            if (!(s & Pe.IgnoreMounts) && (f = ea.get(u)) && !f.overlay)
              return new Tt(f.tree, h, e, o);
            let d = new Tt(u, h, e, o);
            return s & Pe.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(r < 0 ? u.children.length - 1 : 0, r, n, i);
          }
        }
      }
      if (s & Pe.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + r : e = r < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, n = 0) {
    let i;
    if (!(n & Pe.IgnoreOverlays) && (i = ea.get(this._tree)) && i.overlay) {
      let s = e - this.from;
      for (let { from: o, to: a } of i.overlay)
        if ((r > 0 ? o <= s : o < s) && (r < 0 ? a >= s : a > s))
          return new Tt(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, r, n);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function cp(t, e, r, n) {
  let i = t.cursor(), s = [];
  if (!i.firstChild())
    return s;
  if (r != null) {
    for (let o = !1; !o; )
      if (o = i.type.is(r), !i.nextSibling())
        return s;
  }
  for (; ; ) {
    if (n != null && i.type.is(n))
      return s;
    if (i.type.is(e) && s.push(i.node), !i.nextSibling())
      return n == null ? s : [];
  }
}
function ic(t, e, r = e.length - 1) {
  for (let n = t.parent; r >= 0; n = n.parent) {
    if (!n)
      return !1;
    if (!n.type.isAnonymous) {
      if (e[r] && e[r] != n.name)
        return !1;
      r--;
    }
  }
  return !0;
}
class hO {
  constructor(e, r, n, i) {
    this.parent = e, this.buffer = r, this.index = n, this.start = i;
  }
}
class $r extends f1 {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, r, n) {
    super(), this.context = e, this._parent = r, this.index = n, this.type = e.buffer.set.types[e.buffer.buffer[n]];
  }
  child(e, r, n) {
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.context.start, n);
    return s < 0 ? null : new $r(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, n = 0) {
    if (n & Pe.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], r > 0 ? 1 : -1, e - this.context.start, r);
    return s < 0 ? null : new $r(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, r = e.buffer[this.index + 3];
    return r < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new $r(this.context, this._parent, r) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, r = this._parent ? this._parent.index + 4 : 0;
    return this.index == r ? this.externalSibling(-1) : new $r(this.context, this._parent, e.findChild(
      r,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], r = [], { buffer: n } = this.context, i = this.index + 4, s = n.buffer[this.index + 3];
    if (s > i) {
      let o = n.buffer[this.index + 1];
      e.push(n.slice(i, s, o)), r.push(0);
    }
    return new Ue(this.type, e, r, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function d1(t) {
  if (!t.length)
    return null;
  let e = 0, r = t[0];
  for (let s = 1; s < t.length; s++) {
    let o = t[s];
    (o.from > r.from || o.to < r.to) && (r = o, e = s);
  }
  let n = r instanceof Tt && r.index < 0 ? null : r.parent, i = t.slice();
  return n ? i[e] = n : i.splice(e, 1), new fO(i, r);
}
class fO {
  constructor(e, r) {
    this.heads = e, this.node = r;
  }
  get next() {
    return d1(this.heads);
  }
}
function dO(t, e, r) {
  let n = t.resolveInner(e, r), i = null;
  for (let s = n instanceof Tt ? n : n.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (i || (i = [n])).push(o.resolve(e, r)), s = o;
    } else {
      let o = ea.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let a = new Tt(o.tree, o.overlay[0].from + s.from, -1, s);
        (i || (i = [n])).push(ms(a, e, r, !1));
      }
    }
  return i ? d1(i) : n;
}
class sc {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, r = 0) {
    if (this.mode = r, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Tt)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let n = e._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, r) {
    this.index = e;
    let { start: n, buffer: i } = this.buffer;
    return this.type = r || i.set.types[i.buffer[e]], this.from = n + i.buffer[e + 1], this.to = n + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Tt ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, r, n) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, r, n, this.mode));
    let { buffer: i } = this.buffer, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.buffer.start, n);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, r, n = this.mode) {
    return this.buffer ? n & Pe.ExcludeBuffers ? !1 : this.enterChild(1, e, r) : this.yield(this._tree.enter(e, r, n));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Pe.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Pe.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: r } = this.buffer, n = this.stack.length - 1;
    if (e < 0) {
      let i = n < 0 ? 0 : this.stack[n] + 4;
      if (this.index != i)
        return this.yieldBuf(r.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = r.buffer[this.index + 3];
      if (i < (n < 0 ? r.buffer.length : r.buffer[this.stack[n] + 3]))
        return this.yieldBuf(i);
    }
    return n < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let r, n, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (i.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: r, parent: n } = i);
    } else
      ({ index: r, _parent: n } = this._tree);
    for (; n; { index: r, _parent: n } = n)
      if (r > -1)
        for (let s = r + e, o = e < 0 ? -1 : n._tree.children.length; s != o; s += e) {
          let a = n._tree.children[s];
          if (this.mode & Pe.IncludeAnonymous || a instanceof Xr || !a.type.isAnonymous || Nh(a))
            return !1;
        }
    return !0;
  }
  move(e, r) {
    if (r && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, r = 0) {
    for (; (this.from == this.to || (r < 1 ? this.from >= e : this.from > e) || (r > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, r); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, r = null, n = 0;
    if (e && e.context == this.buffer)
      e:
        for (let i = this.index, s = this.stack.length; s >= 0; ) {
          for (let o = e; o; o = o._parent)
            if (o.index == i) {
              if (i == this.index)
                return o;
              r = o, n = s + 1;
              break e;
            }
          i = this.stack[--s];
        }
    for (let i = n; i < this.stack.length; i++)
      r = new $r(this.buffer, r, this.stack[i]);
    return this.bufferNode = new $r(this.buffer, r, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, r) {
    for (let n = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          n++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; i && r && r(this), i = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!n)
          return;
        this.parent(), n--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return ic(this.node, e);
    let { buffer: r } = this.buffer, { types: n } = r.set;
    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0)
        return ic(this.node, e, i);
      let o = n[r.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[i] && e[i] != o.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function Nh(t) {
  return t.children.some((e) => e instanceof Xr || !e.type.isAnonymous || Nh(e));
}
function pO(t) {
  var e;
  let { buffer: r, nodeSet: n, maxBufferLength: i = lO, reused: s = [], minRepeatType: o = n.types.length } = t, a = Array.isArray(r) ? new Ph(r, r.length) : r, l = n.types, c = 0, u = 0;
  function h(D, x, C, k, S, A) {
    let { id: _, start: N, end: $, size: L } = a, I = u;
    for (; L < 0; )
      if (a.next(), L == -1) {
        let ue = s[_];
        C.push(ue), k.push(N - D);
        return;
      } else if (L == -3) {
        c = _;
        return;
      } else if (L == -4) {
        u = _;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${L}`);
    let P = l[_], G, re, oe = N - D;
    if ($ - N <= i && (re = y(a.pos - x, S))) {
      let ue = new Uint16Array(re.size - re.skip), pe = a.pos - re.size, ke = ue.length;
      for (; a.pos > pe; )
        ke = v(re.start, ue, ke);
      G = new Xr(ue, $ - re.start, n), oe = re.start - D;
    } else {
      let ue = a.pos - L;
      a.next();
      let pe = [], ke = [], qe = _ >= o ? _ : -1, se = 0, at = $;
      for (; a.pos > ue; )
        qe >= 0 && a.id == qe && a.size >= 0 ? (a.end <= at - i && (p(pe, ke, N, se, a.end, at, qe, I), se = pe.length, at = a.end), a.next()) : A > 2500 ? f(N, ue, pe, ke) : h(N, ue, pe, ke, qe, A + 1);
      if (qe >= 0 && se > 0 && se < pe.length && p(pe, ke, N, se, N, at, qe, I), pe.reverse(), ke.reverse(), qe > -1 && se > 0) {
        let qt = d(P);
        G = Rh(P, pe, ke, 0, pe.length, 0, $ - N, qt, qt);
      } else
        G = m(P, pe, ke, $ - N, I - $);
    }
    C.push(G), k.push(oe);
  }
  function f(D, x, C, k) {
    let S = [], A = 0, _ = -1;
    for (; a.pos > x; ) {
      let { id: N, start: $, end: L, size: I } = a;
      if (I > 4)
        a.next();
      else {
        if (_ > -1 && $ < _)
          break;
        _ < 0 && (_ = L - i), S.push(N, $, L), A++, a.next();
      }
    }
    if (A) {
      let N = new Uint16Array(A * 4), $ = S[S.length - 2];
      for (let L = S.length - 3, I = 0; L >= 0; L -= 3)
        N[I++] = S[L], N[I++] = S[L + 1] - $, N[I++] = S[L + 2] - $, N[I++] = I;
      C.push(new Xr(N, S[2] - $, n)), k.push($ - D);
    }
  }
  function d(D) {
    return (x, C, k) => {
      let S = 0, A = x.length - 1, _, N;
      if (A >= 0 && (_ = x[A]) instanceof Ue) {
        if (!A && _.type == D && _.length == k)
          return _;
        (N = _.prop(te.lookAhead)) && (S = C[A] + _.length + N);
      }
      return m(D, x, C, k, S);
    };
  }
  function p(D, x, C, k, S, A, _, N) {
    let $ = [], L = [];
    for (; D.length > k; )
      $.push(D.pop()), L.push(x.pop() + C - S);
    D.push(m(n.types[_], $, L, A - S, N - A)), x.push(S - C);
  }
  function m(D, x, C, k, S = 0, A) {
    if (c) {
      let _ = [te.contextHash, c];
      A = A ? [_].concat(A) : [_];
    }
    if (S > 25) {
      let _ = [te.lookAhead, S];
      A = A ? [_].concat(A) : [_];
    }
    return new Ue(D, x, C, k, A);
  }
  function y(D, x) {
    let C = a.fork(), k = 0, S = 0, A = 0, _ = C.end - i, N = { size: 0, start: 0, skip: 0 };
    e:
      for (let $ = C.pos - D; C.pos > $; ) {
        let L = C.size;
        if (C.id == x && L >= 0) {
          N.size = k, N.start = S, N.skip = A, A += 4, k += 4, C.next();
          continue;
        }
        let I = C.pos - L;
        if (L < 0 || I < $ || C.start < _)
          break;
        let P = C.id >= o ? 4 : 0, G = C.start;
        for (C.next(); C.pos > I; ) {
          if (C.size < 0)
            if (C.size == -3)
              P += 4;
            else
              break e;
          else
            C.id >= o && (P += 4);
          C.next();
        }
        S = G, k += L, A += P;
      }
    return (x < 0 || k == D) && (N.size = k, N.start = S, N.skip = A), N.size > 4 ? N : void 0;
  }
  function v(D, x, C) {
    let { id: k, start: S, end: A, size: _ } = a;
    if (a.next(), _ >= 0 && k < o) {
      let N = C;
      if (_ > 4) {
        let $ = a.pos - (_ - 4);
        for (; a.pos > $; )
          C = v(D, x, C);
      }
      x[--C] = N, x[--C] = A - D, x[--C] = S - D, x[--C] = k;
    } else
      _ == -3 ? c = k : _ == -4 && (u = k);
    return C;
  }
  let g = [], b = [];
  for (; a.pos > 0; )
    h(t.start || 0, t.bufferStart || 0, g, b, -1, 0);
  let w = (e = t.length) !== null && e !== void 0 ? e : g.length ? b[0] + g[0].length : 0;
  return new Ue(l[t.topID], g.reverse(), b.reverse(), w);
}
const hp = /* @__PURE__ */ new WeakMap();
function Ro(t, e) {
  if (!t.isAnonymous || e instanceof Xr || e.type != t)
    return 1;
  let r = hp.get(e);
  if (r == null) {
    r = 1;
    for (let n of e.children) {
      if (n.type != t || !(n instanceof Ue)) {
        r = 1;
        break;
      }
      r += Ro(t, n);
    }
    hp.set(e, r);
  }
  return r;
}
function Rh(t, e, r, n, i, s, o, a, l) {
  let c = 0;
  for (let p = n; p < i; p++)
    c += Ro(t, e[p]);
  let u = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), h = [], f = [];
  function d(p, m, y, v, g) {
    for (let b = y; b < v; ) {
      let w = b, D = m[b], x = Ro(t, p[b]);
      for (b++; b < v; b++) {
        let C = Ro(t, p[b]);
        if (x + C >= u)
          break;
        x += C;
      }
      if (b == w + 1) {
        if (x > u) {
          let C = p[w];
          d(C.children, C.positions, 0, C.children.length, m[w] + g);
          continue;
        }
        h.push(p[w]);
      } else {
        let C = m[b - 1] + p[b - 1].length - D;
        h.push(Rh(t, p, m, w, b, D, C, null, l));
      }
      f.push(D + g - s);
    }
  }
  return d(e, r, n, i, 0), (a || l)(h, f, o);
}
class vn {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, r, n, i, s = !1, o = !1) {
    this.from = e, this.to = r, this.tree = n, this.offset = i, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, r = [], n = !1) {
    let i = [new vn(0, e.length, e, 0, !1, n)];
    for (let s of r)
      s.to > e.length && i.push(s);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, r, n = 128) {
    if (!r.length)
      return e;
    let i = [], s = 1, o = e.length ? e[0] : null;
    for (let a = 0, l = 0, c = 0; ; a++) {
      let u = a < r.length ? r[a] : null, h = u ? u.fromA : 1e9;
      if (h - l >= n)
        for (; o && o.from < h; ) {
          let f = o;
          if (l >= f.from || h <= f.to || c) {
            let d = Math.max(f.from, l) - c, p = Math.min(f.to, h) - c;
            f = d >= p ? null : new vn(d, p, f.tree, f.offset + c, a > 0, !!u);
          }
          if (f && i.push(f), o.to > h)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!u)
        break;
      l = u.toA, c = u.toA - u.toB;
    }
    return i;
  }
}
class mO {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, r, n) {
    return typeof e == "string" && (e = new gO(e)), n = n ? n.length ? n.map((i) => new ql(i.from, i.to)) : [new ql(0, 0)] : [new ql(0, e.length)], this.createParse(e, r || [], n);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, r, n) {
    let i = this.startParse(e, r, n);
    for (; ; ) {
      let s = i.advance();
      if (s)
        return s;
    }
  }
}
class gO {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, r) {
    return this.string.slice(e, r);
  }
}
new te({ perNode: !0 });
let yO = 0;
class Xt {
  /**
  @internal
  */
  constructor(e, r, n) {
    this.set = e, this.base = r, this.modified = n, this.id = yO++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let r = new Xt([], null, []);
    if (r.set.push(r), e)
      for (let n of e.set)
        r.set.push(n);
    return r;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new ta();
    return (r) => r.modified.indexOf(e) > -1 ? r : ta.get(r.base || r, r.modified.concat(e).sort((n, i) => n.id - i.id));
  }
}
let vO = 0;
class ta {
  constructor() {
    this.instances = [], this.id = vO++;
  }
  static get(e, r) {
    if (!r.length)
      return e;
    let n = r[0].instances.find((a) => a.base == e && bO(r, a.modified));
    if (n)
      return n;
    let i = [], s = new Xt(i, e, r);
    for (let a of r)
      a.instances.push(s);
    let o = DO(r);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of o)
          i.push(ta.get(a, l));
    return s;
  }
}
function bO(t, e) {
  return t.length == e.length && t.every((r, n) => r == e[n]);
}
function DO(t) {
  let e = [[]];
  for (let r = 0; r < t.length; r++)
    for (let n = 0, i = e.length; n < i; n++)
      e.push(e[n].concat(t[r]));
  return e.sort((r, n) => n.length - r.length);
}
function wO(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let n = t[r];
    Array.isArray(n) || (n = [n]);
    for (let i of r.split(" "))
      if (i) {
        let s = [], o = 2, a = i;
        for (let h = 0; ; ) {
          if (a == "..." && h > 0 && h + 3 == i.length) {
            o = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!f)
            throw new RangeError("Invalid path: " + i);
          if (s.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), h += f[0].length, h == i.length)
            break;
          let d = i[h++];
          if (h == i.length && d == "!") {
            o = 0;
            break;
          }
          if (d != "/")
            throw new RangeError("Invalid path: " + i);
          a = i.slice(h);
        }
        let l = s.length - 1, c = s[l];
        if (!c)
          throw new RangeError("Invalid path: " + i);
        let u = new ra(n, o, l > 0 ? s.slice(0, l) : null);
        e[c] = u.sort(e[c]);
      }
  }
  return p1.add(e);
}
const p1 = new te();
class ra {
  constructor(e, r, n, i) {
    this.tags = e, this.mode = r, this.context = n, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
ra.empty = new ra([], 2, null);
function m1(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let s of t)
    if (!Array.isArray(s.tag))
      r[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        r[o.id] = s.class;
  let { scope: n, all: i = null } = e || {};
  return {
    style: (s) => {
      let o = i;
      for (let a of s)
        for (let l of a.set) {
          let c = r[l.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: n
  };
}
function xO(t, e) {
  let r = null;
  for (let n of t) {
    let i = n.style(e);
    i && (r = r ? r + " " + i : i);
  }
  return r;
}
function CO(t, e, r, n = 0, i = t.length) {
  let s = new kO(n, Array.isArray(e) ? e : [e], r);
  s.highlightRange(t.cursor(), n, i, "", s.highlighters), s.flush(i);
}
class kO {
  constructor(e, r, n) {
    this.at = e, this.highlighters = r, this.span = n, this.class = "";
  }
  startSpan(e, r) {
    r != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = r);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, r, n, i, s) {
    let { type: o, from: a, to: l } = e;
    if (a >= n || l <= r)
      return;
    o.isTop && (s = this.highlighters.filter((d) => !d.scope || d.scope(o)));
    let c = i, u = SO(e) || ra.empty, h = xO(s, u.tags);
    if (h && (c && (c += " "), c += h, u.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(Math.max(r, a), c), u.opaque)
      return;
    let f = e.tree && e.tree.prop(te.mounted);
    if (f && f.overlay) {
      let d = e.node.enter(f.overlay[0].from + a, 1), p = this.highlighters.filter((y) => !y.scope || y.scope(f.tree.type)), m = e.firstChild();
      for (let y = 0, v = a; ; y++) {
        let g = y < f.overlay.length ? f.overlay[y] : null, b = g ? g.from + a : l, w = Math.max(r, v), D = Math.min(n, b);
        if (w < D && m)
          for (; e.from < D && (this.highlightRange(e, w, D, i, s), this.startSpan(Math.min(D, e.to), c), !(e.to >= b || !e.nextSibling())); )
            ;
        if (!g || b > n)
          break;
        v = g.to + a, v > r && (this.highlightRange(d.cursor(), Math.max(r, g.from + a), Math.min(n, v), "", p), this.startSpan(Math.min(n, v), c));
      }
      m && e.parent();
    } else if (e.firstChild()) {
      f && (i = "");
      do
        if (!(e.to <= r)) {
          if (e.from >= n)
            break;
          this.highlightRange(e, r, n, i, s), this.startSpan(Math.min(n, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function SO(t) {
  let e = t.type.prop(p1);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const W = Xt.define, fo = W(), Mr = W(), fp = W(Mr), dp = W(Mr), Lr = W(), po = W(Lr), Hl = W(Lr), Jt = W(), on = W(Jt), Gt = W(), Kt = W(), oc = W(), Li = W(oc), mo = W(), T = {
  /**
  A comment.
  */
  comment: fo,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: W(fo),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: W(fo),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: W(fo),
  /**
  Any kind of identifier.
  */
  name: Mr,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: W(Mr),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: fp,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: W(fp),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: dp,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: W(dp),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: W(Mr),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: W(Mr),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: W(Mr),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: W(Mr),
  /**
  A literal value.
  */
  literal: Lr,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: po,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: W(po),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: W(po),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: W(po),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Hl,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: W(Hl),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: W(Hl),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: W(Lr),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: W(Lr),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: W(Lr),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: W(Lr),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: W(Lr),
  /**
  A language keyword.
  */
  keyword: Gt,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: W(Gt),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: W(Gt),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: W(Gt),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: W(Gt),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: W(Gt),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: W(Gt),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: W(Gt),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: W(Gt),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: W(Gt),
  /**
  An operator.
  */
  operator: Kt,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: W(Kt),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: W(Kt),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: W(Kt),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: W(Kt),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: W(Kt),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: W(Kt),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: W(Kt),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: W(Kt),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: W(Kt),
  /**
  Program or markup punctuation.
  */
  punctuation: oc,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: W(oc),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Li,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: W(Li),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: W(Li),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: W(Li),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: W(Li),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Jt,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: on,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: W(on),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: W(on),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: W(on),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: W(on),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: W(on),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: W(on),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: W(Jt),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: W(Jt),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: W(Jt),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: W(Jt),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: W(Jt),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: W(Jt),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: W(Jt),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: W(Jt),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: W(),
  /**
  Deleted text.
  */
  deleted: W(),
  /**
  Changed text.
  */
  changed: W(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: W(),
  /**
  Metadata or meta-instruction.
  */
  meta: mo,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: W(mo),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: W(mo),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: W(mo),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Xt.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Xt.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Xt.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Xt.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Xt.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Xt.defineModifier()
};
m1([
  { tag: T.link, class: "tok-link" },
  { tag: T.heading, class: "tok-heading" },
  { tag: T.emphasis, class: "tok-emphasis" },
  { tag: T.strong, class: "tok-strong" },
  { tag: T.keyword, class: "tok-keyword" },
  { tag: T.atom, class: "tok-atom" },
  { tag: T.bool, class: "tok-bool" },
  { tag: T.url, class: "tok-url" },
  { tag: T.labelName, class: "tok-labelName" },
  { tag: T.inserted, class: "tok-inserted" },
  { tag: T.deleted, class: "tok-deleted" },
  { tag: T.literal, class: "tok-literal" },
  { tag: T.string, class: "tok-string" },
  { tag: T.number, class: "tok-number" },
  { tag: [T.regexp, T.escape, T.special(T.string)], class: "tok-string2" },
  { tag: T.variableName, class: "tok-variableName" },
  { tag: T.local(T.variableName), class: "tok-variableName tok-local" },
  { tag: T.definition(T.variableName), class: "tok-variableName tok-definition" },
  { tag: T.special(T.variableName), class: "tok-variableName2" },
  { tag: T.definition(T.propertyName), class: "tok-propertyName tok-definition" },
  { tag: T.typeName, class: "tok-typeName" },
  { tag: T.namespace, class: "tok-namespace" },
  { tag: T.className, class: "tok-className" },
  { tag: T.macroName, class: "tok-macroName" },
  { tag: T.propertyName, class: "tok-propertyName" },
  { tag: T.operator, class: "tok-operator" },
  { tag: T.comment, class: "tok-comment" },
  { tag: T.meta, class: "tok-meta" },
  { tag: T.invalid, class: "tok-invalid" },
  { tag: T.punctuation, class: "tok-punctuation" }
]);
var Vl;
const Vi = /* @__PURE__ */ new te(), EO = /* @__PURE__ */ new te();
class er {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, r, n = [], i = "") {
    this.data = e, this.name = i, ee.prototype.hasOwnProperty("tree") || Object.defineProperty(ee.prototype, "tree", { get() {
      return Ke(this);
    } }), this.parser = r, this.extension = [
      Qr.of(this),
      ee.languageData.of((s, o, a) => {
        let l = pp(s, o, a), c = l.type.prop(Vi);
        if (!c)
          return [];
        let u = s.facet(c), h = l.type.prop(EO);
        if (h) {
          let f = l.resolve(o - l.from, a);
          for (let d of h)
            if (d.test(f, s)) {
              let p = s.facet(d.facet);
              return d.type == "replace" ? p : p.concat(u);
            }
        }
        return u;
      })
    ].concat(n);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, r, n = -1) {
    return pp(e, r, n).type.prop(Vi) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let r = e.facet(Qr);
    if ((r == null ? void 0 : r.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!r || !r.allowsNesting)
      return [];
    let n = [], i = (s, o) => {
      if (s.prop(Vi) == this.data) {
        n.push({ from: o, to: o + s.length });
        return;
      }
      let a = s.prop(te.mounted);
      if (a) {
        if (a.tree.prop(Vi) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              n.push({ from: l.from + o, to: l.to + o });
          else
            n.push({ from: o, to: o + s.length });
          return;
        } else if (a.overlay) {
          let l = n.length;
          if (i(a.tree, a.overlay[0].from + o), n.length > l)
            return;
        }
      }
      for (let l = 0; l < s.children.length; l++) {
        let c = s.children[l];
        c instanceof Ue && i(c, s.positions[l] + o);
      }
    };
    return i(Ke(e), 0), n;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
er.setState = /* @__PURE__ */ J.define();
function pp(t, e, r) {
  let n = t.facet(Qr), i = Ke(t).topNode;
  if (!n || n.allowsNesting)
    for (let s = i; s; s = s.enter(e, r, Pe.ExcludeBuffers))
      s.type.isTop && (i = s);
  return i;
}
function Ke(t) {
  let e = t.field(er.state, !1);
  return e ? e.tree : Ue.empty;
}
class AO {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, r) {
    let n = this.cursorPos - this.string.length;
    return e < n || r >= this.cursorPos ? this.doc.sliceString(e, r) : this.string.slice(e - n, r - n);
  }
}
let Pi = null;
class na {
  constructor(e, r, n = [], i, s, o, a, l) {
    this.parser = e, this.state = r, this.fragments = n, this.tree = i, this.treeLen = s, this.viewport = o, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new na(e, r, [], Ue.empty, 0, n, [], null);
  }
  startParse() {
    return this.parser.startParse(new AO(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, r) {
    return r != null && r >= this.state.doc.length && (r = void 0), this.tree != Ue.empty && this.isDone(r ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var n;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), r != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > r) && r < this.state.doc.length && this.parse.stopAt(r); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(vn.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (n = this.parse.stoppedAt) !== null && n !== void 0 ? n : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (r ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, r;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(r = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = r, this.fragments = this.withoutTempSkipped(vn.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let r = Pi;
    Pi = this;
    try {
      return e();
    } finally {
      Pi = r;
    }
  }
  withoutTempSkipped(e) {
    for (let r; r = this.tempSkipped.pop(); )
      e = mp(e, r.from, r.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, r) {
    let { fragments: n, tree: i, treeLen: s, viewport: o, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((c, u, h, f) => l.push({ fromA: c, toA: u, fromB: h, toB: f })), n = vn.applyChanges(n, l), i = Ue.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        a = [];
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1), h = e.mapPos(c.to, -1);
          u < h && a.push({ from: u, to: h });
        }
      }
    }
    return new na(this.parser, r, n, i, s, o, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let r = this.skipped.length;
    for (let n = 0; n < this.skipped.length; n++) {
      let { from: i, to: s } = this.skipped[n];
      i < e.to && s > e.from && (this.fragments = mp(this.fragments, i, s), this.skipped.splice(n--, 1));
    }
    return this.skipped.length >= r ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, r) {
    this.skipped.push({ from: e, to: r });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends mO {
      createParse(r, n, i) {
        let s = i[0].from, o = i[i.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let l = Pi;
            if (l) {
              for (let c of i)
                l.tempSkipped.push(c);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new Ue(Ot.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let r = this.fragments;
    return this.treeLen >= e && r.length && r[0].from == 0 && r[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Pi;
  }
}
function mp(t, e, r) {
  return vn.applyChanges(t, [{ fromA: e, toA: r, fromB: e, toB: r }]);
}
class hi {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let r = this.context.changes(e.changes, e.state), n = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), r.viewport.to);
    return r.work(20, n) || r.takeTree(), new hi(r);
  }
  static init(e) {
    let r = Math.min(3e3, e.doc.length), n = na.create(e.facet(Qr).parser, e, { from: 0, to: r });
    return n.work(20, r) || n.takeTree(), new hi(n);
  }
}
er.state = /* @__PURE__ */ We.define({
  create: hi.init,
  update(t, e) {
    for (let r of e.effects)
      if (r.is(er.setState))
        return r.value;
    return e.startState.facet(Qr) != e.state.facet(Qr) ? hi.init(e.state) : t.apply(e);
  }
});
let g1 = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (g1 = (t) => {
  let e = -1, r = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(r) : cancelIdleCallback(e);
});
const zl = typeof navigator < "u" && (!((Vl = navigator.scheduling) === null || Vl === void 0) && Vl.isInputPending) ? () => navigator.scheduling.isInputPending() : null, FO = /* @__PURE__ */ Ee.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let r = this.view.state.field(er.state).context;
    (r.updateViewport(e.view.viewport) || this.view.viewport.to > r.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(r);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, r = e.field(er.state);
    (r.tree != r.context.tree || !r.context.isDone(e.doc.length)) && (this.working = g1(this.work));
  }
  work(e) {
    this.working = null;
    let r = Date.now();
    if (this.chunkEnd < r && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = r + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: n, viewport: { to: i } } = this.view, s = n.field(er.state);
    if (s.tree == s.context.tree && s.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !zl ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = s.context.treeLen < i && n.doc.length > i + 1e3, l = s.context.work(() => zl && zl() || Date.now() > o, i + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - r, (l || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: er.setState.of(new hi(s.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((r) => At(this.view.state, r)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Qr = /* @__PURE__ */ z.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    er.state,
    FO,
    H.contentAttributes.compute([t], (e) => {
      let r = e.facet(t);
      return r && r.name ? { "data-language": r.name } : {};
    })
  ]
}), TO = /* @__PURE__ */ z.define(), tl = /* @__PURE__ */ z.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((r) => r != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function ia(t) {
  let e = t.facet(tl);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function gs(t, e) {
  let r = "", n = t.tabSize, i = t.facet(tl)[0];
  if (i == "	") {
    for (; e >= n; )
      r += "	", e -= n;
    i = " ";
  }
  for (let s = 0; s < e; s++)
    r += i;
  return r;
}
function Ih(t, e) {
  t instanceof ee && (t = new rl(t));
  for (let n of t.state.facet(TO)) {
    let i = n(t, e);
    if (i !== void 0)
      return i;
  }
  let r = Ke(t.state);
  return r.length >= e ? BO(t, r, e) : null;
}
class rl {
  /**
  Create an indent context.
  */
  constructor(e, r = {}) {
    this.state = e, this.options = r, this.unit = ia(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, r = 1) {
    let n = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: s } = this.options;
    return i != null && i >= n.from && i <= n.to ? s && i == e ? { text: "", from: e } : (r < 0 ? i < e : i <= e) ? { text: n.text.slice(i - n.from), from: i } : { text: n.text.slice(0, i - n.from), from: n.from } : n;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, r = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: n, from: i } = this.lineAt(e, r);
    return n.slice(e - i, Math.min(n.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, r = 1) {
    let { text: n, from: i } = this.lineAt(e, r), s = this.countColumn(n, e - i), o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return o > -1 && (s += o - this.countColumn(n, n.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, r = e.length) {
    return wi(e, this.state.tabSize, r);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, r = 1) {
    let { text: n, from: i } = this.lineAt(e, r), s = this.options.overrideIndentation;
    if (s) {
      let o = s(i);
      if (o > -1)
        return o;
    }
    return this.countColumn(n, n.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const _O = /* @__PURE__ */ new te();
function BO(t, e, r) {
  let n = e.resolveStack(r), i = n.node.enterUnfinishedNodesBefore(r);
  if (i != n.node) {
    let s = [];
    for (let o = i; o != n.node; o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      n = { node: s[o], next: n };
  }
  return y1(n, t, r);
}
function y1(t, e, r) {
  for (let n = t; n; n = n.next) {
    let i = MO(n.node);
    if (i)
      return i($h.create(e, r, n));
  }
  return 0;
}
function OO(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function MO(t) {
  let e = t.type.prop(_O);
  if (e)
    return e;
  let r = t.firstChild, n;
  if (r && (n = r.type.prop(te.closedBy))) {
    let i = t.lastChild, s = i && n.indexOf(i.name) > -1;
    return (o) => RO(o, !0, 1, void 0, s && !OO(o) ? i.from : void 0);
  }
  return t.parent == null ? LO : null;
}
function LO() {
  return 0;
}
class $h extends rl {
  constructor(e, r, n) {
    super(e.state, e.options), this.base = e, this.pos = r, this.context = n;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new $h(e, r, n);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let r = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let n = e.resolve(r.from);
      for (; n.parent && n.parent.from == n.from; )
        n = n.parent;
      if (PO(n, e))
        break;
      r = this.state.doc.lineAt(n.from);
    }
    return this.lineIndent(r.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return y1(this.context.next, this.base, this.pos);
  }
}
function PO(t, e) {
  for (let r = e; r; r = r.parent)
    if (t == r)
      return !0;
  return !1;
}
function NO(t) {
  let e = t.node, r = e.childAfter(e.from), n = e.lastChild;
  if (!r)
    return null;
  let i = t.options.simulateBreak, s = t.state.doc.lineAt(r.from), o = i == null || i <= s.from ? s.to : Math.min(s.to, i);
  for (let a = r.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == n)
      return null;
    if (!l.type.isSkipped)
      return l.from < o ? r : null;
    a = l.to;
  }
}
function RO(t, e, r, n, i) {
  let s = t.textAfter, o = s.match(/^\s*/)[0].length, a = n && s.slice(o, o + n.length) == n || i == t.pos + o, l = e ? NO(t) : null;
  return l ? a ? t.column(l.from) : t.column(l.to) : t.baseIndent + (a ? 0 : t.unit * r);
}
const IO = 200;
function $O() {
  return ee.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let r = t.newDoc, { head: n } = t.newSelection.main, i = r.lineAt(n);
    if (n > i.from + IO)
      return t;
    let s = r.sliceString(i.from, n);
    if (!e.some((c) => c.test(s)))
      return t;
    let { state: o } = t, a = -1, l = [];
    for (let { head: c } of o.selection.ranges) {
      let u = o.doc.lineAt(c);
      if (u.from == a)
        continue;
      a = u.from;
      let h = Ih(o, u.from);
      if (h == null)
        continue;
      let f = /^\s*/.exec(u.text)[0], d = gs(o, h);
      f != d && l.push({ from: u.from, to: u.from + f.length, insert: d });
    }
    return l.length ? [t, { changes: l, sequential: !0 }] : t;
  });
}
const jO = /* @__PURE__ */ z.define(), WO = /* @__PURE__ */ new te();
function qO(t, e, r) {
  let n = Ke(t);
  if (n.length < r)
    return null;
  let i = n.resolveStack(r, 1), s = null;
  for (let o = i; o; o = o.next) {
    let a = o.node;
    if (a.to <= r || a.from > r)
      continue;
    if (s && a.from < e)
      break;
    let l = a.type.prop(WO);
    if (l && (a.to < n.length - 50 || n.length == t.doc.length || !HO(a))) {
      let c = l(a, t);
      c && c.from <= r && c.from >= e && c.to > r && (s = c);
    }
  }
  return s;
}
function HO(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function sa(t, e, r) {
  for (let n of t.facet(jO)) {
    let i = n(t, e, r);
    if (i)
      return i;
  }
  return qO(t, e, r);
}
function v1(t, e) {
  let r = e.mapPos(t.from, 1), n = e.mapPos(t.to, -1);
  return r >= n ? void 0 : { from: r, to: n };
}
const nl = /* @__PURE__ */ J.define({ map: v1 }), Rs = /* @__PURE__ */ J.define({ map: v1 });
function b1(t) {
  let e = [];
  for (let { head: r } of t.state.selection.ranges)
    e.some((n) => n.from <= r && n.to >= r) || e.push(t.lineBlockAt(r));
  return e;
}
const En = /* @__PURE__ */ We.define({
  create() {
    return K.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let r of e.effects)
      if (r.is(nl) && !VO(t, r.value.from, r.value.to)) {
        let { preparePlaceholder: n } = e.state.facet(jh), i = n ? K.replace({ widget: new XO(n(e.state, r.value)) }) : gp;
        t = t.update({ add: [i.range(r.value.from, r.value.to)] });
      } else
        r.is(Rs) && (t = t.update({
          filter: (n, i) => r.value.from != n || r.value.to != i,
          filterFrom: r.value.from,
          filterTo: r.value.to
        }));
    if (e.selection) {
      let r = !1, { head: n } = e.selection.main;
      t.between(n, n, (i, s) => {
        i < n && s > n && (r = !0);
      }), r && (t = t.update({
        filterFrom: n,
        filterTo: n,
        filter: (i, s) => s <= n || i >= n
      }));
    }
    return t;
  },
  provide: (t) => H.decorations.from(t),
  toJSON(t, e) {
    let r = [];
    return t.between(0, e.doc.length, (n, i) => {
      r.push(n, i);
    }), r;
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let r = 0; r < t.length; ) {
      let n = t[r++], i = t[r++];
      if (typeof n != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(gp.range(n, i));
    }
    return K.set(e, !0);
  }
});
function oa(t, e, r) {
  var n;
  let i = null;
  return (n = t.field(En, !1)) === null || n === void 0 || n.between(e, r, (s, o) => {
    (!i || i.from > s) && (i = { from: s, to: o });
  }), i;
}
function VO(t, e, r) {
  let n = !1;
  return t.between(e, e, (i, s) => {
    i == e && s == r && (n = !0);
  }), n;
}
function D1(t, e) {
  return t.field(En, !1) ? e : e.concat(J.appendConfig.of(x1()));
}
const zO = (t) => {
  for (let e of b1(t)) {
    let r = sa(t.state, e.from, e.to);
    if (r)
      return t.dispatch({ effects: D1(t.state, [nl.of(r), w1(t, r)]) }), !0;
  }
  return !1;
}, UO = (t) => {
  if (!t.state.field(En, !1))
    return !1;
  let e = [];
  for (let r of b1(t)) {
    let n = oa(t.state, r.from, r.to);
    n && e.push(Rs.of(n), w1(t, n, !1));
  }
  return e.length && t.dispatch({ effects: e }), e.length > 0;
};
function w1(t, e, r = !0) {
  let n = t.state.doc.lineAt(e.from).number, i = t.state.doc.lineAt(e.to).number;
  return H.announce.of(`${t.state.phrase(r ? "Folded lines" : "Unfolded lines")} ${n} ${t.state.phrase("to")} ${i}.`);
}
const GO = (t) => {
  let { state: e } = t, r = [];
  for (let n = 0; n < e.doc.length; ) {
    let i = t.lineBlockAt(n), s = sa(e, i.from, i.to);
    s && r.push(nl.of(s)), n = (s ? t.lineBlockAt(s.to) : i).to + 1;
  }
  return r.length && t.dispatch({ effects: D1(t.state, r) }), !!r.length;
}, KO = (t) => {
  let e = t.state.field(En, !1);
  if (!e || !e.size)
    return !1;
  let r = [];
  return e.between(0, t.state.doc.length, (n, i) => {
    r.push(Rs.of({ from: n, to: i }));
  }), t.dispatch({ effects: r }), !0;
}, YO = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: zO },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: UO },
  { key: "Ctrl-Alt-[", run: GO },
  { key: "Ctrl-Alt-]", run: KO }
], JO = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, jh = /* @__PURE__ */ z.define({
  combine(t) {
    return ur(t, JO);
  }
});
function x1(t) {
  let e = [En, e3];
  return t && e.push(jh.of(t)), e;
}
function C1(t, e) {
  let { state: r } = t, n = r.facet(jh), i = (o) => {
    let a = t.lineBlockAt(t.posAtDOM(o.target)), l = oa(t.state, a.from, a.to);
    l && t.dispatch({ effects: Rs.of(l) }), o.preventDefault();
  };
  if (n.placeholderDOM)
    return n.placeholderDOM(t, i, e);
  let s = document.createElement("span");
  return s.textContent = n.placeholderText, s.setAttribute("aria-label", r.phrase("folded code")), s.title = r.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = i, s;
}
const gp = /* @__PURE__ */ K.replace({ widget: /* @__PURE__ */ new class extends Sr {
  toDOM(t) {
    return C1(t, null);
  }
}() });
class XO extends Sr {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return C1(e, this.value);
  }
}
const QO = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Ul extends yr {
  constructor(e, r) {
    super(), this.config = e, this.open = r;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let r = document.createElement("span");
    return r.textContent = this.open ? this.config.openText : this.config.closedText, r.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), r;
  }
}
function ZO(t = {}) {
  let e = Object.assign(Object.assign({}, QO), t), r = new Ul(e, !0), n = new Ul(e, !1), i = Ee.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(Qr) != o.state.facet(Qr) || o.startState.field(En, !1) != o.state.field(En, !1) || Ke(o.startState) != Ke(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let a = new Gr();
      for (let l of o.viewportLineBlocks) {
        let c = oa(o.state, l.from, l.to) ? n : sa(o.state, l.from, l.to) ? r : null;
        c && a.add(l.from, l.from, c);
      }
      return a.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    i,
    QB({
      class: "cm-foldGutter",
      markers(o) {
        var a;
        return ((a = o.plugin(i)) === null || a === void 0 ? void 0 : a.markers) || ie.empty;
      },
      initialSpacer() {
        return new Ul(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, s), { click: (o, a, l) => {
        if (s.click && s.click(o, a, l))
          return !0;
        let c = oa(o.state, a.from, a.to);
        if (c)
          return o.dispatch({ effects: Rs.of(c) }), !0;
        let u = sa(o.state, a.from, a.to);
        return u ? (o.dispatch({ effects: nl.of(u) }), !0) : !1;
      } })
    }),
    x1()
  ];
}
const e3 = /* @__PURE__ */ H.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Is {
  constructor(e, r) {
    this.specs = e;
    let n;
    function i(a) {
      let l = Kr.newName();
      return (n || (n = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const s = typeof r.all == "string" ? r.all : r.all ? i(r.all) : void 0, o = r.scope;
    this.scope = o instanceof er ? (a) => a.prop(Vi) == o.data : o ? (a) => a == o : void 0, this.style = m1(e.map((a) => ({
      tag: a.tag,
      class: a.class || i(Object.assign({}, a, { tag: null }))
    })), {
      all: s
    }).style, this.module = n ? new Kr(n) : null, this.themeType = r.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, r) {
    return new Is(e, r || {});
  }
}
const ac = /* @__PURE__ */ z.define(), k1 = /* @__PURE__ */ z.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function Gl(t) {
  let e = t.facet(ac);
  return e.length ? e : t.facet(k1);
}
function S1(t, e) {
  let r = [r3], n;
  return t instanceof Is && (t.module && r.push(H.styleModule.of(t.module)), n = t.themeType), e != null && e.fallback ? r.push(k1.of(t)) : n ? r.push(ac.computeN([H.darkTheme], (i) => i.facet(H.darkTheme) == (n == "dark") ? [t] : [])) : r.push(ac.of(t)), r;
}
class t3 {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Ke(e.state), this.decorations = this.buildDeco(e, Gl(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let r = Ke(e.state), n = Gl(e.state), i = n != Gl(e.startState), { viewport: s } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    r.length < s.to && !i && r.type == this.tree.type && o >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (r != this.tree || e.viewportChanged || i) && (this.tree = r, this.decorations = this.buildDeco(e.view, n), this.decoratedTo = s.to);
  }
  buildDeco(e, r) {
    if (!r || !this.tree.length)
      return K.none;
    let n = new Gr();
    for (let { from: i, to: s } of e.visibleRanges)
      CO(this.tree, r, (o, a, l) => {
        n.add(o, a, this.markCache[l] || (this.markCache[l] = K.mark({ class: l })));
      }, i, s);
    return n.finish();
  }
}
const r3 = /* @__PURE__ */ Di.high(/* @__PURE__ */ Ee.fromClass(t3, {
  decorations: (t) => t.decorations
})), n3 = /* @__PURE__ */ Is.define([
  {
    tag: T.meta,
    color: "#404740"
  },
  {
    tag: T.link,
    textDecoration: "underline"
  },
  {
    tag: T.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: T.emphasis,
    fontStyle: "italic"
  },
  {
    tag: T.strong,
    fontWeight: "bold"
  },
  {
    tag: T.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: T.keyword,
    color: "#708"
  },
  {
    tag: [T.atom, T.bool, T.url, T.contentSeparator, T.labelName],
    color: "#219"
  },
  {
    tag: [T.literal, T.inserted],
    color: "#164"
  },
  {
    tag: [T.string, T.deleted],
    color: "#a11"
  },
  {
    tag: [T.regexp, T.escape, /* @__PURE__ */ T.special(T.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ T.definition(T.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ T.local(T.variableName),
    color: "#30a"
  },
  {
    tag: [T.typeName, T.namespace],
    color: "#085"
  },
  {
    tag: T.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ T.special(T.variableName), T.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ T.definition(T.propertyName),
    color: "#00c"
  },
  {
    tag: T.comment,
    color: "#940"
  },
  {
    tag: T.invalid,
    color: "#f00"
  }
]), i3 = /* @__PURE__ */ H.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), E1 = 1e4, A1 = "()[]{}", F1 = /* @__PURE__ */ z.define({
  combine(t) {
    return ur(t, {
      afterCursor: !0,
      brackets: A1,
      maxScanDistance: E1,
      renderMatch: a3
    });
  }
}), s3 = /* @__PURE__ */ K.mark({ class: "cm-matchingBracket" }), o3 = /* @__PURE__ */ K.mark({ class: "cm-nonmatchingBracket" });
function a3(t) {
  let e = [], r = t.matched ? s3 : o3;
  return e.push(r.range(t.start.from, t.start.to)), t.end && e.push(r.range(t.end.from, t.end.to)), e;
}
const l3 = /* @__PURE__ */ We.define({
  create() {
    return K.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let r = [], n = e.state.facet(F1);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let s = tr(e.state, i.head, -1, n) || i.head > 0 && tr(e.state, i.head - 1, 1, n) || n.afterCursor && (tr(e.state, i.head, 1, n) || i.head < e.state.doc.length && tr(e.state, i.head + 1, -1, n));
      s && (r = r.concat(n.renderMatch(s, e.state)));
    }
    return K.set(r, !0);
  },
  provide: (t) => H.decorations.from(t)
}), u3 = [
  l3,
  i3
];
function c3(t = {}) {
  return [F1.of(t), u3];
}
const h3 = /* @__PURE__ */ new te();
function lc(t, e, r) {
  let n = t.prop(e < 0 ? te.openedBy : te.closedBy);
  if (n)
    return n;
  if (t.name.length == 1) {
    let i = r.indexOf(t.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [r[i + e]];
  }
  return null;
}
function uc(t) {
  let e = t.type.prop(h3);
  return e ? e(t.node) : t;
}
function tr(t, e, r, n = {}) {
  let i = n.maxScanDistance || E1, s = n.brackets || A1, o = Ke(t), a = o.resolveInner(e, r);
  for (let l = a; l; l = l.parent) {
    let c = lc(l.type, r, s);
    if (c && l.from < l.to) {
      let u = uc(l);
      if (u && (r > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
        return f3(t, e, r, l, u, c, s);
    }
  }
  return d3(t, e, r, o, a.type, i, s);
}
function f3(t, e, r, n, i, s, o) {
  let a = n.parent, l = { from: i.from, to: i.to }, c = 0, u = a == null ? void 0 : a.cursor();
  if (u && (r < 0 ? u.childBefore(n.from) : u.childAfter(n.to)))
    do
      if (r < 0 ? u.to <= n.from : u.from >= n.to) {
        if (c == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {
          let h = uc(u);
          return { start: l, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (lc(u.type, r, o))
          c++;
        else if (lc(u.type, -r, o)) {
          if (c == 0) {
            let h = uc(u);
            return {
              start: l,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (r < 0 ? u.prevSibling() : u.nextSibling());
  return { start: l, matched: !1 };
}
function d3(t, e, r, n, i, s, o) {
  let a = r < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), l = o.indexOf(a);
  if (l < 0 || l % 2 == 0 != r > 0)
    return null;
  let c = { from: r < 0 ? e - 1 : e, to: r > 0 ? e + 1 : e }, u = t.doc.iterRange(e, r > 0 ? t.doc.length : 0), h = 0;
  for (let f = 0; !u.next().done && f <= s; ) {
    let d = u.value;
    r < 0 && (f += d.length);
    let p = e + f * r;
    for (let m = r > 0 ? 0 : d.length - 1, y = r > 0 ? d.length : -1; m != y; m += r) {
      let v = o.indexOf(d[m]);
      if (!(v < 0 || n.resolveInner(p + m, 1).type != i))
        if (v % 2 == 0 == r > 0)
          h++;
        else {
          if (h == 1)
            return { start: c, end: { from: p + m, to: p + m + 1 }, matched: v >> 1 == l >> 1 };
          h--;
        }
    }
    r > 0 && (f += d.length);
  }
  return u.done ? { start: c, matched: !1 } : null;
}
const p3 = /* @__PURE__ */ Object.create(null), yp = [Ot.none], vp = [], bp = /* @__PURE__ */ Object.create(null), m3 = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  m3[t] = /* @__PURE__ */ g3(p3, e);
function Kl(t, e) {
  vp.indexOf(t) > -1 || (vp.push(t), console.warn(e));
}
function g3(t, e) {
  let r = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let c of a.split(".")) {
      let u = t[c] || T[c];
      u ? typeof u == "function" ? l.length ? l = l.map(u) : Kl(c, `Modifier ${c} used at start of tag`) : l.length ? Kl(c, `Tag ${c} used as modifier`) : l = Array.isArray(u) ? u : [u] : Kl(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l)
      r.push(c);
  }
  if (!r.length)
    return 0;
  let n = e.replace(/ /g, "_"), i = n + " " + r.map((a) => a.id), s = bp[i];
  if (s)
    return s.id;
  let o = bp[i] = Ot.define({
    id: yp.length,
    name: n,
    props: [wO({ [n]: r })]
  });
  return yp.push(o), o.id;
}
ye.RTL, ye.LTR;
const y3 = (t) => {
  let { state: e } = t, r = e.doc.lineAt(e.selection.main.from), n = qh(t.state, r.from);
  return n.line ? v3(t) : n.block ? D3(t) : !1;
};
function Wh(t, e) {
  return ({ state: r, dispatch: n }) => {
    if (r.readOnly)
      return !1;
    let i = t(e, r);
    return i ? (n(r.update(i)), !0) : !1;
  };
}
const v3 = /* @__PURE__ */ Wh(
  C3,
  0
  /* CommentOption.Toggle */
), b3 = /* @__PURE__ */ Wh(
  T1,
  0
  /* CommentOption.Toggle */
), D3 = /* @__PURE__ */ Wh(
  (t, e) => T1(t, e, x3(e)),
  0
  /* CommentOption.Toggle */
);
function qh(t, e) {
  let r = t.languageDataAt("commentTokens", e);
  return r.length ? r[0] : {};
}
const Ni = 50;
function w3(t, { open: e, close: r }, n, i) {
  let s = t.sliceDoc(n - Ni, n), o = t.sliceDoc(i, i + Ni), a = /\s*$/.exec(s)[0].length, l = /^\s*/.exec(o)[0].length, c = s.length - a;
  if (s.slice(c - e.length, c) == e && o.slice(l, l + r.length) == r)
    return {
      open: { pos: n - a, margin: a && 1 },
      close: { pos: i + l, margin: l && 1 }
    };
  let u, h;
  i - n <= 2 * Ni ? u = h = t.sliceDoc(n, i) : (u = t.sliceDoc(n, n + Ni), h = t.sliceDoc(i - Ni, i));
  let f = /^\s*/.exec(u)[0].length, d = /\s*$/.exec(h)[0].length, p = h.length - d - r.length;
  return u.slice(f, f + e.length) == e && h.slice(p, p + r.length) == r ? {
    open: {
      pos: n + f + e.length,
      margin: /\s/.test(u.charAt(f + e.length)) ? 1 : 0
    },
    close: {
      pos: i - d - r.length,
      margin: /\s/.test(h.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function x3(t) {
  let e = [];
  for (let r of t.selection.ranges) {
    let n = t.doc.lineAt(r.from), i = r.to <= n.to ? n : t.doc.lineAt(r.to), s = e.length - 1;
    s >= 0 && e[s].to > n.from ? e[s].to = i.to : e.push({ from: n.from + /^\s*/.exec(n.text)[0].length, to: i.to });
  }
  return e;
}
function T1(t, e, r = e.selection.ranges) {
  let n = r.map((s) => qh(e, s.from).block);
  if (!n.every((s) => s))
    return null;
  let i = r.map((s, o) => w3(e, n[o], s.from, s.to));
  if (t != 2 && !i.every((s) => s))
    return { changes: e.changes(r.map((s, o) => i[o] ? [] : [{ from: s.from, insert: n[o].open + " " }, { from: s.to, insert: " " + n[o].close }])) };
  if (t != 1 && i.some((s) => s)) {
    let s = [];
    for (let o = 0, a; o < i.length; o++)
      if (a = i[o]) {
        let l = n[o], { open: c, close: u } = a;
        s.push({ from: c.pos - l.open.length, to: c.pos + c.margin }, { from: u.pos - u.margin, to: u.pos + l.close.length });
      }
    return { changes: s };
  }
  return null;
}
function C3(t, e, r = e.selection.ranges) {
  let n = [], i = -1;
  for (let { from: s, to: o } of r) {
    let a = n.length, l = 1e9, c = qh(e, s).line;
    if (c) {
      for (let u = s; u <= o; ) {
        let h = e.doc.lineAt(u);
        if (h.from > i && (s == o || o > h.from)) {
          i = h.from;
          let f = /^\s*/.exec(h.text)[0].length, d = f == h.length, p = h.text.slice(f, f + c.length) == c ? f : -1;
          f < h.text.length && f < l && (l = f), n.push({ line: h, comment: p, token: c, indent: f, empty: d, single: !1 });
        }
        u = h.to + 1;
      }
      if (l < 1e9)
        for (let u = a; u < n.length; u++)
          n[u].indent < n[u].line.text.length && (n[u].indent = l);
      n.length == a + 1 && (n[a].single = !0);
    }
  }
  if (t != 2 && n.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: a, token: l, indent: c, empty: u, single: h } of n)
      (h || !u) && s.push({ from: a.from + c, insert: l + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (t != 1 && n.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: a, token: l } of n)
      if (a >= 0) {
        let c = o.from + a, u = c + l.length;
        o.text[u - o.from] == " " && u++, s.push({ from: c, to: u });
      }
    return { changes: s };
  }
  return null;
}
const cc = /* @__PURE__ */ lr.define(), k3 = /* @__PURE__ */ lr.define(), S3 = /* @__PURE__ */ z.define(), _1 = /* @__PURE__ */ z.define({
  combine(t) {
    return ur(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, r) => r
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, r) => (n, i) => e(n, i) || r(n, i)
    });
  }
}), B1 = /* @__PURE__ */ We.define({
  create() {
    return rr.empty;
  },
  update(t, e) {
    let r = e.state.facet(_1), n = e.annotation(cc);
    if (n) {
      let l = it.fromTransaction(e, n.selection), c = n.side, u = c == 0 ? t.undone : t.done;
      return l ? u = aa(u, u.length, r.minDepth, l) : u = L1(u, e.startState.selection), new rr(c == 0 ? n.rest : u, c == 0 ? u : n.rest);
    }
    let i = e.annotation(k3);
    if ((i == "full" || i == "before") && (t = t.isolate()), e.annotation(Te.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let s = it.fromTransaction(e), o = e.annotation(Te.time), a = e.annotation(Te.userEvent);
    return s ? t = t.addChanges(s, o, a, r, e) : e.selection && (t = t.addSelection(e.startState.selection, o, a, r.newGroupDelay)), (i == "full" || i == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new rr(t.done.map(it.fromJSON), t.undone.map(it.fromJSON));
  }
});
function E3(t = {}) {
  return [
    B1,
    _1.of(t),
    H.domEventHandlers({
      beforeinput(e, r) {
        let n = e.inputType == "historyUndo" ? O1 : e.inputType == "historyRedo" ? hc : null;
        return n ? (e.preventDefault(), n(r)) : !1;
      }
    })
  ];
}
function il(t, e) {
  return function({ state: r, dispatch: n }) {
    if (!e && r.readOnly)
      return !1;
    let i = r.field(B1, !1);
    if (!i)
      return !1;
    let s = i.pop(t, r, e);
    return s ? (n(s), !0) : !1;
  };
}
const O1 = /* @__PURE__ */ il(0, !1), hc = /* @__PURE__ */ il(1, !1), A3 = /* @__PURE__ */ il(0, !0), F3 = /* @__PURE__ */ il(1, !0);
class it {
  constructor(e, r, n, i, s) {
    this.changes = e, this.effects = r, this.mapped = n, this.startSelection = i, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new it(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, r, n;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (r = this.mapped) === null || r === void 0 ? void 0 : r.toJSON(),
      startSelection: (n = this.startSelection) === null || n === void 0 ? void 0 : n.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new it(e.changes && Fe.fromJSON(e.changes), [], e.mapped && nr.fromJSON(e.mapped), e.startSelection && B.fromJSON(e.startSelection), e.selectionsAfter.map(B.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, r) {
    let n = Et;
    for (let i of e.startState.facet(S3)) {
      let s = i(e);
      s.length && (n = n.concat(s));
    }
    return !n.length && e.changes.empty ? null : new it(e.changes.invert(e.startState.doc), n, void 0, r || e.startState.selection, Et);
  }
  static selection(e) {
    return new it(void 0, Et, void 0, void 0, e);
  }
}
function aa(t, e, r, n) {
  let i = e + 1 > r + 20 ? e - r - 1 : 0, s = t.slice(i, e);
  return s.push(n), s;
}
function T3(t, e) {
  let r = [], n = !1;
  return t.iterChangedRanges((i, s) => r.push(i, s)), e.iterChangedRanges((i, s, o, a) => {
    for (let l = 0; l < r.length; ) {
      let c = r[l++], u = r[l++];
      a >= c && o <= u && (n = !0);
    }
  }), n;
}
function _3(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((r, n) => r.empty != e.ranges[n].empty).length === 0;
}
function M1(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const Et = [], B3 = 200;
function L1(t, e) {
  if (t.length) {
    let r = t[t.length - 1], n = r.selectionsAfter.slice(Math.max(0, r.selectionsAfter.length - B3));
    return n.length && n[n.length - 1].eq(e) ? t : (n.push(e), aa(t, t.length - 1, 1e9, r.setSelAfter(n)));
  } else
    return [it.selection([e])];
}
function O3(t) {
  let e = t[t.length - 1], r = t.slice();
  return r[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), r;
}
function Yl(t, e) {
  if (!t.length)
    return t;
  let r = t.length, n = Et;
  for (; r; ) {
    let i = M3(t[r - 1], e, n);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let s = t.slice(0, r);
      return s[r - 1] = i, s;
    } else
      e = i.mapped, r--, n = i.selectionsAfter;
  }
  return n.length ? [it.selection(n)] : Et;
}
function M3(t, e, r) {
  let n = M1(t.selectionsAfter.length ? t.selectionsAfter.map((a) => a.map(e)) : Et, r);
  if (!t.changes)
    return it.selection(n);
  let i = t.changes.map(e), s = e.mapDesc(t.changes, !0), o = t.mapped ? t.mapped.composeDesc(s) : s;
  return new it(i, J.mapEffects(t.effects, e), o, t.startSelection.map(s), n);
}
const L3 = /^(input\.type|delete)($|\.)/;
class rr {
  constructor(e, r, n = 0, i = void 0) {
    this.done = e, this.undone = r, this.prevTime = n, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new rr(this.done, this.undone) : this;
  }
  addChanges(e, r, n, i, s) {
    let o = this.done, a = o[o.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!n || L3.test(n)) && (!a.selectionsAfter.length && r - this.prevTime < i.newGroupDelay && i.joinToEvent(s, T3(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    n == "input.type.compose") ? o = aa(o, o.length - 1, i.minDepth, new it(e.changes.compose(a.changes), M1(e.effects, a.effects), a.mapped, a.startSelection, Et)) : o = aa(o, o.length, i.minDepth, e), new rr(o, Et, r, n);
  }
  addSelection(e, r, n, i) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Et;
    return s.length > 0 && r - this.prevTime < i && n == this.prevUserEvent && n && /^select($|\.)/.test(n) && _3(s[s.length - 1], e) ? this : new rr(L1(this.done, e), this.undone, r, n);
  }
  addMapping(e) {
    return new rr(Yl(this.done, e), Yl(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, r, n) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let s = i[i.length - 1], o = s.selectionsAfter[0] || r.selection;
    if (n && s.selectionsAfter.length)
      return r.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: cc.of({ side: e, rest: O3(i), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let a = i.length == 1 ? Et : i.slice(0, i.length - 1);
      return s.mapped && (a = Yl(a, s.mapped)), r.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: cc.of({ side: e, rest: a, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
rr.empty = /* @__PURE__ */ new rr(Et, Et);
const P3 = [
  { key: "Mod-z", run: O1, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: hc, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: hc, preventDefault: !0 },
  { key: "Mod-u", run: A3, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: F3, preventDefault: !0 }
];
function xi(t, e) {
  return B.create(t.ranges.map(e), t.mainIndex);
}
function cr(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Wt({ state: t, dispatch: e }, r) {
  let n = xi(t.selection, r);
  return n.eq(t.selection, !0) ? !1 : (e(cr(t, n)), !0);
}
function sl(t, e) {
  return B.cursor(e ? t.to : t.from);
}
function P1(t, e) {
  return Wt(t, (r) => r.empty ? t.moveByChar(r, e) : sl(r, e));
}
function Ye(t) {
  return t.textDirectionAt(t.state.selection.main.head) == ye.LTR;
}
const N1 = (t) => P1(t, !Ye(t)), R1 = (t) => P1(t, Ye(t));
function I1(t, e) {
  return Wt(t, (r) => r.empty ? t.moveByGroup(r, e) : sl(r, e));
}
const N3 = (t) => I1(t, !Ye(t)), R3 = (t) => I1(t, Ye(t));
function I3(t, e, r) {
  if (e.type.prop(r))
    return !0;
  let n = e.to - e.from;
  return n && (n > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function ol(t, e, r) {
  let n = Ke(t).resolveInner(e.head), i = r ? te.closedBy : te.openedBy;
  for (let l = e.head; ; ) {
    let c = r ? n.childAfter(l) : n.childBefore(l);
    if (!c)
      break;
    I3(t, c, i) ? n = c : l = r ? c.to : c.from;
  }
  let s = n.type.prop(i), o, a;
  return s && (o = r ? tr(t, n.from, 1) : tr(t, n.to, -1)) && o.matched ? a = r ? o.end.to : o.end.from : a = r ? n.to : n.from, B.cursor(a, r ? -1 : 1);
}
const $3 = (t) => Wt(t, (e) => ol(t.state, e, !Ye(t))), j3 = (t) => Wt(t, (e) => ol(t.state, e, Ye(t)));
function $1(t, e) {
  return Wt(t, (r) => {
    if (!r.empty)
      return sl(r, e);
    let n = t.moveVertically(r, e);
    return n.head != r.head ? n : t.moveToLineBoundary(r, e);
  });
}
const j1 = (t) => $1(t, !1), W1 = (t) => $1(t, !0);
function q1(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, r = 0, n = 0, i;
  if (e) {
    for (let s of t.state.facet(H.scrollMargins)) {
      let o = s(t);
      o != null && o.top && (r = Math.max(o == null ? void 0 : o.top, r)), o != null && o.bottom && (n = Math.max(o == null ? void 0 : o.bottom, n));
    }
    i = t.scrollDOM.clientHeight - r - n;
  } else
    i = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: r,
    marginBottom: n,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, i - 5)
  };
}
function H1(t, e) {
  let r = q1(t), { state: n } = t, i = xi(n.selection, (o) => o.empty ? t.moveVertically(o, e, r.height) : sl(o, e));
  if (i.eq(n.selection))
    return !1;
  let s;
  if (r.selfScroll) {
    let o = t.coordsAtPos(n.selection.main.head), a = t.scrollDOM.getBoundingClientRect(), l = a.top + r.marginTop, c = a.bottom - r.marginBottom;
    o && o.top > l && o.bottom < c && (s = H.scrollIntoView(i.main.head, { y: "start", yMargin: o.top - l }));
  }
  return t.dispatch(cr(n, i), { effects: s }), !0;
}
const Dp = (t) => H1(t, !1), fc = (t) => H1(t, !0);
function tn(t, e, r) {
  let n = t.lineBlockAt(e.head), i = t.moveToLineBoundary(e, r);
  if (i.head == e.head && i.head != (r ? n.to : n.from) && (i = t.moveToLineBoundary(e, r, !1)), !r && i.head == n.from && n.length) {
    let s = /^\s*/.exec(t.state.sliceDoc(n.from, Math.min(n.from + 100, n.to)))[0].length;
    s && e.head != n.from + s && (i = B.cursor(n.from + s));
  }
  return i;
}
const W3 = (t) => Wt(t, (e) => tn(t, e, !0)), q3 = (t) => Wt(t, (e) => tn(t, e, !1)), H3 = (t) => Wt(t, (e) => tn(t, e, !Ye(t))), V3 = (t) => Wt(t, (e) => tn(t, e, Ye(t))), z3 = (t) => Wt(t, (e) => B.cursor(t.lineBlockAt(e.head).from, 1)), U3 = (t) => Wt(t, (e) => B.cursor(t.lineBlockAt(e.head).to, -1));
function G3(t, e, r) {
  let n = !1, i = xi(t.selection, (s) => {
    let o = tr(t, s.head, -1) || tr(t, s.head, 1) || s.head > 0 && tr(t, s.head - 1, 1) || s.head < t.doc.length && tr(t, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    n = !0;
    let a = o.start.from == s.head ? o.end.to : o.end.from;
    return r ? B.range(s.anchor, a) : B.cursor(a);
  });
  return n ? (e(cr(t, i)), !0) : !1;
}
const K3 = ({ state: t, dispatch: e }) => G3(t, e, !1);
function Mt(t, e) {
  let r = xi(t.state.selection, (n) => {
    let i = e(n);
    return B.range(n.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return r.eq(t.state.selection) ? !1 : (t.dispatch(cr(t.state, r)), !0);
}
function V1(t, e) {
  return Mt(t, (r) => t.moveByChar(r, e));
}
const z1 = (t) => V1(t, !Ye(t)), U1 = (t) => V1(t, Ye(t));
function G1(t, e) {
  return Mt(t, (r) => t.moveByGroup(r, e));
}
const Y3 = (t) => G1(t, !Ye(t)), J3 = (t) => G1(t, Ye(t)), X3 = (t) => Mt(t, (e) => ol(t.state, e, !Ye(t))), Q3 = (t) => Mt(t, (e) => ol(t.state, e, Ye(t)));
function K1(t, e) {
  return Mt(t, (r) => t.moveVertically(r, e));
}
const Y1 = (t) => K1(t, !1), J1 = (t) => K1(t, !0);
function X1(t, e) {
  return Mt(t, (r) => t.moveVertically(r, e, q1(t).height));
}
const wp = (t) => X1(t, !1), xp = (t) => X1(t, !0), Z3 = (t) => Mt(t, (e) => tn(t, e, !0)), eM = (t) => Mt(t, (e) => tn(t, e, !1)), tM = (t) => Mt(t, (e) => tn(t, e, !Ye(t))), rM = (t) => Mt(t, (e) => tn(t, e, Ye(t))), nM = (t) => Mt(t, (e) => B.cursor(t.lineBlockAt(e.head).from)), iM = (t) => Mt(t, (e) => B.cursor(t.lineBlockAt(e.head).to)), Cp = ({ state: t, dispatch: e }) => (e(cr(t, { anchor: 0 })), !0), kp = ({ state: t, dispatch: e }) => (e(cr(t, { anchor: t.doc.length })), !0), Sp = ({ state: t, dispatch: e }) => (e(cr(t, { anchor: t.selection.main.anchor, head: 0 })), !0), Ep = ({ state: t, dispatch: e }) => (e(cr(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), sM = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), oM = ({ state: t, dispatch: e }) => {
  let r = al(t).map(({ from: n, to: i }) => B.range(n, Math.min(i + 1, t.doc.length)));
  return e(t.update({ selection: B.create(r), userEvent: "select" })), !0;
}, aM = ({ state: t, dispatch: e }) => {
  let r = xi(t.selection, (n) => {
    var i;
    let s = Ke(t).resolveStack(n.from, 1);
    for (let o = s; o; o = o.next) {
      let { node: a } = o;
      if ((a.from < n.from && a.to >= n.to || a.to > n.to && a.from <= n.from) && (!((i = a.parent) === null || i === void 0) && i.parent))
        return B.range(a.to, a.from);
    }
    return n;
  });
  return e(cr(t, r)), !0;
}, lM = ({ state: t, dispatch: e }) => {
  let r = t.selection, n = null;
  return r.ranges.length > 1 ? n = B.create([r.main]) : r.main.empty || (n = B.create([B.cursor(r.main.head)])), n ? (e(cr(t, n)), !0) : !1;
};
function $s(t, e) {
  if (t.state.readOnly)
    return !1;
  let r = "delete.selection", { state: n } = t, i = n.changeByRange((s) => {
    let { from: o, to: a } = s;
    if (o == a) {
      let l = e(s);
      l < o ? (r = "delete.backward", l = go(t, l, !1)) : l > o && (r = "delete.forward", l = go(t, l, !0)), o = Math.min(o, l), a = Math.max(a, l);
    } else
      o = go(t, o, !1), a = go(t, a, !0);
    return o == a ? { range: s } : { changes: { from: o, to: a }, range: B.cursor(o, o < s.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (t.dispatch(n.update(i, {
    scrollIntoView: !0,
    userEvent: r,
    effects: r == "delete.selection" ? H.announce.of(n.phrase("Selection deleted")) : void 0
  })), !0);
}
function go(t, e, r) {
  if (t instanceof H)
    for (let n of t.state.facet(H.atomicRanges).map((i) => i(t)))
      n.between(e, e, (i, s) => {
        i < e && s > e && (e = r ? s : i);
      });
  return e;
}
const Q1 = (t, e) => $s(t, (r) => {
  let n = r.from, { state: i } = t, s = i.doc.lineAt(n), o, a;
  if (!e && n > s.from && n < s.from + 200 && !/[^ \t]/.test(o = s.text.slice(0, n - s.from))) {
    if (o[o.length - 1] == "	")
      return n - 1;
    let l = wi(o, i.tabSize), c = l % ia(i) || ia(i);
    for (let u = 0; u < c && o[o.length - 1 - u] == " "; u++)
      n--;
    a = n;
  } else
    a = Ie(s.text, n - s.from, e, e) + s.from, a == n && s.number != (e ? i.doc.lines : 1) ? a += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(a - s.from, n - s.from)) && (a = Ie(s.text, a - s.from, !1, !1) + s.from);
  return a;
}), dc = (t) => Q1(t, !1), Z1 = (t) => Q1(t, !0), ev = (t, e) => $s(t, (r) => {
  let n = r.head, { state: i } = t, s = i.doc.lineAt(n), o = i.charCategorizer(n);
  for (let a = null; ; ) {
    if (n == (e ? s.to : s.from)) {
      n == r.head && s.number != (e ? i.doc.lines : 1) && (n += e ? 1 : -1);
      break;
    }
    let l = Ie(s.text, n - s.from, e) + s.from, c = s.text.slice(Math.min(n, l) - s.from, Math.max(n, l) - s.from), u = o(c);
    if (a != null && u != a)
      break;
    (c != " " || n != r.head) && (a = u), n = l;
  }
  return n;
}), tv = (t) => ev(t, !1), uM = (t) => ev(t, !0), cM = (t) => $s(t, (e) => {
  let r = t.lineBlockAt(e.head).to;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), hM = (t) => $s(t, (e) => {
  let r = t.moveToLineBoundary(e, !1).head;
  return e.head > r ? r : Math.max(0, e.head - 1);
}), fM = (t) => $s(t, (e) => {
  let r = t.moveToLineBoundary(e, !0).head;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), dM = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((n) => ({
    changes: { from: n.from, to: n.to, insert: le.of(["", ""]) },
    range: B.cursor(n.from)
  }));
  return e(t.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
}, pM = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((n) => {
    if (!n.empty || n.from == 0 || n.from == t.doc.length)
      return { range: n };
    let i = n.from, s = t.doc.lineAt(i), o = i == s.from ? i - 1 : Ie(s.text, i - s.from, !1) + s.from, a = i == s.to ? i + 1 : Ie(s.text, i - s.from, !0) + s.from;
    return {
      changes: { from: o, to: a, insert: t.doc.slice(i, a).append(t.doc.slice(o, i)) },
      range: B.cursor(a)
    };
  });
  return r.changes.empty ? !1 : (e(t.update(r, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function al(t) {
  let e = [], r = -1;
  for (let n of t.selection.ranges) {
    let i = t.doc.lineAt(n.from), s = t.doc.lineAt(n.to);
    if (!n.empty && n.to == s.from && (s = t.doc.lineAt(n.to - 1)), r >= i.number) {
      let o = e[e.length - 1];
      o.to = s.to, o.ranges.push(n);
    } else
      e.push({ from: i.from, to: s.to, ranges: [n] });
    r = s.number + 1;
  }
  return e;
}
function rv(t, e, r) {
  if (t.readOnly)
    return !1;
  let n = [], i = [];
  for (let s of al(t)) {
    if (r ? s.to == t.doc.length : s.from == 0)
      continue;
    let o = t.doc.lineAt(r ? s.to + 1 : s.from - 1), a = o.length + 1;
    if (r) {
      n.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + t.lineBreak });
      for (let l of s.ranges)
        i.push(B.range(Math.min(t.doc.length, l.anchor + a), Math.min(t.doc.length, l.head + a)));
    } else {
      n.push({ from: o.from, to: s.from }, { from: s.to, insert: t.lineBreak + o.text });
      for (let l of s.ranges)
        i.push(B.range(l.anchor - a, l.head - a));
    }
  }
  return n.length ? (e(t.update({
    changes: n,
    scrollIntoView: !0,
    selection: B.create(i, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const mM = ({ state: t, dispatch: e }) => rv(t, e, !1), gM = ({ state: t, dispatch: e }) => rv(t, e, !0);
function nv(t, e, r) {
  if (t.readOnly)
    return !1;
  let n = [];
  for (let i of al(t))
    r ? n.push({ from: i.from, insert: t.doc.slice(i.from, i.to) + t.lineBreak }) : n.push({ from: i.to, insert: t.lineBreak + t.doc.slice(i.from, i.to) });
  return e(t.update({ changes: n, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const yM = ({ state: t, dispatch: e }) => nv(t, e, !1), vM = ({ state: t, dispatch: e }) => nv(t, e, !0), bM = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, r = e.changes(al(e).map(({ from: i, to: s }) => (i > 0 ? i-- : s < e.doc.length && s++, { from: i, to: s }))), n = xi(e.selection, (i) => t.moveVertically(i, !0)).map(r);
  return t.dispatch({ changes: r, selection: n, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function DM(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let r = Ke(t).resolveInner(e), n = r.childBefore(e), i = r.childAfter(e), s;
  return n && i && n.to <= e && i.from >= e && (s = n.type.prop(te.closedBy)) && s.indexOf(i.name) > -1 && t.doc.lineAt(n.to).from == t.doc.lineAt(i.from).from && !/\S/.test(t.sliceDoc(n.to, i.from)) ? { from: n.to, to: i.from } : null;
}
const wM = /* @__PURE__ */ iv(!1), xM = /* @__PURE__ */ iv(!0);
function iv(t) {
  return ({ state: e, dispatch: r }) => {
    if (e.readOnly)
      return !1;
    let n = e.changeByRange((i) => {
      let { from: s, to: o } = i, a = e.doc.lineAt(s), l = !t && s == o && DM(e, s);
      t && (s = o = (o <= a.to ? a : e.doc.lineAt(o)).to);
      let c = new rl(e, { simulateBreak: s, simulateDoubleBreak: !!l }), u = Ih(c, s);
      for (u == null && (u = wi(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < a.to && /\s/.test(a.text[o - a.from]); )
        o++;
      l ? { from: s, to: o } = l : s > a.from && s < a.from + 100 && !/\S/.test(a.text.slice(0, s)) && (s = a.from);
      let h = ["", gs(e, u)];
      return l && h.push(gs(e, c.lineIndent(a.from, -1))), {
        changes: { from: s, to: o, insert: le.of(h) },
        range: B.cursor(s + 1 + h[1].length)
      };
    });
    return r(e.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Hh(t, e) {
  let r = -1;
  return t.changeByRange((n) => {
    let i = [];
    for (let o = n.from; o <= n.to; ) {
      let a = t.doc.lineAt(o);
      a.number > r && (n.empty || n.to > a.from) && (e(a, i, n), r = a.number), o = a.to + 1;
    }
    let s = t.changes(i);
    return {
      changes: i,
      range: B.range(s.mapPos(n.anchor, 1), s.mapPos(n.head, 1))
    };
  });
}
const CM = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = /* @__PURE__ */ Object.create(null), n = new rl(t, { overrideIndentation: (s) => {
    let o = r[s];
    return o ?? -1;
  } }), i = Hh(t, (s, o, a) => {
    let l = Ih(n, s.from);
    if (l == null)
      return;
    /\S/.test(s.text) || (l = 0);
    let c = /^\s*/.exec(s.text)[0], u = gs(t, l);
    (c != u || a.from < s.from + c.length) && (r[s.from] = l, o.push({ from: s.from, to: s.from + c.length, insert: u }));
  });
  return i.changes.empty || e(t.update(i, { userEvent: "indent" })), !0;
}, sv = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Hh(t, (r, n) => {
  n.push({ from: r.from, insert: t.facet(tl) });
}), { userEvent: "input.indent" })), !0), ov = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Hh(t, (r, n) => {
  let i = /^\s*/.exec(r.text)[0];
  if (!i)
    return;
  let s = wi(i, t.tabSize), o = 0, a = gs(t, Math.max(0, s - ia(t)));
  for (; o < i.length && o < a.length && i.charCodeAt(o) == a.charCodeAt(o); )
    o++;
  n.push({ from: r.from + o, to: r.from + i.length, insert: a.slice(o) });
}), { userEvent: "delete.dedent" })), !0), kM = [
  { key: "Ctrl-b", run: N1, shift: z1, preventDefault: !0 },
  { key: "Ctrl-f", run: R1, shift: U1 },
  { key: "Ctrl-p", run: j1, shift: Y1 },
  { key: "Ctrl-n", run: W1, shift: J1 },
  { key: "Ctrl-a", run: z3, shift: nM },
  { key: "Ctrl-e", run: U3, shift: iM },
  { key: "Ctrl-d", run: Z1 },
  { key: "Ctrl-h", run: dc },
  { key: "Ctrl-k", run: cM },
  { key: "Ctrl-Alt-h", run: tv },
  { key: "Ctrl-o", run: dM },
  { key: "Ctrl-t", run: pM },
  { key: "Ctrl-v", run: fc }
], SM = /* @__PURE__ */ [
  { key: "ArrowLeft", run: N1, shift: z1, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: N3, shift: Y3, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: H3, shift: tM, preventDefault: !0 },
  { key: "ArrowRight", run: R1, shift: U1, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: R3, shift: J3, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: V3, shift: rM, preventDefault: !0 },
  { key: "ArrowUp", run: j1, shift: Y1, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Cp, shift: Sp },
  { mac: "Ctrl-ArrowUp", run: Dp, shift: wp },
  { key: "ArrowDown", run: W1, shift: J1, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: kp, shift: Ep },
  { mac: "Ctrl-ArrowDown", run: fc, shift: xp },
  { key: "PageUp", run: Dp, shift: wp },
  { key: "PageDown", run: fc, shift: xp },
  { key: "Home", run: q3, shift: eM, preventDefault: !0 },
  { key: "Mod-Home", run: Cp, shift: Sp },
  { key: "End", run: W3, shift: Z3, preventDefault: !0 },
  { key: "Mod-End", run: kp, shift: Ep },
  { key: "Enter", run: wM },
  { key: "Mod-a", run: sM },
  { key: "Backspace", run: dc, shift: dc },
  { key: "Delete", run: Z1 },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: tv },
  { key: "Mod-Delete", mac: "Alt-Delete", run: uM },
  { mac: "Mod-Backspace", run: hM },
  { mac: "Mod-Delete", run: fM }
].concat(/* @__PURE__ */ kM.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), EM = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: $3, shift: X3 },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: j3, shift: Q3 },
  { key: "Alt-ArrowUp", run: mM },
  { key: "Shift-Alt-ArrowUp", run: yM },
  { key: "Alt-ArrowDown", run: gM },
  { key: "Shift-Alt-ArrowDown", run: vM },
  { key: "Escape", run: lM },
  { key: "Mod-Enter", run: xM },
  { key: "Alt-l", mac: "Ctrl-l", run: oM },
  { key: "Mod-i", run: aM, preventDefault: !0 },
  { key: "Mod-[", run: ov },
  { key: "Mod-]", run: sv },
  { key: "Mod-Alt-\\", run: CM },
  { key: "Shift-Mod-k", run: bM },
  { key: "Shift-Mod-\\", run: K3 },
  { key: "Mod-/", run: y3 },
  { key: "Alt-A", run: b3 }
].concat(SM), AM = { key: "Tab", run: sv, shift: ov };
function de() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, r = arguments[1];
  if (r && typeof r == "object" && r.nodeType == null && !Array.isArray(r)) {
    for (var n in r)
      if (Object.prototype.hasOwnProperty.call(r, n)) {
        var i = r[n];
        typeof i == "string" ? t.setAttribute(n, i) : i != null && (t[n] = i);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    av(t, arguments[e]);
  return t;
}
function av(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      t.appendChild(e);
    else if (Array.isArray(e))
      for (var r = 0; r < e.length; r++)
        av(t, e[r]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const Ap = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class fi {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, r, n = 0, i = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(n, i), this.bufferStart = n, this.normalize = s ? (a) => s(Ap(a)) : Ap, this.query = this.normalize(r);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Me(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let r = Ch(e), n = this.bufferStart + this.bufferPos;
      this.bufferPos += St(e);
      let i = this.normalize(r);
      for (let s = 0, o = n; ; s++) {
        let a = i.charCodeAt(s), l = this.match(a, o, this.bufferPos + this.bufferStart);
        if (s == i.length - 1) {
          if (l)
            return this.value = l, this;
          break;
        }
        o == n && s < r.length && r.charCodeAt(s) == a && o++;
      }
    }
  }
  match(e, r, n) {
    let i = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let o = this.matches[s], a = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? i = { from: this.matches[s + 1], to: n } : (this.matches[s]++, a = !0)), a || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: r, to: n } : this.matches.push(1, r)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (fi.prototype[Symbol.iterator] = function() {
  return this;
});
const lv = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Vh = "gm" + (/x/.unicode == null ? "" : "u");
class uv {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, r, n, i = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = lv, /\\[sWDnr]|\n|\r|\[\^/.test(r))
      return new cv(e, r, n, i, s);
    this.re = new RegExp(r, Vh + (n != null && n.ignoreCase ? "i" : "")), this.test = n == null ? void 0 : n.test, this.iter = e.iter();
    let o = e.lineAt(i);
    this.curLineStart = o.from, this.matchPos = la(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let r = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (r) {
        let n = this.curLineStart + r.index, i = n + r[0].length;
        if (this.matchPos = la(this.text, i + (n == i ? 1 : 0)), n == this.curLineStart + this.curLine.length && this.nextLine(), (n < i || n > this.value.to) && (!this.test || this.test(n, i, r)))
          return this.value = { from: n, to: i, match: r }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Jl = /* @__PURE__ */ new WeakMap();
class ni {
  constructor(e, r) {
    this.from = e, this.text = r;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, r, n) {
    let i = Jl.get(e);
    if (!i || i.from >= n || i.to <= r) {
      let a = new ni(r, e.sliceString(r, n));
      return Jl.set(e, a), a;
    }
    if (i.from == r && i.to == n)
      return i;
    let { text: s, from: o } = i;
    return o > r && (s = e.sliceString(r, o) + s, o = r), i.to < n && (s += e.sliceString(i.to, n)), Jl.set(e, new ni(o, s)), new ni(r, s.slice(r - o, n - o));
  }
}
class cv {
  constructor(e, r, n, i, s) {
    this.text = e, this.to = s, this.done = !1, this.value = lv, this.matchPos = la(e, i), this.re = new RegExp(r, Vh + (n != null && n.ignoreCase ? "i" : "")), this.test = n == null ? void 0 : n.test, this.flat = ni.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, r = this.re.exec(this.flat.text);
      if (r && !r[0] && r.index == e && (this.re.lastIndex = e + 1, r = this.re.exec(this.flat.text)), r) {
        let n = this.flat.from + r.index, i = n + r[0].length;
        if ((this.flat.to >= this.to || r.index + r[0].length <= this.flat.text.length - 10) && (!this.test || this.test(n, i, r)))
          return this.value = { from: n, to: i, match: r }, this.matchPos = la(this.text, i + (n == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = ni.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (uv.prototype[Symbol.iterator] = cv.prototype[Symbol.iterator] = function() {
  return this;
});
function FM(t) {
  try {
    return new RegExp(t, Vh), !0;
  } catch {
    return !1;
  }
}
function la(t, e) {
  if (e >= t.length)
    return e;
  let r = t.lineAt(e), n;
  for (; e < r.to && (n = r.text.charCodeAt(e - r.from)) >= 56320 && n < 57344; )
    e++;
  return e;
}
function pc(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), r = de("input", { class: "cm-textfield", name: "line", value: e }), n = de("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), t.dispatch({ effects: ua.of(!1) }), t.focus()) : s.keyCode == 13 && (s.preventDefault(), i());
    },
    onsubmit: (s) => {
      s.preventDefault(), i();
    }
  }, de("label", t.state.phrase("Go to line"), ": ", r), " ", de("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")));
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(r.value);
    if (!s)
      return;
    let { state: o } = t, a = o.doc.lineAt(o.selection.main.head), [, l, c, u, h] = s, f = u ? +u.slice(1) : 0, d = c ? +c : a.number;
    if (c && h) {
      let y = d / 100;
      l && (y = y * (l == "-" ? -1 : 1) + a.number / o.doc.lines), d = Math.round(o.doc.lines * y);
    } else
      c && l && (d = d * (l == "-" ? -1 : 1) + a.number);
    let p = o.doc.line(Math.max(1, Math.min(o.doc.lines, d))), m = B.cursor(p.from + Math.max(0, Math.min(f, p.length)));
    t.dispatch({
      effects: [ua.of(!1), H.scrollIntoView(m.from, { y: "center" })],
      selection: m
    }), t.focus();
  }
  return { dom: n };
}
const ua = /* @__PURE__ */ J.define(), Fp = /* @__PURE__ */ We.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(ua) && (t = r.value);
    return t;
  },
  provide: (t) => ps.from(t, (e) => e ? pc : null)
}), TM = (t) => {
  let e = ds(t, pc);
  if (!e) {
    let r = [ua.of(!0)];
    t.state.field(Fp, !1) == null && r.push(J.appendConfig.of([Fp, _M])), t.dispatch({ effects: r }), e = ds(t, pc);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, _M = /* @__PURE__ */ H.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), BM = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, hv = /* @__PURE__ */ z.define({
  combine(t) {
    return ur(t, BM, {
      highlightWordAroundCursor: (e, r) => e || r,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function OM(t) {
  let e = [RM, NM];
  return t && e.push(hv.of(t)), e;
}
const MM = /* @__PURE__ */ K.mark({ class: "cm-selectionMatch" }), LM = /* @__PURE__ */ K.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function Tp(t, e, r, n) {
  return (r == 0 || t(e.sliceDoc(r - 1, r)) != xe.Word) && (n == e.doc.length || t(e.sliceDoc(n, n + 1)) != xe.Word);
}
function PM(t, e, r, n) {
  return t(e.sliceDoc(r, r + 1)) == xe.Word && t(e.sliceDoc(n - 1, n)) == xe.Word;
}
const NM = /* @__PURE__ */ Ee.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(hv), { state: r } = t, n = r.selection;
    if (n.ranges.length > 1)
      return K.none;
    let i = n.main, s, o = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return K.none;
      let l = r.wordAt(i.head);
      if (!l)
        return K.none;
      o = r.charCategorizer(i.head), s = r.sliceDoc(l.from, l.to);
    } else {
      let l = i.to - i.from;
      if (l < e.minSelectionLength || l > 200)
        return K.none;
      if (e.wholeWords) {
        if (s = r.sliceDoc(i.from, i.to), o = r.charCategorizer(i.head), !(Tp(o, r, i.from, i.to) && PM(o, r, i.from, i.to)))
          return K.none;
      } else if (s = r.sliceDoc(i.from, i.to), !s)
        return K.none;
    }
    let a = [];
    for (let l of t.visibleRanges) {
      let c = new fi(r.doc, s, l.from, l.to);
      for (; !c.next().done; ) {
        let { from: u, to: h } = c.value;
        if ((!o || Tp(o, r, u, h)) && (i.empty && u <= i.from && h >= i.to ? a.push(LM.range(u, h)) : (u >= i.to || h <= i.from) && a.push(MM.range(u, h)), a.length > e.maxMatches))
          return K.none;
      }
    }
    return K.set(a);
  }
}, {
  decorations: (t) => t.decorations
}), RM = /* @__PURE__ */ H.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), IM = ({ state: t, dispatch: e }) => {
  let { selection: r } = t, n = B.create(r.ranges.map((i) => t.wordAt(i.head) || B.cursor(i.head)), r.mainIndex);
  return n.eq(r) ? !1 : (e(t.update({ selection: n })), !0);
};
function $M(t, e) {
  let { main: r, ranges: n } = t.selection, i = t.wordAt(r.head), s = i && i.from == r.from && i.to == r.to;
  for (let o = !1, a = new fi(t.doc, e, n[n.length - 1].to); ; )
    if (a.next(), a.done) {
      if (o)
        return null;
      a = new fi(t.doc, e, 0, Math.max(0, n[n.length - 1].from - 1)), o = !0;
    } else {
      if (o && n.some((l) => l.from == a.value.from))
        continue;
      if (s) {
        let l = t.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const jM = ({ state: t, dispatch: e }) => {
  let { ranges: r } = t.selection;
  if (r.some((s) => s.from === s.to))
    return IM({ state: t, dispatch: e });
  let n = t.sliceDoc(r[0].from, r[0].to);
  if (t.selection.ranges.some((s) => t.sliceDoc(s.from, s.to) != n))
    return !1;
  let i = $M(t, n);
  return i ? (e(t.update({
    selection: t.selection.addRange(B.range(i.from, i.to), !1),
    effects: H.scrollIntoView(i.to)
  })), !0) : !1;
}, Ci = /* @__PURE__ */ z.define({
  combine(t) {
    return ur(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new QM(e),
      scrollToMatch: (e) => H.scrollIntoView(e)
    });
  }
});
class fv {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || FM(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (r, n) => n == "n" ? `
` : n == "r" ? "\r" : n == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new VM(this) : new qM(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, r = 0, n) {
    let i = e.doc ? e : ee.create({ doc: e });
    return n == null && (n = i.doc.length), this.regexp ? Un(this, i, r, n) : zn(this, i, r, n);
  }
}
class dv {
  constructor(e) {
    this.spec = e;
  }
}
function zn(t, e, r, n) {
  return new fi(e.doc, t.unquoted, r, n, t.caseSensitive ? void 0 : (i) => i.toLowerCase(), t.wholeWord ? WM(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function WM(t, e) {
  return (r, n, i, s) => ((s > r || s + i.length < n) && (s = Math.max(0, r - 2), i = t.sliceString(s, Math.min(t.length, n + 2))), (e(ca(i, r - s)) != xe.Word || e(ha(i, r - s)) != xe.Word) && (e(ha(i, n - s)) != xe.Word || e(ca(i, n - s)) != xe.Word));
}
class qM extends dv {
  constructor(e) {
    super(e);
  }
  nextMatch(e, r, n) {
    let i = zn(this.spec, e, n, e.doc.length).nextOverlapping();
    return i.done && (i = zn(this.spec, e, 0, r).nextOverlapping()), i.done ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, r, n) {
    for (let i = n; ; ) {
      let s = Math.max(r, i - 1e4 - this.spec.unquoted.length), o = zn(this.spec, e, s, i), a = null;
      for (; !o.nextOverlapping().done; )
        a = o.value;
      if (a)
        return a;
      if (s == r)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, r, n) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, r) {
    let n = zn(this.spec, e, 0, e.doc.length), i = [];
    for (; !n.next().done; ) {
      if (i.length >= r)
        return null;
      i.push(n.value);
    }
    return i;
  }
  highlight(e, r, n, i) {
    let s = zn(this.spec, e, Math.max(0, r - this.spec.unquoted.length), Math.min(n + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
function Un(t, e, r, n) {
  return new uv(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? HM(e.charCategorizer(e.selection.main.head)) : void 0
  }, r, n);
}
function ca(t, e) {
  return t.slice(Ie(t, e, !1), e);
}
function ha(t, e) {
  return t.slice(e, Ie(t, e));
}
function HM(t) {
  return (e, r, n) => !n[0].length || (t(ca(n.input, n.index)) != xe.Word || t(ha(n.input, n.index)) != xe.Word) && (t(ha(n.input, n.index + n[0].length)) != xe.Word || t(ca(n.input, n.index + n[0].length)) != xe.Word);
}
class VM extends dv {
  nextMatch(e, r, n) {
    let i = Un(this.spec, e, n, e.doc.length).next();
    return i.done && (i = Un(this.spec, e, 0, r).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, r, n) {
    for (let i = 1; ; i++) {
      let s = Math.max(
        r,
        n - i * 1e4
        /* FindPrev.ChunkSize */
      ), o = Un(this.spec, e, s, n), a = null;
      for (; !o.next().done; )
        a = o.value;
      if (a && (s == r || a.from > s + 10))
        return a;
      if (s == r)
        return null;
    }
  }
  prevMatch(e, r, n) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (r, n) => n == "$" ? "$" : n == "&" ? e.match[0] : n != "0" && +n < e.match.length ? e.match[n] : r);
  }
  matchAll(e, r) {
    let n = Un(this.spec, e, 0, e.doc.length), i = [];
    for (; !n.next().done; ) {
      if (i.length >= r)
        return null;
      i.push(n.value);
    }
    return i;
  }
  highlight(e, r, n, i) {
    let s = Un(this.spec, e, Math.max(
      0,
      r - 250
      /* RegExp.HighlightMargin */
    ), Math.min(n + 250, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
const ys = /* @__PURE__ */ J.define(), zh = /* @__PURE__ */ J.define(), Hr = /* @__PURE__ */ We.define({
  create(t) {
    return new Xl(mc(t).create(), null);
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(ys) ? t = new Xl(r.value.create(), t.panel) : r.is(zh) && (t = new Xl(t.query, r.value ? Uh : null));
    return t;
  },
  provide: (t) => ps.from(t, (e) => e.panel)
});
class Xl {
  constructor(e, r) {
    this.query = e, this.panel = r;
  }
}
const zM = /* @__PURE__ */ K.mark({ class: "cm-searchMatch" }), UM = /* @__PURE__ */ K.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), GM = /* @__PURE__ */ Ee.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(Hr));
  }
  update(t) {
    let e = t.state.field(Hr);
    (e != t.startState.field(Hr) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return K.none;
    let { view: r } = this, n = new Gr();
    for (let i = 0, s = r.visibleRanges, o = s.length; i < o; i++) {
      let { from: a, to: l } = s[i];
      for (; i < o - 1 && l > s[i + 1].from - 2 * 250; )
        l = s[++i].to;
      t.highlight(r.state, a, l, (c, u) => {
        let h = r.state.selection.ranges.some((f) => f.from == c && f.to == u);
        n.add(c, u, h ? UM : zM);
      });
    }
    return n.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function js(t) {
  return (e) => {
    let r = e.state.field(Hr, !1);
    return r && r.query.spec.valid ? t(e, r) : gv(e);
  };
}
const fa = /* @__PURE__ */ js((t, { query: e }) => {
  let { to: r } = t.state.selection.main, n = e.nextMatch(t.state, r, r);
  if (!n)
    return !1;
  let i = B.single(n.from, n.to), s = t.state.facet(Ci);
  return t.dispatch({
    selection: i,
    effects: [Gh(t, n), s.scrollToMatch(i.main, t)],
    userEvent: "select.search"
  }), mv(t), !0;
}), da = /* @__PURE__ */ js((t, { query: e }) => {
  let { state: r } = t, { from: n } = r.selection.main, i = e.prevMatch(r, n, n);
  if (!i)
    return !1;
  let s = B.single(i.from, i.to), o = t.state.facet(Ci);
  return t.dispatch({
    selection: s,
    effects: [Gh(t, i), o.scrollToMatch(s.main, t)],
    userEvent: "select.search"
  }), mv(t), !0;
}), KM = /* @__PURE__ */ js((t, { query: e }) => {
  let r = e.matchAll(t.state, 1e3);
  return !r || !r.length ? !1 : (t.dispatch({
    selection: B.create(r.map((n) => B.range(n.from, n.to))),
    userEvent: "select.search.matches"
  }), !0);
}), YM = ({ state: t, dispatch: e }) => {
  let r = t.selection;
  if (r.ranges.length > 1 || r.main.empty)
    return !1;
  let { from: n, to: i } = r.main, s = [], o = 0;
  for (let a = new fi(t.doc, t.sliceDoc(n, i)); !a.next().done; ) {
    if (s.length > 1e3)
      return !1;
    a.value.from == n && (o = s.length), s.push(B.range(a.value.from, a.value.to));
  }
  return e(t.update({
    selection: B.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, _p = /* @__PURE__ */ js((t, { query: e }) => {
  let { state: r } = t, { from: n, to: i } = r.selection.main;
  if (r.readOnly)
    return !1;
  let s = e.nextMatch(r, n, n);
  if (!s)
    return !1;
  let o = [], a, l, c = [];
  if (s.from == n && s.to == i && (l = r.toText(e.getReplacement(s)), o.push({ from: s.from, to: s.to, insert: l }), s = e.nextMatch(r, s.from, s.to), c.push(H.announce.of(r.phrase("replaced match on line $", r.doc.lineAt(n).number) + "."))), s) {
    let u = o.length == 0 || o[0].from >= s.to ? 0 : s.to - s.from - l.length;
    a = B.single(s.from - u, s.to - u), c.push(Gh(t, s)), c.push(r.facet(Ci).scrollToMatch(a.main, t));
  }
  return t.dispatch({
    changes: o,
    selection: a,
    effects: c,
    userEvent: "input.replace"
  }), !0;
}), JM = /* @__PURE__ */ js((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let r = e.matchAll(t.state, 1e9).map((i) => {
    let { from: s, to: o } = i;
    return { from: s, to: o, insert: e.getReplacement(i) };
  });
  if (!r.length)
    return !1;
  let n = t.state.phrase("replaced $ matches", r.length) + ".";
  return t.dispatch({
    changes: r,
    effects: H.announce.of(n),
    userEvent: "input.replace.all"
  }), !0;
});
function Uh(t) {
  return t.state.facet(Ci).createPanel(t);
}
function mc(t, e) {
  var r, n, i, s, o;
  let a = t.selection.main, l = a.empty || a.to > a.from + 100 ? "" : t.sliceDoc(a.from, a.to);
  if (e && !l)
    return e;
  let c = t.facet(Ci);
  return new fv({
    search: ((r = e == null ? void 0 : e.literal) !== null && r !== void 0 ? r : c.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (n = e == null ? void 0 : e.caseSensitive) !== null && n !== void 0 ? n : c.caseSensitive,
    literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : c.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : c.regexp,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
  });
}
function pv(t) {
  let e = ds(t, Uh);
  return e && e.dom.querySelector("[main-field]");
}
function mv(t) {
  let e = pv(t);
  e && e == t.root.activeElement && e.select();
}
const gv = (t) => {
  let e = t.state.field(Hr, !1);
  if (e && e.panel) {
    let r = pv(t);
    if (r && r != t.root.activeElement) {
      let n = mc(t.state, e.query.spec);
      n.valid && t.dispatch({ effects: ys.of(n) }), r.focus(), r.select();
    }
  } else
    t.dispatch({ effects: [
      zh.of(!0),
      e ? ys.of(mc(t.state, e.query.spec)) : J.appendConfig.of(eL)
    ] });
  return !0;
}, yv = (t) => {
  let e = t.state.field(Hr, !1);
  if (!e || !e.panel)
    return !1;
  let r = ds(t, Uh);
  return r && r.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: zh.of(!1) }), !0;
}, XM = [
  { key: "Mod-f", run: gv, scope: "editor search-panel" },
  { key: "F3", run: fa, shift: da, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: fa, shift: da, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: yv, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: YM },
  { key: "Mod-Alt-g", run: TM },
  { key: "Mod-d", run: jM, preventDefault: !0 }
];
class QM {
  constructor(e) {
    this.view = e;
    let r = this.query = e.state.field(Hr).query.spec;
    this.commit = this.commit.bind(this), this.searchField = de("input", {
      value: r.search,
      placeholder: lt(e, "Find"),
      "aria-label": lt(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = de("input", {
      value: r.replace,
      placeholder: lt(e, "Replace"),
      "aria-label": lt(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = de("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: r.caseSensitive,
      onchange: this.commit
    }), this.reField = de("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: r.regexp,
      onchange: this.commit
    }), this.wordField = de("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: r.wholeWord,
      onchange: this.commit
    });
    function n(i, s, o) {
      return de("button", { class: "cm-button", name: i, onclick: s, type: "button" }, o);
    }
    this.dom = de("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      n("next", () => fa(e), [lt(e, "next")]),
      n("prev", () => da(e), [lt(e, "previous")]),
      n("select", () => KM(e), [lt(e, "all")]),
      de("label", null, [this.caseField, lt(e, "match case")]),
      de("label", null, [this.reField, lt(e, "regexp")]),
      de("label", null, [this.wordField, lt(e, "by word")]),
      ...e.state.readOnly ? [] : [
        de("br"),
        this.replaceField,
        n("replace", () => _p(e), [lt(e, "replace")]),
        n("replaceAll", () => JM(e), [lt(e, "replace all")])
      ],
      de("button", {
        name: "close",
        onclick: () => yv(e),
        "aria-label": lt(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new fv({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: ys.of(e) }));
  }
  keydown(e) {
    aB(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? da : fa)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), _p(this.view));
  }
  update(e) {
    for (let r of e.transactions)
      for (let n of r.effects)
        n.is(ys) && !n.value.eq(this.query) && this.setQuery(n.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Ci).top;
  }
}
function lt(t, e) {
  return t.state.phrase(e);
}
const yo = 30, vo = /[\s\.,:;?!]/;
function Gh(t, { from: e, to: r }) {
  let n = t.state.doc.lineAt(e), i = t.state.doc.lineAt(r).to, s = Math.max(n.from, e - yo), o = Math.min(i, r + yo), a = t.state.sliceDoc(s, o);
  if (s != n.from) {
    for (let l = 0; l < yo; l++)
      if (!vo.test(a[l + 1]) && vo.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (o != i) {
    for (let l = a.length - 1; l > a.length - yo; l--)
      if (!vo.test(a[l - 1]) && vo.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return H.announce.of(`${t.state.phrase("current match")}. ${a} ${t.state.phrase("on line")} ${n.number}.`);
}
const ZM = /* @__PURE__ */ H.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), eL = [
  Hr,
  /* @__PURE__ */ Di.low(GM),
  ZM
];
class vv {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, r, n) {
    this.state = e, this.pos = r, this.explicit = n, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let r = Ke(this.state).resolveInner(this.pos, -1);
    for (; r && e.indexOf(r.name) < 0; )
      r = r.parent;
    return r ? {
      from: r.from,
      to: this.pos,
      text: this.state.sliceDoc(r.from, this.pos),
      type: r.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let r = this.state.doc.lineAt(this.pos), n = Math.max(r.from, this.pos - 250), i = r.text.slice(n - r.from, this.pos - r.from), s = i.search(bv(e, !1));
    return s < 0 ? null : { from: n + s, to: this.pos, text: i.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, r) {
    e == "abort" && this.abortListeners && this.abortListeners.push(r);
  }
}
function Bp(t) {
  let e = Object.keys(t).join(""), r = /\w/.test(e);
  return r && (e = e.replace(/\w/g, "")), `[${r ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function tL(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of t) {
    e[i[0]] = !0;
    for (let s = 1; s < i.length; s++)
      r[i[s]] = !0;
  }
  let n = Bp(e) + Bp(r) + "*$";
  return [new RegExp("^" + n), new RegExp(n)];
}
function rL(t) {
  let e = t.map((i) => typeof i == "string" ? { label: i } : i), [r, n] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : tL(e);
  return (i) => {
    let s = i.matchBefore(n);
    return s || i.explicit ? { from: s ? s.from : i.pos, options: e, validFor: r } : null;
  };
}
class Op {
  constructor(e, r, n, i) {
    this.completion = e, this.source = r, this.match = n, this.score = i;
  }
}
function Vr(t) {
  return t.selection.main.from;
}
function bv(t, e) {
  var r;
  let { source: n } = t, i = e && n[0] != "^", s = n[n.length - 1] != "$";
  return !i && !s ? t : new RegExp(`${i ? "^" : ""}(?:${n})${s ? "$" : ""}`, (r = t.flags) !== null && r !== void 0 ? r : t.ignoreCase ? "i" : "");
}
const nL = /* @__PURE__ */ lr.define();
function iL(t, e, r, n) {
  let { main: i } = t.selection, s = r - i.from, o = n - i.from;
  return Object.assign(Object.assign({}, t.changeByRange((a) => a != i && r != n && t.sliceDoc(a.from + s, a.from + o) != t.sliceDoc(r, n) ? { range: a } : {
    changes: { from: a.from + s, to: n == i.from ? a.to : a.from + o, insert: e },
    range: B.cursor(a.from + s + e.length)
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const Mp = /* @__PURE__ */ new WeakMap();
function sL(t) {
  if (!Array.isArray(t))
    return t;
  let e = Mp.get(t);
  return e || Mp.set(t, e = rL(t)), e;
}
const pa = /* @__PURE__ */ J.define(), vs = /* @__PURE__ */ J.define();
class oL {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let r = 0; r < e.length; ) {
      let n = Me(e, r), i = St(n);
      this.chars.push(n);
      let s = e.slice(r, r + i), o = s.toUpperCase();
      this.folded.push(Me(o == s ? s.toLowerCase() : o, 0)), r += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, r) {
    return this.score = e, this.matched = r, !0;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return !1;
    let { chars: r, folded: n, any: i, precise: s, byWord: o } = this;
    if (r.length == 1) {
      let g = Me(e, 0), b = St(g), w = b == e.length ? 0 : -100;
      if (g != r[0])
        if (g == n[0])
          w += -200;
        else
          return !1;
      return this.ret(w, [0, b]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = r.length, c = 0;
    if (a < 0) {
      for (let g = 0, b = Math.min(e.length, 200); g < b && c < l; ) {
        let w = Me(e, g);
        (w == r[c] || w == n[c]) && (i[c++] = g), g += St(w);
      }
      if (c < l)
        return !1;
    }
    let u = 0, h = 0, f = !1, d = 0, p = -1, m = -1, y = /[a-z]/.test(e), v = !0;
    for (let g = 0, b = Math.min(e.length, 200), w = 0; g < b && h < l; ) {
      let D = Me(e, g);
      a < 0 && (u < l && D == r[u] && (s[u++] = g), d < l && (D == r[d] || D == n[d] ? (d == 0 && (p = g), m = g + 1, d++) : d = 0));
      let x, C = D < 255 ? D >= 48 && D <= 57 || D >= 97 && D <= 122 ? 2 : D >= 65 && D <= 90 ? 1 : 0 : (x = Ch(D)) != x.toLowerCase() ? 1 : x != x.toUpperCase() ? 2 : 0;
      (!g || C == 1 && y || w == 0 && C != 0) && (r[h] == D || n[h] == D && (f = !0) ? o[h++] = g : o.length && (v = !1)), w = C, g += St(D);
    }
    return h == l && o[0] == 0 && v ? this.result(-100 + (f ? -200 : 0), o, e) : d == l && p == 0 ? this.ret(-200 - e.length + (m == e.length ? 0 : -100), [0, m]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : d == l ? this.ret(-900 - e.length, [p, m]) : h == l ? this.result(-100 + (f ? -200 : 0) + -700 + (v ? 0 : -1100), o, e) : r.length == 2 ? !1 : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, r, n) {
    let i = [], s = 0;
    for (let o of r) {
      let a = o + (this.astral ? St(Me(n, o)) : 1);
      s && i[s - 1] == o ? i[s - 1] = a : (i[s++] = o, i[s++] = a);
    }
    return this.ret(e - n.length, i);
  }
}
const Re = /* @__PURE__ */ z.define({
  combine(t) {
    return ur(t, {
      activateOnTyping: !0,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: aL,
      compareCompletions: (e, r) => e.label.localeCompare(r.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, r) => e && r,
      closeOnBlur: (e, r) => e && r,
      icons: (e, r) => e && r,
      tooltipClass: (e, r) => (n) => Lp(e(n), r(n)),
      optionClass: (e, r) => (n) => Lp(e(n), r(n)),
      addToOptions: (e, r) => e.concat(r)
    });
  }
});
function Lp(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function aL(t, e, r, n, i, s) {
  let o = t.textDirection == ye.RTL, a = o, l = !1, c = "top", u, h, f = e.left - i.left, d = i.right - e.right, p = n.right - n.left, m = n.bottom - n.top;
  if (a && f < Math.min(p, d) ? a = !1 : !a && d < Math.min(p, f) && (a = !0), p <= (a ? f : d))
    u = Math.max(i.top, Math.min(r.top, i.bottom - m)) - e.top, h = Math.min(400, a ? f : d);
  else {
    l = !0, h = Math.min(
      400,
      (o ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let g = i.bottom - e.bottom;
    g >= m || g > e.top ? u = r.bottom - e.top : (c = "bottom", u = e.bottom - r.top);
  }
  let y = (e.bottom - e.top) / s.offsetHeight, v = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${c}: ${u / y}px; max-width: ${h / v}px`,
    class: "cm-completionInfo-" + (l ? o ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function lL(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(r) {
      let n = document.createElement("div");
      return n.classList.add("cm-completionIcon"), r.type && n.classList.add(...r.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), n.setAttribute("aria-hidden", "true"), n;
    },
    position: 20
  }), e.push({
    render(r, n, i, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let a = r.displayLabel || r.label, l = 0;
      for (let c = 0; c < s.length; ) {
        let u = s[c++], h = s[c++];
        u > l && o.appendChild(document.createTextNode(a.slice(l, u)));
        let f = o.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(a.slice(u, h))), f.className = "cm-completionMatchedText", l = h;
      }
      return l < a.length && o.appendChild(document.createTextNode(a.slice(l))), o;
    },
    position: 50
  }, {
    render(r) {
      if (!r.detail)
        return null;
      let n = document.createElement("span");
      return n.className = "cm-completionDetail", n.textContent = r.detail, n;
    },
    position: 80
  }), e.sort((r, n) => r.position - n.position).map((r) => r.render);
}
function Ql(t, e, r) {
  if (t <= r)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let i = Math.floor(e / r);
    return { from: i * r, to: (i + 1) * r };
  }
  let n = Math.floor((t - e) / r);
  return { from: t - (n + 1) * r, to: t - n * r };
}
class uL {
  constructor(e, r, n) {
    this.view = e, this.stateField = r, this.applyCompletion = n, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(r), { options: s, selected: o } = i.open, a = e.state.facet(Re);
    this.optionContent = lL(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = Ql(s.length, o, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: c } = e.state.field(r).open;
      for (let u = l.target, h; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < c.length) {
          this.applyCompletion(e, c[+h[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(Re).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: vs.of(null) });
    }), this.showOptions(s, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, r) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, r, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var r;
    let n = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), n != i) {
      let { options: s, selected: o, disabled: a } = n.open;
      (!i.open || i.open.options != s) && (this.range = Ql(s.length, o, e.state.facet(Re).maxRenderedOptions), this.showOptions(s, n.id)), this.updateSel(), a != ((r = i.open) === null || r === void 0 ? void 0 : r.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let r = this.tooltipClass(e);
    if (r != this.currentClass) {
      for (let n of this.currentClass.split(" "))
        n && this.dom.classList.remove(n);
      for (let n of r.split(" "))
        n && this.dom.classList.add(n);
      this.currentClass = r;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), r = e.open;
    if ((r.selected > -1 && r.selected < this.range.from || r.selected >= this.range.to) && (this.range = Ql(r.options.length, r.selected, this.view.state.facet(Re).maxRenderedOptions), this.showOptions(r.options, e.id)), this.updateSelectedOption(r.selected)) {
      this.destroyInfo();
      let { completion: n } = r.options[r.selected], { info: i } = n;
      if (!i)
        return;
      let s = typeof i == "string" ? document.createTextNode(i) : i(n);
      if (!s)
        return;
      "then" in s ? s.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, n);
      }).catch((o) => At(this.view.state, o, "completion info")) : this.addInfoPane(s, n);
    }
  }
  addInfoPane(e, r) {
    this.destroyInfo();
    let n = this.info = document.createElement("div");
    if (n.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      n.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: s } = e;
      n.appendChild(i), this.infoDestroy = s || null;
    }
    this.dom.appendChild(n), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let r = null;
    for (let n = this.list.firstChild, i = this.range.from; n; n = n.nextSibling, i++)
      n.nodeName != "LI" || !n.id ? i-- : i == e ? n.hasAttribute("aria-selected") || (n.setAttribute("aria-selected", "true"), r = n) : n.hasAttribute("aria-selected") && n.removeAttribute("aria-selected");
    return r && hL(this.list, r), r;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let r = this.dom.getBoundingClientRect(), n = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };
    }
    return i.top > Math.min(s.bottom, r.bottom) - 10 || i.bottom < Math.max(s.top, r.top) + 10 ? null : this.view.state.facet(Re).positionInfo(this.view, r, i, n, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, r, n) {
    const i = document.createElement("ul");
    i.id = r, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let s = null;
    for (let o = n.from; o < n.to; o++) {
      let { completion: a, match: l } = e[o], { section: c } = a;
      if (c) {
        let f = typeof c == "string" ? c : c.name;
        if (f != s && (o > n.from || n.from == 0))
          if (s = f, typeof c != "string" && c.header)
            i.appendChild(c.header(c));
          else {
            let d = i.appendChild(document.createElement("completion-section"));
            d.textContent = f;
          }
      }
      const u = i.appendChild(document.createElement("li"));
      u.id = r + "-" + o, u.setAttribute("role", "option");
      let h = this.optionClass(a);
      h && (u.className = h);
      for (let f of this.optionContent) {
        let d = f(a, this.view.state, this.view, l);
        d && u.appendChild(d);
      }
    }
    return n.from && i.classList.add("cm-completionListIncompleteTop"), n.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function cL(t, e) {
  return (r) => new uL(r, t, e);
}
function hL(t, e) {
  let r = t.getBoundingClientRect(), n = e.getBoundingClientRect(), i = r.height / t.offsetHeight;
  n.top < r.top ? t.scrollTop -= (r.top - n.top) / i : n.bottom > r.bottom && (t.scrollTop += (n.bottom - r.bottom) / i);
}
function Pp(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function fL(t, e) {
  let r = [], n = null, i = (l) => {
    r.push(l);
    let { section: c } = l.completion;
    if (c) {
      n || (n = []);
      let u = typeof c == "string" ? c : c.name;
      n.some((h) => h.name == u) || n.push(typeof c == "string" ? { name: u } : c);
    }
  };
  for (let l of t)
    if (l.hasResult()) {
      let c = l.result.getMatch;
      if (l.result.filter === !1)
        for (let u of l.result.options)
          i(new Op(u, l.source, c ? c(u) : [], 1e9 - r.length));
      else {
        let u = new oL(e.sliceDoc(l.from, l.to));
        for (let h of l.result.options)
          if (u.match(h.label)) {
            let f = h.displayLabel ? c ? c(h, u.matched) : [] : u.matched;
            i(new Op(h, l.source, f, u.score + (h.boost || 0)));
          }
      }
    }
  if (n) {
    let l = /* @__PURE__ */ Object.create(null), c = 0, u = (h, f) => {
      var d, p;
      return ((d = h.rank) !== null && d !== void 0 ? d : 1e9) - ((p = f.rank) !== null && p !== void 0 ? p : 1e9) || (h.name < f.name ? -1 : 1);
    };
    for (let h of n.sort(u))
      c -= 1e5, l[h.name] = c;
    for (let h of r) {
      let { section: f } = h.completion;
      f && (h.score += l[typeof f == "string" ? f : f.name]);
    }
  }
  let s = [], o = null, a = e.facet(Re).compareCompletions;
  for (let l of r.sort((c, u) => u.score - c.score || a(c.completion, u.completion))) {
    let c = l.completion;
    !o || o.label != c.label || o.detail != c.detail || o.type != null && c.type != null && o.type != c.type || o.apply != c.apply || o.boost != c.boost ? s.push(l) : Pp(l.completion) > Pp(o) && (s[s.length - 1] = l), o = l.completion;
  }
  return s;
}
class Qn {
  constructor(e, r, n, i, s, o) {
    this.options = e, this.attrs = r, this.tooltip = n, this.timestamp = i, this.selected = s, this.disabled = o;
  }
  setSelected(e, r) {
    return e == this.selected || e >= this.options.length ? this : new Qn(this.options, Np(r, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, r, n, i, s) {
    let o = fL(e, r);
    if (!o.length)
      return i && e.some(
        (l) => l.state == 1
        /* State.Pending */
      ) ? new Qn(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, !0) : null;
    let a = r.facet(Re).selectOnOpen ? 0 : -1;
    if (i && i.selected != a && i.selected != -1) {
      let l = i.options[i.selected].completion;
      for (let c = 0; c < o.length; c++)
        if (o[c].completion == l) {
          a = c;
          break;
        }
    }
    return new Qn(o, Np(n, a), {
      pos: e.reduce((l, c) => c.hasResult() ? Math.min(l, c.from) : l, 1e8),
      create: yL,
      above: s.aboveCursor
    }, i ? i.timestamp : Date.now(), a, !1);
  }
  map(e) {
    return new Qn(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class ma {
  constructor(e, r, n) {
    this.active = e, this.id = r, this.open = n;
  }
  static start() {
    return new ma(mL, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: r } = e, n = r.facet(Re), s = (n.override || r.languageDataAt("autocomplete", Vr(r)).map(sL)).map((a) => (this.active.find((c) => c.source == a) || new nt(
      a,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, n));
    s.length == this.active.length && s.every((a, l) => a == this.active[l]) && (s = this.active);
    let o = this.open;
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !dL(s, this.active) ? o = Qn.build(s, r, this.id, o, n) : o && o.disabled && !s.some(
      (a) => a.state == 1
      /* State.Pending */
    ) && (o = null), !o && s.every(
      (a) => a.state != 1
      /* State.Pending */
    ) && s.some((a) => a.hasResult()) && (s = s.map((a) => a.hasResult() ? new nt(
      a.source,
      0
      /* State.Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(wv) && (o = o && o.setSelected(a.value, this.id));
    return s == this.active && o == this.open ? this : new ma(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : pL;
  }
}
function dL(t, e) {
  if (t == e)
    return !0;
  for (let r = 0, n = 0; ; ) {
    for (; r < t.length && !t[r].hasResult; )
      r++;
    for (; n < e.length && !e[n].hasResult; )
      n++;
    let i = r == t.length, s = n == e.length;
    if (i || s)
      return i == s;
    if (t[r++].result != e[n++].result)
      return !1;
  }
}
const pL = {
  "aria-autocomplete": "list"
};
function Np(t, e) {
  let r = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (r["aria-activedescendant"] = t + "-" + e), r;
}
const mL = [];
function gc(t) {
  return t.isUserEvent("input.type") ? "input" : t.isUserEvent("delete.backward") ? "delete" : null;
}
class nt {
  constructor(e, r, n = -1) {
    this.source = e, this.state = r, this.explicitPos = n;
  }
  hasResult() {
    return !1;
  }
  update(e, r) {
    let n = gc(e), i = this;
    n ? i = i.handleUserEvent(e, n, r) : e.docChanged ? i = i.handleChange(e) : e.selection && i.state != 0 && (i = new nt(
      i.source,
      0
      /* State.Inactive */
    ));
    for (let s of e.effects)
      if (s.is(pa))
        i = new nt(i.source, 1, s.value ? Vr(e.state) : -1);
      else if (s.is(vs))
        i = new nt(
          i.source,
          0
          /* State.Inactive */
        );
      else if (s.is(Dv))
        for (let o of s.value)
          o.source == i.source && (i = o);
    return i;
  }
  handleUserEvent(e, r, n) {
    return r == "delete" || !n.activateOnTyping ? this.map(e.changes) : new nt(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(Vr(e.startState)) ? new nt(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new nt(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class ii extends nt {
  constructor(e, r, n, i, s) {
    super(e, 2, r), this.result = n, this.from = i, this.to = s;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, r, n) {
    var i;
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), a = Vr(e.state);
    if ((this.explicitPos < 0 ? a <= s : a < this.from) || a > o || r == "delete" && Vr(e.startState) == this.from)
      return new nt(
        this.source,
        r == "input" && n.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), c;
    return gL(this.result.validFor, e.state, s, o) ? new ii(this.source, l, this.result, s, o) : this.result.update && (c = this.result.update(this.result, s, o, new vv(e.state, a, l >= 0))) ? new ii(this.source, l, c, c.from, (i = c.to) !== null && i !== void 0 ? i : Vr(e.state)) : new nt(this.source, 1, l);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new nt(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new ii(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function gL(t, e, r, n) {
  if (!t)
    return !1;
  let i = e.sliceDoc(r, n);
  return typeof t == "function" ? t(i, r, n, e) : bv(t, !0).test(i);
}
const Dv = /* @__PURE__ */ J.define({
  map(t, e) {
    return t.map((r) => r.map(e));
  }
}), wv = /* @__PURE__ */ J.define(), ht = /* @__PURE__ */ We.define({
  create() {
    return ma.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    Lh.from(t, (e) => e.tooltip),
    H.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function xv(t, e) {
  const r = e.completion.apply || e.completion.label;
  let n = t.state.field(ht).active.find((i) => i.source == e.source);
  return n instanceof ii ? (typeof r == "string" ? t.dispatch(Object.assign(Object.assign({}, iL(t.state, r, n.from, n.to)), { annotations: nL.of(e.completion) })) : r(t, e.completion, n.from, n.to), !0) : !1;
}
const yL = /* @__PURE__ */ cL(ht, xv);
function bo(t, e = "option") {
  return (r) => {
    let n = r.state.field(ht, !1);
    if (!n || !n.open || n.open.disabled || Date.now() - n.open.timestamp < r.state.facet(Re).interactionDelay)
      return !1;
    let i = 1, s;
    e == "page" && (s = a1(r, n.open.tooltip)) && (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = n.open.options, a = n.open.selected > -1 ? n.open.selected + i * (t ? 1 : -1) : t ? 0 : o - 1;
    return a < 0 ? a = e == "page" ? 0 : o - 1 : a >= o && (a = e == "page" ? o - 1 : 0), r.dispatch({ effects: wv.of(a) }), !0;
  };
}
const vL = (t) => {
  let e = t.state.field(ht, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(Re).interactionDelay ? !1 : xv(t, e.open.options[e.open.selected]);
}, bL = (t) => t.state.field(ht, !1) ? (t.dispatch({ effects: pa.of(!0) }), !0) : !1, DL = (t) => {
  let e = t.state.field(ht, !1);
  return !e || !e.active.some(
    (r) => r.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: vs.of(null) }), !0);
};
class wL {
  constructor(e, r) {
    this.active = e, this.context = r, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const xL = 50, CL = 1e3, kL = /* @__PURE__ */ Ee.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(ht).active)
      e.state == 1 && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(ht);
    if (!t.selectionSet && !t.docChanged && t.startState.field(ht) == e)
      return;
    let r = t.transactions.some((i) => (i.selection || i.docChanged) && !gc(i));
    for (let i = 0; i < this.running.length; i++) {
      let s = this.running[i];
      if (r || s.updates.length + t.transactions.length > xL && Date.now() - s.time > CL) {
        for (let o of s.context.abortListeners)
          try {
            o();
          } catch (a) {
            At(this.view.state, a);
          }
        s.context.abortListeners = null, this.running.splice(i--, 1);
      } else
        s.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((i) => i.effects.some((s) => s.is(pa))) && (this.pendingStart = !0);
    let n = this.pendingStart ? 50 : t.state.facet(Re).activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((i) => i.state == 1 && !this.running.some((s) => s.active.source == i.source)) ? setTimeout(() => this.startUpdate(), n) : -1, this.composing != 0)
      for (let i of t.transactions)
        gc(i) == "input" ? this.composing = 2 : this.composing == 2 && i.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(ht);
    for (let r of e.active)
      r.state == 1 && !this.running.some((n) => n.active.source == r.source) && this.startQuery(r);
  }
  startQuery(t) {
    let { state: e } = this.view, r = Vr(e), n = new vv(e, r, t.explicitPos == r), i = new wL(t, n);
    this.running.push(i), Promise.resolve(t.source(n)).then((s) => {
      i.context.aborted || (i.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: vs.of(null) }), At(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Re).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], r = this.view.state.facet(Re);
    for (let n = 0; n < this.running.length; n++) {
      let i = this.running[n];
      if (i.done === void 0)
        continue;
      if (this.running.splice(n--, 1), i.done) {
        let o = new ii(i.active.source, i.active.explicitPos, i.done, i.done.from, (t = i.done.to) !== null && t !== void 0 ? t : Vr(i.updates.length ? i.updates[0].startState : this.view.state));
        for (let a of i.updates)
          o = o.update(a, r);
        if (o.hasResult()) {
          e.push(o);
          continue;
        }
      }
      let s = this.view.state.field(ht).active.find((o) => o.source == i.active.source);
      if (s && s.state == 1)
        if (i.done == null) {
          let o = new nt(
            i.active.source,
            0
            /* State.Inactive */
          );
          for (let a of i.updates)
            o = o.update(a, r);
          o.state != 1 && e.push(o);
        } else
          this.startQuery(s);
    }
    e.length && this.view.dispatch({ effects: Dv.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(ht, !1);
      if (e && e.tooltip && this.view.state.facet(Re).closeOnBlur) {
        let r = e.open && a1(this.view, e.open.tooltip);
        (!r || !r.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: vs.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: pa.of(!1) }), 20), this.composing = 0;
    }
  }
}), SL = /* @__PURE__ */ H.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
}), bs = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, mn = /* @__PURE__ */ J.define({
  map(t, e) {
    let r = e.mapPos(t, -1, Qe.TrackAfter);
    return r ?? void 0;
  }
}), Kh = /* @__PURE__ */ new class extends Cn {
}();
Kh.startSide = 1;
Kh.endSide = -1;
const Cv = /* @__PURE__ */ We.define({
  create() {
    return ie.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let r = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (n) => n >= r.from && n <= r.to });
    }
    for (let r of e.effects)
      r.is(mn) && (t = t.update({ add: [Kh.range(r.value, r.value + 1)] }));
    return t;
  }
});
function EL() {
  return [FL, Cv];
}
const Zl = "()[]{}<>";
function kv(t) {
  for (let e = 0; e < Zl.length; e += 2)
    if (Zl.charCodeAt(e) == t)
      return Zl.charAt(e + 1);
  return Ch(t < 128 ? t : t + 1);
}
function Sv(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || bs;
}
const AL = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), FL = /* @__PURE__ */ H.inputHandler.of((t, e, r, n) => {
  if ((AL ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let i = t.state.selection.main;
  if (n.length > 2 || n.length == 2 && St(Me(n, 0)) == 1 || e != i.from || r != i.to)
    return !1;
  let s = BL(t.state, n);
  return s ? (t.dispatch(s), !0) : !1;
}), TL = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = Sv(t, t.selection.main.head).brackets || bs.brackets, i = null, s = t.changeByRange((o) => {
    if (o.empty) {
      let a = OL(t.doc, o.head);
      for (let l of n)
        if (l == a && ll(t.doc, o.head) == kv(Me(l, 0)))
          return {
            changes: { from: o.head - l.length, to: o.head + l.length },
            range: B.cursor(o.head - l.length)
          };
    }
    return { range: i = o };
  });
  return i || e(t.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, _L = [
  { key: "Backspace", run: TL }
];
function BL(t, e) {
  let r = Sv(t, t.selection.main.head), n = r.brackets || bs.brackets;
  for (let i of n) {
    let s = kv(Me(i, 0));
    if (e == i)
      return s == i ? PL(t, i, n.indexOf(i + i + i) > -1, r) : ML(t, i, s, r.before || bs.before);
    if (e == s && Ev(t, t.selection.main.from))
      return LL(t, i, s);
  }
  return null;
}
function Ev(t, e) {
  let r = !1;
  return t.field(Cv).between(0, t.doc.length, (n) => {
    n == e && (r = !0);
  }), r;
}
function ll(t, e) {
  let r = t.sliceString(e, e + 2);
  return r.slice(0, St(Me(r, 0)));
}
function OL(t, e) {
  let r = t.sliceString(e - 2, e);
  return St(Me(r, 0)) == r.length ? r : r.slice(1);
}
function ML(t, e, r, n) {
  let i = null, s = t.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: r, from: o.to }],
        effects: mn.of(o.to + e.length),
        range: B.range(o.anchor + e.length, o.head + e.length)
      };
    let a = ll(t.doc, o.head);
    return !a || /\s/.test(a) || n.indexOf(a) > -1 ? {
      changes: { insert: e + r, from: o.head },
      effects: mn.of(o.head + e.length),
      range: B.cursor(o.head + e.length)
    } : { range: i = o };
  });
  return i ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function LL(t, e, r) {
  let n = null, i = t.changeByRange((s) => s.empty && ll(t.doc, s.head) == r ? {
    changes: { from: s.head, to: s.head + r.length, insert: r },
    range: B.cursor(s.head + r.length)
  } : n = { range: s });
  return n ? null : t.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function PL(t, e, r, n) {
  let i = n.stringPrefixes || bs.stringPrefixes, s = null, o = t.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: mn.of(a.to + e.length),
        range: B.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, c = ll(t.doc, l), u;
    if (c == e) {
      if (Rp(t, l))
        return {
          changes: { insert: e + e, from: l },
          effects: mn.of(l + e.length),
          range: B.cursor(l + e.length)
        };
      if (Ev(t, l)) {
        let f = r && t.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + f.length, insert: f },
          range: B.cursor(l + f.length)
        };
      }
    } else {
      if (r && t.sliceDoc(l - 2 * e.length, l) == e + e && (u = Ip(t, l - 2 * e.length, i)) > -1 && Rp(t, u))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: mn.of(l + e.length),
          range: B.cursor(l + e.length)
        };
      if (t.charCategorizer(l)(c) != xe.Word && Ip(t, l, i) > -1 && !NL(t, l, e, i))
        return {
          changes: { insert: e + e, from: l },
          effects: mn.of(l + e.length),
          range: B.cursor(l + e.length)
        };
    }
    return { range: s = a };
  });
  return s ? null : t.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Rp(t, e) {
  let r = Ke(t).resolveInner(e + 1);
  return r.parent && r.from == e;
}
function NL(t, e, r, n) {
  let i = Ke(t).resolveInner(e, -1), s = n.reduce((o, a) => Math.max(o, a.length), 0);
  for (let o = 0; o < 5; o++) {
    let a = t.sliceDoc(i.from, Math.min(i.to, i.from + r.length + s)), l = a.indexOf(r);
    if (!l || l > -1 && n.indexOf(a.slice(0, l)) > -1) {
      let u = i.firstChild;
      for (; u && u.from == i.from && u.to - u.from > r.length + l; ) {
        if (t.sliceDoc(u.to - r.length, u.to) == r)
          return !1;
        u = u.firstChild;
      }
      return !0;
    }
    let c = i.to == e && i.parent;
    if (!c)
      break;
    i = c;
  }
  return !1;
}
function Ip(t, e, r) {
  let n = t.charCategorizer(e);
  if (n(t.sliceDoc(e - 1, e)) != xe.Word)
    return e;
  for (let i of r) {
    let s = e - i.length;
    if (t.sliceDoc(s, e) == i && n(t.sliceDoc(s - 1, s)) != xe.Word)
      return s;
  }
  return -1;
}
function RL(t = {}) {
  return [
    ht,
    Re.of(t),
    kL,
    IL,
    SL
  ];
}
const Av = [
  { key: "Ctrl-Space", run: bL },
  { key: "Escape", run: DL },
  { key: "ArrowDown", run: /* @__PURE__ */ bo(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ bo(!1) },
  { key: "PageDown", run: /* @__PURE__ */ bo(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ bo(!1, "page") },
  { key: "Enter", run: vL }
], IL = /* @__PURE__ */ Di.highest(/* @__PURE__ */ Za.computeN([Re], (t) => t.facet(Re).defaultKeymap ? [Av] : []));
class $L {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.diagnostic = n;
  }
}
class hn {
  constructor(e, r, n) {
    this.diagnostics = e, this.panel = r, this.selected = n;
  }
  static init(e, r, n) {
    let i = e, s = n.facet(_v).markerFilter;
    s && (i = s(i, n));
    let o = K.set(i.map((a) => a.from == a.to || a.from == a.to - 1 && n.doc.lineAt(a.from).to == a.from ? K.widget({
      widget: new KL(a),
      diagnostic: a
    }).range(a.from) : K.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + a.severity + (a.markClass ? " " + a.markClass : "") },
      diagnostic: a,
      inclusive: !0
    }).range(a.from, a.to)), !0);
    return new hn(o, r, di(o));
  }
}
function di(t, e = null, r = 0) {
  let n = null;
  return t.between(r, 1e9, (i, s, { spec: o }) => {
    if (!(e && o.diagnostic != e))
      return n = new $L(i, s, o.diagnostic), !1;
  }), n;
}
function jL(t, e) {
  let r = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((n) => n.is(Fv)) || t.changes.touchesRange(r.from, r.to));
}
function WL(t, e) {
  return t.field(mt, !1) ? e : e.concat(J.appendConfig.of(XL));
}
const Fv = /* @__PURE__ */ J.define(), Yh = /* @__PURE__ */ J.define(), Tv = /* @__PURE__ */ J.define(), mt = /* @__PURE__ */ We.define({
  create() {
    return new hn(K.none, null, null);
  },
  update(t, e) {
    if (e.docChanged) {
      let r = t.diagnostics.map(e.changes), n = null;
      if (t.selected) {
        let i = e.changes.mapPos(t.selected.from, 1);
        n = di(r, t.selected.diagnostic, i) || di(r, null, i);
      }
      t = new hn(r, t.panel, n);
    }
    for (let r of e.effects)
      r.is(Fv) ? t = hn.init(r.value, t.panel, e.state) : r.is(Yh) ? t = new hn(t.diagnostics, r.value ? ul.open : null, t.selected) : r.is(Tv) && (t = new hn(t.diagnostics, t.panel, r.value));
    return t;
  },
  provide: (t) => [
    ps.from(t, (e) => e.panel),
    H.decorations.from(t, (e) => e.diagnostics)
  ]
}), qL = /* @__PURE__ */ K.mark({ class: "cm-lintRange cm-lintRange-active", inclusive: !0 });
function HL(t, e, r) {
  let { diagnostics: n } = t.state.field(mt), i = [], s = 2e8, o = 0;
  n.between(e - (r < 0 ? 1 : 0), e + (r > 0 ? 1 : 0), (l, c, { spec: u }) => {
    e >= l && e <= c && (l == c || (e > l || r > 0) && (e < c || r < 0)) && (i.push(u.diagnostic), s = Math.min(l, s), o = Math.max(c, o));
  });
  let a = t.state.facet(_v).tooltipFilter;
  return a && (i = a(i, t.state)), i.length ? {
    pos: s,
    end: o,
    above: t.state.doc.lineAt(s).to < o,
    create() {
      return { dom: VL(t, i) };
    }
  } : null;
}
function VL(t, e) {
  return de("ul", { class: "cm-tooltip-lint" }, e.map((r) => Ov(t, r, !1)));
}
const zL = (t) => {
  let e = t.state.field(mt, !1);
  (!e || !e.panel) && t.dispatch({ effects: WL(t.state, [Yh.of(!0)]) });
  let r = ds(t, ul.open);
  return r && r.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, $p = (t) => {
  let e = t.state.field(mt, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: Yh.of(!1) }), !0);
}, UL = (t) => {
  let e = t.state.field(mt, !1);
  if (!e)
    return !1;
  let r = t.state.selection.main, n = e.diagnostics.iter(r.to + 1);
  return !n.value && (n = e.diagnostics.iter(0), !n.value || n.from == r.from && n.to == r.to) ? !1 : (t.dispatch({ selection: { anchor: n.from, head: n.to }, scrollIntoView: !0 }), !0);
}, GL = [
  { key: "Mod-Shift-m", run: zL, preventDefault: !0 },
  { key: "F8", run: UL }
], _v = /* @__PURE__ */ z.define({
  combine(t) {
    return Object.assign({ sources: t.map((e) => e.source).filter((e) => e != null) }, ur(t.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (e, r) => e ? r ? (n) => e(n) || r(n) : e : r
    }));
  }
});
function Bv(t) {
  let e = [];
  if (t)
    e:
      for (let { name: r } of t) {
        for (let n = 0; n < r.length; n++) {
          let i = r[n];
          if (/[a-zA-Z]/.test(i) && !e.some((s) => s.toLowerCase() == i.toLowerCase())) {
            e.push(i);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function Ov(t, e, r) {
  var n;
  let i = r ? Bv(e.actions) : [];
  return de("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, de("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (n = e.actions) === null || n === void 0 ? void 0 : n.map((s, o) => {
    let a = !1, l = (f) => {
      if (f.preventDefault(), a)
        return;
      a = !0;
      let d = di(t.state.field(mt).diagnostics, e);
      d && s.apply(t, d.from, d.to);
    }, { name: c } = s, u = i[o] ? c.indexOf(i[o]) : -1, h = u < 0 ? c : [
      c.slice(0, u),
      de("u", c.slice(u, u + 1)),
      c.slice(u + 1)
    ];
    return de("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${i[o]})"`}.`
    }, h);
  }), e.source && de("div", { class: "cm-diagnosticSource" }, e.source));
}
class KL extends Sr {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return de("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class jp {
  constructor(e, r) {
    this.diagnostic = r, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = Ov(e, r, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class ul {
  constructor(e) {
    this.view = e, this.items = [];
    let r = (i) => {
      if (i.keyCode == 27)
        $p(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = Bv(s.actions);
        for (let a = 0; a < o.length; a++)
          if (o[a].toUpperCase().charCodeAt(0) == i.keyCode) {
            let l = di(this.view.state.field(mt).diagnostics, s);
            l && s.actions[a].apply(e, l.from, l.to);
          }
      } else
        return;
      i.preventDefault();
    }, n = (i) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(i.target) && this.moveSelection(s);
    };
    this.list = de("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: r,
      onclick: n
    }), this.dom = de("div", { class: "cm-panel-lint" }, this.list, de("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => $p(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(mt).selected;
    if (!e)
      return -1;
    for (let r = 0; r < this.items.length; r++)
      if (this.items[r].diagnostic == e.diagnostic)
        return r;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: r } = this.view.state.field(mt), n = 0, i = !1, s = null;
    for (e.between(0, this.view.state.doc.length, (o, a, { spec: l }) => {
      let c = -1, u;
      for (let h = n; h < this.items.length; h++)
        if (this.items[h].diagnostic == l.diagnostic) {
          c = h;
          break;
        }
      c < 0 ? (u = new jp(this.view, l.diagnostic), this.items.splice(n, 0, u), i = !0) : (u = this.items[c], c > n && (this.items.splice(n, c - n), i = !0)), r && u.diagnostic == r.diagnostic ? u.dom.hasAttribute("aria-selected") || (u.dom.setAttribute("aria-selected", "true"), s = u) : u.dom.hasAttribute("aria-selected") && u.dom.removeAttribute("aria-selected"), n++;
    }); n < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new jp(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: o, panel: a }) => {
        let l = a.height / this.list.offsetHeight;
        o.top < a.top ? this.list.scrollTop -= (a.top - o.top) / l : o.bottom > a.bottom && (this.list.scrollTop += (o.bottom - a.bottom) / l);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function r() {
      let n = e;
      e = n.nextSibling, n.remove();
    }
    for (let n of this.items)
      if (n.dom.parentNode == this.list) {
        for (; e != n.dom; )
          r();
        e = n.dom.nextSibling;
      } else
        this.list.insertBefore(n.dom, e);
    for (; e; )
      r();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let r = this.view.state.field(mt), n = di(r.diagnostics, this.items[e].diagnostic);
    n && this.view.dispatch({
      selection: { anchor: n.from, head: n.to },
      scrollIntoView: !0,
      effects: Tv.of(n)
    });
  }
  static open(e) {
    return new ul(e);
  }
}
function YL(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function Do(t) {
  return YL(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const JL = /* @__PURE__ */ H.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Do("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Do("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Do("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Do("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), XL = [
  mt,
  /* @__PURE__ */ H.decorations.compute([mt], (t) => {
    let { selected: e, panel: r } = t.field(mt);
    return !e || !r || e.from == e.to ? K.none : K.set([
      qL.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ YB(HL, { hideOn: jL }),
  JL
];
var Wp = function(e) {
  e === void 0 && (e = {});
  var {
    crosshairCursor: r = !1
  } = e, n = [];
  e.closeBracketsKeymap !== !1 && (n = n.concat(_L)), e.defaultKeymap !== !1 && (n = n.concat(EM)), e.searchKeymap !== !1 && (n = n.concat(XM)), e.historyKeymap !== !1 && (n = n.concat(P3)), e.foldKeymap !== !1 && (n = n.concat(YO)), e.completionKeymap !== !1 && (n = n.concat(Av)), e.lintKeymap !== !1 && (n = n.concat(GL));
  var i = [];
  return e.lineNumbers !== !1 && i.push(iO()), e.highlightActiveLineGutter !== !1 && i.push(aO()), e.highlightSpecialChars !== !1 && i.push(kB()), e.history !== !1 && i.push(E3()), e.foldGutter !== !1 && i.push(ZO()), e.drawSelection !== !1 && i.push(dB()), e.dropCursor !== !1 && i.push(vB()), e.allowMultipleSelections !== !1 && i.push(ee.allowMultipleSelections.of(!0)), e.indentOnInput !== !1 && i.push($O()), e.syntaxHighlighting !== !1 && i.push(S1(n3, {
    fallback: !0
  })), e.bracketMatching !== !1 && i.push(c3()), e.closeBrackets !== !1 && i.push(EL()), e.autocompletion !== !1 && i.push(RL()), e.rectangularSelection !== !1 && i.push(IB()), r !== !1 && i.push(WB()), e.highlightActiveLine !== !1 && i.push(_B()), e.highlightSelectionMatches !== !1 && i.push(OM()), e.tabSize && typeof e.tabSize == "number" && i.push(tl.of(" ".repeat(e.tabSize))), i.concat([Za.of(n.flat())]).filter(Boolean);
};
const QL = "#e5c07b", qp = "#e06c75", ZL = "#56b6c2", eP = "#ffffff", Io = "#abb2bf", yc = "#7d8799", tP = "#61afef", rP = "#98c379", Hp = "#d19a66", nP = "#c678dd", iP = "#21252b", Vp = "#2c313a", zp = "#282c34", eu = "#353a42", sP = "#3E4451", Up = "#528bff", oP = /* @__PURE__ */ H.theme({
  "&": {
    color: Io,
    backgroundColor: zp
  },
  ".cm-content": {
    caretColor: Up
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: Up },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: sP },
  ".cm-panels": { backgroundColor: iP, color: Io },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: zp,
    color: yc,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: Vp
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: eu
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: eu,
    borderBottomColor: eu
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: Vp,
      color: Io
    }
  }
}, { dark: !0 }), aP = /* @__PURE__ */ Is.define([
  {
    tag: T.keyword,
    color: nP
  },
  {
    tag: [T.name, T.deleted, T.character, T.propertyName, T.macroName],
    color: qp
  },
  {
    tag: [/* @__PURE__ */ T.function(T.variableName), T.labelName],
    color: tP
  },
  {
    tag: [T.color, /* @__PURE__ */ T.constant(T.name), /* @__PURE__ */ T.standard(T.name)],
    color: Hp
  },
  {
    tag: [/* @__PURE__ */ T.definition(T.name), T.separator],
    color: Io
  },
  {
    tag: [T.typeName, T.className, T.number, T.changed, T.annotation, T.modifier, T.self, T.namespace],
    color: QL
  },
  {
    tag: [T.operator, T.operatorKeyword, T.url, T.escape, T.regexp, T.link, /* @__PURE__ */ T.special(T.string)],
    color: ZL
  },
  {
    tag: [T.meta, T.comment],
    color: yc
  },
  {
    tag: T.strong,
    fontWeight: "bold"
  },
  {
    tag: T.emphasis,
    fontStyle: "italic"
  },
  {
    tag: T.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: T.link,
    color: yc,
    textDecoration: "underline"
  },
  {
    tag: T.heading,
    fontWeight: "bold",
    color: qp
  },
  {
    tag: [T.atom, T.bool, /* @__PURE__ */ T.special(T.variableName)],
    color: Hp
  },
  {
    tag: [T.processingInstruction, T.string, T.inserted],
    color: rP
  },
  {
    tag: T.invalid,
    color: eP
  }
]), lP = [oP, /* @__PURE__ */ S1(aP)];
var uP = H.theme({
  "&": {
    backgroundColor: "#fff"
  }
}, {
  dark: !1
}), cP = function(e) {
  e === void 0 && (e = {});
  var {
    indentWithTab: r = !0,
    editable: n = !0,
    readOnly: i = !1,
    theme: s = "light",
    placeholder: o = "",
    basicSetup: a = !0
  } = e, l = [];
  switch (r && l.unshift(Za.of([AM])), a && (typeof a == "boolean" ? l.unshift(Wp()) : l.unshift(Wp(a))), o && l.unshift(LB(o)), s) {
    case "light":
      l.push(uP);
      break;
    case "dark":
      l.push(lP);
      break;
    case "none":
      break;
    default:
      l.push(s);
      break;
  }
  return n === !1 && l.push(H.editable.of(!1)), i && l.push(ee.readOnly.of(!0)), [...l];
}, hP = (t) => ({
  line: t.state.doc.lineAt(t.state.selection.main.from),
  lineCount: t.state.doc.lines,
  lineBreak: t.state.lineBreak,
  length: t.state.doc.length,
  readOnly: t.state.readOnly,
  tabSize: t.state.tabSize,
  selection: t.state.selection,
  selectionAsSingle: t.state.selection.asSingle().main,
  ranges: t.state.selection.ranges,
  selectionCode: t.state.sliceDoc(t.state.selection.main.from, t.state.selection.main.to),
  selections: t.state.selection.ranges.map((e) => t.state.sliceDoc(e.from, e.to)),
  selectedText: t.state.selection.ranges.some((e) => !e.empty)
}), Gp = lr.define(), fP = [];
function dP(t) {
  var {
    value: e,
    selection: r,
    onChange: n,
    onStatistics: i,
    onCreateEditor: s,
    onUpdate: o,
    extensions: a = fP,
    autoFocus: l,
    theme: c = "light",
    height: u = null,
    minHeight: h = null,
    maxHeight: f = null,
    width: d = null,
    minWidth: p = null,
    maxWidth: m = null,
    placeholder: y = "",
    editable: v = !0,
    readOnly: g = !1,
    indentWithTab: b = !0,
    basicSetup: w = !0,
    root: D,
    initialState: x
  } = t, [C, k] = jr(), [S, A] = jr(), [_, N] = jr(), $ = H.theme({
    "&": {
      height: u,
      minHeight: h,
      maxHeight: f,
      width: d,
      minWidth: p,
      maxWidth: m
    },
    "& .cm-scroller": {
      height: "100% !important"
    }
  }), L = H.updateListener.of((G) => {
    if (G.docChanged && typeof n == "function" && // Fix echoing of the remote changes:
    // If transaction is market as remote we don't have to call `onChange` handler again
    !G.transactions.some((ue) => ue.annotation(Gp))) {
      var re = G.state.doc, oe = re.toString();
      n(oe, G);
    }
    i && i(hP(G));
  }), I = cP({
    theme: c,
    editable: v,
    readOnly: g,
    placeholder: y,
    indentWithTab: b,
    basicSetup: w
  }), P = [L, $, ...I];
  return o && typeof o == "function" && P.push(H.updateListener.of(o)), P = P.concat(a), Nt(() => {
    if (C && !_) {
      var G = {
        doc: e,
        selection: r,
        extensions: P
      }, re = x ? ee.fromJSON(x.json, G, x.fields) : ee.create(G);
      if (N(re), !S) {
        var oe = new H({
          state: re,
          parent: C,
          root: D
        });
        A(oe), s && s(oe, re);
      }
    }
    return () => {
      S && (N(void 0), A(void 0));
    };
  }, [C, _]), Nt(() => k(t.container), [t.container]), Nt(() => () => {
    S && (S.destroy(), A(void 0));
  }, [S]), Nt(() => {
    l && S && S.focus();
  }, [l, S]), Nt(() => {
    S && S.dispatch({
      effects: J.reconfigure.of(P)
    });
  }, [c, a, u, h, f, d, p, m, y, v, g, b, w, n, o]), Nt(() => {
    if (e !== void 0) {
      var G = S ? S.state.doc.toString() : "";
      S && e !== G && S.dispatch({
        changes: {
          from: 0,
          to: G.length,
          insert: e || ""
        },
        annotations: [Gp.of(!0)]
      });
    }
  }, [e, S]), {
    state: _,
    setState: N,
    view: S,
    setView: A,
    container: C,
    setContainer: k
  };
}
var pP = ["className", "value", "selection", "extensions", "onChange", "onStatistics", "onCreateEditor", "onUpdate", "autoFocus", "theme", "height", "minHeight", "maxHeight", "width", "minWidth", "maxWidth", "basicSetup", "placeholder", "indentWithTab", "editable", "readOnly", "root", "initialState"], Mv = /* @__PURE__ */ zv((t, e) => {
  var {
    className: r,
    value: n = "",
    selection: i,
    extensions: s = [],
    onChange: o,
    onStatistics: a,
    onCreateEditor: l,
    onUpdate: c,
    autoFocus: u,
    theme: h = "light",
    height: f,
    minHeight: d,
    maxHeight: p,
    width: m,
    minWidth: y,
    maxWidth: v,
    basicSetup: g,
    placeholder: b,
    indentWithTab: w,
    editable: D,
    readOnly: x,
    root: C,
    initialState: k
  } = t, S = dT(t, pP), A = vc(null), {
    state: _,
    view: N,
    container: $
  } = dP({
    container: A.current,
    root: C,
    value: n,
    autoFocus: u,
    theme: h,
    height: f,
    minHeight: d,
    maxHeight: p,
    width: m,
    minWidth: y,
    maxWidth: v,
    basicSetup: g,
    placeholder: b,
    indentWithTab: w,
    editable: D,
    readOnly: x,
    selection: i,
    onChange: o,
    onStatistics: a,
    onCreateEditor: l,
    onUpdate: c,
    extensions: s,
    initialState: k
  });
  if (Uv(e, () => ({
    editor: A.current,
    state: _,
    view: N
  }), [A, $, _, N]), typeof n != "string")
    throw new Error("value must be typeof string but got " + typeof n);
  var L = typeof h == "string" ? "cm-theme-" + h : "cm-theme";
  return /* @__PURE__ */ M.jsx("div", wu({
    ref: A,
    className: "" + L + (r ? " " + r : "")
  }, S));
});
Mv.displayName = "CodeMirror";
const mP = () => {
  const { config: t } = vt();
  return l2(t);
}, gP = {
  html: Yv(),
  css: Jv(),
  js: Xv(),
  json: Qv()
}, yP = () => {
  var c;
  const [t, e] = jr("light"), {
    project: r,
    saveFile: n,
    config: { editableFileTypes: i }
  } = vt(), s = mP(), o = (c = Object.values(r.files).filter((u) => u.active)) == null ? void 0 : c[0], a = Gv(
    (u) => {
      n(o.id, u);
    },
    [n, o]
  ), l = async () => {
    try {
      const u = await QF(o.contents, o.language);
      n(o.id, u);
    } catch (u) {
      console.log("FAILURE : ", u);
    }
  };
  return o ? s2(o.language, i) ? /* @__PURE__ */ M.jsxs("div", { className: "editor-container", children: [
    /* @__PURE__ */ M.jsx("button", { onClick: () => l(), children: "Format" }),
    /* @__PURE__ */ M.jsxs("select", { onChange: (u) => e(u.target.value), children: [
      /* @__PURE__ */ M.jsx("option", { value: "light", children: "light theme" }),
      /* @__PURE__ */ M.jsx("option", { value: "dark", children: "dark theme" })
    ] }),
    o && /* @__PURE__ */ M.jsx(
      Mv,
      {
        value: o.contents,
        width: "100%",
        height: "100%",
        extensions: [gP[o.language]],
        onChange: a,
        theme: t
      }
    )
  ] }) : /* @__PURE__ */ M.jsxs("div", { children: [
    "Can only edit html, css, or javascript files. Cannot edit",
    " ",
    o.language,
    " files."
  ] }) : /* @__PURE__ */ M.jsx(s, {});
}, vP = () => {
  const { config: t } = vt(), e = t.EditorComponent || yP;
  return /* @__PURE__ */ M.jsxs("div", { className: "center-pane", children: [
    /* @__PURE__ */ M.jsx("div", { className: "center-nav", children: /* @__PURE__ */ M.jsx(fT, {}) }),
    /* @__PURE__ */ M.jsx("div", { className: "center-main", children: /* @__PURE__ */ M.jsx(e, {}) })
  ] });
}, bP = ({ file: t }) => {
  const e = vc(null), {
    project: { files: r, folders: n }
  } = vt(), i = Jp(() => t ? t.contents.replace(
    new RegExp('<link rel="stylesheet" href="([^"]+)"/>', "g"),
    (o, a) => {
      const l = a.split("/"), c = l.pop(), u = Qp(l, {
        folders: Object.values(n)
      }), h = Object.values(r).find(
        (f) => f.name === c && f.folderId === u
      );
      return `
          <style>
            ${h == null ? void 0 : h.contents}
          </style>
      `;
    }
  ) : "", [r, t]);
  return /* @__PURE__ */ M.jsx(M.Fragment, { children: t && /* @__PURE__ */ M.jsx(
    "iframe",
    {
      allow: "self",
      title: "Web Preview",
      ref: e,
      id: "preview",
      style: { width: "100%", height: "100%" },
      srcDoc: i
    }
  ) });
};
var Lv = { exports: {} };
(function(t, e) {
  (function(n, i) {
    t.exports = i();
  })(Zv, function() {
    return (
      /******/
      function(r) {
        var n = {};
        function i(s) {
          if (n[s])
            return n[s].exports;
          var o = n[s] = {
            /******/
            i: s,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return r[s].call(o.exports, o, o.exports, i), o.l = !0, o.exports;
        }
        return i.m = r, i.c = n, i.i = function(s) {
          return s;
        }, i.d = function(s, o, a) {
          i.o(s, o) || Object.defineProperty(s, o, {
            /******/
            configurable: !1,
            /******/
            enumerable: !0,
            /******/
            get: a
            /******/
          });
        }, i.n = function(s) {
          var o = s && s.__esModule ? (
            /******/
            function() {
              return s.default;
            }
          ) : (
            /******/
            function() {
              return s;
            }
          );
          return i.d(o, "a", o), o;
        }, i.o = function(s, o) {
          return Object.prototype.hasOwnProperty.call(s, o);
        }, i.p = "", i(i.s = 3);
      }([
        /* 0 */
        /***/
        function(r, n, i) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          });
          var s = Object.assign || function(y) {
            for (var v = 1; v < arguments.length; v++) {
              var g = arguments[v];
              for (var b in g)
                Object.prototype.hasOwnProperty.call(g, b) && (y[b] = g[b]);
            }
            return y;
          }, o = /* @__PURE__ */ function() {
            function y(v, g) {
              for (var b = 0; b < g.length; b++) {
                var w = g[b];
                w.enumerable = w.enumerable || !1, w.configurable = !0, "value" in w && (w.writable = !0), Object.defineProperty(v, w.key, w);
              }
            }
            return function(v, g, b) {
              return g && y(v.prototype, g), b && y(v, b), v;
            };
          }();
          function a(y) {
            if (Array.isArray(y)) {
              for (var v = 0, g = Array(y.length); v < y.length; v++)
                g[v] = y[v];
              return g;
            } else
              return Array.from(y);
          }
          function l(y, v) {
            if (!(y instanceof v))
              throw new TypeError("Cannot call a class as a function");
          }
          var c = n.TYPE_MESSAGE = "message", u = n.TYPE_RESPONSE = "response", h = n.TYPE_SET_INTERFACE = "set-interface", f = n.TYPE_SERVICE_MESSAGE = "service-message", d = !!window.MSInputMethodContext && !!document.documentMode, p = {
            //Will not affect IE11 because there sandboxed iframe has not 'null' origin
            //but base URL of iframe's src
            allowedSenderOrigin: void 0
          }, m = function() {
            function y(v, g, b) {
              var w = this;
              l(this, y), this.options = s({}, p, b), this.incrementalID = Math.floor(Math.random() * 1e5), this.postMessage = v, this.remote = {}, this.callbacks = {}, this.remoteMethodsWaitPromise = new Promise(function(D) {
                w._resolveRemoteMethodsPromise = D;
              }), g(function() {
                return w.onMessageListener.apply(w, arguments);
              });
            }
            return o(y, [{
              key: "onMessageListener",
              value: function(g) {
                var b = this, w = g.data, D = this.options.allowedSenderOrigin;
                D && g.origin !== D && !d || (w.type === u ? this.popCallback(w.callId, w.success, w.result) : w.type === c ? this.callLocalApi(w.methodName, w.arguments).then(function(x) {
                  return b.responseOtherSide(w.callId, x);
                }).catch(function(x) {
                  return b.responseOtherSide(w.callId, x, !1);
                }) : w.type === h ? (this.setInterface(w.apiMethods), this.responseOtherSide(w.callId)) : w.type === f && this.callLocalServiceMethod(w.methodName, w.arguments).then(function(x) {
                  return b.responseOtherSide(w.callId, x);
                }).catch(function(x) {
                  return b.responseOtherSide(w.callId, x, !1);
                }));
              }
            }, {
              key: "postMessageToOtherSide",
              value: function(g) {
                this.postMessage(g, "*");
              }
              /**
                 * Sets remote interface methods
                 * @param remote - hash with keys of remote API methods. Values is ignored
                 */
            }, {
              key: "setInterface",
              value: function(g) {
                var b = this;
                this.remote = {}, g.forEach(function(w) {
                  return b.remote[w] = b.createMethodWrapper(w);
                }), this._resolveRemoteMethodsPromise();
              }
            }, {
              key: "setLocalApi",
              value: function(g) {
                var b = this;
                return new Promise(function(w, D) {
                  var x = b.registerCallback(w, D);
                  b.postMessageToOtherSide({
                    callId: x,
                    apiMethods: Object.keys(g),
                    type: h
                  });
                }).then(function() {
                  return b.localApi = g;
                });
              }
            }, {
              key: "setServiceMethods",
              value: function(g) {
                this.serviceMethods = g;
              }
              /**
                 * Calls local method
                 * @param methodName
                 * @param args
                 * @returns {Promise.<*>|string}
                 */
            }, {
              key: "callLocalApi",
              value: function(g, b) {
                var w;
                return Promise.resolve((w = this.localApi)[g].apply(w, a(b)));
              }
              /**
                 * Calls local method registered as "service method"
                 * @param methodName
                 * @param args
                 * @returns {Promise.<*>}
                 */
            }, {
              key: "callLocalServiceMethod",
              value: function(g, b) {
                var w;
                if (!this.serviceMethods[g])
                  throw new Error("Serivce method " + g + " is not registered");
                return Promise.resolve((w = this.serviceMethods)[g].apply(w, a(b)));
              }
              /**
                 * Wraps remote method with callback storing code
                 * @param methodName - method to wrap
                 * @returns {Function} - function to call as remote API interface
                 */
            }, {
              key: "createMethodWrapper",
              value: function(g) {
                var b = this;
                return function() {
                  for (var w = arguments.length, D = Array(w), x = 0; x < w; x++)
                    D[x] = arguments[x];
                  return b.callRemoteMethod.apply(b, [g].concat(D));
                };
              }
              /**
                 * Calls other side with arguments provided
                 * @param id
                 * @param methodName
                 * @param args
                 */
            }, {
              key: "callRemoteMethod",
              value: function(g) {
                for (var b = this, w = arguments.length, D = Array(w > 1 ? w - 1 : 0), x = 1; x < w; x++)
                  D[x - 1] = arguments[x];
                return new Promise(function(C, k) {
                  var S = b.registerCallback(C, k);
                  b.postMessageToOtherSide({
                    callId: S,
                    methodName: g,
                    type: c,
                    arguments: D
                  });
                });
              }
              /**
                 * Calls remote service method
                 * @param methodName
                 * @param args
                 * @returns {*}
                 */
            }, {
              key: "callRemoteServiceMethod",
              value: function(g) {
                for (var b = this, w = arguments.length, D = Array(w > 1 ? w - 1 : 0), x = 1; x < w; x++)
                  D[x - 1] = arguments[x];
                return new Promise(function(C, k) {
                  var S = b.registerCallback(C, k);
                  b.postMessageToOtherSide({
                    callId: S,
                    methodName: g,
                    type: f,
                    arguments: D
                  });
                });
              }
              /**
                 * Respond to remote call
                 * @param id - remote call ID
                 * @param result - result to pass to calling function
                 */
            }, {
              key: "responseOtherSide",
              value: function(g, b) {
                var w = this, D = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
                b instanceof Error && (b = [].concat(a(Object.keys(b)), ["message"]).reduce(function(C, k) {
                  return C[k] = b[k], C;
                }, {}));
                var x = function() {
                  return w.postMessage({
                    callId: g,
                    type: u,
                    success: D,
                    result: b
                  }, "*");
                };
                try {
                  x();
                } catch (C) {
                  console.error("Failed to post response, recovering...", C), C instanceof DOMException && (b = JSON.parse(JSON.stringify(b)), x());
                }
              }
              /**
                 * Stores callbacks to call later when remote call will be answered
                 * @param successCallback
                 * @param failureCallback
                 */
            }, {
              key: "registerCallback",
              value: function(g, b) {
                var w = (++this.incrementalID).toString();
                return this.callbacks[w] = { successCallback: g, failureCallback: b }, w;
              }
              /**
                 * Calls and delete stored callback
                 * @param id - call id
                 * @param success - was call successful
                 * @param result - result of remote call
                 */
            }, {
              key: "popCallback",
              value: function(g, b, w) {
                b ? this.callbacks[g].successCallback(w) : this.callbacks[g].failureCallback(w), delete this.callbacks[g];
              }
            }]), y;
          }();
          n.default = m;
        },
        /* 1 */
        /***/
        function(r, n) {
          r.exports = `/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TYPE_MESSAGE = exports.TYPE_MESSAGE = 'message';
var TYPE_RESPONSE = exports.TYPE_RESPONSE = 'response';
var TYPE_SET_INTERFACE = exports.TYPE_SET_INTERFACE = 'set-interface';
var TYPE_SERVICE_MESSAGE = exports.TYPE_SERVICE_MESSAGE = 'service-message';

var isIE11 = !!window.MSInputMethodContext && !!document.documentMode;

var defaultOptions = {
  //Will not affect IE11 because there sandboxed iframe has not 'null' origin
  //but base URL of iframe's src
  allowedSenderOrigin: undefined
};

var Connection = function () {
  function Connection(postMessage, registerOnMessageListener, options) {
    var _this = this;

    _classCallCheck(this, Connection);

    this.options = _extends({}, defaultOptions, options);
    //Random number between 0 and 100000
    this.incrementalID = Math.floor(Math.random() * 100000);

    this.postMessage = postMessage;
    this.remote = {};
    this.callbacks = {};

    this.remoteMethodsWaitPromise = new Promise(function (resolve) {
      _this._resolveRemoteMethodsPromise = resolve;
    });

    registerOnMessageListener(function () {
      return _this.onMessageListener.apply(_this, arguments);
    });
  }

  /**
     * Listens to remote messages. Calls local method if it is called outside or call stored callback if it is response.
     * @param e - onMessage event
     */


  _createClass(Connection, [{
    key: 'onMessageListener',
    value: function onMessageListener(e) {
      var _this2 = this;

      var data = e.data;

      var allowedSenderOrigin = this.options.allowedSenderOrigin;

      if (allowedSenderOrigin && e.origin !== allowedSenderOrigin && !isIE11) {
        return;
      }

      if (data.type === TYPE_RESPONSE) {
        this.popCallback(data.callId, data.success, data.result);
      } else if (data.type === TYPE_MESSAGE) {
        this.callLocalApi(data.methodName, data.arguments).then(function (res) {
          return _this2.responseOtherSide(data.callId, res);
        }).catch(function (err) {
          return _this2.responseOtherSide(data.callId, err, false);
        });
      } else if (data.type === TYPE_SET_INTERFACE) {
        this.setInterface(data.apiMethods);
        this.responseOtherSide(data.callId);
      } else if (data.type === TYPE_SERVICE_MESSAGE) {
        this.callLocalServiceMethod(data.methodName, data.arguments).then(function (res) {
          return _this2.responseOtherSide(data.callId, res);
        }).catch(function (err) {
          return _this2.responseOtherSide(data.callId, err, false);
        });
      }
    }
  }, {
    key: 'postMessageToOtherSide',
    value: function postMessageToOtherSide(dataToPost) {
      this.postMessage(dataToPost, '*');
    }

    /**
       * Sets remote interface methods
       * @param remote - hash with keys of remote API methods. Values is ignored
       */

  }, {
    key: 'setInterface',
    value: function setInterface(remoteMethods) {
      var _this3 = this;

      this.remote = {};

      remoteMethods.forEach(function (key) {
        return _this3.remote[key] = _this3.createMethodWrapper(key);
      });

      this._resolveRemoteMethodsPromise();
    }
  }, {
    key: 'setLocalApi',
    value: function setLocalApi(api) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        var id = _this4.registerCallback(resolve, reject);
        _this4.postMessageToOtherSide({
          callId: id,
          apiMethods: Object.keys(api),
          type: TYPE_SET_INTERFACE
        });
      }).then(function () {
        return _this4.localApi = api;
      });
    }
  }, {
    key: 'setServiceMethods',
    value: function setServiceMethods(api) {
      this.serviceMethods = api;
    }

    /**
       * Calls local method
       * @param methodName
       * @param args
       * @returns {Promise.<*>|string}
       */

  }, {
    key: 'callLocalApi',
    value: function callLocalApi(methodName, args) {
      var _localApi;

      return Promise.resolve((_localApi = this.localApi)[methodName].apply(_localApi, _toConsumableArray(args)));
    }

    /**
       * Calls local method registered as "service method"
       * @param methodName
       * @param args
       * @returns {Promise.<*>}
       */

  }, {
    key: 'callLocalServiceMethod',
    value: function callLocalServiceMethod(methodName, args) {
      var _serviceMethods;

      if (!this.serviceMethods[methodName]) {
        throw new Error('Serivce method ' + methodName + ' is not registered');
      }
      return Promise.resolve((_serviceMethods = this.serviceMethods)[methodName].apply(_serviceMethods, _toConsumableArray(args)));
    }

    /**
       * Wraps remote method with callback storing code
       * @param methodName - method to wrap
       * @returns {Function} - function to call as remote API interface
       */

  }, {
    key: 'createMethodWrapper',
    value: function createMethodWrapper(methodName) {
      var _this5 = this;

      return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _this5.callRemoteMethod.apply(_this5, [methodName].concat(args));
      };
    }

    /**
       * Calls other side with arguments provided
       * @param id
       * @param methodName
       * @param args
       */

  }, {
    key: 'callRemoteMethod',
    value: function callRemoteMethod(methodName) {
      var _this6 = this;

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return new Promise(function (resolve, reject) {
        var id = _this6.registerCallback(resolve, reject);
        _this6.postMessageToOtherSide({
          callId: id,
          methodName: methodName,
          type: TYPE_MESSAGE,
          arguments: args
        });
      });
    }

    /**
       * Calls remote service method
       * @param methodName
       * @param args
       * @returns {*}
       */

  }, {
    key: 'callRemoteServiceMethod',
    value: function callRemoteServiceMethod(methodName) {
      var _this7 = this;

      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return new Promise(function (resolve, reject) {
        var id = _this7.registerCallback(resolve, reject);
        _this7.postMessageToOtherSide({
          callId: id,
          methodName: methodName,
          type: TYPE_SERVICE_MESSAGE,
          arguments: args
        });
      });
    }

    /**
       * Respond to remote call
       * @param id - remote call ID
       * @param result - result to pass to calling function
       */

  }, {
    key: 'responseOtherSide',
    value: function responseOtherSide(id, result) {
      var _this8 = this;

      var success = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (result instanceof Error) {
        // Error could be non-serializable, so we copy properties manually
        result = [].concat(_toConsumableArray(Object.keys(result)), ['message']).reduce(function (acc, it) {
          acc[it] = result[it];
          return acc;
        }, {});
      }

      var doPost = function doPost() {
        return _this8.postMessage({
          callId: id,
          type: TYPE_RESPONSE,
          success: success,
          result: result
        }, '*');
      };

      try {
        doPost();
      } catch (err) {
        console.error('Failed to post response, recovering...', err); // eslint-disable-line no-console
        if (err instanceof DOMException) {
          result = JSON.parse(JSON.stringify(result));
          doPost();
        }
      }
    }

    /**
       * Stores callbacks to call later when remote call will be answered
       * @param successCallback
       * @param failureCallback
       */

  }, {
    key: 'registerCallback',
    value: function registerCallback(successCallback, failureCallback) {
      var id = (++this.incrementalID).toString();
      this.callbacks[id] = { successCallback: successCallback, failureCallback: failureCallback };
      return id;
    }

    /**
       * Calls and delete stored callback
       * @param id - call id
       * @param success - was call successful
       * @param result - result of remote call
       */

  }, {
    key: 'popCallback',
    value: function popCallback(id, success, result) {
      if (success) {
        this.callbacks[id].successCallback(result);
      } else {
        this.callbacks[id].failureCallback(result);
      }
      delete this.callbacks[id];
    }
  }]);

  return Connection;
}();

exports.default = Connection;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _connection = __webpack_require__(0);

var _connection2 = _interopRequireDefault(_connection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Frame = function () {
  function Frame() {
    var _this = this;

    _classCallCheck(this, Frame);

    this.connection = new _connection2.default(window.parent.postMessage.bind(window.parent), function (listener) {
      window.addEventListener('message', listener);
    });

    this.connection.setServiceMethods({
      runCode: function runCode(code) {
        return _this.runCode(code);
      },
      importScript: function importScript(path) {
        return _this.importScript(path);
      },
      injectStyle: function injectStyle(style) {
        return _this.injectStyle(style);
      },
      importStyle: function importStyle(path) {
        return _this.importStyle(path);
      }
    });

    this.connection.callRemoteServiceMethod('iframeInitialized');
  }

  /**
     * Creates script tag with passed code and attaches it. Runs synchronous
     * @param code
     */


  _createClass(Frame, [{
    key: 'runCode',
    value: function runCode(code) {
      var scriptTag = document.createElement('script');
      scriptTag.innerHTML = code;
      document.getElementsByTagName('head')[0].appendChild(scriptTag);
    }
  }, {
    key: 'importScript',
    value: function importScript(scriptUrl) {
      var scriptTag = document.createElement('script');
      scriptTag.src = scriptUrl;
      document.getElementsByTagName('head')[0].appendChild(scriptTag);
      return new Promise(function (resolve) {
        return scriptTag.onload = function () {
          return resolve();
        };
      });
    }
  }, {
    key: 'injectStyle',
    value: function injectStyle(style) {
      var styleTag = document.createElement('style');
      styleTag.innerHTML = style;
      document.getElementsByTagName('head')[0].appendChild(styleTag);
    }
  }, {
    key: 'importStyle',
    value: function importStyle(styleUrl) {
      var linkTag = document.createElement('link');
      linkTag.rel = 'stylesheet';
      linkTag.href = styleUrl;
      document.getElementsByTagName('head')[0].appendChild(linkTag);
    }
  }]);

  return Frame;
}();

var Websandbox = new Frame();
window.Websandbox = window.Websandbox || Websandbox;
module.exports = Websandbox; // eslint-disable-line

/***/ })
/******/ ]);
//# sourceMappingURL=compile-loader-file-name.js.map`;
        },
        ,
        /* 3 */
        /***/
        function(r, n, i) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.BaseOptions = void 0;
          var s = Object.assign || function(m) {
            for (var y = 1; y < arguments.length; y++) {
              var v = arguments[y];
              for (var g in v)
                Object.prototype.hasOwnProperty.call(v, g) && (m[g] = v[g]);
            }
            return m;
          }, o = /* @__PURE__ */ function() {
            function m(y, v) {
              for (var g = 0; g < v.length; g++) {
                var b = v[g];
                b.enumerable = b.enumerable || !1, b.configurable = !0, "value" in b && (b.writable = !0), Object.defineProperty(y, b.key, b);
              }
            }
            return function(y, v, g) {
              return v && m(y.prototype, v), g && m(y, g), y;
            };
          }(), a = i(0), l = h(a), c = i(1), u = h(c);
          function h(m) {
            return m && m.__esModule ? m : { default: m };
          }
          function f(m, y) {
            if (!(m instanceof y))
              throw new TypeError("Cannot call a class as a function");
          }
          var d = n.BaseOptions = {
            frameContainer: "body",
            frameClassName: "websandbox__frame",
            frameSrc: null,
            frameContent: `
<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"></head>
<body></body>
</html>
  `,
            codeToRunBeforeInit: null,
            initialStyles: null,
            baseUrl: null,
            allowPointerLock: !1,
            allowFullScreen: !1,
            sandboxAdditionalAttributes: ""
          }, p = function() {
            o(m, null, [{
              key: "create",
              /**
               * Creates sandbox instancea
               * @param {?Object} localApi Api of this side. Will be available for sandboxed code as remoteApi
               * @param {?SandboxOptions} options Options of created sandbox
               */
              value: function(v) {
                var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                return new m(v, s(d, g));
              }
              /**
               * {Constructor}
               * @param {?Object} localApi
               * @param {?SandboxOptions} options
               */
            }]);
            function m(y, v) {
              var g = this;
              f(this, m), this.options = v, this.iframe = this.createIframe(), this.promise = new Promise(function(b) {
                g.connection = new l.default(g.iframe.contentWindow.postMessage.bind(g.iframe.contentWindow), function(w) {
                  var D = function(C) {
                    if (C.source === g.iframe.contentWindow)
                      return w(C);
                  };
                  window.addEventListener("message", D), g.removeMessageListener = function() {
                    return window.removeEventListener("message", D);
                  };
                }, { allowedSenderOrigin: "null" }), g.connection.setServiceMethods({
                  iframeInitialized: function() {
                    return g.connection.setLocalApi(y).then(function() {
                      return b(g);
                    });
                  }
                });
              });
            }
            return o(m, [{
              key: "_prepareFrameContent",
              value: function(v) {
                var g = v.frameContent.replace("</head>", "<script>" + u.default + `<\/script>
</head>`);
                return v.initialStyles && (g = g.replace("</head>", "<style>" + v.initialStyles + `</style>
</head>`)), v.baseUrl && (g = g.replace("<head>", `<head>
<base href="` + v.baseUrl + '"/>')), v.codeToRunBeforeInit && (g = g.replace("<head>", `<head>
<script>` + v.codeToRunBeforeInit + "<\/script>")), g;
              }
            }, {
              key: "createIframe",
              value: function() {
                var v = this.options.frameContainer, g = typeof v == "string" ? document.querySelector(v) : v;
                if (!g)
                  throw new Error("Websandbox: Cannot find container for sandbox " + g);
                var b = document.createElement("iframe");
                if (b.sandbox = "allow-scripts " + this.options.sandboxAdditionalAttributes, b.className = this.options.frameClassName, this.options.allowFullScreen && (b.allowfullscreen = "true"), this.options.frameSrc)
                  return b.src = this.options.frameSrc, g.appendChild(b), b;
                if (this.options.frameContent.indexOf("<head>") < 0)
                  throw new Error('Websandbox: iFrame content must have "<head>" tag.');
                return b.setAttribute("srcdoc", this._prepareFrameContent(this.options)), g.appendChild(b), b;
              }
            }, {
              key: "destroy",
              value: function() {
                this.iframe.remove(), this.removeMessageListener();
              }
            }, {
              key: "_runCode",
              value: function(v) {
                return this.connection.callRemoteServiceMethod("runCode", v);
              }
            }, {
              key: "_runFunction",
              value: function(v) {
                return this._runCode("(" + v.toString() + ")()");
              }
            }, {
              key: "run",
              value: function(v) {
                return v.name ? this._runFunction(v) : this._runCode(v);
              }
            }, {
              key: "importScript",
              value: function(v) {
                return this.connection.callRemoteServiceMethod("importScript", v);
              }
            }, {
              key: "injectStyle",
              value: function(v) {
                return this.connection.callRemoteServiceMethod("injectStyle", v);
              }
            }]), m;
          }();
          n.default = p;
        }
        /******/
      ])
    );
  });
})(Lv);
var DP = Lv.exports;
const wP = /* @__PURE__ */ e2(DP), xP = ({ output: t }) => {
  const [e, r] = jr(t);
  return Nt(() => r(t), [t]), /* @__PURE__ */ M.jsxs("div", { className: "debugger-pane", children: [
    /* @__PURE__ */ M.jsxs("div", { className: "debugger-title-bar", children: [
      /* @__PURE__ */ M.jsx("div", { className: "debugger-title", children: "Console" }),
      /* @__PURE__ */ M.jsx("button", { type: "button", onClick: () => r(void 0), children: "Clear console" })
    ] }),
    /* @__PURE__ */ M.jsx("div", { className: "debugger-view", children: e == null ? void 0 : e.map((n) => n.join(", ")).join(`
`) })
  ] });
}, CP = ({
  contentFrameHeight: t = "1fr",
  debuggerOutput: e,
  children: r
}) => {
  const { config: n } = vt();
  return /* @__PURE__ */ M.jsxs(
    "div",
    {
      className: "debugger-wrapper",
      style: {
        gridTemplateRows: n.showDebug ? `${t} 1fr` : "auto"
      },
      children: [
        /* @__PURE__ */ M.jsx("div", { className: "debugger-wrapper-child", children: r }),
        n.showDebug && /* @__PURE__ */ M.jsx(xP, { output: e })
      ]
    }
  );
}, kP = ({ file: t }) => {
  const [e, r] = jr([]), n = () => {
    const i = {
      consoleLog: (...s) => (r((o) => [...o, s]), Promise.resolve("messaged"))
    };
    for (let s of document.getElementsByClassName("js-preview-output"))
      s.innerHTML = "";
    wP.create(i, {
      frameContainer: ".js-preview-output"
    }).promise.then(function(s) {
      r([]), s.run(
        `
        console.log = Websandbox.connection.remote.consoleLog;
        ${t.contents}
      `
      );
    });
  };
  return /* @__PURE__ */ M.jsx(CP, { contentFrameHeight: "1fr", debuggerOutput: e, children: /* @__PURE__ */ M.jsxs("div", { className: "js-preview-container", children: [
    /* @__PURE__ */ M.jsx("div", { className: "js-preview-output", children: "pending..." }),
    /* @__PURE__ */ M.jsx("div", { className: "button-bar", children: /* @__PURE__ */ M.jsx("button", { onClick: n, children: "Run" }) })
  ] }) });
}, SP = ({ file: t }) => {
  let e = "";
  try {
    e = JSON.stringify(JSON.parse(t.contents), void 0, 2);
  } catch (r) {
    const n = Zp(r);
    return /* @__PURE__ */ M.jsxs("div", { className: "json-preview", children: [
      "Cannot display json: invalid format.",
      n
    ] });
  }
  return /* @__PURE__ */ M.jsx("div", { className: "json-preview", children: e });
}, Kp = {
  html: bP,
  js: kP,
  json: SP
}, EP = (t, e = {}) => t ? e[t == null ? void 0 : t.language] ? e[t == null ? void 0 : t.language] : Kp[t == null ? void 0 : t.language] ? Kp[t == null ? void 0 : t.language] : () => /* @__PURE__ */ M.jsxs("div", { children: [
  "Cannot preview files of type ",
  t == null ? void 0 : t.language
] }) : () => "", AP = () => {
  const {
    project: { files: t },
    config: { previewFileTypes: e, PreviewComponents: r }
  } = vt(), [n, i] = jr(
    Object.values(t).find((a) => a.name === "index.html" && !a.folderId)
  ), s = Object.values(t).find(
    (a) => a.active && Ws(a.language)
  );
  Nt(() => {
    Ws(s == null ? void 0 : s.language, e) && i(s);
  }, [s]), Nt(() => {
    n && !t[n.id] && i(
      Object.values(t).find(
        (a) => Ws(a.language, e)
      )
    );
  }, [n, t]);
  const o = EP(n, r);
  return /* @__PURE__ */ M.jsxs("div", { className: "right-pane", children: [
    /* @__PURE__ */ M.jsx(
      "select",
      {
        onChange: (a) => {
          const l = Object.values(t).find(
            (c) => c.id === a.target.value
          );
          i(l);
        },
        value: n == null ? void 0 : n.id,
        children: Object.values(t).sort().filter((a) => Ws(a.language, e)).map((a) => /* @__PURE__ */ M.jsx("option", { value: a.id, children: a.name }, a.id))
      }
    ),
    n && /* @__PURE__ */ M.jsx(o, { file: n })
  ] });
}, FP = () => /* @__PURE__ */ M.jsxs("div", { className: "run-bar", children: [
  /* @__PURE__ */ M.jsx("div", { children: /* @__PURE__ */ M.jsx("button", { type: "button", onClick: () => alert("not implemented"), children: "Share" }) }),
  /* @__PURE__ */ M.jsx("div", { children: /* @__PURE__ */ M.jsx("button", { type: "button", onClick: () => alert("not implemented"), children: "Finish" }) })
] }), TP = {
  showPreview: !0,
  showEditor: !0,
  showLeftNav: !0,
  showRunBar: !1
}, qn = (t, e) => e[t] ?? TP[t] ?? !1, _P = [
  { key: "showLeftNav", width: "1fr" },
  { key: "showPreview", width: "2fr" },
  { key: "showEditor", width: "2fr" }
], BP = [
  { key: "showRunBar", height: "40px" }
], y8 = ({
  project: t,
  config: e,
  setProject: r,
  setConfig: n
}) => {
  const i = vc(!0), [s, o] = Kv(iT, t), a = nT(o);
  Nt(() => {
    i.current && r(s), i.current = !0;
  }, [s]), Nt(() => {
    t !== s && (a.replaceProject(t), i.current = !1);
  }, [t, s]);
  const l = ["auto"];
  BP.forEach((u) => {
    qn(u.key, e) && l.push(u.height);
  });
  const c = [];
  return _P.forEach((u) => {
    qn(u.key, e) && c.push(u.width);
  }), /* @__PURE__ */ M.jsx(
    n2,
    {
      value: {
        project: s,
        config: e,
        setProject: r,
        setConfig: n,
        ...a
      },
      children: /* @__PURE__ */ M.jsxs(
        "div",
        {
          className: "cdo-ide-outer",
          style: { gridTemplateRows: l.join(" ") },
          children: [
            /* @__PURE__ */ M.jsxs(
              "div",
              {
                className: "cdo-ide-inner",
                style: {
                  gridTemplateColumns: c.join(" ")
                },
                children: [
                  qn("showLeftNav", e) && /* @__PURE__ */ M.jsx("div", { className: "cdo-ide-area", children: /* @__PURE__ */ M.jsx(hT, {}) }),
                  qn("showEditor", e) && /* @__PURE__ */ M.jsx("div", { className: "cdo-ide-area", children: /* @__PURE__ */ M.jsx(vP, {}) }),
                  qn("showPreview", e) && /* @__PURE__ */ M.jsx(AP, {})
                ]
              }
            ),
            qn("showRunBar", e) && /* @__PURE__ */ M.jsx(FP, {})
          ]
        }
      )
    }
  );
};
export {
  y8 as CDOIDE,
  Xp as CDOIDEContext,
  n2 as CDOIDEContextProvider,
  s2 as editableFileType,
  rT as findFiles,
  Qp as findFolder,
  xh as findSubFolders,
  l2 as getEmptyEditor,
  IP as getEmptyProject,
  Zp as getErrorMessage,
  eT as getNextFileId,
  tT as getNextFolderId,
  QF as prettify,
  Ws as previewFileType,
  iT as projectReducer,
  $0 as sortFilesByName,
  vt as useCDOIDEContext,
  nT as useProjectUtilities
};
//# sourceMappingURL=cdo-ide-poc.js.map
