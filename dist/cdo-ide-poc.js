import './style.css';
var fF = Object.defineProperty;
var mF = (t, e, r) => e in t ? fF(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var wn = (t, e, r) => (mF(t, typeof e != "symbol" ? e + "" : e, r), r);
import sr, { createContext as bo, useContext as hs, useMemo as Ke, useState as At, useLayoutEffect as gF, useEffect as Qe, useRef as et, useCallback as Ht, memo as yF, useReducer as op, forwardRef as OF, useImperativeHandle as xF } from "react";
import { unstable_batchedUpdates as Xo, createPortal as bF } from "react-dom";
var DF = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function vF(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Rf = { exports: {} }, Aa = {};
/** @license React v16.14.0
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vO;
function SF() {
  if (vO)
    return Aa;
  vO = 1;
  var t = sr, e = 60103;
  if (Aa.Fragment = 60107, typeof Symbol == "function" && Symbol.for) {
    var r = Symbol.for;
    e = r("react.element"), Aa.Fragment = r("react.fragment");
  }
  var n = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = Object.prototype.hasOwnProperty, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(o, u, c) {
    var h, p = {}, m = null, g = null;
    c !== void 0 && (m = "" + c), u.key !== void 0 && (m = "" + u.key), u.ref !== void 0 && (g = u.ref);
    for (h in u)
      i.call(u, h) && !s.hasOwnProperty(h) && (p[h] = u[h]);
    if (o && o.defaultProps)
      for (h in u = o.defaultProps, u)
        p[h] === void 0 && (p[h] = u[h]);
    return { $$typeof: e, type: o, key: m, ref: g, props: p, _owner: n.current };
  }
  return Aa.jsx = a, Aa.jsxs = a, Aa;
}
var wd = {};
/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var SO;
function wF() {
  return SO || (SO = 1, function(t) {
    process.env.NODE_ENV !== "production" && function() {
      var e = sr, r = 60103, n = 60106;
      t.Fragment = 60107;
      var i = 60108, s = 60114, a = 60109, o = 60110, u = 60112, c = 60113, h = 60120, p = 60115, m = 60116, g = 60121, O = 60122, b = 60117, D = 60129, S = 60131;
      if (typeof Symbol == "function" && Symbol.for) {
        var x = Symbol.for;
        r = x("react.element"), n = x("react.portal"), t.Fragment = x("react.fragment"), i = x("react.strict_mode"), s = x("react.profiler"), a = x("react.provider"), o = x("react.context"), u = x("react.forward_ref"), c = x("react.suspense"), h = x("react.suspense_list"), p = x("react.memo"), m = x("react.lazy"), g = x("react.block"), O = x("react.server.block"), b = x("react.fundamental"), x("react.scope"), x("react.opaque.id"), D = x("react.debug_trace_mode"), x("react.offscreen"), S = x("react.legacy_hidden");
      }
      var w = typeof Symbol == "function" && Symbol.iterator, T = "@@iterator";
      function C(L) {
        if (L === null || typeof L != "object")
          return null;
        var ie = w && L[w] || L[T];
        return typeof ie == "function" ? ie : null;
      }
      var A = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function P(L) {
        {
          for (var ie = arguments.length, pe = new Array(ie > 1 ? ie - 1 : 0), Be = 1; Be < ie; Be++)
            pe[Be - 1] = arguments[Be];
          $("error", L, pe);
        }
      }
      function $(L, ie, pe) {
        {
          var Be = A.ReactDebugCurrentFrame, Ue = "";
          if (ye) {
            var _e = X(ye.type), Ie = ye._owner;
            Ue += Y(_e, ye._source, Ie && X(Ie.type));
          }
          Ue += Be.getStackAddendum(), Ue !== "" && (ie += "%s", pe = pe.concat([Ue]));
          var ke = pe.map(function(_t) {
            return "" + _t;
          });
          ke.unshift("Warning: " + ie), Function.prototype.apply.call(console[L], console, ke);
        }
      }
      var B = !1;
      function _(L) {
        return !!(typeof L == "string" || typeof L == "function" || L === t.Fragment || L === s || L === D || L === i || L === c || L === h || L === S || B || typeof L == "object" && L !== null && (L.$$typeof === m || L.$$typeof === p || L.$$typeof === a || L.$$typeof === o || L.$$typeof === u || L.$$typeof === b || L.$$typeof === g || L[0] === O));
      }
      var M = /^(.*)[\\\/]/;
      function Y(L, ie, pe) {
        var Be = "";
        if (ie) {
          var Ue = ie.fileName, _e = Ue.replace(M, "");
          if (/^index\./.test(_e)) {
            var Ie = Ue.match(M);
            if (Ie) {
              var ke = Ie[1];
              if (ke) {
                var _t = ke.replace(M, "");
                _e = _t + "/" + _e;
              }
            }
          }
          Be = " (at " + _e + ":" + ie.lineNumber + ")";
        } else
          pe && (Be = " (created by " + pe + ")");
        return `
    in ` + (L || "Unknown") + Be;
      }
      var J = 1;
      function R(L) {
        return L._status === J ? L._result : null;
      }
      function q(L, ie, pe) {
        var Be = ie.displayName || ie.name || "";
        return L.displayName || (Be !== "" ? pe + "(" + Be + ")" : pe);
      }
      function X(L) {
        if (L == null)
          return null;
        if (typeof L.tag == "number" && P("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue."), typeof L == "function")
          return L.displayName || L.name || null;
        if (typeof L == "string")
          return L;
        switch (L) {
          case t.Fragment:
            return "Fragment";
          case n:
            return "Portal";
          case s:
            return "Profiler";
          case i:
            return "StrictMode";
          case c:
            return "Suspense";
          case h:
            return "SuspenseList";
        }
        if (typeof L == "object")
          switch (L.$$typeof) {
            case o:
              return "Context.Consumer";
            case a:
              return "Context.Provider";
            case u:
              return q(L, L.render, "ForwardRef");
            case p:
              return X(L.type);
            case g:
              return X(L.render);
            case m: {
              var ie = L, pe = R(ie);
              if (pe)
                return X(pe);
              break;
            }
          }
        return null;
      }
      var H = {};
      A.ReactDebugCurrentFrame;
      var ye = null;
      function Ce(L) {
        ye = L;
      }
      function Se(L, ie, pe, Be, Ue) {
        {
          var _e = Function.call.bind(Object.prototype.hasOwnProperty);
          for (var Ie in L)
            if (_e(L, Ie)) {
              var ke = void 0;
              try {
                if (typeof L[Ie] != "function") {
                  var _t = Error((Be || "React class") + ": " + pe + " type `" + Ie + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof L[Ie] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw _t.name = "Invariant Violation", _t;
                }
                ke = L[Ie](ie, Ie, Be, pe, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Dr) {
                ke = Dr;
              }
              ke && !(ke instanceof Error) && (Ce(Ue), P("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Be || "React class", pe, Ie, typeof ke), Ce(null)), ke instanceof Error && !(ke.message in H) && (H[ke.message] = !0, Ce(Ue), P("Failed %s type: %s", pe, ke.message), Ce(null));
            }
        }
      }
      var Ne = A.ReactCurrentOwner, Te = Object.prototype.hasOwnProperty, Me = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Ee, nt, se;
      se = {};
      function V(L) {
        if (Te.call(L, "ref")) {
          var ie = Object.getOwnPropertyDescriptor(L, "ref").get;
          if (ie && ie.isReactWarning)
            return !1;
        }
        return L.ref !== void 0;
      }
      function W(L) {
        if (Te.call(L, "key")) {
          var ie = Object.getOwnPropertyDescriptor(L, "key").get;
          if (ie && ie.isReactWarning)
            return !1;
        }
        return L.key !== void 0;
      }
      function j(L, ie) {
        if (typeof L.ref == "string" && Ne.current && ie && Ne.current.stateNode !== ie) {
          var pe = X(Ne.current.type);
          se[pe] || (P('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', X(Ne.current.type), L.ref), se[pe] = !0);
        }
      }
      function le(L, ie) {
        {
          var pe = function() {
            Ee || (Ee = !0, P("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ie));
          };
          pe.isReactWarning = !0, Object.defineProperty(L, "key", {
            get: pe,
            configurable: !0
          });
        }
      }
      function De(L, ie) {
        {
          var pe = function() {
            nt || (nt = !0, P("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ie));
          };
          pe.isReactWarning = !0, Object.defineProperty(L, "ref", {
            get: pe,
            configurable: !0
          });
        }
      }
      var we = function(L, ie, pe, Be, Ue, _e, Ie) {
        var ke = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: r,
          // Built-in properties that belong on the element
          type: L,
          key: ie,
          ref: pe,
          props: Ie,
          // Record the component responsible for creating this element.
          _owner: _e
        };
        return ke._store = {}, Object.defineProperty(ke._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(ke, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Be
        }), Object.defineProperty(ke, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Ue
        }), Object.freeze && (Object.freeze(ke.props), Object.freeze(ke)), ke;
      };
      function Dt(L, ie, pe, Be, Ue) {
        {
          var _e, Ie = {}, ke = null, _t = null;
          pe !== void 0 && (ke = "" + pe), W(ie) && (ke = "" + ie.key), V(ie) && (_t = ie.ref, j(ie, Ue));
          for (_e in ie)
            Te.call(ie, _e) && !Me.hasOwnProperty(_e) && (Ie[_e] = ie[_e]);
          if (L && L.defaultProps) {
            var Dr = L.defaultProps;
            for (_e in Dr)
              Ie[_e] === void 0 && (Ie[_e] = Dr[_e]);
          }
          if (ke || _t) {
            var Je = typeof L == "function" ? L.displayName || L.name || "Unknown" : L;
            ke && le(Ie, Je), _t && De(Ie, Je);
          }
          return we(L, ke, _t, Ue, Be, Ne.current, Ie);
        }
      }
      var it = A.ReactCurrentOwner;
      A.ReactDebugCurrentFrame;
      function ht(L) {
        ye = L;
      }
      var It;
      It = !1;
      function Dn(L) {
        return typeof L == "object" && L !== null && L.$$typeof === r;
      }
      function tr() {
        {
          if (it.current) {
            var L = X(it.current.type);
            if (L)
              return `

Check the render method of \`` + L + "`.";
          }
          return "";
        }
      }
      function rr(L) {
        {
          if (L !== void 0) {
            var ie = L.fileName.replace(/^.*[\\\/]/, ""), pe = L.lineNumber;
            return `

Check your code at ` + ie + ":" + pe + ".";
          }
          return "";
        }
      }
      var kt = {};
      function $r(L) {
        {
          var ie = tr();
          if (!ie) {
            var pe = typeof L == "string" ? L : L.displayName || L.name;
            pe && (ie = `

Check the top-level render call using <` + pe + ">.");
          }
          return ie;
        }
      }
      function br(L, ie) {
        {
          if (!L._store || L._store.validated || L.key != null)
            return;
          L._store.validated = !0;
          var pe = $r(ie);
          if (kt[pe])
            return;
          kt[pe] = !0;
          var Be = "";
          L && L._owner && L._owner !== it.current && (Be = " It was passed a child from " + X(L._owner.type) + "."), ht(L), P('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', pe, Be), ht(null);
        }
      }
      function tn(L, ie) {
        {
          if (typeof L != "object")
            return;
          if (Array.isArray(L))
            for (var pe = 0; pe < L.length; pe++) {
              var Be = L[pe];
              Dn(Be) && br(Be, ie);
            }
          else if (Dn(L))
            L._store && (L._store.validated = !0);
          else if (L) {
            var Ue = C(L);
            if (typeof Ue == "function" && Ue !== L.entries)
              for (var _e = Ue.call(L), Ie; !(Ie = _e.next()).done; )
                Dn(Ie.value) && br(Ie.value, ie);
          }
        }
      }
      function Br(L) {
        {
          var ie = L.type;
          if (ie == null || typeof ie == "string")
            return;
          var pe;
          if (typeof ie == "function")
            pe = ie.propTypes;
          else if (typeof ie == "object" && (ie.$$typeof === u || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          ie.$$typeof === p))
            pe = ie.propTypes;
          else
            return;
          if (pe) {
            var Be = X(ie);
            Se(pe, L.props, "prop", Be, L);
          } else if (ie.PropTypes !== void 0 && !It) {
            It = !0;
            var Ue = X(ie);
            P("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ue || "Unknown");
          }
          typeof ie.getDefaultProps == "function" && !ie.getDefaultProps.isReactClassApproved && P("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Li(L) {
        {
          for (var ie = Object.keys(L.props), pe = 0; pe < ie.length; pe++) {
            var Be = ie[pe];
            if (Be !== "children" && Be !== "key") {
              ht(L), P("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Be), ht(null);
              break;
            }
          }
          L.ref !== null && (ht(L), P("Invalid attribute `ref` supplied to `React.Fragment`."), ht(null));
        }
      }
      function Sa(L, ie, pe, Be, Ue, _e) {
        {
          var Ie = _(L);
          if (!Ie) {
            var ke = "";
            (L === void 0 || typeof L == "object" && L !== null && Object.keys(L).length === 0) && (ke += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
            var _t = rr(Ue);
            _t ? ke += _t : ke += tr();
            var Dr;
            L === null ? Dr = "null" : Array.isArray(L) ? Dr = "array" : L !== void 0 && L.$$typeof === r ? (Dr = "<" + (X(L.type) || "Unknown") + " />", ke = " Did you accidentally export a JSX literal instead of a component?") : Dr = typeof L, P("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Dr, ke);
          }
          var Je = Dt(L, ie, pe, Ue, _e);
          if (Je == null)
            return Je;
          if (Ie) {
            var gt = ie.children;
            if (gt !== void 0)
              if (Be)
                if (Array.isArray(gt)) {
                  for (var Ct = 0; Ct < gt.length; Ct++)
                    tn(gt[Ct], L);
                  Object.freeze && Object.freeze(gt);
                } else
                  P("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
              else
                tn(gt, L);
          }
          return L === t.Fragment ? Li(Je) : Br(Je), Je;
        }
      }
      function Ir(L, ie, pe) {
        return Sa(L, ie, pe, !0);
      }
      function Nt(L, ie, pe) {
        return Sa(L, ie, pe, !1);
      }
      var vn = Nt, Ps = Ir;
      t.jsx = vn, t.jsxs = Ps;
    }();
  }(wd)), wd;
}
process.env.NODE_ENV === "production" ? Rf.exports = SF() : Rf.exports = wF();
var z = Rf.exports;
const qD = bo(null), kr = () => {
  const t = hs(qD);
  if (t === null)
    throw new Error("CDO IDE Context has not been provided!");
  return t;
}, CF = ({
  children: t,
  value: e
}) => /* @__PURE__ */ z.jsx(qD.Provider, { value: e, children: t }), EF = ["html", "css", "js", "json"], XD = (t, e = EF) => new Set(e).has(t), Vs = "0", VD = (t = [], e) => t.reduce((r, n) => {
  if (!n.length)
    return r;
  const i = Object.values(e.folders).find(
    (s) => s.name === n && s.parentId === r
  );
  if (!i) {
    if (e.required)
      throw new Error(`Could not find folder ${t.join("/")}`);
    return Vs;
  }
  return i.id;
}, Vs), AF = () => /* @__PURE__ */ z.jsx("div", { children: "No files are open. Choose a file from the browser to the left." }), TF = () => /* @__PURE__ */ z.jsx("div", {}), kF = (t) => t.EmptyEditorComponent ? t.EmptyEditorComponent : t.blankEmptyEditor ? TF : AF, fee = () => ({ files: {}, folders: {} }), YD = (t) => typeof t == "string" ? t : t instanceof Error ? t.message : "", PF = ["html", "js", "json"], nc = (t, e = PF) => new Set(e).has(t);
var FF = Object.create, lp = Object.defineProperty, $F = Object.getOwnPropertyDescriptor, BF = Object.getOwnPropertyNames, IF = Object.getPrototypeOf, NF = Object.prototype.hasOwnProperty, _F = (t, e) => () => (t && (e = t(t = 0)), e), up = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), cp = (t, e) => {
  for (var r in e)
    lp(t, r, { get: e[r], enumerable: !0 });
}, UD = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of BF(e))
      !NF.call(t, i) && i !== r && lp(t, i, { get: () => e[i], enumerable: !(n = $F(e, i)) || n.enumerable });
  return t;
}, fu = (t, e, r) => (r = t != null ? FF(IF(t)) : {}, UD(e || !t || !t.__esModule ? lp(r, "default", { value: t, enumerable: !0 }) : r, t)), QF = (t) => UD(lp({}, "__esModule", { value: !0 }), t), MF = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, wO = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, Vo = (t, e, r) => (MF(t, e, "access private method"), r), LF = up((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = e;
  function e() {
  }
  e.prototype = { diff: function(i, s) {
    var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = a.callback;
    typeof a == "function" && (o = a, a = {}), this.options = a;
    var u = this;
    function c(x) {
      return o ? (setTimeout(function() {
        o(void 0, x);
      }, 0), !0) : x;
    }
    i = this.castInput(i), s = this.castInput(s), i = this.removeEmpty(this.tokenize(i)), s = this.removeEmpty(this.tokenize(s));
    var h = s.length, p = i.length, m = 1, g = h + p;
    a.maxEditLength && (g = Math.min(g, a.maxEditLength));
    var O = [{ newPos: -1, components: [] }], b = this.extractCommon(O[0], s, i, 0);
    if (O[0].newPos + 1 >= h && b + 1 >= p)
      return c([{ value: this.join(s), count: s.length }]);
    function D() {
      for (var x = -1 * m; x <= m; x += 2) {
        var w = void 0, T = O[x - 1], C = O[x + 1], A = (C ? C.newPos : 0) - x;
        T && (O[x - 1] = void 0);
        var P = T && T.newPos + 1 < h, $ = C && 0 <= A && A < p;
        if (!P && !$) {
          O[x] = void 0;
          continue;
        }
        if (!P || $ && T.newPos < C.newPos ? (w = n(C), u.pushComponent(w.components, void 0, !0)) : (w = T, w.newPos++, u.pushComponent(w.components, !0, void 0)), A = u.extractCommon(w, s, i, x), w.newPos + 1 >= h && A + 1 >= p)
          return c(r(u, w.components, s, i, u.useLongestToken));
        O[x] = w;
      }
      m++;
    }
    if (o)
      (function x() {
        setTimeout(function() {
          if (m > g)
            return o();
          D() || x();
        }, 0);
      })();
    else
      for (; m <= g; ) {
        var S = D();
        if (S)
          return S;
      }
  }, pushComponent: function(i, s, a) {
    var o = i[i.length - 1];
    o && o.added === s && o.removed === a ? i[i.length - 1] = { count: o.count + 1, added: s, removed: a } : i.push({ count: 1, added: s, removed: a });
  }, extractCommon: function(i, s, a, o) {
    for (var u = s.length, c = a.length, h = i.newPos, p = h - o, m = 0; h + 1 < u && p + 1 < c && this.equals(s[h + 1], a[p + 1]); )
      h++, p++, m++;
    return m && i.components.push({ count: m }), i.newPos = h, p;
  }, equals: function(i, s) {
    return this.options.comparator ? this.options.comparator(i, s) : i === s || this.options.ignoreCase && i.toLowerCase() === s.toLowerCase();
  }, removeEmpty: function(i) {
    for (var s = [], a = 0; a < i.length; a++)
      i[a] && s.push(i[a]);
    return s;
  }, castInput: function(i) {
    return i;
  }, tokenize: function(i) {
    return i.split("");
  }, join: function(i) {
    return i.join("");
  } };
  function r(i, s, a, o, u) {
    for (var c = 0, h = s.length, p = 0, m = 0; c < h; c++) {
      var g = s[c];
      if (g.removed) {
        if (g.value = i.join(o.slice(m, m + g.count)), m += g.count, c && s[c - 1].added) {
          var O = s[c - 1];
          s[c - 1] = s[c], s[c] = O;
        }
      } else {
        if (!g.added && u) {
          var b = a.slice(p, p + g.count);
          b = b.map(function(S, x) {
            var w = o[m + x];
            return w.length > S.length ? w : S;
          }), g.value = i.join(b);
        } else
          g.value = i.join(a.slice(p, p + g.count));
        p += g.count, g.added || (m += g.count);
      }
    }
    var D = s[h - 1];
    return h > 1 && typeof D.value == "string" && (D.added || D.removed) && i.equals("", D.value) && (s[h - 2].value += D.value, s.pop()), s;
  }
  function n(i) {
    return { newPos: i.newPos, components: i.components.slice(0) };
  }
}), RF = up((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.diffArrays = i, t.arrayDiff = void 0;
  var e = r(LF());
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  var n = new e.default();
  t.arrayDiff = n, n.tokenize = function(s) {
    return s.slice();
  }, n.join = n.removeEmpty = function(s) {
    return s;
  };
  function i(s, a, o) {
    return n.diff(s, a, o);
  }
}), hp = up((t, e) => {
  var r = new Proxy(String, { get: () => r });
  e.exports = r;
}), zD = {};
cp(zD, { default: () => HD, shouldHighlight: () => GD });
var GD, HD, jF = _F(() => {
  GD = () => !1, HD = String;
}), ZF = up((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.codeFrameColumns = p, t.default = m;
  var e = (jF(), QF(zD)), r = i(hp(), !0);
  function n(g) {
    if (typeof WeakMap != "function")
      return null;
    var O = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap();
    return (n = function(D) {
      return D ? b : O;
    })(g);
  }
  function i(g, O) {
    if (!O && g && g.__esModule)
      return g;
    if (g === null || typeof g != "object" && typeof g != "function")
      return { default: g };
    var b = n(O);
    if (b && b.has(g))
      return b.get(g);
    var D = { __proto__: null }, S = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var x in g)
      if (x !== "default" && Object.prototype.hasOwnProperty.call(g, x)) {
        var w = S ? Object.getOwnPropertyDescriptor(g, x) : null;
        w && (w.get || w.set) ? Object.defineProperty(D, x, w) : D[x] = g[x];
      }
    return D.default = g, b && b.set(g, D), D;
  }
  var s;
  function a(g) {
    return g ? (s != null || (s = new r.default.constructor({ enabled: !0, level: 1 })), s) : r.default;
  }
  var o = !1;
  function u(g) {
    return { gutter: g.grey, marker: g.red.bold, message: g.red.bold };
  }
  var c = /\r\n|[\n\r\u2028\u2029]/;
  function h(g, O, b) {
    let D = Object.assign({ column: 0, line: -1 }, g.start), S = Object.assign({}, D, g.end), { linesAbove: x = 2, linesBelow: w = 3 } = b || {}, T = D.line, C = D.column, A = S.line, P = S.column, $ = Math.max(T - (x + 1), 0), B = Math.min(O.length, A + w);
    T === -1 && ($ = 0), A === -1 && (B = O.length);
    let _ = A - T, M = {};
    if (_)
      for (let Y = 0; Y <= _; Y++) {
        let J = Y + T;
        if (!C)
          M[J] = !0;
        else if (Y === 0) {
          let R = O[J - 1].length;
          M[J] = [C, R - C + 1];
        } else if (Y === _)
          M[J] = [0, P];
        else {
          let R = O[J - Y].length;
          M[J] = [0, R];
        }
      }
    else
      C === P ? C ? M[T] = [C, 0] : M[T] = !0 : M[T] = [C, P - C];
    return { start: $, end: B, markerLines: M };
  }
  function p(g, O, b = {}) {
    let D = (b.highlightCode || b.forceColor) && (0, e.shouldHighlight)(b), S = a(b.forceColor), x = u(S), w = (M, Y) => D ? M(Y) : Y, T = g.split(c), { start: C, end: A, markerLines: P } = h(O, T, b), $ = O.start && typeof O.start.column == "number", B = String(A).length, _ = (D ? (0, e.default)(g, b) : g).split(c, A).slice(C, A).map((M, Y) => {
      let J = C + 1 + Y, R = ` ${` ${J}`.slice(-B)} |`, q = P[J], X = !P[J + 1];
      if (q) {
        let H = "";
        if (Array.isArray(q)) {
          let ye = M.slice(0, Math.max(q[0] - 1, 0)).replace(/[^\t]/g, " "), Ce = q[1] || 1;
          H = [`
 `, w(x.gutter, R.replace(/\d/g, " ")), " ", ye, w(x.marker, "^").repeat(Ce)].join(""), X && b.message && (H += " " + w(x.message, b.message));
        }
        return [w(x.marker, ">"), w(x.gutter, R), M.length > 0 ? ` ${M}` : "", H].join("");
      } else
        return ` ${w(x.gutter, R)}${M.length > 0 ? ` ${M}` : ""}`;
    }).join(`
`);
    return b.message && !$ && (_ = `${" ".repeat(B + 1)}${b.message}
${_}`), D ? S.reset(_) : _;
  }
  function m(g, O, b, D = {}) {
    if (!o) {
      o = !0;
      let S = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      {
        let x = new Error(S);
        x.name = "DeprecationWarning", console.warn(new Error(S));
      }
    }
    return b = Math.max(b, 0), p(g, { start: { column: b, line: O } }, D);
  }
}), JD = {};
cp(JD, { __debug: () => LB, check: () => QB, doc: () => _v, format: () => Lv, formatWithCursor: () => Mv, getSupportInfo: () => MB, util: () => Qv, version: () => dB });
var WF = (t, e, r, n) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
}, pp = WF, qF = fu(RF(), 1);
function XF(t) {
  let e = t.indexOf("\r");
  return e >= 0 ? t.charAt(e + 1) === `
` ? "crlf" : "cr" : "lf";
}
function Fg(t) {
  switch (t) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function KD(t, e) {
  let r;
  switch (e) {
    case `
`:
      r = /\n/g;
      break;
    case "\r":
      r = /\r/g;
      break;
    case `\r
`:
      r = /\r\n/g;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(e)}.`);
  }
  let n = t.match(r);
  return n ? n.length : 0;
}
function VF(t) {
  return pp(!1, t, /\r\n?/g, `
`);
}
var ua = "string", ps = "array", ca = "cursor", Fi = "indent", $i = "align", Bi = "trim", Ar = "group", dn = "fill", zr = "if-break", Ii = "indent-if-break", Ni = "line-suffix", _i = "line-suffix-boundary", Jt = "line", ci = "label", fn = "break-parent", ev = /* @__PURE__ */ new Set([ca, Fi, $i, Bi, Ar, dn, zr, Ii, Ni, _i, Jt, ci, fn]);
function YF(t) {
  if (typeof t == "string")
    return ua;
  if (Array.isArray(t))
    return ps;
  if (!t)
    return;
  let { type: e } = t;
  if (ev.has(e))
    return e;
}
var ha = YF, UF = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function zF(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (ha(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = UF([...ev].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`;
}
var GF = class extends Error {
  constructor(r) {
    super(zF(r));
    wn(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, io = GF, CO = {};
function HF(t, e, r, n) {
  let i = [t];
  for (; i.length > 0; ) {
    let s = i.pop();
    if (s === CO) {
      r(i.pop());
      continue;
    }
    r && i.push(s, CO);
    let a = ha(s);
    if (!a)
      throw new io(s);
    if ((e == null ? void 0 : e(s)) !== !1)
      switch (a) {
        case ps:
        case dn: {
          let o = a === ps ? s : s.parts;
          for (let u = o.length, c = u - 1; c >= 0; --c)
            i.push(o[c]);
          break;
        }
        case zr:
          i.push(s.flatContents, s.breakContents);
          break;
        case Ar:
          if (n && s.expandedStates)
            for (let o = s.expandedStates.length, u = o - 1; u >= 0; --u)
              i.push(s.expandedStates[u]);
          else
            i.push(s.contents);
          break;
        case $i:
        case Fi:
        case Ii:
        case ci:
        case Ni:
          i.push(s.contents);
          break;
        case ua:
        case ca:
        case Bi:
        case _i:
        case Jt:
        case fn:
          break;
        default:
          throw new io(s);
      }
  }
}
var $g = HF, JF = () => {
}, KF = JF;
function fh(t) {
  return { type: Fi, contents: t };
}
function so(t, e) {
  return { type: $i, contents: e, n: t };
}
function tv(t, e = {}) {
  return KF(e.expandedStates), { type: Ar, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function e$(t) {
  return so(Number.NEGATIVE_INFINITY, t);
}
function t$(t) {
  return so({ type: "root" }, t);
}
function r$(t) {
  return so(-1, t);
}
function n$(t, e) {
  return tv(t[0], { ...e, expandedStates: t });
}
function rv(t) {
  return { type: dn, parts: t };
}
function i$(t, e = "", r = {}) {
  return { type: zr, breakContents: t, flatContents: e, groupId: r.groupId };
}
function s$(t, e) {
  return { type: Ii, contents: t, groupId: e.groupId, negate: e.negate };
}
function jf(t) {
  return { type: Ni, contents: t };
}
var a$ = { type: _i }, dp = { type: fn }, o$ = { type: Bi }, Bg = { type: Jt, hard: !0 }, nv = { type: Jt, hard: !0, literal: !0 }, iv = { type: Jt }, l$ = { type: Jt, soft: !0 }, Ys = [Bg, dp], sv = [nv, dp], Zf = { type: ca };
function av(t, e) {
  let r = [];
  for (let n = 0; n < e.length; n++)
    n !== 0 && r.push(t), r.push(e[n]);
  return r;
}
function ov(t, e, r) {
  let n = t;
  if (e > 0) {
    for (let i = 0; i < Math.floor(e / r); ++i)
      n = fh(n);
    n = so(e % r, n), n = so(Number.NEGATIVE_INFINITY, n);
  }
  return n;
}
function u$(t, e) {
  return t ? { type: ci, label: t, contents: e } : e;
}
function bi(t) {
  var e;
  if (!t)
    return "";
  if (Array.isArray(t)) {
    let r = [];
    for (let n of t)
      if (Array.isArray(n))
        r.push(...bi(n));
      else {
        let i = bi(n);
        i !== "" && r.push(i);
      }
    return r;
  }
  return t.type === zr ? { ...t, breakContents: bi(t.breakContents), flatContents: bi(t.flatContents) } : t.type === Ar ? { ...t, contents: bi(t.contents), expandedStates: (e = t.expandedStates) == null ? void 0 : e.map(bi) } : t.type === dn ? { type: "fill", parts: t.parts.map(bi) } : t.contents ? { ...t, contents: bi(t.contents) } : t;
}
function c$(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Set();
  return n(bi(t));
  function n(s, a, o) {
    var u, c;
    if (typeof s == "string")
      return JSON.stringify(s);
    if (Array.isArray(s)) {
      let h = s.map(n).filter(Boolean);
      return h.length === 1 ? h[0] : `[${h.join(", ")}]`;
    }
    if (s.type === Jt) {
      let h = ((u = o == null ? void 0 : o[a + 1]) == null ? void 0 : u.type) === fn;
      return s.literal ? h ? "literalline" : "literallineWithoutBreakParent" : s.hard ? h ? "hardline" : "hardlineWithoutBreakParent" : s.soft ? "softline" : "line";
    }
    if (s.type === fn)
      return ((c = o == null ? void 0 : o[a - 1]) == null ? void 0 : c.type) === Jt && o[a - 1].hard ? void 0 : "breakParent";
    if (s.type === Bi)
      return "trim";
    if (s.type === Fi)
      return "indent(" + n(s.contents) + ")";
    if (s.type === $i)
      return s.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n(s.contents) + ")" : s.n < 0 ? "dedent(" + n(s.contents) + ")" : s.n.type === "root" ? "markAsRoot(" + n(s.contents) + ")" : "align(" + JSON.stringify(s.n) + ", " + n(s.contents) + ")";
    if (s.type === zr)
      return "ifBreak(" + n(s.breakContents) + (s.flatContents ? ", " + n(s.flatContents) : "") + (s.groupId ? (s.flatContents ? "" : ', ""') + `, { groupId: ${i(s.groupId)} }` : "") + ")";
    if (s.type === Ii) {
      let h = [];
      s.negate && h.push("negate: true"), s.groupId && h.push(`groupId: ${i(s.groupId)}`);
      let p = h.length > 0 ? `, { ${h.join(", ")} }` : "";
      return `indentIfBreak(${n(s.contents)}${p})`;
    }
    if (s.type === Ar) {
      let h = [];
      s.break && s.break !== "propagated" && h.push("shouldBreak: true"), s.id && h.push(`id: ${i(s.id)}`);
      let p = h.length > 0 ? `, { ${h.join(", ")} }` : "";
      return s.expandedStates ? `conditionalGroup([${s.expandedStates.map((m) => n(m)).join(",")}]${p})` : `group(${n(s.contents)}${p})`;
    }
    if (s.type === dn)
      return `fill([${s.parts.map((h) => n(h)).join(", ")}])`;
    if (s.type === Ni)
      return "lineSuffix(" + n(s.contents) + ")";
    if (s.type === _i)
      return "lineSuffixBoundary";
    if (s.type === ci)
      return `label(${JSON.stringify(s.label)}, ${n(s.contents)})`;
    throw new Error("Unknown doc type " + s.type);
  }
  function i(s) {
    if (typeof s != "symbol")
      return JSON.stringify(String(s));
    if (s in e)
      return e[s];
    let a = s.description || "symbol";
    for (let o = 0; ; o++) {
      let u = a + (o > 0 ? ` #${o}` : "");
      if (!r.has(u))
        return r.add(u), e[s] = `Symbol.for(${JSON.stringify(u)})`;
    }
  }
}
var h$ = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, Qt = h$, p$ = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function d$(t) {
  return t === 12288 || t >= 65281 && t <= 65376 || t >= 65504 && t <= 65510;
}
function f$(t) {
  return t >= 4352 && t <= 4447 || t === 8986 || t === 8987 || t === 9001 || t === 9002 || t >= 9193 && t <= 9196 || t === 9200 || t === 9203 || t === 9725 || t === 9726 || t === 9748 || t === 9749 || t >= 9800 && t <= 9811 || t === 9855 || t === 9875 || t === 9889 || t === 9898 || t === 9899 || t === 9917 || t === 9918 || t === 9924 || t === 9925 || t === 9934 || t === 9940 || t === 9962 || t === 9970 || t === 9971 || t === 9973 || t === 9978 || t === 9981 || t === 9989 || t === 9994 || t === 9995 || t === 10024 || t === 10060 || t === 10062 || t >= 10067 && t <= 10069 || t === 10071 || t >= 10133 && t <= 10135 || t === 10160 || t === 10175 || t === 11035 || t === 11036 || t === 11088 || t === 11093 || t >= 11904 && t <= 11929 || t >= 11931 && t <= 12019 || t >= 12032 && t <= 12245 || t >= 12272 && t <= 12287 || t >= 12289 && t <= 12350 || t >= 12353 && t <= 12438 || t >= 12441 && t <= 12543 || t >= 12549 && t <= 12591 || t >= 12593 && t <= 12686 || t >= 12688 && t <= 12771 || t >= 12783 && t <= 12830 || t >= 12832 && t <= 12871 || t >= 12880 && t <= 19903 || t >= 19968 && t <= 42124 || t >= 42128 && t <= 42182 || t >= 43360 && t <= 43388 || t >= 44032 && t <= 55203 || t >= 63744 && t <= 64255 || t >= 65040 && t <= 65049 || t >= 65072 && t <= 65106 || t >= 65108 && t <= 65126 || t >= 65128 && t <= 65131 || t >= 94176 && t <= 94180 || t === 94192 || t === 94193 || t >= 94208 && t <= 100343 || t >= 100352 && t <= 101589 || t >= 101632 && t <= 101640 || t >= 110576 && t <= 110579 || t >= 110581 && t <= 110587 || t === 110589 || t === 110590 || t >= 110592 && t <= 110882 || t === 110898 || t >= 110928 && t <= 110930 || t === 110933 || t >= 110948 && t <= 110951 || t >= 110960 && t <= 111355 || t === 126980 || t === 127183 || t === 127374 || t >= 127377 && t <= 127386 || t >= 127488 && t <= 127490 || t >= 127504 && t <= 127547 || t >= 127552 && t <= 127560 || t === 127568 || t === 127569 || t >= 127584 && t <= 127589 || t >= 127744 && t <= 127776 || t >= 127789 && t <= 127797 || t >= 127799 && t <= 127868 || t >= 127870 && t <= 127891 || t >= 127904 && t <= 127946 || t >= 127951 && t <= 127955 || t >= 127968 && t <= 127984 || t === 127988 || t >= 127992 && t <= 128062 || t === 128064 || t >= 128066 && t <= 128252 || t >= 128255 && t <= 128317 || t >= 128331 && t <= 128334 || t >= 128336 && t <= 128359 || t === 128378 || t === 128405 || t === 128406 || t === 128420 || t >= 128507 && t <= 128591 || t >= 128640 && t <= 128709 || t === 128716 || t >= 128720 && t <= 128722 || t >= 128725 && t <= 128727 || t >= 128732 && t <= 128735 || t === 128747 || t === 128748 || t >= 128756 && t <= 128764 || t >= 128992 && t <= 129003 || t === 129008 || t >= 129292 && t <= 129338 || t >= 129340 && t <= 129349 || t >= 129351 && t <= 129535 || t >= 129648 && t <= 129660 || t >= 129664 && t <= 129672 || t >= 129680 && t <= 129725 || t >= 129727 && t <= 129733 || t >= 129742 && t <= 129755 || t >= 129760 && t <= 129768 || t >= 129776 && t <= 129784 || t >= 131072 && t <= 196605 || t >= 196608 && t <= 262141;
}
var m$ = (t) => !(d$(t) || f$(t)), g$ = /[^\x20-\x7F]/;
function y$(t) {
  if (!t)
    return 0;
  if (!g$.test(t))
    return t.length;
  t = t.replace(p$(), "  ");
  let e = 0;
  for (let r of t) {
    let n = r.codePointAt(0);
    n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (e += m$(n) ? 1 : 2);
  }
  return e;
}
var Ig = y$, O$ = (t) => {
  if (Array.isArray(t))
    return t;
  if (t.type !== dn)
    throw new Error(`Expect doc to be 'array' or '${dn}'.`);
  return t.parts;
};
function fp(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return n(t);
  function n(s) {
    if (r.has(s))
      return r.get(s);
    let a = i(s);
    return r.set(s, a), a;
  }
  function i(s) {
    switch (ha(s)) {
      case ps:
        return e(s.map(n));
      case dn:
        return e({ ...s, parts: s.parts.map(n) });
      case zr:
        return e({ ...s, breakContents: n(s.breakContents), flatContents: n(s.flatContents) });
      case Ar: {
        let { expandedStates: a, contents: o } = s;
        return a ? (a = a.map(n), o = a[0]) : o = n(o), e({ ...s, contents: o, expandedStates: a });
      }
      case $i:
      case Fi:
      case Ii:
      case ci:
      case Ni:
        return e({ ...s, contents: n(s.contents) });
      case ua:
      case ca:
      case Bi:
      case _i:
      case Jt:
      case fn:
        return e(s);
      default:
        throw new io(s);
    }
  }
}
function Ng(t, e, r) {
  let n = r, i = !1;
  function s(a) {
    if (i)
      return !1;
    let o = e(a);
    o !== void 0 && (i = !0, n = o);
  }
  return $g(t, s), n;
}
function x$(t) {
  if (t.type === Ar && t.break || t.type === Jt && t.hard || t.type === fn)
    return !0;
}
function b$(t) {
  return Ng(t, x$, !1);
}
function EO(t) {
  if (t.length > 0) {
    let e = Qt(!1, t, -1);
    !e.expandedStates && !e.break && (e.break = "propagated");
  }
  return null;
}
function D$(t) {
  let e = /* @__PURE__ */ new Set(), r = [];
  function n(s) {
    if (s.type === fn && EO(r), s.type === Ar) {
      if (r.push(s), e.has(s))
        return !1;
      e.add(s);
    }
  }
  function i(s) {
    s.type === Ar && r.pop().break && EO(r);
  }
  $g(t, n, i, !0);
}
function v$(t) {
  return t.type === Jt && !t.hard ? t.soft ? "" : " " : t.type === zr ? t.flatContents : t;
}
function S$(t) {
  return fp(t, v$);
}
function AO(t) {
  for (t = [...t]; t.length >= 2 && Qt(!1, t, -2).type === Jt && Qt(!1, t, -1).type === fn; )
    t.length -= 2;
  if (t.length > 0) {
    let e = xl(Qt(!1, t, -1));
    t[t.length - 1] = e;
  }
  return t;
}
function xl(t) {
  switch (ha(t)) {
    case $i:
    case Fi:
    case Ii:
    case Ar:
    case Ni:
    case ci: {
      let e = xl(t.contents);
      return { ...t, contents: e };
    }
    case zr:
      return { ...t, breakContents: xl(t.breakContents), flatContents: xl(t.flatContents) };
    case dn:
      return { ...t, parts: AO(t.parts) };
    case ps:
      return AO(t);
    case ua:
      return t.replace(/[\n\r]*$/, "");
    case ca:
    case Bi:
    case _i:
    case Jt:
    case fn:
      break;
    default:
      throw new io(t);
  }
  return t;
}
function lv(t) {
  return xl(C$(t));
}
function w$(t) {
  switch (ha(t)) {
    case dn:
      if (t.parts.every((e) => e === ""))
        return "";
      break;
    case Ar:
      if (!t.contents && !t.id && !t.break && !t.expandedStates)
        return "";
      if (t.contents.type === Ar && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates)
        return t.contents;
      break;
    case $i:
    case Fi:
    case Ii:
    case Ni:
      if (!t.contents)
        return "";
      break;
    case zr:
      if (!t.flatContents && !t.breakContents)
        return "";
      break;
    case ps: {
      let e = [];
      for (let r of t) {
        if (!r)
          continue;
        let [n, ...i] = Array.isArray(r) ? r : [r];
        typeof n == "string" && typeof Qt(!1, e, -1) == "string" ? e[e.length - 1] += n : e.push(n), e.push(...i);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case ua:
    case ca:
    case Bi:
    case _i:
    case Jt:
    case ci:
    case fn:
      break;
    default:
      throw new io(t);
  }
  return t;
}
function C$(t) {
  return fp(t, (e) => w$(e));
}
function E$(t, e = sv) {
  return fp(t, (r) => typeof r == "string" ? av(e, r.split(`
`)) : r);
}
function A$(t) {
  if (t.type === Jt)
    return !0;
}
function T$(t) {
  return Ng(t, A$, !1);
}
function uv(t, e) {
  return t.type === ci ? { ...t, contents: e(t.contents) } : e(t);
}
var Sr = Symbol("MODE_BREAK"), Xn = Symbol("MODE_FLAT"), bl = Symbol("cursor");
function cv() {
  return { value: "", length: 0, queue: [] };
}
function k$(t, e) {
  return Wf(t, { type: "indent" }, e);
}
function P$(t, e, r) {
  return e === Number.NEGATIVE_INFINITY ? t.root || cv() : e < 0 ? Wf(t, { type: "dedent" }, r) : e ? e.type === "root" ? { ...t, root: t } : Wf(t, { type: typeof e == "string" ? "stringAlign" : "numberAlign", n: e }, r) : t;
}
function Wf(t, e, r) {
  let n = e.type === "dedent" ? t.queue.slice(0, -1) : [...t.queue, e], i = "", s = 0, a = 0, o = 0;
  for (let O of n)
    switch (O.type) {
      case "indent":
        h(), r.useTabs ? u(1) : c(r.tabWidth);
        break;
      case "stringAlign":
        h(), i += O.n, s += O.n.length;
        break;
      case "numberAlign":
        a += 1, o += O.n;
        break;
      default:
        throw new Error(`Unexpected type '${O.type}'`);
    }
  return m(), { ...t, value: i, length: s, queue: n };
  function u(O) {
    i += "	".repeat(O), s += r.tabWidth * O;
  }
  function c(O) {
    i += " ".repeat(O), s += O;
  }
  function h() {
    r.useTabs ? p() : m();
  }
  function p() {
    a > 0 && u(a), g();
  }
  function m() {
    o > 0 && c(o), g();
  }
  function g() {
    a = 0, o = 0;
  }
}
function qf(t) {
  let e = 0, r = 0, n = t.length;
  e:
    for (; n--; ) {
      let i = t[n];
      if (i === bl) {
        r++;
        continue;
      }
      for (let s = i.length - 1; s >= 0; s--) {
        let a = i[s];
        if (a === " " || a === "	")
          e++;
        else {
          t[n] = i.slice(0, s + 1);
          break e;
        }
      }
    }
  if (e > 0 || r > 0)
    for (t.length = n + 1; r-- > 0; )
      t.push(bl);
  return e;
}
function ic(t, e, r, n, i, s) {
  if (r === Number.POSITIVE_INFINITY)
    return !0;
  let a = e.length, o = [t], u = [];
  for (; r >= 0; ) {
    if (o.length === 0) {
      if (a === 0)
        return !0;
      o.push(e[--a]);
      continue;
    }
    let { mode: c, doc: h } = o.pop();
    switch (ha(h)) {
      case ua:
        u.push(h), r -= Ig(h);
        break;
      case ps:
      case dn: {
        let p = O$(h);
        for (let m = p.length - 1; m >= 0; m--)
          o.push({ mode: c, doc: p[m] });
        break;
      }
      case Fi:
      case $i:
      case Ii:
      case ci:
        o.push({ mode: c, doc: h.contents });
        break;
      case Bi:
        r += qf(u);
        break;
      case Ar: {
        if (s && h.break)
          return !1;
        let p = h.break ? Sr : c, m = h.expandedStates && p === Sr ? Qt(!1, h.expandedStates, -1) : h.contents;
        o.push({ mode: p, doc: m });
        break;
      }
      case zr: {
        let p = (h.groupId ? i[h.groupId] || Xn : c) === Sr ? h.breakContents : h.flatContents;
        p && o.push({ mode: c, doc: p });
        break;
      }
      case Jt:
        if (c === Sr || h.hard)
          return !0;
        h.soft || (u.push(" "), r--);
        break;
      case Ni:
        n = !0;
        break;
      case _i:
        if (n)
          return !1;
        break;
    }
  }
  return !1;
}
function mp(t, e) {
  let r = {}, n = e.printWidth, i = Fg(e.endOfLine), s = 0, a = [{ ind: cv(), mode: Sr, doc: t }], o = [], u = !1, c = [], h = 0;
  for (D$(t); a.length > 0; ) {
    let { ind: m, mode: g, doc: O } = a.pop();
    switch (ha(O)) {
      case ua: {
        let b = i !== `
` ? pp(!1, O, `
`, i) : O;
        o.push(b), a.length > 0 && (s += Ig(b));
        break;
      }
      case ps:
        for (let b = O.length - 1; b >= 0; b--)
          a.push({ ind: m, mode: g, doc: O[b] });
        break;
      case ca:
        if (h >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        o.push(bl), h++;
        break;
      case Fi:
        a.push({ ind: k$(m, e), mode: g, doc: O.contents });
        break;
      case $i:
        a.push({ ind: P$(m, O.n, e), mode: g, doc: O.contents });
        break;
      case Bi:
        s -= qf(o);
        break;
      case Ar:
        switch (g) {
          case Xn:
            if (!u) {
              a.push({ ind: m, mode: O.break ? Sr : Xn, doc: O.contents });
              break;
            }
          case Sr: {
            u = !1;
            let b = { ind: m, mode: Xn, doc: O.contents }, D = n - s, S = c.length > 0;
            if (!O.break && ic(b, a, D, S, r))
              a.push(b);
            else if (O.expandedStates) {
              let x = Qt(!1, O.expandedStates, -1);
              if (O.break) {
                a.push({ ind: m, mode: Sr, doc: x });
                break;
              } else
                for (let w = 1; w < O.expandedStates.length + 1; w++)
                  if (w >= O.expandedStates.length) {
                    a.push({ ind: m, mode: Sr, doc: x });
                    break;
                  } else {
                    let T = O.expandedStates[w], C = { ind: m, mode: Xn, doc: T };
                    if (ic(C, a, D, S, r)) {
                      a.push(C);
                      break;
                    }
                  }
            } else
              a.push({ ind: m, mode: Sr, doc: O.contents });
            break;
          }
        }
        O.id && (r[O.id] = Qt(!1, a, -1).mode);
        break;
      case dn: {
        let b = n - s, { parts: D } = O;
        if (D.length === 0)
          break;
        let [S, x] = D, w = { ind: m, mode: Xn, doc: S }, T = { ind: m, mode: Sr, doc: S }, C = ic(w, [], b, c.length > 0, r, !0);
        if (D.length === 1) {
          C ? a.push(w) : a.push(T);
          break;
        }
        let A = { ind: m, mode: Xn, doc: x }, P = { ind: m, mode: Sr, doc: x };
        if (D.length === 2) {
          C ? a.push(A, w) : a.push(P, T);
          break;
        }
        D.splice(0, 2);
        let $ = { ind: m, mode: g, doc: rv(D) }, B = D[0];
        ic({ ind: m, mode: Xn, doc: [S, x, B] }, [], b, c.length > 0, r, !0) ? a.push($, A, w) : C ? a.push($, P, w) : a.push($, P, T);
        break;
      }
      case zr:
      case Ii: {
        let b = O.groupId ? r[O.groupId] : g;
        if (b === Sr) {
          let D = O.type === zr ? O.breakContents : O.negate ? O.contents : fh(O.contents);
          D && a.push({ ind: m, mode: g, doc: D });
        }
        if (b === Xn) {
          let D = O.type === zr ? O.flatContents : O.negate ? fh(O.contents) : O.contents;
          D && a.push({ ind: m, mode: g, doc: D });
        }
        break;
      }
      case Ni:
        c.push({ ind: m, mode: g, doc: O.contents });
        break;
      case _i:
        c.length > 0 && a.push({ ind: m, mode: g, doc: Bg });
        break;
      case Jt:
        switch (g) {
          case Xn:
            if (O.hard)
              u = !0;
            else {
              O.soft || (o.push(" "), s += 1);
              break;
            }
          case Sr:
            if (c.length > 0) {
              a.push({ ind: m, mode: g, doc: O }, ...c.reverse()), c.length = 0;
              break;
            }
            O.literal ? m.root ? (o.push(i, m.root.value), s = m.root.length) : (o.push(i), s = 0) : (s -= qf(o), o.push(i + m.value), s = m.length);
            break;
        }
        break;
      case ci:
        a.push({ ind: m, mode: g, doc: O.contents });
        break;
      case fn:
        break;
      default:
        throw new io(O);
    }
    a.length === 0 && c.length > 0 && (a.push(...c.reverse()), c.length = 0);
  }
  let p = o.indexOf(bl);
  if (p !== -1) {
    let m = o.indexOf(bl, p + 1), g = o.slice(0, p).join(""), O = o.slice(p + 1, m).join(""), b = o.slice(m + 1).join("");
    return { formatted: g + O + b, cursorNodeStart: g.length, cursorNodeText: O };
  }
  return { formatted: o.join("") };
}
function F$(t, e, r = 0) {
  let n = 0;
  for (let i = r; i < t.length; ++i)
    t[i] === "	" ? n = n + e - n % e : n++;
  return n;
}
var _g = F$, qc, Xf, ul, Xc, $$ = class {
  constructor(e) {
    wO(this, qc), wO(this, ul), this.stack = [e];
  }
  get key() {
    let { stack: e, siblings: r } = this;
    return Qt(!1, e, r === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : Qt(!1, this.stack, -2);
  }
  get node() {
    return Qt(!1, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: e } = this, r = Qt(!1, e, -3);
    return Array.isArray(r) ? r : null;
  }
  get next() {
    let { siblings: e } = this;
    return e === null ? null : e[this.index + 1];
  }
  get previous() {
    let { siblings: e } = this;
    return e === null ? null : e[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: e, index: r } = this;
    return e !== null && r === e.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...Vo(this, ul, Xc).call(this)];
  }
  getName() {
    let { stack: e } = this, { length: r } = e;
    return r > 1 ? Qt(!1, e, -2) : null;
  }
  getValue() {
    return Qt(!1, this.stack, -1);
  }
  getNode(e = 0) {
    let r = Vo(this, qc, Xf).call(this, e);
    return r === -1 ? null : this.stack[r];
  }
  getParentNode(e = 0) {
    return this.getNode(e + 1);
  }
  call(e, ...r) {
    let { stack: n } = this, { length: i } = n, s = Qt(!1, n, -1);
    for (let a of r)
      s = s[a], n.push(a, s);
    try {
      return e(this);
    } finally {
      n.length = i;
    }
  }
  callParent(e, r = 0) {
    let n = Vo(this, qc, Xf).call(this, r + 1), i = this.stack.splice(n + 1);
    try {
      return e(this);
    } finally {
      this.stack.push(...i);
    }
  }
  each(e, ...r) {
    let { stack: n } = this, { length: i } = n, s = Qt(!1, n, -1);
    for (let a of r)
      s = s[a], n.push(a, s);
    try {
      for (let a = 0; a < s.length; ++a)
        n.push(a, s[a]), e(this, a, s), n.length -= 2;
    } finally {
      n.length = i;
    }
  }
  map(e, ...r) {
    let n = [];
    return this.each((i, s, a) => {
      n[s] = e(i, s, a);
    }, ...r), n;
  }
  match(...e) {
    let r = this.stack.length - 1, n = null, i = this.stack[r--];
    for (let s of e) {
      if (i === void 0)
        return !1;
      let a = null;
      if (typeof n == "number" && (a = n, n = this.stack[r--], i = this.stack[r--]), s && !s(i, n, a))
        return !1;
      n = this.stack[r--], i = this.stack[r--];
    }
    return !0;
  }
  findAncestor(e) {
    for (let r of Vo(this, ul, Xc).call(this))
      if (e(r))
        return r;
  }
  hasAncestor(e) {
    for (let r of Vo(this, ul, Xc).call(this))
      if (e(r))
        return !0;
    return !1;
  }
};
qc = /* @__PURE__ */ new WeakSet(), Xf = function(t) {
  let { stack: e } = this;
  for (let r = e.length - 1; r >= 0; r -= 2)
    if (!Array.isArray(e[r]) && --t < 0)
      return r;
  return -1;
}, ul = /* @__PURE__ */ new WeakSet(), Xc = function* () {
  let { stack: t } = this;
  for (let e = t.length - 3; e >= 0; e -= 2) {
    let r = t[e];
    Array.isArray(r) || (yield r);
  }
};
var B$ = $$, hv = new Proxy(() => {
}, { get: () => hv }), Vf = hv;
function I$(t) {
  return t !== null && typeof t == "object";
}
var N$ = I$;
function* pv(t, e) {
  let { getVisitorKeys: r, filter: n = () => !0 } = e, i = (s) => N$(s) && n(s);
  for (let s of r(t)) {
    let a = t[s];
    if (Array.isArray(a))
      for (let o of a)
        i(o) && (yield o);
    else
      i(a) && (yield a);
  }
}
function* _$(t, e) {
  let r = [t];
  for (let n = 0; n < r.length; n++) {
    let i = r[n];
    for (let s of pv(i, e))
      yield s, r.push(s);
  }
}
function mu(t) {
  return (e, r, n) => {
    let i = !!(n != null && n.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, a = r;
    for (; a >= 0 && a < s; ) {
      let o = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(o))
          return a;
      } else if (!t.includes(o))
        return a;
      i ? a-- : a++;
    }
    return a === -1 || a === s ? a : !1;
  };
}
var Q$ = mu(/\s/), ds = mu(" 	"), dv = mu(",; 	"), fv = mu(/[^\n\r]/);
function M$(t, e, r) {
  let n = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let i = t.charAt(e);
  if (n) {
    if (t.charAt(e - 1) === "\r" && i === `
`)
      return e - 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e - 1;
  } else {
    if (i === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e + 1;
  }
  return e;
}
var Us = M$;
function L$(t, e, r = {}) {
  let n = ds(t, r.backwards ? e - 1 : e, r), i = Us(t, n, r);
  return n !== i;
}
var os = L$;
function R$(t) {
  return Array.isArray(t) && t.length > 0;
}
var j$ = R$, mv = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]), Z$ = (t) => Object.keys(t).filter((e) => !mv.has(e));
function W$(t) {
  return t ? (e) => t(e, mv) : Z$;
}
var gp = W$;
function q$(t) {
  let e = t.type || t.kind || "(unknown type)", r = String(t.name || t.id && (typeof t.id == "object" ? t.id.name : t.id) || t.key && (typeof t.key == "object" ? t.key.name : t.key) || t.value && (typeof t.value == "object" ? "" : String(t.value)) || t.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + ""), e + (r ? " " + r : "");
}
function Qg(t, e) {
  (t.comments ?? (t.comments = [])).push(e), e.printed = !1, e.nodeDescription = q$(t);
}
function ja(t, e) {
  e.leading = !0, e.trailing = !1, Qg(t, e);
}
function _s(t, e, r) {
  e.leading = !1, e.trailing = !1, r && (e.marker = r), Qg(t, e);
}
function Za(t, e) {
  e.leading = !1, e.trailing = !0, Qg(t, e);
}
var Cd = /* @__PURE__ */ new WeakMap();
function Mg(t, e) {
  if (Cd.has(t))
    return Cd.get(t);
  let { printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: i }, locStart: s, locEnd: a } = e;
  if (!n)
    return [];
  let o = ((r == null ? void 0 : r(t, e)) ?? [...pv(t, { getVisitorKeys: gp(i) })]).flatMap((u) => n(u) ? [u] : Mg(u, e));
  return o.sort((u, c) => s(u) - s(c) || a(u) - a(c)), Cd.set(t, o), o;
}
function gv(t, e, r, n) {
  let { locStart: i, locEnd: s } = r, a = i(e), o = s(e), u = Mg(t, r), c, h, p = 0, m = u.length;
  for (; p < m; ) {
    let g = p + m >> 1, O = u[g], b = i(O), D = s(O);
    if (b <= a && o <= D)
      return gv(O, e, r, O);
    if (D <= a) {
      c = O, p = g + 1;
      continue;
    }
    if (o <= b) {
      h = O, m = g;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((n == null ? void 0 : n.type) === "TemplateLiteral") {
    let { quasis: g } = n, O = Ad(g, e, r);
    c && Ad(g, c, r) !== O && (c = null), h && Ad(g, h, r) !== O && (h = null);
  }
  return { enclosingNode: n, precedingNode: c, followingNode: h };
}
var Ed = () => !1;
function X$(t, e) {
  let { comments: r } = t;
  if (delete t.comments, !j$(r) || !e.printer.canAttachComment)
    return;
  let n = [], { locStart: i, locEnd: s, printer: { experimentalFeatures: { avoidAstMutation: a = !1 } = {}, handleComments: o = {} }, originalText: u } = e, { ownLine: c = Ed, endOfLine: h = Ed, remaining: p = Ed } = o, m = r.map((g, O) => ({ ...gv(t, g, e), comment: g, text: u, options: e, ast: t, isLastComment: r.length - 1 === O }));
  for (let [g, O] of m.entries()) {
    let { comment: b, precedingNode: D, enclosingNode: S, followingNode: x, text: w, options: T, ast: C, isLastComment: A } = O;
    if (T.parser === "json" || T.parser === "json5" || T.parser === "jsonc" || T.parser === "__js_expression" || T.parser === "__ts_expression" || T.parser === "__vue_expression" || T.parser === "__vue_ts_expression") {
      if (i(b) - i(C) <= 0) {
        ja(C, b);
        continue;
      }
      if (s(b) - s(C) >= 0) {
        Za(C, b);
        continue;
      }
    }
    let P;
    if (a ? P = [O] : (b.enclosingNode = S, b.precedingNode = D, b.followingNode = x, P = [b, w, T, C, A]), V$(w, T, m, g))
      b.placement = "ownLine", c(...P) || (x ? ja(x, b) : D ? Za(D, b) : _s(S || C, b));
    else if (Y$(w, T, m, g))
      b.placement = "endOfLine", h(...P) || (D ? Za(D, b) : x ? ja(x, b) : _s(S || C, b));
    else if (b.placement = "remaining", !p(...P))
      if (D && x) {
        let $ = n.length;
        $ > 0 && n[$ - 1].followingNode !== x && TO(n, T), n.push(O);
      } else
        D ? Za(D, b) : x ? ja(x, b) : _s(S || C, b);
  }
  if (TO(n, e), !a)
    for (let g of r)
      delete g.precedingNode, delete g.enclosingNode, delete g.followingNode;
}
var yv = (t) => !/[\S\n\u2028\u2029]/.test(t);
function V$(t, e, r, n) {
  let { comment: i, precedingNode: s } = r[n], { locStart: a, locEnd: o } = e, u = a(i);
  if (s)
    for (let c = n - 1; c >= 0; c--) {
      let { comment: h, precedingNode: p } = r[c];
      if (p !== s || !yv(t.slice(o(h), u)))
        break;
      u = a(h);
    }
  return os(t, u, { backwards: !0 });
}
function Y$(t, e, r, n) {
  let { comment: i, followingNode: s } = r[n], { locStart: a, locEnd: o } = e, u = o(i);
  if (s)
    for (let c = n + 1; c < r.length; c++) {
      let { comment: h, followingNode: p } = r[c];
      if (p !== s || !yv(t.slice(u, a(h))))
        break;
      u = o(h);
    }
  return os(t, u);
}
function TO(t, e) {
  var r, n;
  let i = t.length;
  if (i === 0)
    return;
  let { precedingNode: s, followingNode: a } = t[0], o = e.locStart(a), u;
  for (u = i; u > 0; --u) {
    let { comment: c, precedingNode: h, followingNode: p } = t[u - 1];
    Vf.strictEqual(h, s), Vf.strictEqual(p, a);
    let m = e.originalText.slice(e.locEnd(c), o);
    if (((n = (r = e.printer).isGap) == null ? void 0 : n.call(r, m, e)) ?? /^[\s(]*$/.test(m))
      o = e.locStart(c);
    else
      break;
  }
  for (let [c, { comment: h }] of t.entries())
    c < u ? Za(s, h) : ja(a, h);
  for (let c of [s, a])
    c.comments && c.comments.length > 1 && c.comments.sort((h, p) => e.locStart(h) - e.locStart(p));
  t.length = 0;
}
function Ad(t, e, r) {
  let n = r.locStart(e) - 1;
  for (let i = 1; i < t.length; ++i)
    if (n < r.locStart(t[i]))
      return i - 1;
  return 0;
}
function U$(t, e) {
  let r = e - 1;
  r = ds(t, r, { backwards: !0 }), r = Us(t, r, { backwards: !0 }), r = ds(t, r, { backwards: !0 });
  let n = Us(t, r, { backwards: !0 });
  return r !== n;
}
var Lg = U$;
function Ov(t, e) {
  let r = t.node;
  return r.printed = !0, e.printer.printComment(t, e);
}
function z$(t, e) {
  var r;
  let n = t.node, i = [Ov(t, e)], { printer: s, originalText: a, locStart: o, locEnd: u } = e;
  if ((r = s.isBlockComment) != null && r.call(s, n)) {
    let h = os(a, u(n)) ? os(a, o(n), { backwards: !0 }) ? Ys : iv : " ";
    i.push(h);
  } else
    i.push(Ys);
  let c = Us(a, ds(a, u(n)));
  return c !== !1 && os(a, c) && i.push(Ys), i;
}
function G$(t, e, r) {
  var n;
  let i = t.node, s = Ov(t, e), { printer: a, originalText: o, locStart: u } = e, c = (n = a.isBlockComment) == null ? void 0 : n.call(a, i);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || os(o, u(i), { backwards: !0 })) {
    let h = Lg(o, u(i));
    return { doc: jf([Ys, h ? Ys : "", s]), isBlock: c, hasLineSuffix: !0 };
  }
  return !c || r != null && r.hasLineSuffix ? { doc: [jf([" ", s]), dp], isBlock: c, hasLineSuffix: !0 } : { doc: [" ", s], isBlock: c, hasLineSuffix: !1 };
}
function H$(t, e) {
  let r = t.node;
  if (!r)
    return {};
  let n = e[Symbol.for("printedComments")];
  if ((r.comments || []).filter((o) => !n.has(o)).length === 0)
    return { leading: "", trailing: "" };
  let i = [], s = [], a;
  return t.each(() => {
    let o = t.node;
    if (n != null && n.has(o))
      return;
    let { leading: u, trailing: c } = o;
    u ? i.push(z$(t, e)) : c && (a = G$(t, e, a), s.push(a.doc));
  }, "comments"), { leading: i, trailing: s };
}
function J$(t, e, r) {
  let { leading: n, trailing: i } = H$(t, r);
  return !n && !i ? e : uv(e, (s) => [n, s, i]);
}
function K$(t) {
  let { [Symbol.for("comments")]: e, [Symbol.for("printedComments")]: r } = t;
  for (let n of e) {
    if (!n.printed && !r.has(n))
      throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
    delete n.printed;
  }
}
var xv = class extends Error {
  constructor() {
    super(...arguments);
    wn(this, "name", "ConfigError");
  }
}, kO = class extends Error {
  constructor() {
    super(...arguments);
    wn(this, "name", "UndefinedParserError");
  }
}, e3 = { cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (t) => typeof t == "string" || typeof t == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }] }, plugins: { type: "path", array: !0, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (t) => typeof t == "string" || typeof t == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: !1, description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: !1, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function bv({ plugins: t = [], showDeprecated: e = !1 } = {}) {
  let r = t.flatMap((i) => i.languages ?? []), n = [];
  for (let i of r3(Object.assign({}, ...t.map(({ options: s }) => s), e3)))
    !e && i.deprecated || (Array.isArray(i.choices) && (e || (i.choices = i.choices.filter((s) => !s.deprecated)), i.name === "parser" && (i.choices = [...i.choices, ...t3(i.choices, r, t)])), i.pluginDefaults = Object.fromEntries(t.filter((s) => {
      var a;
      return ((a = s.defaultOptions) == null ? void 0 : a[i.name]) !== void 0;
    }).map((s) => [s.name, s.defaultOptions[i.name]])), n.push(i));
  return { languages: r, options: n };
}
function* t3(t, e, r) {
  let n = new Set(t.map((i) => i.value));
  for (let i of e)
    if (i.parsers) {
      for (let s of i.parsers)
        if (!n.has(s)) {
          n.add(s);
          let a = r.find((u) => u.parsers && Object.prototype.hasOwnProperty.call(u.parsers, s)), o = i.name;
          a != null && a.name && (o += ` (plugin: ${a.name})`), yield { value: s, description: o };
        }
    }
}
function r3(t) {
  let e = [];
  for (let [r, n] of Object.entries(t)) {
    let i = { name: r, ...n };
    Array.isArray(i.default) && (i.default = Qt(!1, i.default, -1).value), e.push(i);
  }
  return e;
}
var n3 = (t) => String(t).split(/[/\\]/).pop();
function PO(t, e) {
  if (!e)
    return;
  let r = n3(e).toLowerCase();
  return t.find(({ filenames: n }) => n == null ? void 0 : n.some((i) => i.toLowerCase() === r)) ?? t.find(({ extensions: n }) => n == null ? void 0 : n.some((i) => r.endsWith(i)));
}
function i3(t, e) {
  if (e)
    return t.find(({ name: r }) => r.toLowerCase() === e) ?? t.find(({ aliases: r }) => r == null ? void 0 : r.includes(e)) ?? t.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${e}`));
}
function s3(t, e) {
  let r = t.plugins.flatMap((i) => i.languages ?? []), n = i3(r, e.language) ?? PO(r, e.physicalFile) ?? PO(r, e.file) ?? (e.physicalFile, void 0);
  return n == null ? void 0 : n.parsers[0];
}
var a3 = s3, Wa = { key: (t) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(t) ? t : JSON.stringify(t), value(t) {
  if (t === null || typeof t != "object")
    return JSON.stringify(t);
  if (Array.isArray(t))
    return `[${t.map((r) => Wa.value(r)).join(", ")}]`;
  let e = Object.keys(t);
  return e.length === 0 ? "{}" : `{ ${e.map((r) => `${Wa.key(r)}: ${Wa.value(t[r])}`).join(", ")} }`;
}, pair: ({ key: t, value: e }) => Wa.value({ [t]: e }) }, FO = fu(hp(), 1), o3 = (t, e, { descriptor: r }) => {
  let n = [`${FO.default.yellow(typeof t == "string" ? r.key(t) : r.pair(t))} is deprecated`];
  return e && n.push(`we now treat it as ${FO.default.blue(typeof e == "string" ? r.key(e) : r.pair(e))}`), n.join("; ") + ".";
}, qa = fu(hp(), 1), Dv = Symbol.for("vnopts.VALUE_NOT_EXIST"), Vc = Symbol.for("vnopts.VALUE_UNCHANGED"), $O = " ".repeat(2), l3 = (t, e, r) => {
  let { text: n, list: i } = r.normalizeExpectedResult(r.schemas[t].expected(r)), s = [];
  return n && s.push(BO(t, e, n, r.descriptor)), i && s.push([BO(t, e, i.title, r.descriptor)].concat(i.values.map((a) => vv(a, r.loggerPrintWidth))).join(`
`)), Sv(s, r.loggerPrintWidth);
};
function BO(t, e, r, n) {
  return [`Invalid ${qa.default.red(n.key(t))} value.`, `Expected ${qa.default.blue(r)},`, `but received ${e === Dv ? qa.default.gray("nothing") : qa.default.red(n.value(e))}.`].join(" ");
}
function vv({ text: t, list: e }, r) {
  let n = [];
  return t && n.push(`- ${qa.default.blue(t)}`), e && n.push([`- ${qa.default.blue(e.title)}:`].concat(e.values.map((i) => vv(i, r - $O.length).replace(/^|\n/g, `$&${$O}`))).join(`
`)), Sv(n, r);
}
function Sv(t, e) {
  if (t.length === 1)
    return t[0];
  let [r, n] = t, [i, s] = t.map((a) => a.split(`
`, 1)[0].length);
  return i > e && i > s ? n : r;
}
var IO = fu(hp(), 1), Td = [], NO = [];
function u3(t, e) {
  if (t === e)
    return 0;
  let r = t;
  t.length > e.length && (t = e, e = r);
  let n = t.length, i = e.length;
  for (; n > 0 && t.charCodeAt(~-n) === e.charCodeAt(~-i); )
    n--, i--;
  let s = 0;
  for (; s < n && t.charCodeAt(s) === e.charCodeAt(s); )
    s++;
  if (n -= s, i -= s, n === 0)
    return i;
  let a, o, u, c, h = 0, p = 0;
  for (; h < n; )
    NO[h] = t.charCodeAt(s + h), Td[h] = ++h;
  for (; p < i; )
    for (a = e.charCodeAt(s + p), u = p++, o = p, h = 0; h < n; h++)
      c = a === NO[h] ? u : u + 1, u = Td[h], o = Td[h] = u > o ? c > o ? o + 1 : c : c > u ? u + 1 : c;
  return o;
}
var wv = (t, e, { descriptor: r, logger: n, schemas: i }) => {
  let s = [`Ignored unknown option ${IO.default.yellow(r.pair({ key: t, value: e }))}.`], a = Object.keys(i).sort().find((o) => u3(t, o) < 3);
  a && s.push(`Did you mean ${IO.default.blue(r.key(a))}?`), n.warn(s.join(" "));
}, c3 = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function h3(t, e) {
  let r = new t(e), n = Object.create(r);
  for (let i of c3)
    i in e && (n[i] = p3(e[i], r, Ss.prototype[i].length));
  return n;
}
var Ss = class {
  static create(e) {
    return h3(this, e);
  }
  constructor(e) {
    this.name = e.name;
  }
  default(e) {
  }
  expected(e) {
    return "nothing";
  }
  validate(e, r) {
    return !1;
  }
  deprecated(e, r) {
    return !1;
  }
  forward(e, r) {
  }
  redirect(e, r) {
  }
  overlap(e, r, n) {
    return e;
  }
  preprocess(e, r) {
    return e;
  }
  postprocess(e, r) {
    return Vc;
  }
};
function p3(t, e, r) {
  return typeof t == "function" ? (...n) => t(...n.slice(0, r - 1), e, ...n.slice(r - 1)) : () => t;
}
var d3 = class extends Ss {
  constructor(e) {
    super(e), this._sourceName = e.sourceName;
  }
  expected(e) {
    return e.schemas[this._sourceName].expected(e);
  }
  validate(e, r) {
    return r.schemas[this._sourceName].validate(e, r);
  }
  redirect(e, r) {
    return this._sourceName;
  }
}, f3 = class extends Ss {
  expected() {
    return "anything";
  }
  validate() {
    return !0;
  }
}, m3 = class extends Ss {
  constructor({ valueSchema: e, name: r = e.name, ...n }) {
    super({ ...n, name: r }), this._valueSchema = e;
  }
  expected(e) {
    let { text: r, list: n } = e.normalizeExpectedResult(this._valueSchema.expected(e));
    return { text: r && `an array of ${r}`, list: n && { title: "an array of the following values", values: [{ list: n }] } };
  }
  validate(e, r) {
    if (!Array.isArray(e))
      return !1;
    let n = [];
    for (let i of e) {
      let s = r.normalizeValidateResult(this._valueSchema.validate(i, r), i);
      s !== !0 && n.push(s.value);
    }
    return n.length === 0 ? !0 : { value: n };
  }
  deprecated(e, r) {
    let n = [];
    for (let i of e) {
      let s = r.normalizeDeprecatedResult(this._valueSchema.deprecated(i, r), i);
      s !== !1 && n.push(...s.map(({ value: a }) => ({ value: [a] })));
    }
    return n;
  }
  forward(e, r) {
    let n = [];
    for (let i of e) {
      let s = r.normalizeForwardResult(this._valueSchema.forward(i, r), i);
      n.push(...s.map(_O));
    }
    return n;
  }
  redirect(e, r) {
    let n = [], i = [];
    for (let s of e) {
      let a = r.normalizeRedirectResult(this._valueSchema.redirect(s, r), s);
      "remain" in a && n.push(a.remain), i.push(...a.redirect.map(_O));
    }
    return n.length === 0 ? { redirect: i } : { redirect: i, remain: n };
  }
  overlap(e, r) {
    return e.concat(r);
  }
};
function _O({ from: t, to: e }) {
  return { from: [t], to: e };
}
var g3 = class extends Ss {
  expected() {
    return "true or false";
  }
  validate(e) {
    return typeof e == "boolean";
  }
};
function y3(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let n of t) {
    let i = n[e];
    if (r[i])
      throw new Error(`Duplicate ${e} ${JSON.stringify(i)}`);
    r[i] = n;
  }
  return r;
}
function O3(t, e) {
  let r = /* @__PURE__ */ new Map();
  for (let n of t) {
    let i = n[e];
    if (r.has(i))
      throw new Error(`Duplicate ${e} ${JSON.stringify(i)}`);
    r.set(i, n);
  }
  return r;
}
function x3() {
  let t = /* @__PURE__ */ Object.create(null);
  return (e) => {
    let r = JSON.stringify(e);
    return t[r] ? !0 : (t[r] = !0, !1);
  };
}
function b3(t, e) {
  let r = [], n = [];
  for (let i of t)
    e(i) ? r.push(i) : n.push(i);
  return [r, n];
}
function D3(t) {
  return t === Math.floor(t);
}
function v3(t, e) {
  if (t === e)
    return 0;
  let r = typeof t, n = typeof e, i = ["undefined", "object", "boolean", "number", "string"];
  return r !== n ? i.indexOf(r) - i.indexOf(n) : r !== "string" ? Number(t) - Number(e) : t.localeCompare(e);
}
function S3(t) {
  return (...e) => {
    let r = t(...e);
    return typeof r == "string" ? new Error(r) : r;
  };
}
function QO(t) {
  return t === void 0 ? {} : t;
}
function Cv(t) {
  if (typeof t == "string")
    return { text: t };
  let { text: e, list: r } = t;
  return w3((e || r) !== void 0, "Unexpected `expected` result, there should be at least one field."), r ? { text: e, list: { title: r.title, values: r.values.map(Cv) } } : { text: e };
}
function MO(t, e) {
  return t === !0 ? !0 : t === !1 ? { value: e } : t;
}
function LO(t, e, r = !1) {
  return t === !1 ? !1 : t === !0 ? r ? !0 : [{ value: e }] : "value" in t ? [t] : t.length === 0 ? !1 : t;
}
function RO(t, e) {
  return typeof t == "string" || "key" in t ? { from: e, to: t } : "from" in t ? { from: t.from, to: t.to } : { from: e, to: t.to };
}
function Yf(t, e) {
  return t === void 0 ? [] : Array.isArray(t) ? t.map((r) => RO(r, e)) : [RO(t, e)];
}
function jO(t, e) {
  let r = Yf(typeof t == "object" && "redirect" in t ? t.redirect : t, e);
  return r.length === 0 ? { remain: e, redirect: r } : typeof t == "object" && "remain" in t ? { remain: t.remain, redirect: r } : { redirect: r };
}
function w3(t, e) {
  if (!t)
    throw new Error(e);
}
var C3 = class extends Ss {
  constructor(e) {
    super(e), this._choices = O3(e.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
  }
  expected({ descriptor: e }) {
    let r = Array.from(this._choices.keys()).map((s) => this._choices.get(s)).filter(({ hidden: s }) => !s).map((s) => s.value).sort(v3).map(e.value), n = r.slice(0, -2), i = r.slice(-2);
    return { text: n.concat(i.join(" or ")).join(", "), list: { title: "one of the following values", values: r } };
  }
  validate(e) {
    return this._choices.has(e);
  }
  deprecated(e) {
    let r = this._choices.get(e);
    return r && r.deprecated ? { value: e } : !1;
  }
  forward(e) {
    let r = this._choices.get(e);
    return r ? r.forward : void 0;
  }
  redirect(e) {
    let r = this._choices.get(e);
    return r ? r.redirect : void 0;
  }
}, E3 = class extends Ss {
  expected() {
    return "a number";
  }
  validate(e, r) {
    return typeof e == "number";
  }
}, A3 = class extends E3 {
  expected() {
    return "an integer";
  }
  validate(e, r) {
    return r.normalizeValidateResult(super.validate(e, r), e) === !0 && D3(e);
  }
}, ZO = class extends Ss {
  expected() {
    return "a string";
  }
  validate(e) {
    return typeof e == "string";
  }
}, T3 = Wa, k3 = wv, P3 = l3, F3 = o3, $3 = class {
  constructor(e, r) {
    let { logger: n = console, loggerPrintWidth: i = 80, descriptor: s = T3, unknown: a = k3, invalid: o = P3, deprecated: u = F3, missing: c = () => !1, required: h = () => !1, preprocess: p = (g) => g, postprocess: m = () => Vc } = r || {};
    this._utils = { descriptor: s, logger: n || { warn: () => {
    } }, loggerPrintWidth: i, schemas: y3(e, "name"), normalizeDefaultResult: QO, normalizeExpectedResult: Cv, normalizeDeprecatedResult: LO, normalizeForwardResult: Yf, normalizeRedirectResult: jO, normalizeValidateResult: MO }, this._unknownHandler = a, this._invalidHandler = S3(o), this._deprecatedHandler = u, this._identifyMissing = (g, O) => !(g in O) || c(g, O), this._identifyRequired = h, this._preprocess = p, this._postprocess = m, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = x3();
  }
  normalize(e) {
    let r = {}, n = [this._preprocess(e, this._utils)], i = () => {
      for (; n.length !== 0; ) {
        let s = n.shift(), a = this._applyNormalization(s, r);
        n.push(...a);
      }
    };
    i();
    for (let s of Object.keys(this._utils.schemas)) {
      let a = this._utils.schemas[s];
      if (!(s in r)) {
        let o = QO(a.default(this._utils));
        "value" in o && n.push({ [s]: o.value });
      }
    }
    i();
    for (let s of Object.keys(this._utils.schemas)) {
      if (!(s in r))
        continue;
      let a = this._utils.schemas[s], o = r[s], u = a.postprocess(o, this._utils);
      u !== Vc && (this._applyValidation(u, s, a), r[s] = u);
    }
    return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
  }
  _applyNormalization(e, r) {
    let n = [], { knownKeys: i, unknownKeys: s } = this._partitionOptionKeys(e);
    for (let a of i) {
      let o = this._utils.schemas[a], u = o.preprocess(e[a], this._utils);
      this._applyValidation(u, a, o);
      let c = ({ from: m, to: g }) => {
        n.push(typeof g == "string" ? { [g]: m } : { [g.key]: g.value });
      }, h = ({ value: m, redirectTo: g }) => {
        let O = LO(o.deprecated(m, this._utils), u, !0);
        if (O !== !1)
          if (O === !0)
            this._hasDeprecationWarned(a) || this._utils.logger.warn(this._deprecatedHandler(a, g, this._utils));
          else
            for (let { value: b } of O) {
              let D = { key: a, value: b };
              if (!this._hasDeprecationWarned(D)) {
                let S = typeof g == "string" ? { key: g, value: b } : g;
                this._utils.logger.warn(this._deprecatedHandler(D, S, this._utils));
              }
            }
      };
      Yf(o.forward(u, this._utils), u).forEach(c);
      let p = jO(o.redirect(u, this._utils), u);
      if (p.redirect.forEach(c), "remain" in p) {
        let m = p.remain;
        r[a] = a in r ? o.overlap(r[a], m, this._utils) : m, h({ value: m });
      }
      for (let { from: m, to: g } of p.redirect)
        h({ value: m, redirectTo: g });
    }
    for (let a of s) {
      let o = e[a];
      this._applyUnknownHandler(a, o, r, (u, c) => {
        n.push({ [u]: c });
      });
    }
    return n;
  }
  _applyRequiredCheck(e) {
    for (let r of Object.keys(this._utils.schemas))
      if (this._identifyMissing(r, e) && this._identifyRequired(r))
        throw this._invalidHandler(r, Dv, this._utils);
  }
  _partitionOptionKeys(e) {
    let [r, n] = b3(Object.keys(e).filter((i) => !this._identifyMissing(i, e)), (i) => i in this._utils.schemas);
    return { knownKeys: r, unknownKeys: n };
  }
  _applyValidation(e, r, n) {
    let i = MO(n.validate(e, this._utils), e);
    if (i !== !0)
      throw this._invalidHandler(r, i.value, this._utils);
  }
  _applyUnknownHandler(e, r, n, i) {
    let s = this._unknownHandler(e, r, this._utils);
    if (s)
      for (let a of Object.keys(s)) {
        if (this._identifyMissing(a, s))
          continue;
        let o = s[a];
        a in this._utils.schemas ? i(a, o) : n[a] = o;
      }
  }
  _applyPostprocess(e) {
    let r = this._postprocess(e, this._utils);
    if (r !== Vc) {
      if (r.delete)
        for (let n of r.delete)
          delete e[n];
      if (r.override) {
        let { knownKeys: n, unknownKeys: i } = this._partitionOptionKeys(r.override);
        for (let s of n) {
          let a = r.override[s];
          this._applyValidation(a, s, this._utils.schemas[s]), e[s] = a;
        }
        for (let s of i) {
          let a = r.override[s];
          this._applyUnknownHandler(s, a, e, (o, u) => {
            let c = this._utils.schemas[o];
            this._applyValidation(u, o, c), e[o] = u;
          });
        }
      }
    }
  }
}, kd;
function B3(t, e, { logger: r = !1, isCLI: n = !1, passThrough: i = !1, FlagSchema: s, descriptor: a } = {}) {
  if (n) {
    if (!s)
      throw new Error("'FlagSchema' option is required.");
    if (!a)
      throw new Error("'descriptor' option is required.");
  } else
    a = Wa;
  let o = i ? Array.isArray(i) ? (m, g) => i.includes(m) ? { [m]: g } : void 0 : (m, g) => ({ [m]: g }) : (m, g, O) => {
    let { _: b, ...D } = O.schemas;
    return wv(m, g, { ...O, schemas: D });
  }, u = I3(e, { isCLI: n, FlagSchema: s }), c = new $3(u, { logger: r, unknown: o, descriptor: a }), h = r !== !1;
  h && kd && (c._hasDeprecationWarned = kd);
  let p = c.normalize(t);
  return h && (kd = c._hasDeprecationWarned), p;
}
function I3(t, { isCLI: e, FlagSchema: r }) {
  let n = [];
  e && n.push(f3.create({ name: "_" }));
  for (let i of t)
    n.push(N3(i, { isCLI: e, optionInfos: t, FlagSchema: r })), i.alias && e && n.push(d3.create({ name: i.alias, sourceName: i.name }));
  return n;
}
function N3(t, { isCLI: e, optionInfos: r, FlagSchema: n }) {
  let { name: i } = t, s = { name: i }, a, o = {};
  switch (t.type) {
    case "int":
      a = A3, e && (s.preprocess = Number);
      break;
    case "string":
      a = ZO;
      break;
    case "choice":
      a = C3, s.choices = t.choices.map((u) => u != null && u.redirect ? { ...u, redirect: { to: { key: t.name, value: u.redirect } } } : u);
      break;
    case "boolean":
      a = g3;
      break;
    case "flag":
      a = n, s.flags = r.flatMap((u) => [u.alias, u.description && u.name, u.oppositeDescription && `no-${u.name}`].filter(Boolean));
      break;
    case "path":
      a = ZO;
      break;
    default:
      throw new Error(`Unexpected type ${t.type}`);
  }
  if (t.exception ? s.validate = (u, c, h) => t.exception(u) || c.validate(u, h) : s.validate = (u, c, h) => u === void 0 || c.validate(u, h), t.redirect && (o.redirect = (u) => u ? { to: { key: t.redirect.option, value: t.redirect.value } } : void 0), t.deprecated && (o.deprecated = !0), e && !t.array) {
    let u = s.preprocess || ((c) => c);
    s.preprocess = (c, h, p) => h.preprocess(u(Array.isArray(c) ? Qt(!1, c, -1) : c), p);
  }
  return t.array ? m3.create({ ...e ? { preprocess: (u) => Array.isArray(u) ? u : [u] } : {}, ...o, valueSchema: a.create(s) }) : a.create({ ...s, ...o });
}
var _3 = B3, Q3 = (t, e, r) => {
  if (!(t && e == null)) {
    if (e.findLast)
      return e.findLast(r);
    for (let n = e.length - 1; n >= 0; n--) {
      let i = e[n];
      if (r(i, n, e))
        return i;
    }
  }
}, Ev = Q3;
function Av(t, e) {
  if (!e)
    throw new Error("parserName is required.");
  let r = Ev(!1, t, (i) => i.parsers && Object.prototype.hasOwnProperty.call(i.parsers, e));
  if (r)
    return r;
  let n = `Couldn't resolve parser "${e}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new xv(n);
}
function M3(t, e) {
  if (!e)
    throw new Error("astFormat is required.");
  let r = Ev(!1, t, (i) => i.printers && Object.prototype.hasOwnProperty.call(i.printers, e));
  if (r)
    return r;
  let n = `Couldn't find plugin for AST format "${e}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new xv(n);
}
function Tv({ plugins: t, parser: e }) {
  let r = Av(t, e);
  return kv(r, e);
}
function kv(t, e) {
  let r = t.parsers[e];
  return typeof r == "function" ? r() : r;
}
function L3(t, e) {
  let r = t.printers[e];
  return typeof r == "function" ? r() : r;
}
var WO = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
async function R3(t, e = {}) {
  var r;
  let n = { ...t };
  if (!n.parser)
    if (n.filepath) {
      if (n.parser = a3(n, { physicalFile: n.filepath }), !n.parser)
        throw new kO(`No parser could be inferred for file "${n.filepath}".`);
    } else
      throw new kO("No parser and no file path given, couldn't infer a parser.");
  let i = bv({ plugins: t.plugins, showDeprecated: !0 }).options, s = { ...WO, ...Object.fromEntries(i.filter((m) => m.default !== void 0).map((m) => [m.name, m.default])) }, a = Av(n.plugins, n.parser), o = await kv(a, n.parser);
  n.astFormat = o.astFormat, n.locEnd = o.locEnd, n.locStart = o.locStart;
  let u = (r = a.printers) != null && r[o.astFormat] ? a : M3(n.plugins, o.astFormat), c = await L3(u, o.astFormat);
  n.printer = c;
  let h = u.defaultOptions ? Object.fromEntries(Object.entries(u.defaultOptions).filter(([, m]) => m !== void 0)) : {}, p = { ...s, ...h };
  for (let [m, g] of Object.entries(p))
    (n[m] === null || n[m] === void 0) && (n[m] = g);
  return n.parser === "json" && (n.trailingComma = "none"), _3(n, i, { passThrough: Object.keys(WO), ...e });
}
var Do = R3, j3 = fu(ZF(), 1);
async function Z3(t, e) {
  let r = await Tv(e), n = r.preprocess ? r.preprocess(t, e) : t;
  e.originalText = n;
  let i;
  try {
    i = await r.parse(n, e, e);
  } catch (s) {
    W3(s, t);
  }
  return { text: n, ast: i };
}
function W3(t, e) {
  let { loc: r } = t;
  if (r) {
    let n = (0, j3.codeFrameColumns)(e, r, { highlightCode: !0 });
    throw t.message += `
` + n, t.codeFrame = n, t;
  }
  throw t;
}
var gu = Z3;
async function q3(t, e, r, n, i) {
  let { embeddedLanguageFormatting: s, printer: { embed: a, hasPrettierIgnore: o = () => !1, getVisitorKeys: u } } = r;
  if (!a || s !== "auto")
    return;
  if (a.length > 2)
    throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed");
  let c = gp(a.getVisitorKeys ?? u), h = [];
  g();
  let p = t.stack;
  for (let { print: O, node: b, pathStack: D } of h)
    try {
      t.stack = D;
      let S = await O(m, e, t, r);
      S && i.set(b, S);
    } catch (S) {
      if (globalThis.PRETTIER_DEBUG)
        throw S;
    }
  t.stack = p;
  function m(O, b) {
    return X3(O, b, r, n);
  }
  function g() {
    let { node: O } = t;
    if (O === null || typeof O != "object" || o(t))
      return;
    for (let D of c(O))
      Array.isArray(O[D]) ? t.each(g, D) : t.call(g, D);
    let b = a(t, r);
    if (b) {
      if (typeof b == "function") {
        h.push({ print: b, node: O, pathStack: [...t.stack] });
        return;
      }
      i.set(O, b);
    }
  }
}
async function X3(t, e, r, n) {
  let i = await Do({ ...r, ...e, parentParser: r.parser, originalText: t }, { passThrough: !0 }), { ast: s } = await gu(t, i), a = await n(s, i);
  return lv(a);
}
function V3(t, e) {
  let { originalText: r, [Symbol.for("comments")]: n, locStart: i, locEnd: s, [Symbol.for("printedComments")]: a } = e, { node: o } = t, u = i(o), c = s(o);
  for (let h of n)
    i(h) >= u && s(h) <= c && a.add(h);
  return r.slice(u, c);
}
var Y3 = V3;
async function yp(t, e) {
  ({ ast: t } = await Pv(t, e));
  let r = /* @__PURE__ */ new Map(), n = new B$(t), i = /* @__PURE__ */ new Map();
  await q3(n, a, e, yp, i);
  let s = await qO(n, e, a, void 0, i);
  return K$(e), s;
  function a(u, c) {
    return u === void 0 || u === n ? o(c) : Array.isArray(u) ? n.call(() => o(c), ...u) : n.call(() => o(c), u);
  }
  function o(u) {
    let c = n.node;
    if (c == null)
      return "";
    let h = c && typeof c == "object" && u === void 0;
    if (h && r.has(c))
      return r.get(c);
    let p = qO(n, e, a, u, i);
    return h && r.set(c, p), p;
  }
}
function qO(t, e, r, n, i) {
  var s;
  let { node: a } = t, { printer: o } = e, u;
  return (s = o.hasPrettierIgnore) != null && s.call(o, t) ? u = Y3(t, e) : i.has(a) ? u = i.get(a) : u = o.print(t, e, r, n), a === e.cursorNode && (u = uv(u, (c) => [Zf, c, Zf])), o.printComment && (!o.willPrintOwnComments || !o.willPrintOwnComments(t, e)) && (u = J$(t, u, e)), u;
}
async function Pv(t, e) {
  let r = t.comments ?? [];
  e[Symbol.for("comments")] = r, e[Symbol.for("tokens")] = t.tokens ?? [], e[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), X$(t, e);
  let { printer: { preprocess: n } } = e;
  return t = n ? await n(t, e) : t, { ast: t, comments: r };
}
function U3(t, e) {
  let { cursorOffset: r, locStart: n, locEnd: i } = e, s = gp(e.printer.getVisitorKeys), a = (u) => n(u) <= r && i(u) >= r, o = t;
  for (let u of _$(t, { getVisitorKeys: s, filter: a }))
    o = u;
  return o;
}
var z3 = U3;
function G3(t, e) {
  let { printer: { massageAstNode: r, getVisitorKeys: n } } = e;
  if (!r)
    return t;
  let i = gp(n), s = r.ignoredProperties ?? /* @__PURE__ */ new Set();
  return a(t);
  function a(o, u) {
    if (!(o !== null && typeof o == "object"))
      return o;
    if (Array.isArray(o))
      return o.map((m) => a(m, u)).filter(Boolean);
    let c = {}, h = new Set(i(o));
    for (let m in o)
      !Object.prototype.hasOwnProperty.call(o, m) || s.has(m) || (h.has(m) ? c[m] = a(o[m], o) : c[m] = o[m]);
    let p = r(o, c, u);
    if (p !== null)
      return p ?? c;
  }
}
var H3 = G3, J3 = ({ parser: t }) => t === "json" || t === "json5" || t === "jsonc" || t === "json-stringify";
function K3(t, e) {
  let r = [t.node, ...t.parentNodes], n = /* @__PURE__ */ new Set([e.node, ...e.parentNodes]);
  return r.find((i) => Fv.has(i.type) && n.has(i));
}
function XO(t) {
  let e = t.length - 1;
  for (; ; ) {
    let r = t[e];
    if ((r == null ? void 0 : r.type) === "Program" || (r == null ? void 0 : r.type) === "File")
      e--;
    else
      break;
  }
  return t.slice(0, e + 1);
}
function eB(t, e, { locStart: r, locEnd: n }) {
  let i = t.node, s = e.node;
  if (i === s)
    return { startNode: i, endNode: s };
  let a = r(t.node);
  for (let u of XO(e.parentNodes))
    if (r(u) >= a)
      s = u;
    else
      break;
  let o = n(e.node);
  for (let u of XO(t.parentNodes)) {
    if (n(u) <= o)
      i = u;
    else
      break;
    if (i === s)
      break;
  }
  return { startNode: i, endNode: s };
}
function Uf(t, e, r, n, i = [], s) {
  let { locStart: a, locEnd: o } = r, u = a(t), c = o(t);
  if (!(e > c || e < u || s === "rangeEnd" && e === u || s === "rangeStart" && e === c)) {
    for (let h of Mg(t, r)) {
      let p = Uf(h, e, r, n, [t, ...i], s);
      if (p)
        return p;
    }
    if (!n || n(t, i[0]))
      return { node: t, parentNodes: i };
  }
}
function tB(t, e) {
  return e !== "DeclareExportDeclaration" && t !== "TypeParameterDeclaration" && (t === "Directive" || t === "TypeAlias" || t === "TSExportAssignment" || t.startsWith("Declare") || t.startsWith("TSDeclare") || t.endsWith("Statement") || t.endsWith("Declaration"));
}
var Fv = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), rB = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function VO(t, e, r) {
  if (!e)
    return !1;
  switch (t.parser) {
    case "flow":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "__babel_estree":
      return tB(e.type, r == null ? void 0 : r.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return Fv.has(e.type);
    case "graphql":
      return rB.has(e.kind);
    case "vue":
      return e.tag !== "root";
  }
  return !1;
}
function nB(t, e, r) {
  let { rangeStart: n, rangeEnd: i, locStart: s, locEnd: a } = e;
  Vf.ok(i > n);
  let o = t.slice(n, i).search(/\S/), u = o === -1;
  if (!u)
    for (n += o; i > n && !/\S/.test(t[i - 1]); --i)
      ;
  let c = Uf(r, n, e, (g, O) => VO(e, g, O), [], "rangeStart"), h = u ? c : Uf(r, i, e, (g) => VO(e, g), [], "rangeEnd");
  if (!c || !h)
    return { rangeStart: 0, rangeEnd: 0 };
  let p, m;
  if (J3(e)) {
    let g = K3(c, h);
    p = g, m = g;
  } else
    ({ startNode: p, endNode: m } = eB(c, h, e));
  return { rangeStart: Math.min(s(p), s(m)), rangeEnd: Math.max(a(p), a(m)) };
}
var $v = "\uFEFF", YO = Symbol("cursor");
async function Bv(t, e, r = 0) {
  if (!t || t.trim().length === 0)
    return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: n, text: i } = await gu(t, e);
  e.cursorOffset >= 0 && (e.cursorNode = z3(n, e));
  let s = await yp(n, e);
  r > 0 && (s = ov([Ys, s], r, e.tabWidth));
  let a = mp(s, e);
  if (r > 0) {
    let u = a.formatted.trim();
    a.cursorNodeStart !== void 0 && (a.cursorNodeStart -= a.formatted.indexOf(u)), a.formatted = u + Fg(e.endOfLine);
  }
  let o = e[Symbol.for("comments")];
  if (e.cursorOffset >= 0) {
    let u, c, h, p, m;
    if (e.cursorNode && a.cursorNodeText ? (u = e.locStart(e.cursorNode), c = i.slice(u, e.locEnd(e.cursorNode)), h = e.cursorOffset - u, p = a.cursorNodeStart, m = a.cursorNodeText) : (u = 0, c = i, h = e.cursorOffset, p = 0, m = a.formatted), c === m)
      return { formatted: a.formatted, cursorOffset: p + h, comments: o };
    let g = c.split("");
    g.splice(h, 0, YO);
    let O = m.split(""), b = (0, qF.diffArrays)(g, O), D = p;
    for (let S of b)
      if (S.removed) {
        if (S.value.includes(YO))
          break;
      } else
        D += S.count;
    return { formatted: a.formatted, cursorOffset: D, comments: o };
  }
  return { formatted: a.formatted, cursorOffset: -1, comments: o };
}
async function iB(t, e) {
  let { ast: r, text: n } = await gu(t, e), { rangeStart: i, rangeEnd: s } = nB(n, e, r), a = n.slice(i, s), o = Math.min(i, n.lastIndexOf(`
`, i) + 1), u = n.slice(o, i).match(/^\s*/)[0], c = _g(u, e.tabWidth), h = await Bv(a, { ...e, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: e.cursorOffset > i && e.cursorOffset <= s ? e.cursorOffset - i : -1, endOfLine: "lf" }, c), p = h.formatted.trimEnd(), { cursorOffset: m } = e;
  m > s ? m += p.length - a.length : h.cursorOffset >= 0 && (m = h.cursorOffset + i);
  let g = n.slice(0, i) + p + n.slice(s);
  if (e.endOfLine !== "lf") {
    let O = Fg(e.endOfLine);
    m >= 0 && O === `\r
` && (m += KD(g.slice(0, m), `
`)), g = pp(!1, g, `
`, O);
  }
  return { formatted: g, cursorOffset: m, comments: h.comments };
}
function Pd(t, e, r) {
  return typeof e != "number" || Number.isNaN(e) || e < 0 || e > t.length ? r : e;
}
function UO(t, e) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: i } = e;
  return r = Pd(t, r, -1), n = Pd(t, n, 0), i = Pd(t, i, t.length), { ...e, cursorOffset: r, rangeStart: n, rangeEnd: i };
}
function Iv(t, e) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: i, endOfLine: s } = UO(t, e), a = t.charAt(0) === $v;
  if (a && (t = t.slice(1), r--, n--, i--), s === "auto" && (s = XF(t)), t.includes("\r")) {
    let o = (u) => KD(t.slice(0, Math.max(u, 0)), `\r
`);
    r -= o(r), n -= o(n), i -= o(i), t = VF(t);
  }
  return { hasBOM: a, text: t, options: UO(t, { ...e, cursorOffset: r, rangeStart: n, rangeEnd: i, endOfLine: s }) };
}
async function zO(t, e) {
  let r = await Tv(e);
  return !r.hasPragma || r.hasPragma(t);
}
async function Nv(t, e) {
  let { hasBOM: r, text: n, options: i } = Iv(t, await Do(e));
  if (i.rangeStart >= i.rangeEnd && n !== "" || i.requirePragma && !await zO(n, i))
    return { formatted: t, cursorOffset: e.cursorOffset, comments: [] };
  let s;
  return i.rangeStart > 0 || i.rangeEnd < n.length ? s = await iB(n, i) : (!i.requirePragma && i.insertPragma && i.printer.insertPragma && !await zO(n, i) && (n = i.printer.insertPragma(n)), s = await Bv(n, i)), r && (s.formatted = $v + s.formatted, s.cursorOffset >= 0 && s.cursorOffset++), s;
}
async function sB(t, e, r) {
  let { text: n, options: i } = Iv(t, await Do(e)), s = await gu(n, i);
  return r && (r.preprocessForPrint && (s.ast = await Pv(s.ast, i)), r.massage && (s.ast = H3(s.ast, i))), s;
}
async function aB(t, e) {
  e = await Do(e);
  let r = await yp(t, e);
  return mp(r, e);
}
async function oB(t, e) {
  let r = c$(t), { formatted: n } = await Nv(r, { ...e, parser: "__js_expression" });
  return n;
}
async function lB(t, e) {
  e = await Do(e);
  let { ast: r } = await gu(t, e);
  return yp(r, e);
}
async function uB(t, e) {
  return mp(t, await Do(e));
}
var _v = {};
cp(_v, { builders: () => cB, printer: () => hB, utils: () => pB });
var cB = { join: av, line: iv, softline: l$, hardline: Ys, literalline: sv, group: tv, conditionalGroup: n$, fill: rv, lineSuffix: jf, lineSuffixBoundary: a$, cursor: Zf, breakParent: dp, ifBreak: i$, trim: o$, indent: fh, indentIfBreak: s$, align: so, addAlignmentToDoc: ov, markAsRoot: t$, dedentToRoot: e$, dedent: r$, hardlineWithoutBreakParent: Bg, literallineWithoutBreakParent: nv, label: u$, concat: (t) => t }, hB = { printDocToString: mp }, pB = { willBreak: b$, traverseDoc: $g, findInDoc: Ng, mapDoc: fp, removeLines: S$, stripTrailingHardline: lv, replaceEndOfLine: E$, canBreak: T$ }, dB = "3.2.5", Qv = {};
cp(Qv, { addDanglingComment: () => _s, addLeadingComment: () => ja, addTrailingComment: () => Za, getAlignmentSize: () => _g, getIndentSize: () => xB, getMaxContinuousCount: () => vB, getNextNonSpaceNonCommentCharacter: () => wB, getNextNonSpaceNonCommentCharacterIndex: () => $B, getStringWidth: () => Ig, hasNewline: () => os, hasNewlineInRange: () => EB, hasSpaces: () => TB, isNextLineEmpty: () => _B, isNextLineEmptyAfterIndex: () => Wg, isPreviousLineEmpty: () => IB, makeString: () => PB, skip: () => mu, skipEverythingButNewLine: () => fv, skipInlineComment: () => Rg, skipNewline: () => Us, skipSpaces: () => ds, skipToLineEnd: () => dv, skipTrailingComment: () => jg, skipWhitespace: () => Q$ });
function fB(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var Rg = fB;
function mB(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? fv(t, e) : e;
}
var jg = mB;
function gB(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = ds(t, n), n = Rg(t, n), n = jg(t, n), n = Us(t, n);
  return n;
}
var Zg = gB;
function yB(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = dv(t, n), n = Rg(t, n), n = ds(t, n);
  return n = jg(t, n), n = Us(t, n), n !== !1 && os(t, n);
}
var Wg = yB;
function OB(t, e) {
  let r = t.lastIndexOf(`
`);
  return r === -1 ? 0 : _g(t.slice(r + 1).match(/^[\t ]*/)[0], e);
}
var xB = OB;
function bB(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function DB(t, e) {
  let r = t.match(new RegExp(`(${bB(e)})+`, "g"));
  return r === null ? 0 : r.reduce((n, i) => Math.max(n, i.length / e.length), 0);
}
var vB = DB;
function SB(t, e) {
  let r = Zg(t, e);
  return r === !1 ? "" : t.charAt(r);
}
var wB = SB;
function CB(t, e, r) {
  for (let n = e; n < r; ++n)
    if (t.charAt(n) === `
`)
      return !0;
  return !1;
}
var EB = CB;
function AB(t, e, r = {}) {
  return ds(t, r.backwards ? e - 1 : e, r) !== e;
}
var TB = AB;
function kB(t, e, r) {
  let n = e === '"' ? "'" : '"', i = pp(!1, t, /\\(.)|(["'])/gs, (s, a, o) => a === n ? a : o === e ? "\\" + o : o || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(a) ? a : "\\" + a));
  return e + i + e;
}
var PB = kB;
function FB(t, e, r) {
  return Zg(t, r(e));
}
function $B(t, e) {
  return arguments.length === 2 || typeof e == "number" ? Zg(t, e) : FB(...arguments);
}
function BB(t, e, r) {
  return Lg(t, r(e));
}
function IB(t, e) {
  return arguments.length === 2 || typeof e == "number" ? Lg(t, e) : BB(...arguments);
}
function NB(t, e, r) {
  return Wg(t, r(e));
}
function _B(t, e) {
  return arguments.length === 2 || typeof e == "number" ? Wg(t, e) : NB(...arguments);
}
function Ms(t, e = 1) {
  return async (...r) => {
    let n = r[e] ?? {}, i = n.plugins ?? [];
    return r[e] = { ...n, plugins: Array.isArray(i) ? i : Object.values(i) }, t(...r);
  };
}
var Mv = Ms(Nv);
async function Lv(t, e) {
  let { formatted: r } = await Mv(t, { ...e, cursorOffset: -1 });
  return r;
}
async function QB(t, e) {
  return await Lv(t, e) === t;
}
var MB = Ms(bv, 0), LB = { parse: Ms(sB), formatAST: Ms(aB), formatDoc: Ms(oB), printToDoc: Ms(lB), printDocToString: Ms(uB) }, RB = JD, jB = Object.defineProperty, Rv = (t, e) => {
  for (var r in e)
    jB(t, r, { get: e[r], enumerable: !0 });
}, jv = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, Xi = (t, e, r) => (jv(t, e, "read from private field"), r ? r.call(t) : e.get(t)), ZB = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, WB = (t, e, r, n) => (jv(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r), Zv = {};
Rv(Zv, { languages: () => TN, options: () => PN, parsers: () => v2, printers: () => N5 });
var qB = (t, e, r, n) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
}, Gr = qB, qg = "string", Xg = "array", Vg = "cursor", Op = "indent", xp = "align", Yg = "trim", Ml = "group", bp = "fill", Dp = "if-break", vp = "indent-if-break", Ug = "line-suffix", zg = "line-suffix-boundary", pa = "line", Gg = "label", Sp = "break-parent", Wv = /* @__PURE__ */ new Set([Vg, Op, xp, Yg, Ml, bp, Dp, vp, Ug, zg, pa, Gg, Sp]);
function XB(t) {
  if (typeof t == "string")
    return qg;
  if (Array.isArray(t))
    return Xg;
  if (!t)
    return;
  let { type: e } = t;
  if (Wv.has(e))
    return e;
}
var Hg = XB, VB = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function YB(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (Hg(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = VB([...Wv].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`;
}
var UB = class extends Error {
  constructor(r) {
    super(YB(r));
    wn(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, qv = UB, zB = () => {
}, GB = zB;
function Qi(t) {
  return { type: Op, contents: t };
}
function Xv(t, e) {
  return { type: xp, contents: e, n: t };
}
function lr(t, e = {}) {
  return GB(e.expandedStates), { type: Ml, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function HB(t) {
  return Xv(Number.NEGATIVE_INFINITY, t);
}
function JB(t) {
  return Xv({ type: "root" }, t);
}
function Vv(t) {
  return { type: bp, parts: t };
}
function mh(t, e = "", r = {}) {
  return { type: Dp, breakContents: t, flatContents: e, groupId: r.groupId };
}
function KB(t, e) {
  return { type: vp, contents: t, groupId: e.groupId, negate: e.negate };
}
var yu = { type: Sp }, eI = { type: pa, hard: !0 }, tI = { type: pa, hard: !0, literal: !0 }, zt = { type: pa }, ar = { type: pa, soft: !0 }, pt = [eI, yu], rI = [tI, yu];
function vo(t, e) {
  let r = [];
  for (let n = 0; n < e.length; n++)
    n !== 0 && r.push(t), r.push(e[n]);
  return r;
}
var nI = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, Ou = nI;
function Jg(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return n(t);
  function n(s) {
    if (r.has(s))
      return r.get(s);
    let a = i(s);
    return r.set(s, a), a;
  }
  function i(s) {
    switch (Hg(s)) {
      case Xg:
        return e(s.map(n));
      case bp:
        return e({ ...s, parts: s.parts.map(n) });
      case Dp:
        return e({ ...s, breakContents: n(s.breakContents), flatContents: n(s.flatContents) });
      case Ml: {
        let { expandedStates: a, contents: o } = s;
        return a ? (a = a.map(n), o = a[0]) : o = n(o), e({ ...s, contents: o, expandedStates: a });
      }
      case xp:
      case Op:
      case vp:
      case Gg:
      case Ug:
        return e({ ...s, contents: n(s.contents) });
      case qg:
      case Vg:
      case Yg:
      case zg:
      case pa:
      case Sp:
        return e(s);
      default:
        throw new qv(s);
    }
  }
}
function iI(t) {
  switch (Hg(t)) {
    case bp:
      if (t.parts.every((e) => e === ""))
        return "";
      break;
    case Ml:
      if (!t.contents && !t.id && !t.break && !t.expandedStates)
        return "";
      if (t.contents.type === Ml && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates)
        return t.contents;
      break;
    case xp:
    case Op:
    case vp:
    case Ug:
      if (!t.contents)
        return "";
      break;
    case Dp:
      if (!t.flatContents && !t.breakContents)
        return "";
      break;
    case Xg: {
      let e = [];
      for (let r of t) {
        if (!r)
          continue;
        let [n, ...i] = Array.isArray(r) ? r : [r];
        typeof n == "string" && typeof Ou(!1, e, -1) == "string" ? e[e.length - 1] += n : e.push(n), e.push(...i);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case qg:
    case Vg:
    case Yg:
    case zg:
    case pa:
    case Gg:
    case Sp:
      break;
    default:
      throw new qv(t);
  }
  return t;
}
function sI(t) {
  return Jg(t, (e) => iI(e));
}
function Fn(t, e = rI) {
  return Jg(t, (r) => typeof r == "string" ? vo(e, r.split(`
`)) : r);
}
var sc = "'", GO = '"';
function aI(t, e) {
  let r = e === !0 || e === sc ? sc : GO, n = r === sc ? GO : sc, i = 0, s = 0;
  for (let a of t)
    a === r ? i++ : a === n && s++;
  return i > s ? n : r;
}
var oI = aI;
function lI(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var Cn, uI = class {
  constructor(e) {
    ZB(this, Cn, void 0), WB(this, Cn, new Set(e));
  }
  getLeadingWhitespaceCount(e) {
    let r = Xi(this, Cn), n = 0;
    for (let i = 0; i < e.length && r.has(e.charAt(i)); i++)
      n++;
    return n;
  }
  getTrailingWhitespaceCount(e) {
    let r = Xi(this, Cn), n = 0;
    for (let i = e.length - 1; i >= 0 && r.has(e.charAt(i)); i--)
      n++;
    return n;
  }
  getLeadingWhitespace(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(0, r);
  }
  getTrailingWhitespace(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(e.length - r);
  }
  hasLeadingWhitespace(e) {
    return Xi(this, Cn).has(e.charAt(0));
  }
  hasTrailingWhitespace(e) {
    return Xi(this, Cn).has(Ou(!1, e, -1));
  }
  trimStart(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(r);
  }
  trimEnd(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(0, e.length - r);
  }
  trim(e) {
    return this.trimEnd(this.trimStart(e));
  }
  split(e, r = !1) {
    let n = `[${lI([...Xi(this, Cn)].join(""))}]+`, i = new RegExp(r ? `(${n})` : n);
    return e.split(i);
  }
  hasWhitespaceCharacter(e) {
    let r = Xi(this, Cn);
    return Array.prototype.some.call(e, (n) => r.has(n));
  }
  hasNonWhitespaceCharacter(e) {
    let r = Xi(this, Cn);
    return Array.prototype.some.call(e, (n) => !r.has(n));
  }
  isWhitespaceOnly(e) {
    let r = Xi(this, Cn);
    return Array.prototype.every.call(e, (n) => r.has(n));
  }
};
Cn = /* @__PURE__ */ new WeakMap();
var cI = uI, hI = ["	", `
`, "\f", "\r", " "], pI = new cI(hI), si = pI, dI = class extends Error {
  constructor(r, n, i = "type") {
    super(`Unexpected ${n} node ${i}: ${JSON.stringify(r[i])}.`);
    wn(this, "name", "UnexpectedNodeError");
    this.node = r;
  }
}, fI = dI;
function mI(t) {
  return (t == null ? void 0 : t.type) === "front-matter";
}
var wp = mI, gI = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "keySpan", "tagDefinition", "tokens", "valueTokens", "switchValueSourceSpan", "expSourceSpan", "valueSourceSpan"]), yI = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function Yv(t, e) {
  var r;
  if (t.type === "text" || t.type === "comment" || wp(t) || t.type === "yaml" || t.type === "toml")
    return null;
  if (t.type === "attribute" && delete e.value, t.type === "docType" && delete e.value, t.type === "angularControlFlowBlock" && (r = e.parameters) != null && r.children)
    for (let n of e.parameters.children)
      yI.has(t.name) ? delete n.expression : n.expression = n.expression.trim();
  t.type === "angularIcuExpression" && (e.switchValue = t.switchValue.trim());
}
Yv.ignoredProperties = gI;
var OI = Yv;
async function xI(t, e) {
  if (t.lang === "yaml") {
    let r = t.value.trim(), n = r ? await e(r, { parser: "yaml" }) : "";
    return JB([t.startDelimiter, pt, n, n ? pt : "", t.endDelimiter]);
  }
}
var bI = xI;
function Cp(t, e = !0) {
  return [Qi([ar, t]), e ? ar : ""];
}
function So(t, e) {
  let r = t.type === "NGRoot" ? t.node.type === "NGMicrosyntax" && t.node.body.length === 1 && t.node.body[0].type === "NGMicrosyntaxExpression" ? t.node.body[0].expression : t.node : t.type === "JsExpressionRoot" ? t.node : t;
  return r && (r.type === "ObjectExpression" || r.type === "ArrayExpression" || (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && (r.type === "TemplateLiteral" || r.type === "StringLiteral"));
}
async function ai(t, e, r, n) {
  r = { __isInHtmlAttribute: !0, __embeddedInHtml: !0, ...r };
  let i = !0;
  n && (r.__onHtmlBindingRoot = (a, o) => {
    i = n(a, o);
  });
  let s = await e(t, r, e);
  return i ? lr(s) : Cp(s);
}
function DI(t, e, r, n) {
  let { node: i } = r, s = n.originalText.slice(i.sourceSpan.start.offset, i.sourceSpan.end.offset);
  return /^\s*$/.test(s) ? "" : ai(s, t, { parser: "__ng_directive", __isInHtmlAttribute: !1, trailingComma: "none" }, So);
}
var vI = DI, SI = (t) => String(t).split(/[/\\]/).pop();
function HO(t, e) {
  if (!e)
    return;
  let r = SI(e).toLowerCase();
  return t.find(({ filenames: n }) => n == null ? void 0 : n.some((i) => i.toLowerCase() === r)) ?? t.find(({ extensions: n }) => n == null ? void 0 : n.some((i) => r.endsWith(i)));
}
function wI(t, e) {
  if (e)
    return t.find(({ name: r }) => r.toLowerCase() === e) ?? t.find(({ aliases: r }) => r == null ? void 0 : r.includes(e)) ?? t.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${e}`));
}
function CI(t, e) {
  let r = t.plugins.flatMap((i) => i.languages ?? []), n = wI(r, e.language) ?? HO(r, e.physicalFile) ?? HO(r, e.file) ?? (e.physicalFile, void 0);
  return n == null ? void 0 : n.parsers[0];
}
var Ep = CI, EI = "inline", AI = { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", style: "none", template: "inline", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", dialog: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", search: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", menu: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", input: "inline-block", button: "inline-block", fieldset: "block", marquee: "inline-block", source: "block", track: "block", details: "block", summary: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, TI = "normal", kI = { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" };
function PI(t) {
  return t.type === "element" && !t.hasExplicitNamespace && !["html", "svg"].includes(t.namespace);
}
var Ll = PI, FI = (t) => Gr(!1, t, /^[\t\f\r ]*\n/g, ""), Uv = (t) => FI(si.trimEnd(t)), $I = (t) => {
  let e = t, r = si.getLeadingWhitespace(e);
  r && (e = e.slice(r.length));
  let n = si.getTrailingWhitespace(e);
  return n && (e = e.slice(0, -n.length)), { leadingWhitespace: r, trailingWhitespace: n, text: e };
};
function zv(t, e) {
  return !!(t.type === "ieConditionalComment" && t.lastChild && !t.lastChild.isSelfClosing && !t.lastChild.endSourceSpan || t.type === "ieConditionalComment" && !t.complete || ao(t) && t.children.some((r) => r.type !== "text" && r.type !== "interpolation") || ey(t, e) && !Si(t) && t.type !== "interpolation");
}
function Ap(t) {
  return t.type === "attribute" || !t.parent || !t.prev ? !1 : BI(t.prev);
}
function BI(t) {
  return t.type === "comment" && t.value.trim() === "prettier-ignore";
}
function an(t) {
  return t.type === "text" || t.type === "comment";
}
function Si(t) {
  return t.type === "element" && (t.fullName === "script" || t.fullName === "style" || t.fullName === "svg:style" || t.fullName === "svg:script" || Ll(t) && (t.name === "script" || t.name === "style"));
}
function II(t) {
  return t.children && !Si(t);
}
function NI(t) {
  return Si(t) || t.type === "interpolation" || Gv(t);
}
function Gv(t) {
  return n2(t).startsWith("pre");
}
function _I(t, e) {
  var r, n;
  let i = s();
  if (i && !t.prev && (n = (r = t.parent) == null ? void 0 : r.tagDefinition) != null && n.ignoreFirstLf)
    return t.type === "interpolation";
  return i;
  function s() {
    return wp(t) || t.type === "angularControlFlowBlock" ? !1 : (t.type === "text" || t.type === "interpolation") && t.prev && (t.prev.type === "text" || t.prev.type === "interpolation") ? !0 : !t.parent || t.parent.cssDisplay === "none" ? !1 : ao(t.parent) ? !0 : !(!t.prev && (t.parent.type === "root" || ao(t) && t.parent || Si(t.parent) || Tp(t.parent, e) || !XI(t.parent.cssDisplay)) || t.prev && !UI(t.prev.cssDisplay));
  }
}
function QI(t, e) {
  return wp(t) || t.type === "angularControlFlowBlock" ? !1 : (t.type === "text" || t.type === "interpolation") && t.next && (t.next.type === "text" || t.next.type === "interpolation") ? !0 : !t.parent || t.parent.cssDisplay === "none" ? !1 : ao(t.parent) ? !0 : !(!t.next && (t.parent.type === "root" || ao(t) && t.parent || Si(t.parent) || Tp(t.parent, e) || !VI(t.parent.cssDisplay)) || t.next && !YI(t.next.cssDisplay));
}
function MI(t) {
  return zI(t.cssDisplay) && !Si(t);
}
function ac(t) {
  return wp(t) || t.next && t.sourceSpan.end && t.sourceSpan.end.line + 1 < t.next.sourceSpan.start.line;
}
function LI(t) {
  return Hv(t) || t.type === "element" && t.children.length > 0 && (["body", "script", "style"].includes(t.name) || t.children.some((e) => jI(e))) || t.firstChild && t.firstChild === t.lastChild && t.firstChild.type !== "text" && Kv(t.firstChild) && (!t.lastChild.isTrailingSpaceSensitive || e2(t.lastChild));
}
function Hv(t) {
  return t.type === "element" && t.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(t.name) || t.cssDisplay.startsWith("table") && t.cssDisplay !== "table-cell");
}
function Fd(t) {
  return t2(t) || t.prev && RI(t.prev) || Jv(t);
}
function RI(t) {
  return t2(t) || t.type === "element" && t.fullName === "br" || Jv(t);
}
function Jv(t) {
  return Kv(t) && e2(t);
}
function Kv(t) {
  return t.hasLeadingSpaces && (t.prev ? t.prev.sourceSpan.end.line < t.sourceSpan.start.line : t.parent.type === "root" || t.parent.startSourceSpan.end.line < t.sourceSpan.start.line);
}
function e2(t) {
  return t.hasTrailingSpaces && (t.next ? t.next.sourceSpan.start.line > t.sourceSpan.end.line : t.parent.type === "root" || t.parent.endSourceSpan && t.parent.endSourceSpan.start.line > t.sourceSpan.end.line);
}
function t2(t) {
  switch (t.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return !0;
    case "element":
      return ["script", "select"].includes(t.name);
  }
  return !1;
}
function Kg(t) {
  return t.lastChild ? Kg(t.lastChild) : t;
}
function jI(t) {
  var e;
  return (e = t.children) == null ? void 0 : e.some((r) => r.type !== "text");
}
function r2(t) {
  if (t)
    switch (t) {
      case "module":
      case "text/javascript":
      case "text/babel":
      case "application/javascript":
        return "babel";
      case "application/x-typescript":
        return "typescript";
      case "text/markdown":
        return "markdown";
      case "text/html":
        return "html";
      case "text/x-handlebars-template":
        return "glimmer";
      default:
        if (t.endsWith("json") || t.endsWith("importmap") || t === "speculationrules")
          return "json";
    }
}
function ZI(t, e) {
  let { name: r, attrMap: n } = t;
  if (r !== "script" || Object.prototype.hasOwnProperty.call(n, "src"))
    return;
  let { type: i, lang: s } = t.attrMap;
  return !s && !i ? "babel" : Ep(e, { language: s }) ?? r2(i);
}
function WI(t, e) {
  if (!ey(t, e))
    return;
  let { attrMap: r } = t;
  if (Object.prototype.hasOwnProperty.call(r, "src"))
    return;
  let { type: n, lang: i } = r;
  return Ep(e, { language: i }) ?? r2(n);
}
function qI(t, e) {
  if (t.name !== "style")
    return;
  let { lang: r } = t.attrMap;
  return r ? Ep(e, { language: r }) : "css";
}
function JO(t, e) {
  return ZI(t, e) ?? qI(t, e) ?? WI(t, e);
}
function xu(t) {
  return t === "block" || t === "list-item" || t.startsWith("table");
}
function XI(t) {
  return !xu(t) && t !== "inline-block";
}
function VI(t) {
  return !xu(t) && t !== "inline-block";
}
function YI(t) {
  return !xu(t);
}
function UI(t) {
  return !xu(t);
}
function zI(t) {
  return !xu(t) && t !== "inline-block";
}
function ao(t) {
  return n2(t).startsWith("pre");
}
function GI(t, e) {
  let r = t;
  for (; r; ) {
    if (e(r))
      return !0;
    r = r.parent;
  }
  return !1;
}
function HI(t, e) {
  var r;
  if (wo(t, e))
    return "block";
  if (((r = t.prev) == null ? void 0 : r.type) === "comment") {
    let i = t.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
    if (i)
      return i[1];
  }
  let n = !1;
  if (t.type === "element" && t.namespace === "svg")
    if (GI(t, (i) => i.fullName === "svg:foreignObject"))
      n = !0;
    else
      return t.name === "svg" ? "inline-block" : "block";
  switch (e.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      return t.type === "element" && (!t.namespace || n || Ll(t)) && AI[t.name] || EI;
  }
}
function n2(t) {
  return t.type === "element" && (!t.namespace || Ll(t)) && kI[t.name] || TI;
}
function JI(t) {
  let e = Number.POSITIVE_INFINITY;
  for (let r of t.split(`
`)) {
    if (r.length === 0)
      continue;
    let n = si.getLeadingWhitespaceCount(r);
    if (n === 0)
      return 0;
    r.length !== n && n < e && (e = n);
  }
  return e === Number.POSITIVE_INFINITY ? 0 : e;
}
function i2(t, e = JI(t)) {
  return e === 0 ? t : t.split(`
`).map((r) => r.slice(e)).join(`
`);
}
function s2(t) {
  return Gr(!1, Gr(!1, t, "&apos;", "'"), "&quot;", '"');
}
function ws(t) {
  return s2(t.value);
}
var KI = /* @__PURE__ */ new Set(["template", "style", "script"]);
function Tp(t, e) {
  return wo(t, e) && !KI.has(t.fullName);
}
function wo(t, e) {
  return e.parser === "vue" && t.type === "element" && t.parent.type === "root" && t.fullName.toLowerCase() !== "html";
}
function ey(t, e) {
  return wo(t, e) && (Tp(t, e) || t.attrMap.lang && t.attrMap.lang !== "html");
}
function e8(t) {
  let e = t.fullName;
  return e.charAt(0) === "#" || e === "slot-scope" || e === "v-slot" || e.startsWith("v-slot:");
}
function t8(t, e) {
  let r = t.parent;
  if (!wo(r, e))
    return !1;
  let n = r.fullName, i = t.fullName;
  return n === "script" && i === "setup" || n === "style" && i === "vars";
}
function a2(t, e = t.value) {
  return t.parent.isWhitespaceSensitive ? t.parent.isIndentationSensitive ? Fn(e) : Fn(i2(Uv(e)), pt) : vo(zt, si.split(e));
}
function o2(t, e) {
  return wo(t, e) && t.name === "script";
}
var l2 = /{{(.+?)}}/s;
async function r8(t, e) {
  let r = [];
  for (let [n, i] of t.split(l2).entries())
    if (n % 2 === 0)
      r.push(Fn(i));
    else
      try {
        r.push(lr(["{{", Qi([zt, await ai(i, e, { parser: "__ng_interpolation", __isInHtmlInterpolation: !0, trailingComma: "none" })]), zt, "}}"]));
      } catch {
        r.push("{{", Fn(i), "}}");
      }
  return r;
}
function ty({ parser: t }) {
  return (e, r, n) => ai(ws(n.node), e, { parser: t, trailingComma: "none" }, So);
}
var n8 = ty({ parser: "__ng_action" }), i8 = ty({ parser: "__ng_binding" }), s8 = ty({ parser: "__ng_directive" });
function a8(t, e) {
  if (e.parser !== "angular")
    return;
  let { node: r } = t, n = r.fullName;
  if (n.startsWith("(") && n.endsWith(")") || n.startsWith("on-"))
    return n8;
  if (n.startsWith("[") && n.endsWith("]") || /^bind(?:on)?-/.test(n) || /^ng-(?:if|show|hide|class|style)$/.test(n))
    return i8;
  if (n.startsWith("*"))
    return s8;
  let i = ws(r);
  if (/^i18n(?:-.+)?$/.test(n))
    return () => Cp(Vv(a2(r, i.trim())), !i.includes("@@"));
  if (l2.test(i))
    return (s) => r8(i, s);
}
var o8 = a8;
function l8(t, e) {
  let { node: r } = t, n = ws(r);
  if (r.fullName === "class" && !e.parentParser && !n.includes("{{"))
    return () => n.trim().split(/\s+/).join(" ");
}
var u8 = l8;
function KO(t) {
  return t === "	" || t === `
` || t === "\f" || t === "\r" || t === " ";
}
var c8 = /^[ \t\n\r\u000c]+/, h8 = /^[, \t\n\r\u000c]+/, p8 = /^[^ \t\n\r\u000c]+/, d8 = /[,]+$/, e1 = /^\d+$/, f8 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
function m8(t) {
  let e = t.length, r, n, i, s, a, o = 0, u;
  function c(g) {
    let O, b = g.exec(t.substring(o));
    if (b)
      return [O] = b, o += O.length, O;
  }
  let h = [];
  for (; ; ) {
    if (c(h8), o >= e) {
      if (h.length === 0)
        throw new Error("Must contain one or more image candidate strings.");
      return h;
    }
    u = o, r = c(p8), n = [], r.slice(-1) === "," ? (r = r.replace(d8, ""), m()) : p();
  }
  function p() {
    for (c(c8), i = "", s = "in descriptor"; ; ) {
      if (a = t.charAt(o), s === "in descriptor")
        if (KO(a))
          i && (n.push(i), i = "", s = "after descriptor");
        else if (a === ",") {
          o += 1, i && n.push(i), m();
          return;
        } else if (a === "(")
          i += a, s = "in parens";
        else if (a === "") {
          i && n.push(i), m();
          return;
        } else
          i += a;
      else if (s === "in parens")
        if (a === ")")
          i += a, s = "in descriptor";
        else if (a === "") {
          n.push(i), m();
          return;
        } else
          i += a;
      else if (s === "after descriptor" && !KO(a))
        if (a === "") {
          m();
          return;
        } else
          s = "in descriptor", o -= 1;
      o += 1;
    }
  }
  function m() {
    let g = !1, O, b, D, S, x = {}, w, T, C, A, P;
    for (S = 0; S < n.length; S++)
      w = n[S], T = w[w.length - 1], C = w.substring(0, w.length - 1), A = parseInt(C, 10), P = parseFloat(C), e1.test(C) && T === "w" ? ((O || b) && (g = !0), A === 0 ? g = !0 : O = A) : f8.test(C) && T === "x" ? ((O || b || D) && (g = !0), P < 0 ? g = !0 : b = P) : e1.test(C) && T === "h" ? ((D || b) && (g = !0), A === 0 ? g = !0 : D = A) : g = !0;
    if (!g)
      x.source = { value: r, startOffset: u }, O && (x.width = { value: O }), b && (x.density = { value: b }), D && (x.height = { value: D }), h.push(x);
    else
      throw new Error(`Invalid srcset descriptor found in "${t}" at "${w}".`);
  }
}
var g8 = m8;
function y8(t) {
  if (t.node.fullName === "srcset" && (t.parent.fullName === "img" || t.parent.fullName === "source"))
    return () => x8(ws(t.node));
}
var u2 = { width: "w", height: "h", density: "x" }, O8 = Object.keys(u2);
function x8(t) {
  let e = g8(t), r = O8.filter((h) => e.some((p) => Object.prototype.hasOwnProperty.call(p, h)));
  if (r.length > 1)
    throw new Error("Mixed descriptor in srcset is not supported");
  let [n] = r, i = u2[n], s = e.map((h) => h.source.value), a = Math.max(...s.map((h) => h.length)), o = e.map((h) => h[n] ? String(h[n].value) : ""), u = o.map((h) => {
    let p = h.indexOf(".");
    return p === -1 ? h.length : p;
  }), c = Math.max(...u);
  return Cp(vo([",", zt], s.map((h, p) => {
    let m = [h], g = o[p];
    if (g) {
      let O = a - h.length + 1, b = c - u[p], D = " ".repeat(O + b);
      m.push(mh(D, " "), g + i);
    }
    return m;
  })));
}
var b8 = y8;
function D8(t, e) {
  let { node: r } = t, n = ws(t.node).trim();
  if (r.fullName === "style" && !e.parentParser && !n.includes("{{"))
    return async (i) => Cp(await i(n, { parser: "css", __isHTMLStyleAttribute: !0 }));
}
var $d = /* @__PURE__ */ new WeakMap();
function v8(t, e) {
  let { root: r } = t;
  return $d.has(r) || $d.set(r, r.children.some((n) => o2(n, e) && ["ts", "typescript"].includes(n.attrMap.lang))), $d.get(r);
}
var ry = v8;
function S8(t, e, r) {
  let { node: n } = r, i = ws(n);
  return ai(`type T<${i}> = any`, t, { parser: "babel-ts", __isEmbeddedTypescriptGenericParameters: !0 }, So);
}
function w8(t, e, { parseWithTs: r }) {
  return ai(`function _(${t}) {}`, e, { parser: r ? "babel-ts" : "babel", __isVueBindings: !0 });
}
function C8(t) {
  let e = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, r = /^[$_a-z][\w$]*(?:\.[$_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$_a-z][\w$]*])*$/i, n = t.trim();
  return e.test(n) || r.test(n);
}
async function E8(t, e, r, n) {
  let i = ws(r.node), { left: s, operator: a, right: o } = A8(i), u = ry(r, n);
  return [lr(await ai(`function _(${s}) {}`, t, { parser: u ? "babel-ts" : "babel", __isVueForBindingLeft: !0 })), " ", a, " ", await ai(o, t, { parser: u ? "__ts_expression" : "__js_expression" })];
}
function A8(t) {
  let e = /(.*?)\s+(in|of)\s+(.*)/s, r = /,([^,\]}]*)(?:,([^,\]}]*))?$/, n = /^\(|\)$/g, i = t.match(e);
  if (!i)
    return;
  let s = {};
  if (s.for = i[3].trim(), !s.for)
    return;
  let a = Gr(!1, i[1].trim(), n, ""), o = a.match(r);
  o ? (s.alias = a.replace(r, ""), s.iterator1 = o[1].trim(), o[2] && (s.iterator2 = o[2].trim())) : s.alias = a;
  let u = [s.alias, s.iterator1, s.iterator2];
  if (!u.some((c, h) => !c && (h === 0 || u.slice(h + 1).some(Boolean))))
    return { left: u.filter(Boolean).join(","), operator: i[2], right: s.for };
}
function T8(t, e) {
  if (e.parser !== "vue")
    return;
  let { node: r } = t, n = r.fullName;
  if (n === "v-for")
    return E8;
  if (n === "generic" && o2(r.parent, e))
    return S8;
  let i = ws(r), s = ry(t, e);
  if (e8(r) || t8(r, e))
    return (a) => w8(i, a, { parseWithTs: s });
  if (n.startsWith("@") || n.startsWith("v-on:"))
    return (a) => k8(i, a, { parseWithTs: s });
  if (n.startsWith(":") || n.startsWith("v-bind:"))
    return (a) => P8(i, a, { parseWithTs: s });
  if (n.startsWith("v-"))
    return (a) => c2(i, a, { parseWithTs: s });
}
function k8(t, e, { parseWithTs: r }) {
  return C8(t) ? c2(t, e, { parseWithTs: r }) : ai(t, e, { parser: r ? "__vue_ts_event_binding" : "__vue_event_binding" }, So);
}
function P8(t, e, { parseWithTs: r }) {
  return ai(t, e, { parser: r ? "__vue_ts_expression" : "__vue_expression" }, So);
}
function c2(t, e, { parseWithTs: r }) {
  return ai(t, e, { parser: r ? "__ts_expression" : "__js_expression" }, So);
}
var F8 = T8;
function $8(t, e) {
  let { node: r } = t;
  if (r.value) {
    if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(e.originalText.slice(r.valueSpan.start.offset, r.valueSpan.end.offset)) || e.parser === "lwc" && r.value.startsWith("{") && r.value.endsWith("}"))
      return [r.rawName, "=", r.value];
    for (let n of [b8, D8, u8, F8, o8]) {
      let i = n(t, e);
      if (i)
        return B8(i);
    }
  }
}
function B8(t) {
  return async (e, r, n, i) => {
    let s = await t(e, r, n, i);
    if (s)
      return s = Jg(s, (a) => typeof a == "string" ? Gr(!1, a, '"', "&quot;") : a), [n.node.rawName, '="', lr(s), '"'];
  };
}
var I8 = $8, h2 = new Proxy(() => {
}, { get: () => h2 }), p2 = h2;
function N8(t) {
  return Array.isArray(t) && t.length > 0;
}
var ny = N8;
function kp(t) {
  return t.sourceSpan.start.offset;
}
function Pp(t) {
  return t.sourceSpan.end.offset;
}
function zf(t, e) {
  return [t.isSelfClosing ? "" : _8(t, e), Dl(t, e)];
}
function _8(t, e) {
  return t.lastChild && Rl(t.lastChild) ? "" : [Q8(t, e), iy(t, e)];
}
function Dl(t, e) {
  return (t.next ? Gs(t.next) : Du(t.parent)) ? "" : [bu(t, e), zs(t, e)];
}
function Q8(t, e) {
  return Du(t) ? bu(t.lastChild, e) : "";
}
function zs(t, e) {
  return Rl(t) ? iy(t.parent, e) : Fp(t) ? sy(t.next) : "";
}
function iy(t, e) {
  if (p2(!t.isSelfClosing), d2(t, e))
    return "";
  switch (t.type) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (t.hasHtmComponentClosingTag)
        return "<//";
    default:
      return `</${t.rawName}`;
  }
}
function bu(t, e) {
  if (d2(t, e))
    return "";
  switch (t.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "angularIcuExpression":
      return "}";
    case "element":
      if (t.isSelfClosing)
        return "/>";
    default:
      return ">";
  }
}
function d2(t, e) {
  return !t.isSelfClosing && !t.endSourceSpan && (Ap(t) || zv(t.parent, e));
}
function Gs(t) {
  return t.prev && t.prev.type !== "docType" && t.type !== "angularControlFlowBlock" && !an(t.prev) && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
}
function Du(t) {
  var e;
  return ((e = t.lastChild) == null ? void 0 : e.isTrailingSpaceSensitive) && !t.lastChild.hasTrailingSpaces && !an(Kg(t.lastChild)) && !ao(t);
}
function Rl(t) {
  return !t.next && !t.hasTrailingSpaces && t.isTrailingSpaceSensitive && an(Kg(t));
}
function Fp(t) {
  return t.next && !an(t.next) && an(t) && t.isTrailingSpaceSensitive && !t.hasTrailingSpaces;
}
function M8(t) {
  let e = t.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
  return e ? e[1] ? e[1].split(/\s+/) : !0 : !1;
}
function $p(t) {
  return !t.prev && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
}
function L8(t, e, r) {
  var n;
  let { node: i } = t;
  if (!ny(i.attrs))
    return i.isSelfClosing ? " " : "";
  let s = ((n = i.prev) == null ? void 0 : n.type) === "comment" && M8(i.prev.value), a = typeof s == "boolean" ? () => s : Array.isArray(s) ? (p) => s.includes(p.rawName) : () => !1, o = t.map(({ node: p }) => a(p) ? Fn(e.originalText.slice(kp(p), Pp(p))) : r(), "attrs"), u = i.type === "element" && i.fullName === "script" && i.attrs.length === 1 && i.attrs[0].fullName === "src" && i.children.length === 0, c = e.singleAttributePerLine && i.attrs.length > 1 && !wo(i, e) ? pt : zt, h = [Qi([u ? " " : zt, vo(c, o)])];
  return i.firstChild && $p(i.firstChild) || i.isSelfClosing && Du(i.parent) || u ? h.push(i.isSelfClosing ? " " : "") : h.push(e.bracketSameLine ? i.isSelfClosing ? " " : "" : i.isSelfClosing ? zt : ar), h;
}
function R8(t) {
  return t.firstChild && $p(t.firstChild) ? "" : ay(t);
}
function Gf(t, e, r) {
  let { node: n } = t;
  return [vl(n, e), L8(t, e, r), n.isSelfClosing ? "" : R8(n)];
}
function vl(t, e) {
  return t.prev && Fp(t.prev) ? "" : [Hs(t, e), sy(t)];
}
function Hs(t, e) {
  return $p(t) ? ay(t.parent) : Gs(t) ? bu(t.prev, e) : "";
}
function sy(t) {
  switch (t.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${t.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType":
      return t.value === "html" ? "<!doctype" : "<!DOCTYPE";
    case "angularIcuExpression":
      return "{";
    case "element":
      if (t.condition)
        return `<!--[if ${t.condition}]><!--><${t.rawName}`;
    default:
      return `<${t.rawName}`;
  }
}
function ay(t) {
  switch (p2(!t.isSelfClosing), t.type) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (t.condition)
        return "><!--<![endif]-->";
    default:
      return ">";
  }
}
function j8(t, e) {
  if (!t.endSourceSpan)
    return "";
  let r = t.startSourceSpan.end.offset;
  t.firstChild && $p(t.firstChild) && (r -= ay(t).length);
  let n = t.endSourceSpan.start.offset;
  return t.lastChild && Rl(t.lastChild) ? n += iy(t, e).length : Du(t) && (n -= bu(t.lastChild, e).length), e.originalText.slice(r, n);
}
var f2 = j8, Z8 = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
function W8(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "element":
      if (Si(r) || r.type === "interpolation")
        return;
      if (!r.isSelfClosing && ey(r, e)) {
        let n = JO(r, e);
        return n ? async (i, s) => {
          let a = f2(r, e), o = /^\s*$/.test(a), u = "";
          return o || (u = await i(Uv(a), { parser: n, __embeddedInHtml: !0 }), o = u === ""), [Hs(r, e), lr(Gf(t, e, s)), o ? "" : pt, u, o ? "" : pt, zf(r, e), zs(r, e)];
        } : void 0;
      }
      break;
    case "text":
      if (Si(r.parent)) {
        let n = JO(r.parent, e);
        if (n)
          return async (i) => {
            let s = n === "markdown" ? i2(r.value.replace(/^[^\S\n]*\n/, "")) : r.value, a = { parser: n, __embeddedInHtml: !0 };
            if (e.parser === "html" && n === "babel") {
              let o = "script", { attrMap: u } = r.parent;
              u && (u.type === "module" || u.type === "text/babel" && u["data-type"] === "module") && (o = "module"), a.__babelSourceType = o;
            }
            return [yu, Hs(r, e), await i(s, a), zs(r, e)];
          };
      } else if (r.parent.type === "interpolation")
        return async (n) => {
          let i = { __isInHtmlInterpolation: !0, __embeddedInHtml: !0 };
          return e.parser === "angular" ? (i.parser = "__ng_interpolation", i.trailingComma = "none") : e.parser === "vue" ? i.parser = ry(t, e) ? "__vue_ts_expression" : "__vue_expression" : i.parser = "__js_expression", [Qi([zt, await n(r.value, i)]), r.parent.next && Gs(r.parent.next) ? " " : zt];
        };
      break;
    case "attribute":
      return I8(t, e);
    case "front-matter":
      return (n) => bI(r, n);
    case "angularControlFlowBlockParameters":
      return Z8.has(t.parent.name) ? vI : void 0;
  }
}
var q8 = W8, Yo = null;
function Sl(t) {
  if (Yo !== null && typeof Yo.property) {
    let e = Yo;
    return Yo = Sl.prototype = null, e;
  }
  return Yo = Sl.prototype = t ?? /* @__PURE__ */ Object.create(null), new Sl();
}
var X8 = 10;
for (let t = 0; t <= X8; t++)
  Sl();
function V8(t) {
  return Sl(t);
}
function Y8(t, e = "type") {
  V8(t);
  function r(n) {
    let i = n[e], s = t[i];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: n });
    return s;
  }
  return r;
}
var U8 = Y8, z8 = { "front-matter": [], root: ["children"], element: ["attrs", "children"], ieConditionalComment: ["children"], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ["children"], text: ["children"], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ["children", "parameters"], angularControlFlowBlockParameters: ["children"], angularControlFlowBlockParameter: [], angularIcuExpression: ["cases"], angularIcuCase: ["expression"] }, G8 = z8, H8 = U8(G8), J8 = H8;
function K8(t) {
  return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(t);
}
function eN(t) {
  return `<!-- @format -->

` + t;
}
var tN = /* @__PURE__ */ new Map([["if", /* @__PURE__ */ new Set(["else if", "else"])], ["else if", /* @__PURE__ */ new Set(["else if", "else"])], ["for", /* @__PURE__ */ new Set(["empty"])], ["defer", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["placeholder", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["error", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["loading", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])]]);
function m2(t) {
  let e = Pp(t);
  return t.type === "element" && !t.endSourceSpan && ny(t.children) ? Math.max(e, m2(Ou(!1, t.children, -1))) : e;
}
function Uo(t, e, r) {
  let n = t.node;
  if (Ap(n)) {
    let i = m2(n);
    return [Hs(n, e), Fn(si.trimEnd(e.originalText.slice(kp(n) + (n.prev && Fp(n.prev) ? sy(n).length : 0), i - (n.next && Gs(n.next) ? bu(n, e).length : 0)))), zs(n, e)];
  }
  return r();
}
function oc(t, e) {
  return an(t) && an(e) ? t.isTrailingSpaceSensitive ? t.hasTrailingSpaces ? Fd(e) ? pt : zt : "" : Fd(e) ? pt : ar : Fp(t) && (Ap(e) || e.firstChild || e.isSelfClosing || e.type === "element" && e.attrs.length > 0) || t.type === "element" && t.isSelfClosing && Gs(e) ? "" : !e.isLeadingSpaceSensitive || Fd(e) || Gs(e) && t.lastChild && Rl(t.lastChild) && t.lastChild.lastChild && Rl(t.lastChild.lastChild) ? pt : e.hasLeadingSpaces ? zt : ar;
}
function oy(t, e, r) {
  let { node: n } = t;
  if (Hv(n))
    return [yu, ...t.map((s) => {
      let a = s.node, o = a.prev ? oc(a.prev, a) : "";
      return [o ? [o, ac(a.prev) ? pt : ""] : "", Uo(s, e, r)];
    }, "children")];
  let i = n.children.map(() => Symbol(""));
  return t.map((s, a) => {
    let o = s.node;
    if (an(o)) {
      if (o.prev && an(o.prev)) {
        let O = oc(o.prev, o);
        if (O)
          return ac(o.prev) ? [pt, pt, Uo(s, e, r)] : [O, Uo(s, e, r)];
      }
      return Uo(s, e, r);
    }
    let u = [], c = [], h = [], p = [], m = o.prev ? oc(o.prev, o) : "", g = o.next ? oc(o, o.next) : "";
    return m && (ac(o.prev) ? u.push(pt, pt) : m === pt ? u.push(pt) : an(o.prev) ? c.push(m) : c.push(mh("", ar, { groupId: i[a - 1] }))), g && (ac(o) ? an(o.next) && p.push(pt, pt) : g === pt ? an(o.next) && p.push(pt) : h.push(g)), [...u, lr([...c, lr([Uo(s, e, r), ...h], { id: i[a] })]), ...p];
  }, "children");
}
function rN(t, e, r) {
  let { node: n } = t, i = [];
  nN(t) && i.push("} "), i.push("@", n.name), n.parameters && i.push(" (", lr(r("parameters")), ")"), i.push(" {");
  let s = g2(n);
  return n.children.length > 0 ? (n.firstChild.hasLeadingSpaces = !0, n.lastChild.hasTrailingSpaces = !0, i.push(Qi([pt, oy(t, e, r)])), s && i.push(pt, "}")) : s && i.push("}"), lr(i, { shouldBreak: !0 });
}
function g2(t) {
  var e, r;
  return !(((e = t.next) == null ? void 0 : e.type) === "angularControlFlowBlock" && (r = tN.get(t.name)) != null && r.has(t.next.name));
}
function nN(t) {
  let { previous: e } = t;
  return (e == null ? void 0 : e.type) === "angularControlFlowBlock" && !Ap(e) && !g2(e);
}
function iN(t, e, r) {
  return [Qi([ar, vo([";", zt], t.map(r, "children"))]), ar];
}
function sN(t, e, r) {
  let { node: n } = t;
  return [vl(n, e), lr([n.switchValue.trim(), ", ", n.clause, n.cases.length > 0 ? [",", Qi([zt, vo(zt, t.map(r, "cases"))])] : "", ar]), Dl(n, e)];
}
function aN(t, e, r) {
  let { node: n } = t;
  return [n.value, " {", lr([Qi([ar, t.map(({ node: i }) => i.type === "text" && !si.trim(i.value) ? "" : r(), "expression")]), ar]), "}"];
}
function oN(t, e, r) {
  let { node: n } = t;
  if (zv(n, e))
    return [Hs(n, e), lr(Gf(t, e, r)), Fn(f2(n, e)), ...zf(n, e), zs(n, e)];
  let i = n.children.length === 1 && (n.firstChild.type === "interpolation" || n.firstChild.type === "angularIcuExpression") && n.firstChild.isLeadingSpaceSensitive && !n.firstChild.hasLeadingSpaces && n.lastChild.isTrailingSpaceSensitive && !n.lastChild.hasTrailingSpaces, s = Symbol("element-attr-group-id"), a = (h) => lr([lr(Gf(t, e, r), { id: s }), h, zf(n, e)]), o = (h) => i ? KB(h, { groupId: s }) : (Si(n) || Tp(n, e)) && n.parent.type === "root" && e.parser === "vue" && !e.vueIndentScriptAndStyle ? h : Qi(h), u = () => i ? mh(ar, "", { groupId: s }) : n.firstChild.hasLeadingSpaces && n.firstChild.isLeadingSpaceSensitive ? zt : n.firstChild.type === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive ? HB(ar) : ar, c = () => (n.next ? Gs(n.next) : Du(n.parent)) ? n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? " " : "" : i ? mh(ar, "", { groupId: s }) : n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? zt : (n.lastChild.type === "comment" || n.lastChild.type === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${e.tabWidth * (t.ancestors.length - 1)}}$`).test(n.lastChild.value) ? "" : ar;
  return n.children.length === 0 ? a(n.hasDanglingSpaces && n.isDanglingSpaceSensitive ? zt : "") : a([LI(n) ? yu : "", o([u(), oy(t, e, r)]), c()]);
}
function ly(t) {
  return t >= 9 && t <= 32 || t == 160;
}
function y2(t) {
  return 48 <= t && t <= 57;
}
function uy(t) {
  return t >= 97 && t <= 122 || t >= 65 && t <= 90;
}
function lN(t) {
  return t >= 97 && t <= 102 || t >= 65 && t <= 70 || y2(t);
}
function O2(t) {
  return t === 10 || t === 13;
}
function t1(t) {
  return 48 <= t && t <= 55;
}
function r1(t) {
  return t === 39 || t === 34 || t === 96;
}
var uN = /-+([a-z0-9])/g;
function cN(t) {
  return t.replace(uN, (...e) => e[1].toUpperCase());
}
var Hf = class x2 {
  constructor(e, r, n, i) {
    this.file = e, this.offset = r, this.line = n, this.col = i;
  }
  toString() {
    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
  }
  moveBy(e) {
    let r = this.file.content, n = r.length, i = this.offset, s = this.line, a = this.col;
    for (; i > 0 && e < 0; )
      if (i--, e++, r.charCodeAt(i) == 10) {
        s--;
        let o = r.substring(0, i - 1).lastIndexOf(`
`);
        a = o > 0 ? i - o : i;
      } else
        a--;
    for (; i < n && e > 0; ) {
      let o = r.charCodeAt(i);
      i++, e--, o == 10 ? (s++, a = 0) : a++;
    }
    return new x2(this.file, i, s, a);
  }
  getContext(e, r) {
    let n = this.file.content, i = this.offset;
    if (i != null) {
      i > n.length - 1 && (i = n.length - 1);
      let s = i, a = 0, o = 0;
      for (; a < e && i > 0 && (i--, a++, !(n[i] == `
` && ++o == r)); )
        ;
      for (a = 0, o = 0; a < e && s < n.length - 1 && (s++, a++, !(n[s] == `
` && ++o == r)); )
        ;
      return { before: n.substring(i, this.offset), after: n.substring(this.offset, s + 1) };
    }
    return null;
  }
}, b2 = class {
  constructor(e, r) {
    this.content = e, this.url = r;
  }
}, je = class {
  constructor(t, e, r = t, n = null) {
    this.start = t, this.end = e, this.fullStart = r, this.details = n;
  }
  toString() {
    return this.start.file.content.substring(this.start.offset, this.end.offset);
  }
}, gh;
(function(t) {
  t[t.WARNING = 0] = "WARNING", t[t.ERROR = 1] = "ERROR";
})(gh || (gh = {}));
var D2 = class {
  constructor(e, r, n = gh.ERROR) {
    this.span = e, this.msg = r, this.level = n;
  }
  contextualMessage() {
    let e = this.span.start.getContext(100, 3);
    return e ? `${this.msg} ("${e.before}[${gh[this.level]} ->]${e.after}")` : this.msg;
  }
  toString() {
    let e = this.span.details ? `, ${this.span.details}` : "";
    return `${this.contextualMessage()}: ${this.span.start}${e}`;
  }
}, hN = [dN, fN, gN, ON, xN, vN, bN, DN, SN, yN];
function pN(t, e) {
  for (let r of hN)
    r(t, e);
  return t;
}
function dN(t) {
  t.walk((e) => {
    if (e.type === "element" && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && e.children[0].type === "text" && e.children[0].value[0] === `
`) {
      let r = e.children[0];
      r.value.length === 1 ? e.removeChild(r) : r.value = r.value.slice(1);
    }
  });
}
function fN(t) {
  let e = (r) => {
    var n, i;
    return r.type === "element" && ((n = r.prev) == null ? void 0 : n.type) === "ieConditionalStartComment" && r.prev.sourceSpan.end.offset === r.startSourceSpan.start.offset && ((i = r.firstChild) == null ? void 0 : i.type) === "ieConditionalEndComment" && r.firstChild.sourceSpan.start.offset === r.startSourceSpan.end.offset;
  };
  t.walk((r) => {
    if (r.children)
      for (let n = 0; n < r.children.length; n++) {
        let i = r.children[n];
        if (!e(i))
          continue;
        let s = i.prev, a = i.firstChild;
        r.removeChild(s), n--;
        let o = new je(s.sourceSpan.start, a.sourceSpan.end), u = new je(o.start, i.sourceSpan.end);
        i.condition = s.condition, i.sourceSpan = u, i.startSourceSpan = o, i.removeChild(a);
      }
  });
}
function mN(t, e, r) {
  t.walk((n) => {
    if (n.children)
      for (let i = 0; i < n.children.length; i++) {
        let s = n.children[i];
        if (s.type !== "text" && !e(s))
          continue;
        s.type !== "text" && (s.type = "text", s.value = r(s));
        let a = s.prev;
        !a || a.type !== "text" || (a.value += s.value, a.sourceSpan = new je(a.sourceSpan.start, s.sourceSpan.end), n.removeChild(s), i--);
      }
  });
}
function gN(t) {
  return mN(t, (e) => e.type === "cdata", (e) => `<![CDATA[${e.value}]]>`);
}
function yN(t) {
  let e = (r) => {
    var n, i;
    return r.type === "element" && r.attrs.length === 0 && r.children.length === 1 && r.firstChild.type === "text" && !si.hasWhitespaceCharacter(r.children[0].value) && !r.firstChild.hasLeadingSpaces && !r.firstChild.hasTrailingSpaces && r.isLeadingSpaceSensitive && !r.hasLeadingSpaces && r.isTrailingSpaceSensitive && !r.hasTrailingSpaces && ((n = r.prev) == null ? void 0 : n.type) === "text" && ((i = r.next) == null ? void 0 : i.type) === "text";
  };
  t.walk((r) => {
    if (r.children)
      for (let n = 0; n < r.children.length; n++) {
        let i = r.children[n];
        if (!e(i))
          continue;
        let s = i.prev, a = i.next;
        s.value += `<${i.rawName}>` + i.firstChild.value + `</${i.rawName}>` + a.value, s.sourceSpan = new je(s.sourceSpan.start, a.sourceSpan.end), s.isTrailingSpaceSensitive = a.isTrailingSpaceSensitive, s.hasTrailingSpaces = a.hasTrailingSpaces, r.removeChild(i), n--, r.removeChild(a);
      }
  });
}
function ON(t, e) {
  if (e.parser === "html")
    return;
  let r = /{{(.+?)}}/s;
  t.walk((n) => {
    if (II(n))
      for (let i of n.children) {
        if (i.type !== "text")
          continue;
        let s = i.sourceSpan.start, a = null, o = i.value.split(r);
        for (let u = 0; u < o.length; u++, s = a) {
          let c = o[u];
          if (u % 2 === 0) {
            a = s.moveBy(c.length), c.length > 0 && n.insertChildBefore(i, { type: "text", value: c, sourceSpan: new je(s, a) });
            continue;
          }
          a = s.moveBy(c.length + 4), n.insertChildBefore(i, { type: "interpolation", sourceSpan: new je(s, a), children: c.length === 0 ? [] : [{ type: "text", value: c, sourceSpan: new je(s.moveBy(2), a.moveBy(-2)) }] });
        }
        n.removeChild(i);
      }
  });
}
function xN(t) {
  t.walk((e) => {
    if (!e.children)
      return;
    if (e.children.length === 0 || e.children.length === 1 && e.children[0].type === "text" && si.trim(e.children[0].value).length === 0) {
      e.hasDanglingSpaces = e.children.length > 0, e.children = [];
      return;
    }
    let r = NI(e), n = Gv(e);
    if (!r)
      for (let i = 0; i < e.children.length; i++) {
        let s = e.children[i];
        if (s.type !== "text")
          continue;
        let { leadingWhitespace: a, text: o, trailingWhitespace: u } = $I(s.value), c = s.prev, h = s.next;
        o ? (s.value = o, s.sourceSpan = new je(s.sourceSpan.start.moveBy(a.length), s.sourceSpan.end.moveBy(-u.length)), a && (c && (c.hasTrailingSpaces = !0), s.hasLeadingSpaces = !0), u && (s.hasTrailingSpaces = !0, h && (h.hasLeadingSpaces = !0))) : (e.removeChild(s), i--, (a || u) && (c && (c.hasTrailingSpaces = !0), h && (h.hasLeadingSpaces = !0)));
      }
    e.isWhitespaceSensitive = r, e.isIndentationSensitive = n;
  });
}
function bN(t) {
  t.walk((e) => {
    e.isSelfClosing = !e.children || e.type === "element" && (e.tagDefinition.isVoid || e.endSourceSpan && e.startSourceSpan.start === e.endSourceSpan.start && e.startSourceSpan.end === e.endSourceSpan.end);
  });
}
function DN(t, e) {
  t.walk((r) => {
    r.type === "element" && (r.hasHtmComponentClosingTag = r.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(e.originalText.slice(r.endSourceSpan.start.offset, r.endSourceSpan.end.offset)));
  });
}
function vN(t, e) {
  t.walk((r) => {
    r.cssDisplay = HI(r, e);
  });
}
function SN(t, e) {
  t.walk((r) => {
    let { children: n } = r;
    if (n) {
      if (n.length === 0) {
        r.isDanglingSpaceSensitive = MI(r);
        return;
      }
      for (let i of n)
        i.isLeadingSpaceSensitive = _I(i, e), i.isTrailingSpaceSensitive = QI(i, e);
      for (let i = 0; i < n.length; i++) {
        let s = n[i];
        s.isLeadingSpaceSensitive = (i === 0 || s.prev.isTrailingSpaceSensitive) && s.isLeadingSpaceSensitive, s.isTrailingSpaceSensitive = (i === n.length - 1 || s.next.isLeadingSpaceSensitive) && s.isTrailingSpaceSensitive;
      }
    }
  });
}
var wN = pN;
function CN(t, e, r) {
  let { node: n } = t;
  switch (n.type) {
    case "front-matter":
      return Fn(n.raw);
    case "root":
      return e.__onHtmlRoot && e.__onHtmlRoot(n), [lr(oy(t, e, r)), pt];
    case "element":
    case "ieConditionalComment":
      return oN(t, e, r);
    case "angularControlFlowBlock":
      return rN(t, e, r);
    case "angularControlFlowBlockParameters":
      return iN(t, e, r);
    case "angularControlFlowBlockParameter":
      return si.trim(n.expression);
    case "angularIcuExpression":
      return sN(t, e, r);
    case "angularIcuCase":
      return aN(t, e, r);
    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return [vl(n), Dl(n)];
    case "interpolation":
      return [vl(n, e), ...t.map(r, "children"), Dl(n, e)];
    case "text": {
      if (n.parent.type === "interpolation") {
        let s = /\n[^\S\n]*$/, a = s.test(n.value), o = a ? n.value.replace(s, "") : n.value;
        return [Fn(o), a ? pt : ""];
      }
      let i = sI([Hs(n, e), ...a2(n), zs(n, e)]);
      return Array.isArray(i) ? Vv(i) : i;
    }
    case "docType":
      return [lr([vl(n, e), " ", Gr(!1, n.value.replace(/^html\b/i, "html"), /\s+/g, " ")]), Dl(n, e)];
    case "comment":
      return [Hs(n, e), Fn(e.originalText.slice(kp(n), Pp(n))), zs(n, e)];
    case "attribute": {
      if (n.value === null)
        return n.rawName;
      let i = s2(n.value), s = oI(i, '"');
      return [n.rawName, "=", s, Fn(s === '"' ? Gr(!1, i, '"', "&quot;") : Gr(!1, i, "'", "&apos;")), s];
    }
    case "cdata":
    default:
      throw new fI(n, "HTML");
  }
}
var EN = { preprocess: wN, print: CN, insertPragma: eN, massageAstNode: OI, embed: q8, getVisitorKeys: J8 }, AN = EN, TN = [{ linguistLanguageId: 146, name: "Angular", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".component.html"], parsers: ["angular"], vscodeLanguageIds: ["html"], filenames: [] }, { linguistLanguageId: 146, name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml", ".mjml"], parsers: ["html"], vscodeLanguageIds: ["html"] }, { linguistLanguageId: 146, name: "Lightning Web Components", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [], parsers: ["lwc"], vscodeLanguageIds: ["html"], filenames: [] }, { linguistLanguageId: 391, name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", parsers: ["vue"], vscodeLanguageIds: ["vue"] }], n1 = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, i1 = "HTML", kN = { bracketSameLine: n1.bracketSameLine, htmlWhitespaceSensitivity: { category: i1, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: n1.singleAttributePerLine, vueIndentScriptAndStyle: { category: i1, type: "boolean", default: !1, description: "Indent script and style tags in Vue files." } }, PN = kN, v2 = {};
Rv(v2, { angular: () => $5, html: () => F5, lwc: () => I5, vue: () => B5 });
var s1;
(function(t) {
  t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom";
})(s1 || (s1 = {}));
var a1;
(function(t) {
  t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default";
})(a1 || (a1 = {}));
var o1 = { name: "custom-elements" }, l1 = { name: "no-errors-schema" }, js;
(function(t) {
  t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL";
})(js || (js = {}));
var u1;
(function(t) {
  t[t.Error = 0] = "Error", t[t.Warning = 1] = "Warning", t[t.Ignore = 2] = "Ignore";
})(u1 || (u1 = {}));
var Pn;
(function(t) {
  t[t.RAW_TEXT = 0] = "RAW_TEXT", t[t.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", t[t.PARSABLE_DATA = 2] = "PARSABLE_DATA";
})(Pn || (Pn = {}));
function Bp(t) {
  if (t[0] != ":")
    return [null, t];
  let e = t.indexOf(":", 1);
  if (e === -1)
    throw new Error(`Unsupported format "${t}" expecting ":namespace:name"`);
  return [t.slice(1, e), t.slice(e + 1)];
}
function c1(t) {
  return Bp(t)[1] === "ng-container";
}
function h1(t) {
  return Bp(t)[1] === "ng-content";
}
function Yc(t) {
  return t === null ? null : Bp(t)[0];
}
function yh(t, e) {
  return t ? `:${t}:${e}` : e;
}
var Uc;
function p1() {
  return Uc || (Uc = {}, lc(js.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), lc(js.STYLE, ["*|style"]), lc(js.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), lc(js.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), Uc;
}
function lc(t, e) {
  for (let r of e)
    Uc[r.toLowerCase()] = t;
}
var FN = class {
}, $N = "boolean", BN = "number", IN = "string", NN = "object", _N = ["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|"], S2 = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" })), QN = Array.from(S2).reduce((t, [e, r]) => (t.set(e, r), t), /* @__PURE__ */ new Map()), MN = class extends FN {
  constructor() {
    super(), this._schema = /* @__PURE__ */ new Map(), this._eventSchema = /* @__PURE__ */ new Map(), _N.forEach((e) => {
      let r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), [i, s] = e.split("|"), a = s.split(","), [o, u] = i.split("^");
      o.split(",").forEach((h) => {
        this._schema.set(h.toLowerCase(), r), this._eventSchema.set(h.toLowerCase(), n);
      });
      let c = u && this._schema.get(u.toLowerCase());
      if (c) {
        for (let [h, p] of c)
          r.set(h, p);
        for (let h of this._eventSchema.get(u.toLowerCase()))
          n.add(h);
      }
      a.forEach((h) => {
        if (h.length > 0)
          switch (h[0]) {
            case "*":
              n.add(h.substring(1));
              break;
            case "!":
              r.set(h.substring(1), $N);
              break;
            case "#":
              r.set(h.substring(1), BN);
              break;
            case "%":
              r.set(h.substring(1), NN);
              break;
            default:
              r.set(h, IN);
          }
      });
    });
  }
  hasProperty(e, r, n) {
    if (n.some((i) => i.name === l1.name))
      return !0;
    if (e.indexOf("-") > -1) {
      if (c1(e) || h1(e))
        return !1;
      if (n.some((i) => i.name === o1.name))
        return !0;
    }
    return (this._schema.get(e.toLowerCase()) || this._schema.get("unknown")).has(r);
  }
  hasElement(e, r) {
    return r.some((n) => n.name === l1.name) || e.indexOf("-") > -1 && (c1(e) || h1(e) || r.some((n) => n.name === o1.name)) ? !0 : this._schema.has(e.toLowerCase());
  }
  securityContext(e, r, n) {
    n && (r = this.getMappedPropName(r)), e = e.toLowerCase(), r = r.toLowerCase();
    let i = p1()[e + "|" + r];
    return i || (i = p1()["*|" + r], i || js.NONE);
  }
  getMappedPropName(e) {
    return S2.get(e) ?? e;
  }
  getDefaultComponentElementName() {
    return "ng-component";
  }
  validateProperty(e) {
    return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...
If '${e}' is a directive input, make sure the directive is imported by the current module.` } : { error: !1 };
  }
  validateAttribute(e) {
    return e.toLowerCase().startsWith("on") ? { error: !0, msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...` } : { error: !1 };
  }
  allKnownElementNames() {
    return Array.from(this._schema.keys());
  }
  allKnownAttributesOfElement(e) {
    let r = this._schema.get(e.toLowerCase()) || this._schema.get("unknown");
    return Array.from(r.keys()).map((n) => QN.get(n) ?? n);
  }
  allKnownEventsOfElement(e) {
    return Array.from(this._eventSchema.get(e.toLowerCase()) ?? []);
  }
  normalizeAnimationStyleProperty(e) {
    return cN(e);
  }
  normalizeAnimationStyleValue(e, r, n) {
    let i = "", s = n.toString().trim(), a = null;
    if (LN(e) && n !== 0 && n !== "0")
      if (typeof n == "number")
        i = "px";
      else {
        let o = n.match(/^[+-]?[\d\.]+([a-z]*)$/);
        o && o[1].length == 0 && (a = `Please provide a CSS unit value for ${r}:${n}`);
      }
    return { error: a, value: s + i };
  }
};
function LN(t) {
  switch (t) {
    case "width":
    case "height":
    case "minWidth":
    case "minHeight":
    case "maxWidth":
    case "maxHeight":
    case "left":
    case "top":
    case "bottom":
    case "right":
    case "fontSize":
    case "outlineWidth":
    case "outlineOffset":
    case "paddingTop":
    case "paddingLeft":
    case "paddingBottom":
    case "paddingRight":
    case "marginTop":
    case "marginLeft":
    case "marginBottom":
    case "marginRight":
    case "borderRadius":
    case "borderWidth":
    case "borderTopWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderBottomWidth":
    case "textIndent":
      return !0;
    default:
      return !1;
  }
}
var Pe = class {
  constructor({ closedByChildren: t, implicitNamespacePrefix: e, contentType: r = Pn.PARSABLE_DATA, closedByParent: n = !1, isVoid: i = !1, ignoreFirstLf: s = !1, preventNamespaceInheritance: a = !1, canSelfClose: o = !1 } = {}) {
    this.closedByChildren = {}, this.closedByParent = !1, t && t.length > 0 && t.forEach((u) => this.closedByChildren[u] = !0), this.isVoid = i, this.closedByParent = n || i, this.implicitNamespacePrefix = e || null, this.contentType = r, this.ignoreFirstLf = s, this.preventNamespaceInheritance = a, this.canSelfClose = o ?? i;
  }
  isClosedByChild(t) {
    return this.isVoid || t.toLowerCase() in this.closedByChildren;
  }
  getContentType(t) {
    return typeof this.contentType == "object" ? (t === void 0 ? void 0 : this.contentType[t]) ?? this.contentType.default : this.contentType;
  }
}, d1, zo;
function Jf(t) {
  return zo || (d1 = new Pe({ canSelfClose: !0 }), zo = Object.assign(/* @__PURE__ */ Object.create(null), { base: new Pe({ isVoid: !0 }), meta: new Pe({ isVoid: !0 }), area: new Pe({ isVoid: !0 }), embed: new Pe({ isVoid: !0 }), link: new Pe({ isVoid: !0 }), img: new Pe({ isVoid: !0 }), input: new Pe({ isVoid: !0 }), param: new Pe({ isVoid: !0 }), hr: new Pe({ isVoid: !0 }), br: new Pe({ isVoid: !0 }), source: new Pe({ isVoid: !0 }), track: new Pe({ isVoid: !0 }), wbr: new Pe({ isVoid: !0 }), p: new Pe({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: !0 }), thead: new Pe({ closedByChildren: ["tbody", "tfoot"] }), tbody: new Pe({ closedByChildren: ["tbody", "tfoot"], closedByParent: !0 }), tfoot: new Pe({ closedByChildren: ["tbody"], closedByParent: !0 }), tr: new Pe({ closedByChildren: ["tr"], closedByParent: !0 }), td: new Pe({ closedByChildren: ["td", "th"], closedByParent: !0 }), th: new Pe({ closedByChildren: ["td", "th"], closedByParent: !0 }), col: new Pe({ isVoid: !0 }), svg: new Pe({ implicitNamespacePrefix: "svg" }), foreignObject: new Pe({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: !0 }), math: new Pe({ implicitNamespacePrefix: "math" }), li: new Pe({ closedByChildren: ["li"], closedByParent: !0 }), dt: new Pe({ closedByChildren: ["dt", "dd"] }), dd: new Pe({ closedByChildren: ["dt", "dd"], closedByParent: !0 }), rb: new Pe({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rt: new Pe({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), rtc: new Pe({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: !0 }), rp: new Pe({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: !0 }), optgroup: new Pe({ closedByChildren: ["optgroup"], closedByParent: !0 }), option: new Pe({ closedByChildren: ["option", "optgroup"], closedByParent: !0 }), pre: new Pe({ ignoreFirstLf: !0 }), listing: new Pe({ ignoreFirstLf: !0 }), style: new Pe({ contentType: Pn.RAW_TEXT }), script: new Pe({ contentType: Pn.RAW_TEXT }), title: new Pe({ contentType: { default: Pn.ESCAPABLE_RAW_TEXT, svg: Pn.PARSABLE_DATA } }), textarea: new Pe({ contentType: Pn.ESCAPABLE_RAW_TEXT, ignoreFirstLf: !0 }) }), new MN().allKnownElementNames().forEach((e) => {
    !zo[e] && Yc(e) === null && (zo[e] = new Pe({ canSelfClose: !1 }));
  })), zo[t] ?? d1;
}
var vu = class {
  constructor(e, r) {
    this.sourceSpan = e, this.i18n = r;
  }
}, RN = class extends vu {
  constructor(e, r, n, i) {
    super(r, i), this.value = e, this.tokens = n, this.type = "text";
  }
  visit(e, r) {
    return e.visitText(this, r);
  }
}, jN = class extends vu {
  constructor(e, r, n, i) {
    super(r, i), this.value = e, this.tokens = n, this.type = "cdata";
  }
  visit(e, r) {
    return e.visitCdata(this, r);
  }
}, ZN = class extends vu {
  constructor(e, r, n, i, s, a) {
    super(i, a), this.switchValue = e, this.type = r, this.cases = n, this.switchValueSourceSpan = s;
  }
  visit(e, r) {
    return e.visitExpansion(this, r);
  }
}, WN = class {
  constructor(e, r, n, i, s) {
    this.value = e, this.expression = r, this.sourceSpan = n, this.valueSourceSpan = i, this.expSourceSpan = s, this.type = "expansionCase";
  }
  visit(e, r) {
    return e.visitExpansionCase(this, r);
  }
}, qN = class extends vu {
  constructor(e, r, n, i, s, a, o) {
    super(n, o), this.name = e, this.value = r, this.keySpan = i, this.valueSpan = s, this.valueTokens = a, this.type = "attribute";
  }
  visit(e, r) {
    return e.visitAttribute(this, r);
  }
  get nameSpan() {
    return this.keySpan;
  }
}, Vi = class extends vu {
  constructor(e, r, n, i, s, a = null, o = null, u) {
    super(i, u), this.name = e, this.attrs = r, this.children = n, this.startSourceSpan = s, this.endSourceSpan = a, this.nameSpan = o, this.type = "element";
  }
  visit(e, r) {
    return e.visitElement(this, r);
  }
}, XN = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "comment";
  }
  visit(e, r) {
    return e.visitComment(this, r);
  }
}, VN = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "docType";
  }
  visit(e, r) {
    return e.visitDocType(this, r);
  }
}, Ta = class {
  constructor(e, r, n, i, s, a = null) {
    this.name = e, this.parameters = r, this.children = n, this.sourceSpan = i, this.startSourceSpan = s, this.endSourceSpan = a, this.type = "block";
  }
  visit(e, r) {
    return e.visitBlock(this, r);
  }
}, f1 = class {
  constructor(e, r) {
    this.expression = e, this.sourceSpan = r, this.type = "blockParameter", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e, r) {
    return e.visitBlockParameter(this, r);
  }
};
function w2(t, e, r = null) {
  let n = [], i = t.visit ? (s) => t.visit(s, r) || s.visit(t, r) : (s) => s.visit(t, r);
  return e.forEach((s) => {
    let a = i(s);
    a && n.push(a);
  }), n;
}
var YN = class {
  constructor() {
  }
  visitElement(e, r) {
    this.visitChildren(r, (n) => {
      n(e.attrs), n(e.children);
    });
  }
  visitAttribute(e, r) {
  }
  visitText(e, r) {
  }
  visitCdata(e, r) {
  }
  visitComment(e, r) {
  }
  visitDocType(e, r) {
  }
  visitExpansion(e, r) {
    return this.visitChildren(r, (n) => {
      n(e.cases);
    });
  }
  visitExpansionCase(e, r) {
  }
  visitBlock(e, r) {
    this.visitChildren(r, (n) => {
      n(e.parameters), n(e.children);
    });
  }
  visitBlockParameter(e, r) {
  }
  visitChildren(e, r) {
    let n = [], i = this;
    function s(a) {
      a && n.push(w2(i, a, e));
    }
    return r(s), Array.prototype.concat.apply([], n);
  }
}, Oh = { AElig: "", AMP: "&", amp: "&", Aacute: "", Abreve: "", Acirc: "", Acy: "", Afr: "", Agrave: "", Alpha: "", Amacr: "", And: "", Aogon: "", Aopf: "", ApplyFunction: "", af: "", Aring: "", angst: "", Ascr: "", Assign: "", colone: "", coloneq: "", Atilde: "", Auml: "", Backslash: "", setminus: "", setmn: "", smallsetminus: "", ssetmn: "", Barv: "", Barwed: "", doublebarwedge: "", Bcy: "", Because: "", becaus: "", because: "", Bernoullis: "", Bscr: "", bernou: "", Beta: "", Bfr: "", Bopf: "", Breve: "", breve: "", Bumpeq: "", HumpDownHump: "", bump: "", CHcy: "", COPY: "", copy: "", Cacute: "", Cap: "", CapitalDifferentialD: "", DD: "", Cayleys: "", Cfr: "", Ccaron: "", Ccedil: "", Ccirc: "", Cconint: "", Cdot: "", Cedilla: "", cedil: "", CenterDot: "", centerdot: "", middot: "", Chi: "", CircleDot: "", odot: "", CircleMinus: "", ominus: "", CirclePlus: "", oplus: "", CircleTimes: "", otimes: "", ClockwiseContourIntegral: "", cwconint: "", CloseCurlyDoubleQuote: "", rdquo: "", rdquor: "", CloseCurlyQuote: "", rsquo: "", rsquor: "", Colon: "", Proportion: "", Colone: "", Congruent: "", equiv: "", Conint: "", DoubleContourIntegral: "", ContourIntegral: "", conint: "", oint: "", Copf: "", complexes: "", Coproduct: "", coprod: "", CounterClockwiseContourIntegral: "", awconint: "", Cross: "", Cscr: "", Cup: "", CupCap: "", asympeq: "", DDotrahd: "", DJcy: "", DScy: "", DZcy: "", Dagger: "", ddagger: "", Darr: "", Dashv: "", DoubleLeftTee: "", Dcaron: "", Dcy: "", Del: "", nabla: "", Delta: "", Dfr: "", DiacriticalAcute: "", acute: "", DiacriticalDot: "", dot: "", DiacriticalDoubleAcute: "", dblac: "", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "", tilde: "", Diamond: "", diam: "", diamond: "", DifferentialD: "", dd: "", Dopf: "", Dot: "", DoubleDot: "", die: "", uml: "", DotDot: "", DotEqual: "", doteq: "", esdot: "", DoubleDownArrow: "", Downarrow: "", dArr: "", DoubleLeftArrow: "", Leftarrow: "", lArr: "", DoubleLeftRightArrow: "", Leftrightarrow: "", hArr: "", iff: "", DoubleLongLeftArrow: "", Longleftarrow: "", xlArr: "", DoubleLongLeftRightArrow: "", Longleftrightarrow: "", xhArr: "", DoubleLongRightArrow: "", Longrightarrow: "", xrArr: "", DoubleRightArrow: "", Implies: "", Rightarrow: "", rArr: "", DoubleRightTee: "", vDash: "", DoubleUpArrow: "", Uparrow: "", uArr: "", DoubleUpDownArrow: "", Updownarrow: "", vArr: "", DoubleVerticalBar: "", par: "", parallel: "", shortparallel: "", spar: "", DownArrow: "", ShortDownArrow: "", darr: "", downarrow: "", DownArrowBar: "", DownArrowUpArrow: "", duarr: "", DownBreve: "", DownLeftRightVector: "", DownLeftTeeVector: "", DownLeftVector: "", leftharpoondown: "", lhard: "", DownLeftVectorBar: "", DownRightTeeVector: "", DownRightVector: "", rhard: "", rightharpoondown: "", DownRightVectorBar: "", DownTee: "", top: "", DownTeeArrow: "", mapstodown: "", Dscr: "", Dstrok: "", ENG: "", ETH: "", Eacute: "", Ecaron: "", Ecirc: "", Ecy: "", Edot: "", Efr: "", Egrave: "", Element: "", in: "", isin: "", isinv: "", Emacr: "", EmptySmallSquare: "", EmptyVerySmallSquare: "", Eogon: "", Eopf: "", Epsilon: "", Equal: "", EqualTilde: "", eqsim: "", esim: "", Equilibrium: "", rightleftharpoons: "", rlhar: "", Escr: "", expectation: "", Esim: "", Eta: "", Euml: "", Exists: "", exist: "", ExponentialE: "", ee: "", exponentiale: "", Fcy: "", Ffr: "", FilledSmallSquare: "", FilledVerySmallSquare: "", blacksquare: "", squarf: "", squf: "", Fopf: "", ForAll: "", forall: "", Fouriertrf: "", Fscr: "", GJcy: "", GT: ">", gt: ">", Gamma: "", Gammad: "", Gbreve: "", Gcedil: "", Gcirc: "", Gcy: "", Gdot: "", Gfr: "", Gg: "", ggg: "", Gopf: "", GreaterEqual: "", ge: "", geq: "", GreaterEqualLess: "", gel: "", gtreqless: "", GreaterFullEqual: "", gE: "", geqq: "", GreaterGreater: "", GreaterLess: "", gl: "", gtrless: "", GreaterSlantEqual: "", geqslant: "", ges: "", GreaterTilde: "", gsim: "", gtrsim: "", Gscr: "", Gt: "", NestedGreaterGreater: "", gg: "", HARDcy: "", Hacek: "", caron: "", Hat: "^", Hcirc: "", Hfr: "", Poincareplane: "", HilbertSpace: "", Hscr: "", hamilt: "", Hopf: "", quaternions: "", HorizontalLine: "", boxh: "", Hstrok: "", HumpEqual: "", bumpe: "", bumpeq: "", IEcy: "", IJlig: "", IOcy: "", Iacute: "", Icirc: "", Icy: "", Idot: "", Ifr: "", Im: "", image: "", imagpart: "", Igrave: "", Imacr: "", ImaginaryI: "", ii: "", Int: "", Integral: "", int: "", Intersection: "", bigcap: "", xcap: "", InvisibleComma: "", ic: "", InvisibleTimes: "", it: "", Iogon: "", Iopf: "", Iota: "", Iscr: "", imagline: "", Itilde: "", Iukcy: "", Iuml: "", Jcirc: "", Jcy: "", Jfr: "", Jopf: "", Jscr: "", Jsercy: "", Jukcy: "", KHcy: "", KJcy: "", Kappa: "", Kcedil: "", Kcy: "", Kfr: "", Kopf: "", Kscr: "", LJcy: "", LT: "<", lt: "<", Lacute: "", Lambda: "", Lang: "", Laplacetrf: "", Lscr: "", lagran: "", Larr: "", twoheadleftarrow: "", Lcaron: "", Lcedil: "", Lcy: "", LeftAngleBracket: "", lang: "", langle: "", LeftArrow: "", ShortLeftArrow: "", larr: "", leftarrow: "", slarr: "", LeftArrowBar: "", larrb: "", LeftArrowRightArrow: "", leftrightarrows: "", lrarr: "", LeftCeiling: "", lceil: "", LeftDoubleBracket: "", lobrk: "", LeftDownTeeVector: "", LeftDownVector: "", dharl: "", downharpoonleft: "", LeftDownVectorBar: "", LeftFloor: "", lfloor: "", LeftRightArrow: "", harr: "", leftrightarrow: "", LeftRightVector: "", LeftTee: "", dashv: "", LeftTeeArrow: "", mapstoleft: "", LeftTeeVector: "", LeftTriangle: "", vartriangleleft: "", vltri: "", LeftTriangleBar: "", LeftTriangleEqual: "", ltrie: "", trianglelefteq: "", LeftUpDownVector: "", LeftUpTeeVector: "", LeftUpVector: "", uharl: "", upharpoonleft: "", LeftUpVectorBar: "", LeftVector: "", leftharpoonup: "", lharu: "", LeftVectorBar: "", LessEqualGreater: "", leg: "", lesseqgtr: "", LessFullEqual: "", lE: "", leqq: "", LessGreater: "", lessgtr: "", lg: "", LessLess: "", LessSlantEqual: "", leqslant: "", les: "", LessTilde: "", lesssim: "", lsim: "", Lfr: "", Ll: "", Lleftarrow: "", lAarr: "", Lmidot: "", LongLeftArrow: "", longleftarrow: "", xlarr: "", LongLeftRightArrow: "", longleftrightarrow: "", xharr: "", LongRightArrow: "", longrightarrow: "", xrarr: "", Lopf: "", LowerLeftArrow: "", swarr: "", swarrow: "", LowerRightArrow: "", searr: "", searrow: "", Lsh: "", lsh: "", Lstrok: "", Lt: "", NestedLessLess: "", ll: "", Map: "", Mcy: "", MediumSpace: "", Mellintrf: "", Mscr: "", phmmat: "", Mfr: "", MinusPlus: "", mnplus: "", mp: "", Mopf: "", Mu: "", NJcy: "", Nacute: "", Ncaron: "", Ncedil: "", Ncy: "", NegativeMediumSpace: "", NegativeThickSpace: "", NegativeThinSpace: "", NegativeVeryThinSpace: "", ZeroWidthSpace: "", NewLine: `
`, Nfr: "", NoBreak: "", NonBreakingSpace: "", nbsp: "", Nopf: "", naturals: "", Not: "", NotCongruent: "", nequiv: "", NotCupCap: "", NotDoubleVerticalBar: "", npar: "", nparallel: "", nshortparallel: "", nspar: "", NotElement: "", notin: "", notinva: "", NotEqual: "", ne: "", NotEqualTilde: "", nesim: "", NotExists: "", nexist: "", nexists: "", NotGreater: "", ngt: "", ngtr: "", NotGreaterEqual: "", nge: "", ngeq: "", NotGreaterFullEqual: "", ngE: "", ngeqq: "", NotGreaterGreater: "", nGtv: "", NotGreaterLess: "", ntgl: "", NotGreaterSlantEqual: "", ngeqslant: "", nges: "", NotGreaterTilde: "", ngsim: "", NotHumpDownHump: "", nbump: "", NotHumpEqual: "", nbumpe: "", NotLeftTriangle: "", nltri: "", ntriangleleft: "", NotLeftTriangleBar: "", NotLeftTriangleEqual: "", nltrie: "", ntrianglelefteq: "", NotLess: "", nless: "", nlt: "", NotLessEqual: "", nle: "", nleq: "", NotLessGreater: "", ntlg: "", NotLessLess: "", nLtv: "", NotLessSlantEqual: "", nleqslant: "", nles: "", NotLessTilde: "", nlsim: "", NotNestedGreaterGreater: "", NotNestedLessLess: "", NotPrecedes: "", npr: "", nprec: "", NotPrecedesEqual: "", npre: "", npreceq: "", NotPrecedesSlantEqual: "", nprcue: "", NotReverseElement: "", notni: "", notniva: "", NotRightTriangle: "", nrtri: "", ntriangleright: "", NotRightTriangleBar: "", NotRightTriangleEqual: "", nrtrie: "", ntrianglerighteq: "", NotSquareSubset: "", NotSquareSubsetEqual: "", nsqsube: "", NotSquareSuperset: "", NotSquareSupersetEqual: "", nsqsupe: "", NotSubset: "", nsubset: "", vnsub: "", NotSubsetEqual: "", nsube: "", nsubseteq: "", NotSucceeds: "", nsc: "", nsucc: "", NotSucceedsEqual: "", nsce: "", nsucceq: "", NotSucceedsSlantEqual: "", nsccue: "", NotSucceedsTilde: "", NotSuperset: "", nsupset: "", vnsup: "", NotSupersetEqual: "", nsupe: "", nsupseteq: "", NotTilde: "", nsim: "", NotTildeEqual: "", nsime: "", nsimeq: "", NotTildeFullEqual: "", ncong: "", NotTildeTilde: "", nap: "", napprox: "", NotVerticalBar: "", nmid: "", nshortmid: "", nsmid: "", Nscr: "", Ntilde: "", Nu: "", OElig: "", Oacute: "", Ocirc: "", Ocy: "", Odblac: "", Ofr: "", Ograve: "", Omacr: "", Omega: "", ohm: "", Omicron: "", Oopf: "", OpenCurlyDoubleQuote: "", ldquo: "", OpenCurlyQuote: "", lsquo: "", Or: "", Oscr: "", Oslash: "", Otilde: "", Otimes: "", Ouml: "", OverBar: "", oline: "", OverBrace: "", OverBracket: "", tbrk: "", OverParenthesis: "", PartialD: "", part: "", Pcy: "", Pfr: "", Phi: "", Pi: "", PlusMinus: "", plusmn: "", pm: "", Popf: "", primes: "", Pr: "", Precedes: "", pr: "", prec: "", PrecedesEqual: "", pre: "", preceq: "", PrecedesSlantEqual: "", prcue: "", preccurlyeq: "", PrecedesTilde: "", precsim: "", prsim: "", Prime: "", Product: "", prod: "", Proportional: "", prop: "", propto: "", varpropto: "", vprop: "", Pscr: "", Psi: "", QUOT: '"', quot: '"', Qfr: "", Qopf: "", rationals: "", Qscr: "", RBarr: "", drbkarow: "", REG: "", circledR: "", reg: "", Racute: "", Rang: "", Rarr: "", twoheadrightarrow: "", Rarrtl: "", Rcaron: "", Rcedil: "", Rcy: "", Re: "", Rfr: "", real: "", realpart: "", ReverseElement: "", SuchThat: "", ni: "", niv: "", ReverseEquilibrium: "", leftrightharpoons: "", lrhar: "", ReverseUpEquilibrium: "", duhar: "", Rho: "", RightAngleBracket: "", rang: "", rangle: "", RightArrow: "", ShortRightArrow: "", rarr: "", rightarrow: "", srarr: "", RightArrowBar: "", rarrb: "", RightArrowLeftArrow: "", rightleftarrows: "", rlarr: "", RightCeiling: "", rceil: "", RightDoubleBracket: "", robrk: "", RightDownTeeVector: "", RightDownVector: "", dharr: "", downharpoonright: "", RightDownVectorBar: "", RightFloor: "", rfloor: "", RightTee: "", vdash: "", RightTeeArrow: "", map: "", mapsto: "", RightTeeVector: "", RightTriangle: "", vartriangleright: "", vrtri: "", RightTriangleBar: "", RightTriangleEqual: "", rtrie: "", trianglerighteq: "", RightUpDownVector: "", RightUpTeeVector: "", RightUpVector: "", uharr: "", upharpoonright: "", RightUpVectorBar: "", RightVector: "", rharu: "", rightharpoonup: "", RightVectorBar: "", Ropf: "", reals: "", RoundImplies: "", Rrightarrow: "", rAarr: "", Rscr: "", realine: "", Rsh: "", rsh: "", RuleDelayed: "", SHCHcy: "", SHcy: "", SOFTcy: "", Sacute: "", Sc: "", Scaron: "", Scedil: "", Scirc: "", Scy: "", Sfr: "", ShortUpArrow: "", UpArrow: "", uarr: "", uparrow: "", Sigma: "", SmallCircle: "", compfn: "", Sopf: "", Sqrt: "", radic: "", Square: "", squ: "", square: "", SquareIntersection: "", sqcap: "", SquareSubset: "", sqsub: "", sqsubset: "", SquareSubsetEqual: "", sqsube: "", sqsubseteq: "", SquareSuperset: "", sqsup: "", sqsupset: "", SquareSupersetEqual: "", sqsupe: "", sqsupseteq: "", SquareUnion: "", sqcup: "", Sscr: "", Star: "", sstarf: "", Sub: "", Subset: "", SubsetEqual: "", sube: "", subseteq: "", Succeeds: "", sc: "", succ: "", SucceedsEqual: "", sce: "", succeq: "", SucceedsSlantEqual: "", sccue: "", succcurlyeq: "", SucceedsTilde: "", scsim: "", succsim: "", Sum: "", sum: "", Sup: "", Supset: "", Superset: "", sup: "", supset: "", SupersetEqual: "", supe: "", supseteq: "", THORN: "", TRADE: "", trade: "", TSHcy: "", TScy: "", Tab: "	", Tau: "", Tcaron: "", Tcedil: "", Tcy: "", Tfr: "", Therefore: "", there4: "", therefore: "", Theta: "", ThickSpace: "", ThinSpace: "", thinsp: "", Tilde: "", sim: "", thicksim: "", thksim: "", TildeEqual: "", sime: "", simeq: "", TildeFullEqual: "", cong: "", TildeTilde: "", ap: "", approx: "", asymp: "", thickapprox: "", thkap: "", Topf: "", TripleDot: "", tdot: "", Tscr: "", Tstrok: "", Uacute: "", Uarr: "", Uarrocir: "", Ubrcy: "", Ubreve: "", Ucirc: "", Ucy: "", Udblac: "", Ufr: "", Ugrave: "", Umacr: "", UnderBar: "_", lowbar: "_", UnderBrace: "", UnderBracket: "", bbrk: "", UnderParenthesis: "", Union: "", bigcup: "", xcup: "", UnionPlus: "", uplus: "", Uogon: "", Uopf: "", UpArrowBar: "", UpArrowDownArrow: "", udarr: "", UpDownArrow: "", updownarrow: "", varr: "", UpEquilibrium: "", udhar: "", UpTee: "", bot: "", bottom: "", perp: "", UpTeeArrow: "", mapstoup: "", UpperLeftArrow: "", nwarr: "", nwarrow: "", UpperRightArrow: "", nearr: "", nearrow: "", Upsi: "", upsih: "", Upsilon: "", Uring: "", Uscr: "", Utilde: "", Uuml: "", VDash: "", Vbar: "", Vcy: "", Vdash: "", Vdashl: "", Vee: "", bigvee: "", xvee: "", Verbar: "", Vert: "", VerticalBar: "", mid: "", shortmid: "", smid: "", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "", VerticalTilde: "", wr: "", wreath: "", VeryThinSpace: "", hairsp: "", Vfr: "", Vopf: "", Vscr: "", Vvdash: "", Wcirc: "", Wedge: "", bigwedge: "", xwedge: "", Wfr: "", Wopf: "", Wscr: "", Xfr: "", Xi: "", Xopf: "", Xscr: "", YAcy: "", YIcy: "", YUcy: "", Yacute: "", Ycirc: "", Ycy: "", Yfr: "", Yopf: "", Yscr: "", Yuml: "", ZHcy: "", Zacute: "", Zcaron: "", Zcy: "", Zdot: "", Zeta: "", Zfr: "", zeetrf: "", Zopf: "", integers: "", Zscr: "", aacute: "", abreve: "", ac: "", mstpos: "", acE: "", acd: "", acirc: "", acy: "", aelig: "", afr: "", agrave: "", alefsym: "", aleph: "", alpha: "", amacr: "", amalg: "", and: "", wedge: "", andand: "", andd: "", andslope: "", andv: "", ang: "", angle: "", ange: "", angmsd: "", measuredangle: "", angmsdaa: "", angmsdab: "", angmsdac: "", angmsdad: "", angmsdae: "", angmsdaf: "", angmsdag: "", angmsdah: "", angrt: "", angrtvb: "", angrtvbd: "", angsph: "", angzarr: "", aogon: "", aopf: "", apE: "", apacir: "", ape: "", approxeq: "", apid: "", apos: "'", aring: "", ascr: "", ast: "*", midast: "*", atilde: "", auml: "", awint: "", bNot: "", backcong: "", bcong: "", backepsilon: "", bepsi: "", backprime: "", bprime: "", backsim: "", bsim: "", backsimeq: "", bsime: "", barvee: "", barwed: "", barwedge: "", bbrktbrk: "", bcy: "", bdquo: "", ldquor: "", bemptyv: "", beta: "", beth: "", between: "", twixt: "", bfr: "", bigcirc: "", xcirc: "", bigodot: "", xodot: "", bigoplus: "", xoplus: "", bigotimes: "", xotime: "", bigsqcup: "", xsqcup: "", bigstar: "", starf: "", bigtriangledown: "", xdtri: "", bigtriangleup: "", xutri: "", biguplus: "", xuplus: "", bkarow: "", rbarr: "", blacklozenge: "", lozf: "", blacktriangle: "", utrif: "", blacktriangledown: "", dtrif: "", blacktriangleleft: "", ltrif: "", blacktriangleright: "", rtrif: "", blank: "", blk12: "", blk14: "", blk34: "", block: "", bne: "=", bnequiv: "", bnot: "", bopf: "", bowtie: "", boxDL: "", boxDR: "", boxDl: "", boxDr: "", boxH: "", boxHD: "", boxHU: "", boxHd: "", boxHu: "", boxUL: "", boxUR: "", boxUl: "", boxUr: "", boxV: "", boxVH: "", boxVL: "", boxVR: "", boxVh: "", boxVl: "", boxVr: "", boxbox: "", boxdL: "", boxdR: "", boxdl: "", boxdr: "", boxhD: "", boxhU: "", boxhd: "", boxhu: "", boxminus: "", minusb: "", boxplus: "", plusb: "", boxtimes: "", timesb: "", boxuL: "", boxuR: "", boxul: "", boxur: "", boxv: "", boxvH: "", boxvL: "", boxvR: "", boxvh: "", boxvl: "", boxvr: "", brvbar: "", bscr: "", bsemi: "", bsol: "\\", bsolb: "", bsolhsub: "", bull: "", bullet: "", bumpE: "", cacute: "", cap: "", capand: "", capbrcup: "", capcap: "", capcup: "", capdot: "", caps: "", caret: "", ccaps: "", ccaron: "", ccedil: "", ccirc: "", ccups: "", ccupssm: "", cdot: "", cemptyv: "", cent: "", cfr: "", chcy: "", check: "", checkmark: "", chi: "", cir: "", cirE: "", circ: "", circeq: "", cire: "", circlearrowleft: "", olarr: "", circlearrowright: "", orarr: "", circledS: "", oS: "", circledast: "", oast: "", circledcirc: "", ocir: "", circleddash: "", odash: "", cirfnint: "", cirmid: "", cirscir: "", clubs: "", clubsuit: "", colon: ":", comma: ",", commat: "@", comp: "", complement: "", congdot: "", copf: "", copysr: "", crarr: "", cross: "", cscr: "", csub: "", csube: "", csup: "", csupe: "", ctdot: "", cudarrl: "", cudarrr: "", cuepr: "", curlyeqprec: "", cuesc: "", curlyeqsucc: "", cularr: "", curvearrowleft: "", cularrp: "", cup: "", cupbrcap: "", cupcap: "", cupcup: "", cupdot: "", cupor: "", cups: "", curarr: "", curvearrowright: "", curarrm: "", curlyvee: "", cuvee: "", curlywedge: "", cuwed: "", curren: "", cwint: "", cylcty: "", dHar: "", dagger: "", daleth: "", dash: "", hyphen: "", dbkarow: "", rBarr: "", dcaron: "", dcy: "", ddarr: "", downdownarrows: "", ddotseq: "", eDDot: "", deg: "", delta: "", demptyv: "", dfisht: "", dfr: "", diamondsuit: "", diams: "", digamma: "", gammad: "", disin: "", div: "", divide: "", divideontimes: "", divonx: "", djcy: "", dlcorn: "", llcorner: "", dlcrop: "", dollar: "$", dopf: "", doteqdot: "", eDot: "", dotminus: "", minusd: "", dotplus: "", plusdo: "", dotsquare: "", sdotb: "", drcorn: "", lrcorner: "", drcrop: "", dscr: "", dscy: "", dsol: "", dstrok: "", dtdot: "", dtri: "", triangledown: "", dwangle: "", dzcy: "", dzigrarr: "", eacute: "", easter: "", ecaron: "", ecir: "", eqcirc: "", ecirc: "", ecolon: "", eqcolon: "", ecy: "", edot: "", efDot: "", fallingdotseq: "", efr: "", eg: "", egrave: "", egs: "", eqslantgtr: "", egsdot: "", el: "", elinters: "", ell: "", els: "", eqslantless: "", elsdot: "", emacr: "", empty: "", emptyset: "", emptyv: "", varnothing: "", emsp13: "", emsp14: "", emsp: "", eng: "", ensp: "", eogon: "", eopf: "", epar: "", eparsl: "", eplus: "", epsi: "", epsilon: "", epsiv: "", straightepsilon: "", varepsilon: "", equals: "=", equest: "", questeq: "", equivDD: "", eqvparsl: "", erDot: "", risingdotseq: "", erarr: "", escr: "", eta: "", eth: "", euml: "", euro: "", excl: "!", fcy: "", female: "", ffilig: "", fflig: "", ffllig: "", ffr: "", filig: "", fjlig: "fj", flat: "", fllig: "", fltns: "", fnof: "", fopf: "", fork: "", pitchfork: "", forkv: "", fpartint: "", frac12: "", half: "", frac13: "", frac14: "", frac15: "", frac16: "", frac18: "", frac23: "", frac25: "", frac34: "", frac35: "", frac38: "", frac45: "", frac56: "", frac58: "", frac78: "", frasl: "", frown: "", sfrown: "", fscr: "", gEl: "", gtreqqless: "", gacute: "", gamma: "", gap: "", gtrapprox: "", gbreve: "", gcirc: "", gcy: "", gdot: "", gescc: "", gesdot: "", gesdoto: "", gesdotol: "", gesl: "", gesles: "", gfr: "", gimel: "", gjcy: "", glE: "", gla: "", glj: "", gnE: "", gneqq: "", gnap: "", gnapprox: "", gne: "", gneq: "", gnsim: "", gopf: "", gscr: "", gsime: "", gsiml: "", gtcc: "", gtcir: "", gtdot: "", gtrdot: "", gtlPar: "", gtquest: "", gtrarr: "", gvertneqq: "", gvnE: "", hardcy: "", harrcir: "", harrw: "", leftrightsquigarrow: "", hbar: "", hslash: "", planck: "", plankv: "", hcirc: "", hearts: "", heartsuit: "", hellip: "", mldr: "", hercon: "", hfr: "", hksearow: "", searhk: "", hkswarow: "", swarhk: "", hoarr: "", homtht: "", hookleftarrow: "", larrhk: "", hookrightarrow: "", rarrhk: "", hopf: "", horbar: "", hscr: "", hstrok: "", hybull: "", iacute: "", icirc: "", icy: "", iecy: "", iexcl: "", ifr: "", igrave: "", iiiint: "", qint: "", iiint: "", tint: "", iinfin: "", iiota: "", ijlig: "", imacr: "", imath: "", inodot: "", imof: "", imped: "", incare: "", infin: "", infintie: "", intcal: "", intercal: "", intlarhk: "", intprod: "", iprod: "", iocy: "", iogon: "", iopf: "", iota: "", iquest: "", iscr: "", isinE: "", isindot: "", isins: "", isinsv: "", itilde: "", iukcy: "", iuml: "", jcirc: "", jcy: "", jfr: "", jmath: "", jopf: "", jscr: "", jsercy: "", jukcy: "", kappa: "", kappav: "", varkappa: "", kcedil: "", kcy: "", kfr: "", kgreen: "", khcy: "", kjcy: "", kopf: "", kscr: "", lAtail: "", lBarr: "", lEg: "", lesseqqgtr: "", lHar: "", lacute: "", laemptyv: "", lambda: "", langd: "", lap: "", lessapprox: "", laquo: "", larrbfs: "", larrfs: "", larrlp: "", looparrowleft: "", larrpl: "", larrsim: "", larrtl: "", leftarrowtail: "", lat: "", latail: "", late: "", lates: "", lbarr: "", lbbrk: "", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "", lbrksld: "", lbrkslu: "", lcaron: "", lcedil: "", lcy: "", ldca: "", ldrdhar: "", ldrushar: "", ldsh: "", le: "", leq: "", leftleftarrows: "", llarr: "", leftthreetimes: "", lthree: "", lescc: "", lesdot: "", lesdoto: "", lesdotor: "", lesg: "", lesges: "", lessdot: "", ltdot: "", lfisht: "", lfr: "", lgE: "", lharul: "", lhblk: "", ljcy: "", llhard: "", lltri: "", lmidot: "", lmoust: "", lmoustache: "", lnE: "", lneqq: "", lnap: "", lnapprox: "", lne: "", lneq: "", lnsim: "", loang: "", loarr: "", longmapsto: "", xmap: "", looparrowright: "", rarrlp: "", lopar: "", lopf: "", loplus: "", lotimes: "", lowast: "", loz: "", lozenge: "", lpar: "(", lparlt: "", lrhard: "", lrm: "", lrtri: "", lsaquo: "", lscr: "", lsime: "", lsimg: "", lsquor: "", sbquo: "", lstrok: "", ltcc: "", ltcir: "", ltimes: "", ltlarr: "", ltquest: "", ltrPar: "", ltri: "", triangleleft: "", lurdshar: "", luruhar: "", lvertneqq: "", lvnE: "", mDDot: "", macr: "", strns: "", male: "", malt: "", maltese: "", marker: "", mcomma: "", mcy: "", mdash: "", mfr: "", mho: "", micro: "", midcir: "", minus: "", minusdu: "", mlcp: "", models: "", mopf: "", mscr: "", mu: "", multimap: "", mumap: "", nGg: "", nGt: "", nLeftarrow: "", nlArr: "", nLeftrightarrow: "", nhArr: "", nLl: "", nLt: "", nRightarrow: "", nrArr: "", nVDash: "", nVdash: "", nacute: "", nang: "", napE: "", napid: "", napos: "", natur: "", natural: "", ncap: "", ncaron: "", ncedil: "", ncongdot: "", ncup: "", ncy: "", ndash: "", neArr: "", nearhk: "", nedot: "", nesear: "", toea: "", nfr: "", nharr: "", nleftrightarrow: "", nhpar: "", nis: "", nisd: "", njcy: "", nlE: "", nleqq: "", nlarr: "", nleftarrow: "", nldr: "", nopf: "", not: "", notinE: "", notindot: "", notinvb: "", notinvc: "", notnivb: "", notnivc: "", nparsl: "", npart: "", npolint: "", nrarr: "", nrightarrow: "", nrarrc: "", nrarrw: "", nscr: "", nsub: "", nsubE: "", nsubseteqq: "", nsup: "", nsupE: "", nsupseteqq: "", ntilde: "", nu: "", num: "#", numero: "", numsp: "", nvDash: "", nvHarr: "", nvap: "", nvdash: "", nvge: "", nvgt: ">", nvinfin: "", nvlArr: "", nvle: "", nvlt: "<", nvltrie: "", nvrArr: "", nvrtrie: "", nvsim: "", nwArr: "", nwarhk: "", nwnear: "", oacute: "", ocirc: "", ocy: "", odblac: "", odiv: "", odsold: "", oelig: "", ofcir: "", ofr: "", ogon: "", ograve: "", ogt: "", ohbar: "", olcir: "", olcross: "", olt: "", omacr: "", omega: "", omicron: "", omid: "", oopf: "", opar: "", operp: "", or: "", vee: "", ord: "", order: "", orderof: "", oscr: "", ordf: "", ordm: "", origof: "", oror: "", orslope: "", orv: "", oslash: "", osol: "", otilde: "", otimesas: "", ouml: "", ovbar: "", para: "", parsim: "", parsl: "", pcy: "", percnt: "%", period: ".", permil: "", pertenk: "", pfr: "", phi: "", phiv: "", straightphi: "", varphi: "", phone: "", pi: "", piv: "", varpi: "", planckh: "", plus: "+", plusacir: "", pluscir: "", plusdu: "", pluse: "", plussim: "", plustwo: "", pointint: "", popf: "", pound: "", prE: "", prap: "", precapprox: "", precnapprox: "", prnap: "", precneqq: "", prnE: "", precnsim: "", prnsim: "", prime: "", profalar: "", profline: "", profsurf: "", prurel: "", pscr: "", psi: "", puncsp: "", qfr: "", qopf: "", qprime: "", qscr: "", quatint: "", quest: "?", rAtail: "", rHar: "", race: "", racute: "", raemptyv: "", rangd: "", range: "", raquo: "", rarrap: "", rarrbfs: "", rarrc: "", rarrfs: "", rarrpl: "", rarrsim: "", rarrtl: "", rightarrowtail: "", rarrw: "", rightsquigarrow: "", ratail: "", ratio: "", rbbrk: "", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "", rbrksld: "", rbrkslu: "", rcaron: "", rcedil: "", rcy: "", rdca: "", rdldhar: "", rdsh: "", rect: "", rfisht: "", rfr: "", rharul: "", rho: "", rhov: "", varrho: "", rightrightarrows: "", rrarr: "", rightthreetimes: "", rthree: "", ring: "", rlm: "", rmoust: "", rmoustache: "", rnmid: "", roang: "", roarr: "", ropar: "", ropf: "", roplus: "", rotimes: "", rpar: ")", rpargt: "", rppolint: "", rsaquo: "", rscr: "", rtimes: "", rtri: "", triangleright: "", rtriltri: "", ruluhar: "", rx: "", sacute: "", scE: "", scap: "", succapprox: "", scaron: "", scedil: "", scirc: "", scnE: "", succneqq: "", scnap: "", succnapprox: "", scnsim: "", succnsim: "", scpolint: "", scy: "", sdot: "", sdote: "", seArr: "", sect: "", semi: ";", seswar: "", tosa: "", sext: "", sfr: "", sharp: "", shchcy: "", shcy: "", shy: "", sigma: "", sigmaf: "", sigmav: "", varsigma: "", simdot: "", simg: "", simgE: "", siml: "", simlE: "", simne: "", simplus: "", simrarr: "", smashp: "", smeparsl: "", smile: "", ssmile: "", smt: "", smte: "", smtes: "", softcy: "", sol: "/", solb: "", solbar: "", sopf: "", spades: "", spadesuit: "", sqcaps: "", sqcups: "", sscr: "", star: "", sub: "", subset: "", subE: "", subseteqq: "", subdot: "", subedot: "", submult: "", subnE: "", subsetneqq: "", subne: "", subsetneq: "", subplus: "", subrarr: "", subsim: "", subsub: "", subsup: "", sung: "", sup1: "", sup2: "", sup3: "", supE: "", supseteqq: "", supdot: "", supdsub: "", supedot: "", suphsol: "", suphsub: "", suplarr: "", supmult: "", supnE: "", supsetneqq: "", supne: "", supsetneq: "", supplus: "", supsim: "", supsub: "", supsup: "", swArr: "", swnwar: "", szlig: "", target: "", tau: "", tcaron: "", tcedil: "", tcy: "", telrec: "", tfr: "", theta: "", thetasym: "", thetav: "", vartheta: "", thorn: "", times: "", timesbar: "", timesd: "", topbot: "", topcir: "", topf: "", topfork: "", tprime: "", triangle: "", utri: "", triangleq: "", trie: "", tridot: "", triminus: "", triplus: "", trisb: "", tritime: "", trpezium: "", tscr: "", tscy: "", tshcy: "", tstrok: "", uHar: "", uacute: "", ubrcy: "", ubreve: "", ucirc: "", ucy: "", udblac: "", ufisht: "", ufr: "", ugrave: "", uhblk: "", ulcorn: "", ulcorner: "", ulcrop: "", ultri: "", umacr: "", uogon: "", uopf: "", upsi: "", upsilon: "", upuparrows: "", uuarr: "", urcorn: "", urcorner: "", urcrop: "", uring: "", urtri: "", uscr: "", utdot: "", utilde: "", uuml: "", uwangle: "", vBar: "", vBarv: "", vangrt: "", varsubsetneq: "", vsubne: "", varsubsetneqq: "", vsubnE: "", varsupsetneq: "", vsupne: "", varsupsetneqq: "", vsupnE: "", vcy: "", veebar: "", veeeq: "", vellip: "", vfr: "", vopf: "", vscr: "", vzigzag: "", wcirc: "", wedbar: "", wedgeq: "", weierp: "", wp: "", wfr: "", wopf: "", wscr: "", xfr: "", xi: "", xnis: "", xopf: "", xscr: "", yacute: "", yacy: "", ycirc: "", ycy: "", yen: "", yfr: "", yicy: "", yopf: "", yscr: "", yucy: "", yuml: "", zacute: "", zcaron: "", zcy: "", zdot: "", zeta: "", zfr: "", zhcy: "", zigrarr: "", zopf: "", zscr: "", zwj: "", zwnj: "" }, UN = "";
Oh.ngsp = UN;
var zN = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
function GN(t, e) {
  if (e != null && !(Array.isArray(e) && e.length == 2))
    throw new Error(`Expected '${t}' to be an array, [start, end].`);
  if (e != null) {
    let r = e[0], n = e[1];
    zN.forEach((i) => {
      if (i.test(r) || i.test(n))
        throw new Error(`['${r}', '${n}'] contains unusable interpolation symbol.`);
    });
  }
}
var HN = class C2 {
  static fromArray(e) {
    return e ? (GN("interpolation", e), new C2(e[0], e[1])) : E2;
  }
  constructor(e, r) {
    this.start = e, this.end = r;
  }
}, E2 = new HN("{{", "}}"), Bd = class extends D2 {
  constructor(e, r, n) {
    super(n, e), this.tokenType = r;
  }
}, JN = class {
  constructor(e, r, n) {
    this.tokens = e, this.errors = r, this.nonNormalizedIcuExpressions = n;
  }
};
function KN(t, e, r, n = {}) {
  let i = new r5(new b2(t, e), r, n);
  return i.tokenize(), new JN(l5(i.tokens), i.errors, i.nonNormalizedIcuExpressions);
}
var e5 = /\r\n?/g;
function ka(t) {
  return `Unexpected character "${t === 0 ? "EOF" : String.fromCharCode(t)}"`;
}
function m1(t) {
  return `Unknown entity "${t}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
}
function t5(t, e) {
  return `Unable to parse entity "${e}" - ${t} character reference entities must end with ";"`;
}
var xh;
(function(t) {
  t.HEX = "hexadecimal", t.DEC = "decimal";
})(xh || (xh = {}));
var Id = class {
  constructor(e) {
    this.error = e;
  }
}, r5 = class {
  constructor(e, r, n) {
    this._getTagContentType = r, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = !1, this._fullNameStack = [], this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = n.tokenizeExpansionForms || !1, this._interpolationConfig = n.interpolationConfig || E2, this._leadingTriviaCodePoints = n.leadingTriviaChars && n.leadingTriviaChars.map((s) => s.codePointAt(0) || 0), this._canSelfClose = n.canSelfClose || !1, this._allowHtmComponentClosingTags = n.allowHtmComponentClosingTags || !1;
    let i = n.range || { endPos: e.content.length, startPos: 0, startLine: 0, startCol: 0 };
    this._cursor = n.escapedString ? new u5(e, i) : new A2(e, i), this._preserveLineEndings = n.preserveLineEndings || !1, this._i18nNormalizeLineEndingsInICUs = n.i18nNormalizeLineEndingsInICUs || !1, this._tokenizeBlocks = n.tokenizeBlocks ?? !0;
    try {
      this._cursor.init();
    } catch (s) {
      this.handleError(s);
    }
  }
  _processCarriageReturns(e) {
    return this._preserveLineEndings ? e : e.replace(e5, `
`);
  }
  tokenize() {
    for (; this._cursor.peek() !== 0; ) {
      let e = this._cursor.clone();
      try {
        if (this._attemptCharCode(60))
          if (this._attemptCharCode(33))
            this._attemptStr("[CDATA[") ? this._consumeCdata(e) : this._attemptStr("--") ? this._consumeComment(e) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e) : this._consumeBogusComment(e);
          else if (this._attemptCharCode(47))
            this._consumeTagClose(e);
          else {
            let r = this._cursor.clone();
            this._attemptCharCode(63) ? (this._cursor = r, this._consumeBogusComment(e)) : this._consumeTagOpen(e);
          }
        else
          this._tokenizeBlocks && this._attemptCharCode(64) ? this._consumeBlockStart(e) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(125) ? this._consumeBlockEnd(e) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
      } catch (r) {
        this.handleError(r);
      }
    }
    this._beginToken(30), this._endToken([]);
  }
  _getBlockName() {
    let e = !1, r = this._cursor.clone();
    return this._attemptCharCodeUntilFn((n) => ly(n) ? !e : O1(n) ? (e = !0, !1) : !0), this._cursor.getChars(r).trim();
  }
  _consumeBlockStart(e) {
    this._beginToken(25, e);
    let r = this._endToken([this._getBlockName()]);
    if (this._cursor.peek() === 40)
      if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(jt), this._attemptCharCode(41))
        this._attemptCharCodeUntilFn(jt);
      else {
        r.type = 29;
        return;
      }
    this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : r.type = 29;
  }
  _consumeBlockEnd(e) {
    this._beginToken(27, e), this._endToken([]);
  }
  _consumeBlockParameters() {
    for (this._attemptCharCodeUntilFn(x1); this._cursor.peek() !== 41 && this._cursor.peek() !== 0; ) {
      this._beginToken(28);
      let e = this._cursor.clone(), r = null, n = 0;
      for (; this._cursor.peek() !== 59 && this._cursor.peek() !== 0 || r !== null; ) {
        let i = this._cursor.peek();
        if (i === 92)
          this._cursor.advance();
        else if (i === r)
          r = null;
        else if (r === null && r1(i))
          r = i;
        else if (i === 40 && r === null)
          n++;
        else if (i === 41 && r === null) {
          if (n === 0)
            break;
          n > 0 && n--;
        }
        this._cursor.advance();
      }
      this._endToken([this._cursor.getChars(e)]), this._attemptCharCodeUntilFn(x1);
    }
  }
  _tokenizeExpansionForm() {
    if (this.isExpansionFormStart())
      return this._consumeExpansionFormStart(), !0;
    if (a5(this._cursor.peek()) && this._isInExpansionForm())
      return this._consumeExpansionCaseStart(), !0;
    if (this._cursor.peek() === 125) {
      if (this._isInExpansionCase())
        return this._consumeExpansionCaseEnd(), !0;
      if (this._isInExpansionForm())
        return this._consumeExpansionFormEnd(), !0;
    }
    return !1;
  }
  _beginToken(e, r = this._cursor.clone()) {
    this._currentTokenStart = r, this._currentTokenType = e;
  }
  _endToken(e, r) {
    if (this._currentTokenStart === null)
      throw new Bd("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(r));
    if (this._currentTokenType === null)
      throw new Bd("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
    let n = { type: this._currentTokenType, parts: e, sourceSpan: (r ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
    return this.tokens.push(n), this._currentTokenStart = null, this._currentTokenType = null, n;
  }
  _createError(e, r) {
    this._isInExpansionForm() && (e += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
    let n = new Bd(e, this._currentTokenType, r);
    return this._currentTokenStart = null, this._currentTokenType = null, new Id(n);
  }
  handleError(e) {
    if (e instanceof cy && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), e instanceof Id)
      this.errors.push(e.error);
    else
      throw e;
  }
  _attemptCharCode(e) {
    return this._cursor.peek() === e ? (this._cursor.advance(), !0) : !1;
  }
  _attemptCharCodeCaseInsensitive(e) {
    return o5(this._cursor.peek(), e) ? (this._cursor.advance(), !0) : !1;
  }
  _requireCharCode(e) {
    let r = this._cursor.clone();
    if (!this._attemptCharCode(e))
      throw this._createError(ka(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptStr(e) {
    let r = e.length;
    if (this._cursor.charsLeft() < r)
      return !1;
    let n = this._cursor.clone();
    for (let i = 0; i < r; i++)
      if (!this._attemptCharCode(e.charCodeAt(i)))
        return this._cursor = n, !1;
    return !0;
  }
  _attemptStrCaseInsensitive(e) {
    for (let r = 0; r < e.length; r++)
      if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(r)))
        return !1;
    return !0;
  }
  _requireStr(e) {
    let r = this._cursor.clone();
    if (!this._attemptStr(e))
      throw this._createError(ka(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _requireStrCaseInsensitive(e) {
    let r = this._cursor.clone();
    if (!this._attemptStrCaseInsensitive(e))
      throw this._createError(ka(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptCharCodeUntilFn(e) {
    for (; !e(this._cursor.peek()); )
      this._cursor.advance();
  }
  _requireCharCodeUntilFn(e, r) {
    let n = this._cursor.clone();
    if (this._attemptCharCodeUntilFn(e), this._cursor.diff(n) < r)
      throw this._createError(ka(this._cursor.peek()), this._cursor.getSpan(n));
  }
  _attemptUntilChar(e) {
    for (; this._cursor.peek() !== e; )
      this._cursor.advance();
  }
  _readChar() {
    let e = String.fromCodePoint(this._cursor.peek());
    return this._cursor.advance(), e;
  }
  _consumeEntity(e) {
    this._beginToken(9);
    let r = this._cursor.clone();
    if (this._cursor.advance(), this._attemptCharCode(35)) {
      let n = this._attemptCharCode(120) || this._attemptCharCode(88), i = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(i5), this._cursor.peek() != 59) {
        this._cursor.advance();
        let a = n ? xh.HEX : xh.DEC;
        throw this._createError(t5(a, this._cursor.getChars(r)), this._cursor.getSpan());
      }
      let s = this._cursor.getChars(i);
      this._cursor.advance();
      try {
        let a = parseInt(s, n ? 16 : 10);
        this._endToken([String.fromCharCode(a), this._cursor.getChars(r)]);
      } catch {
        throw this._createError(m1(this._cursor.getChars(r)), this._cursor.getSpan());
      }
    } else {
      let n = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(s5), this._cursor.peek() != 59)
        this._beginToken(e, r), this._cursor = n, this._endToken(["&"]);
      else {
        let i = this._cursor.getChars(n);
        this._cursor.advance();
        let s = Oh[i];
        if (!s)
          throw this._createError(m1(i), this._cursor.getSpan(r));
        this._endToken([s, `&${i};`]);
      }
    }
  }
  _consumeRawText(e, r) {
    this._beginToken(e ? 6 : 7);
    let n = [];
    for (; ; ) {
      let i = this._cursor.clone(), s = r();
      if (this._cursor = i, s)
        break;
      e && this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(n.join(""))]), n.length = 0, this._consumeEntity(6), this._beginToken(6)) : n.push(this._readChar());
    }
    this._endToken([this._processCarriageReturns(n.join(""))]);
  }
  _consumeComment(e) {
    this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("-->")), this._beginToken(11), this._requireStr("-->"), this._endToken([]);
  }
  _consumeBogusComment(e) {
    this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._cursor.peek() === 62), this._beginToken(11), this._cursor.advance(), this._endToken([]);
  }
  _consumeCdata(e) {
    this._beginToken(12, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]);
  }
  _consumeDocType(e) {
    this._beginToken(18, e), this._endToken([]), this._consumeRawText(!1, () => this._cursor.peek() === 62), this._beginToken(19), this._cursor.advance(), this._endToken([]);
  }
  _consumePrefixAndName() {
    let e = this._cursor.clone(), r = "";
    for (; this._cursor.peek() !== 58 && !n5(this._cursor.peek()); )
      this._cursor.advance();
    let n;
    this._cursor.peek() === 58 ? (r = this._cursor.getChars(e), this._cursor.advance(), n = this._cursor.clone()) : n = e, this._requireCharCodeUntilFn(g1, r === "" ? 0 : 1);
    let i = this._cursor.getChars(n);
    return [r, i];
  }
  _consumeTagOpen(e) {
    let r, n, i, s = [];
    try {
      if (!uy(this._cursor.peek()))
        throw this._createError(ka(this._cursor.peek()), this._cursor.getSpan(e));
      for (i = this._consumeTagOpenStart(e), n = i.parts[0], r = i.parts[1], this._attemptCharCodeUntilFn(jt); this._cursor.peek() !== 47 && this._cursor.peek() !== 62 && this._cursor.peek() !== 60 && this._cursor.peek() !== 0; ) {
        let [o, u] = this._consumeAttributeName();
        if (this._attemptCharCodeUntilFn(jt), this._attemptCharCode(61)) {
          this._attemptCharCodeUntilFn(jt);
          let c = this._consumeAttributeValue();
          s.push({ prefix: o, name: u, value: c });
        } else
          s.push({ prefix: o, name: u });
        this._attemptCharCodeUntilFn(jt);
      }
      this._consumeTagOpenEnd();
    } catch (o) {
      if (o instanceof Id) {
        i ? i.type = 4 : (this._beginToken(5, e), this._endToken(["<"]));
        return;
      }
      throw o;
    }
    if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === 2)
      return;
    let a = this._getTagContentType(r, n, this._fullNameStack.length > 0, s);
    this._handleFullNameStackForTagOpen(n, r), a === Pn.RAW_TEXT ? this._consumeRawTextWithTagClose(n, r, !1) : a === Pn.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(n, r, !0);
  }
  _consumeRawTextWithTagClose(e, r, n) {
    this._consumeRawText(n, () => !this._attemptCharCode(60) || !this._attemptCharCode(47) || (this._attemptCharCodeUntilFn(jt), !this._attemptStrCaseInsensitive(e ? `${e}:${r}` : r)) ? !1 : (this._attemptCharCodeUntilFn(jt), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((i) => i === 62, 3), this._cursor.advance(), this._endToken([e, r]), this._handleFullNameStackForTagClose(e, r);
  }
  _consumeTagOpenStart(e) {
    this._beginToken(0, e);
    let r = this._consumePrefixAndName();
    return this._endToken(r);
  }
  _consumeAttributeName() {
    let e = this._cursor.peek();
    if (e === 39 || e === 34)
      throw this._createError(ka(e), this._cursor.getSpan());
    this._beginToken(14);
    let r = this._consumePrefixAndName();
    return this._endToken(r), r;
  }
  _consumeAttributeValue() {
    let e;
    if (this._cursor.peek() === 39 || this._cursor.peek() === 34) {
      let r = this._cursor.peek();
      this._consumeQuote(r);
      let n = () => this._cursor.peek() === r;
      e = this._consumeWithInterpolation(16, 17, n, n), this._consumeQuote(r);
    } else {
      let r = () => g1(this._cursor.peek());
      e = this._consumeWithInterpolation(16, 17, r, r);
    }
    return e;
  }
  _consumeQuote(e) {
    this._beginToken(15), this._requireCharCode(e), this._endToken([String.fromCodePoint(e)]);
  }
  _consumeTagOpenEnd() {
    let e = this._attemptCharCode(47) ? 2 : 1;
    this._beginToken(e), this._requireCharCode(62), this._endToken([]);
  }
  _consumeTagClose(e) {
    if (this._beginToken(3, e), this._attemptCharCodeUntilFn(jt), this._allowHtmComponentClosingTags && this._attemptCharCode(47))
      this._attemptCharCodeUntilFn(jt), this._requireCharCode(62), this._endToken([]);
    else {
      let [r, n] = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(jt), this._requireCharCode(62), this._endToken([r, n]), this._handleFullNameStackForTagClose(r, n);
    }
  }
  _consumeExpansionFormStart() {
    this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
    let e = this._readUntil(44), r = this._processCarriageReturns(e);
    if (this._i18nNormalizeLineEndingsInICUs)
      this._endToken([r]);
    else {
      let i = this._endToken([e]);
      r !== e && this.nonNormalizedIcuExpressions.push(i);
    }
    this._requireCharCode(44), this._attemptCharCodeUntilFn(jt), this._beginToken(7);
    let n = this._readUntil(44);
    this._endToken([n]), this._requireCharCode(44), this._attemptCharCodeUntilFn(jt);
  }
  _consumeExpansionCaseStart() {
    this._beginToken(21);
    let e = this._readUntil(123).trim();
    this._endToken([e]), this._attemptCharCodeUntilFn(jt), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(jt), this._expansionCaseStack.push(22);
  }
  _consumeExpansionCaseEnd() {
    this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(jt), this._expansionCaseStack.pop();
  }
  _consumeExpansionFormEnd() {
    this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
  }
  _consumeWithInterpolation(e, r, n, i) {
    this._beginToken(e);
    let s = [];
    for (; !n(); ) {
      let o = this._cursor.clone();
      this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(s.join(""))], o), s.length = 0, this._consumeInterpolation(r, o, i), this._beginToken(e)) : this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(s.join(""))]), s.length = 0, this._consumeEntity(e), this._beginToken(e)) : s.push(this._readChar());
    }
    this._inInterpolation = !1;
    let a = this._processCarriageReturns(s.join(""));
    return this._endToken([a]), a;
  }
  _consumeInterpolation(e, r, n) {
    let i = [];
    this._beginToken(e, r), i.push(this._interpolationConfig.start);
    let s = this._cursor.clone(), a = null, o = !1;
    for (; this._cursor.peek() !== 0 && (n === null || !n()); ) {
      let u = this._cursor.clone();
      if (this._isTagStart()) {
        this._cursor = u, i.push(this._getProcessedChars(s, u)), this._endToken(i);
        return;
      }
      if (a === null)
        if (this._attemptStr(this._interpolationConfig.end)) {
          i.push(this._getProcessedChars(s, u)), i.push(this._interpolationConfig.end), this._endToken(i);
          return;
        } else
          this._attemptStr("//") && (o = !0);
      let c = this._cursor.peek();
      this._cursor.advance(), c === 92 ? this._cursor.advance() : c === a ? a = null : !o && a === null && r1(c) && (a = c);
    }
    i.push(this._getProcessedChars(s, this._cursor)), this._endToken(i);
  }
  _getProcessedChars(e, r) {
    return this._processCarriageReturns(r.getChars(e));
  }
  _isTextEnd() {
    return !!(this._isTagStart() || this._cursor.peek() === 0 || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === 125 && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._cursor.peek() === 125));
  }
  _isTagStart() {
    if (this._cursor.peek() === 60) {
      let e = this._cursor.clone();
      e.advance();
      let r = e.peek();
      if (97 <= r && r <= 122 || 65 <= r && r <= 90 || r === 47 || r === 33)
        return !0;
    }
    return !1;
  }
  _isBlockStart() {
    if (this._tokenizeBlocks && this._cursor.peek() === 64) {
      let e = this._cursor.clone();
      if (e.advance(), O1(e.peek()))
        return !0;
    }
    return !1;
  }
  _readUntil(e) {
    let r = this._cursor.clone();
    return this._attemptUntilChar(e), this._cursor.getChars(r);
  }
  _isInExpansion() {
    return this._isInExpansionCase() || this._isInExpansionForm();
  }
  _isInExpansionCase() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 22;
  }
  _isInExpansionForm() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 20;
  }
  isExpansionFormStart() {
    if (this._cursor.peek() !== 123)
      return !1;
    if (this._interpolationConfig) {
      let e = this._cursor.clone(), r = this._attemptStr(this._interpolationConfig.start);
      return this._cursor = e, !r;
    }
    return !0;
  }
  _handleFullNameStackForTagOpen(e, r) {
    let n = yh(e, r);
    (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === n) && this._fullNameStack.push(n);
  }
  _handleFullNameStackForTagClose(e, r) {
    let n = yh(e, r);
    this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === n && this._fullNameStack.pop();
  }
};
function jt(t) {
  return !ly(t) || t === 0;
}
function g1(t) {
  return ly(t) || t === 62 || t === 60 || t === 47 || t === 39 || t === 34 || t === 61 || t === 0;
}
function n5(t) {
  return (t < 97 || 122 < t) && (t < 65 || 90 < t) && (t < 48 || t > 57);
}
function i5(t) {
  return t === 59 || t === 0 || !lN(t);
}
function s5(t) {
  return t === 59 || t === 0 || !uy(t);
}
function a5(t) {
  return t !== 125;
}
function o5(t, e) {
  return y1(t) === y1(e);
}
function y1(t) {
  return t >= 97 && t <= 122 ? t - 97 + 65 : t;
}
function O1(t) {
  return uy(t) || y2(t) || t === 95;
}
function x1(t) {
  return t !== 59 && jt(t);
}
function l5(t) {
  let e = [], r;
  for (let n = 0; n < t.length; n++) {
    let i = t[n];
    r && r.type === 5 && i.type === 5 || r && r.type === 16 && i.type === 16 ? (r.parts[0] += i.parts[0], r.sourceSpan.end = i.sourceSpan.end) : (r = i, e.push(r));
  }
  return e;
}
var A2 = class Kf {
  constructor(e, r) {
    if (e instanceof Kf) {
      this.file = e.file, this.input = e.input, this.end = e.end;
      let n = e.state;
      this.state = { peek: n.peek, offset: n.offset, line: n.line, column: n.column };
    } else {
      if (!r)
        throw new Error("Programming error: the range argument must be provided with a file argument.");
      this.file = e, this.input = e.content, this.end = r.endPos, this.state = { peek: -1, offset: r.startPos, line: r.startLine, column: r.startCol };
    }
  }
  clone() {
    return new Kf(this);
  }
  peek() {
    return this.state.peek;
  }
  charsLeft() {
    return this.end - this.state.offset;
  }
  diff(e) {
    return this.state.offset - e.state.offset;
  }
  advance() {
    this.advanceState(this.state);
  }
  init() {
    this.updatePeek(this.state);
  }
  getSpan(e, r) {
    e = e || this;
    let n = e;
    if (r)
      for (; this.diff(e) > 0 && r.indexOf(e.peek()) !== -1; )
        n === e && (e = e.clone()), e.advance();
    let i = this.locationFromCursor(e), s = this.locationFromCursor(this), a = n !== e ? this.locationFromCursor(n) : i;
    return new je(i, s, a);
  }
  getChars(e) {
    return this.input.substring(e.state.offset, this.state.offset);
  }
  charAt(e) {
    return this.input.charCodeAt(e);
  }
  advanceState(e) {
    if (e.offset >= this.end)
      throw this.state = e, new cy('Unexpected character "EOF"', this);
    let r = this.charAt(e.offset);
    r === 10 ? (e.line++, e.column = 0) : O2(r) || e.column++, e.offset++, this.updatePeek(e);
  }
  updatePeek(e) {
    e.peek = e.offset >= this.end ? 0 : this.charAt(e.offset);
  }
  locationFromCursor(e) {
    return new Hf(e.file, e.state.offset, e.state.line, e.state.column);
  }
}, u5 = class em extends A2 {
  constructor(e, r) {
    e instanceof em ? (super(e), this.internalState = { ...e.internalState }) : (super(e, r), this.internalState = this.state);
  }
  advance() {
    this.state = this.internalState, super.advance(), this.processEscapeSequence();
  }
  init() {
    super.init(), this.processEscapeSequence();
  }
  clone() {
    return new em(this);
  }
  getChars(e) {
    let r = e.clone(), n = "";
    for (; r.internalState.offset < this.internalState.offset; )
      n += String.fromCodePoint(r.peek()), r.advance();
    return n;
  }
  processEscapeSequence() {
    let e = () => this.internalState.peek;
    if (e() === 92)
      if (this.internalState = { ...this.state }, this.advanceState(this.internalState), e() === 110)
        this.state.peek = 10;
      else if (e() === 114)
        this.state.peek = 13;
      else if (e() === 118)
        this.state.peek = 11;
      else if (e() === 116)
        this.state.peek = 9;
      else if (e() === 98)
        this.state.peek = 8;
      else if (e() === 102)
        this.state.peek = 12;
      else if (e() === 117)
        if (this.advanceState(this.internalState), e() === 123) {
          this.advanceState(this.internalState);
          let r = this.clone(), n = 0;
          for (; e() !== 125; )
            this.advanceState(this.internalState), n++;
          this.state.peek = this.decodeHexDigits(r, n);
        } else {
          let r = this.clone();
          this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 4);
        }
      else if (e() === 120) {
        this.advanceState(this.internalState);
        let r = this.clone();
        this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 2);
      } else if (t1(e())) {
        let r = "", n = 0, i = this.clone();
        for (; t1(e()) && n < 3; )
          i = this.clone(), r += String.fromCodePoint(e()), this.advanceState(this.internalState), n++;
        this.state.peek = parseInt(r, 8), this.internalState = i.internalState;
      } else
        O2(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
  }
  decodeHexDigits(e, r) {
    let n = this.input.slice(e.internalState.offset, e.internalState.offset + r), i = parseInt(n, 16);
    if (isNaN(i))
      throw e.state = e.internalState, new cy("Invalid hexadecimal escape sequence", e);
    return i;
  }
}, cy = class {
  constructor(e, r) {
    this.msg = e, this.cursor = r;
  }
}, nn = class T2 extends D2 {
  static create(e, r, n) {
    return new T2(e, r, n);
  }
  constructor(e, r, n) {
    super(r, n), this.elementName = e;
  }
}, c5 = class {
  constructor(e, r) {
    this.rootNodes = e, this.errors = r;
  }
}, h5 = class {
  constructor(e) {
    this.getTagDefinition = e;
  }
  parse(e, r, n, i = !1, s) {
    let a = (O) => (b, ...D) => O(b.toLowerCase(), ...D), o = i ? this.getTagDefinition : a(this.getTagDefinition), u = (O) => o(O).getContentType(), c = i ? s : a(s), h = KN(e, r, s ? (O, b, D, S) => {
      let x = c(O, b, D, S);
      return x !== void 0 ? x : u(O);
    } : u, n), p = n && n.canSelfClose || !1, m = n && n.allowHtmComponentClosingTags || !1, g = new p5(h.tokens, o, p, m, i);
    return g.build(), new c5(g.rootNodes, h.errors.concat(g.errors));
  }
}, p5 = class k2 {
  constructor(e, r, n, i, s) {
    this.tokens = e, this.getTagDefinition = r, this.canSelfClose = n, this.allowHtmComponentClosingTags = i, this.isTagNameCaseSensitive = s, this._index = -1, this._containerStack = [], this.rootNodes = [], this.errors = [], this._advance();
  }
  build() {
    for (; this._peek.type !== 30; )
      this._peek.type === 0 || this._peek.type === 4 ? this._consumeStartTag(this._advance()) : this._peek.type === 3 ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === 12 ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === 10 ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6 ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === 20 ? this._consumeExpansion(this._advance()) : this._peek.type === 25 ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === 27 ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === 29 ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === 18 ? this._consumeDocType(this._advance()) : this._advance();
    for (let e of this._containerStack)
      e instanceof Ta && this.errors.push(nn.create(e.name, e.sourceSpan, `Unclosed block "${e.name}"`));
  }
  _advance() {
    let e = this._peek;
    return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e;
  }
  _advanceIf(e) {
    return this._peek.type === e ? this._advance() : null;
  }
  _consumeCdata(e) {
    let r = this._advance(), n = this._getText(r), i = this._advanceIf(13);
    this._addToParent(new jN(n, new je(e.sourceSpan.start, (i || r).sourceSpan.end), [r]));
  }
  _consumeComment(e) {
    let r = this._advanceIf(7), n = this._advanceIf(11), i = r != null ? r.parts[0].trim() : null, s = new je(e.sourceSpan.start, (n || r || e).sourceSpan.end);
    this._addToParent(new XN(i, s));
  }
  _consumeDocType(e) {
    let r = this._advanceIf(7), n = this._advanceIf(19), i = r != null ? r.parts[0].trim() : null, s = new je(e.sourceSpan.start, (n || r || e).sourceSpan.end);
    this._addToParent(new VN(i, s));
  }
  _consumeExpansion(e) {
    let r = this._advance(), n = this._advance(), i = [];
    for (; this._peek.type === 21; ) {
      let a = this._parseExpansionCase();
      if (!a)
        return;
      i.push(a);
    }
    if (this._peek.type !== 24) {
      this.errors.push(nn.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      return;
    }
    let s = new je(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart);
    this._addToParent(new ZN(r.parts[0], n.parts[0], i, s, r.sourceSpan)), this._advance();
  }
  _parseExpansionCase() {
    let e = this._advance();
    if (this._peek.type !== 22)
      return this.errors.push(nn.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
    let r = this._advance(), n = this._collectExpansionExpTokens(r);
    if (!n)
      return null;
    let i = this._advance();
    n.push({ type: 30, parts: [], sourceSpan: i.sourceSpan });
    let s = new k2(n, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
    if (s.build(), s.errors.length > 0)
      return this.errors = this.errors.concat(s.errors), null;
    let a = new je(e.sourceSpan.start, i.sourceSpan.end, e.sourceSpan.fullStart), o = new je(r.sourceSpan.start, i.sourceSpan.end, r.sourceSpan.fullStart);
    return new WN(e.parts[0], s.rootNodes, a, e.sourceSpan, o);
  }
  _collectExpansionExpTokens(e) {
    let r = [], n = [22];
    for (; ; ) {
      if ((this._peek.type === 20 || this._peek.type === 22) && n.push(this._peek.type), this._peek.type === 23)
        if (b1(n, 22)) {
          if (n.pop(), n.length === 0)
            return r;
        } else
          return this.errors.push(nn.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 24)
        if (b1(n, 20))
          n.pop();
        else
          return this.errors.push(nn.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 30)
        return this.errors.push(nn.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      r.push(this._advance());
    }
  }
  _getText(e) {
    let r = e.parts[0];
    if (r.length > 0 && r[0] == `
`) {
      let n = this._getClosestParentElement();
      n != null && n.children.length == 0 && this.getTagDefinition(n.name).ignoreFirstLf && (r = r.substring(1));
    }
    return r;
  }
  _consumeText(e) {
    let r = [e], n = e.sourceSpan, i = e.parts[0];
    if (i.length > 0 && i[0] === `
`) {
      let s = this._getContainer();
      s != null && s.children.length === 0 && this.getTagDefinition(s.name).ignoreFirstLf && (i = i.substring(1), r[0] = { type: e.type, sourceSpan: e.sourceSpan, parts: [i] });
    }
    for (; this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9; )
      e = this._advance(), r.push(e), e.type === 8 ? i += e.parts.join("").replace(/&([^;]+);/g, D1) : e.type === 9 ? i += e.parts[0] : i += e.parts.join("");
    if (i.length > 0) {
      let s = e.sourceSpan;
      this._addToParent(new RN(i, new je(n.start, s.end, n.fullStart, n.details), r));
    }
  }
  _closeVoidElement() {
    let e = this._getContainer();
    e instanceof Vi && this.getTagDefinition(e.name).isVoid && this._containerStack.pop();
  }
  _consumeStartTag(e) {
    let [r, n] = e.parts, i = [];
    for (; this._peek.type === 14; )
      i.push(this._consumeAttr(this._advance()));
    let s = this._getElementFullName(r, n, this._getClosestParentElement()), a = !1;
    if (this._peek.type === 2) {
      this._advance(), a = !0;
      let g = this.getTagDefinition(s);
      this.canSelfClose || g.canSelfClose || Yc(s) !== null || g.isVoid || this.errors.push(nn.create(s, e.sourceSpan, `Only void, custom and foreign elements can be self closed "${e.parts[1]}"`));
    } else
      this._peek.type === 1 && (this._advance(), a = !1);
    let o = this._peek.sourceSpan.fullStart, u = new je(e.sourceSpan.start, o, e.sourceSpan.fullStart), c = new je(e.sourceSpan.start, o, e.sourceSpan.fullStart), h = new je(e.sourceSpan.start.moveBy(1), e.sourceSpan.end), p = new Vi(s, i, [], u, c, void 0, h), m = this._getContainer();
    this._pushContainer(p, m instanceof Vi && this.getTagDefinition(m.name).isClosedByChild(p.name)), a ? this._popContainer(s, Vi, u) : e.type === 4 && (this._popContainer(s, Vi, null), this.errors.push(nn.create(s, u, `Opening tag "${s}" not terminated.`)));
  }
  _pushContainer(e, r) {
    r && this._containerStack.pop(), this._addToParent(e), this._containerStack.push(e);
  }
  _consumeEndTag(e) {
    let r = this.allowHtmComponentClosingTags && e.parts.length === 0 ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getClosestParentElement());
    if (r && this.getTagDefinition(r).isVoid)
      this.errors.push(nn.create(r, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
    else if (!this._popContainer(r, Vi, e.sourceSpan)) {
      let n = `Unexpected closing tag "${r}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
      this.errors.push(nn.create(r, e.sourceSpan, n));
    }
  }
  _popContainer(e, r, n) {
    let i = !1;
    for (let s = this._containerStack.length - 1; s >= 0; s--) {
      let a = this._containerStack[s];
      if (Yc(a.name) ? a.name === e : (e == null || a.name.toLowerCase() === e.toLowerCase()) && a instanceof r)
        return a.endSourceSpan = n, a.sourceSpan.end = n !== null ? n.end : a.sourceSpan.end, this._containerStack.splice(s, this._containerStack.length - s), !i;
      (a instanceof Ta || a instanceof Vi && !this.getTagDefinition(a.name).closedByParent) && (i = !0);
    }
    return !1;
  }
  _consumeAttr(e) {
    let r = yh(e.parts[0], e.parts[1]), n = e.sourceSpan.end, i;
    this._peek.type === 15 && (i = this._advance());
    let s = "", a = [], o, u;
    if (this._peek.type === 16)
      for (o = this._peek.sourceSpan, u = this._peek.sourceSpan.end; this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9; ) {
        let h = this._advance();
        a.push(h), h.type === 17 ? s += h.parts.join("").replace(/&([^;]+);/g, D1) : h.type === 9 ? s += h.parts[0] : s += h.parts.join(""), u = n = h.sourceSpan.end;
      }
    this._peek.type === 15 && (u = n = this._advance().sourceSpan.end);
    let c = o && u && new je((i == null ? void 0 : i.sourceSpan.start) ?? o.start, u, (i == null ? void 0 : i.sourceSpan.fullStart) ?? o.fullStart);
    return new qN(r, s, new je(e.sourceSpan.start, n, e.sourceSpan.fullStart), e.sourceSpan, c, a.length > 0 ? a : void 0, void 0);
  }
  _consumeBlockOpen(e) {
    let r = [];
    for (; this._peek.type === 28; ) {
      let o = this._advance();
      r.push(new f1(o.parts[0], o.sourceSpan));
    }
    this._peek.type === 26 && this._advance();
    let n = this._peek.sourceSpan.fullStart, i = new je(e.sourceSpan.start, n, e.sourceSpan.fullStart), s = new je(e.sourceSpan.start, n, e.sourceSpan.fullStart), a = new Ta(e.parts[0], r, [], i, s);
    this._pushContainer(a, !1);
  }
  _consumeBlockClose(e) {
    this._popContainer(null, Ta, e.sourceSpan) || this.errors.push(nn.create(null, e.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
  }
  _consumeIncompleteBlock(e) {
    let r = [];
    for (; this._peek.type === 28; ) {
      let o = this._advance();
      r.push(new f1(o.parts[0], o.sourceSpan));
    }
    let n = this._peek.sourceSpan.fullStart, i = new je(e.sourceSpan.start, n, e.sourceSpan.fullStart), s = new je(e.sourceSpan.start, n, e.sourceSpan.fullStart), a = new Ta(e.parts[0], r, [], i, s);
    this._pushContainer(a, !1), this._popContainer(null, Ta, null), this.errors.push(nn.create(e.parts[0], i, `Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
  }
  _getContainer() {
    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
  }
  _getClosestParentElement() {
    for (let e = this._containerStack.length - 1; e > -1; e--)
      if (this._containerStack[e] instanceof Vi)
        return this._containerStack[e];
    return null;
  }
  _addToParent(e) {
    let r = this._getContainer();
    r === null ? this.rootNodes.push(e) : r.children.push(e);
  }
  _getElementFullName(e, r, n) {
    if (e === "" && (e = this.getTagDefinition(r).implicitNamespacePrefix || "", e === "" && n != null)) {
      let i = Bp(n.name)[1];
      this.getTagDefinition(i).preventNamespaceInheritance || (e = Yc(n.name));
    }
    return yh(e, r);
  }
};
function b1(t, e) {
  return t.length > 0 && t[t.length - 1] === e;
}
function D1(t, e) {
  return Oh[e] !== void 0 ? Oh[e] || t : /^#x[a-f0-9]+$/i.test(e) ? String.fromCodePoint(parseInt(e.slice(2), 16)) : /^#\d+$/.test(e) ? String.fromCodePoint(parseInt(e.slice(1), 10)) : t;
}
var d5 = class extends h5 {
  constructor() {
    super(Jf);
  }
  parse(e, r, n, i = !1, s) {
    return super.parse(e, r, n, i, s);
  }
}, Nd = null, f5 = () => (Nd || (Nd = new d5()), Nd);
function v1(t, e = {}) {
  let { canSelfClose: r = !1, allowHtmComponentClosingTags: n = !1, isTagNameCaseSensitive: i = !1, getTagContentType: s, tokenizeAngularBlocks: a = !1 } = e;
  return f5().parse(t, "angular-html-parser", { tokenizeExpansionForms: a, interpolationConfig: void 0, canSelfClose: r, allowHtmComponentClosingTags: n, tokenizeBlocks: a }, i, s);
}
function m5(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var g5 = m5, y5 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
function O5(t) {
  let e = t.match(y5);
  if (!e)
    return { content: t };
  let { startDelimiter: r, language: n, value: i = "", endDelimiter: s } = e.groups, a = n.trim() || "yaml";
  if (r === "+++" && (a = "toml"), a !== "yaml" && r !== s)
    return { content: t };
  let [o] = e;
  return { frontMatter: { type: "front-matter", lang: a, value: i, startDelimiter: r, endDelimiter: s, raw: o.replace(/\n$/, "") }, content: Gr(!1, o, /[^\n]/g, " ") + t.slice(o.length) };
}
var x5 = O5, uc = { attrs: !0, children: !0, cases: !0, expression: !0 }, S1 = /* @__PURE__ */ new Set(["parent"]), b5 = class cl {
  constructor(e = {}) {
    for (let r of /* @__PURE__ */ new Set([...S1, ...Object.keys(e)]))
      this.setProperty(r, e[r]);
  }
  setProperty(e, r) {
    if (this[e] !== r) {
      if (e in uc && (r = r.map((n) => this.createChild(n))), !S1.has(e)) {
        this[e] = r;
        return;
      }
      Object.defineProperty(this, e, { value: r, enumerable: !1, configurable: !0 });
    }
  }
  map(e) {
    let r;
    for (let n in uc) {
      let i = this[n];
      if (i) {
        let s = D5(i, (a) => a.map(e));
        r !== i && (r || (r = new cl({ parent: this.parent })), r.setProperty(n, s));
      }
    }
    if (r)
      for (let n in this)
        n in uc || (r[n] = this[n]);
    return e(r || this);
  }
  walk(e) {
    for (let r in uc) {
      let n = this[r];
      if (n)
        for (let i = 0; i < n.length; i++)
          n[i].walk(e);
    }
    e(this);
  }
  createChild(e) {
    let r = e instanceof cl ? e.clone() : new cl(e);
    return r.setProperty("parent", this), r;
  }
  insertChildBefore(e, r) {
    this.children.splice(this.children.indexOf(e), 0, this.createChild(r));
  }
  removeChild(e) {
    this.children.splice(this.children.indexOf(e), 1);
  }
  replaceChild(e, r) {
    this.children[this.children.indexOf(e)] = this.createChild(r);
  }
  clone() {
    return new cl(this);
  }
  get firstChild() {
    var e;
    return (e = this.children) == null ? void 0 : e[0];
  }
  get lastChild() {
    var e;
    return (e = this.children) == null ? void 0 : e[this.children.length - 1];
  }
  get prev() {
    var e, r;
    return (r = (e = this.parent) == null ? void 0 : e.children) == null ? void 0 : r[this.parent.children.indexOf(this) - 1];
  }
  get next() {
    var e, r;
    return (r = (e = this.parent) == null ? void 0 : e.children) == null ? void 0 : r[this.parent.children.indexOf(this) + 1];
  }
  get rawName() {
    return this.hasExplicitNamespace ? this.fullName : this.name;
  }
  get fullName() {
    return this.namespace ? this.namespace + ":" + this.name : this.name;
  }
  get attrMap() {
    return Object.fromEntries(this.attrs.map((e) => [e.fullName, e.value]));
  }
};
function D5(t, e) {
  let r = t.map(e);
  return r.some((n, i) => n !== t[i]) ? r : t;
}
var v5 = [{ regex: /^(\[if([^\]]*)]>)(.*?)<!\s*\[endif]$/s, parse: w5 }, { regex: /^\[if([^\]]*)]><!$/, parse: C5 }, { regex: /^<!\s*\[endif]$/, parse: E5 }];
function S5(t, e) {
  if (t.value)
    for (let { regex: r, parse: n } of v5) {
      let i = t.value.match(r);
      if (i)
        return n(t, e, i);
    }
  return null;
}
function w5(t, e, r) {
  let [, n, i, s] = r, a = 4 + n.length, o = t.sourceSpan.start.moveBy(a), u = o.moveBy(s.length), [c, h] = (() => {
    try {
      return [!0, e(s, o).children];
    } catch {
      return [!1, [{ type: "text", value: s, sourceSpan: new je(o, u) }]];
    }
  })();
  return { type: "ieConditionalComment", complete: c, children: h, condition: Gr(!1, i.trim(), /\s+/g, " "), sourceSpan: t.sourceSpan, startSourceSpan: new je(t.sourceSpan.start, o), endSourceSpan: new je(u, t.sourceSpan.end) };
}
function C5(t, e, r) {
  let [, n] = r;
  return { type: "ieConditionalStartComment", condition: Gr(!1, n.trim(), /\s+/g, " "), sourceSpan: t.sourceSpan };
}
function E5(t) {
  return { type: "ieConditionalEndComment", sourceSpan: t.sourceSpan };
}
var _d = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set(["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "slot", "spellcheck", "style", "tabindex", "title", "translate"])], ["a", /* @__PURE__ */ new Set(["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"])], ["applet", /* @__PURE__ */ new Set(["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"])], ["area", /* @__PURE__ */ new Set(["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"])], ["audio", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"])], ["base", /* @__PURE__ */ new Set(["href", "target"])], ["basefont", /* @__PURE__ */ new Set(["color", "face", "size"])], ["blockquote", /* @__PURE__ */ new Set(["cite"])], ["body", /* @__PURE__ */ new Set(["alink", "background", "bgcolor", "link", "text", "vlink"])], ["br", /* @__PURE__ */ new Set(["clear"])], ["button", /* @__PURE__ */ new Set(["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "popovertarget", "popovertargetaction", "type", "value"])], ["canvas", /* @__PURE__ */ new Set(["height", "width"])], ["caption", /* @__PURE__ */ new Set(["align"])], ["col", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["colgroup", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["data", /* @__PURE__ */ new Set(["value"])], ["del", /* @__PURE__ */ new Set(["cite", "datetime"])], ["details", /* @__PURE__ */ new Set(["name", "open"])], ["dialog", /* @__PURE__ */ new Set(["open"])], ["dir", /* @__PURE__ */ new Set(["compact"])], ["div", /* @__PURE__ */ new Set(["align"])], ["dl", /* @__PURE__ */ new Set(["compact"])], ["embed", /* @__PURE__ */ new Set(["height", "src", "type", "width"])], ["fieldset", /* @__PURE__ */ new Set(["disabled", "form", "name"])], ["font", /* @__PURE__ */ new Set(["color", "face", "size"])], ["form", /* @__PURE__ */ new Set(["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"])], ["frame", /* @__PURE__ */ new Set(["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"])], ["frameset", /* @__PURE__ */ new Set(["cols", "rows"])], ["h1", /* @__PURE__ */ new Set(["align"])], ["h2", /* @__PURE__ */ new Set(["align"])], ["h3", /* @__PURE__ */ new Set(["align"])], ["h4", /* @__PURE__ */ new Set(["align"])], ["h5", /* @__PURE__ */ new Set(["align"])], ["h6", /* @__PURE__ */ new Set(["align"])], ["head", /* @__PURE__ */ new Set(["profile"])], ["hr", /* @__PURE__ */ new Set(["align", "noshade", "size", "width"])], ["html", /* @__PURE__ */ new Set(["manifest", "version"])], ["iframe", /* @__PURE__ */ new Set(["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"])], ["img", /* @__PURE__ */ new Set(["align", "alt", "border", "crossorigin", "decoding", "fetchpriority", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"])], ["input", /* @__PURE__ */ new Set(["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "popovertarget", "popovertargetaction", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"])], ["ins", /* @__PURE__ */ new Set(["cite", "datetime"])], ["isindex", /* @__PURE__ */ new Set(["prompt"])], ["label", /* @__PURE__ */ new Set(["for", "form"])], ["legend", /* @__PURE__ */ new Set(["align"])], ["li", /* @__PURE__ */ new Set(["type", "value"])], ["link", /* @__PURE__ */ new Set(["as", "blocking", "charset", "color", "crossorigin", "disabled", "fetchpriority", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"])], ["map", /* @__PURE__ */ new Set(["name"])], ["menu", /* @__PURE__ */ new Set(["compact"])], ["meta", /* @__PURE__ */ new Set(["charset", "content", "http-equiv", "media", "name", "scheme"])], ["meter", /* @__PURE__ */ new Set(["high", "low", "max", "min", "optimum", "value"])], ["object", /* @__PURE__ */ new Set(["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"])], ["ol", /* @__PURE__ */ new Set(["compact", "reversed", "start", "type"])], ["optgroup", /* @__PURE__ */ new Set(["disabled", "label"])], ["option", /* @__PURE__ */ new Set(["disabled", "label", "selected", "value"])], ["output", /* @__PURE__ */ new Set(["for", "form", "name"])], ["p", /* @__PURE__ */ new Set(["align"])], ["param", /* @__PURE__ */ new Set(["name", "type", "value", "valuetype"])], ["pre", /* @__PURE__ */ new Set(["width"])], ["progress", /* @__PURE__ */ new Set(["max", "value"])], ["q", /* @__PURE__ */ new Set(["cite"])], ["script", /* @__PURE__ */ new Set(["async", "blocking", "charset", "crossorigin", "defer", "fetchpriority", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"])], ["select", /* @__PURE__ */ new Set(["autocomplete", "disabled", "form", "multiple", "name", "required", "size"])], ["slot", /* @__PURE__ */ new Set(["name"])], ["source", /* @__PURE__ */ new Set(["height", "media", "sizes", "src", "srcset", "type", "width"])], ["style", /* @__PURE__ */ new Set(["blocking", "media", "type"])], ["table", /* @__PURE__ */ new Set(["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"])], ["tbody", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["td", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["template", /* @__PURE__ */ new Set(["shadowrootdelegatesfocus", "shadowrootmode"])], ["textarea", /* @__PURE__ */ new Set(["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"])], ["tfoot", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["th", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["thead", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["time", /* @__PURE__ */ new Set(["datetime"])], ["tr", /* @__PURE__ */ new Set(["align", "bgcolor", "char", "charoff", "valign"])], ["track", /* @__PURE__ */ new Set(["default", "kind", "label", "src", "srclang"])], ["ul", /* @__PURE__ */ new Set(["compact", "type"])], ["video", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"])]]), A5 = /* @__PURE__ */ new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
function T5(t) {
  if (t.type === "block") {
    if (t.name = Gr(!1, t.name.toLowerCase(), /\s+/g, " ").trim(), t.type = "angularControlFlowBlock", !ny(t.parameters)) {
      delete t.parameters;
      return;
    }
    for (let e of t.parameters)
      e.type = "angularControlFlowBlockParameter";
    t.parameters = { type: "angularControlFlowBlockParameters", children: t.parameters, sourceSpan: new je(t.parameters[0].sourceSpan.start, Ou(!1, t.parameters, -1).sourceSpan.end) };
  }
}
function k5(t) {
  (t.type === "plural" || t.type === "select") && (t.clause = t.type, t.type = "angularIcuExpression"), t.type === "expansionCase" && (t.type = "angularIcuCase");
}
function P2(t, e, r) {
  let { name: n, canSelfClose: i = !0, normalizeTagName: s = !1, normalizeAttributeName: a = !1, allowHtmComponentClosingTags: o = !1, isTagNameCaseSensitive: u = !1, shouldParseAsRawText: c } = e, { rootNodes: h, errors: p } = v1(t, { canSelfClose: i, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u, getTagContentType: c ? (...x) => c(...x) ? Pn.RAW_TEXT : void 0 : void 0, tokenizeAngularBlocks: n === "angular" ? !0 : void 0 });
  if (n === "vue") {
    if (h.some((C) => C.type === "docType" && C.value === "html" || C.type === "element" && C.name.toLowerCase() === "html"))
      return P2(t, $2, r);
    let x, w = () => x ?? (x = v1(t, { canSelfClose: i, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u })), T = (C) => w().rootNodes.find(({ startSourceSpan: A }) => A && A.start.offset === C.startSourceSpan.start.offset) ?? C;
    for (let [C, A] of h.entries()) {
      let { endSourceSpan: P, startSourceSpan: $ } = A;
      if (P === null)
        p = w().errors, h[C] = T(A);
      else if (P5(A, r)) {
        let B = w().errors.find((_) => _.span.start.offset > $.start.offset && _.span.start.offset < P.end.offset);
        B && w1(B), h[C] = T(A);
      }
    }
  }
  p.length > 0 && w1(p[0]);
  let m = (x) => {
    let w = x.name.startsWith(":") ? x.name.slice(1).split(":")[0] : null, T = x.nameSpan.toString(), C = w !== null && T.startsWith(`${w}:`), A = C ? T.slice(w.length + 1) : T;
    x.name = A, x.namespace = w, x.hasExplicitNamespace = C;
  }, g = (x) => {
    switch (x.type) {
      case "element":
        m(x);
        for (let w of x.attrs)
          m(w), w.valueSpan ? (w.value = w.valueSpan.toString(), /["']/.test(w.value[0]) && (w.value = w.value.slice(1, -1))) : w.value = null;
        break;
      case "comment":
        x.value = x.sourceSpan.toString().slice(4, -3);
        break;
      case "text":
        x.value = x.sourceSpan.toString();
        break;
    }
  }, O = (x, w) => {
    let T = x.toLowerCase();
    return w(T) ? T : x;
  }, b = (x) => {
    if (x.type === "element" && (s && (!x.namespace || x.namespace === x.tagDefinition.implicitNamespacePrefix || Ll(x)) && (x.name = O(x.name, (w) => A5.has(w))), a))
      for (let w of x.attrs)
        w.namespace || (w.name = O(w.name, (T) => _d.has(x.name) && (_d.get("*").has(T) || _d.get(x.name).has(T))));
  }, D = (x) => {
    x.sourceSpan && x.endSourceSpan && (x.sourceSpan = new je(x.sourceSpan.start, x.endSourceSpan.end));
  }, S = (x) => {
    if (x.type === "element") {
      let w = Jf(u ? x.name : x.name.toLowerCase());
      !x.namespace || x.namespace === w.implicitNamespacePrefix || Ll(x) ? x.tagDefinition = w : x.tagDefinition = Jf("");
    }
  };
  return w2(new class extends YN {
    visitExpansionCase(x, w) {
      n === "angular" && this.visitChildren(w, (T) => {
        T(x.expression);
      });
    }
    visit(x) {
      g(x), S(x), b(x), D(x);
    }
  }(), h), h;
}
function P5(t, e) {
  var r;
  if (t.type !== "element" || t.name !== "template")
    return !1;
  let n = (r = t.attrs.find((i) => i.name === "lang")) == null ? void 0 : r.value;
  return !n || Ep(e, { language: n }) === "html";
}
function w1(t) {
  let { msg: e, span: { start: r, end: n } } = t;
  throw g5(e, { loc: { start: { line: r.line + 1, column: r.col + 1 }, end: { line: n.line + 1, column: n.col + 1 } }, cause: t });
}
function F2(t, e, r = {}, n = !0) {
  let { frontMatter: i, content: s } = n ? x5(t) : { frontMatter: null, content: t }, a = new b2(t, r.filepath), o = new Hf(a, 0, 0, 0), u = o.moveBy(t.length), c = { type: "root", sourceSpan: new je(o, u), children: P2(s, e, r) };
  if (i) {
    let m = new Hf(a, 0, 0, 0), g = m.moveBy(i.raw.length);
    i.sourceSpan = new je(m, g), c.children.unshift(i);
  }
  let h = new b5(c), p = (m, g) => {
    let { offset: O } = g, b = Gr(!1, t.slice(0, O), /[^\n\r]/g, " "), D = F2(b + m, e, r, !1);
    D.sourceSpan = new je(g, Ou(!1, D.children, -1).sourceSpan.end);
    let S = D.children[0];
    return S.length === O ? D.children.shift() : (S.sourceSpan = new je(S.sourceSpan.start.moveBy(O), S.sourceSpan.end), S.value = S.value.slice(O)), D;
  };
  return h.walk((m) => {
    if (m.type === "comment") {
      let g = S5(m, p);
      g && m.parent.replaceChild(m, g);
    }
    T5(m), k5(m);
  }), h;
}
function Ip(t) {
  return { parse: (e, r) => F2(e, t, r), hasPragma: K8, astFormat: "html", locStart: kp, locEnd: Pp };
}
var $2 = { name: "html", normalizeTagName: !0, normalizeAttributeName: !0, allowHtmComponentClosingTags: !0 }, F5 = Ip($2), $5 = Ip({ name: "angular" }), B5 = Ip({ name: "vue", isTagNameCaseSensitive: !0, shouldParseAsRawText(t, e, r, n) {
  return t.toLowerCase() !== "html" && !r && (t !== "template" || n.some(({ name: i, value: s }) => i === "lang" && s !== "html" && s !== "" && s !== void 0));
} }), I5 = Ip({ name: "lwc", canSelfClose: !1 }), N5 = { html: AN }, _5 = Zv, Q5 = Object.create, hy = Object.defineProperty, M5 = Object.getOwnPropertyDescriptor, L5 = Object.getOwnPropertyNames, R5 = Object.getPrototypeOf, j5 = Object.prototype.hasOwnProperty, re = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), B2 = (t, e) => {
  for (var r in e)
    hy(t, r, { get: e[r], enumerable: !0 });
}, Z5 = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of L5(e))
      !j5.call(t, i) && i !== r && hy(t, i, { get: () => e[i], enumerable: !(n = M5(e, i)) || n.enumerable });
  return t;
}, da = (t, e, r) => (r = t != null ? Q5(R5(t)) : {}, Z5(e || !t || !t.__esModule ? hy(r, "default", { value: t, enumerable: !0 }) : r, t)), W5 = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = h, t.parse = m, t.parseWithComments = g, t.print = O, t.strip = p;
  var e = /\*\/$/, r = /^\/\*\*?/, n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, s = /^(\r?\n)+/, a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, o = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, u = /(\r?\n|^) *\* ?/g, c = [];
  function h(D) {
    let S = D.match(n);
    return S ? S[0].trimLeft() : "";
  }
  function p(D) {
    let S = D.match(n);
    return S && S[0] ? D.substring(S[0].length) : D;
  }
  function m(D) {
    return g(D).pragmas;
  }
  function g(D) {
    let S = `
`;
    D = D.replace(r, "").replace(e, "").replace(u, "$1");
    let x = "";
    for (; x !== D; )
      x = D, D = D.replace(a, `${S}$1 $2${S}`);
    D = D.replace(s, "").trimRight();
    let w = /* @__PURE__ */ Object.create(null), T = D.replace(o, "").replace(s, "").trimRight(), C;
    for (; C = o.exec(D); ) {
      let A = C[2].replace(i, "");
      typeof w[C[1]] == "string" || Array.isArray(w[C[1]]) ? w[C[1]] = c.concat(w[C[1]], A) : w[C[1]] = A;
    }
    return { comments: T, pragmas: w };
  }
  function O({ comments: D = "", pragmas: S = {} }) {
    let x = `
`, w = "/**", T = " *", C = " */", A = Object.keys(S), P = A.flatMap((B) => b(B, S[B])).map((B) => `${T} ${B}${x}`).join("");
    if (!D) {
      if (A.length === 0)
        return "";
      if (A.length === 1 && !Array.isArray(S[A[0]])) {
        let B = S[A[0]];
        return `${w} ${b(A[0], B)[0]}${C}`;
      }
    }
    let $ = D.split(x).map((B) => `${T} ${B}`).join(x) + x;
    return w + x + (D ? $ : "") + (D && A.length ? T + x : "") + P + C;
  }
  function b(D, S) {
    return c.concat(S).map((x) => `@${D} ${x}`.trim());
  }
}), py = re((t, e) => {
  e.exports.isClean = Symbol("isClean"), e.exports.my = Symbol("my");
}), q5 = re((t, e) => {
  var r = String, n = function() {
    return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r };
  };
  e.exports = n(), e.exports.createColors = n;
}), I2 = re(() => {
}), dy = re((t, e) => {
  var r = q5(), n = I2(), i = class N2 extends Error {
    constructor(a, o, u, c, h, p) {
      super(a), this.name = "CssSyntaxError", this.reason = a, h && (this.file = h), c && (this.source = c), p && (this.plugin = p), typeof o < "u" && typeof u < "u" && (typeof o == "number" ? (this.line = o, this.column = u) : (this.line = o.line, this.column = o.column, this.endLine = u.line, this.endColumn = u.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, N2);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(a) {
      if (!this.source)
        return "";
      let o = this.source;
      a == null && (a = r.isColorSupported), n && a && (o = n(o));
      let u = o.split(/\r?\n/), c = Math.max(this.line - 3, 0), h = Math.min(this.line + 2, u.length), p = String(h).length, m, g;
      if (a) {
        let { bold: O, gray: b, red: D } = r.createColors(!0);
        m = (S) => O(D(S)), g = (S) => b(S);
      } else
        m = g = (O) => O;
      return u.slice(c, h).map((O, b) => {
        let D = c + 1 + b, S = " " + (" " + D).slice(-p) + " | ";
        if (D === this.line) {
          let x = g(S.replace(/\d/g, " ")) + O.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return m(">") + g(S) + O + `
 ` + x + m("^");
        }
        return " " + g(S) + O;
      }).join(`
`);
    }
    toString() {
      let a = this.showSourceCode();
      return a && (a = `

` + a + `
`), this.name + ": " + this.message + a;
    }
  };
  e.exports = i, i.default = i;
}), fy = re((t, e) => {
  var r = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: !1 };
  function n(s) {
    return s[0].toUpperCase() + s.slice(1);
  }
  var i = class {
    constructor(s) {
      this.builder = s;
    }
    atrule(s, a) {
      let o = "@" + s.name, u = s.params ? this.rawValue(s, "params") : "";
      if (typeof s.raws.afterName < "u" ? o += s.raws.afterName : u && (o += " "), s.nodes)
        this.block(s, o + u);
      else {
        let c = (s.raws.between || "") + (a ? ";" : "");
        this.builder(o + u + c, s);
      }
    }
    beforeAfter(s, a) {
      let o;
      s.type === "decl" ? o = this.raw(s, null, "beforeDecl") : s.type === "comment" ? o = this.raw(s, null, "beforeComment") : a === "before" ? o = this.raw(s, null, "beforeRule") : o = this.raw(s, null, "beforeClose");
      let u = s.parent, c = 0;
      for (; u && u.type !== "root"; )
        c += 1, u = u.parent;
      if (o.includes(`
`)) {
        let h = this.raw(s, null, "indent");
        if (h.length)
          for (let p = 0; p < c; p++)
            o += h;
      }
      return o;
    }
    block(s, a) {
      let o = this.raw(s, "between", "beforeOpen");
      this.builder(a + o + "{", s, "start");
      let u;
      s.nodes && s.nodes.length ? (this.body(s), u = this.raw(s, "after")) : u = this.raw(s, "after", "emptyBody"), u && this.builder(u), this.builder("}", s, "end");
    }
    body(s) {
      let a = s.nodes.length - 1;
      for (; a > 0 && s.nodes[a].type === "comment"; )
        a -= 1;
      let o = this.raw(s, "semicolon");
      for (let u = 0; u < s.nodes.length; u++) {
        let c = s.nodes[u], h = this.raw(c, "before");
        h && this.builder(h), this.stringify(c, a !== u || o);
      }
    }
    comment(s) {
      let a = this.raw(s, "left", "commentLeft"), o = this.raw(s, "right", "commentRight");
      this.builder("/*" + a + s.text + o + "*/", s);
    }
    decl(s, a) {
      let o = this.raw(s, "between", "colon"), u = s.prop + o + this.rawValue(s, "value");
      s.important && (u += s.raws.important || " !important"), a && (u += ";"), this.builder(u, s);
    }
    document(s) {
      this.body(s);
    }
    raw(s, a, o) {
      let u;
      if (o || (o = a), a && (u = s.raws[a], typeof u < "u"))
        return u;
      let c = s.parent;
      if (o === "before" && (!c || c.type === "root" && c.first === s || c && c.type === "document"))
        return "";
      if (!c)
        return r[o];
      let h = s.root();
      if (h.rawCache || (h.rawCache = {}), typeof h.rawCache[o] < "u")
        return h.rawCache[o];
      if (o === "before" || o === "after")
        return this.beforeAfter(s, o);
      {
        let p = "raw" + n(o);
        this[p] ? u = this[p](h, s) : h.walk((m) => {
          if (u = m.raws[a], typeof u < "u")
            return !1;
        });
      }
      return typeof u > "u" && (u = r[o]), h.rawCache[o] = u, u;
    }
    rawBeforeClose(s) {
      let a;
      return s.walk((o) => {
        if (o.nodes && o.nodes.length > 0 && typeof o.raws.after < "u")
          return a = o.raws.after, a.includes(`
`) && (a = a.replace(/[^\n]+$/, "")), !1;
      }), a && (a = a.replace(/\S/g, "")), a;
    }
    rawBeforeComment(s, a) {
      let o;
      return s.walkComments((u) => {
        if (typeof u.raws.before < "u")
          return o = u.raws.before, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), !1;
      }), typeof o > "u" ? o = this.raw(a, null, "beforeDecl") : o && (o = o.replace(/\S/g, "")), o;
    }
    rawBeforeDecl(s, a) {
      let o;
      return s.walkDecls((u) => {
        if (typeof u.raws.before < "u")
          return o = u.raws.before, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), !1;
      }), typeof o > "u" ? o = this.raw(a, null, "beforeRule") : o && (o = o.replace(/\S/g, "")), o;
    }
    rawBeforeOpen(s) {
      let a;
      return s.walk((o) => {
        if (o.type !== "decl" && (a = o.raws.between, typeof a < "u"))
          return !1;
      }), a;
    }
    rawBeforeRule(s) {
      let a;
      return s.walk((o) => {
        if (o.nodes && (o.parent !== s || s.first !== o) && typeof o.raws.before < "u")
          return a = o.raws.before, a.includes(`
`) && (a = a.replace(/[^\n]+$/, "")), !1;
      }), a && (a = a.replace(/\S/g, "")), a;
    }
    rawColon(s) {
      let a;
      return s.walkDecls((o) => {
        if (typeof o.raws.between < "u")
          return a = o.raws.between.replace(/[^\s:]/g, ""), !1;
      }), a;
    }
    rawEmptyBody(s) {
      let a;
      return s.walk((o) => {
        if (o.nodes && o.nodes.length === 0 && (a = o.raws.after, typeof a < "u"))
          return !1;
      }), a;
    }
    rawIndent(s) {
      if (s.raws.indent)
        return s.raws.indent;
      let a;
      return s.walk((o) => {
        let u = o.parent;
        if (u && u !== s && u.parent && u.parent === s && typeof o.raws.before < "u") {
          let c = o.raws.before.split(`
`);
          return a = c[c.length - 1], a = a.replace(/\S/g, ""), !1;
        }
      }), a;
    }
    rawSemicolon(s) {
      let a;
      return s.walk((o) => {
        if (o.nodes && o.nodes.length && o.last.type === "decl" && (a = o.raws.semicolon, typeof a < "u"))
          return !1;
      }), a;
    }
    rawValue(s, a) {
      let o = s[a], u = s.raws[a];
      return u && u.value === o ? u.raw : o;
    }
    root(s) {
      this.body(s), s.raws.after && this.builder(s.raws.after);
    }
    rule(s) {
      this.block(s, this.rawValue(s, "selector")), s.raws.ownSemicolon && this.builder(s.raws.ownSemicolon, s, "end");
    }
    stringify(s, a) {
      if (!this[s.type])
        throw new Error("Unknown AST node type " + s.type + ". Maybe you need to change PostCSS stringifier.");
      this[s.type](s, a);
    }
  };
  e.exports = i, i.default = i;
}), Np = re((t, e) => {
  var r = fy();
  function n(i, s) {
    new r(s).stringify(i);
  }
  e.exports = n, n.default = n;
}), _p = re((t, e) => {
  var { isClean: r, my: n } = py(), i = dy(), s = fy(), a = Np();
  function o(c, h) {
    let p = new c.constructor();
    for (let m in c) {
      if (!Object.prototype.hasOwnProperty.call(c, m) || m === "proxyCache")
        continue;
      let g = c[m], O = typeof g;
      m === "parent" && O === "object" ? h && (p[m] = h) : m === "source" ? p[m] = g : Array.isArray(g) ? p[m] = g.map((b) => o(b, p)) : (O === "object" && g !== null && (g = o(g)), p[m] = g);
    }
    return p;
  }
  var u = class {
    constructor(c = {}) {
      this.raws = {}, this[r] = !1, this[n] = !0;
      for (let h in c)
        if (h === "nodes") {
          this.nodes = [];
          for (let p of c[h])
            typeof p.clone == "function" ? this.append(p.clone()) : this.append(p);
        } else
          this[h] = c[h];
    }
    addToError(c) {
      if (c.postcssNode = this, c.stack && this.source && /\n\s{4}at /.test(c.stack)) {
        let h = this.source;
        c.stack = c.stack.replace(/\n\s{4}at /, `$&${h.input.from}:${h.start.line}:${h.start.column}$&`);
      }
      return c;
    }
    after(c) {
      return this.parent.insertAfter(this, c), this;
    }
    assign(c = {}) {
      for (let h in c)
        this[h] = c[h];
      return this;
    }
    before(c) {
      return this.parent.insertBefore(this, c), this;
    }
    cleanRaws(c) {
      delete this.raws.before, delete this.raws.after, c || delete this.raws.between;
    }
    clone(c = {}) {
      let h = o(this);
      for (let p in c)
        h[p] = c[p];
      return h;
    }
    cloneAfter(c = {}) {
      let h = this.clone(c);
      return this.parent.insertAfter(this, h), h;
    }
    cloneBefore(c = {}) {
      let h = this.clone(c);
      return this.parent.insertBefore(this, h), h;
    }
    error(c, h = {}) {
      if (this.source) {
        let { end: p, start: m } = this.rangeBy(h);
        return this.source.input.error(c, { column: m.column, line: m.line }, { column: p.column, line: p.line }, h);
      }
      return new i(c);
    }
    getProxyProcessor() {
      return { get(c, h) {
        return h === "proxyOf" ? c : h === "root" ? () => c.root().toProxy() : c[h];
      }, set(c, h, p) {
        return c[h] === p || (c[h] = p, (h === "prop" || h === "value" || h === "name" || h === "params" || h === "important" || h === "text") && c.markDirty()), !0;
      } };
    }
    markDirty() {
      if (this[r]) {
        this[r] = !1;
        let c = this;
        for (; c = c.parent; )
          c[r] = !1;
      }
    }
    next() {
      if (!this.parent)
        return;
      let c = this.parent.index(this);
      return this.parent.nodes[c + 1];
    }
    positionBy(c, h) {
      let p = this.source.start;
      if (c.index)
        p = this.positionInside(c.index, h);
      else if (c.word) {
        h = this.toString();
        let m = h.indexOf(c.word);
        m !== -1 && (p = this.positionInside(m, h));
      }
      return p;
    }
    positionInside(c, h) {
      let p = h || this.toString(), m = this.source.start.column, g = this.source.start.line;
      for (let O = 0; O < c; O++)
        p[O] === `
` ? (m = 1, g += 1) : m += 1;
      return { column: m, line: g };
    }
    prev() {
      if (!this.parent)
        return;
      let c = this.parent.index(this);
      return this.parent.nodes[c - 1];
    }
    rangeBy(c) {
      let h = { column: this.source.start.column, line: this.source.start.line }, p = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: h.column + 1, line: h.line };
      if (c.word) {
        let m = this.toString(), g = m.indexOf(c.word);
        g !== -1 && (h = this.positionInside(g, m), p = this.positionInside(g + c.word.length, m));
      } else
        c.start ? h = { column: c.start.column, line: c.start.line } : c.index && (h = this.positionInside(c.index)), c.end ? p = { column: c.end.column, line: c.end.line } : c.endIndex ? p = this.positionInside(c.endIndex) : c.index && (p = this.positionInside(c.index + 1));
      return (p.line < h.line || p.line === h.line && p.column <= h.column) && (p = { column: h.column + 1, line: h.line }), { end: p, start: h };
    }
    raw(c, h) {
      return new s().raw(this, c, h);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith(...c) {
      if (this.parent) {
        let h = this, p = !1;
        for (let m of c)
          m === this ? p = !0 : p ? (this.parent.insertAfter(h, m), h = m) : this.parent.insertBefore(h, m);
        p || this.remove();
      }
      return this;
    }
    root() {
      let c = this;
      for (; c.parent && c.parent.type !== "document"; )
        c = c.parent;
      return c;
    }
    toJSON(c, h) {
      let p = {}, m = h == null;
      h = h || /* @__PURE__ */ new Map();
      let g = 0;
      for (let O in this) {
        if (!Object.prototype.hasOwnProperty.call(this, O) || O === "parent" || O === "proxyCache")
          continue;
        let b = this[O];
        if (Array.isArray(b))
          p[O] = b.map((D) => typeof D == "object" && D.toJSON ? D.toJSON(null, h) : D);
        else if (typeof b == "object" && b.toJSON)
          p[O] = b.toJSON(null, h);
        else if (O === "source") {
          let D = h.get(b.input);
          D == null && (D = g, h.set(b.input, g), g++), p[O] = { end: b.end, inputId: D, start: b.start };
        } else
          p[O] = b;
      }
      return m && (p.inputs = [...h.keys()].map((O) => O.toJSON())), p;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(c = a) {
      c.stringify && (c = c.stringify);
      let h = "";
      return c(this, (p) => {
        h += p;
      }), h;
    }
    warn(c, h, p) {
      let m = { node: this };
      for (let g in p)
        m[g] = p[g];
      return c.warn(h, m);
    }
    get proxyOf() {
      return this;
    }
  };
  e.exports = u, u.default = u;
}), Qp = re((t, e) => {
  var r = _p(), n = class extends r {
    constructor(i) {
      i && typeof i.value < "u" && typeof i.value != "string" && (i = { ...i, value: String(i.value) }), super(i), this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
  };
  e.exports = n, n.default = n;
}), Su = re((t, e) => {
  var r = _p(), n = class extends r {
    constructor(i) {
      super(i), this.type = "comment";
    }
  };
  e.exports = n, n.default = n;
}), fa = re((t, e) => {
  var { isClean: r, my: n } = py(), i = Qp(), s = Su(), a = _p(), o, u, c, h;
  function p(O) {
    return O.map((b) => (b.nodes && (b.nodes = p(b.nodes)), delete b.source, b));
  }
  function m(O) {
    if (O[r] = !1, O.proxyOf.nodes)
      for (let b of O.proxyOf.nodes)
        m(b);
  }
  var g = class _2 extends a {
    append(...b) {
      for (let D of b) {
        let S = this.normalize(D, this.last);
        for (let x of S)
          this.proxyOf.nodes.push(x);
      }
      return this.markDirty(), this;
    }
    cleanRaws(b) {
      if (super.cleanRaws(b), this.nodes)
        for (let D of this.nodes)
          D.cleanRaws(b);
    }
    each(b) {
      if (!this.proxyOf.nodes)
        return;
      let D = this.getIterator(), S, x;
      for (; this.indexes[D] < this.proxyOf.nodes.length && (S = this.indexes[D], x = b(this.proxyOf.nodes[S], S), x !== !1); )
        this.indexes[D] += 1;
      return delete this.indexes[D], x;
    }
    every(b) {
      return this.nodes.every(b);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let b = this.lastEach;
      return this.indexes[b] = 0, b;
    }
    getProxyProcessor() {
      return { get(b, D) {
        return D === "proxyOf" ? b : b[D] ? D === "each" || typeof D == "string" && D.startsWith("walk") ? (...S) => b[D](...S.map((x) => typeof x == "function" ? (w, T) => x(w.toProxy(), T) : x)) : D === "every" || D === "some" ? (S) => b[D]((x, ...w) => S(x.toProxy(), ...w)) : D === "root" ? () => b.root().toProxy() : D === "nodes" ? b.nodes.map((S) => S.toProxy()) : D === "first" || D === "last" ? b[D].toProxy() : b[D] : b[D];
      }, set(b, D, S) {
        return b[D] === S || (b[D] = S, (D === "name" || D === "params" || D === "selector") && b.markDirty()), !0;
      } };
    }
    index(b) {
      return typeof b == "number" ? b : (b.proxyOf && (b = b.proxyOf), this.proxyOf.nodes.indexOf(b));
    }
    insertAfter(b, D) {
      let S = this.index(b), x = this.normalize(D, this.proxyOf.nodes[S]).reverse();
      S = this.index(b);
      for (let T of x)
        this.proxyOf.nodes.splice(S + 1, 0, T);
      let w;
      for (let T in this.indexes)
        w = this.indexes[T], S < w && (this.indexes[T] = w + x.length);
      return this.markDirty(), this;
    }
    insertBefore(b, D) {
      let S = this.index(b), x = S === 0 ? "prepend" : !1, w = this.normalize(D, this.proxyOf.nodes[S], x).reverse();
      S = this.index(b);
      for (let C of w)
        this.proxyOf.nodes.splice(S, 0, C);
      let T;
      for (let C in this.indexes)
        T = this.indexes[C], S <= T && (this.indexes[C] = T + w.length);
      return this.markDirty(), this;
    }
    normalize(b, D) {
      if (typeof b == "string")
        b = p(o(b).nodes);
      else if (Array.isArray(b)) {
        b = b.slice(0);
        for (let S of b)
          S.parent && S.parent.removeChild(S, "ignore");
      } else if (b.type === "root" && this.type !== "document") {
        b = b.nodes.slice(0);
        for (let S of b)
          S.parent && S.parent.removeChild(S, "ignore");
      } else if (b.type)
        b = [b];
      else if (b.prop) {
        if (typeof b.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof b.value != "string" && (b.value = String(b.value)), b = [new i(b)];
      } else if (b.selector)
        b = [new u(b)];
      else if (b.name)
        b = [new c(b)];
      else if (b.text)
        b = [new s(b)];
      else
        throw new Error("Unknown node type in node creation");
      return b.map((S) => (S[n] || _2.rebuild(S), S = S.proxyOf, S.parent && S.parent.removeChild(S), S[r] && m(S), typeof S.raws.before > "u" && D && typeof D.raws.before < "u" && (S.raws.before = D.raws.before.replace(/\S/g, "")), S.parent = this.proxyOf, S));
    }
    prepend(...b) {
      b = b.reverse();
      for (let D of b) {
        let S = this.normalize(D, this.first, "prepend").reverse();
        for (let x of S)
          this.proxyOf.nodes.unshift(x);
        for (let x in this.indexes)
          this.indexes[x] = this.indexes[x] + S.length;
      }
      return this.markDirty(), this;
    }
    push(b) {
      return b.parent = this, this.proxyOf.nodes.push(b), this;
    }
    removeAll() {
      for (let b of this.proxyOf.nodes)
        b.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(b) {
      b = this.index(b), this.proxyOf.nodes[b].parent = void 0, this.proxyOf.nodes.splice(b, 1);
      let D;
      for (let S in this.indexes)
        D = this.indexes[S], D >= b && (this.indexes[S] = D - 1);
      return this.markDirty(), this;
    }
    replaceValues(b, D, S) {
      return S || (S = D, D = {}), this.walkDecls((x) => {
        D.props && !D.props.includes(x.prop) || D.fast && !x.value.includes(D.fast) || (x.value = x.value.replace(b, S));
      }), this.markDirty(), this;
    }
    some(b) {
      return this.nodes.some(b);
    }
    walk(b) {
      return this.each((D, S) => {
        let x;
        try {
          x = b(D, S);
        } catch (w) {
          throw D.addToError(w);
        }
        return x !== !1 && D.walk && (x = D.walk(b)), x;
      });
    }
    walkAtRules(b, D) {
      return D ? b instanceof RegExp ? this.walk((S, x) => {
        if (S.type === "atrule" && b.test(S.name))
          return D(S, x);
      }) : this.walk((S, x) => {
        if (S.type === "atrule" && S.name === b)
          return D(S, x);
      }) : (D = b, this.walk((S, x) => {
        if (S.type === "atrule")
          return D(S, x);
      }));
    }
    walkComments(b) {
      return this.walk((D, S) => {
        if (D.type === "comment")
          return b(D, S);
      });
    }
    walkDecls(b, D) {
      return D ? b instanceof RegExp ? this.walk((S, x) => {
        if (S.type === "decl" && b.test(S.prop))
          return D(S, x);
      }) : this.walk((S, x) => {
        if (S.type === "decl" && S.prop === b)
          return D(S, x);
      }) : (D = b, this.walk((S, x) => {
        if (S.type === "decl")
          return D(S, x);
      }));
    }
    walkRules(b, D) {
      return D ? b instanceof RegExp ? this.walk((S, x) => {
        if (S.type === "rule" && b.test(S.selector))
          return D(S, x);
      }) : this.walk((S, x) => {
        if (S.type === "rule" && S.selector === b)
          return D(S, x);
      }) : (D = b, this.walk((S, x) => {
        if (S.type === "rule")
          return D(S, x);
      }));
    }
    get first() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
  };
  g.registerParse = (O) => {
    o = O;
  }, g.registerRule = (O) => {
    u = O;
  }, g.registerAtRule = (O) => {
    c = O;
  }, g.registerRoot = (O) => {
    h = O;
  }, e.exports = g, g.default = g, g.rebuild = (O) => {
    O.type === "atrule" ? Object.setPrototypeOf(O, c.prototype) : O.type === "rule" ? Object.setPrototypeOf(O, u.prototype) : O.type === "decl" ? Object.setPrototypeOf(O, i.prototype) : O.type === "comment" ? Object.setPrototypeOf(O, s.prototype) : O.type === "root" && Object.setPrototypeOf(O, h.prototype), O[n] = !0, O.nodes && O.nodes.forEach((b) => {
      g.rebuild(b);
    });
  };
}), my = re((t, e) => {
  var r = /[\t\n\f\r "#'()/;[\\\]{}]/g, n = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, i = /.[\r\n"'(/\\]/, s = /[\da-f]/i;
  e.exports = function(a, o = {}) {
    let u = a.css.valueOf(), c = o.ignoreErrors, h, p, m, g, O, b, D, S, x, w, T = u.length, C = 0, A = [], P = [];
    function $() {
      return C;
    }
    function B(J) {
      throw a.error("Unclosed " + J, C);
    }
    function _() {
      return P.length === 0 && C >= T;
    }
    function M(J) {
      if (P.length)
        return P.pop();
      if (C >= T)
        return;
      let R = J ? J.ignoreUnclosed : !1;
      switch (h = u.charCodeAt(C), h) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12: {
          p = C;
          do
            p += 1, h = u.charCodeAt(p);
          while (h === 32 || h === 10 || h === 9 || h === 13 || h === 12);
          w = ["space", u.slice(C, p)], C = p - 1;
          break;
        }
        case 91:
        case 93:
        case 123:
        case 125:
        case 58:
        case 59:
        case 41: {
          let q = String.fromCharCode(h);
          w = [q, q, C];
          break;
        }
        case 40: {
          if (S = A.length ? A.pop()[1] : "", x = u.charCodeAt(C + 1), S === "url" && x !== 39 && x !== 34 && x !== 32 && x !== 10 && x !== 9 && x !== 12 && x !== 13) {
            p = C;
            do {
              if (b = !1, p = u.indexOf(")", p + 1), p === -1)
                if (c || R) {
                  p = C;
                  break;
                } else
                  B("bracket");
              for (D = p; u.charCodeAt(D - 1) === 92; )
                D -= 1, b = !b;
            } while (b);
            w = ["brackets", u.slice(C, p + 1), C, p], C = p;
          } else
            p = u.indexOf(")", C + 1), g = u.slice(C, p + 1), p === -1 || i.test(g) ? w = ["(", "(", C] : (w = ["brackets", g, C, p], C = p);
          break;
        }
        case 39:
        case 34: {
          m = h === 39 ? "'" : '"', p = C;
          do {
            if (b = !1, p = u.indexOf(m, p + 1), p === -1)
              if (c || R) {
                p = C + 1;
                break;
              } else
                B("string");
            for (D = p; u.charCodeAt(D - 1) === 92; )
              D -= 1, b = !b;
          } while (b);
          w = ["string", u.slice(C, p + 1), C, p], C = p;
          break;
        }
        case 64: {
          r.lastIndex = C + 1, r.test(u), r.lastIndex === 0 ? p = u.length - 1 : p = r.lastIndex - 2, w = ["at-word", u.slice(C, p + 1), C, p], C = p;
          break;
        }
        case 92: {
          for (p = C, O = !0; u.charCodeAt(p + 1) === 92; )
            p += 1, O = !O;
          if (h = u.charCodeAt(p + 1), O && h !== 47 && h !== 32 && h !== 10 && h !== 9 && h !== 13 && h !== 12 && (p += 1, s.test(u.charAt(p)))) {
            for (; s.test(u.charAt(p + 1)); )
              p += 1;
            u.charCodeAt(p + 1) === 32 && (p += 1);
          }
          w = ["word", u.slice(C, p + 1), C, p], C = p;
          break;
        }
        default: {
          h === 47 && u.charCodeAt(C + 1) === 42 ? (p = u.indexOf("*/", C + 2) + 1, p === 0 && (c || R ? p = u.length : B("comment")), w = ["comment", u.slice(C, p + 1), C, p], C = p) : (n.lastIndex = C + 1, n.test(u), n.lastIndex === 0 ? p = u.length - 1 : p = n.lastIndex - 2, w = ["word", u.slice(C, p + 1), C, p], A.push(w), C = p);
          break;
        }
      }
      return C++, w;
    }
    function Y(J) {
      P.push(J);
    }
    return { back: Y, endOfFile: _, nextToken: M, position: $ };
  };
}), gy = re((t, e) => {
  var r = fa(), n = class extends r {
    constructor(i) {
      super(i), this.type = "atrule";
    }
    append(...i) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...i);
    }
    prepend(...i) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...i);
    }
  };
  e.exports = n, n.default = n, r.registerAtRule(n);
}), wu = re((t, e) => {
  var r = fa(), n, i, s = class extends r {
    constructor(a) {
      super(a), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(a, o, u) {
      let c = super.normalize(a);
      if (o) {
        if (u === "prepend")
          this.nodes.length > 1 ? o.raws.before = this.nodes[1].raws.before : delete o.raws.before;
        else if (this.first !== o)
          for (let h of c)
            h.raws.before = o.raws.before;
      }
      return c;
    }
    removeChild(a, o) {
      let u = this.index(a);
      return !o && u === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[u].raws.before), super.removeChild(a);
    }
    toResult(a = {}) {
      return new n(new i(), this, a).stringify();
    }
  };
  s.registerLazyResult = (a) => {
    n = a;
  }, s.registerProcessor = (a) => {
    i = a;
  }, e.exports = s, s.default = s, r.registerRoot(s);
}), Q2 = re((t, e) => {
  var r = { comma(n) {
    return r.split(n, [","], !0);
  }, space(n) {
    let i = [" ", `
`, "	"];
    return r.split(n, i);
  }, split(n, i, s) {
    let a = [], o = "", u = !1, c = 0, h = !1, p = "", m = !1;
    for (let g of n)
      m ? m = !1 : g === "\\" ? m = !0 : h ? g === p && (h = !1) : g === '"' || g === "'" ? (h = !0, p = g) : g === "(" ? c += 1 : g === ")" ? c > 0 && (c -= 1) : c === 0 && i.includes(g) && (u = !0), u ? (o !== "" && a.push(o.trim()), o = "", u = !1) : o += g;
    return (s || o !== "") && a.push(o.trim()), a;
  } };
  e.exports = r, r.default = r;
}), yy = re((t, e) => {
  var r = fa(), n = Q2(), i = class extends r {
    constructor(s) {
      super(s), this.type = "rule", this.nodes || (this.nodes = []);
    }
    get selectors() {
      return n.comma(this.selector);
    }
    set selectors(s) {
      let a = this.selector ? this.selector.match(/,\s*/) : null, o = a ? a[0] : "," + this.raw("between", "beforeOpen");
      this.selector = s.join(o);
    }
  };
  e.exports = i, i.default = i, r.registerRule(i);
}), Oy = re((t, e) => {
  var r = Qp(), n = my(), i = Su(), s = gy(), a = wu(), o = yy(), u = { empty: !0, space: !0 };
  function c(p) {
    for (let m = p.length - 1; m >= 0; m--) {
      let g = p[m], O = g[3] || g[2];
      if (O)
        return O;
    }
  }
  var h = class {
    constructor(p) {
      this.input = p, this.root = new a(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.customProperty = !1, this.createTokenizer(), this.root.source = { input: p, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(p) {
      let m = new s();
      m.name = p[1].slice(1), m.name === "" && this.unnamedAtrule(m, p), this.init(m, p[2]);
      let g, O, b, D = !1, S = !1, x = [], w = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (p = this.tokenizer.nextToken(), g = p[0], g === "(" || g === "[" ? w.push(g === "(" ? ")" : "]") : g === "{" && w.length > 0 ? w.push("}") : g === w[w.length - 1] && w.pop(), w.length === 0)
          if (g === ";") {
            m.source.end = this.getPosition(p[2]), m.source.end.offset++, this.semicolon = !0;
            break;
          } else if (g === "{") {
            S = !0;
            break;
          } else if (g === "}") {
            if (x.length > 0) {
              for (b = x.length - 1, O = x[b]; O && O[0] === "space"; )
                O = x[--b];
              O && (m.source.end = this.getPosition(O[3] || O[2]), m.source.end.offset++);
            }
            this.end(p);
            break;
          } else
            x.push(p);
        else
          x.push(p);
        if (this.tokenizer.endOfFile()) {
          D = !0;
          break;
        }
      }
      m.raws.between = this.spacesAndCommentsFromEnd(x), x.length ? (m.raws.afterName = this.spacesAndCommentsFromStart(x), this.raw(m, "params", x), D && (p = x[x.length - 1], m.source.end = this.getPosition(p[3] || p[2]), m.source.end.offset++, this.spaces = m.raws.between, m.raws.between = "")) : (m.raws.afterName = "", m.params = ""), S && (m.nodes = [], this.current = m);
    }
    checkMissedSemicolon(p) {
      let m = this.colon(p);
      if (m === !1)
        return;
      let g = 0, O;
      for (let b = m - 1; b >= 0 && (O = p[b], !(O[0] !== "space" && (g += 1, g === 2))); b--)
        ;
      throw this.input.error("Missed semicolon", O[0] === "word" ? O[3] + 1 : O[2]);
    }
    colon(p) {
      let m = 0, g, O, b;
      for (let [D, S] of p.entries()) {
        if (g = S, O = g[0], O === "(" && (m += 1), O === ")" && (m -= 1), m === 0 && O === ":")
          if (!b)
            this.doubleColon(g);
          else {
            if (b[0] === "word" && b[1] === "progid")
              continue;
            return D;
          }
        b = g;
      }
      return !1;
    }
    comment(p) {
      let m = new i();
      this.init(m, p[2]), m.source.end = this.getPosition(p[3] || p[2]), m.source.end.offset++;
      let g = p[1].slice(2, -2);
      if (/^\s*$/.test(g))
        m.text = "", m.raws.left = g, m.raws.right = "";
      else {
        let O = g.match(/^(\s*)([^]*\S)(\s*)$/);
        m.text = O[2], m.raws.left = O[1], m.raws.right = O[3];
      }
    }
    createTokenizer() {
      this.tokenizer = n(this.input);
    }
    decl(p, m) {
      let g = new r();
      this.init(g, p[0][2]);
      let O = p[p.length - 1];
      for (O[0] === ";" && (this.semicolon = !0, p.pop()), g.source.end = this.getPosition(O[3] || O[2] || c(p)), g.source.end.offset++; p[0][0] !== "word"; )
        p.length === 1 && this.unknownWord(p), g.raws.before += p.shift()[1];
      for (g.source.start = this.getPosition(p[0][2]), g.prop = ""; p.length; ) {
        let x = p[0][0];
        if (x === ":" || x === "space" || x === "comment")
          break;
        g.prop += p.shift()[1];
      }
      g.raws.between = "";
      let b;
      for (; p.length; )
        if (b = p.shift(), b[0] === ":") {
          g.raws.between += b[1];
          break;
        } else
          b[0] === "word" && /\w/.test(b[1]) && this.unknownWord([b]), g.raws.between += b[1];
      (g.prop[0] === "_" || g.prop[0] === "*") && (g.raws.before += g.prop[0], g.prop = g.prop.slice(1));
      let D = [], S;
      for (; p.length && (S = p[0][0], !(S !== "space" && S !== "comment")); )
        D.push(p.shift());
      this.precheckMissedSemicolon(p);
      for (let x = p.length - 1; x >= 0; x--) {
        if (b = p[x], b[1].toLowerCase() === "!important") {
          g.important = !0;
          let w = this.stringFrom(p, x);
          w = this.spacesFromEnd(p) + w, w !== " !important" && (g.raws.important = w);
          break;
        } else if (b[1].toLowerCase() === "important") {
          let w = p.slice(0), T = "";
          for (let C = x; C > 0; C--) {
            let A = w[C][0];
            if (T.trim().indexOf("!") === 0 && A !== "space")
              break;
            T = w.pop()[1] + T;
          }
          T.trim().indexOf("!") === 0 && (g.important = !0, g.raws.important = T, p = w);
        }
        if (b[0] !== "space" && b[0] !== "comment")
          break;
      }
      p.some((x) => x[0] !== "space" && x[0] !== "comment") && (g.raws.between += D.map((x) => x[1]).join(""), D = []), this.raw(g, "value", D.concat(p), m), g.value.includes(":") && !m && this.checkMissedSemicolon(p);
    }
    doubleColon(p) {
      throw this.input.error("Double colon", { offset: p[2] }, { offset: p[2] + p[1].length });
    }
    emptyRule(p) {
      let m = new o();
      this.init(m, p[2]), m.selector = "", m.raws.between = "", this.current = m;
    }
    end(p) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(p[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(p);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(p) {
      if (this.spaces += p[1], this.current.nodes) {
        let m = this.current.nodes[this.current.nodes.length - 1];
        m && m.type === "rule" && !m.raws.ownSemicolon && (m.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }
    getPosition(p) {
      let m = this.input.fromOffset(p);
      return { column: m.col, line: m.line, offset: p };
    }
    init(p, m) {
      this.current.push(p), p.source = { input: this.input, start: this.getPosition(m) }, p.raws.before = this.spaces, this.spaces = "", p.type !== "comment" && (this.semicolon = !1);
    }
    other(p) {
      let m = !1, g = null, O = !1, b = null, D = [], S = p[1].startsWith("--"), x = [], w = p;
      for (; w; ) {
        if (g = w[0], x.push(w), g === "(" || g === "[")
          b || (b = w), D.push(g === "(" ? ")" : "]");
        else if (S && O && g === "{")
          b || (b = w), D.push("}");
        else if (D.length === 0)
          if (g === ";")
            if (O) {
              this.decl(x, S);
              return;
            } else
              break;
          else if (g === "{") {
            this.rule(x);
            return;
          } else if (g === "}") {
            this.tokenizer.back(x.pop()), m = !0;
            break;
          } else
            g === ":" && (O = !0);
        else
          g === D[D.length - 1] && (D.pop(), D.length === 0 && (b = null));
        w = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (m = !0), D.length > 0 && this.unclosedBracket(b), m && O) {
        if (!S)
          for (; x.length && (w = x[x.length - 1][0], !(w !== "space" && w !== "comment")); )
            this.tokenizer.back(x.pop());
        this.decl(x, S);
      } else
        this.unknownWord(x);
    }
    parse() {
      let p;
      for (; !this.tokenizer.endOfFile(); )
        switch (p = this.tokenizer.nextToken(), p[0]) {
          case "space":
            this.spaces += p[1];
            break;
          case ";":
            this.freeSemicolon(p);
            break;
          case "}":
            this.end(p);
            break;
          case "comment":
            this.comment(p);
            break;
          case "at-word":
            this.atrule(p);
            break;
          case "{":
            this.emptyRule(p);
            break;
          default:
            this.other(p);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(p, m, g, O) {
      let b, D, S = g.length, x = "", w = !0, T, C;
      for (let A = 0; A < S; A += 1)
        b = g[A], D = b[0], D === "space" && A === S - 1 && !O ? w = !1 : D === "comment" ? (C = g[A - 1] ? g[A - 1][0] : "empty", T = g[A + 1] ? g[A + 1][0] : "empty", !u[C] && !u[T] ? x.slice(-1) === "," ? w = !1 : x += b[1] : w = !1) : x += b[1];
      if (!w) {
        let A = g.reduce((P, $) => P + $[1], "");
        p.raws[m] = { raw: A, value: x };
      }
      p[m] = x;
    }
    rule(p) {
      p.pop();
      let m = new o();
      this.init(m, p[0][2]), m.raws.between = this.spacesAndCommentsFromEnd(p), this.raw(m, "selector", p), this.current = m;
    }
    spacesAndCommentsFromEnd(p) {
      let m, g = "";
      for (; p.length && (m = p[p.length - 1][0], !(m !== "space" && m !== "comment")); )
        g = p.pop()[1] + g;
      return g;
    }
    spacesAndCommentsFromStart(p) {
      let m, g = "";
      for (; p.length && (m = p[0][0], !(m !== "space" && m !== "comment")); )
        g += p.shift()[1];
      return g;
    }
    spacesFromEnd(p) {
      let m, g = "";
      for (; p.length && (m = p[p.length - 1][0], m === "space"); )
        g = p.pop()[1] + g;
      return g;
    }
    stringFrom(p, m) {
      let g = "";
      for (let O = m; O < p.length; O++)
        g += p[O][1];
      return p.splice(m, p.length - m), g;
    }
    unclosedBlock() {
      let p = this.current.source.start;
      throw this.input.error("Unclosed block", p.line, p.column);
    }
    unclosedBracket(p) {
      throw this.input.error("Unclosed bracket", { offset: p[2] }, { offset: p[2] + 1 });
    }
    unexpectedClose(p) {
      throw this.input.error("Unexpected }", { offset: p[2] }, { offset: p[2] + 1 });
    }
    unknownWord(p) {
      throw this.input.error("Unknown word", { offset: p[0][2] }, { offset: p[0][2] + p[0][1].length });
    }
    unnamedAtrule(p, m) {
      throw this.input.error("At-rule without name", { offset: m[2] }, { offset: m[2] + m[1].length });
    }
  };
  e.exports = h;
}), X5 = re(() => {
}), V5 = re((t, e) => {
  var r = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", n = (s, a = 21) => (o = a) => {
    let u = "", c = o;
    for (; c--; )
      u += s[Math.random() * s.length | 0];
    return u;
  }, i = (s = 21) => {
    let a = "", o = s;
    for (; o--; )
      a += r[Math.random() * 64 | 0];
    return a;
  };
  e.exports = { nanoid: i, customAlphabet: n };
}), M2 = re((t, e) => {
  e.exports = class {
  };
}), Cu = re((t, e) => {
  var { SourceMapConsumer: r, SourceMapGenerator: n } = X5(), { fileURLToPath: i, pathToFileURL: s } = {}, { isAbsolute: a, resolve: o } = {}, { nanoid: u } = V5(), c = I2(), h = dy(), p = M2(), m = Symbol("fromOffsetCache"), g = !!(r && n), O = !!(o && a), b = class {
    constructor(D, S = {}) {
      if (D === null || typeof D > "u" || typeof D == "object" && !D.toString)
        throw new Error(`PostCSS received ${D} instead of CSS string`);
      if (this.css = D.toString(), this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, S.from && (!O || /^\w+:\/\//.test(S.from) || a(S.from) ? this.file = S.from : this.file = o(S.from)), O && g) {
        let x = new p(this.css, S);
        if (x.text) {
          this.map = x;
          let w = x.consumer().file;
          !this.file && w && (this.file = this.mapResolve(w));
        }
      }
      this.file || (this.id = "<input css " + u(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(D, S, x, w = {}) {
      let T, C, A;
      if (S && typeof S == "object") {
        let $ = S, B = x;
        if (typeof $.offset == "number") {
          let _ = this.fromOffset($.offset);
          S = _.line, x = _.col;
        } else
          S = $.line, x = $.column;
        if (typeof B.offset == "number") {
          let _ = this.fromOffset(B.offset);
          C = _.line, A = _.col;
        } else
          C = B.line, A = B.column;
      } else if (!x) {
        let $ = this.fromOffset(S);
        S = $.line, x = $.col;
      }
      let P = this.origin(S, x, C, A);
      return P ? T = new h(D, P.endLine === void 0 ? P.line : { column: P.column, line: P.line }, P.endLine === void 0 ? P.column : { column: P.endColumn, line: P.endLine }, P.source, P.file, w.plugin) : T = new h(D, C === void 0 ? S : { column: x, line: S }, C === void 0 ? x : { column: A, line: C }, this.css, this.file, w.plugin), T.input = { column: x, endColumn: A, endLine: C, line: S, source: this.css }, this.file && (s && (T.input.url = s(this.file).toString()), T.input.file = this.file), T;
    }
    fromOffset(D) {
      let S, x;
      if (this[m])
        x = this[m];
      else {
        let T = this.css.split(`
`);
        x = new Array(T.length);
        let C = 0;
        for (let A = 0, P = T.length; A < P; A++)
          x[A] = C, C += T[A].length + 1;
        this[m] = x;
      }
      S = x[x.length - 1];
      let w = 0;
      if (D >= S)
        w = x.length - 1;
      else {
        let T = x.length - 2, C;
        for (; w < T; )
          if (C = w + (T - w >> 1), D < x[C])
            T = C - 1;
          else if (D >= x[C + 1])
            w = C + 1;
          else {
            w = C;
            break;
          }
      }
      return { col: D - x[w] + 1, line: w + 1 };
    }
    mapResolve(D) {
      return /^\w+:\/\//.test(D) ? D : o(this.map.consumer().sourceRoot || this.map.root || ".", D);
    }
    origin(D, S, x, w) {
      if (!this.map)
        return !1;
      let T = this.map.consumer(), C = T.originalPositionFor({ column: S, line: D });
      if (!C.source)
        return !1;
      let A;
      typeof x == "number" && (A = T.originalPositionFor({ column: w, line: x }));
      let P;
      a(C.source) ? P = s(C.source) : P = new URL(C.source, this.map.consumer().sourceRoot || s(this.map.mapFile));
      let $ = { column: C.column, endColumn: A && A.column, endLine: A && A.line, line: C.line, url: P.toString() };
      if (P.protocol === "file:")
        if (i)
          $.file = i(P);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let B = T.sourceContentFor(C.source);
      return B && ($.source = B), $;
    }
    toJSON() {
      let D = {};
      for (let S of ["hasBOM", "css", "file", "id"])
        this[S] != null && (D[S] = this[S]);
      return this.map && (D.map = { ...this.map }, D.map.consumerCache && (D.map.consumerCache = void 0)), D;
    }
    get from() {
      return this.file || this.id;
    }
  };
  e.exports = b, b.default = b, c && c.registerInput && c.registerInput(b);
}), Mp = re((t, e) => {
  var r = fa(), n = Oy(), i = Cu();
  function s(a, o) {
    let u = new i(a, o), c = new n(u);
    try {
      c.parse();
    } catch (h) {
      throw h;
    }
    return c.root;
  }
  e.exports = s, s.default = s, r.registerParse(s);
}), Y5 = re((t, e) => {
  var r = my(), n = Cu();
  e.exports = { isInlineComment(i) {
    if (i[0] === "word" && i[1].slice(0, 2) === "//") {
      let s = i, a = [], o, u;
      for (; i; ) {
        if (/\r?\n/.test(i[1])) {
          if (/['"].*\r?\n/.test(i[1])) {
            a.push(i[1].substring(0, i[1].indexOf(`
`))), u = i[1].substring(i[1].indexOf(`
`));
            let h = this.input.css.valueOf().substring(this.tokenizer.position());
            u += h, o = i[3] + h.length - u.length;
          } else
            this.tokenizer.back(i);
          break;
        }
        a.push(i[1]), o = i[2], i = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
      }
      let c = ["comment", a.join(""), s[2], o];
      return this.inlineComment(c), u && (this.input = new n(u), this.tokenizer = r(this.input)), !0;
    } else if (i[1] === "/") {
      let s = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
      if (s[0] === "comment" && /^\/\*/.test(s[1]))
        return s[0] = "word", s[1] = s[1].slice(1), i[1] = "//", this.tokenizer.back(s), e.exports.isInlineComment.bind(this)(i);
    }
    return !1;
  } };
}), U5 = re((t, e) => {
  e.exports = { interpolation(r) {
    let n = [r, this.tokenizer.nextToken()], i = ["word", "}"];
    if (n[0][1].length > 1 || n[1][0] !== "{")
      return this.tokenizer.back(n[1]), !1;
    for (r = this.tokenizer.nextToken(); r && i.includes(r[0]); )
      n.push(r), r = this.tokenizer.nextToken();
    let s = n.map((c) => c[1]), [a] = n, o = n.pop(), u = ["word", s.join(""), a[2], o[2]];
    return this.tokenizer.back(r), this.tokenizer.back(u), !0;
  } };
}), z5 = re((t, e) => {
  var r = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, n = /\.[0-9]/, i = (s) => {
    let [, a] = s, [o] = a;
    return (o === "." || o === "#") && r.test(a) === !1 && n.test(a) === !1;
  };
  e.exports = { isMixinToken: i };
}), G5 = re((t, e) => {
  var r = my(), n = /^url\((.+)\)/;
  e.exports = (i) => {
    let { name: s, params: a = "" } = i;
    if (s === "import" && a.length) {
      i.import = !0;
      let o = r({ css: a });
      for (i.filename = a.replace(n, "$1"); !o.endOfFile(); ) {
        let [u, c] = o.nextToken();
        if (u === "word" && c === "url")
          return;
        if (u === "brackets") {
          i.options = c, i.filename = a.replace(c, "").trim();
          break;
        }
      }
    }
  };
}), H5 = re((t, e) => {
  var r = /:$/, n = /^:(\s+)?/;
  e.exports = (i) => {
    let { name: s, params: a = "" } = i;
    if (i.name.slice(-1) === ":") {
      if (r.test(s)) {
        let [o] = s.match(r);
        i.name = s.replace(o, ""), i.raws.afterName = o + (i.raws.afterName || ""), i.variable = !0, i.value = i.params;
      }
      if (n.test(a)) {
        let [o] = a.match(n);
        i.value = a.replace(o, ""), i.raws.afterName = (i.raws.afterName || "") + o, i.variable = !0;
      }
    }
  };
}), J5 = re((t, e) => {
  var r = Su(), n = Oy(), { isInlineComment: i } = Y5(), { interpolation: s } = U5(), { isMixinToken: a } = z5(), o = G5(), u = H5(), c = /(!\s*important)$/i;
  e.exports = class extends n {
    constructor(...h) {
      super(...h), this.lastNode = null;
    }
    atrule(h) {
      s.bind(this)(h) || (super.atrule(h), o(this.lastNode), u(this.lastNode));
    }
    decl(...h) {
      super.decl(...h), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = !0);
    }
    each(h) {
      h[0][1] = ` ${h[0][1]}`;
      let p = h.findIndex((b) => b[0] === "("), m = h.reverse().find((b) => b[0] === ")"), g = h.reverse().indexOf(m), O = h.splice(p, g).map((b) => b[1]).join("");
      for (let b of h.reverse())
        this.tokenizer.back(b);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.function = !0, this.lastNode.params = O;
    }
    init(h, p, m) {
      super.init(h, p, m), this.lastNode = h;
    }
    inlineComment(h) {
      let p = new r(), m = h[1].slice(2);
      if (this.init(p, h[2]), p.source.end = this.getPosition(h[3] || h[2]), p.inline = !0, p.raws.begin = "//", /^\s*$/.test(m))
        p.text = "", p.raws.left = m, p.raws.right = "";
      else {
        let g = m.match(/^(\s*)([^]*[^\s])(\s*)$/);
        [, p.raws.left, p.text, p.raws.right] = g;
      }
    }
    mixin(h) {
      let [p] = h, m = p[1].slice(0, 1), g = h.findIndex((x) => x[0] === "brackets"), O = h.findIndex((x) => x[0] === "("), b = "";
      if ((g < 0 || g > 3) && O > 0) {
        let x = h.reduce((M, Y, J) => Y[0] === ")" ? J : M), w = h.slice(O, x + O).map((M) => M[1]).join(""), [T] = h.slice(O), C = [T[2], T[3]], [A] = h.slice(x, x + 1), P = [A[2], A[3]], $ = ["brackets", w].concat(C, P), B = h.slice(0, O), _ = h.slice(x + 1);
        h = B, h.push($), h = h.concat(_);
      }
      let D = [];
      for (let x of h)
        if ((x[1] === "!" || D.length) && D.push(x), x[1] === "important")
          break;
      if (D.length) {
        let [x] = D, w = h.indexOf(x), T = D[D.length - 1], C = [x[2], x[3]], A = [T[4], T[5]], P = ["word", D.map(($) => $[1]).join("")].concat(C, A);
        h.splice(w, D.length, P);
      }
      let S = h.findIndex((x) => c.test(x[1]));
      S > 0 && ([, b] = h[S], h.splice(S, 1));
      for (let x of h.reverse())
        this.tokenizer.back(x);
      this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = !0, this.lastNode.raws.identifier = m, b && (this.lastNode.important = !0, this.lastNode.raws.important = b);
    }
    other(h) {
      i.bind(this)(h) || super.other(h);
    }
    rule(h) {
      let p = h[h.length - 1], m = h[h.length - 2];
      if (m[0] === "at-word" && p[0] === "{" && (this.tokenizer.back(p), s.bind(this)(m))) {
        let g = this.tokenizer.nextToken();
        h = h.slice(0, h.length - 2).concat([g]);
        for (let O of h.reverse())
          this.tokenizer.back(O);
        return;
      }
      super.rule(h), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = !0);
    }
    unknownWord(h) {
      let [p] = h;
      if (h[0][1] === "each" && h[1][0] === "(") {
        this.each(h);
        return;
      }
      if (a(p)) {
        this.mixin(h);
        return;
      }
      super.unknownWord(h);
    }
  };
}), K5 = re((t, e) => {
  var r = fy();
  e.exports = class extends r {
    atrule(n, i) {
      if (!n.mixin && !n.variable && !n.function) {
        super.atrule(n, i);
        return;
      }
      let s = `${n.function ? "" : n.raws.identifier || "@"}${n.name}`, a = n.params ? this.rawValue(n, "params") : "", o = n.raws.important || "";
      if (n.variable && (a = n.value), typeof n.raws.afterName < "u" ? s += n.raws.afterName : a && (s += " "), n.nodes)
        this.block(n, s + a + o);
      else {
        let u = (n.raws.between || "") + o + (i ? ";" : "");
        this.builder(s + a + u, n);
      }
    }
    comment(n) {
      if (n.inline) {
        let i = this.raw(n, "left", "commentLeft"), s = this.raw(n, "right", "commentRight");
        this.builder(`//${i}${n.text}${s}`, n);
      } else
        super.comment(n);
    }
  };
}), e_ = re((t, e) => {
  var r = Cu(), n = J5(), i = K5();
  e.exports = { parse(s, a) {
    let o = new r(s, a), u = new n(o);
    return u.parse(), u.root.walk((c) => {
      let h = o.css.lastIndexOf(c.source.input.css);
      if (h === 0)
        return;
      if (h + c.source.input.css.length !== o.css.length)
        throw new Error("Invalid state detected in postcss-less");
      let p = h + c.source.start.offset, m = o.fromOffset(h + c.source.start.offset);
      if (c.source.start = { offset: p, line: m.line, column: m.col }, c.source.end) {
        let g = h + c.source.end.offset, O = o.fromOffset(h + c.source.end.offset);
        c.source.end = { offset: g, line: O.line, column: O.col };
      }
    }), u.root;
  }, stringify(s, a) {
    new i(a).stringify(s);
  }, nodeToString(s) {
    let a = "";
    return e.exports.stringify(s, (o) => {
      a += o;
    }), a;
  } };
}), L2 = re((t, e) => {
  e.exports = class {
    generate() {
    }
  };
}), xy = re((t, e) => {
  var r = fa(), n, i, s = class extends r {
    constructor(a) {
      super({ type: "document", ...a }), this.nodes || (this.nodes = []);
    }
    toResult(a = {}) {
      return new n(new i(), this, a).stringify();
    }
  };
  s.registerLazyResult = (a) => {
    n = a;
  }, s.registerProcessor = (a) => {
    i = a;
  }, e.exports = s, s.default = s;
}), R2 = re((t, e) => {
  var r = {};
  e.exports = function(n) {
    r[n] || (r[n] = !0, typeof console < "u" && console.warn && console.warn(n));
  };
}), j2 = re((t, e) => {
  var r = class {
    constructor(n, i = {}) {
      if (this.type = "warning", this.text = n, i.node && i.node.source) {
        let s = i.node.rangeBy(i);
        this.line = s.start.line, this.column = s.start.column, this.endLine = s.end.line, this.endColumn = s.end.column;
      }
      for (let s in i)
        this[s] = i[s];
    }
    toString() {
      return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  };
  e.exports = r, r.default = r;
}), by = re((t, e) => {
  var r = j2(), n = class {
    constructor(i, s, a) {
      this.processor = i, this.messages = [], this.root = s, this.opts = a, this.css = void 0, this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(i, s = {}) {
      s.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (s.plugin = this.lastPlugin.postcssPlugin);
      let a = new r(i, s);
      return this.messages.push(a), a;
    }
    warnings() {
      return this.messages.filter((i) => i.type === "warning");
    }
    get content() {
      return this.css;
    }
  };
  e.exports = n, n.default = n;
}), Z2 = re((t, e) => {
  var { isClean: r, my: n } = py(), i = L2(), s = Np(), a = fa(), o = xy();
  R2();
  var u = by(), c = Mp(), h = wu(), p = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, m = { AtRule: !0, AtRuleExit: !0, Comment: !0, CommentExit: !0, Declaration: !0, DeclarationExit: !0, Document: !0, DocumentExit: !0, Once: !0, OnceExit: !0, postcssPlugin: !0, prepare: !0, Root: !0, RootExit: !0, Rule: !0, RuleExit: !0 }, g = { Once: !0, postcssPlugin: !0, prepare: !0 }, O = 0;
  function b(C) {
    return typeof C == "object" && typeof C.then == "function";
  }
  function D(C) {
    let A = !1, P = p[C.type];
    return C.type === "decl" ? A = C.prop.toLowerCase() : C.type === "atrule" && (A = C.name.toLowerCase()), A && C.append ? [P, P + "-" + A, O, P + "Exit", P + "Exit-" + A] : A ? [P, P + "-" + A, P + "Exit", P + "Exit-" + A] : C.append ? [P, O, P + "Exit"] : [P, P + "Exit"];
  }
  function S(C) {
    let A;
    return C.type === "document" ? A = ["Document", O, "DocumentExit"] : C.type === "root" ? A = ["Root", O, "RootExit"] : A = D(C), { eventIndex: 0, events: A, iterator: 0, node: C, visitorIndex: 0, visitors: [] };
  }
  function x(C) {
    return C[r] = !1, C.nodes && C.nodes.forEach((A) => x(A)), C;
  }
  var w = {}, T = class W2 {
    constructor(A, P, $) {
      this.stringified = !1, this.processed = !1;
      let B;
      if (typeof P == "object" && P !== null && (P.type === "root" || P.type === "document"))
        B = x(P);
      else if (P instanceof W2 || P instanceof u)
        B = x(P.root), P.map && (typeof $.map > "u" && ($.map = {}), $.map.inline || ($.map.inline = !1), $.map.prev = P.map);
      else {
        let _ = c;
        $.syntax && (_ = $.syntax.parse), $.parser && (_ = $.parser), _.parse && (_ = _.parse);
        try {
          B = _(P, $);
        } catch (M) {
          this.processed = !0, this.error = M;
        }
        B && !B[n] && a.rebuild(B);
      }
      this.result = new u(A, B, $), this.helpers = { ...w, postcss: w, result: this.result }, this.plugins = this.processor.plugins.map((_) => typeof _ == "object" && _.prepare ? { ..._, ..._.prepare(this.result) } : _);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(A) {
      return this.async().catch(A);
    }
    finally(A) {
      return this.async().then(A, A);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(A, P) {
      let $ = this.result.lastPlugin;
      try {
        P && P.addToError(A), this.error = A, A.name === "CssSyntaxError" && !A.plugin ? (A.plugin = $.postcssPlugin, A.setMessage()) : $.postcssVersion;
      } catch (B) {
        console && console.error && console.error(B);
      }
      return A;
    }
    prepareVisitors() {
      this.listeners = {};
      let A = (P, $, B) => {
        this.listeners[$] || (this.listeners[$] = []), this.listeners[$].push([P, B]);
      };
      for (let P of this.plugins)
        if (typeof P == "object")
          for (let $ in P) {
            if (!m[$] && /^[A-Z]/.test($))
              throw new Error(`Unknown event ${$} in ${P.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
            if (!g[$])
              if (typeof P[$] == "object")
                for (let B in P[$])
                  B === "*" ? A(P, $, P[$][B]) : A(P, $ + "-" + B.toLowerCase(), P[$][B]);
              else
                typeof P[$] == "function" && A(P, $, P[$]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let A = 0; A < this.plugins.length; A++) {
        let P = this.plugins[A], $ = this.runOnRoot(P);
        if (b($))
          try {
            await $;
          } catch (B) {
            throw this.handleError(B);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let A = this.result.root;
        for (; !A[r]; ) {
          A[r] = !0;
          let P = [S(A)];
          for (; P.length > 0; ) {
            let $ = this.visitTick(P);
            if (b($))
              try {
                await $;
              } catch (B) {
                let _ = P[P.length - 1].node;
                throw this.handleError(B, _);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [P, $] of this.listeners.OnceExit) {
            this.result.lastPlugin = P;
            try {
              if (A.type === "document") {
                let B = A.nodes.map((_) => $(_, this.helpers));
                await Promise.all(B);
              } else
                await $(A, this.helpers);
            } catch (B) {
              throw this.handleError(B);
            }
          }
      }
      return this.processed = !0, this.stringify();
    }
    runOnRoot(A) {
      this.result.lastPlugin = A;
      try {
        if (typeof A == "object" && A.Once) {
          if (this.result.root.type === "document") {
            let P = this.result.root.nodes.map(($) => A.Once($, this.helpers));
            return b(P[0]) ? Promise.all(P) : P;
          }
          return A.Once(this.result.root, this.helpers);
        } else if (typeof A == "function")
          return A(this.result.root, this.result);
      } catch (P) {
        throw this.handleError(P);
      }
    }
    stringify() {
      if (this.error)
        throw this.error;
      if (this.stringified)
        return this.result;
      this.stringified = !0, this.sync();
      let A = this.result.opts, P = s;
      A.syntax && (P = A.syntax.stringify), A.stringifier && (P = A.stringifier), P.stringify && (P = P.stringify);
      let $ = new i(P, this.result.root, this.result.opts).generate();
      return this.result.css = $[0], this.result.map = $[1], this.result;
    }
    sync() {
      if (this.error)
        throw this.error;
      if (this.processed)
        return this.result;
      if (this.processed = !0, this.processing)
        throw this.getAsyncError();
      for (let A of this.plugins) {
        let P = this.runOnRoot(A);
        if (b(P))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let A = this.result.root;
        for (; !A[r]; )
          A[r] = !0, this.walkSync(A);
        if (this.listeners.OnceExit)
          if (A.type === "document")
            for (let P of A.nodes)
              this.visitSync(this.listeners.OnceExit, P);
          else
            this.visitSync(this.listeners.OnceExit, A);
      }
      return this.result;
    }
    then(A, P) {
      return this.async().then(A, P);
    }
    toString() {
      return this.css;
    }
    visitSync(A, P) {
      for (let [$, B] of A) {
        this.result.lastPlugin = $;
        let _;
        try {
          _ = B(P, this.helpers);
        } catch (M) {
          throw this.handleError(M, P.proxyOf);
        }
        if (P.type !== "root" && P.type !== "document" && !P.parent)
          return !0;
        if (b(_))
          throw this.getAsyncError();
      }
    }
    visitTick(A) {
      let P = A[A.length - 1], { node: $, visitors: B } = P;
      if ($.type !== "root" && $.type !== "document" && !$.parent) {
        A.pop();
        return;
      }
      if (B.length > 0 && P.visitorIndex < B.length) {
        let [M, Y] = B[P.visitorIndex];
        P.visitorIndex += 1, P.visitorIndex === B.length && (P.visitors = [], P.visitorIndex = 0), this.result.lastPlugin = M;
        try {
          return Y($.toProxy(), this.helpers);
        } catch (J) {
          throw this.handleError(J, $);
        }
      }
      if (P.iterator !== 0) {
        let M = P.iterator, Y;
        for (; Y = $.nodes[$.indexes[M]]; )
          if ($.indexes[M] += 1, !Y[r]) {
            Y[r] = !0, A.push(S(Y));
            return;
          }
        P.iterator = 0, delete $.indexes[M];
      }
      let _ = P.events;
      for (; P.eventIndex < _.length; ) {
        let M = _[P.eventIndex];
        if (P.eventIndex += 1, M === O) {
          $.nodes && $.nodes.length && ($[r] = !0, P.iterator = $.getIterator());
          return;
        } else if (this.listeners[M]) {
          P.visitors = this.listeners[M];
          return;
        }
      }
      A.pop();
    }
    walkSync(A) {
      A[r] = !0;
      let P = D(A);
      for (let $ of P)
        if ($ === O)
          A.nodes && A.each((B) => {
            B[r] || this.walkSync(B);
          });
        else {
          let B = this.listeners[$];
          if (B && this.visitSync(B, A.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
  };
  T.registerPostcss = (C) => {
    w = C;
  }, e.exports = T, T.default = T, h.registerLazyResult(T), o.registerLazyResult(T);
}), t_ = re((t, e) => {
  var r = L2(), n = Np();
  R2();
  var i = Mp(), s = by(), a = class {
    constructor(o, u, c) {
      u = u.toString(), this.stringified = !1, this._processor = o, this._css = u, this._opts = c, this._map = void 0;
      let h, p = n;
      this.result = new s(this._processor, h, this._opts), this.result.css = u;
      let m = this;
      Object.defineProperty(this.result, "root", { get() {
        return m.root;
      } });
      let g = new r(p, h, this._opts, u);
      if (g.isMap()) {
        let [O, b] = g.generate();
        O && (this.result.css = O), b && (this.result.map = b);
      } else
        g.clearAnnotation(), this.result.css = g.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(o) {
      return this.async().catch(o);
    }
    finally(o) {
      return this.async().then(o, o);
    }
    sync() {
      if (this.error)
        throw this.error;
      return this.result;
    }
    then(o, u) {
      return this.async().then(o, u);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let o, u = i;
      try {
        o = u(this._css, this._opts);
      } catch (c) {
        this.error = c;
      }
      if (this.error)
        throw this.error;
      return this._root = o, o;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
  };
  e.exports = a, a.default = a;
}), r_ = re((t, e) => {
  var r = t_(), n = Z2(), i = xy(), s = wu(), a = class {
    constructor(o = []) {
      this.version = "8.4.33", this.plugins = this.normalize(o);
    }
    normalize(o) {
      let u = [];
      for (let c of o)
        if (c.postcss === !0 ? c = c() : c.postcss && (c = c.postcss), typeof c == "object" && Array.isArray(c.plugins))
          u = u.concat(c.plugins);
        else if (typeof c == "object" && c.postcssPlugin)
          u.push(c);
        else if (typeof c == "function")
          u.push(c);
        else if (!(typeof c == "object" && (c.parse || c.stringify)))
          throw new Error(c + " is not a PostCSS plugin");
      return u;
    }
    process(o, u = {}) {
      return !this.plugins.length && !u.parser && !u.stringifier && !u.syntax ? new r(this, o, u) : new n(this, o, u);
    }
    use(o) {
      return this.plugins = this.plugins.concat(this.normalize([o])), this;
    }
  };
  e.exports = a, a.default = a, s.registerProcessor(a), i.registerProcessor(a);
}), n_ = re((t, e) => {
  var r = Qp(), n = M2(), i = Su(), s = gy(), a = Cu(), o = wu(), u = yy();
  function c(h, p) {
    if (Array.isArray(h))
      return h.map((O) => c(O));
    let { inputs: m, ...g } = h;
    if (m) {
      p = [];
      for (let O of m) {
        let b = { ...O, __proto__: a.prototype };
        b.map && (b.map = { ...b.map, __proto__: n.prototype }), p.push(b);
      }
    }
    if (g.nodes && (g.nodes = h.nodes.map((O) => c(O, p))), g.source) {
      let { inputId: O, ...b } = g.source;
      g.source = b, O != null && (g.source.input = p[O]);
    }
    if (g.type === "root")
      return new o(g);
    if (g.type === "decl")
      return new r(g);
    if (g.type === "rule")
      return new u(g);
    if (g.type === "comment")
      return new i(g);
    if (g.type === "atrule")
      return new s(g);
    throw new Error("Unknown node type: " + h.type);
  }
  e.exports = c, c.default = c;
}), Dy = re((t, e) => {
  var r = dy(), n = Qp(), i = Z2(), s = fa(), a = r_(), o = Np(), u = n_(), c = xy(), h = j2(), p = Su(), m = gy(), g = by(), O = Cu(), b = Mp(), D = Q2(), S = yy(), x = wu(), w = _p();
  function T(...C) {
    return C.length === 1 && Array.isArray(C[0]) && (C = C[0]), new a(C);
  }
  T.plugin = function(C, A) {
    let P = !1;
    function $(..._) {
      console && console.warn && !P && (P = !0, console.warn(C + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`));
      let M = A(..._);
      return M.postcssPlugin = C, M.postcssVersion = new a().version, M;
    }
    let B;
    return Object.defineProperty($, "postcss", { get() {
      return B || (B = $()), B;
    } }), $.process = function(_, M, Y) {
      return T([$(Y)]).process(_, M);
    }, $;
  }, T.stringify = o, T.parse = b, T.fromJSON = u, T.list = D, T.comment = (C) => new p(C), T.atRule = (C) => new m(C), T.decl = (C) => new n(C), T.rule = (C) => new S(C), T.root = (C) => new x(C), T.document = (C) => new c(C), T.CssSyntaxError = r, T.Declaration = n, T.Container = s, T.Processor = a, T.Document = c, T.Comment = p, T.Warning = h, T.AtRule = m, T.Result = g, T.Input = O, T.Rule = S, T.Root = x, T.Node = w, i.registerPostcss(T), e.exports = T, T.default = T;
}), i_ = re((t, e) => {
  var { Container: r } = Dy(), n = class extends r {
    constructor(i) {
      super(i), this.type = "decl", this.isNested = !0, this.nodes || (this.nodes = []);
    }
  };
  e.exports = n;
}), s_ = re((t, e) => {
  var r = /[\t\n\f\r "#'()/;[\\\]{}]/g, n = /[,\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, i = /.[\r\n"'(/\\]/, s = /[\da-f]/i, a = /[\n\f\r]/g;
  e.exports = function(o, u = {}) {
    let c = o.css.valueOf(), h = u.ignoreErrors, p, m, g, O, b, D, S, x, w, T = c.length, C = 0, A = [], P = [], $;
    function B() {
      return C;
    }
    function _(q) {
      throw o.error("Unclosed " + q, C);
    }
    function M() {
      return P.length === 0 && C >= T;
    }
    function Y() {
      let q = 1, X = !1, H = !1;
      for (; q > 0; )
        m += 1, c.length <= m && _("interpolation"), p = c.charCodeAt(m), x = c.charCodeAt(m + 1), X ? !H && p === X ? (X = !1, H = !1) : p === 92 ? H = !H : H && (H = !1) : p === 39 || p === 34 ? X = p : p === 125 ? q -= 1 : p === 35 && x === 123 && (q += 1);
    }
    function J(q) {
      if (P.length)
        return P.pop();
      if (C >= T)
        return;
      let X = q ? q.ignoreUnclosed : !1;
      switch (p = c.charCodeAt(C), p) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12: {
          m = C;
          do
            m += 1, p = c.charCodeAt(m);
          while (p === 32 || p === 10 || p === 9 || p === 13 || p === 12);
          w = ["space", c.slice(C, m)], C = m - 1;
          break;
        }
        case 91:
        case 93:
        case 123:
        case 125:
        case 58:
        case 59:
        case 41: {
          let H = String.fromCharCode(p);
          w = [H, H, C];
          break;
        }
        case 44: {
          w = ["word", ",", C, C + 1];
          break;
        }
        case 40: {
          if (S = A.length ? A.pop()[1] : "", x = c.charCodeAt(C + 1), S === "url" && x !== 39 && x !== 34) {
            for ($ = 1, D = !1, m = C + 1; m <= c.length - 1; ) {
              if (x = c.charCodeAt(m), x === 92)
                D = !D;
              else if (x === 40)
                $ += 1;
              else if (x === 41 && ($ -= 1, $ === 0))
                break;
              m += 1;
            }
            O = c.slice(C, m + 1), w = ["brackets", O, C, m], C = m;
          } else
            m = c.indexOf(")", C + 1), O = c.slice(C, m + 1), m === -1 || i.test(O) ? w = ["(", "(", C] : (w = ["brackets", O, C, m], C = m);
          break;
        }
        case 39:
        case 34: {
          for (g = p, m = C, D = !1; m < T && (m++, m === T && _("string"), p = c.charCodeAt(m), x = c.charCodeAt(m + 1), !(!D && p === g)); )
            p === 92 ? D = !D : D ? D = !1 : p === 35 && x === 123 && Y();
          w = ["string", c.slice(C, m + 1), C, m], C = m;
          break;
        }
        case 64: {
          r.lastIndex = C + 1, r.test(c), r.lastIndex === 0 ? m = c.length - 1 : m = r.lastIndex - 2, w = ["at-word", c.slice(C, m + 1), C, m], C = m;
          break;
        }
        case 92: {
          for (m = C, b = !0; c.charCodeAt(m + 1) === 92; )
            m += 1, b = !b;
          if (p = c.charCodeAt(m + 1), b && p !== 47 && p !== 32 && p !== 10 && p !== 9 && p !== 13 && p !== 12 && (m += 1, s.test(c.charAt(m)))) {
            for (; s.test(c.charAt(m + 1)); )
              m += 1;
            c.charCodeAt(m + 1) === 32 && (m += 1);
          }
          w = ["word", c.slice(C, m + 1), C, m], C = m;
          break;
        }
        default:
          x = c.charCodeAt(C + 1), p === 35 && x === 123 ? (m = C, Y(), O = c.slice(C, m + 1), w = ["word", O, C, m], C = m) : p === 47 && x === 42 ? (m = c.indexOf("*/", C + 2) + 1, m === 0 && (h || X ? m = c.length : _("comment")), w = ["comment", c.slice(C, m + 1), C, m], C = m) : p === 47 && x === 47 ? (a.lastIndex = C + 1, a.test(c), a.lastIndex === 0 ? m = c.length - 1 : m = a.lastIndex - 2, O = c.slice(C, m + 1), w = ["comment", O, C, m, "inline"], C = m) : (n.lastIndex = C + 1, n.test(c), n.lastIndex === 0 ? m = c.length - 1 : m = n.lastIndex - 2, w = ["word", c.slice(C, m + 1), C, m], A.push(w), C = m);
          break;
      }
      return C++, w;
    }
    function R(q) {
      P.push(q);
    }
    return { back: R, endOfFile: M, nextToken: J, position: B };
  };
}), a_ = re((t, e) => {
  var { Comment: r } = Dy(), n = Oy(), i = i_(), s = s_(), a = class extends n {
    atrule(o) {
      let u = o[1], c = o;
      for (; !this.tokenizer.endOfFile(); ) {
        let h = this.tokenizer.nextToken();
        if (h[0] === "word" && h[2] === c[3] + 1)
          u += h[1], c = h;
        else {
          this.tokenizer.back(h);
          break;
        }
      }
      super.atrule(["at-word", u, o[2], c[3]]);
    }
    comment(o) {
      if (o[4] === "inline") {
        let u = new r();
        this.init(u, o[2]), u.raws.inline = !0;
        let c = this.input.fromOffset(o[3]);
        u.source.end = { column: c.col, line: c.line, offset: o[3] + 1 };
        let h = o[1].slice(2);
        if (/^\s*$/.test(h))
          u.text = "", u.raws.left = h, u.raws.right = "";
        else {
          let p = h.match(/^(\s*)([^]*\S)(\s*)$/), m = p[2].replace(/(\*\/|\/\*)/g, "*//*");
          u.text = m, u.raws.left = p[1], u.raws.right = p[3], u.raws.text = p[2];
        }
      } else
        super.comment(o);
    }
    createTokenizer() {
      this.tokenizer = s(this.input);
    }
    raw(o, u, c, h) {
      if (super.raw(o, u, c, h), o.raws[u]) {
        let p = o.raws[u].raw;
        o.raws[u].raw = c.reduce((m, g) => {
          if (g[0] === "comment" && g[4] === "inline") {
            let O = g[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*");
            return m + "/*" + O + "*/";
          } else
            return m + g[1];
        }, ""), p !== o.raws[u].raw && (o.raws[u].scss = p);
      }
    }
    rule(o) {
      let u = !1, c = 0, h = "";
      for (let p of o)
        if (u)
          p[0] !== "comment" && p[0] !== "{" && (h += p[1]);
        else {
          if (p[0] === "space" && p[1].includes(`
`))
            break;
          p[0] === "(" ? c += 1 : p[0] === ")" ? c -= 1 : c === 0 && p[0] === ":" && (u = !0);
        }
      if (!u || h.trim() === "" || /^[#:A-Za-z-]/.test(h))
        super.rule(o);
      else {
        o.pop();
        let p = new i();
        this.init(p, o[0][2]);
        let m;
        for (let O = o.length - 1; O >= 0; O--)
          if (o[O][0] !== "space") {
            m = o[O];
            break;
          }
        if (m[3]) {
          let O = this.input.fromOffset(m[3]);
          p.source.end = { column: O.col, line: O.line, offset: m[3] + 1 };
        } else {
          let O = this.input.fromOffset(m[2]);
          p.source.end = { column: O.col, line: O.line, offset: m[2] + 1 };
        }
        for (; o[0][0] !== "word"; )
          p.raws.before += o.shift()[1];
        if (o[0][2]) {
          let O = this.input.fromOffset(o[0][2]);
          p.source.start = { column: O.col, line: O.line, offset: o[0][2] };
        }
        for (p.prop = ""; o.length; ) {
          let O = o[0][0];
          if (O === ":" || O === "space" || O === "comment")
            break;
          p.prop += o.shift()[1];
        }
        p.raws.between = "";
        let g;
        for (; o.length; )
          if (g = o.shift(), g[0] === ":") {
            p.raws.between += g[1];
            break;
          } else
            p.raws.between += g[1];
        (p.prop[0] === "_" || p.prop[0] === "*") && (p.raws.before += p.prop[0], p.prop = p.prop.slice(1)), p.raws.between += this.spacesAndCommentsFromStart(o), this.precheckMissedSemicolon(o);
        for (let O = o.length - 1; O > 0; O--) {
          if (g = o[O], g[1] === "!important") {
            p.important = !0;
            let b = this.stringFrom(o, O);
            b = this.spacesFromEnd(o) + b, b !== " !important" && (p.raws.important = b);
            break;
          } else if (g[1] === "important") {
            let b = o.slice(0), D = "";
            for (let S = O; S > 0; S--) {
              let x = b[S][0];
              if (D.trim().indexOf("!") === 0 && x !== "space")
                break;
              D = b.pop()[1] + D;
            }
            D.trim().indexOf("!") === 0 && (p.important = !0, p.raws.important = D, o = b);
          }
          if (g[0] !== "space" && g[0] !== "comment")
            break;
        }
        this.raw(p, "value", o), p.value.includes(":") && this.checkMissedSemicolon(o), this.current = p;
      }
    }
  };
  e.exports = a;
}), o_ = re((t, e) => {
  var { Input: r } = Dy(), n = a_();
  e.exports = function(i, s) {
    let a = new r(i, s), o = new n(a);
    return o.parse(), o.root;
  };
}), q2 = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(r) {
    this.after = r.after, this.before = r.before, this.type = r.type, this.value = r.value, this.sourceIndex = r.sourceIndex;
  }
  t.default = e;
}), X2 = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = q2(), r = n(e);
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i(s) {
    var a = this;
    this.constructor(s), this.nodes = s.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(o) {
      o.parent = a;
    });
  }
  i.prototype = Object.create(r.default.prototype), i.constructor = r.default, i.prototype.walk = function(s, a) {
    for (var o = typeof s == "string" || s instanceof RegExp, u = o ? a : s, c = typeof s == "string" ? new RegExp(s) : s, h = 0; h < this.nodes.length; h++) {
      var p = this.nodes[h], m = o ? c.test(p.type) : !0;
      if (m && u && u(p, h, this.nodes) === !1 || p.nodes && p.walk(s, a) === !1)
        return !1;
    }
    return !0;
  }, i.prototype.each = function() {
    for (var s = arguments.length <= 0 || arguments[0] === void 0 ? function() {
    } : arguments[0], a = 0; a < this.nodes.length; a++) {
      var o = this.nodes[a];
      if (s(o, a, this.nodes) === !1)
        return !1;
    }
    return !0;
  }, t.default = i;
}), l_ = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.parseMediaFeature = a, t.parseMediaQuery = o, t.parseMediaList = u;
  var e = q2(), r = s(e), n = X2(), i = s(n);
  function s(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function a(c) {
    var h = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], p = [{ mode: "normal", character: null }], m = [], g = 0, O = "", b = null, D = null, S = h, x = c;
    c[0] === "(" && c[c.length - 1] === ")" && (x = c.substring(1, c.length - 1), S++);
    for (var w = 0; w < x.length; w++) {
      var T = x[w];
      if ((T === "'" || T === '"') && (p[g].isCalculationEnabled === !0 ? (p.push({ mode: "string", isCalculationEnabled: !1, character: T }), g++) : p[g].mode === "string" && p[g].character === T && x[w - 1] !== "\\" && (p.pop(), g--)), T === "{" ? (p.push({ mode: "interpolation", isCalculationEnabled: !0 }), g++) : T === "}" && (p.pop(), g--), p[g].mode === "normal" && T === ":") {
        var C = x.substring(w + 1);
        D = { type: "value", before: /^(\s*)/.exec(C)[1], after: /(\s*)$/.exec(C)[1], value: C.trim() }, D.sourceIndex = D.before.length + w + 1 + S, b = { type: "colon", sourceIndex: w + S, after: D.before, value: ":" };
        break;
      }
      O += T;
    }
    return O = { type: "media-feature", before: /^(\s*)/.exec(O)[1], after: /(\s*)$/.exec(O)[1], value: O.trim() }, O.sourceIndex = O.before.length + S, m.push(O), b !== null && (b.before = O.after, m.push(b)), D !== null && m.push(D), m;
  }
  function o(c) {
    var h = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], p = [], m = 0, g = !1, O = void 0;
    function b() {
      return { before: "", after: "", value: "" };
    }
    O = b();
    for (var D = 0; D < c.length; D++) {
      var S = c[D];
      g ? (O.value += S, (S === "{" || S === "(") && m++, (S === ")" || S === "}") && m--) : S.search(/\s/) !== -1 ? O.before += S : (S === "(" && (O.type = "media-feature-expression", m++), O.value = S, O.sourceIndex = h + D, g = !0), g && m === 0 && (S === ")" || D === c.length - 1 || c[D + 1].search(/\s/) !== -1) && (["not", "only", "and"].indexOf(O.value) !== -1 && (O.type = "keyword"), O.type === "media-feature-expression" && (O.nodes = a(O.value, O.sourceIndex)), p.push(Array.isArray(O.nodes) ? new i.default(O) : new r.default(O)), O = b(), g = !1);
    }
    for (var x = 0; x < p.length; x++)
      if (O = p[x], x > 0 && (p[x - 1].after = O.before), O.type === void 0) {
        if (x > 0) {
          if (p[x - 1].type === "media-feature-expression") {
            O.type = "keyword";
            continue;
          }
          if (p[x - 1].value === "not" || p[x - 1].value === "only") {
            O.type = "media-type";
            continue;
          }
          if (p[x - 1].value === "and") {
            O.type = "media-feature-expression";
            continue;
          }
          p[x - 1].type === "media-type" && (p[x + 1] ? O.type = p[x + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : O.type = "media-feature-expression");
        }
        if (x === 0) {
          if (!p[x + 1]) {
            O.type = "media-type";
            continue;
          }
          if (p[x + 1] && (p[x + 1].type === "media-feature-expression" || p[x + 1].type === "keyword")) {
            O.type = "media-type";
            continue;
          }
          if (p[x + 2]) {
            if (p[x + 2].type === "media-feature-expression") {
              O.type = "media-type", p[x + 1].type = "keyword";
              continue;
            }
            if (p[x + 2].type === "keyword") {
              O.type = "keyword", p[x + 1].type = "media-type";
              continue;
            }
          }
          if (p[x + 3] && p[x + 3].type === "media-feature-expression") {
            O.type = "keyword", p[x + 1].type = "media-type", p[x + 2].type = "keyword";
            continue;
          }
        }
      }
    return p;
  }
  function u(c) {
    var h = [], p = 0, m = 0, g = /^(\s*)url\s*\(/.exec(c);
    if (g !== null) {
      for (var O = g[0].length, b = 1; b > 0; ) {
        var D = c[O];
        D === "(" && b++, D === ")" && b--, O++;
      }
      h.unshift(new r.default({ type: "url", value: c.substring(0, O).trim(), sourceIndex: g[1].length, before: g[1], after: /^(\s*)/.exec(c.substring(O))[1] })), p = O;
    }
    for (var S = p; S < c.length; S++) {
      var x = c[S];
      if (x === "(" && m++, x === ")" && m--, m === 0 && x === ",") {
        var w = c.substring(p, S), T = /^(\s*)/.exec(w)[1];
        h.push(new i.default({ type: "media-query", value: w.trim(), sourceIndex: p + T.length, nodes: o(w, p), before: T, after: /(\s*)$/.exec(w)[1] })), p = S + 1;
      }
    }
    var C = c.substring(p), A = /^(\s*)/.exec(C)[1];
    return h.push(new i.default({ type: "media-query", value: C.trim(), sourceIndex: p + A.length, nodes: o(C, p), before: A, after: /(\s*)$/.exec(C)[1] })), h;
  }
}), u_ = re((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = s;
  var e = X2(), r = i(e), n = l_();
  function i(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function s(a) {
    return new r.default({ nodes: (0, n.parseMediaList)(a), type: "media-query-list", value: a.trim() });
  }
}), V2 = re((t, e) => {
  e.exports = function(r, n) {
    if (n = typeof n == "number" ? n : 1 / 0, !n)
      return Array.isArray(r) ? r.map(function(s) {
        return s;
      }) : r;
    return i(r, 1);
    function i(s, a) {
      return s.reduce(function(o, u) {
        return Array.isArray(u) && a < n ? o.concat(i(u, a + 1)) : o.concat(u);
      }, []);
    }
  };
}), Y2 = re((t, e) => {
  e.exports = function(r, n) {
    for (var i = -1, s = []; (i = r.indexOf(n, i + 1)) !== -1; )
      s.push(i);
    return s;
  };
}), U2 = re((t, e) => {
  function r(s, a) {
    for (var o = 1, u = s.length, c = s[0], h = s[0], p = 1; p < u; ++p)
      if (h = c, c = s[p], a(c, h)) {
        if (p === o) {
          o++;
          continue;
        }
        s[o++] = c;
      }
    return s.length = o, s;
  }
  function n(s) {
    for (var a = 1, o = s.length, u = s[0], c = s[0], h = 1; h < o; ++h, c = u)
      if (c = u, u = s[h], u !== c) {
        if (h === a) {
          a++;
          continue;
        }
        s[a++] = u;
      }
    return s.length = a, s;
  }
  function i(s, a, o) {
    return s.length === 0 ? s : a ? (o || s.sort(a), r(s, a)) : (o || s.sort(), n(s));
  }
  e.exports = i;
}), Co = re((t, e) => {
  t.__esModule = !0;
  var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
    return typeof a;
  } : function(a) {
    return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
  };
  function n(a, o) {
    if (!(a instanceof o))
      throw new TypeError("Cannot call a class as a function");
  }
  var i = function a(o, u) {
    if ((typeof o > "u" ? "undefined" : r(o)) !== "object")
      return o;
    var c = new o.constructor();
    for (var h in o)
      if (o.hasOwnProperty(h)) {
        var p = o[h], m = typeof p > "u" ? "undefined" : r(p);
        h === "parent" && m === "object" ? u && (c[h] = u) : p instanceof Array ? c[h] = p.map(function(g) {
          return a(g, c);
        }) : c[h] = a(p, c);
      }
    return c;
  }, s = function() {
    function a() {
      var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      n(this, a);
      for (var u in o)
        this[u] = o[u];
      var c = o.spaces;
      c = c === void 0 ? {} : c;
      var h = c.before, p = h === void 0 ? "" : h, m = c.after, g = m === void 0 ? "" : m;
      this.spaces = { before: p, after: g };
    }
    return a.prototype.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, a.prototype.replaceWith = function() {
      if (this.parent) {
        for (var o in arguments)
          this.parent.insertBefore(this, arguments[o]);
        this.remove();
      }
      return this;
    }, a.prototype.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, a.prototype.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, a.prototype.clone = function() {
      var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = i(this);
      for (var c in o)
        u[c] = o[c];
      return u;
    }, a.prototype.toString = function() {
      return [this.spaces.before, String(this.value), this.spaces.after].join("");
    }, a;
  }();
  t.default = s, e.exports = t.default;
}), Pr = re((t) => {
  t.__esModule = !0, t.TAG = "tag", t.STRING = "string", t.SELECTOR = "selector", t.ROOT = "root", t.PSEUDO = "pseudo", t.NESTING = "nesting", t.ID = "id", t.COMMENT = "comment", t.COMBINATOR = "combinator", t.CLASS = "class", t.ATTRIBUTE = "attribute", t.UNIVERSAL = "universal";
}), vy = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function g(O, b) {
      for (var D = 0; D < b.length; D++) {
        var S = b[D];
        S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(O, S.key, S);
      }
    }
    return function(O, b, D) {
      return b && g(O.prototype, b), D && g(O, D), O;
    };
  }(), n = Co(), i = u(n), s = Pr(), a = o(s);
  function o(g) {
    if (g && g.__esModule)
      return g;
    var O = {};
    if (g != null)
      for (var b in g)
        Object.prototype.hasOwnProperty.call(g, b) && (O[b] = g[b]);
    return O.default = g, O;
  }
  function u(g) {
    return g && g.__esModule ? g : { default: g };
  }
  function c(g, O) {
    if (!(g instanceof O))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(g, O) {
    if (!g)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return O && (typeof O == "object" || typeof O == "function") ? O : g;
  }
  function p(g, O) {
    if (typeof O != "function" && O !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof O);
    g.prototype = Object.create(O && O.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }), O && (Object.setPrototypeOf ? Object.setPrototypeOf(g, O) : g.__proto__ = O);
  }
  var m = function(g) {
    p(O, g);
    function O(b) {
      c(this, O);
      var D = h(this, g.call(this, b));
      return D.nodes || (D.nodes = []), D;
    }
    return O.prototype.append = function(b) {
      return b.parent = this, this.nodes.push(b), this;
    }, O.prototype.prepend = function(b) {
      return b.parent = this, this.nodes.unshift(b), this;
    }, O.prototype.at = function(b) {
      return this.nodes[b];
    }, O.prototype.index = function(b) {
      return typeof b == "number" ? b : this.nodes.indexOf(b);
    }, O.prototype.removeChild = function(b) {
      b = this.index(b), this.at(b).parent = void 0, this.nodes.splice(b, 1);
      var D = void 0;
      for (var S in this.indexes)
        D = this.indexes[S], D >= b && (this.indexes[S] = D - 1);
      return this;
    }, O.prototype.removeAll = function() {
      for (var S = this.nodes, b = Array.isArray(S), D = 0, S = b ? S : S[Symbol.iterator](); ; ) {
        var x;
        if (b) {
          if (D >= S.length)
            break;
          x = S[D++];
        } else {
          if (D = S.next(), D.done)
            break;
          x = D.value;
        }
        var w = x;
        w.parent = void 0;
      }
      return this.nodes = [], this;
    }, O.prototype.empty = function() {
      return this.removeAll();
    }, O.prototype.insertAfter = function(b, D) {
      var S = this.index(b);
      this.nodes.splice(S + 1, 0, D);
      var x = void 0;
      for (var w in this.indexes)
        x = this.indexes[w], S <= x && (this.indexes[w] = x + this.nodes.length);
      return this;
    }, O.prototype.insertBefore = function(b, D) {
      var S = this.index(b);
      this.nodes.splice(S, 0, D);
      var x = void 0;
      for (var w in this.indexes)
        x = this.indexes[w], S <= x && (this.indexes[w] = x + this.nodes.length);
      return this;
    }, O.prototype.each = function(b) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var D = this.lastEach;
      if (this.indexes[D] = 0, !!this.length) {
        for (var S = void 0, x = void 0; this.indexes[D] < this.length && (S = this.indexes[D], x = b(this.at(S), S), x !== !1); )
          this.indexes[D] += 1;
        if (delete this.indexes[D], x === !1)
          return !1;
      }
    }, O.prototype.walk = function(b) {
      return this.each(function(D, S) {
        var x = b(D, S);
        if (x !== !1 && D.length && (x = D.walk(b)), x === !1)
          return !1;
      });
    }, O.prototype.walkAttributes = function(b) {
      var D = this;
      return this.walk(function(S) {
        if (S.type === a.ATTRIBUTE)
          return b.call(D, S);
      });
    }, O.prototype.walkClasses = function(b) {
      var D = this;
      return this.walk(function(S) {
        if (S.type === a.CLASS)
          return b.call(D, S);
      });
    }, O.prototype.walkCombinators = function(b) {
      var D = this;
      return this.walk(function(S) {
        if (S.type === a.COMBINATOR)
          return b.call(D, S);
      });
    }, O.prototype.walkComments = function(b) {
      var D = this;
      return this.walk(function(S) {
        if (S.type === a.COMMENT)
          return b.call(D, S);
      });
    }, O.prototype.walkIds = function(b) {
      var D = this;
      return this.walk(function(S) {
        if (S.type === a.ID)
          return b.call(D, S);
      });
    }, O.prototype.walkNesting = function(b) {
      var D = this;
      return this.walk(function(S) {
        if (S.type === a.NESTING)
          return b.call(D, S);
      });
    }, O.prototype.walkPseudos = function(b) {
      var D = this;
      return this.walk(function(S) {
        if (S.type === a.PSEUDO)
          return b.call(D, S);
      });
    }, O.prototype.walkTags = function(b) {
      var D = this;
      return this.walk(function(S) {
        if (S.type === a.TAG)
          return b.call(D, S);
      });
    }, O.prototype.walkUniversals = function(b) {
      var D = this;
      return this.walk(function(S) {
        if (S.type === a.UNIVERSAL)
          return b.call(D, S);
      });
    }, O.prototype.split = function(b) {
      var D = this, S = [];
      return this.reduce(function(x, w, T) {
        var C = b.call(D, w);
        return S.push(w), C ? (x.push(S), S = []) : T === D.length - 1 && x.push(S), x;
      }, []);
    }, O.prototype.map = function(b) {
      return this.nodes.map(b);
    }, O.prototype.reduce = function(b, D) {
      return this.nodes.reduce(b, D);
    }, O.prototype.every = function(b) {
      return this.nodes.every(b);
    }, O.prototype.some = function(b) {
      return this.nodes.some(b);
    }, O.prototype.filter = function(b) {
      return this.nodes.filter(b);
    }, O.prototype.sort = function(b) {
      return this.nodes.sort(b);
    }, O.prototype.toString = function() {
      return this.map(String).join("");
    }, r(O, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), O;
  }(i.default);
  t.default = m, e.exports = t.default;
}), c_ = re((t, e) => {
  t.__esModule = !0;
  var r = vy(), n = s(r), i = Pr();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, p) {
    if (!(h instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, p) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return p && (typeof p == "object" || typeof p == "function") ? p : h;
  }
  function u(h, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof p);
    h.prototype = Object.create(p && p.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), p && (Object.setPrototypeOf ? Object.setPrototypeOf(h, p) : h.__proto__ = p);
  }
  var c = function(h) {
    u(p, h);
    function p(m) {
      a(this, p);
      var g = o(this, h.call(this, m));
      return g.type = i.ROOT, g;
    }
    return p.prototype.toString = function() {
      var m = this.reduce(function(g, O) {
        var b = String(O);
        return b ? g + b + "," : "";
      }, "").slice(0, -1);
      return this.trailingComma ? m + "," : m;
    }, p;
  }(n.default);
  t.default = c, e.exports = t.default;
}), h_ = re((t, e) => {
  t.__esModule = !0;
  var r = vy(), n = s(r), i = Pr();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, p) {
    if (!(h instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, p) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return p && (typeof p == "object" || typeof p == "function") ? p : h;
  }
  function u(h, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof p);
    h.prototype = Object.create(p && p.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), p && (Object.setPrototypeOf ? Object.setPrototypeOf(h, p) : h.__proto__ = p);
  }
  var c = function(h) {
    u(p, h);
    function p(m) {
      a(this, p);
      var g = o(this, h.call(this, m));
      return g.type = i.SELECTOR, g;
    }
    return p;
  }(n.default);
  t.default = c, e.exports = t.default;
}), Eu = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function h(p, m) {
      for (var g = 0; g < m.length; g++) {
        var O = m[g];
        O.enumerable = O.enumerable || !1, O.configurable = !0, "value" in O && (O.writable = !0), Object.defineProperty(p, O.key, O);
      }
    }
    return function(p, m, g) {
      return m && h(p.prototype, m), g && h(p, g), p;
    };
  }(), n = Co(), i = s(n);
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, p) {
    if (!(h instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, p) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return p && (typeof p == "object" || typeof p == "function") ? p : h;
  }
  function u(h, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof p);
    h.prototype = Object.create(p && p.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), p && (Object.setPrototypeOf ? Object.setPrototypeOf(h, p) : h.__proto__ = p);
  }
  var c = function(h) {
    u(p, h);
    function p() {
      return a(this, p), o(this, h.apply(this, arguments));
    }
    return p.prototype.toString = function() {
      return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
    }, r(p, [{ key: "ns", get: function() {
      var m = this.namespace;
      return m ? (typeof m == "string" ? m : "") + "|" : "";
    } }]), p;
  }(i.default);
  t.default = c, e.exports = t.default;
}), p_ = re((t, e) => {
  t.__esModule = !0;
  var r = Eu(), n = s(r), i = Pr();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, p) {
    if (!(h instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, p) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return p && (typeof p == "object" || typeof p == "function") ? p : h;
  }
  function u(h, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof p);
    h.prototype = Object.create(p && p.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), p && (Object.setPrototypeOf ? Object.setPrototypeOf(h, p) : h.__proto__ = p);
  }
  var c = function(h) {
    u(p, h);
    function p(m) {
      a(this, p);
      var g = o(this, h.call(this, m));
      return g.type = i.CLASS, g;
    }
    return p.prototype.toString = function() {
      return [this.spaces.before, this.ns, "." + this.value, this.spaces.after].join("");
    }, p;
  }(n.default);
  t.default = c, e.exports = t.default;
}), d_ = re((t, e) => {
  t.__esModule = !0;
  var r = Co(), n = s(r), i = Pr();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, p) {
    if (!(h instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, p) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return p && (typeof p == "object" || typeof p == "function") ? p : h;
  }
  function u(h, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof p);
    h.prototype = Object.create(p && p.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), p && (Object.setPrototypeOf ? Object.setPrototypeOf(h, p) : h.__proto__ = p);
  }
  var c = function(h) {
    u(p, h);
    function p(m) {
      a(this, p);
      var g = o(this, h.call(this, m));
      return g.type = i.COMMENT, g;
    }
    return p;
  }(n.default);
  t.default = c, e.exports = t.default;
}), f_ = re((t, e) => {
  t.__esModule = !0;
  var r = Eu(), n = s(r), i = Pr();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, p) {
    if (!(h instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, p) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return p && (typeof p == "object" || typeof p == "function") ? p : h;
  }
  function u(h, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof p);
    h.prototype = Object.create(p && p.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), p && (Object.setPrototypeOf ? Object.setPrototypeOf(h, p) : h.__proto__ = p);
  }
  var c = function(h) {
    u(p, h);
    function p(m) {
      a(this, p);
      var g = o(this, h.call(this, m));
      return g.type = i.ID, g;
    }
    return p.prototype.toString = function() {
      return [this.spaces.before, this.ns, "#" + this.value, this.spaces.after].join("");
    }, p;
  }(n.default);
  t.default = c, e.exports = t.default;
}), m_ = re((t, e) => {
  t.__esModule = !0;
  var r = Eu(), n = s(r), i = Pr();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, p) {
    if (!(h instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, p) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return p && (typeof p == "object" || typeof p == "function") ? p : h;
  }
  function u(h, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof p);
    h.prototype = Object.create(p && p.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), p && (Object.setPrototypeOf ? Object.setPrototypeOf(h, p) : h.__proto__ = p);
  }
  var c = function(h) {
    u(p, h);
    function p(m) {
      a(this, p);
      var g = o(this, h.call(this, m));
      return g.type = i.TAG, g;
    }
    return p;
  }(n.default);
  t.default = c, e.exports = t.default;
}), g_ = re((t, e) => {
  t.__esModule = !0;
  var r = Co(), n = s(r), i = Pr();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, p) {
    if (!(h instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, p) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return p && (typeof p == "object" || typeof p == "function") ? p : h;
  }
  function u(h, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof p);
    h.prototype = Object.create(p && p.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), p && (Object.setPrototypeOf ? Object.setPrototypeOf(h, p) : h.__proto__ = p);
  }
  var c = function(h) {
    u(p, h);
    function p(m) {
      a(this, p);
      var g = o(this, h.call(this, m));
      return g.type = i.STRING, g;
    }
    return p;
  }(n.default);
  t.default = c, e.exports = t.default;
}), y_ = re((t, e) => {
  t.__esModule = !0;
  var r = vy(), n = s(r), i = Pr();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, p) {
    if (!(h instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, p) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return p && (typeof p == "object" || typeof p == "function") ? p : h;
  }
  function u(h, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof p);
    h.prototype = Object.create(p && p.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), p && (Object.setPrototypeOf ? Object.setPrototypeOf(h, p) : h.__proto__ = p);
  }
  var c = function(h) {
    u(p, h);
    function p(m) {
      a(this, p);
      var g = o(this, h.call(this, m));
      return g.type = i.PSEUDO, g;
    }
    return p.prototype.toString = function() {
      var m = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.spaces.before, String(this.value), m, this.spaces.after].join("");
    }, p;
  }(n.default);
  t.default = c, e.exports = t.default;
}), O_ = re((t, e) => {
  t.__esModule = !0;
  var r = Eu(), n = s(r), i = Pr();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, p) {
    if (!(h instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, p) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return p && (typeof p == "object" || typeof p == "function") ? p : h;
  }
  function u(h, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof p);
    h.prototype = Object.create(p && p.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), p && (Object.setPrototypeOf ? Object.setPrototypeOf(h, p) : h.__proto__ = p);
  }
  var c = function(h) {
    u(p, h);
    function p(m) {
      a(this, p);
      var g = o(this, h.call(this, m));
      return g.type = i.ATTRIBUTE, g.raws = {}, g;
    }
    return p.prototype.toString = function() {
      var m = [this.spaces.before, "[", this.ns, this.attribute];
      return this.operator && m.push(this.operator), this.value && m.push(this.value), this.raws.insensitive ? m.push(this.raws.insensitive) : this.insensitive && m.push(" i"), m.push("]"), m.concat(this.spaces.after).join("");
    }, p;
  }(n.default);
  t.default = c, e.exports = t.default;
}), x_ = re((t, e) => {
  t.__esModule = !0;
  var r = Eu(), n = s(r), i = Pr();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, p) {
    if (!(h instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, p) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return p && (typeof p == "object" || typeof p == "function") ? p : h;
  }
  function u(h, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof p);
    h.prototype = Object.create(p && p.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), p && (Object.setPrototypeOf ? Object.setPrototypeOf(h, p) : h.__proto__ = p);
  }
  var c = function(h) {
    u(p, h);
    function p(m) {
      a(this, p);
      var g = o(this, h.call(this, m));
      return g.type = i.UNIVERSAL, g.value = "*", g;
    }
    return p;
  }(n.default);
  t.default = c, e.exports = t.default;
}), b_ = re((t, e) => {
  t.__esModule = !0;
  var r = Co(), n = s(r), i = Pr();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, p) {
    if (!(h instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, p) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return p && (typeof p == "object" || typeof p == "function") ? p : h;
  }
  function u(h, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof p);
    h.prototype = Object.create(p && p.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), p && (Object.setPrototypeOf ? Object.setPrototypeOf(h, p) : h.__proto__ = p);
  }
  var c = function(h) {
    u(p, h);
    function p(m) {
      a(this, p);
      var g = o(this, h.call(this, m));
      return g.type = i.COMBINATOR, g;
    }
    return p;
  }(n.default);
  t.default = c, e.exports = t.default;
}), D_ = re((t, e) => {
  t.__esModule = !0;
  var r = Co(), n = s(r), i = Pr();
  function s(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function a(h, p) {
    if (!(h instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(h, p) {
    if (!h)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return p && (typeof p == "object" || typeof p == "function") ? p : h;
  }
  function u(h, p) {
    if (typeof p != "function" && p !== null)
      throw new TypeError("Super expression must either be null or a function, not " + typeof p);
    h.prototype = Object.create(p && p.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }), p && (Object.setPrototypeOf ? Object.setPrototypeOf(h, p) : h.__proto__ = p);
  }
  var c = function(h) {
    u(p, h);
    function p(m) {
      a(this, p);
      var g = o(this, h.call(this, m));
      return g.type = i.NESTING, g.value = "&", g;
    }
    return p;
  }(n.default);
  t.default = c, e.exports = t.default;
}), v_ = re((t, e) => {
  t.__esModule = !0, t.default = r;
  function r(n) {
    return n.sort(function(i, s) {
      return i - s;
    });
  }
  e.exports = t.default;
}), S_ = re((t, e) => {
  t.__esModule = !0, t.default = M;
  var r = 39, n = 34, i = 92, s = 47, a = 10, o = 32, u = 12, c = 9, h = 13, p = 43, m = 62, g = 126, O = 124, b = 44, D = 40, S = 41, x = 91, w = 93, T = 59, C = 42, A = 58, P = 38, $ = 64, B = /[ \n\t\r\{\(\)'"\\;/]/g, _ = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
  function M(Y) {
    for (var J = [], R = Y.css.valueOf(), q = void 0, X = void 0, H = void 0, ye = void 0, Ce = void 0, Se = void 0, Ne = void 0, Te = void 0, Me = void 0, Ee = void 0, nt = void 0, se = R.length, V = -1, W = 1, j = 0, le = function(De, we) {
      if (Y.safe)
        R += we, X = R.length - 1;
      else
        throw Y.error("Unclosed " + De, W, j - V, j);
    }; j < se; ) {
      switch (q = R.charCodeAt(j), q === a && (V = j, W += 1), q) {
        case a:
        case o:
        case c:
        case h:
        case u:
          X = j;
          do
            X += 1, q = R.charCodeAt(X), q === a && (V = X, W += 1);
          while (q === o || q === a || q === c || q === h || q === u);
          J.push(["space", R.slice(j, X), W, j - V, j]), j = X - 1;
          break;
        case p:
        case m:
        case g:
        case O:
          X = j;
          do
            X += 1, q = R.charCodeAt(X);
          while (q === p || q === m || q === g || q === O);
          J.push(["combinator", R.slice(j, X), W, j - V, j]), j = X - 1;
          break;
        case C:
          J.push(["*", "*", W, j - V, j]);
          break;
        case P:
          J.push(["&", "&", W, j - V, j]);
          break;
        case b:
          J.push([",", ",", W, j - V, j]);
          break;
        case x:
          J.push(["[", "[", W, j - V, j]);
          break;
        case w:
          J.push(["]", "]", W, j - V, j]);
          break;
        case A:
          J.push([":", ":", W, j - V, j]);
          break;
        case T:
          J.push([";", ";", W, j - V, j]);
          break;
        case D:
          J.push(["(", "(", W, j - V, j]);
          break;
        case S:
          J.push([")", ")", W, j - V, j]);
          break;
        case r:
        case n:
          H = q === r ? "'" : '"', X = j;
          do
            for (Ee = !1, X = R.indexOf(H, X + 1), X === -1 && le("quote", H), nt = X; R.charCodeAt(nt - 1) === i; )
              nt -= 1, Ee = !Ee;
          while (Ee);
          J.push(["string", R.slice(j, X + 1), W, j - V, W, X - V, j]), j = X;
          break;
        case $:
          B.lastIndex = j + 1, B.test(R), B.lastIndex === 0 ? X = R.length - 1 : X = B.lastIndex - 2, J.push(["at-word", R.slice(j, X + 1), W, j - V, W, X - V, j]), j = X;
          break;
        case i:
          for (X = j, Ne = !0; R.charCodeAt(X + 1) === i; )
            X += 1, Ne = !Ne;
          q = R.charCodeAt(X + 1), Ne && q !== s && q !== o && q !== a && q !== c && q !== h && q !== u && (X += 1), J.push(["word", R.slice(j, X + 1), W, j - V, W, X - V, j]), j = X;
          break;
        default:
          q === s && R.charCodeAt(j + 1) === C ? (X = R.indexOf("*/", j + 2) + 1, X === 0 && le("comment", "*/"), Se = R.slice(j, X + 1), ye = Se.split(`
`), Ce = ye.length - 1, Ce > 0 ? (Te = W + Ce, Me = X - ye[Ce].length) : (Te = W, Me = V), J.push(["comment", Se, W, j - V, Te, X - Me, j]), V = Me, W = Te, j = X) : (_.lastIndex = j + 1, _.test(R), _.lastIndex === 0 ? X = R.length - 1 : X = _.lastIndex - 2, J.push(["word", R.slice(j, X + 1), W, j - V, W, X - V, j]), j = X);
          break;
      }
      j++;
    }
    return J;
  }
  e.exports = t.default;
}), w_ = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function V(W, j) {
      for (var le = 0; le < j.length; le++) {
        var De = j[le];
        De.enumerable = De.enumerable || !1, De.configurable = !0, "value" in De && (De.writable = !0), Object.defineProperty(W, De.key, De);
      }
    }
    return function(W, j, le) {
      return j && V(W.prototype, j), le && V(W, le), W;
    };
  }(), n = V2(), i = Ee(n), s = Y2(), a = Ee(s), o = U2(), u = Ee(o), c = c_(), h = Ee(c), p = h_(), m = Ee(p), g = p_(), O = Ee(g), b = d_(), D = Ee(b), S = f_(), x = Ee(S), w = m_(), T = Ee(w), C = g_(), A = Ee(C), P = y_(), $ = Ee(P), B = O_(), _ = Ee(B), M = x_(), Y = Ee(M), J = b_(), R = Ee(J), q = D_(), X = Ee(q), H = v_(), ye = Ee(H), Ce = S_(), Se = Ee(Ce), Ne = Pr(), Te = Me(Ne);
  function Me(V) {
    if (V && V.__esModule)
      return V;
    var W = {};
    if (V != null)
      for (var j in V)
        Object.prototype.hasOwnProperty.call(V, j) && (W[j] = V[j]);
    return W.default = V, W;
  }
  function Ee(V) {
    return V && V.__esModule ? V : { default: V };
  }
  function nt(V, W) {
    if (!(V instanceof W))
      throw new TypeError("Cannot call a class as a function");
  }
  var se = function() {
    function V(W) {
      nt(this, V), this.input = W, this.lossy = W.options.lossless === !1, this.position = 0, this.root = new h.default();
      var j = new m.default();
      return this.root.append(j), this.current = j, this.lossy ? this.tokens = (0, Se.default)({ safe: W.safe, css: W.css.trim() }) : this.tokens = (0, Se.default)(W), this.loop();
    }
    return V.prototype.attribute = function() {
      var W = "", j = void 0, le = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; )
        W += this.tokens[this.position][1], this.position++;
      this.position === this.tokens.length && !~W.indexOf("]") && this.error("Expected a closing square bracket.");
      var De = W.split(/((?:[*~^$|]?=))([^]*)/), we = De[0].split(/(\|)/g), Dt = { operator: De[1], value: De[2], source: { start: { line: le[2], column: le[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: le[4] };
      if (we.length > 1 ? (we[0] === "" && (we[0] = !0), Dt.attribute = this.parseValue(we[2]), Dt.namespace = this.parseNamespace(we[0])) : Dt.attribute = this.parseValue(De[0]), j = new _.default(Dt), De[2]) {
        var it = De[2].split(/(\s+i\s*?)$/), ht = it[0].trim();
        j.value = this.lossy ? ht : it[0], it[1] && (j.insensitive = !0, this.lossy || (j.raws.insensitive = it[1])), j.quoted = ht[0] === "'" || ht[0] === '"', j.raws.unquoted = j.quoted ? ht.slice(1, -1) : ht;
      }
      this.newNode(j), this.position++;
    }, V.prototype.combinator = function() {
      if (this.currToken[1] === "|")
        return this.namespace();
      for (var W = new R.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); )
        this.nextToken && this.nextToken[0] === "combinator" ? (W.spaces.before = this.parseSpace(this.currToken[1]), W.source.start.line = this.nextToken[2], W.source.start.column = this.nextToken[3], W.source.end.column = this.nextToken[3], W.source.end.line = this.nextToken[2], W.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? W.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? W.value = this.currToken[1] : this.currToken[0] === "space" && (W.value = this.parseSpace(this.currToken[1], " ")), this.position++;
      return this.newNode(W);
    }, V.prototype.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = !0, this.position++;
        return;
      }
      var W = new m.default();
      this.current.parent.append(W), this.current = W, this.position++;
    }, V.prototype.comment = function() {
      var W = new D.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
      this.newNode(W), this.position++;
    }, V.prototype.error = function(W) {
      throw new this.input.error(W);
    }, V.prototype.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.");
    }, V.prototype.missingParenthesis = function() {
      return this.error("Expected opening parenthesis.");
    }, V.prototype.missingSquareBracket = function() {
      return this.error("Expected opening square bracket.");
    }, V.prototype.namespace = function() {
      var W = this.prevToken && this.prevToken[1] || !0;
      if (this.nextToken[0] === "word")
        return this.position++, this.word(W);
      if (this.nextToken[0] === "*")
        return this.position++, this.universal(W);
    }, V.prototype.nesting = function() {
      this.newNode(new X.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
    }, V.prototype.parentheses = function() {
      var W = this.current.last;
      if (W && W.type === Te.PSEUDO) {
        var j = new m.default(), le = this.current;
        W.append(j), this.current = j;
        var De = 1;
        for (this.position++; this.position < this.tokens.length && De; )
          this.currToken[0] === "(" && De++, this.currToken[0] === ")" && De--, De ? this.parse() : (j.parent.source.end.line = this.currToken[2], j.parent.source.end.column = this.currToken[3], this.position++);
        De && this.error("Expected closing parenthesis."), this.current = le;
      } else {
        var we = 1;
        for (this.position++, W.value += "("; this.position < this.tokens.length && we; )
          this.currToken[0] === "(" && we++, this.currToken[0] === ")" && we--, W.value += this.parseParenthesisToken(this.currToken), this.position++;
        we && this.error("Expected closing parenthesis.");
      }
    }, V.prototype.pseudo = function() {
      for (var W = this, j = "", le = this.currToken; this.currToken && this.currToken[0] === ":"; )
        j += this.currToken[1], this.position++;
      if (!this.currToken)
        return this.error("Expected pseudo-class or pseudo-element");
      if (this.currToken[0] === "word") {
        var De = void 0;
        this.splitWord(!1, function(we, Dt) {
          j += we, De = new $.default({ value: j, source: { start: { line: le[2], column: le[3] }, end: { line: W.currToken[4], column: W.currToken[5] } }, sourceIndex: le[4] }), W.newNode(De), Dt > 1 && W.nextToken && W.nextToken[0] === "(" && W.error("Misplaced parenthesis.");
        });
      } else
        this.error('Unexpected "' + this.currToken[0] + '" found.');
    }, V.prototype.space = function() {
      var W = this.currToken;
      this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(W[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(W[1]), this.position++) : this.combinator();
    }, V.prototype.string = function() {
      var W = this.currToken;
      this.newNode(new A.default({ value: this.currToken[1], source: { start: { line: W[2], column: W[3] }, end: { line: W[4], column: W[5] } }, sourceIndex: W[6] })), this.position++;
    }, V.prototype.universal = function(W) {
      var j = this.nextToken;
      if (j && j[1] === "|")
        return this.position++, this.namespace();
      this.newNode(new Y.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), W), this.position++;
    }, V.prototype.splitWord = function(W, j) {
      for (var le = this, De = this.nextToken, we = this.currToken[1]; De && De[0] === "word"; ) {
        this.position++;
        var Dt = this.currToken[1];
        if (we += Dt, Dt.lastIndexOf("\\") === Dt.length - 1) {
          var it = this.nextToken;
          it && it[0] === "space" && (we += this.parseSpace(it[1], " "), this.position++);
        }
        De = this.nextToken;
      }
      var ht = (0, a.default)(we, "."), It = (0, a.default)(we, "#"), Dn = (0, a.default)(we, "#{");
      Dn.length && (It = It.filter(function(rr) {
        return !~Dn.indexOf(rr);
      }));
      var tr = (0, ye.default)((0, u.default)((0, i.default)([[0], ht, It])));
      tr.forEach(function(rr, kt) {
        var $r = tr[kt + 1] || we.length, br = we.slice(rr, $r);
        if (kt === 0 && j)
          return j.call(le, br, tr.length);
        var tn = void 0;
        ~ht.indexOf(rr) ? tn = new O.default({ value: br.slice(1), source: { start: { line: le.currToken[2], column: le.currToken[3] + rr }, end: { line: le.currToken[4], column: le.currToken[3] + ($r - 1) } }, sourceIndex: le.currToken[6] + tr[kt] }) : ~It.indexOf(rr) ? tn = new x.default({ value: br.slice(1), source: { start: { line: le.currToken[2], column: le.currToken[3] + rr }, end: { line: le.currToken[4], column: le.currToken[3] + ($r - 1) } }, sourceIndex: le.currToken[6] + tr[kt] }) : tn = new T.default({ value: br, source: { start: { line: le.currToken[2], column: le.currToken[3] + rr }, end: { line: le.currToken[4], column: le.currToken[3] + ($r - 1) } }, sourceIndex: le.currToken[6] + tr[kt] }), le.newNode(tn, W);
      }), this.position++;
    }, V.prototype.word = function(W) {
      var j = this.nextToken;
      return j && j[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(W);
    }, V.prototype.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(!0);
      return this.root;
    }, V.prototype.parse = function(W) {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parentheses();
          break;
        case ")":
          W && this.missingParenthesis();
          break;
        case "[":
          this.attribute();
          break;
        case "]":
          this.missingSquareBracket();
          break;
        case "at-word":
        case "word":
          this.word();
          break;
        case ":":
          this.pseudo();
          break;
        case ";":
          this.missingBackslash();
          break;
        case ",":
          this.comma();
          break;
        case "*":
          this.universal();
          break;
        case "&":
          this.nesting();
          break;
        case "combinator":
          this.combinator();
          break;
        case "string":
          this.string();
          break;
      }
    }, V.prototype.parseNamespace = function(W) {
      if (this.lossy && typeof W == "string") {
        var j = W.trim();
        return j.length ? j : !0;
      }
      return W;
    }, V.prototype.parseSpace = function(W, j) {
      return this.lossy ? j || "" : W;
    }, V.prototype.parseValue = function(W) {
      return this.lossy && W && typeof W == "string" ? W.trim() : W;
    }, V.prototype.parseParenthesisToken = function(W) {
      return this.lossy ? W[0] === "space" ? this.parseSpace(W[1], " ") : this.parseValue(W[1]) : W[1];
    }, V.prototype.newNode = function(W, j) {
      return j && (W.namespace = this.parseNamespace(j)), this.spaces && (W.spaces.before = this.spaces, this.spaces = ""), this.current.append(W);
    }, r(V, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), V;
  }();
  t.default = se, e.exports = t.default;
}), C_ = re((t, e) => {
  t.__esModule = !0;
  var r = /* @__PURE__ */ function() {
    function u(c, h) {
      for (var p = 0; p < h.length; p++) {
        var m = h[p];
        m.enumerable = m.enumerable || !1, m.configurable = !0, "value" in m && (m.writable = !0), Object.defineProperty(c, m.key, m);
      }
    }
    return function(c, h, p) {
      return h && u(c.prototype, h), p && u(c, p), c;
    };
  }(), n = w_(), i = s(n);
  function s(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function a(u, c) {
    if (!(u instanceof c))
      throw new TypeError("Cannot call a class as a function");
  }
  var o = function() {
    function u(c) {
      return a(this, u), this.func = c || function() {
      }, this;
    }
    return u.prototype.process = function(c) {
      var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = new i.default({ css: c, error: function(m) {
        throw new Error(m);
      }, options: h });
      return this.res = p, this.func(p), this;
    }, r(u, [{ key: "result", get: function() {
      return String(this.res);
    } }]), u;
  }();
  t.default = o, e.exports = t.default;
}), hi = re((t, e) => {
  var r = function(n, i) {
    let s = new n.constructor();
    for (let a in n) {
      if (!n.hasOwnProperty(a))
        continue;
      let o = n[a], u = typeof o;
      a === "parent" && u === "object" ? i && (s[a] = i) : a === "source" ? s[a] = o : o instanceof Array ? s[a] = o.map((c) => r(c, s)) : a !== "before" && a !== "after" && a !== "between" && a !== "semicolon" && (u === "object" && o !== null && (o = r(o)), s[a] = o);
    }
    return s;
  };
  e.exports = class {
    constructor(n) {
      n = n || {}, this.raws = { before: "", after: "" };
      for (let i in n)
        this[i] = n[i];
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    toString() {
      return [this.raws.before, String(this.value), this.raws.after].join("");
    }
    clone(n) {
      n = n || {};
      let i = r(this);
      for (let s in n)
        i[s] = n[s];
      return i;
    }
    cloneBefore(n) {
      n = n || {};
      let i = this.clone(n);
      return this.parent.insertBefore(this, i), i;
    }
    cloneAfter(n) {
      n = n || {};
      let i = this.clone(n);
      return this.parent.insertAfter(this, i), i;
    }
    replaceWith() {
      let n = Array.prototype.slice.call(arguments);
      if (this.parent) {
        for (let i of n)
          this.parent.insertBefore(this, i);
        this.remove();
      }
      return this;
    }
    moveTo(n) {
      return this.cleanRaws(this.root() === n.root()), this.remove(), n.append(this), this;
    }
    moveBefore(n) {
      return this.cleanRaws(this.root() === n.root()), this.remove(), n.parent.insertBefore(n, this), this;
    }
    moveAfter(n) {
      return this.cleanRaws(this.root() === n.root()), this.remove(), n.parent.insertAfter(n, this), this;
    }
    next() {
      let n = this.parent.index(this);
      return this.parent.nodes[n + 1];
    }
    prev() {
      let n = this.parent.index(this);
      return this.parent.nodes[n - 1];
    }
    toJSON() {
      let n = {};
      for (let i in this) {
        if (!this.hasOwnProperty(i) || i === "parent")
          continue;
        let s = this[i];
        s instanceof Array ? n[i] = s.map((a) => typeof a == "object" && a.toJSON ? a.toJSON() : a) : typeof s == "object" && s.toJSON ? n[i] = s.toJSON() : n[i] = s;
      }
      return n;
    }
    root() {
      let n = this;
      for (; n.parent; )
        n = n.parent;
      return n;
    }
    cleanRaws(n) {
      delete this.raws.before, delete this.raws.after, n || delete this.raws.between;
    }
    positionInside(n) {
      let i = this.toString(), s = this.source.start.column, a = this.source.start.line;
      for (let o = 0; o < n; o++)
        i[o] === `
` ? (s = 1, a += 1) : s += 1;
      return { line: a, column: s };
    }
    positionBy(n) {
      let i = this.source.start;
      if (Object(n).index)
        i = this.positionInside(n.index);
      else if (Object(n).word) {
        let s = this.toString().indexOf(n.word);
        s !== -1 && (i = this.positionInside(s));
      }
      return i;
    }
  };
}), Kr = re((t, e) => {
  var r = hi(), n = class extends r {
    constructor(i) {
      super(i), this.nodes || (this.nodes = []);
    }
    push(i) {
      return i.parent = this, this.nodes.push(i), this;
    }
    each(i) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let s = this.lastEach, a, o;
      if (this.indexes[s] = 0, !!this.nodes) {
        for (; this.indexes[s] < this.nodes.length && (a = this.indexes[s], o = i(this.nodes[a], a), o !== !1); )
          this.indexes[s] += 1;
        return delete this.indexes[s], o;
      }
    }
    walk(i) {
      return this.each((s, a) => {
        let o = i(s, a);
        return o !== !1 && s.walk && (o = s.walk(i)), o;
      });
    }
    walkType(i, s) {
      if (!i || !s)
        throw new Error("Parameters {type} and {callback} are required.");
      let a = typeof i == "function";
      return this.walk((o, u) => {
        if (a && o instanceof i || !a && o.type === i)
          return s.call(this, o, u);
      });
    }
    append(i) {
      return i.parent = this, this.nodes.push(i), this;
    }
    prepend(i) {
      return i.parent = this, this.nodes.unshift(i), this;
    }
    cleanRaws(i) {
      if (super.cleanRaws(i), this.nodes)
        for (let s of this.nodes)
          s.cleanRaws(i);
    }
    insertAfter(i, s) {
      let a = this.index(i), o;
      this.nodes.splice(a + 1, 0, s);
      for (let u in this.indexes)
        o = this.indexes[u], a <= o && (this.indexes[u] = o + this.nodes.length);
      return this;
    }
    insertBefore(i, s) {
      let a = this.index(i), o;
      this.nodes.splice(a, 0, s);
      for (let u in this.indexes)
        o = this.indexes[u], a <= o && (this.indexes[u] = o + this.nodes.length);
      return this;
    }
    removeChild(i) {
      i = this.index(i), this.nodes[i].parent = void 0, this.nodes.splice(i, 1);
      let s;
      for (let a in this.indexes)
        s = this.indexes[a], s >= i && (this.indexes[a] = s - 1);
      return this;
    }
    removeAll() {
      for (let i of this.nodes)
        i.parent = void 0;
      return this.nodes = [], this;
    }
    every(i) {
      return this.nodes.every(i);
    }
    some(i) {
      return this.nodes.some(i);
    }
    index(i) {
      return typeof i == "number" ? i : this.nodes.indexOf(i);
    }
    get first() {
      if (this.nodes)
        return this.nodes[0];
    }
    get last() {
      if (this.nodes)
        return this.nodes[this.nodes.length - 1];
    }
    toString() {
      let i = this.nodes.map(String).join("");
      return this.value && (i = this.value + i), this.raws.before && (i = this.raws.before + i), this.raws.after && (i += this.raws.after), i;
    }
  };
  n.registerWalker = (i) => {
    let s = "walk" + i.name;
    s.lastIndexOf("s") !== s.length - 1 && (s += "s"), !n.prototype[s] && (n.prototype[s] = function(a) {
      return this.walkType(i, a);
    });
  }, e.exports = n;
}), E_ = re((t, e) => {
  var r = Kr();
  e.exports = class extends r {
    constructor(n) {
      super(n), this.type = "root";
    }
  };
}), A_ = re((t, e) => {
  var r = Kr();
  e.exports = class extends r {
    constructor(n) {
      super(n), this.type = "value", this.unbalanced = 0;
    }
  };
}), T_ = re((t, e) => {
  var r = Kr(), n = class extends r {
    constructor(i) {
      super(i), this.type = "atword";
    }
    toString() {
      return this.quoted && this.raws.quote, [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
    }
  };
  r.registerWalker(n), e.exports = n;
}), k_ = re((t, e) => {
  var r = Kr(), n = hi(), i = class extends n {
    constructor(s) {
      super(s), this.type = "colon";
    }
  };
  r.registerWalker(i), e.exports = i;
}), P_ = re((t, e) => {
  var r = Kr(), n = hi(), i = class extends n {
    constructor(s) {
      super(s), this.type = "comma";
    }
  };
  r.registerWalker(i), e.exports = i;
}), F_ = re((t, e) => {
  var r = Kr(), n = hi(), i = class extends n {
    constructor(s) {
      super(s), this.type = "comment", this.inline = Object(s).inline || !1;
    }
    toString() {
      return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
    }
  };
  r.registerWalker(i), e.exports = i;
}), $_ = re((t, e) => {
  var r = Kr(), n = class extends r {
    constructor(i) {
      super(i), this.type = "func", this.unbalanced = -1;
    }
  };
  r.registerWalker(n), e.exports = n;
}), B_ = re((t, e) => {
  var r = Kr(), n = hi(), i = class extends n {
    constructor(s) {
      super(s), this.type = "number", this.unit = Object(s).unit || "";
    }
    toString() {
      return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
    }
  };
  r.registerWalker(i), e.exports = i;
}), I_ = re((t, e) => {
  var r = Kr(), n = hi(), i = class extends n {
    constructor(s) {
      super(s), this.type = "operator";
    }
  };
  r.registerWalker(i), e.exports = i;
}), N_ = re((t, e) => {
  var r = Kr(), n = hi(), i = class extends n {
    constructor(s) {
      super(s), this.type = "paren", this.parenType = "";
    }
  };
  r.registerWalker(i), e.exports = i;
}), __ = re((t, e) => {
  var r = Kr(), n = hi(), i = class extends n {
    constructor(s) {
      super(s), this.type = "string";
    }
    toString() {
      let s = this.quoted ? this.raws.quote : "";
      return [this.raws.before, s, this.value + "", s, this.raws.after].join("");
    }
  };
  r.registerWalker(i), e.exports = i;
}), Q_ = re((t, e) => {
  var r = Kr(), n = hi(), i = class extends n {
    constructor(s) {
      super(s), this.type = "word";
    }
  };
  r.registerWalker(i), e.exports = i;
}), M_ = re((t, e) => {
  var r = Kr(), n = hi(), i = class extends n {
    constructor(s) {
      super(s), this.type = "unicode-range";
    }
  };
  r.registerWalker(i), e.exports = i;
}), L_ = re((t, e) => {
  var r = class extends Error {
    constructor(n) {
      super(n), this.name = this.constructor.name, this.message = n || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(n).stack;
    }
  };
  e.exports = r;
}), R_ = re((t, e) => {
  var r = /[ \n\t\r\{\(\)'"\\;,/]/g, n = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, i = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, s = /^[a-z0-9]/i, a = /^[a-f0-9?\-]/i, o = L_();
  e.exports = function(u, c) {
    c = c || {};
    let h = [], p = u.valueOf(), m = p.length, g = -1, O = 1, b = 0, D = 0, S = null, x, w, T, C, A, P, $, B, _, M, Y;
    function J(R) {
      let q = `Unclosed ${R} at line: ${O}, column: ${b - g}, token: ${b}`;
      throw new o(q);
    }
    for (; b < m; ) {
      switch (x = p.charCodeAt(b), x === 10 && (g = b, O += 1), x) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12:
          w = b;
          do
            w += 1, x = p.charCodeAt(w), x === 10 && (g = w, O += 1);
          while (x === 32 || x === 10 || x === 9 || x === 13 || x === 12);
          h.push(["space", p.slice(b, w), O, b - g, O, w - g, b]), b = w - 1;
          break;
        case 58:
          w = b + 1, h.push(["colon", p.slice(b, w), O, b - g, O, w - g, b]), b = w - 1;
          break;
        case 44:
          w = b + 1, h.push(["comma", p.slice(b, w), O, b - g, O, w - g, b]), b = w - 1;
          break;
        case 123:
          h.push(["{", "{", O, b - g, O, w - g, b]);
          break;
        case 125:
          h.push(["}", "}", O, b - g, O, w - g, b]);
          break;
        case 40:
          D++, S = !S && D === 1 && h.length > 0 && h[h.length - 1][0] === "word" && h[h.length - 1][1] === "url", h.push(["(", "(", O, b - g, O, w - g, b]);
          break;
        case 41:
          D--, S = S && D > 0, h.push([")", ")", O, b - g, O, w - g, b]);
          break;
        case 39:
        case 34:
          T = x === 39 ? "'" : '"', w = b;
          do
            for (_ = !1, w = p.indexOf(T, w + 1), w === -1 && J("quote"), M = w; p.charCodeAt(M - 1) === 92; )
              M -= 1, _ = !_;
          while (_);
          h.push(["string", p.slice(b, w + 1), O, b - g, O, w - g, b]), b = w;
          break;
        case 64:
          r.lastIndex = b + 1, r.test(p), r.lastIndex === 0 ? w = p.length - 1 : w = r.lastIndex - 2, h.push(["atword", p.slice(b, w + 1), O, b - g, O, w - g, b]), b = w;
          break;
        case 92:
          w = b, x = p.charCodeAt(w + 1), h.push(["word", p.slice(b, w + 1), O, b - g, O, w - g, b]), b = w;
          break;
        case 43:
        case 45:
        case 42:
          if (w = b + 1, Y = p.slice(b + 1, w + 1), p.slice(b - 1, b), x === 45 && Y.charCodeAt(0) === 45) {
            w++, h.push(["word", p.slice(b, w), O, b - g, O, w - g, b]), b = w - 1;
            break;
          }
          h.push(["operator", p.slice(b, w), O, b - g, O, w - g, b]), b = w - 1;
          break;
        default:
          if (x === 47 && (p.charCodeAt(b + 1) === 42 || c.loose && !S && p.charCodeAt(b + 1) === 47)) {
            if (p.charCodeAt(b + 1) === 42)
              w = p.indexOf("*/", b + 2) + 1, w === 0 && J("comment");
            else {
              let R = p.indexOf(`
`, b + 2);
              w = R !== -1 ? R - 1 : m;
            }
            P = p.slice(b, w + 1), C = P.split(`
`), A = C.length - 1, A > 0 ? ($ = O + A, B = w - C[A].length) : ($ = O, B = g), h.push(["comment", P, O, b - g, $, w - B, b]), g = B, O = $, b = w;
          } else if (x === 35 && !s.test(p.slice(b + 1, b + 2)))
            w = b + 1, h.push(["#", p.slice(b, w), O, b - g, O, w - g, b]), b = w - 1;
          else if ((x === 117 || x === 85) && p.charCodeAt(b + 1) === 43) {
            w = b + 2;
            do
              w += 1, x = p.charCodeAt(w);
            while (w < m && a.test(p.slice(w, w + 1)));
            h.push(["unicoderange", p.slice(b, w), O, b - g, O, w - g, b]), b = w - 1;
          } else if (x === 47)
            w = b + 1, h.push(["operator", p.slice(b, w), O, b - g, O, w - g, b]), b = w - 1;
          else {
            let R = n;
            if (x >= 48 && x <= 57 && (R = i), R.lastIndex = b + 1, R.test(p), R.lastIndex === 0 ? w = p.length - 1 : w = R.lastIndex - 2, R === i || x === 46) {
              let q = p.charCodeAt(w), X = p.charCodeAt(w + 1), H = p.charCodeAt(w + 2);
              (q === 101 || q === 69) && (X === 45 || X === 43) && H >= 48 && H <= 57 && (i.lastIndex = w + 2, i.test(p), i.lastIndex === 0 ? w = p.length - 1 : w = i.lastIndex - 2);
            }
            h.push(["word", p.slice(b, w + 1), O, b - g, O, w - g, b]), b = w;
          }
          break;
      }
      b++;
    }
    return h;
  };
}), j_ = re((t, e) => {
  var r = class extends Error {
    constructor(n) {
      super(n), this.name = this.constructor.name, this.message = n || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(n).stack;
    }
  };
  e.exports = r;
}), Z_ = re((t, e) => {
  var r = E_(), n = A_(), i = T_(), s = k_(), a = P_(), o = F_(), u = $_(), c = B_(), h = I_(), p = N_(), m = __(), g = Q_(), O = M_(), b = R_(), D = V2(), S = Y2(), x = U2(), w = j_();
  function T(C) {
    return C.sort((A, P) => A - P);
  }
  e.exports = class {
    constructor(C, A) {
      let P = { loose: !1 };
      this.cache = [], this.input = C, this.options = Object.assign({}, P, A), this.position = 0, this.unbalanced = 0, this.root = new r();
      let $ = new n();
      this.root.append($), this.current = $, this.tokens = b(C, this.options);
    }
    parse() {
      return this.loop();
    }
    colon() {
      let C = this.currToken;
      this.newNode(new s({ value: C[1], source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6] })), this.position++;
    }
    comma() {
      let C = this.currToken;
      this.newNode(new a({ value: C[1], source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6] })), this.position++;
    }
    comment() {
      let C = !1, A = this.currToken[1].replace(/\/\*|\*\//g, ""), P;
      this.options.loose && A.startsWith("//") && (A = A.substring(2), C = !0), P = new o({ value: A, inline: C, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] }), this.newNode(P), this.position++;
    }
    error(C, A) {
      throw new w(C + ` at line: ${A[2]}, column ${A[3]}`);
    }
    loop() {
      for (; this.position < this.tokens.length; )
        this.parseTokens();
      return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
    }
    operator() {
      let C = this.currToken[1], A;
      if (C === "+" || C === "-") {
        if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? this.prevToken[0] !== "space" && this.prevToken[0] !== "(" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "word" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(" && this.error("Syntax Error", this.currToken) : (this.nextToken[0] === "space" || this.nextToken[0] === "operator" || this.prevToken[0] === "operator") && this.error("Syntax Error", this.currToken)), this.options.loose) {
          if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word")
            return this.word();
        } else if (this.nextToken[0] === "word")
          return this.word();
      }
      return A = new h({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), this.position++, this.newNode(A);
    }
    parseTokens() {
      switch (this.currToken[0]) {
        case "space":
          this.space();
          break;
        case "colon":
          this.colon();
          break;
        case "comma":
          this.comma();
          break;
        case "comment":
          this.comment();
          break;
        case "(":
          this.parenOpen();
          break;
        case ")":
          this.parenClose();
          break;
        case "atword":
        case "word":
          this.word();
          break;
        case "operator":
          this.operator();
          break;
        case "string":
          this.string();
          break;
        case "unicoderange":
          this.unicodeRange();
          break;
        default:
          this.word();
          break;
      }
    }
    parenOpen() {
      let C = 1, A = this.position + 1, P = this.currToken, $;
      for (; A < this.tokens.length && C; ) {
        let B = this.tokens[A];
        B[0] === "(" && C++, B[0] === ")" && C--, A++;
      }
      if (C && this.error("Expected closing parenthesis", P), $ = this.current.last, $ && $.type === "func" && $.unbalanced < 0 && ($.unbalanced = 0, this.current = $), this.current.unbalanced++, this.newNode(new p({ value: P[1], source: { start: { line: P[2], column: P[3] }, end: { line: P[4], column: P[5] } }, sourceIndex: P[6] })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
        let B = this.nextToken, _ = this.currToken[1], M = { line: this.currToken[2], column: this.currToken[3] };
        for (; B && B[0] !== ")" && this.current.unbalanced; )
          this.position++, _ += this.currToken[1], B = this.nextToken;
        this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new g({ value: _, source: { start: M, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
      }
    }
    parenClose() {
      let C = this.currToken;
      this.newNode(new p({ value: C[1], source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6] })), this.position++, !(this.position >= this.tokens.length - 1 && !this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", C), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
    }
    space() {
      let C = this.currToken;
      this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += C[1], this.position++) : (this.spaces = C[1], this.position++);
    }
    unicodeRange() {
      let C = this.currToken;
      this.newNode(new O({ value: C[1], source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6] })), this.position++;
    }
    splitWord() {
      let C = this.nextToken, A = this.currToken[1], P = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/, $ = /^(?!\#([a-z0-9]+))[\#\{\}]/gi, B, _;
      if (!$.test(A))
        for (; C && C[0] === "word"; ) {
          this.position++;
          let M = this.currToken[1];
          A += M, C = this.nextToken;
        }
      B = S(A, "@"), _ = T(x(D([[0], B]))), _.forEach((M, Y) => {
        let J = _[Y + 1] || A.length, R = A.slice(M, J), q;
        if (~B.indexOf(M))
          q = new i({ value: R.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + M }, end: { line: this.currToken[4], column: this.currToken[3] + (J - 1) } }, sourceIndex: this.currToken[6] + _[Y] });
        else if (P.test(this.currToken[1])) {
          let X = R.replace(P, "");
          q = new c({ value: R.replace(X, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + M }, end: { line: this.currToken[4], column: this.currToken[3] + (J - 1) } }, sourceIndex: this.currToken[6] + _[Y], unit: X });
        } else
          q = new (C && C[0] === "(" ? u : g)({ value: R, source: { start: { line: this.currToken[2], column: this.currToken[3] + M }, end: { line: this.currToken[4], column: this.currToken[3] + (J - 1) } }, sourceIndex: this.currToken[6] + _[Y] }), q.type === "word" ? (q.isHex = /^#(.+)/.test(R), q.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(R)) : this.cache.push(this.current);
        this.newNode(q);
      }), this.position++;
    }
    string() {
      let C = this.currToken, A = this.currToken[1], P = /^(\"|\')/, $ = P.test(A), B = "", _;
      $ && (B = A.match(P)[0], A = A.slice(1, A.length - 1)), _ = new m({ value: A, source: { start: { line: C[2], column: C[3] }, end: { line: C[4], column: C[5] } }, sourceIndex: C[6], quoted: $ }), _.raws.quote = B, this.newNode(_), this.position++;
    }
    word() {
      return this.splitWord();
    }
    newNode(C) {
      return this.spaces && (C.raws.before += this.spaces, this.spaces = ""), this.current.append(C);
    }
    get currToken() {
      return this.tokens[this.position];
    }
    get nextToken() {
      return this.tokens[this.position + 1];
    }
    get prevToken() {
      return this.tokens[this.position - 1];
    }
  };
}), z2 = {};
B2(z2, { languages: () => IQ, options: () => QQ, parsers: () => CS, printers: () => y9 });
var W_ = (t, e, r, n) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
}, Xt = W_, G2 = "string", H2 = "array", J2 = "cursor", Sy = "indent", wy = "align", K2 = "trim", Cy = "group", jl = "fill", Lp = "if-break", eS = "indent-if-break", tS = "line-suffix", rS = "line-suffix-boundary", Eo = "line", nS = "label", Ey = "break-parent", iS = /* @__PURE__ */ new Set([J2, Sy, wy, K2, Cy, jl, Lp, eS, tS, rS, Eo, nS, Ey]);
function q_(t) {
  if (typeof t == "string")
    return G2;
  if (Array.isArray(t))
    return H2;
  if (!t)
    return;
  let { type: e } = t;
  if (iS.has(e))
    return e;
}
var sS = q_, X_ = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function V_(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (sS(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = X_([...iS].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`;
}
var Y_ = class extends Error {
  constructor(r) {
    super(V_(r));
    wn(this, "name", "InvalidDocError");
    this.doc = r;
  }
}, U_ = Y_, z_ = () => {
}, G_ = z_;
function jr(t) {
  return { type: Sy, contents: t };
}
function aS(t, e) {
  return { type: wy, contents: e, n: t };
}
function on(t, e = {}) {
  return G_(e.expandedStates), { type: Cy, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function H_(t) {
  return aS({ type: "root" }, t);
}
function bh(t) {
  return aS(-1, t);
}
function tm(t) {
  return { type: jl, parts: t };
}
function oS(t, e = "", r = {}) {
  return { type: Lp, breakContents: t, flatContents: e, groupId: r.groupId };
}
var Ay = { type: Ey }, J_ = { type: Eo, hard: !0 }, dr = { type: Eo }, An = { type: Eo, soft: !0 }, xt = [J_, Ay];
function Zs(t, e) {
  let r = [];
  for (let n = 0; n < e.length; n++)
    n !== 0 && r.push(t), r.push(e[n]);
  return r;
}
var K_ = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, Zl = K_, e7 = (t) => {
  if (Array.isArray(t))
    return t;
  if (t.type !== jl)
    throw new Error(`Expect doc to be 'array' or '${jl}'.`);
  return t.parts;
};
function t7(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return n(t);
  function n(s) {
    if (r.has(s))
      return r.get(s);
    let a = i(s);
    return r.set(s, a), a;
  }
  function i(s) {
    switch (sS(s)) {
      case H2:
        return e(s.map(n));
      case jl:
        return e({ ...s, parts: s.parts.map(n) });
      case Lp:
        return e({ ...s, breakContents: n(s.breakContents), flatContents: n(s.flatContents) });
      case Cy: {
        let { expandedStates: a, contents: o } = s;
        return a ? (a = a.map(n), o = a[0]) : o = n(o), e({ ...s, contents: o, expandedStates: a });
      }
      case wy:
      case Sy:
      case eS:
      case nS:
      case tS:
        return e({ ...s, contents: n(s.contents) });
      case G2:
      case J2:
      case K2:
      case rS:
      case Eo:
      case Ey:
        return e(s);
      default:
        throw new U_(s);
    }
  }
}
function r7(t) {
  return t.type === Eo && !t.hard ? t.soft ? "" : " " : t.type === Lp ? t.flatContents : t;
}
function n7(t) {
  return t7(t, r7);
}
function i7(t) {
  return Array.isArray(t) && t.length > 0;
}
var Rp = i7, cc = "'", C1 = '"';
function s7(t, e) {
  let r = e === !0 || e === cc ? cc : C1, n = r === cc ? C1 : cc, i = 0, s = 0;
  for (let a of t)
    a === r ? i++ : a === n && s++;
  return i > s ? n : r;
}
var a7 = s7;
function o7(t, e, r) {
  let n = e === '"' ? "'" : '"', i = Xt(!1, t, /\\(.)|(["'])/gs, (s, a, o) => a === n ? a : o === e ? "\\" + o : o || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(a) ? a : "\\" + a));
  return e + i + e;
}
var l7 = o7;
function u7(t, e) {
  let r = t.slice(1, -1), n = e.parser === "json" || e.parser === "jsonc" || e.parser === "json5" && e.quoteProps === "preserve" && !e.singleQuote ? '"' : e.__isInHtmlAttribute ? "'" : a7(r, e.singleQuote);
  return l7(r, n, !(e.parser === "css" || e.parser === "less" || e.parser === "scss" || e.__embeddedInHtml));
}
var lS = u7, c7 = class extends Error {
  constructor(r, n, i = "type") {
    super(`Unexpected ${n} node ${i}: ${JSON.stringify(r[i])}.`);
    wn(this, "name", "UnexpectedNodeError");
    this.node = r;
  }
}, h7 = c7;
function p7(t) {
  return (t == null ? void 0 : t.type) === "front-matter";
}
var Dh = p7, d7 = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma", "spaces"]);
function uS(t, e, r) {
  if (Dh(t) && t.lang === "yaml" && delete e.value, t.type === "css-comment" && r.type === "css-root" && r.nodes.length > 0 && ((r.nodes[0] === t || Dh(r.nodes[0]) && r.nodes[1] === t) && (delete e.text, /^\*\s*@(?:format|prettier)\s*$/.test(t.text)) || r.type === "css-root" && Zl(!1, r.nodes, -1) === t))
    return null;
  if (t.type === "value-root" && delete e.text, (t.type === "media-query" || t.type === "media-query-list" || t.type === "media-feature-expression") && delete e.value, t.type === "css-rule" && delete e.params, t.type === "selector-combinator" && (e.value = Xt(!1, e.value, /\s+/g, " ")), t.type === "media-feature" && (e.value = Xt(!1, e.value, " ", "")), (t.type === "value-word" && (t.isColor && t.isHex || ["initial", "inherit", "unset", "revert"].includes(e.value.toLowerCase())) || t.type === "media-feature" || t.type === "selector-root-invalid" || t.type === "selector-pseudo") && (e.value = e.value.toLowerCase()), t.type === "css-decl" && (e.prop = e.prop.toLowerCase()), (t.type === "css-atrule" || t.type === "css-import") && (e.name = e.name.toLowerCase()), t.type === "value-number" && (e.unit = e.unit.toLowerCase()), t.type === "value-unknown" && (e.value = Xt(!1, e.value, /;$/g, "")), (t.type === "media-feature" || t.type === "media-keyword" || t.type === "media-type" || t.type === "media-unknown" || t.type === "media-url" || t.type === "media-value" || t.type === "selector-attribute" || t.type === "selector-string" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "value-string") && e.value && (e.value = f7(e.value)), t.type === "selector-attribute" && (e.attribute = e.attribute.trim(), e.namespace && typeof e.namespace == "string" && (e.namespace = e.namespace.trim(), e.namespace.length === 0 && (e.namespace = !0)), e.value && (e.value = Xt(!1, e.value.trim(), /^["']|["']$/g, ""), delete e.quoted)), (t.type === "media-value" || t.type === "media-type" || t.type === "value-number" || t.type === "selector-root-invalid" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "selector-tag") && e.value && (e.value = Xt(!1, e.value, /([\d+.e-]+)([a-z]*)/gi, (n, i, s) => {
    let a = Number(i);
    return Number.isNaN(a) ? n : a + s.toLowerCase();
  })), t.type === "selector-tag") {
    let n = t.value.toLowerCase();
    ["from", "to"].includes(n) && (e.value = n);
  }
  if (t.type === "css-atrule" && t.name.toLowerCase() === "supports" && delete e.value, t.type === "selector-unknown" && delete e.value, t.type === "value-comma_group") {
    let n = t.groups.findIndex((i) => i.type === "value-number" && i.unit === "...");
    n !== -1 && (e.groups[n].unit = "", e.groups.splice(n + 1, 0, { type: "value-word", value: "...", isColor: !1, isHex: !1 }));
  }
  if (t.type === "value-comma_group" && t.groups.some((n) => n.type === "value-atword" && n.value.endsWith("[") || n.type === "value-word" && n.value.startsWith("]")))
    return { type: "value-atword", value: t.groups.map((n) => n.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
}
uS.ignoredProperties = d7;
function f7(t) {
  return Xt(!1, Xt(!1, t, "'", '"'), /\\([^\da-f])/gi, "$1");
}
var m7 = uS;
async function g7(t, e) {
  if (t.lang === "yaml") {
    let r = t.value.trim(), n = r ? await e(r, { parser: "yaml" }) : "";
    return H_([t.startDelimiter, xt, n, n ? xt : "", t.endDelimiter]);
  }
}
var y7 = g7;
function cS(t) {
  let { node: e } = t;
  if (e.type === "front-matter")
    return async (r) => {
      let n = await y7(e, r);
      return n ? [n, xt] : void 0;
    };
}
cS.getVisitorKeys = (t) => t.type === "css-root" ? ["frontMatter"] : [];
var O7 = cS, Go = null;
function wl(t) {
  if (Go !== null && typeof Go.property) {
    let e = Go;
    return Go = wl.prototype = null, e;
  }
  return Go = wl.prototype = t ?? /* @__PURE__ */ Object.create(null), new wl();
}
var x7 = 10;
for (let t = 0; t <= x7; t++)
  wl();
function b7(t) {
  return wl(t);
}
function D7(t, e = "type") {
  b7(t);
  function r(n) {
    let i = n[e], s = t[i];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: n });
    return s;
  }
  return r;
}
var v7 = D7, S7 = { "front-matter": [], "css-root": ["frontMatter", "nodes"], "css-comment": [], "css-rule": ["selector", "nodes"], "css-decl": ["value", "selector", "nodes"], "css-atrule": ["selector", "params", "value", "nodes"], "media-query-list": ["nodes"], "media-query": ["nodes"], "media-type": [], "media-feature-expression": ["nodes"], "media-feature": [], "media-colon": [], "media-value": [], "media-keyword": [], "media-url": [], "media-unknown": [], "selector-root": ["nodes"], "selector-selector": ["nodes"], "selector-comment": [], "selector-string": [], "selector-tag": [], "selector-id": [], "selector-class": [], "selector-attribute": [], "selector-combinator": ["nodes"], "selector-universal": [], "selector-pseudo": ["nodes"], "selector-nesting": [], "selector-unknown": [], "value-value": ["group"], "value-root": ["group"], "value-comment": [], "value-comma_group": ["groups"], "value-paren_group": ["open", "groups", "close"], "value-func": ["group"], "value-paren": [], "value-number": [], "value-operator": [], "value-word": [], "value-colon": [], "value-comma": [], "value-string": [], "value-atword": [], "value-unicode-range": [], "value-unknown": [] }, w7 = S7, C7 = v7(w7), E7 = C7;
function A7(t, e) {
  let r = 0;
  for (let n = 0; n < t.line - 1; ++n)
    r = e.indexOf(`
`, r) + 1;
  return r + t.column;
}
var hS = A7;
function Ty(t) {
  return (e, r, n) => {
    let i = !!(n != null && n.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, a = r;
    for (; a >= 0 && a < s; ) {
      let o = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(o))
          return a;
      } else if (!t.includes(o))
        return a;
      i ? a-- : a++;
    }
    return a === -1 || a === s ? a : !1;
  };
}
var pS = Ty(" 	"), T7 = Ty(",; 	"), dS = Ty(/[^\n\r]/);
function fS(t, e) {
  var r, n, i;
  if (typeof ((n = (r = t.source) == null ? void 0 : r.start) == null ? void 0 : n.offset) == "number")
    return t.source.start.offset;
  if (typeof t.sourceIndex == "number")
    return t.sourceIndex;
  if ((i = t.source) != null && i.start)
    return hS(t.source.start, e);
  throw Object.assign(new Error("Can not locate node."), { node: t });
}
function ky(t, e) {
  var r, n;
  if (t.type === "css-comment" && t.inline)
    return dS(e, t.source.startOffset);
  if (typeof ((n = (r = t.source) == null ? void 0 : r.end) == null ? void 0 : n.offset) == "number")
    return t.source.end.offset;
  if (t.source) {
    if (t.source.end)
      return hS(t.source.end, e);
    if (Rp(t.nodes))
      return ky(Zl(!1, t.nodes, -1), e);
  }
  return null;
}
function mS(t, e) {
  t.source && (t.source.startOffset = fS(t, e), t.source.endOffset = ky(t, e));
  for (let r in t) {
    let n = t[r];
    r === "source" || !n || typeof n != "object" || (n.type === "value-root" || n.type === "value-unknown" ? gS(n, k7(t), n.text || n.value) : mS(n, e));
  }
}
function gS(t, e, r) {
  t.source && (t.source.startOffset = fS(t, r) + e, t.source.endOffset = ky(t, r) + e);
  for (let n in t) {
    let i = t[n];
    n === "source" || !i || typeof i != "object" || gS(i, e, r);
  }
}
function k7(t) {
  var e;
  let r = t.source.startOffset;
  return typeof t.prop == "string" && (r += t.prop.length), t.type === "css-atrule" && typeof t.name == "string" && (r += 1 + t.name.length + t.raws.afterName.match(/^\s*:?\s*/)[0].length), t.type !== "css-atrule" && typeof ((e = t.raws) == null ? void 0 : e.between) == "string" && (r += t.raws.between.length), r;
}
function P7(t) {
  let e = "initial", r = "initial", n, i = !1, s = [];
  for (let a = 0; a < t.length; a++) {
    let o = t[a];
    switch (e) {
      case "initial":
        if (o === "'") {
          e = "single-quotes";
          continue;
        }
        if (o === '"') {
          e = "double-quotes";
          continue;
        }
        if ((o === "u" || o === "U") && t.slice(a, a + 4).toLowerCase() === "url(") {
          e = "url", a += 3;
          continue;
        }
        if (o === "*" && t[a - 1] === "/") {
          e = "comment-block";
          continue;
        }
        if (o === "/" && t[a - 1] === "/") {
          e = "comment-inline", n = a - 1;
          continue;
        }
        continue;
      case "single-quotes":
        if (o === "'" && t[a - 1] !== "\\" && (e = r, r = "initial"), o === `
` || o === "\r")
          return t;
        continue;
      case "double-quotes":
        if (o === '"' && t[a - 1] !== "\\" && (e = r, r = "initial"), o === `
` || o === "\r")
          return t;
        continue;
      case "url":
        if (o === ")" && (e = "initial"), o === `
` || o === "\r")
          return t;
        if (o === "'") {
          e = "single-quotes", r = "url";
          continue;
        }
        if (o === '"') {
          e = "double-quotes", r = "url";
          continue;
        }
        continue;
      case "comment-block":
        o === "/" && t[a - 1] === "*" && (e = "initial");
        continue;
      case "comment-inline":
        (o === '"' || o === "'" || o === "*") && (i = !0), (o === `
` || o === "\r") && (i && s.push([n, a]), e = "initial", i = !1);
        continue;
    }
  }
  for (let [a, o] of s)
    t = t.slice(0, a) + Xt(!1, t.slice(a, o), /["'*]/g, " ") + t.slice(o);
  return t;
}
function Vr(t) {
  var e;
  return (e = t.source) == null ? void 0 : e.startOffset;
}
function qr(t) {
  var e;
  return (e = t.source) == null ? void 0 : e.endOffset;
}
var vh = da(W5(), 1);
function F7(t) {
  if (!t.startsWith("#!"))
    return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var $7 = F7;
function yS(t) {
  let e = $7(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, vh.extract)(t), { pragmas: n, comments: i } = (0, vh.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: n, comments: i };
}
function B7(t) {
  let { pragmas: e } = yS(t);
  return Object.prototype.hasOwnProperty.call(e, "prettier") || Object.prototype.hasOwnProperty.call(e, "format");
}
function I7(t) {
  let { shebang: e, text: r, pragmas: n, comments: i } = yS(t), s = (0, vh.strip)(r), a = (0, vh.print)({ pragmas: { format: "", ...n }, comments: i.trimStart() });
  return (e ? `${e}
` : "") + a + (s.startsWith(`
`) ? `
` : `

`) + s;
}
var N7 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
function _7(t) {
  let e = t.match(N7);
  if (!e)
    return { content: t };
  let { startDelimiter: r, language: n, value: i = "", endDelimiter: s } = e.groups, a = n.trim() || "yaml";
  if (r === "+++" && (a = "toml"), a !== "yaml" && r !== s)
    return { content: t };
  let [o] = e;
  return { frontMatter: { type: "front-matter", lang: a, value: i, startDelimiter: r, endDelimiter: s, raw: o.replace(/\n$/, "") }, content: Xt(!1, o, /[^\n]/g, " ") + t.slice(o.length) };
}
var Py = _7;
function Q7(t) {
  return B7(Py(t).content);
}
function M7(t) {
  let { frontMatter: e, content: r } = Py(t);
  return (e ? e.raw + `

` : "") + I7(r);
}
var L7 = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
function R7(t) {
  var e, r;
  return (r = (e = t.findAncestor((n) => n.type === "css-decl")) == null ? void 0 : e.prop) == null ? void 0 : r.toLowerCase();
}
var j7 = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
function Z7(t) {
  return j7.has(t.toLowerCase());
}
function W7(t, e) {
  var r;
  let n = t.findAncestor((i) => i.type === "css-atrule");
  return ((r = n == null ? void 0 : n.name) == null ? void 0 : r.toLowerCase().endsWith("keyframes")) && ["from", "to"].includes(e.toLowerCase());
}
function Na(t) {
  return t.includes("$") || t.includes("@") || t.includes("#") || t.startsWith("%") || t.startsWith("--") || t.startsWith(":--") || t.includes("(") && t.includes(")") ? t : t.toLowerCase();
}
function zc(t, e) {
  var r;
  let n = t.findAncestor((i) => i.type === "value-func");
  return ((r = n == null ? void 0 : n.value) == null ? void 0 : r.toLowerCase()) === e;
}
function q7(t) {
  var e;
  let r = t.findAncestor((i) => i.type === "css-rule"), n = (e = r == null ? void 0 : r.raws) == null ? void 0 : e.selector;
  return n && (n.startsWith(":import") || n.startsWith(":export"));
}
function Gc(t, e) {
  let r = Array.isArray(e) ? e : [e], n = t.findAncestor((i) => i.type === "css-atrule");
  return n && r.includes(n.name.toLowerCase());
}
function X7(t) {
  var e;
  let { node: r } = t;
  return r.groups[0].value === "url" && r.groups.length === 2 && ((e = t.findAncestor((n) => n.type === "css-atrule")) == null ? void 0 : e.name) === "import";
}
function V7(t) {
  return t.type === "value-func" && t.value.toLowerCase() === "url";
}
function Y7(t) {
  return t.type === "value-func" && t.value.toLowerCase() === "var";
}
function Qd(t, e) {
  var r;
  let n = (r = t.parent) == null ? void 0 : r.nodes;
  return n && n.indexOf(e) === n.length - 1;
}
function U7(t) {
  let { selector: e } = t;
  return e ? typeof e == "string" && /^@.+:.*$/.test(e) || e.value && /^@.+:.*$/.test(e.value) : !1;
}
function z7(t) {
  return t.type === "value-word" && ["from", "through", "end"].includes(t.value);
}
function G7(t) {
  return t.type === "value-word" && ["and", "or", "not"].includes(t.value);
}
function H7(t) {
  return t.type === "value-word" && t.value === "in";
}
function rm(t) {
  return t.type === "value-operator" && t.value === "*";
}
function Hc(t) {
  return t.type === "value-operator" && t.value === "/";
}
function Gi(t) {
  return t.type === "value-operator" && t.value === "+";
}
function _a(t) {
  return t.type === "value-operator" && t.value === "-";
}
function J7(t) {
  return t.type === "value-operator" && t.value === "%";
}
function Md(t) {
  return rm(t) || Hc(t) || Gi(t) || _a(t) || J7(t);
}
function K7(t) {
  return t.type === "value-word" && ["==", "!="].includes(t.value);
}
function eQ(t) {
  return t.type === "value-word" && ["<", ">", "<=", ">="].includes(t.value);
}
function nm(t, e) {
  return e.parser === "scss" && t.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(t.name);
}
function E1(t) {
  var e;
  return ((e = t.raws) == null ? void 0 : e.params) && /^\(\s*\)$/.test(t.raws.params);
}
function Ld(t) {
  return t.name.startsWith("prettier-placeholder");
}
function tQ(t) {
  return t.prop.startsWith("@prettier-placeholder");
}
function rQ(t, e) {
  return t.value === "$$" && t.type === "value-func" && (e == null ? void 0 : e.type) === "value-word" && !e.raws.before;
}
function nQ(t) {
  var e, r;
  return ((e = t.value) == null ? void 0 : e.type) === "value-root" && ((r = t.value.group) == null ? void 0 : r.type) === "value-value" && t.prop.toLowerCase() === "composes";
}
function iQ(t) {
  var e, r, n;
  return ((n = (r = (e = t.value) == null ? void 0 : e.group) == null ? void 0 : r.group) == null ? void 0 : n.type) === "value-paren_group" && t.value.group.group.open !== null && t.value.group.group.close !== null;
}
function Pa(t) {
  var e;
  return ((e = t.raws) == null ? void 0 : e.before) === "";
}
function Fy(t) {
  var e, r;
  return t.type === "value-comma_group" && ((r = (e = t.groups) == null ? void 0 : e[1]) == null ? void 0 : r.type) === "value-colon";
}
function Rd(t) {
  var e;
  return t.type === "value-paren_group" && ((e = t.groups) == null ? void 0 : e[0]) && Fy(t.groups[0]);
}
function OS(t, e) {
  var r;
  if (e.parser !== "scss")
    return !1;
  let { node: n } = t;
  if (n.groups.length === 0)
    return !1;
  let i = t.grandparent;
  if (!Rd(n) && !(i && Rd(i)))
    return !1;
  let s = t.findAncestor((a) => a.type === "css-decl");
  return !!((r = s == null ? void 0 : s.prop) != null && r.startsWith("$") || Rd(i) || i.type === "value-func");
}
function A1(t) {
  return t.type === "value-comment" && t.inline;
}
function jd(t) {
  return t.type === "value-word" && t.value === "#";
}
function T1(t) {
  return t.type === "value-word" && t.value === "{";
}
function Zd(t) {
  return t.type === "value-word" && t.value === "}";
}
function hc(t) {
  return ["value-word", "value-atword"].includes(t.type);
}
function im(t) {
  return (t == null ? void 0 : t.type) === "value-colon";
}
function sQ(t, e) {
  if (!Fy(e))
    return !1;
  let { groups: r } = e, n = r.indexOf(t);
  return n === -1 ? !1 : im(r[n + 1]);
}
function aQ(t) {
  return t.value && ["not", "and", "or"].includes(t.value.toLowerCase());
}
function oQ(t) {
  return t.type !== "value-func" ? !1 : L7.has(t.value.toLowerCase());
}
function Ho(t) {
  return /\/\//.test(t.split(/[\n\r]/).pop());
}
function pc(t) {
  return (t == null ? void 0 : t.type) === "value-atword" && t.value.startsWith("prettier-placeholder-");
}
function lQ(t, e) {
  var r, n;
  if (((r = t.open) == null ? void 0 : r.value) !== "(" || ((n = t.close) == null ? void 0 : n.value) !== ")" || t.groups.some((i) => i.type !== "value-comma_group"))
    return !1;
  if (e.type === "value-comma_group") {
    let i = e.groups.indexOf(t) - 1, s = e.groups[i];
    if ((s == null ? void 0 : s.type) === "value-word" && s.value === "with")
      return !0;
  }
  return !1;
}
function dc(t) {
  var e, r;
  return t.type === "value-paren_group" && ((e = t.open) == null ? void 0 : e.value) === "(" && ((r = t.close) == null ? void 0 : r.value) === ")";
}
function uQ(t, e, r) {
  var n;
  let { node: i } = t, s = t.parent, a = t.grandparent, o = R7(t), u = o && s.type === "value-value" && (o === "grid" || o.startsWith("grid-template")), c = t.findAncestor((S) => S.type === "css-atrule"), h = c && nm(c, e), p = i.groups.some((S) => A1(S)), m = t.map(r, "groups"), g = [], O = zc(t, "url"), b = !1, D = !1;
  for (let S = 0; S < i.groups.length; ++S) {
    g.push(m[S]);
    let x = i.groups[S - 1], w = i.groups[S], T = i.groups[S + 1], C = i.groups[S + 2];
    if (O) {
      (T && Gi(T) || Gi(w)) && g.push(" ");
      continue;
    }
    if (Gc(t, "forward") && w.type === "value-word" && w.value && x !== void 0 && x.type === "value-word" && x.value === "as" && T.type === "value-operator" && T.value === "*" || !T || w.type === "value-word" && w.value.endsWith("-") && pc(T))
      continue;
    if (w.type === "value-string" && w.quoted) {
      let M = w.value.lastIndexOf("#{"), Y = w.value.lastIndexOf("}");
      M !== -1 && Y !== -1 ? b = M > Y : M !== -1 ? b = !0 : Y !== -1 && (b = !1);
    }
    if (b || im(w) || im(T) || w.type === "value-atword" && (w.value === "" || w.value.endsWith("[")) || T.type === "value-word" && T.value.startsWith("]") || w.value === "~" || w.type !== "value-string" && w.value && w.value.includes("\\") && T && T.type !== "value-comment" || x != null && x.value && x.value.indexOf("\\") === x.value.length - 1 && w.type === "value-operator" && w.value === "/" || w.value === "\\" || rQ(w, T) || jd(w) || T1(w) || Zd(T) || T1(T) && Pa(T) || Zd(w) && Pa(T) || w.value === "--" && jd(T))
      continue;
    let A = Md(w), P = Md(T);
    if ((A && jd(T) || P && Zd(w)) && Pa(T) || !x && Hc(w) || zc(t, "calc") && (Gi(w) || Gi(T) || _a(w) || _a(T)) && Pa(T))
      continue;
    let $ = (Gi(w) || _a(w)) && S === 0 && (T.type === "value-number" || T.isHex) && a && oQ(a) && !Pa(T), B = (C == null ? void 0 : C.type) === "value-func" || C && hc(C) || w.type === "value-func" || hc(w), _ = T.type === "value-func" || hc(T) || (x == null ? void 0 : x.type) === "value-func" || x && hc(x);
    if (e.parser === "scss" && A && w.value === "-" && T.type === "value-func" && qr(w) !== Vr(T)) {
      g.push(" ");
      continue;
    }
    if (!(!(rm(T) || rm(w)) && !zc(t, "calc") && !$ && (Hc(T) && !B || Hc(w) && !_ || Gi(T) && !B || Gi(w) && !_ || _a(T) || _a(w)) && (Pa(T) || A && (!x || x && Md(x)))) && !((e.parser === "scss" || e.parser === "less") && A && w.value === "-" && dc(T) && qr(w) === Vr(T.open) && T.open.value === "(")) {
      if (A1(w)) {
        if (s.type === "value-paren_group") {
          g.push(bh(xt));
          continue;
        }
        g.push(xt);
        continue;
      }
      if (h && (K7(T) || eQ(T) || G7(T) || H7(w) || z7(w))) {
        g.push(" ");
        continue;
      }
      if (c && c.name.toLowerCase() === "namespace") {
        g.push(" ");
        continue;
      }
      if (u) {
        w.source && T.source && w.source.start.line !== T.source.start.line ? (g.push(xt), D = !0) : g.push(" ");
        continue;
      }
      if (P) {
        g.push(" ");
        continue;
      }
      if ((T == null ? void 0 : T.value) !== "..." && !(pc(w) && pc(T) && qr(w) === Vr(T))) {
        if (pc(w) && dc(T) && qr(w) === Vr(T.open)) {
          g.push(An);
          continue;
        }
        if (w.value === "with" && dc(T)) {
          g.push(" ");
          continue;
        }
        (n = w.value) != null && n.endsWith("#") && T.value === "{" && dc(T.group) || g.push(dr);
      }
    }
  }
  return p && g.push(Ay), D && g.unshift(xt), h ? on(jr(g)) : X7(t) ? on(tm(g)) : on(jr(tm(g)));
}
var cQ = uQ;
function hQ(t) {
  return t.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
}
var pQ = hQ, k1 = /* @__PURE__ */ new Map([["em", "em"], ["rem", "rem"], ["ex", "ex"], ["rex", "rex"], ["cap", "cap"], ["rcap", "rcap"], ["ch", "ch"], ["rch", "rch"], ["ic", "ic"], ["ric", "ric"], ["lh", "lh"], ["rlh", "rlh"], ["vw", "vw"], ["svw", "svw"], ["lvw", "lvw"], ["dvw", "dvw"], ["vh", "vh"], ["svh", "svh"], ["lvh", "lvh"], ["dvh", "dvh"], ["vi", "vi"], ["svi", "svi"], ["lvi", "lvi"], ["dvi", "dvi"], ["vb", "vb"], ["svb", "svb"], ["lvb", "lvb"], ["dvb", "dvb"], ["vmin", "vmin"], ["svmin", "svmin"], ["lvmin", "lvmin"], ["dvmin", "dvmin"], ["vmax", "vmax"], ["svmax", "svmax"], ["lvmax", "lvmax"], ["dvmax", "dvmax"], ["cm", "cm"], ["mm", "mm"], ["q", "Q"], ["in", "in"], ["pt", "pt"], ["pc", "pc"], ["px", "px"], ["deg", "deg"], ["grad", "grad"], ["rad", "rad"], ["turn", "turn"], ["s", "s"], ["ms", "ms"], ["hz", "Hz"], ["khz", "kHz"], ["dpi", "dpi"], ["dpcm", "dpcm"], ["dppx", "dppx"], ["x", "x"], ["cqw", "cqw"], ["cqh", "cqh"], ["cqi", "cqi"], ["cqb", "cqb"], ["cqmin", "cqmin"], ["cqmax", "cqmax"]]);
function dQ(t) {
  let e = t.toLowerCase();
  return k1.has(e) ? k1.get(e) : t;
}
var xS = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, fQ = /(?:\d*\.\d+|\d+\.?)(?:e[+-]?\d+)?/gi, mQ = /[a-z]+/gi, gQ = /[$@]?[_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/gi, yQ = new RegExp(xS.source + `|(${gQ.source})?(${fQ.source})(${mQ.source})?`, "gi");
function jn(t, e) {
  return Xt(!1, t, xS, (r) => lS(r, e));
}
function OQ(t, e) {
  let r = e.singleQuote ? "'" : '"';
  return t.includes('"') || t.includes("'") ? t : r + t + r;
}
function Fa(t) {
  return Xt(!1, t, yQ, (e, r, n, i, s) => !n && i ? bS(i) + Na(s || "") : e);
}
function bS(t) {
  return pQ(t).replace(/\.0(?=$|e)/, "");
}
function xQ(t) {
  return t.trailingComma === "es5" || t.trailingComma === "all";
}
function bQ(t, e, r) {
  let n = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let i = t.charAt(e);
  if (n) {
    if (t.charAt(e - 1) === "\r" && i === `
`)
      return e - 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e - 1;
  } else {
    if (i === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e + 1;
  }
  return e;
}
var DS = bQ;
function DQ(t, e, r = {}) {
  let n = pS(t, r.backwards ? e - 1 : e, r), i = DS(t, n, r);
  return n !== i;
}
var vS = DQ;
function vQ(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var SQ = vQ;
function wQ(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? dS(t, e) : e;
}
var CQ = wQ;
function EQ(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = T7(t, n), n = SQ(t, n), n = pS(t, n);
  return n = CQ(t, n), n = DS(t, n), n !== !1 && vS(t, n);
}
var SS = EQ;
function AQ({ node: t, parent: e }, r) {
  return !!(t.source && r.originalText.slice(Vr(t), Vr(e.close)).trimEnd().endsWith(","));
}
function TQ(t, e) {
  return Y7(t.grandparent) && AQ(t, e) ? "," : t.node.type !== "value-comment" && !(t.node.type === "value-comma_group" && t.node.groups.every((r) => r.type === "value-comment")) && xQ(e) && t.callParent(() => OS(t, e)) ? oS(",") : "";
}
function kQ(t, e, r) {
  let { node: n, parent: i } = t, s = t.map(({ node: g }) => typeof g == "string" ? g : r(), "groups");
  if (i && V7(i) && (n.groups.length === 1 || n.groups.length > 0 && n.groups[0].type === "value-comma_group" && n.groups[0].groups.length > 0 && n.groups[0].groups[0].type === "value-word" && n.groups[0].groups[0].value.startsWith("data:")))
    return [n.open ? r("open") : "", Zs(",", s), n.close ? r("close") : ""];
  if (!n.open) {
    let g = wS(t), O = Zs([",", g ? xt : dr], s);
    return jr(g ? [xt, O] : on(tm(O)));
  }
  let a = t.map(({ node: g, isLast: O, index: b }) => {
    var D;
    let S = s[b];
    if (Fy(g) && g.type === "value-comma_group" && g.groups && g.groups[0].type !== "value-paren_group" && ((D = g.groups[2]) == null ? void 0 : D.type) === "value-paren_group") {
      let w = e7(S.contents.contents);
      w[1] = on(w[1]), S = on(bh(S));
    }
    let x = [S, O ? TQ(t, e) : ","];
    if (!O && g.type === "value-comma_group" && Rp(g.groups)) {
      let w = Zl(!1, g.groups, -1);
      !w.source && w.close && (w = w.close), w.source && SS(e.originalText, qr(w)) && x.push(xt);
    }
    return x;
  }, "groups"), o = sQ(n, i), u = lQ(n, i), c = OS(t, e), h = u || c && !o, p = u || o, m = on([n.open ? r("open") : "", jr([An, Zs(dr, a)]), An, n.close ? r("close") : ""], { shouldBreak: h });
  return p ? bh(m) : m;
}
function wS(t) {
  return t.match((e) => e.type === "value-paren_group" && !e.open && e.groups.some((r) => r.type === "value-comma_group"), (e, r) => r === "group" && e.type === "value-value", (e, r) => r === "group" && e.type === "value-root", (e, r) => r === "value" && (e.type === "css-decl" && !e.prop.startsWith("--") || e.type === "css-atrule" && e.variable));
}
function PQ(t, e, r) {
  let n = [];
  return t.each(() => {
    let { node: i, previous: s } = t;
    if ((s == null ? void 0 : s.type) === "css-comment" && s.text.trim() === "prettier-ignore" ? n.push(e.originalText.slice(Vr(i), qr(i))) : n.push(r()), t.isLast)
      return;
    let { next: a } = t;
    a.type === "css-comment" && !vS(e.originalText, Vr(a), { backwards: !0 }) && !Dh(i) || a.type === "css-atrule" && a.name === "else" && i.type !== "css-comment" ? n.push(" ") : (n.push(e.__isHTMLStyleAttribute ? dr : xt), SS(e.originalText, qr(i)) && !Dh(i) && n.push(xt));
  }, "nodes"), n;
}
var Jo = PQ;
function FQ(t, e, r) {
  var n, i, s, a, o, u;
  let { node: c } = t;
  switch (c.type) {
    case "front-matter":
      return [c.raw, xt];
    case "css-root": {
      let h = Jo(t, e, r), p = c.raws.after.trim();
      return p.startsWith(";") && (p = p.slice(1).trim()), [c.frontMatter ? [r("frontMatter"), xt] : "", h, p ? ` ${p}` : "", c.nodes.length > 0 ? xt : ""];
    }
    case "css-comment": {
      let h = c.inline || c.raws.inline, p = e.originalText.slice(Vr(c), qr(c));
      return h ? p.trimEnd() : p;
    }
    case "css-rule":
      return [r("selector"), c.important ? " !important" : "", c.nodes ? [((n = c.selector) == null ? void 0 : n.type) === "selector-unknown" && Ho(c.selector.value) ? dr : c.selector ? " " : "", "{", c.nodes.length > 0 ? jr([xt, Jo(t, e, r)]) : "", xt, "}", U7(c) ? ";" : ""] : ";"];
    case "css-decl": {
      let h = t.parent, { between: p } = c.raws, m = p.trim(), g = m === ":", O = typeof c.value == "string" && /^ *$/.test(c.value), b = typeof c.value == "string" ? c.value : r("value");
      return b = nQ(c) ? n7(b) : b, !g && Ho(m) && !((s = (i = c.value) == null ? void 0 : i.group) != null && s.group && t.call(() => wS(t), "value", "group", "group")) && (b = jr([xt, bh(b)])), [Xt(!1, c.raws.before, /[\s;]/g, ""), h.type === "css-atrule" && h.variable || q7(t) ? c.prop : Na(c.prop), m.startsWith("//") ? " " : "", m, c.extend || O ? "" : " ", e.parser === "less" && c.extend && c.selector ? ["extend(", r("selector"), ")"] : "", b, c.raws.important ? c.raws.important.replace(/\s*!\s*important/i, " !important") : c.important ? " !important" : "", c.raws.scssDefault ? c.raws.scssDefault.replace(/\s*!default/i, " !default") : c.scssDefault ? " !default" : "", c.raws.scssGlobal ? c.raws.scssGlobal.replace(/\s*!global/i, " !global") : c.scssGlobal ? " !global" : "", c.nodes ? [" {", jr([An, Jo(t, e, r)]), An, "}"] : tQ(c) && !h.raws.semicolon && e.originalText[qr(c) - 1] !== ";" ? "" : e.__isHTMLStyleAttribute && Qd(t, c) ? oS(";") : ";"];
    }
    case "css-atrule": {
      let h = t.parent, p = Ld(c) && !h.raws.semicolon && e.originalText[qr(c) - 1] !== ";";
      if (e.parser === "less") {
        if (c.mixin)
          return [r("selector"), c.important ? " !important" : "", p ? "" : ";"];
        if (c.function)
          return [c.name, typeof c.params == "string" ? c.params : r("params"), p ? "" : ";"];
        if (c.variable)
          return ["@", c.name, ": ", c.value ? r("value") : "", c.raws.between.trim() ? c.raws.between.trim() + " " : "", c.nodes ? ["{", jr([c.nodes.length > 0 ? An : "", Jo(t, e, r)]), An, "}"] : "", p ? "" : ";"];
      }
      let m = c.name === "import" && ((a = c.params) == null ? void 0 : a.type) === "value-unknown" && c.params.value.endsWith(";");
      return ["@", E1(c) || c.name.endsWith(":") || Ld(c) ? c.name : Na(c.name), c.params ? [E1(c) ? "" : Ld(c) ? c.raws.afterName === "" ? "" : c.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(c.raws.afterName) ? [xt, xt] : /^\s*\n/.test(c.raws.afterName) ? xt : " " : " ", typeof c.params == "string" ? c.params : r("params")] : "", c.selector ? jr([" ", r("selector")]) : "", c.value ? on([" ", r("value"), nm(c, e) ? iQ(c) ? " " : dr : ""]) : c.name === "else" ? " " : "", c.nodes ? [nm(c, e) ? "" : c.selector && !c.selector.nodes && typeof c.selector.value == "string" && Ho(c.selector.value) || !c.selector && typeof c.params == "string" && Ho(c.params) ? dr : " ", "{", jr([c.nodes.length > 0 ? An : "", Jo(t, e, r)]), An, "}"] : p || m ? "" : ";"];
    }
    case "media-query-list": {
      let h = [];
      return t.each(({ node: p }) => {
        p.type === "media-query" && p.value === "" || h.push(r());
      }, "nodes"), on(jr(Zs(dr, h)));
    }
    case "media-query":
      return [Zs(" ", t.map(r, "nodes")), Qd(t, c) ? "" : ","];
    case "media-type":
      return Fa(jn(c.value, e));
    case "media-feature-expression":
      return c.nodes ? ["(", ...t.map(r, "nodes"), ")"] : c.value;
    case "media-feature":
      return Na(jn(Xt(!1, c.value, / +/g, " "), e));
    case "media-colon":
      return [c.value, " "];
    case "media-value":
      return Fa(jn(c.value, e));
    case "media-keyword":
      return jn(c.value, e);
    case "media-url":
      return jn(Xt(!1, Xt(!1, c.value, /^url\(\s+/gi, "url("), /\s+\)$/g, ")"), e);
    case "media-unknown":
      return c.value;
    case "selector-root":
      return on([Gc(t, "custom-selector") ? [t.findAncestor((h) => h.type === "css-atrule").customSelector, dr] : "", Zs([",", Gc(t, ["extend", "custom-selector", "nest"]) ? dr : xt], t.map(r, "nodes"))]);
    case "selector-selector":
      return on(jr(t.map(r, "nodes")));
    case "selector-comment":
      return c.value;
    case "selector-string":
      return jn(c.value, e);
    case "selector-tag":
      return [c.namespace ? [c.namespace === !0 ? "" : c.namespace.trim(), "|"] : "", ((o = t.previous) == null ? void 0 : o.type) === "selector-nesting" ? c.value : Fa(W7(t, c.value) ? c.value.toLowerCase() : c.value)];
    case "selector-id":
      return ["#", c.value];
    case "selector-class":
      return [".", Fa(jn(c.value, e))];
    case "selector-attribute":
      return ["[", c.namespace ? [c.namespace === !0 ? "" : c.namespace.trim(), "|"] : "", c.attribute.trim(), c.operator ?? "", c.value ? OQ(jn(c.value.trim(), e), e) : "", c.insensitive ? " i" : "", "]"];
    case "selector-combinator": {
      if (c.value === "+" || c.value === ">" || c.value === "~" || c.value === ">>>") {
        let m = t.parent;
        return [m.type === "selector-selector" && m.nodes[0] === c ? "" : dr, c.value, Qd(t, c) ? "" : " "];
      }
      let h = c.value.trim().startsWith("(") ? dr : "", p = Fa(jn(c.value.trim(), e)) || dr;
      return [h, p];
    }
    case "selector-universal":
      return [c.namespace ? [c.namespace === !0 ? "" : c.namespace.trim(), "|"] : "", c.value];
    case "selector-pseudo":
      return [Na(c.value), Rp(c.nodes) ? on(["(", jr([An, Zs([",", dr], t.map(r, "nodes"))]), An, ")"]) : ""];
    case "selector-nesting":
      return c.value;
    case "selector-unknown": {
      let h = t.findAncestor((g) => g.type === "css-rule");
      if (h != null && h.isSCSSNesterProperty)
        return Fa(jn(Na(c.value), e));
      let p = t.parent;
      if ((u = p.raws) != null && u.selector) {
        let g = Vr(p), O = g + p.raws.selector.length;
        return e.originalText.slice(g, O).trim();
      }
      let m = t.grandparent;
      if (p.type === "value-paren_group" && (m == null ? void 0 : m.type) === "value-func" && m.value === "selector") {
        let g = qr(p.open) + 1, O = Vr(p.close), b = e.originalText.slice(g, O).trim();
        return Ho(b) ? [Ay, b] : b;
      }
      return c.value;
    }
    case "value-value":
    case "value-root":
      return r("group");
    case "value-comment":
      return e.originalText.slice(Vr(c), qr(c));
    case "value-comma_group":
      return cQ(t, e, r);
    case "value-paren_group":
      return kQ(t, e, r);
    case "value-func":
      return [c.value, Gc(t, "supports") && aQ(c) ? " " : "", r("group")];
    case "value-paren":
      return c.value;
    case "value-number":
      return [bS(c.value), dQ(c.unit)];
    case "value-operator":
      return c.value;
    case "value-word":
      return c.isColor && c.isHex || Z7(c.value) ? c.value.toLowerCase() : c.value;
    case "value-colon": {
      let { previous: h } = t;
      return [c.value, typeof (h == null ? void 0 : h.value) == "string" && h.value.endsWith("\\") || zc(t, "url") ? "" : dr];
    }
    case "value-string":
      return lS(c.raws.quote + c.value + c.raws.quote, e);
    case "value-atword":
      return ["@", c.value];
    case "value-unicode-range":
      return c.value;
    case "value-unknown":
      return c.value;
    case "value-comma":
    default:
      throw new h7(c, "PostCSS");
  }
}
var $Q = { print: FQ, embed: O7, insertPragma: M7, massageAstNode: m7, getVisitorKeys: E7 }, BQ = $Q, IQ = [{ linguistLanguageId: 50, name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css", ".wxss"], parsers: ["css"], vscodeLanguageIds: ["css"] }, { linguistLanguageId: 262764437, name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", parsers: ["css"], vscodeLanguageIds: ["postcss"] }, { linguistLanguageId: 198, name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", parsers: ["less"], vscodeLanguageIds: ["less"] }, { linguistLanguageId: 329, name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], parsers: ["scss"], vscodeLanguageIds: ["scss"] }], NQ = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, _Q = { singleQuote: NQ.singleQuote }, QQ = _Q, CS = {};
B2(CS, { css: () => f9, less: () => m9, scss: () => g9 });
var MQ = da(Mp(), 1), LQ = da(e_(), 1), RQ = da(o_(), 1);
function jQ(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var ZQ = jQ, WQ = da(u_(), 1);
function Au(t, e, r) {
  if (t && typeof t == "object") {
    delete t.parent;
    for (let n in t)
      Au(t[n], e, r), n === "type" && typeof t[n] == "string" && !t[n].startsWith(e) && (!r || !r.test(t[n])) && (t[n] = e + t[n]);
  }
  return t;
}
function ES(t) {
  if (t && typeof t == "object") {
    delete t.parent;
    for (let e in t)
      ES(t[e]);
    !Array.isArray(t) && t.value && !t.type && (t.type = "unknown");
  }
  return t;
}
var qQ = WQ.default.default;
function XQ(t) {
  let e;
  try {
    e = qQ(t);
  } catch {
    return { type: "selector-unknown", value: t };
  }
  return Au(ES(e), "media-");
}
var VQ = XQ, YQ = da(C_(), 1);
function UQ(t) {
  if (/\/\/|\/\*/.test(t))
    return { type: "selector-unknown", value: t.trim() };
  let e;
  try {
    new YQ.default((r) => {
      e = r;
    }).process(t);
  } catch {
    return { type: "selector-unknown", value: t };
  }
  return Au(e, "selector-");
}
var Qs = UQ, zQ = da(Z_(), 1), GQ = (t) => {
  for (; t.parent; )
    t = t.parent;
  return t;
}, AS = GQ;
function HQ(t) {
  return AS(t).text.slice(t.group.open.sourceIndex + 1, t.group.close.sourceIndex).trim();
}
var JQ = HQ;
function KQ(t) {
  if (Rp(t)) {
    for (let e = t.length - 1; e > 0; e--)
      if (t[e].type === "word" && t[e].value === "{" && t[e - 1].type === "word" && t[e - 1].value.endsWith("#"))
        return !0;
  }
  return !1;
}
var e9 = KQ;
function t9(t) {
  return t.some((e) => e.type === "string" || e.type === "func" && !e.value.endsWith("\\"));
}
var r9 = t9;
function n9(t, e) {
  return !!(e.parser === "scss" && (t == null ? void 0 : t.type) === "word" && t.value.startsWith("$"));
}
var i9 = n9;
function s9(t, e) {
  var r;
  let { nodes: n } = t, i = { open: null, close: null, groups: [], type: "paren_group" }, s = [i], a = i, o = { groups: [], type: "comma_group" }, u = [o];
  for (let c = 0; c < n.length; ++c) {
    let h = n[c];
    if (e.parser === "scss" && h.type === "number" && h.unit === ".." && h.value.endsWith(".") && (h.value = h.value.slice(0, -1), h.unit = "..."), h.type === "func" && h.value === "selector" && (h.group.groups = [Qs(AS(t).text.slice(h.group.open.sourceIndex + 1, h.group.close.sourceIndex))]), h.type === "func" && h.value === "url") {
      let p = ((r = h.group) == null ? void 0 : r.groups) ?? [], m = [];
      for (let g = 0; g < p.length; g++) {
        let O = p[g];
        O.type === "comma_group" ? m = [...m, ...O.groups] : m.push(O);
      }
      (e9(m) || !r9(m) && !i9(m[0], e)) && (h.group.groups = [JQ(h)]);
    }
    if (h.type === "paren" && h.value === "(")
      i = { open: h, close: null, groups: [], type: "paren_group" }, s.push(i), o = { groups: [], type: "comma_group" }, u.push(o);
    else if (h.type === "paren" && h.value === ")") {
      if (o.groups.length > 0 && i.groups.push(o), i.close = h, u.length === 1)
        throw new Error("Unbalanced parenthesis");
      u.pop(), o = Zl(!1, u, -1), o.groups.push(i), s.pop(), i = Zl(!1, s, -1);
    } else
      h.type === "comma" ? (i.groups.push(o), o = { groups: [], type: "comma_group" }, u[u.length - 1] = o) : o.groups.push(h);
  }
  return o.groups.length > 0 && i.groups.push(o), a;
}
function sm(t) {
  return t.type === "paren_group" && !t.open && !t.close && t.groups.length === 1 || t.type === "comma_group" && t.groups.length === 1 ? sm(t.groups[0]) : t.type === "paren_group" || t.type === "comma_group" ? { ...t, groups: t.groups.map(sm) } : t;
}
function TS(t, e) {
  if (t && typeof t == "object")
    for (let r in t)
      r !== "parent" && (TS(t[r], e), r === "nodes" && (t.group = sm(s9(t, e)), delete t[r]));
  return t;
}
function a9(t, e) {
  if (e.parser === "less" && t.startsWith("~`"))
    return { type: "value-unknown", value: t };
  let r = null;
  try {
    r = new zQ.default(t, { loose: !0 }).parse();
  } catch {
    return { type: "value-unknown", value: t };
  }
  r.text = t;
  let n = TS(r, e);
  return Au(n, "value-", /^selector-/);
}
var Bs = a9, o9 = /* @__PURE__ */ new Set(["import", "use", "forward"]);
function l9(t) {
  return o9.has(t);
}
var u9 = l9;
function c9(t, e) {
  return e.parser !== "scss" || !t.selector ? !1 : t.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*\n/, "").trim().endsWith(":");
}
var h9 = c9, p9 = /(\s*)(!default).*$/, d9 = /(\s*)(!global).*$/;
function kS(t, e) {
  var r, n;
  if (t && typeof t == "object") {
    delete t.parent;
    for (let o in t)
      kS(t[o], e);
    if (!t.type)
      return t;
    if (t.raws ?? (t.raws = {}), t.type === "css-decl" && typeof t.prop == "string" && t.prop.startsWith("--") && typeof t.value == "string" && t.value.startsWith("{")) {
      let o;
      if (t.value.trimEnd().endsWith("}")) {
        let u = e.originalText.slice(0, t.source.start.offset), c = "a".repeat(t.prop.length) + e.originalText.slice(t.source.start.offset + t.prop.length, t.source.end.offset), h = Xt(!1, u, /[^\n]/g, " ") + c, p;
        e.parser === "scss" ? p = $S : e.parser === "less" ? p = FS : p = PS;
        let m;
        try {
          m = p(h, { ...e });
        } catch {
        }
        ((r = m == null ? void 0 : m.nodes) == null ? void 0 : r.length) === 1 && m.nodes[0].type === "css-rule" && (o = m.nodes[0].nodes);
      }
      return o ? t.value = { type: "css-rule", nodes: o } : t.value = { type: "value-unknown", value: t.raws.value.raw }, t;
    }
    let i = "";
    typeof t.selector == "string" && (i = t.raws.selector ? t.raws.selector.scss ?? t.raws.selector.raw : t.selector, t.raws.between && t.raws.between.trim().length > 0 && (i += t.raws.between), t.raws.selector = i);
    let s = "";
    typeof t.value == "string" && (s = t.raws.value ? t.raws.value.scss ?? t.raws.value.raw : t.value, s = s.trim(), t.raws.value = s);
    let a = "";
    if (typeof t.params == "string" && (a = t.raws.params ? t.raws.params.scss ?? t.raws.params.raw : t.params, t.raws.afterName && t.raws.afterName.trim().length > 0 && (a = t.raws.afterName + a), t.raws.between && t.raws.between.trim().length > 0 && (a = a + t.raws.between), a = a.trim(), t.raws.params = a), i.trim().length > 0)
      return i.startsWith("@") && i.endsWith(":") ? t : t.mixin ? (t.selector = Bs(i, e), t) : (h9(t, e) && (t.isSCSSNesterProperty = !0), t.selector = Qs(i), t);
    if (s.length > 0) {
      let o = s.match(p9);
      o && (s = s.slice(0, o.index), t.scssDefault = !0, o[0].trim() !== "!default" && (t.raws.scssDefault = o[0]));
      let u = s.match(d9);
      if (u && (s = s.slice(0, u.index), t.scssGlobal = !0, u[0].trim() !== "!global" && (t.raws.scssGlobal = u[0])), s.startsWith("progid:"))
        return { type: "value-unknown", value: s };
      t.value = Bs(s, e);
    }
    if (e.parser === "less" && t.type === "css-decl" && s.startsWith("extend(") && (t.extend || (t.extend = t.raws.between === ":"), t.extend && !t.selector && (delete t.value, t.selector = Qs(s.slice(7, -1)))), t.type === "css-atrule") {
      if (e.parser === "less") {
        if (t.mixin) {
          let o = t.raws.identifier + t.name + t.raws.afterName + t.raws.params;
          return t.selector = Qs(o), delete t.params, t;
        }
        if (t.function)
          return t;
      }
      if (e.parser === "css" && t.name === "custom-selector") {
        let o = t.params.match(/:--\S+\s+/)[0].trim();
        return t.customSelector = o, t.selector = Qs(t.params.slice(o.length).trim()), delete t.params, t;
      }
      if (e.parser === "less") {
        if (t.name.includes(":") && !t.params) {
          t.variable = !0;
          let o = t.name.split(":");
          t.name = o[0], t.value = Bs(o.slice(1).join(":"), e);
        }
        if (!["page", "nest", "keyframes"].includes(t.name) && ((n = t.params) == null ? void 0 : n[0]) === ":") {
          t.variable = !0;
          let o = t.params.slice(1);
          o && (t.value = Bs(o, e)), t.raws.afterName += ":";
        }
        if (t.variable)
          return delete t.params, t.value || delete t.value, t;
      }
    }
    if (t.type === "css-atrule" && a.length > 0) {
      let { name: o } = t, u = t.name.toLowerCase();
      return o === "warn" || o === "error" ? (t.params = { type: "media-unknown", value: a }, t) : o === "extend" || o === "nest" ? (t.selector = Qs(a), delete t.params, t) : o === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(a) ? t.params = Bs(a, e) : (t.selector = Qs(a), delete t.params), t) : u9(u) ? (t.import = !0, delete t.filename, t.params = Bs(a, e), t) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(o) ? (a = a.replace(/(\$\S+?)(\s+)?\.{3}/, "$1...$2"), a = a.replace(/^(?!if)(\S+)(\s+)\(/, "$1($2"), t.value = Bs(a, e), delete t.params, t) : ["media", "custom-media"].includes(u) ? a.includes("#{") ? { type: "media-unknown", value: a } : (t.params = VQ(a), t) : (t.params = a, t);
    }
  }
  return t;
}
function $y(t, e, r) {
  let n = Py(e), { frontMatter: i } = n;
  e = n.content;
  let s;
  try {
    s = t(e, { map: !1 });
  } catch (a) {
    let { name: o, reason: u, line: c, column: h } = a;
    throw typeof c != "number" ? a : ZQ(`${o}: ${u}`, { loc: { start: { line: c, column: h } }, cause: a });
  }
  return r.originalText = e, s = kS(Au(s, "css-"), r), mS(s, e), i && (i.source = { startOffset: 0, endOffset: i.raw.length }, s.frontMatter = i), s;
}
function PS(t, e = {}) {
  return $y(MQ.default.default, t, e);
}
function FS(t, e = {}) {
  return $y((r) => LQ.default.parse(P7(r)), t, e);
}
function $S(t, e = {}) {
  return $y(RQ.default, t, e);
}
var By = { astFormat: "postcss", hasPragma: Q7, locStart: Vr, locEnd: qr }, f9 = { ...By, parse: PS }, m9 = { ...By, parse: FS }, g9 = { ...By, parse: $S }, y9 = { postcss: BQ }, O9 = z2, x9 = Object.create, Iy = Object.defineProperty, b9 = Object.getOwnPropertyDescriptor, D9 = Object.getOwnPropertyNames, v9 = Object.getPrototypeOf, S9 = Object.prototype.hasOwnProperty, w9 = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), jp = (t, e) => {
  for (var r in e)
    Iy(t, r, { get: e[r], enumerable: !0 });
}, C9 = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of D9(e))
      !S9.call(t, i) && i !== r && Iy(t, i, { get: () => e[i], enumerable: !(n = b9(e, i)) || n.enumerable });
  return t;
}, E9 = (t, e, r) => (r = t != null ? x9(v9(t)) : {}, C9(e || !t || !t.__esModule ? Iy(r, "default", { value: t, enumerable: !0 }) : r, t)), BS = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, Yi = (t, e, r) => (BS(t, e, "read from private field"), r ? r.call(t) : e.get(t)), A9 = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, T9 = (t, e, r, n) => (BS(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r), k9 = w9((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = h, t.parse = m, t.parseWithComments = g, t.print = O, t.strip = p;
  var e = /\*\/$/, r = /^\/\*\*?/, n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, s = /^(\r?\n)+/, a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, o = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, u = /(\r?\n|^) *\* ?/g, c = [];
  function h(D) {
    let S = D.match(n);
    return S ? S[0].trimLeft() : "";
  }
  function p(D) {
    let S = D.match(n);
    return S && S[0] ? D.substring(S[0].length) : D;
  }
  function m(D) {
    return g(D).pragmas;
  }
  function g(D) {
    let S = `
`;
    D = D.replace(r, "").replace(e, "").replace(u, "$1");
    let x = "";
    for (; x !== D; )
      x = D, D = D.replace(a, `${S}$1 $2${S}`);
    D = D.replace(s, "").trimRight();
    let w = /* @__PURE__ */ Object.create(null), T = D.replace(o, "").replace(s, "").trimRight(), C;
    for (; C = o.exec(D); ) {
      let A = C[2].replace(i, "");
      typeof w[C[1]] == "string" || Array.isArray(w[C[1]]) ? w[C[1]] = c.concat(w[C[1]], A) : w[C[1]] = A;
    }
    return { comments: T, pragmas: w };
  }
  function O({ comments: D = "", pragmas: S = {} }) {
    let x = `
`, w = "/**", T = " *", C = " */", A = Object.keys(S), P = A.flatMap((B) => b(B, S[B])).map((B) => `${T} ${B}${x}`).join("");
    if (!D) {
      if (A.length === 0)
        return "";
      if (A.length === 1 && !Array.isArray(S[A[0]])) {
        let B = S[A[0]];
        return `${w} ${b(A[0], B)[0]}${C}`;
      }
    }
    let $ = D.split(x).map((B) => `${T} ${B}`).join(x) + x;
    return w + x + (D ? $ : "") + (D && A.length ? T + x : "") + P + C;
  }
  function b(D, S) {
    return c.concat(S).map((x) => `@${D} ${x}`.trim());
  }
}), IS = {};
jp(IS, { languages: () => pj, options: () => cj, printers: () => hj });
var P9 = [{ linguistLanguageId: 183, name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib", ".wxs"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell", "zx"], parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"] }, { linguistLanguageId: 183, name: "Flow", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: [], extensions: [".js.flow"], filenames: [], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"] }, { linguistLanguageId: 183, name: "JSX", type: "programming", tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0, aliases: void 0, extensions: [".jsx"], filenames: void 0, interpreters: void 0, parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], group: "JavaScript" }, { linguistLanguageId: 378, name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] }, { linguistLanguageId: 94901924, name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] }], NS = {};
jp(NS, { canAttachComment: () => Q6, embed: () => wM, experimentalFeatures: () => tj, getCommentChildNodes: () => M6, getVisitorKeys: () => MS, handleComments: () => uw, insertPragma: () => TM, isBlockComment: () => xn, isGap: () => L6, massageAstNode: () => Q4, print: () => ej, printComment: () => r6, willPrintOwnComments: () => xw });
var F9 = (t, e, r, n) => {
  if (!(t && e == null))
    return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
}, Yr = F9, $9 = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, ze = $9, B9 = /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/, I9 = (t) => B9.test(t), N9 = I9;
function _9(t) {
  return t !== null && typeof t == "object";
}
var Q9 = _9;
function* M9(t, e) {
  let { getVisitorKeys: r, filter: n = () => !0 } = e, i = (s) => Q9(s) && n(s);
  for (let s of r(t)) {
    let a = t[s];
    if (Array.isArray(a))
      for (let o of a)
        i(o) && (yield o);
    else
      i(a) && (yield a);
  }
}
function* L9(t, e) {
  let r = [t];
  for (let n = 0; n < r.length; n++) {
    let i = r[n];
    for (let s of M9(i, e))
      yield s, r.push(s);
  }
}
function R9(t, { getVisitorKeys: e, predicate: r }) {
  for (let n of L9(t, { getVisitorKeys: e }))
    if (r(n))
      return !0;
  return !1;
}
var j9 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function Z9(t) {
  return t === 12288 || t >= 65281 && t <= 65376 || t >= 65504 && t <= 65510;
}
function W9(t) {
  return t >= 4352 && t <= 4447 || t === 8986 || t === 8987 || t === 9001 || t === 9002 || t >= 9193 && t <= 9196 || t === 9200 || t === 9203 || t === 9725 || t === 9726 || t === 9748 || t === 9749 || t >= 9800 && t <= 9811 || t === 9855 || t === 9875 || t === 9889 || t === 9898 || t === 9899 || t === 9917 || t === 9918 || t === 9924 || t === 9925 || t === 9934 || t === 9940 || t === 9962 || t === 9970 || t === 9971 || t === 9973 || t === 9978 || t === 9981 || t === 9989 || t === 9994 || t === 9995 || t === 10024 || t === 10060 || t === 10062 || t >= 10067 && t <= 10069 || t === 10071 || t >= 10133 && t <= 10135 || t === 10160 || t === 10175 || t === 11035 || t === 11036 || t === 11088 || t === 11093 || t >= 11904 && t <= 11929 || t >= 11931 && t <= 12019 || t >= 12032 && t <= 12245 || t >= 12272 && t <= 12287 || t >= 12289 && t <= 12350 || t >= 12353 && t <= 12438 || t >= 12441 && t <= 12543 || t >= 12549 && t <= 12591 || t >= 12593 && t <= 12686 || t >= 12688 && t <= 12771 || t >= 12783 && t <= 12830 || t >= 12832 && t <= 12871 || t >= 12880 && t <= 19903 || t >= 19968 && t <= 42124 || t >= 42128 && t <= 42182 || t >= 43360 && t <= 43388 || t >= 44032 && t <= 55203 || t >= 63744 && t <= 64255 || t >= 65040 && t <= 65049 || t >= 65072 && t <= 65106 || t >= 65108 && t <= 65126 || t >= 65128 && t <= 65131 || t >= 94176 && t <= 94180 || t === 94192 || t === 94193 || t >= 94208 && t <= 100343 || t >= 100352 && t <= 101589 || t >= 101632 && t <= 101640 || t >= 110576 && t <= 110579 || t >= 110581 && t <= 110587 || t === 110589 || t === 110590 || t >= 110592 && t <= 110882 || t === 110898 || t >= 110928 && t <= 110930 || t === 110933 || t >= 110948 && t <= 110951 || t >= 110960 && t <= 111355 || t === 126980 || t === 127183 || t === 127374 || t >= 127377 && t <= 127386 || t >= 127488 && t <= 127490 || t >= 127504 && t <= 127547 || t >= 127552 && t <= 127560 || t === 127568 || t === 127569 || t >= 127584 && t <= 127589 || t >= 127744 && t <= 127776 || t >= 127789 && t <= 127797 || t >= 127799 && t <= 127868 || t >= 127870 && t <= 127891 || t >= 127904 && t <= 127946 || t >= 127951 && t <= 127955 || t >= 127968 && t <= 127984 || t === 127988 || t >= 127992 && t <= 128062 || t === 128064 || t >= 128066 && t <= 128252 || t >= 128255 && t <= 128317 || t >= 128331 && t <= 128334 || t >= 128336 && t <= 128359 || t === 128378 || t === 128405 || t === 128406 || t === 128420 || t >= 128507 && t <= 128591 || t >= 128640 && t <= 128709 || t === 128716 || t >= 128720 && t <= 128722 || t >= 128725 && t <= 128727 || t >= 128732 && t <= 128735 || t === 128747 || t === 128748 || t >= 128756 && t <= 128764 || t >= 128992 && t <= 129003 || t === 129008 || t >= 129292 && t <= 129338 || t >= 129340 && t <= 129349 || t >= 129351 && t <= 129535 || t >= 129648 && t <= 129660 || t >= 129664 && t <= 129672 || t >= 129680 && t <= 129725 || t >= 129727 && t <= 129733 || t >= 129742 && t <= 129755 || t >= 129760 && t <= 129768 || t >= 129776 && t <= 129784 || t >= 131072 && t <= 196605 || t >= 196608 && t <= 262141;
}
var q9 = (t) => !(Z9(t) || W9(t)), X9 = /[^\x20-\x7F]/;
function V9(t) {
  if (!t)
    return 0;
  if (!X9.test(t))
    return t.length;
  t = t.replace(j9(), "  ");
  let e = 0;
  for (let r of t) {
    let n = r.codePointAt(0);
    n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (e += q9(n) ? 1 : 2);
  }
  return e;
}
var oo = V9;
function Ny(t) {
  return (e, r, n) => {
    let i = !!(n != null && n.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, a = r;
    for (; a >= 0 && a < s; ) {
      let o = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(o))
          return a;
      } else if (!t.includes(o))
        return a;
      i ? a-- : a++;
    }
    return a === -1 || a === s ? a : !1;
  };
}
var lo = Ny(" 	"), Y9 = Ny(",; 	"), U9 = Ny(/[^\n\r]/);
function z9(t, e, r) {
  let n = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let i = t.charAt(e);
  if (n) {
    if (t.charAt(e - 1) === "\r" && i === `
`)
      return e - 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e - 1;
  } else {
    if (i === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e + 1;
  }
  return e;
}
var uo = z9;
function G9(t, e, r = {}) {
  let n = lo(t, r.backwards ? e - 1 : e, r), i = uo(t, n, r);
  return n !== i;
}
var Hr = G9;
function H9(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var _y = H9;
function J9(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? U9(t, e) : e;
}
var Qy = J9;
function K9(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = Y9(t, n), n = _y(t, n), n = lo(t, n);
  return n = Qy(t, n), n = uo(t, n), n !== !1 && Hr(t, n);
}
var My = K9;
function e4(t) {
  return Array.isArray(t) && t.length > 0;
}
var Ve = e4, fc = "'", P1 = '"';
function t4(t, e) {
  let r = e === !0 || e === fc ? fc : P1, n = r === fc ? P1 : fc, i = 0, s = 0;
  for (let a of t)
    a === r ? i++ : a === n && s++;
  return i > s ? n : r;
}
var _S = t4;
function r4(t, e, r) {
  let n = e === '"' ? "'" : '"', i = Yr(!1, t, /\\(.)|(["'])/gs, (s, a, o) => a === n ? a : o === e ? "\\" + o : o || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(a) ? a : "\\" + a));
  return e + i + e;
}
var n4 = r4;
function i4(t, e) {
  let r = t.slice(1, -1), n = e.parser === "json" || e.parser === "jsonc" || e.parser === "json5" && e.quoteProps === "preserve" && !e.singleQuote ? '"' : e.__isInHtmlAttribute ? "'" : _S(r, e.singleQuote);
  return n4(r, n, !(e.parser === "css" || e.parser === "less" || e.parser === "scss" || e.__embeddedInHtml));
}
var Wl = i4;
function mt(t) {
  var e, r, n;
  let i = ((e = t.range) == null ? void 0 : e[0]) ?? t.start, s = (n = ((r = t.declaration) == null ? void 0 : r.decorators) ?? t.decorators) == null ? void 0 : n[0];
  return s ? Math.min(mt(s), i) : i;
}
function Ye(t) {
  var e;
  return ((e = t.range) == null ? void 0 : e[1]) ?? t.end;
}
function Zp(t, e) {
  let r = mt(t);
  return Number.isInteger(r) && r === mt(e);
}
function s4(t, e) {
  let r = Ye(t);
  return Number.isInteger(r) && r === Ye(e);
}
function a4(t, e) {
  return Zp(t, e) && s4(t, e);
}
var Ko = null;
function Cl(t) {
  if (Ko !== null && typeof Ko.property) {
    let e = Ko;
    return Ko = Cl.prototype = null, e;
  }
  return Ko = Cl.prototype = t ?? /* @__PURE__ */ Object.create(null), new Cl();
}
var o4 = 10;
for (let t = 0; t <= o4; t++)
  Cl();
function l4(t) {
  return Cl(t);
}
function u4(t, e = "type") {
  l4(t);
  function r(n) {
    let i = n[e], s = t[i];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: n });
    return s;
  }
  return r;
}
var QS = u4, c4 = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value", "optional", "static", "method"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareEnum: ["id", "body"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], AsConstExpression: ["expression"], SatisfiesExpression: ["expression", "typeAnnotation"] }, h4 = QS(c4), MS = h4;
function p4(t) {
  let e = new Set(t);
  return (r) => e.has(r == null ? void 0 : r.type);
}
var tt = p4, d4 = tt(["Block", "CommentBlock", "MultiLine"]), xn = d4, f4 = tt(["AnyTypeAnnotation", "ThisTypeAnnotation", "NumberTypeAnnotation", "VoidTypeAnnotation", "BooleanTypeAnnotation", "BigIntTypeAnnotation", "SymbolTypeAnnotation", "StringTypeAnnotation", "NeverTypeAnnotation", "UndefinedTypeAnnotation", "UnknownTypeAnnotation", "EmptyTypeAnnotation", "MixedTypeAnnotation"]), LS = f4;
function m4(t, e) {
  let r = e.split(".");
  for (let n = r.length - 1; n >= 0; n--) {
    let i = r[n];
    if (n === 0)
      return t.type === "Identifier" && t.name === i;
    if (t.type !== "MemberExpression" || t.optional || t.computed || t.property.type !== "Identifier" || t.property.name !== i)
      return !1;
    t = t.object;
  }
}
function g4(t, e) {
  return e.some((r) => m4(t, r));
}
var y4 = g4;
function O4({ type: t }) {
  return t.startsWith("TS") && t.endsWith("Keyword");
}
var RS = O4;
function am(t, e) {
  return e(t) || R9(t, { getVisitorKeys: MS, predicate: e });
}
function Ly(t) {
  return t.type === "AssignmentExpression" || t.type === "BinaryExpression" || t.type === "LogicalExpression" || t.type === "NGPipeExpression" || t.type === "ConditionalExpression" || qe(t) || ft(t) || t.type === "SequenceExpression" || t.type === "TaggedTemplateExpression" || t.type === "BindExpression" || t.type === "UpdateExpression" && !t.prefix || Hn(t) || t.type === "TSNonNullExpression" || t.type === "ChainExpression";
}
function x4(t) {
  return t.expressions ? t.expressions[0] : t.left ?? t.test ?? t.callee ?? t.object ?? t.tag ?? t.argument ?? t.expression;
}
function jS(t) {
  if (t.expressions)
    return ["expressions", 0];
  if (t.left)
    return ["left"];
  if (t.test)
    return ["test"];
  if (t.object)
    return ["object"];
  if (t.callee)
    return ["callee"];
  if (t.tag)
    return ["tag"];
  if (t.argument)
    return ["argument"];
  if (t.expression)
    return ["expression"];
  throw new Error("Unexpected node has no left side.");
}
var Wp = tt(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose", "Hashbang", "InterpreterDirective"]), b4 = tt(["ExportDefaultDeclaration", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "DeclareExportAllDeclaration"]), Kt = tt(["ArrayExpression", "TupleExpression"]), In = tt(["ObjectExpression", "RecordExpression"]);
function fs(t) {
  return t.type === "NumericLiteral" || t.type === "Literal" && typeof t.value == "number";
}
function ZS(t) {
  return t.type === "UnaryExpression" && (t.operator === "+" || t.operator === "-") && fs(t.argument);
}
function Tr(t) {
  return t.type === "StringLiteral" || t.type === "Literal" && typeof t.value == "string";
}
function WS(t) {
  return t.type === "RegExpLiteral" || t.type === "Literal" && !!t.regex;
}
var qp = tt(["Literal", "BooleanLiteral", "BigIntLiteral", "DecimalLiteral", "DirectiveLiteral", "NullLiteral", "NumericLiteral", "RegExpLiteral", "StringLiteral"]), qS = tt(["Identifier", "ThisExpression", "Super", "PrivateName", "PrivateIdentifier", "Import"]), ms = tt(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), ql = tt(["FunctionExpression", "ArrowFunctionExpression"]);
function D4(t) {
  return t.type === "FunctionExpression" || t.type === "ArrowFunctionExpression" && t.body.type === "BlockStatement";
}
function Wd(t) {
  return qe(t) && t.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(t.callee.name);
}
var Lt = tt(["JSXElement", "JSXFragment"]);
function Xp(t) {
  return t.method && t.kind === "init" || t.kind === "get" || t.kind === "set";
}
function XS(t) {
  return (t.type === "ObjectTypeProperty" || t.type === "ObjectTypeInternalSlot") && !t.static && !t.method && t.kind !== "get" && t.kind !== "set" && t.value.type === "FunctionTypeAnnotation";
}
function v4(t) {
  return (t.type === "TypeAnnotation" || t.type === "TSTypeAnnotation") && t.typeAnnotation.type === "FunctionTypeAnnotation" && !t.static && !Zp(t, t.typeAnnotation);
}
var wi = tt(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
function Qa(t) {
  return ft(t) || t.type === "BindExpression" && !!t.object;
}
var S4 = tt(["TSThisType", "NullLiteralTypeAnnotation", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType"]);
function Ry(t) {
  return RS(t) || LS(t) || S4(t) || (t.type === "GenericTypeAnnotation" || t.type === "TSTypeReference") && !t.typeParameters;
}
function w4(t) {
  let e = /^(?:before|after)(?:Each|All)$/;
  return t.callee.type === "Identifier" && t.arguments.length === 1 && e.test(t.callee.name);
}
var C4 = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
function E4(t) {
  return y4(t, C4);
}
function Vp(t, e) {
  if (t.type !== "CallExpression")
    return !1;
  if (t.arguments.length === 1) {
    if (Wd(t) && e && Vp(e))
      return ql(t.arguments[0]);
    if (w4(t))
      return Wd(t.arguments[0]);
  } else if ((t.arguments.length === 2 || t.arguments.length === 3) && (t.arguments[0].type === "TemplateLiteral" || Tr(t.arguments[0])) && E4(t.callee))
    return t.arguments[2] && !fs(t.arguments[2]) ? !1 : (t.arguments.length === 2 ? ql(t.arguments[1]) : D4(t.arguments[1]) && cr(t.arguments[1]).length <= 1) || Wd(t.arguments[1]);
  return !1;
}
var VS = (t) => (e) => ((e == null ? void 0 : e.type) === "ChainExpression" && (e = e.expression), t(e)), qe = VS(tt(["CallExpression", "OptionalCallExpression"])), ft = VS(tt(["MemberExpression", "OptionalMemberExpression"]));
function A4(t) {
  let e = "expressions";
  t.type === "TSTemplateLiteralType" && (e = "types");
  let r = t[e];
  return r.length === 0 ? !1 : r.every((n) => {
    if (om(n) || YS(n))
      return !0;
  });
}
function YS(t, { maxDepth: e = Number.POSITIVE_INFINITY } = {}) {
  if (ae(t))
    return !1;
  if (t.type === "ChainExpression")
    return YS(t.expression, { maxDepth: e });
  if (!ft(t))
    return !1;
  let r = t, n = 0;
  for (; ft(r) && n++ <= e; )
    if (!om(r.property) || (r = r.object, ae(r)))
      return !1;
  return om(r);
}
function om(t) {
  return ae(t) ? !1 : qp(t) || qS(t);
}
function F1(t, e = 5) {
  return US(t, e) <= e;
}
function US(t, e) {
  let r = 0;
  for (let n in t) {
    let i = t[n];
    if (i && typeof i == "object" && typeof i.type == "string" && (r++, r += US(i, e - r)), r > e)
      return r;
  }
  return r;
}
var T4 = 0.25;
function jy(t, e) {
  let { printWidth: r } = e;
  if (ae(t))
    return !1;
  let n = r * T4;
  if (t.type === "ThisExpression" || t.type === "Identifier" && t.name.length <= n || ZS(t) && !ae(t.argument))
    return !0;
  let i = t.type === "Literal" && "regex" in t && t.regex.pattern || t.type === "RegExpLiteral" && t.pattern;
  return i ? i.length <= n : Tr(t) ? Wl(mn(t), e).length <= n : t.type === "TemplateLiteral" ? t.expressions.length === 0 && t.quasis[0].value.raw.length <= n && !t.quasis[0].value.raw.includes(`
`) : t.type === "UnaryExpression" ? jy(t.argument, { printWidth: r }) : t.type === "CallExpression" && t.arguments.length === 0 && t.callee.type === "Identifier" ? t.callee.name.length <= n - 2 : qp(t);
}
function Js(t, e) {
  return Lt(e) ? Yp(e) : ae(e, fe.Leading, (r) => Hr(t, Ye(r)));
}
function $1(t, e) {
  return e.parser !== "json" && e.parser !== "jsonc" && Tr(t.key) && mn(t.key).slice(1, -1) === t.key.value && (N9(t.key.value) && !(e.parser === "babel-ts" && t.type === "ClassProperty" || e.parser === "typescript" && t.type === "PropertyDefinition") || zS(t.key.value) && String(Number(t.key.value)) === t.key.value && (e.parser === "babel" || e.parser === "acorn" || e.parser === "espree" || e.parser === "meriyah" || e.parser === "__babel_estree"));
}
function zS(t) {
  return /^(?:\d+|\d+\.\d+)$/.test(t);
}
function B1(t) {
  return t.quasis.some((e) => e.value.raw.includes(`
`));
}
function GS(t, e) {
  return (t.type === "TemplateLiteral" && B1(t) || t.type === "TaggedTemplateExpression" && B1(t.quasi)) && !Hr(e, mt(t), { backwards: !0 });
}
function HS(t) {
  if (!ae(t))
    return !1;
  let e = ze(!1, Ua(t, fe.Dangling), -1);
  return e && !xn(e);
}
function k4(t) {
  if (t.length <= 1)
    return !1;
  let e = 0;
  for (let r of t)
    if (ql(r)) {
      if (e += 1, e > 1)
        return !0;
    } else if (qe(r)) {
      for (let n of gn(r))
        if (ql(n))
          return !0;
    }
  return !1;
}
function JS(t) {
  let { node: e, parent: r, key: n } = t;
  return n === "callee" && qe(e) && qe(r) && r.arguments.length > 0 && e.arguments.length > r.arguments.length;
}
var P4 = /* @__PURE__ */ new Set(["!", "-", "+", "~"]);
function kn(t, e = 2) {
  if (e <= 0)
    return !1;
  if (t.type === "ChainExpression" || t.type === "TSNonNullExpression")
    return kn(t.expression, e);
  let r = (n) => kn(n, e - 1);
  if (WS(t))
    return oo(t.pattern ?? t.regex.pattern) <= 5;
  if (qp(t) || qS(t) || t.type === "ArgumentPlaceholder")
    return !0;
  if (t.type === "TemplateLiteral")
    return t.quasis.every((n) => !n.value.raw.includes(`
`)) && t.expressions.every(r);
  if (In(t))
    return t.properties.every((n) => !n.computed && (n.shorthand || n.value && r(n.value)));
  if (Kt(t))
    return t.elements.every((n) => n === null || r(n));
  if (co(t)) {
    if (t.type === "ImportExpression" || kn(t.callee, e)) {
      let n = gn(t);
      return n.length <= e && n.every(r);
    }
    return !1;
  }
  return ft(t) ? kn(t.object, e) && kn(t.property, e) : t.type === "UnaryExpression" && P4.has(t.operator) || t.type === "UpdateExpression" ? kn(t.argument, e) : !1;
}
function mn(t) {
  var e;
  return ((e = t.extra) == null ? void 0 : e.raw) ?? t.raw;
}
function F4(t) {
  return t;
}
function Cs(t, e = "es5") {
  return t.trailingComma === "es5" && e === "es5" || t.trailingComma === "all" && (e === "all" || e === "es5");
}
function fr(t, e) {
  switch (t.type) {
    case "BinaryExpression":
    case "LogicalExpression":
    case "AssignmentExpression":
    case "NGPipeExpression":
      return fr(t.left, e);
    case "MemberExpression":
    case "OptionalMemberExpression":
      return fr(t.object, e);
    case "TaggedTemplateExpression":
      return t.tag.type === "FunctionExpression" ? !1 : fr(t.tag, e);
    case "CallExpression":
    case "OptionalCallExpression":
      return t.callee.type === "FunctionExpression" ? !1 : fr(t.callee, e);
    case "ConditionalExpression":
      return fr(t.test, e);
    case "UpdateExpression":
      return !t.prefix && fr(t.argument, e);
    case "BindExpression":
      return t.object && fr(t.object, e);
    case "SequenceExpression":
      return fr(t.expressions[0], e);
    case "ChainExpression":
    case "TSSatisfiesExpression":
    case "TSAsExpression":
    case "TSNonNullExpression":
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
      return fr(t.expression, e);
    default:
      return e(t);
  }
}
var I1 = { "==": !0, "!=": !0, "===": !0, "!==": !0 }, mc = { "*": !0, "/": !0, "%": !0 }, lm = { ">>": !0, ">>>": !0, "<<": !0 };
function Zy(t, e) {
  return !(Sh(e) !== Sh(t) || t === "**" || I1[t] && I1[e] || e === "%" && mc[t] || t === "%" && mc[e] || e !== t && mc[e] && mc[t] || lm[t] && lm[e]);
}
var $4 = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((t, e) => t.map((r) => [r, e])));
function Sh(t) {
  return $4.get(t);
}
function B4(t) {
  return !!lm[t] || t === "|" || t === "^" || t === "&";
}
function I4(t) {
  var e;
  if (t.rest)
    return !0;
  let r = cr(t);
  return ((e = ze(!1, r, -1)) == null ? void 0 : e.type) === "RestElement";
}
var qd = /* @__PURE__ */ new WeakMap();
function cr(t) {
  if (qd.has(t))
    return qd.get(t);
  let e = [];
  return t.this && e.push(t.this), Array.isArray(t.parameters) ? e.push(...t.parameters) : Array.isArray(t.params) && e.push(...t.params), t.rest && e.push(t.rest), qd.set(t, e), e;
}
function N4(t, e) {
  let { node: r } = t, n = 0, i = (s) => e(s, n++);
  r.this && t.call(i, "this"), Array.isArray(r.parameters) ? t.each(i, "parameters") : Array.isArray(r.params) && t.each(i, "params"), r.rest && t.call(i, "rest");
}
var Xd = /* @__PURE__ */ new WeakMap();
function gn(t) {
  if (Xd.has(t))
    return Xd.get(t);
  if (t.type === "ChainExpression")
    return gn(t.expression);
  let e = t.arguments;
  return t.type === "ImportExpression" && (e = [t.source], t.attributes && e.push(t.attributes), t.options && e.push(t.options)), Xd.set(t, e), e;
}
function Wy(t, e) {
  let { node: r } = t;
  if (r.type === "ChainExpression")
    return t.call(() => Wy(t, e), "expression");
  r.type === "ImportExpression" ? (t.call((n) => e(n, 0), "source"), r.attributes && t.call((n) => e(n, 1), "attributes"), r.options && t.call((n) => e(n, 1), "options")) : t.each(e, "arguments");
}
function N1(t, e) {
  let r = [];
  if (t.type === "ChainExpression" && r.push("expression"), t.type === "ImportExpression") {
    if (e === 0 || e === (t.attributes || t.options ? -2 : -1))
      return [...r, "source"];
    if (t.attributes && (e === 1 || e === -1))
      return [...r, "attributes"];
    if (t.options && (e === 1 || e === -1))
      return [...r, "options"];
    throw new RangeError("Invalid argument index");
  }
  if (e < 0 && (e = t.arguments.length + e), e < 0 || e >= t.arguments.length)
    throw new RangeError("Invalid argument index");
  return [...r, "arguments", e];
}
function wh(t) {
  return t.value.trim() === "prettier-ignore" && !t.unignore;
}
function Yp(t) {
  return (t == null ? void 0 : t.prettierIgnore) || ae(t, fe.PrettierIgnore);
}
var fe = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, KS = (t, e) => {
  if (typeof t == "function" && (e = t, t = 0), t || e)
    return (r, n, i) => !(t & fe.Leading && !r.leading || t & fe.Trailing && !r.trailing || t & fe.Dangling && (r.leading || r.trailing) || t & fe.Block && !xn(r) || t & fe.Line && !Wp(r) || t & fe.First && n !== 0 || t & fe.Last && n !== i.length - 1 || t & fe.PrettierIgnore && !wh(r) || e && !e(r));
};
function ae(t, e, r) {
  if (!Ve(t == null ? void 0 : t.comments))
    return !1;
  let n = KS(e, r);
  return n ? t.comments.some(n) : !0;
}
function Ua(t, e, r) {
  if (!Array.isArray(t == null ? void 0 : t.comments))
    return [];
  let n = KS(e, r);
  return n ? t.comments.filter(n) : t.comments;
}
var Es = (t, { originalText: e }) => My(e, Ye(t));
function co(t) {
  return qe(t) || t.type === "NewExpression" || t.type === "ImportExpression";
}
function Mi(t) {
  return t && (t.type === "ObjectProperty" || t.type === "Property" && !Xp(t));
}
var Hn = tt(["TSAsExpression", "TSSatisfiesExpression", "AsExpression", "AsConstExpression", "SatisfiesExpression"]), Ks = tt(["UnionTypeAnnotation", "TSUnionType"]), ew = tt(["IntersectionTypeAnnotation", "TSIntersectionType"]), _4 = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), $a = (t) => {
  for (let e of t.quasis)
    delete e.value;
};
function tw(t, e, r) {
  var n, i;
  if (t.type === "Program" && delete e.sourceType, (t.type === "BigIntLiteral" || t.type === "BigIntLiteralTypeAnnotation") && e.value && (e.value = e.value.toLowerCase()), (t.type === "BigIntLiteral" || t.type === "Literal") && e.bigint && (e.bigint = e.bigint.toLowerCase()), t.type === "DecimalLiteral" && (e.value = Number(e.value)), t.type === "Literal" && e.decimal && (e.decimal = Number(e.decimal)), t.type === "EmptyStatement" || t.type === "JSXText" || t.type === "JSXExpressionContainer" && (t.expression.type === "Literal" || t.expression.type === "StringLiteral") && t.expression.value === " ")
    return null;
  if ((t.type === "Property" || t.type === "ObjectProperty" || t.type === "MethodDefinition" || t.type === "ClassProperty" || t.type === "ClassMethod" || t.type === "PropertyDefinition" || t.type === "TSDeclareMethod" || t.type === "TSPropertySignature" || t.type === "ObjectTypeProperty") && typeof t.key == "object" && t.key && (t.key.type === "Literal" || t.key.type === "NumericLiteral" || t.key.type === "StringLiteral" || t.key.type === "Identifier") && delete e.key, t.type === "JSXElement" && t.openingElement.name.name === "style" && t.openingElement.attributes.some((a) => a.type === "JSXAttribute" && a.name.name === "jsx"))
    for (let { type: a, expression: o } of e.children)
      a === "JSXExpressionContainer" && o.type === "TemplateLiteral" && $a(o);
  t.type === "JSXAttribute" && t.name.name === "css" && t.value.type === "JSXExpressionContainer" && t.value.expression.type === "TemplateLiteral" && $a(e.value.expression), t.type === "JSXAttribute" && ((n = t.value) == null ? void 0 : n.type) === "Literal" && /["']|&quot;|&apos;/.test(t.value.value) && (e.value.value = Yr(!1, e.value.value, /["']|&quot;|&apos;/g, '"'));
  let s = t.expression || t.callee;
  if (t.type === "Decorator" && s.type === "CallExpression" && s.callee.name === "Component" && s.arguments.length === 1) {
    let a = t.expression.arguments[0].properties;
    for (let [o, u] of e.expression.arguments[0].properties.entries())
      switch (a[o].key.name) {
        case "styles":
          Kt(u.value) && $a(u.value.elements[0]);
          break;
        case "template":
          u.value.type === "TemplateLiteral" && $a(u.value);
          break;
      }
  }
  if (t.type === "TaggedTemplateExpression" && (t.tag.type === "MemberExpression" || t.tag.type === "Identifier" && (t.tag.name === "gql" || t.tag.name === "graphql" || t.tag.name === "css" || t.tag.name === "md" || t.tag.name === "markdown" || t.tag.name === "html") || t.tag.type === "CallExpression") && $a(e.quasi), t.type === "TemplateLiteral" && ((i = t.leadingComments) != null && i.some((a) => xn(a) && ["GraphQL", "HTML"].some((o) => a.value === ` ${o} `)) || r.type === "CallExpression" && r.callee.name === "graphql" || !t.leadingComments) && $a(e), (t.type === "TSIntersectionType" || t.type === "TSUnionType") && t.types.length === 1)
    return e.types[0];
  t.type === "ChainExpression" && t.expression.type === "TSNonNullExpression" && ([e.type, e.expression.type] = [e.expression.type, e.type]);
}
tw.ignoredProperties = _4;
var Q4 = tw, Ao = "string", ea = "array", To = "cursor", ma = "indent", ga = "align", ko = "trim", yn = "group", oi = "fill", ti = "if-break", ya = "indent-if-break", Oa = "line-suffix", xa = "line-suffix-boundary", en = "line", As = "label", Ts = "break-parent", rw = /* @__PURE__ */ new Set([To, ma, ga, ko, yn, oi, ti, ya, Oa, xa, en, As, Ts]);
function M4(t) {
  if (typeof t == "string")
    return Ao;
  if (Array.isArray(t))
    return ea;
  if (!t)
    return;
  let { type: e } = t;
  if (rw.has(e))
    return e;
}
var Po = M4, L4 = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
function R4(t) {
  let e = t === null ? "null" : typeof t;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (Po(t))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = L4([...rw].map((i) => `'${i}'`));
  return `Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`;
}
var j4 = class extends Error {
  constructor(e) {
    super(R4(e));
    wn(this, "name", "InvalidDocError");
    this.doc = e;
  }
}, Xl = j4, _1 = {};
function Z4(t, e, r, n) {
  let i = [t];
  for (; i.length > 0; ) {
    let s = i.pop();
    if (s === _1) {
      r(i.pop());
      continue;
    }
    r && i.push(s, _1);
    let a = Po(s);
    if (!a)
      throw new Xl(s);
    if ((e == null ? void 0 : e(s)) !== !1)
      switch (a) {
        case ea:
        case oi: {
          let o = a === ea ? s : s.parts;
          for (let u = o.length, c = u - 1; c >= 0; --c)
            i.push(o[c]);
          break;
        }
        case ti:
          i.push(s.flatContents, s.breakContents);
          break;
        case yn:
          if (n && s.expandedStates)
            for (let o = s.expandedStates.length, u = o - 1; u >= 0; --u)
              i.push(s.expandedStates[u]);
          else
            i.push(s.contents);
          break;
        case ga:
        case ma:
        case ya:
        case As:
        case Oa:
          i.push(s.contents);
          break;
        case Ao:
        case To:
        case ko:
        case xa:
        case en:
        case Ts:
          break;
        default:
          throw new Xl(s);
      }
  }
}
var nw = Z4, W4 = () => {
}, q4 = W4;
function te(t) {
  return { type: ma, contents: t };
}
function li(t, e) {
  return { type: ga, contents: e, n: t };
}
function Z(t, e = {}) {
  return q4(e.expandedStates), { type: yn, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function X4(t) {
  return li(Number.NEGATIVE_INFINITY, t);
}
function iw(t) {
  return li(-1, t);
}
function Ws(t, e) {
  return Z(t[0], { ...e, expandedStates: t });
}
function qy(t) {
  return { type: oi, parts: t };
}
function Fe(t, e = "", r = {}) {
  return { type: ti, breakContents: t, flatContents: e, groupId: r.groupId };
}
function Up(t, e) {
  return { type: ya, contents: t, groupId: e.groupId, negate: e.negate };
}
function Q1(t) {
  return { type: Oa, contents: t };
}
var Ci = { type: xa }, ui = { type: Ts }, sw = { type: en, hard: !0 }, V4 = { type: en, hard: !0, literal: !0 }, de = { type: en }, K = { type: en, soft: !0 }, ee = [sw, ui], aw = [V4, ui], M1 = { type: To };
function Re(t, e) {
  let r = [];
  for (let n = 0; n < e.length; n++)
    n !== 0 && r.push(t), r.push(e[n]);
  return r;
}
function Y4(t, e, r) {
  let n = t;
  if (e > 0) {
    for (let i = 0; i < Math.floor(e / r); ++i)
      n = te(n);
    n = li(e % r, n), n = li(Number.NEGATIVE_INFINITY, n);
  }
  return n;
}
function Tu(t, e) {
  return t ? { type: As, label: t, contents: e } : e;
}
var ow = (t) => {
  if (Array.isArray(t))
    return t;
  if (t.type !== oi)
    throw new Error(`Expect doc to be 'array' or '${oi}'.`);
  return t.parts;
};
function Fo(t, e) {
  if (typeof t == "string")
    return e(t);
  let r = /* @__PURE__ */ new Map();
  return n(t);
  function n(s) {
    if (r.has(s))
      return r.get(s);
    let a = i(s);
    return r.set(s, a), a;
  }
  function i(s) {
    switch (Po(s)) {
      case ea:
        return e(s.map(n));
      case oi:
        return e({ ...s, parts: s.parts.map(n) });
      case ti:
        return e({ ...s, breakContents: n(s.breakContents), flatContents: n(s.flatContents) });
      case yn: {
        let { expandedStates: a, contents: o } = s;
        return a ? (a = a.map(n), o = a[0]) : o = n(o), e({ ...s, contents: o, expandedStates: a });
      }
      case ga:
      case ma:
      case ya:
      case As:
      case Oa:
        return e({ ...s, contents: n(s.contents) });
      case Ao:
      case To:
      case ko:
      case xa:
      case en:
      case Ts:
        return e(s);
      default:
        throw new Xl(s);
    }
  }
}
function lw(t, e, r) {
  let n = r, i = !1;
  function s(a) {
    if (i)
      return !1;
    let o = e(a);
    o !== void 0 && (i = !0, n = o);
  }
  return nw(t, s), n;
}
function U4(t) {
  if (t.type === yn && t.break || t.type === en && t.hard || t.type === Ts)
    return !0;
}
function mr(t) {
  return lw(t, U4, !1);
}
function L1(t) {
  if (t.length > 0) {
    let e = ze(!1, t, -1);
    !e.expandedStates && !e.break && (e.break = "propagated");
  }
  return null;
}
function z4(t) {
  let e = /* @__PURE__ */ new Set(), r = [];
  function n(s) {
    if (s.type === Ts && L1(r), s.type === yn) {
      if (r.push(s), e.has(s))
        return !1;
      e.add(s);
    }
  }
  function i(s) {
    s.type === yn && r.pop().break && L1(r);
  }
  nw(t, n, i, !0);
}
function G4(t) {
  return t.type === en && !t.hard ? t.soft ? "" : " " : t.type === ti ? t.flatContents : t;
}
function um(t) {
  return Fo(t, G4);
}
function H4(t) {
  switch (Po(t)) {
    case oi:
      if (t.parts.every((e) => e === ""))
        return "";
      break;
    case yn:
      if (!t.contents && !t.id && !t.break && !t.expandedStates)
        return "";
      if (t.contents.type === yn && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates)
        return t.contents;
      break;
    case ga:
    case ma:
    case ya:
    case Oa:
      if (!t.contents)
        return "";
      break;
    case ti:
      if (!t.flatContents && !t.breakContents)
        return "";
      break;
    case ea: {
      let e = [];
      for (let r of t) {
        if (!r)
          continue;
        let [n, ...i] = Array.isArray(r) ? r : [r];
        typeof n == "string" && typeof ze(!1, e, -1) == "string" ? e[e.length - 1] += n : e.push(n), e.push(...i);
      }
      return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
    }
    case Ao:
    case To:
    case ko:
    case xa:
    case en:
    case As:
    case Ts:
      break;
    default:
      throw new Xl(t);
  }
  return t;
}
function Xy(t) {
  return Fo(t, (e) => H4(e));
}
function ta(t, e = aw) {
  return Fo(t, (r) => typeof r == "string" ? Re(e, r.split(`
`)) : r);
}
function J4(t) {
  if (t.type === en)
    return !0;
}
function K4(t) {
  return lw(t, J4, !1);
}
function cm(t, e) {
  return t.type === As ? { ...t, contents: e(t.contents) } : e(t);
}
function e6(t) {
  let e = `*${t.value}*`.split(`
`);
  return e.length > 1 && e.every((r) => r.trimStart()[0] === "*");
}
var t6 = e6;
function r6(t, e) {
  let r = t.node;
  if (Wp(r))
    return e.originalText.slice(mt(r), Ye(r)).trimEnd();
  if (xn(r))
    return t6(r) ? n6(r) : ["/*", ta(r.value), "*/"];
  throw new Error("Not a comment: " + JSON.stringify(r));
}
function n6(t) {
  let e = t.value.split(`
`);
  return ["/*", Re(ee, e.map((r, n) => n === 0 ? r.trimEnd() : " " + (n < e.length - 1 ? r.trim() : r.trimStart()))), "*/"];
}
var uw = {};
jp(uw, { endOfLine: () => h6, ownLine: () => c6, remaining: () => p6 });
function i6(t) {
  let e = t.type || t.kind || "(unknown type)", r = String(t.name || t.id && (typeof t.id == "object" ? t.id.name : t.id) || t.key && (typeof t.key == "object" ? t.key.name : t.key) || t.value && (typeof t.value == "object" ? "" : String(t.value)) || t.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + ""), e + (r ? " " + r : "");
}
function Vy(t, e) {
  (t.comments ?? (t.comments = [])).push(e), e.printed = !1, e.nodeDescription = i6(t);
}
function er(t, e) {
  e.leading = !0, e.trailing = !1, Vy(t, e);
}
function Jr(t, e, r) {
  e.leading = !1, e.trailing = !1, r && (e.marker = r), Vy(t, e);
}
function St(t, e) {
  e.leading = !1, e.trailing = !0, Vy(t, e);
}
function s6(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = lo(t, n), n = _y(t, n), n = Qy(t, n), n = uo(t, n);
  return n;
}
var ku = s6;
function a6(t, e) {
  let r = ku(t, e);
  return r === !1 ? "" : t.charAt(r);
}
var Ei = a6;
function o6(t, e, r) {
  for (let n = e; n < r; ++n)
    if (t.charAt(n) === `
`)
      return !0;
  return !1;
}
var gs = o6;
function l6(t) {
  return xn(t) && t.value[0] === "*" && /@(?:type|satisfies)\b/.test(t.value);
}
var u6 = l6;
function c6(t) {
  return [yw, hw, fw, f6, Yy, Uy, cw, pw, E6, w6, Gy, gw, A6, dw, mw, zy, m6, N6].some((e) => e(t));
}
function h6(t) {
  return [d6, fw, hw, gw, Yy, Uy, cw, pw, mw, S6, C6, Gy, P6, zy, B6, I6].some((e) => e(t));
}
function p6(t) {
  return [yw, Yy, Uy, g6, v6, dw, Gy, D6, b6, $6, zy, F6].some((e) => e(t));
}
function ba(t, e) {
  let r = (t.body || t.properties).find(({ type: n }) => n !== "EmptyStatement");
  r ? er(r, e) : Jr(t, e);
}
function hm(t, e) {
  t.type === "BlockStatement" ? ba(t, e) : er(t, e);
}
function d6({ comment: t, followingNode: e }) {
  return e && u6(t) ? (er(e, t), !0) : !1;
}
function Yy({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n, text: i }) {
  if ((r == null ? void 0 : r.type) !== "IfStatement" || !n)
    return !1;
  if (Ei(i, Ye(t)) === ")")
    return St(e, t), !0;
  if (e === r.consequent && n === r.alternate) {
    if (e.type === "BlockStatement")
      St(e, t);
    else {
      let s = Wp(t) || t.loc.start.line === t.loc.end.line, a = t.loc.start.line === e.loc.start.line;
      s && a ? St(e, t) : Jr(r, t);
    }
    return !0;
  }
  return n.type === "BlockStatement" ? (ba(n, t), !0) : n.type === "IfStatement" ? (hm(n.consequent, t), !0) : r.consequent === n ? (er(n, t), !0) : !1;
}
function Uy({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n, text: i }) {
  return (r == null ? void 0 : r.type) !== "WhileStatement" || !n ? !1 : Ei(i, Ye(t)) === ")" ? (St(e, t), !0) : n.type === "BlockStatement" ? (ba(n, t), !0) : r.body === n ? (er(n, t), !0) : !1;
}
function cw({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n }) {
  return (r == null ? void 0 : r.type) !== "TryStatement" && (r == null ? void 0 : r.type) !== "CatchClause" || !n ? !1 : r.type === "CatchClause" && e ? (St(e, t), !0) : n.type === "BlockStatement" ? (ba(n, t), !0) : n.type === "TryStatement" ? (hm(n.finalizer, t), !0) : n.type === "CatchClause" ? (hm(n.body, t), !0) : !1;
}
function f6({ comment: t, enclosingNode: e, followingNode: r }) {
  return ft(e) && (r == null ? void 0 : r.type) === "Identifier" ? (er(e, t), !0) : !1;
}
function m6({ comment: t, enclosingNode: e, followingNode: r, options: n }) {
  return !n.experimentalTernaries || !((e == null ? void 0 : e.type) === "ConditionalExpression" || (e == null ? void 0 : e.type) === "ConditionalTypeAnnotation" || (e == null ? void 0 : e.type) === "TSConditionalType") ? !1 : (r == null ? void 0 : r.type) === "ConditionalExpression" || (r == null ? void 0 : r.type) === "ConditionalTypeAnnotation" || (r == null ? void 0 : r.type) === "TSConditionalType" ? (Jr(e, t), !0) : !1;
}
function hw({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n, text: i, options: s }) {
  let a = e && !gs(i, Ye(e), mt(t));
  return (!e || !a) && ((r == null ? void 0 : r.type) === "ConditionalExpression" || (r == null ? void 0 : r.type) === "ConditionalTypeAnnotation" || (r == null ? void 0 : r.type) === "TSConditionalType") && n ? s.experimentalTernaries && r.alternate === n && !(xn(t) && !gs(s.originalText, mt(t), Ye(t))) ? (Jr(r, t), !0) : (er(n, t), !0) : !1;
}
function g6({ comment: t, precedingNode: e, enclosingNode: r }) {
  return Mi(r) && r.shorthand && r.key === e && r.value.type === "AssignmentPattern" ? (St(r.value.left, t), !0) : !1;
}
var y6 = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
function pw({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n }) {
  if (y6.has(r == null ? void 0 : r.type)) {
    if (Ve(r.decorators) && (n == null ? void 0 : n.type) !== "Decorator")
      return St(ze(!1, r.decorators, -1), t), !0;
    if (r.body && n === r.body)
      return ba(r.body, t), !0;
    if (n) {
      if (r.superClass && n === r.superClass && e && (e === r.id || e === r.typeParameters))
        return St(e, t), !0;
      for (let i of ["implements", "extends", "mixins"])
        if (r[i] && n === r[i][0])
          return e && (e === r.id || e === r.typeParameters || e === r.superClass) ? St(e, t) : Jr(r, t, i), !0;
    }
  }
  return !1;
}
var O6 = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
function dw({ comment: t, precedingNode: e, enclosingNode: r, text: n }) {
  return r && e && Ei(n, Ye(t)) === "(" && (r.type === "Property" || r.type === "TSDeclareMethod" || r.type === "TSAbstractMethodDefinition") && e.type === "Identifier" && r.key === e && Ei(n, Ye(e)) !== ":" || (e == null ? void 0 : e.type) === "Decorator" && O6.has(r == null ? void 0 : r.type) ? (St(e, t), !0) : !1;
}
var x6 = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
function b6({ comment: t, precedingNode: e, enclosingNode: r, text: n }) {
  return Ei(n, Ye(t)) !== "(" ? !1 : e && x6.has(r == null ? void 0 : r.type) ? (St(e, t), !0) : !1;
}
function D6({ comment: t, enclosingNode: e, text: r }) {
  if ((e == null ? void 0 : e.type) !== "ArrowFunctionExpression")
    return !1;
  let n = ku(r, Ye(t));
  return n !== !1 && r.slice(n, n + 2) === "=>" ? (Jr(e, t), !0) : !1;
}
function v6({ comment: t, enclosingNode: e, text: r }) {
  return Ei(r, Ye(t)) !== ")" ? !1 : e && (Ow(e) && cr(e).length === 0 || co(e) && gn(e).length === 0) ? (Jr(e, t), !0) : ((e == null ? void 0 : e.type) === "MethodDefinition" || (e == null ? void 0 : e.type) === "TSAbstractMethodDefinition") && cr(e.value).length === 0 ? (Jr(e.value, t), !0) : !1;
}
function fw({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n, text: i }) {
  return (e == null ? void 0 : e.type) === "FunctionTypeParam" && (r == null ? void 0 : r.type) === "FunctionTypeAnnotation" && (n == null ? void 0 : n.type) !== "FunctionTypeParam" || ((e == null ? void 0 : e.type) === "Identifier" || (e == null ? void 0 : e.type) === "AssignmentPattern" || (e == null ? void 0 : e.type) === "ObjectPattern" || (e == null ? void 0 : e.type) === "ArrayPattern" || (e == null ? void 0 : e.type) === "RestElement" || (e == null ? void 0 : e.type) === "TSParameterProperty") && Ow(r) && Ei(i, Ye(t)) === ")" ? (St(e, t), !0) : !xn(t) && ((r == null ? void 0 : r.type) === "FunctionDeclaration" || (r == null ? void 0 : r.type) === "FunctionExpression" || (r == null ? void 0 : r.type) === "ObjectMethod") && (n == null ? void 0 : n.type) === "BlockStatement" && r.body === n && ku(i, Ye(t)) === mt(n) ? (ba(n, t), !0) : !1;
}
function mw({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "LabeledStatement" ? (er(e, t), !0) : !1;
}
function zy({ comment: t, enclosingNode: e }) {
  return ((e == null ? void 0 : e.type) === "ContinueStatement" || (e == null ? void 0 : e.type) === "BreakStatement") && !e.label ? (St(e, t), !0) : !1;
}
function S6({ comment: t, precedingNode: e, enclosingNode: r }) {
  return qe(r) && e && r.callee === e && r.arguments.length > 0 ? (er(r.arguments[0], t), !0) : !1;
}
function w6({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n }) {
  return Ks(r) ? (wh(t) && (n.prettierIgnore = !0, t.unignore = !0), e ? (St(e, t), !0) : !1) : (Ks(n) && wh(t) && (n.types[0].prettierIgnore = !0, t.unignore = !0), !1);
}
function C6({ comment: t, enclosingNode: e }) {
  return Mi(e) ? (er(e, t), !0) : !1;
}
function Gy({ comment: t, enclosingNode: e, followingNode: r, ast: n, isLastComment: i }) {
  var s;
  return ((s = n == null ? void 0 : n.body) == null ? void 0 : s.length) === 0 ? (i ? Jr(n, t) : er(n, t), !0) : (e == null ? void 0 : e.type) === "Program" && e.body.length === 0 && !Ve(e.directives) ? (i ? Jr(e, t) : er(e, t), !0) : (r == null ? void 0 : r.type) === "Program" && r.body.length === 0 && (e == null ? void 0 : e.type) === "ModuleExpression" ? (Jr(r, t), !0) : !1;
}
function E6({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "ForInStatement" || (e == null ? void 0 : e.type) === "ForOfStatement" ? (er(e, t), !0) : !1;
}
function gw({ comment: t, precedingNode: e, enclosingNode: r, text: n }) {
  if ((r == null ? void 0 : r.type) === "ImportSpecifier" || (r == null ? void 0 : r.type) === "ExportSpecifier")
    return er(r, t), !0;
  let i = (e == null ? void 0 : e.type) === "ImportSpecifier" && (r == null ? void 0 : r.type) === "ImportDeclaration", s = (e == null ? void 0 : e.type) === "ExportSpecifier" && (r == null ? void 0 : r.type) === "ExportNamedDeclaration";
  return (i || s) && Hr(n, Ye(t)) ? (St(e, t), !0) : !1;
}
function A6({ comment: t, enclosingNode: e }) {
  return (e == null ? void 0 : e.type) === "AssignmentPattern" ? (er(e, t), !0) : !1;
}
var T6 = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), k6 = /* @__PURE__ */ new Set(["ObjectExpression", "RecordExpression", "ArrayExpression", "TupleExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
function P6({ comment: t, enclosingNode: e, followingNode: r }) {
  return T6.has(e == null ? void 0 : e.type) && r && (k6.has(r.type) || xn(t)) ? (er(r, t), !0) : !1;
}
function F6({ comment: t, enclosingNode: e, followingNode: r, text: n }) {
  return !r && ((e == null ? void 0 : e.type) === "TSMethodSignature" || (e == null ? void 0 : e.type) === "TSDeclareFunction" || (e == null ? void 0 : e.type) === "TSAbstractMethodDefinition") && Ei(n, Ye(t)) === ";" ? (St(e, t), !0) : !1;
}
function yw({ comment: t, enclosingNode: e, followingNode: r }) {
  if (wh(t) && (e == null ? void 0 : e.type) === "TSMappedType" && (r == null ? void 0 : r.type) === "TSTypeParameter" && r.constraint)
    return e.prettierIgnore = !0, t.unignore = !0, !0;
}
function $6({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n }) {
  return (r == null ? void 0 : r.type) !== "TSMappedType" ? !1 : (n == null ? void 0 : n.type) === "TSTypeParameter" && n.name ? (er(n.name, t), !0) : (e == null ? void 0 : e.type) === "TSTypeParameter" && e.constraint ? (St(e.constraint, t), !0) : !1;
}
function B6({ comment: t, enclosingNode: e, followingNode: r }) {
  return !e || e.type !== "SwitchCase" || e.test || !r || r !== e.consequent[0] ? !1 : (r.type === "BlockStatement" && Wp(t) ? ba(r, t) : Jr(e, t), !0);
}
function I6({ comment: t, precedingNode: e, enclosingNode: r, followingNode: n }) {
  return Ks(e) && ((r.type === "TSArrayType" || r.type === "ArrayTypeAnnotation") && !n || ew(r)) ? (St(ze(!1, e.types, -1), t), !0) : !1;
}
function N6({ comment: t, enclosingNode: e, precedingNode: r, followingNode: n }) {
  if (((e == null ? void 0 : e.type) === "ObjectPattern" || (e == null ? void 0 : e.type) === "ArrayPattern") && (n == null ? void 0 : n.type) === "TSTypeAnnotation")
    return r ? St(r, t) : Jr(e, t), !0;
}
var Ow = tt(["ArrowFunctionExpression", "FunctionExpression", "FunctionDeclaration", "ObjectMethod", "ClassMethod", "TSDeclareFunction", "TSCallSignatureDeclaration", "TSConstructSignatureDeclaration", "TSMethodSignature", "TSConstructorType", "TSFunctionType", "TSDeclareMethod"]), _6 = /* @__PURE__ */ new Set(["EmptyStatement", "TemplateElement", "Import", "TSEmptyBodyFunctionExpression", "ChainExpression"]);
function Q6(t) {
  return !_6.has(t.type);
}
function M6(t, e) {
  var r;
  if ((e.parser === "typescript" || e.parser === "flow" || e.parser === "acorn" || e.parser === "espree" || e.parser === "meriyah" || e.parser === "__babel_estree") && t.type === "MethodDefinition" && ((r = t.value) == null ? void 0 : r.type) === "FunctionExpression" && cr(t.value).length === 0 && !t.value.returnType && !Ve(t.value.typeParameters) && t.value.body)
    return [...t.decorators || [], t.key, t.value.body];
}
function xw(t) {
  let { node: e, parent: r } = t;
  return (Lt(e) || r && (r.type === "JSXSpreadAttribute" || r.type === "JSXSpreadChild" || Ks(r) || (r.type === "ClassDeclaration" || r.type === "ClassExpression") && r.superClass === e)) && (!Yp(e) || Ks(r));
}
function L6(t, { parser: e }) {
  if (e === "flow" || e === "babel-flow")
    return t = Yr(!1, t, /[\s(]/g, ""), t === "" || t === "/*" || t === "/*::";
}
function R6(t) {
  switch (t) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
var wr = Symbol("MODE_BREAK"), Vn = Symbol("MODE_FLAT"), El = Symbol("cursor");
function bw() {
  return { value: "", length: 0, queue: [] };
}
function j6(t, e) {
  return pm(t, { type: "indent" }, e);
}
function Z6(t, e, r) {
  return e === Number.NEGATIVE_INFINITY ? t.root || bw() : e < 0 ? pm(t, { type: "dedent" }, r) : e ? e.type === "root" ? { ...t, root: t } : pm(t, { type: typeof e == "string" ? "stringAlign" : "numberAlign", n: e }, r) : t;
}
function pm(t, e, r) {
  let n = e.type === "dedent" ? t.queue.slice(0, -1) : [...t.queue, e], i = "", s = 0, a = 0, o = 0;
  for (let O of n)
    switch (O.type) {
      case "indent":
        h(), r.useTabs ? u(1) : c(r.tabWidth);
        break;
      case "stringAlign":
        h(), i += O.n, s += O.n.length;
        break;
      case "numberAlign":
        a += 1, o += O.n;
        break;
      default:
        throw new Error(`Unexpected type '${O.type}'`);
    }
  return m(), { ...t, value: i, length: s, queue: n };
  function u(O) {
    i += "	".repeat(O), s += r.tabWidth * O;
  }
  function c(O) {
    i += " ".repeat(O), s += O;
  }
  function h() {
    r.useTabs ? p() : m();
  }
  function p() {
    a > 0 && u(a), g();
  }
  function m() {
    o > 0 && c(o), g();
  }
  function g() {
    a = 0, o = 0;
  }
}
function dm(t) {
  let e = 0, r = 0, n = t.length;
  e:
    for (; n--; ) {
      let i = t[n];
      if (i === El) {
        r++;
        continue;
      }
      for (let s = i.length - 1; s >= 0; s--) {
        let a = i[s];
        if (a === " " || a === "	")
          e++;
        else {
          t[n] = i.slice(0, s + 1);
          break e;
        }
      }
    }
  if (e > 0 || r > 0)
    for (t.length = n + 1; r-- > 0; )
      t.push(El);
  return e;
}
function gc(t, e, r, n, i, s) {
  if (r === Number.POSITIVE_INFINITY)
    return !0;
  let a = e.length, o = [t], u = [];
  for (; r >= 0; ) {
    if (o.length === 0) {
      if (a === 0)
        return !0;
      o.push(e[--a]);
      continue;
    }
    let { mode: c, doc: h } = o.pop();
    switch (Po(h)) {
      case Ao:
        u.push(h), r -= oo(h);
        break;
      case ea:
      case oi: {
        let p = ow(h);
        for (let m = p.length - 1; m >= 0; m--)
          o.push({ mode: c, doc: p[m] });
        break;
      }
      case ma:
      case ga:
      case ya:
      case As:
        o.push({ mode: c, doc: h.contents });
        break;
      case ko:
        r += dm(u);
        break;
      case yn: {
        if (s && h.break)
          return !1;
        let p = h.break ? wr : c, m = h.expandedStates && p === wr ? ze(!1, h.expandedStates, -1) : h.contents;
        o.push({ mode: p, doc: m });
        break;
      }
      case ti: {
        let p = (h.groupId ? i[h.groupId] || Vn : c) === wr ? h.breakContents : h.flatContents;
        p && o.push({ mode: c, doc: p });
        break;
      }
      case en:
        if (c === wr || h.hard)
          return !0;
        h.soft || (u.push(" "), r--);
        break;
      case Oa:
        n = !0;
        break;
      case xa:
        if (n)
          return !1;
        break;
    }
  }
  return !1;
}
function fm(t, e) {
  let r = {}, n = e.printWidth, i = R6(e.endOfLine), s = 0, a = [{ ind: bw(), mode: wr, doc: t }], o = [], u = !1, c = [], h = 0;
  for (z4(t); a.length > 0; ) {
    let { ind: m, mode: g, doc: O } = a.pop();
    switch (Po(O)) {
      case Ao: {
        let b = i !== `
` ? Yr(!1, O, `
`, i) : O;
        o.push(b), a.length > 0 && (s += oo(b));
        break;
      }
      case ea:
        for (let b = O.length - 1; b >= 0; b--)
          a.push({ ind: m, mode: g, doc: O[b] });
        break;
      case To:
        if (h >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        o.push(El), h++;
        break;
      case ma:
        a.push({ ind: j6(m, e), mode: g, doc: O.contents });
        break;
      case ga:
        a.push({ ind: Z6(m, O.n, e), mode: g, doc: O.contents });
        break;
      case ko:
        s -= dm(o);
        break;
      case yn:
        switch (g) {
          case Vn:
            if (!u) {
              a.push({ ind: m, mode: O.break ? wr : Vn, doc: O.contents });
              break;
            }
          case wr: {
            u = !1;
            let b = { ind: m, mode: Vn, doc: O.contents }, D = n - s, S = c.length > 0;
            if (!O.break && gc(b, a, D, S, r))
              a.push(b);
            else if (O.expandedStates) {
              let x = ze(!1, O.expandedStates, -1);
              if (O.break) {
                a.push({ ind: m, mode: wr, doc: x });
                break;
              } else
                for (let w = 1; w < O.expandedStates.length + 1; w++)
                  if (w >= O.expandedStates.length) {
                    a.push({ ind: m, mode: wr, doc: x });
                    break;
                  } else {
                    let T = O.expandedStates[w], C = { ind: m, mode: Vn, doc: T };
                    if (gc(C, a, D, S, r)) {
                      a.push(C);
                      break;
                    }
                  }
            } else
              a.push({ ind: m, mode: wr, doc: O.contents });
            break;
          }
        }
        O.id && (r[O.id] = ze(!1, a, -1).mode);
        break;
      case oi: {
        let b = n - s, { parts: D } = O;
        if (D.length === 0)
          break;
        let [S, x] = D, w = { ind: m, mode: Vn, doc: S }, T = { ind: m, mode: wr, doc: S }, C = gc(w, [], b, c.length > 0, r, !0);
        if (D.length === 1) {
          C ? a.push(w) : a.push(T);
          break;
        }
        let A = { ind: m, mode: Vn, doc: x }, P = { ind: m, mode: wr, doc: x };
        if (D.length === 2) {
          C ? a.push(A, w) : a.push(P, T);
          break;
        }
        D.splice(0, 2);
        let $ = { ind: m, mode: g, doc: qy(D) }, B = D[0];
        gc({ ind: m, mode: Vn, doc: [S, x, B] }, [], b, c.length > 0, r, !0) ? a.push($, A, w) : C ? a.push($, P, w) : a.push($, P, T);
        break;
      }
      case ti:
      case ya: {
        let b = O.groupId ? r[O.groupId] : g;
        if (b === wr) {
          let D = O.type === ti ? O.breakContents : O.negate ? O.contents : te(O.contents);
          D && a.push({ ind: m, mode: g, doc: D });
        }
        if (b === Vn) {
          let D = O.type === ti ? O.flatContents : O.negate ? te(O.contents) : O.contents;
          D && a.push({ ind: m, mode: g, doc: D });
        }
        break;
      }
      case Oa:
        c.push({ ind: m, mode: g, doc: O.contents });
        break;
      case xa:
        c.length > 0 && a.push({ ind: m, mode: g, doc: sw });
        break;
      case en:
        switch (g) {
          case Vn:
            if (O.hard)
              u = !0;
            else {
              O.soft || (o.push(" "), s += 1);
              break;
            }
          case wr:
            if (c.length > 0) {
              a.push({ ind: m, mode: g, doc: O }, ...c.reverse()), c.length = 0;
              break;
            }
            O.literal ? m.root ? (o.push(i, m.root.value), s = m.root.length) : (o.push(i), s = 0) : (s -= dm(o), o.push(i + m.value), s = m.length);
            break;
        }
        break;
      case As:
        a.push({ ind: m, mode: g, doc: O.contents });
        break;
      case Ts:
        break;
      default:
        throw new Xl(O);
    }
    a.length === 0 && c.length > 0 && (a.push(...c.reverse()), c.length = 0);
  }
  let p = o.indexOf(El);
  if (p !== -1) {
    let m = o.indexOf(El, p + 1), g = o.slice(0, p).join(""), O = o.slice(p + 1, m).join(""), b = o.slice(m + 1).join("");
    return { formatted: g + O + b, cursorNodeStart: g.length, cursorNodeText: O };
  }
  return { formatted: o.join("") };
}
function W6(t, e, r = 0) {
  let n = 0;
  for (let i = r; i < t.length; ++i)
    t[i] === "	" ? n = n + e - n % e : n++;
  return n;
}
var q6 = W6;
function X6(t, e) {
  let r = t.lastIndexOf(`
`);
  return r === -1 ? 0 : q6(t.slice(r + 1).match(/^[\t ]*/)[0], e);
}
var V6 = X6;
function Dw(t, e, r) {
  let { node: n } = t;
  if (n.type === "TemplateLiteral" && G6(t)) {
    let c = U6(t, r, e);
    if (c)
      return c;
  }
  let i = "expressions";
  n.type === "TSTemplateLiteralType" && (i = "types");
  let s = [], a = t.map(e, i), o = A4(n);
  o && (a = a.map((c) => fm(c, { ...r, printWidth: Number.POSITIVE_INFINITY }).formatted)), s.push(Ci, "`");
  let u = 0;
  return t.each(({ index: c, node: h }) => {
    if (s.push(e()), h.tail)
      return;
    let { tabWidth: p } = r, m = h.value.raw, g = m.includes(`
`) ? V6(m, p) : u;
    u = g;
    let O = a[c];
    if (!o) {
      let D = n[i][c], S = gs(r.originalText, Ye(h), mt(n.quasis[c + 1]));
      if (!S) {
        let x = fm(O, { ...r, printWidth: Number.POSITIVE_INFINITY }).formatted;
        x.includes(`
`) ? S = !0 : O = x;
      }
      S && (ae(D) || ft(D) || D.type === "ConditionalExpression" || D.type === "SequenceExpression" || Hn(D) || wi(D)) && (O = [te([K, O]), K]);
    }
    let b = g === 0 && m.endsWith(`
`) ? li(Number.NEGATIVE_INFINITY, O) : Y4(O, g, p);
    s.push(Z(["${", b, Ci, "}"]));
  }, "quasis"), s.push("`"), s;
}
function Y6(t) {
  let e = t("quasi");
  return Tu(e.label && { tagged: !0, ...e.label }, [t("tag"), t("typeParameters"), Ci, e]);
}
function U6(t, e, r) {
  let { node: n } = t, i = n.quasis[0].value.raw.trim().split(/\s*\|\s*/);
  if (i.length > 1 || i.some((s) => s.length > 0)) {
    e.__inJestEach = !0;
    let s = t.map(r, "expressions");
    e.__inJestEach = !1;
    let a = [], o = s.map((m) => "${" + fm(m, { ...e, printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" }).formatted + "}"), u = [{ hasLineBreak: !1, cells: [] }];
    for (let m = 1; m < n.quasis.length; m++) {
      let g = ze(!1, u, -1), O = o[m - 1];
      g.cells.push(O), O.includes(`
`) && (g.hasLineBreak = !0), n.quasis[m].value.raw.includes(`
`) && u.push({ hasLineBreak: !1, cells: [] });
    }
    let c = Math.max(i.length, ...u.map((m) => m.cells.length)), h = Array.from({ length: c }).fill(0), p = [{ cells: i }, ...u.filter((m) => m.cells.length > 0)];
    for (let { cells: m } of p.filter((g) => !g.hasLineBreak))
      for (let [g, O] of m.entries())
        h[g] = Math.max(h[g], oo(O));
    return a.push(Ci, "`", te([ee, Re(ee, p.map((m) => Re(" | ", m.cells.map((g, O) => m.hasLineBreak ? g : g + " ".repeat(h[O] - oo(g))))))]), ee, "`"), a;
  }
}
function z6(t, e) {
  let { node: r } = t, n = e();
  return ae(r) && (n = Z([te([K, n]), K])), ["${", n, Ci, "}"];
}
function Hy(t, e) {
  return t.map((r) => z6(r, e), "expressions");
}
function vw(t, e) {
  return Fo(t, (r) => typeof r == "string" ? e ? Yr(!1, r, /(\\*)`/g, "$1$1\\`") : Sw(r) : r);
}
function Sw(t) {
  return Yr(!1, t, /([\\`]|\${)/g, "\\$1");
}
function G6({ node: t, parent: e }) {
  let r = /^[fx]?(?:describe|it|test)$/;
  return e.type === "TaggedTemplateExpression" && e.quasi === t && e.tag.type === "MemberExpression" && e.tag.property.type === "Identifier" && e.tag.property.name === "each" && (e.tag.object.type === "Identifier" && r.test(e.tag.object.name) || e.tag.object.type === "MemberExpression" && e.tag.object.property.type === "Identifier" && (e.tag.object.property.name === "only" || e.tag.object.property.name === "skip") && e.tag.object.object.type === "Identifier" && r.test(e.tag.object.object.name));
}
var mm = [(t, e) => t.type === "ObjectExpression" && e === "properties", (t, e) => t.type === "CallExpression" && t.callee.type === "Identifier" && t.callee.name === "Component" && e === "arguments", (t, e) => t.type === "Decorator" && e === "expression"];
function H6(t) {
  let e = (n) => n.type === "TemplateLiteral", r = (n, i) => Mi(n) && !n.computed && n.key.type === "Identifier" && n.key.name === "styles" && i === "value";
  return t.match(e, (n, i) => Kt(n) && i === "elements", r, ...mm) || t.match(e, r, ...mm);
}
function J6(t) {
  return t.match((e) => e.type === "TemplateLiteral", (e, r) => Mi(e) && !e.computed && e.key.type === "Identifier" && e.key.name === "template" && r === "value", ...mm);
}
function R1(t, e) {
  return ae(t, fe.Block | fe.Leading, ({ value: r }) => r === ` ${e} `);
}
function ww({ node: t, parent: e }, r) {
  return R1(t, r) || K6(e) && R1(e, r);
}
function K6(t) {
  return t.type === "AsConstExpression" || t.type === "TSAsExpression" && t.typeAnnotation.type === "TSTypeReference" && t.typeAnnotation.typeName.type === "Identifier" && t.typeAnnotation.typeName.name === "const";
}
async function eM(t, e, r) {
  let { node: n } = r, i = n.quasis.map((h) => h.value.raw), s = 0, a = i.reduce((h, p, m) => m === 0 ? p : h + "@prettier-placeholder-" + s++ + "-id" + p, ""), o = await t(a, { parser: "scss" }), u = Hy(r, e), c = tM(o, u);
  if (!c)
    throw new Error("Couldn't insert all the expressions");
  return ["`", te([ee, c]), K, "`"];
}
function tM(t, e) {
  if (!Ve(e))
    return t;
  let r = 0, n = Fo(Xy(t), (i) => typeof i != "string" || !i.includes("@prettier-placeholder") ? i : i.split(/@prettier-placeholder-(\d+)-id/).map((s, a) => a % 2 === 0 ? ta(s) : (r++, e[s])));
  return e.length === r ? n : null;
}
function rM({ node: t, parent: e, grandparent: r }) {
  return r && t.quasis && e.type === "JSXExpressionContainer" && r.type === "JSXElement" && r.openingElement.name.name === "style" && r.openingElement.attributes.some((n) => n.type === "JSXAttribute" && n.name.name === "jsx") || (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && e.tag.type === "Identifier" && e.tag.name === "css" || (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && e.tag.type === "MemberExpression" && e.tag.object.name === "css" && (e.tag.property.name === "global" || e.tag.property.name === "resolve");
}
function yc(t) {
  return t.type === "Identifier" && t.name === "styled";
}
function j1(t) {
  return /^[A-Z]/.test(t.object.name) && t.property.name === "extend";
}
function nM({ parent: t }) {
  if (!t || t.type !== "TaggedTemplateExpression")
    return !1;
  let e = t.tag.type === "ParenthesizedExpression" ? t.tag.expression : t.tag;
  switch (e.type) {
    case "MemberExpression":
      return yc(e.object) || j1(e);
    case "CallExpression":
      return yc(e.callee) || e.callee.type === "MemberExpression" && (e.callee.object.type === "MemberExpression" && (yc(e.callee.object.object) || j1(e.callee.object)) || e.callee.object.type === "CallExpression" && yc(e.callee.object.callee));
    case "Identifier":
      return e.name === "css";
    default:
      return !1;
  }
}
function iM({ parent: t, grandparent: e }) {
  return (e == null ? void 0 : e.type) === "JSXAttribute" && t.type === "JSXExpressionContainer" && e.name.type === "JSXIdentifier" && e.name.name === "css";
}
function sM(t) {
  if (rM(t) || nM(t) || iM(t) || H6(t))
    return eM;
}
var aM = sM;
async function oM(t, e, r) {
  let { node: n } = r, i = n.quasis.length, s = Hy(r, e), a = [];
  for (let o = 0; o < i; o++) {
    let u = n.quasis[o], c = o === 0, h = o === i - 1, p = u.value.cooked, m = p.split(`
`), g = m.length, O = s[o], b = g > 2 && m[0].trim() === "" && m[1].trim() === "", D = g > 2 && m[g - 1].trim() === "" && m[g - 2].trim() === "", S = m.every((w) => /^\s*(?:#[^\n\r]*)?$/.test(w));
    if (!h && /#[^\n\r]*$/.test(m[g - 1]))
      return null;
    let x = null;
    S ? x = lM(m) : x = await t(p, { parser: "graphql" }), x ? (x = vw(x, !1), !c && b && a.push(""), a.push(x), !h && D && a.push("")) : !c && !h && b && a.push(""), O && a.push(O);
  }
  return ["`", te([ee, Re(ee, a)]), ee, "`"];
}
function lM(t) {
  let e = [], r = !1, n = t.map((i) => i.trim());
  for (let [i, s] of n.entries())
    s !== "" && (n[i - 1] === "" && r ? e.push([ee, s]) : e.push(s), r = !0);
  return e.length === 0 ? null : Re(ee, e);
}
function uM({ node: t, parent: e }) {
  return ww({ node: t, parent: e }, "GraphQL") || e && (e.type === "TaggedTemplateExpression" && (e.tag.type === "MemberExpression" && e.tag.object.name === "graphql" && e.tag.property.name === "experimental" || e.tag.type === "Identifier" && (e.tag.name === "gql" || e.tag.name === "graphql")) || e.type === "CallExpression" && e.callee.type === "Identifier" && e.callee.name === "graphql");
}
function cM(t) {
  if (uM(t))
    return oM;
}
var hM = cM, Vd = 0;
async function Cw(t, e, r, n, i) {
  let { node: s } = n, a = Vd;
  Vd = Vd + 1 >>> 0;
  let o = (S) => `PRETTIER_HTML_PLACEHOLDER_${S}_${a}_IN_JS`, u = s.quasis.map((S, x, w) => x === w.length - 1 ? S.value.cooked : S.value.cooked + o(x)).join(""), c = Hy(n, r), h = new RegExp(o("(\\d+)"), "g"), p = 0, m = await e(u, { parser: t, __onHtmlRoot(S) {
    p = S.children.length;
  } }), g = Fo(m, (S) => {
    if (typeof S != "string")
      return S;
    let x = [], w = S.split(h);
    for (let T = 0; T < w.length; T++) {
      let C = w[T];
      if (T % 2 === 0) {
        C && (C = Sw(C), i.__embeddedInHtml && (C = Yr(!1, C, /<\/(?=script\b)/gi, "<\\/")), x.push(C));
        continue;
      }
      let A = Number(C);
      x.push(c[A]);
    }
    return x;
  }), O = /^\s/.test(u) ? " " : "", b = /\s$/.test(u) ? " " : "", D = i.htmlWhitespaceSensitivity === "ignore" ? ee : O && b ? de : null;
  return D ? Z(["`", te([D, Z(g)]), D, "`"]) : Tu({ hug: !1 }, Z(["`", O, p > 1 ? te(Z(g)) : Z(g), b, "`"]));
}
function pM(t) {
  return ww(t, "HTML") || t.match((e) => e.type === "TemplateLiteral", (e, r) => e.type === "TaggedTemplateExpression" && e.tag.type === "Identifier" && e.tag.name === "html" && r === "quasi");
}
var dM = Cw.bind(void 0, "html"), fM = Cw.bind(void 0, "angular");
function mM(t) {
  if (pM(t))
    return dM;
  if (J6(t))
    return fM;
}
var gM = mM;
async function yM(t, e, r) {
  let { node: n } = r, i = Yr(!1, n.quasis[0].value.raw, /((?:\\\\)*)\\`/g, (u, c) => "\\".repeat(c.length / 2) + "`"), s = OM(i), a = s !== "";
  a && (i = Yr(!1, i, new RegExp(`^${s}`, "gm"), ""));
  let o = vw(await t(i, { parser: "markdown", __inJsTemplate: !0 }), !0);
  return ["`", a ? te([K, o]) : [aw, X4(o)], K, "`"];
}
function OM(t) {
  let e = t.match(/^([^\S\n]*)\S/m);
  return e === null ? "" : e[1];
}
function xM(t) {
  if (bM(t))
    return yM;
}
function bM({ node: t, parent: e }) {
  return (e == null ? void 0 : e.type) === "TaggedTemplateExpression" && t.quasis.length === 1 && e.tag.type === "Identifier" && (e.tag.name === "md" || e.tag.name === "markdown");
}
var DM = xM;
function vM(t) {
  let { node: e } = t;
  if (e.type !== "TemplateLiteral" || SM(e))
    return;
  let r;
  for (let n of [aM, hM, gM, DM])
    if (r = n(t), !!r)
      return e.quasis.length === 1 && e.quasis[0].value.raw.trim() === "" ? "``" : async (...i) => {
        let s = await r(...i);
        return s && Tu({ embed: !0, ...s.label }, s);
      };
}
function SM({ quasis: t }) {
  return t.some(({ value: { cooked: e } }) => e === null);
}
var wM = vM, Ch = E9(k9(), 1);
function CM(t) {
  if (!t.startsWith("#!"))
    return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var EM = CM;
function AM(t) {
  let e = EM(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, Ch.extract)(t), { pragmas: n, comments: i } = (0, Ch.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: n, comments: i };
}
function TM(t) {
  let { shebang: e, text: r, pragmas: n, comments: i } = AM(t), s = (0, Ch.strip)(r), a = (0, Ch.print)({ pragmas: { format: "", ...n }, comments: i.trimStart() });
  return (e ? `${e}
` : "") + a + (s.startsWith(`
`) ? `
` : `

`) + s;
}
function kM(t, e) {
  let { originalText: r, [Symbol.for("comments")]: n, locStart: i, locEnd: s, [Symbol.for("printedComments")]: a } = e, { node: o } = t, u = i(o), c = s(o);
  for (let h of n)
    i(h) >= u && s(h) <= c && a.add(h);
  return r.slice(u, c);
}
var PM = kM;
function gm(t, e) {
  var r, n, i, s, a, o, u;
  if (t.isRoot)
    return !1;
  let { node: c, key: h, parent: p } = t;
  if (e.__isInHtmlInterpolation && !e.bracketSpacing && IM(c) && hl(t))
    return !0;
  if (FM(c))
    return !1;
  if (c.type === "Identifier") {
    if ((r = c.extra) != null && r.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(c.name) || h === "left" && (c.name === "async" && !p.await || c.name === "let") && p.type === "ForOfStatement")
      return !0;
    if (c.name === "let") {
      let m = (n = t.findAncestor((g) => g.type === "ForOfStatement")) == null ? void 0 : n.left;
      if (m && fr(m, (g) => g === c))
        return !0;
    }
    if (h === "object" && c.name === "let" && p.type === "MemberExpression" && p.computed && !p.optional) {
      let m = t.findAncestor((O) => O.type === "ExpressionStatement" || O.type === "ForStatement" || O.type === "ForInStatement"), g = m ? m.type === "ExpressionStatement" ? m.expression : m.type === "ForStatement" ? m.init : m.left : void 0;
      if (g && fr(g, (O) => O === c))
        return !0;
    }
    if (h === "expression")
      switch (c.name) {
        case "await":
        case "interface":
        case "module":
        case "using":
        case "yield":
        case "let":
        case "type": {
          let m = t.findAncestor((g) => !Hn(g));
          if (m !== p && m.type === "ExpressionStatement")
            return !0;
        }
      }
    return !1;
  }
  if (c.type === "ObjectExpression" || c.type === "FunctionExpression" || c.type === "ClassExpression" || c.type === "DoExpression") {
    let m = (i = t.findAncestor((g) => g.type === "ExpressionStatement")) == null ? void 0 : i.expression;
    if (m && fr(m, (g) => g === c))
      return !0;
  }
  if (c.type === "ObjectExpression") {
    let m = (s = t.findAncestor((g) => g.type === "ArrowFunctionExpression")) == null ? void 0 : s.body;
    if (m && m.type !== "SequenceExpression" && m.type !== "AssignmentExpression" && fr(m, (g) => g === c))
      return !0;
  }
  switch (p.type) {
    case "ParenthesizedExpression":
      return !1;
    case "ClassDeclaration":
    case "ClassExpression":
      if (h === "superClass" && (c.type === "ArrowFunctionExpression" || c.type === "AssignmentExpression" || c.type === "AwaitExpression" || c.type === "BinaryExpression" || c.type === "ConditionalExpression" || c.type === "LogicalExpression" || c.type === "NewExpression" || c.type === "ObjectExpression" || c.type === "SequenceExpression" || c.type === "TaggedTemplateExpression" || c.type === "UnaryExpression" || c.type === "UpdateExpression" || c.type === "YieldExpression" || c.type === "TSNonNullExpression" || c.type === "ClassExpression" && Ve(c.decorators)))
        return !0;
      break;
    case "ExportDefaultDeclaration":
      return Ew(t, e) || c.type === "SequenceExpression";
    case "Decorator":
      if (h === "expression") {
        if (ft(c) && c.computed)
          return !0;
        let m = !1, g = !1, O = c;
        for (; O; )
          switch (O.type) {
            case "MemberExpression":
              g = !0, O = O.object;
              break;
            case "CallExpression":
              if (g || m)
                return e.parser !== "typescript";
              m = !0, O = O.callee;
              break;
            case "Identifier":
              return !1;
            case "TaggedTemplateExpression":
              return e.parser !== "typescript";
            default:
              return !0;
          }
        return !0;
      }
      break;
    case "TypeAnnotation":
      if (t.match(void 0, void 0, (m, g) => g === "returnType" && m.type === "ArrowFunctionExpression") && BM(c))
        return !0;
      break;
    case "BinaryExpression":
      if (h === "left" && (p.operator === "in" || p.operator === "instanceof") && c.type === "UnaryExpression")
        return !0;
      break;
  }
  switch (c.type) {
    case "UpdateExpression":
      if (p.type === "UnaryExpression")
        return c.prefix && (c.operator === "++" && p.operator === "+" || c.operator === "--" && p.operator === "-");
    case "UnaryExpression":
      switch (p.type) {
        case "UnaryExpression":
          return c.operator === p.operator && (c.operator === "+" || c.operator === "-");
        case "BindExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return h === "object";
        case "TaggedTemplateExpression":
          return !0;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return h === "callee";
        case "BinaryExpression":
          return h === "left" && p.operator === "**";
        case "TSNonNullExpression":
          return !0;
        default:
          return !1;
      }
    case "BinaryExpression":
      if (p.type === "UpdateExpression" || c.operator === "in" && $M(t))
        return !0;
      if (c.operator === "|>" && (a = c.extra) != null && a.parenthesized) {
        let m = t.grandparent;
        if (m.type === "BinaryExpression" && m.operator === "|>")
          return !0;
      }
    case "TSTypeAssertion":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
    case "LogicalExpression":
      switch (p.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
          return !Hn(c);
        case "ConditionalExpression":
          return Hn(c);
        case "CallExpression":
        case "NewExpression":
        case "OptionalCallExpression":
          return h === "callee";
        case "ClassExpression":
        case "ClassDeclaration":
          return h === "superClass";
        case "TSTypeAssertion":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "JSXSpreadAttribute":
        case "SpreadElement":
        case "BindExpression":
        case "AwaitExpression":
        case "TSNonNullExpression":
        case "UpdateExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return h === "object";
        case "AssignmentExpression":
        case "AssignmentPattern":
          return h === "left" && (c.type === "TSTypeAssertion" || Hn(c));
        case "LogicalExpression":
          if (c.type === "LogicalExpression")
            return p.operator !== c.operator;
        case "BinaryExpression": {
          let { operator: m, type: g } = c;
          if (!m && g !== "TSTypeAssertion")
            return !0;
          let O = Sh(m), b = p.operator, D = Sh(b);
          return D > O || h === "right" && D === O || D === O && !Zy(b, m) ? !0 : D < O && m === "%" ? b === "+" || b === "-" : !!B4(b);
        }
        default:
          return !1;
      }
    case "SequenceExpression":
      switch (p.type) {
        case "ReturnStatement":
          return !1;
        case "ForStatement":
          return !1;
        case "ExpressionStatement":
          return h !== "expression";
        case "ArrowFunctionExpression":
          return h !== "body";
        default:
          return !0;
      }
    case "YieldExpression":
      if (p.type === "AwaitExpression")
        return !0;
    case "AwaitExpression":
      switch (p.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "SpreadElement":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "BindExpression":
          return !0;
        case "MemberExpression":
        case "OptionalMemberExpression":
          return h === "object";
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return h === "callee";
        case "ConditionalExpression":
          return h === "test";
        case "BinaryExpression":
          return !(!c.argument && p.operator === "|>");
        default:
          return !1;
      }
    case "TSFunctionType":
      if (t.match((m) => m.type === "TSFunctionType", (m, g) => g === "typeAnnotation" && m.type === "TSTypeAnnotation", (m, g) => g === "returnType" && m.type === "ArrowFunctionExpression"))
        return !0;
    case "TSConditionalType":
    case "TSConstructorType":
      if (h === "extendsType" && p.type === "TSConditionalType") {
        if (c.type === "TSConditionalType")
          return !0;
        let { typeAnnotation: m } = c.returnType || c.typeAnnotation;
        if (m.type === "TSTypePredicate" && m.typeAnnotation && (m = m.typeAnnotation.typeAnnotation), m.type === "TSInferType" && m.typeParameter.constraint)
          return !0;
      }
      if (h === "checkType" && p.type === "TSConditionalType")
        return !0;
    case "TSUnionType":
    case "TSIntersectionType":
      if ((p.type === "TSUnionType" || p.type === "TSIntersectionType") && p.types.length > 1 && (!c.types || c.types.length > 1))
        return !0;
    case "TSInferType":
      if (c.type === "TSInferType" && p.type === "TSRestType")
        return !1;
    case "TSTypeOperator":
      return p.type === "TSArrayType" || p.type === "TSOptionalType" || p.type === "TSRestType" || h === "objectType" && p.type === "TSIndexedAccessType" || p.type === "TSTypeOperator" || p.type === "TSTypeAnnotation" && t.grandparent.type.startsWith("TSJSDoc");
    case "TSTypeQuery":
      return h === "objectType" && p.type === "TSIndexedAccessType" || h === "elementType" && p.type === "TSArrayType";
    case "TypeofTypeAnnotation":
      return h === "objectType" && (p.type === "IndexedAccessType" || p.type === "OptionalIndexedAccessType") || h === "elementType" && p.type === "ArrayTypeAnnotation";
    case "ArrayTypeAnnotation":
      return p.type === "NullableTypeAnnotation";
    case "IntersectionTypeAnnotation":
    case "UnionTypeAnnotation":
      return p.type === "ArrayTypeAnnotation" || p.type === "NullableTypeAnnotation" || p.type === "IntersectionTypeAnnotation" || p.type === "UnionTypeAnnotation" || h === "objectType" && (p.type === "IndexedAccessType" || p.type === "OptionalIndexedAccessType");
    case "InferTypeAnnotation":
    case "NullableTypeAnnotation":
      return p.type === "ArrayTypeAnnotation" || h === "objectType" && (p.type === "IndexedAccessType" || p.type === "OptionalIndexedAccessType");
    case "FunctionTypeAnnotation": {
      if (t.match(void 0, (g, O) => O === "typeAnnotation" && g.type === "TypeAnnotation", (g, O) => O === "returnType" && g.type === "ArrowFunctionExpression") || t.match(void 0, (g, O) => O === "typeAnnotation" && g.type === "TypePredicate", (g, O) => O === "typeAnnotation" && g.type === "TypeAnnotation", (g, O) => O === "returnType" && g.type === "ArrowFunctionExpression"))
        return !0;
      let m = p.type === "NullableTypeAnnotation" ? t.grandparent : p;
      return m.type === "UnionTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "ArrayTypeAnnotation" || h === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType") || h === "checkType" && p.type === "ConditionalTypeAnnotation" || h === "extendsType" && p.type === "ConditionalTypeAnnotation" && c.returnType.type === "InferTypeAnnotation" && c.returnType.typeParameter.bound || m.type === "NullableTypeAnnotation" || p.type === "FunctionTypeParam" && p.name === null && cr(c).some((g) => {
        var O;
        return ((O = g.typeAnnotation) == null ? void 0 : O.type) === "NullableTypeAnnotation";
      });
    }
    case "ConditionalTypeAnnotation":
      if (h === "extendsType" && p.type === "ConditionalTypeAnnotation" && c.type === "ConditionalTypeAnnotation" || h === "checkType" && p.type === "ConditionalTypeAnnotation")
        return !0;
    case "OptionalIndexedAccessType":
      return h === "objectType" && p.type === "IndexedAccessType";
    case "StringLiteral":
    case "NumericLiteral":
    case "Literal":
      if (typeof c.value == "string" && p.type === "ExpressionStatement" && !p.directive) {
        let m = t.grandparent;
        return m.type === "Program" || m.type === "BlockStatement";
      }
      return h === "object" && p.type === "MemberExpression" && typeof c.value == "number";
    case "AssignmentExpression": {
      let m = t.grandparent;
      return h === "body" && p.type === "ArrowFunctionExpression" ? !0 : h === "key" && (p.type === "ClassProperty" || p.type === "PropertyDefinition") && p.computed || (h === "init" || h === "update") && p.type === "ForStatement" ? !1 : p.type === "ExpressionStatement" ? c.left.type === "ObjectPattern" : !(h === "key" && p.type === "TSPropertySignature" || p.type === "AssignmentExpression" || p.type === "SequenceExpression" && m.type === "ForStatement" && (m.init === p || m.update === p) || h === "value" && p.type === "Property" && m.type === "ObjectPattern" && m.properties.includes(p) || p.type === "NGChainedExpression");
    }
    case "ConditionalExpression":
      switch (p.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "BinaryExpression":
        case "LogicalExpression":
        case "NGPipeExpression":
        case "ExportDefaultDeclaration":
        case "AwaitExpression":
        case "JSXSpreadAttribute":
        case "TSTypeAssertion":
        case "TypeCastExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "TSNonNullExpression":
          return !0;
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return h === "callee";
        case "ConditionalExpression":
          return e.experimentalTernaries ? !1 : h === "test";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return h === "object";
        default:
          return !1;
      }
    case "FunctionExpression":
      switch (p.type) {
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return h === "callee";
        case "TaggedTemplateExpression":
          return !0;
        default:
          return !1;
      }
    case "ArrowFunctionExpression":
      switch (p.type) {
        case "BinaryExpression":
          return p.operator !== "|>" || ((o = c.extra) == null ? void 0 : o.parenthesized);
        case "NewExpression":
        case "CallExpression":
        case "OptionalCallExpression":
          return h === "callee";
        case "MemberExpression":
        case "OptionalMemberExpression":
          return h === "object";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "AsExpression":
        case "AsConstExpression":
        case "SatisfiesExpression":
        case "TSNonNullExpression":
        case "BindExpression":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "AwaitExpression":
        case "TSTypeAssertion":
          return !0;
        case "ConditionalExpression":
          return h === "test";
        default:
          return !1;
      }
    case "ClassExpression":
      switch (p.type) {
        case "NewExpression":
          return h === "callee";
        default:
          return !1;
      }
    case "OptionalMemberExpression":
    case "OptionalCallExpression":
    case "CallExpression":
    case "MemberExpression":
      if (NM(t))
        return !0;
    case "TaggedTemplateExpression":
    case "TSNonNullExpression":
      if (h === "callee" && (p.type === "BindExpression" || p.type === "NewExpression")) {
        let m = c;
        for (; m; )
          switch (m.type) {
            case "CallExpression":
            case "OptionalCallExpression":
              return !0;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "BindExpression":
              m = m.object;
              break;
            case "TaggedTemplateExpression":
              m = m.tag;
              break;
            case "TSNonNullExpression":
              m = m.expression;
              break;
            default:
              return !1;
          }
      }
      return !1;
    case "BindExpression":
      return h === "callee" && (p.type === "BindExpression" || p.type === "NewExpression") || h === "object" && ft(p);
    case "NGPipeExpression":
      return !(p.type === "NGRoot" || p.type === "NGMicrosyntaxExpression" || p.type === "ObjectProperty" && !((u = c.extra) != null && u.parenthesized) || Kt(p) || h === "arguments" && qe(p) || h === "right" && p.type === "NGPipeExpression" || h === "property" && p.type === "MemberExpression" || p.type === "AssignmentExpression");
    case "JSXFragment":
    case "JSXElement":
      return h === "callee" || h === "left" && p.type === "BinaryExpression" && p.operator === "<" || !Kt(p) && p.type !== "ArrowFunctionExpression" && p.type !== "AssignmentExpression" && p.type !== "AssignmentPattern" && p.type !== "BinaryExpression" && p.type !== "NewExpression" && p.type !== "ConditionalExpression" && p.type !== "ExpressionStatement" && p.type !== "JsExpressionRoot" && p.type !== "JSXAttribute" && p.type !== "JSXElement" && p.type !== "JSXExpressionContainer" && p.type !== "JSXFragment" && p.type !== "LogicalExpression" && !qe(p) && !Mi(p) && p.type !== "ReturnStatement" && p.type !== "ThrowStatement" && p.type !== "TypeCastExpression" && p.type !== "VariableDeclarator" && p.type !== "YieldExpression";
    case "TSInstantiationExpression":
      return h === "object" && ft(p);
  }
  return !1;
}
var FM = tt(["BlockStatement", "BreakStatement", "ClassBody", "ClassDeclaration", "ClassMethod", "ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ContinueStatement", "DebuggerStatement", "DeclareClass", "DeclareExportAllDeclaration", "DeclareExportDeclaration", "DeclareFunction", "DeclareInterface", "DeclareModule", "DeclareModuleExports", "DeclareVariable", "DeclareEnum", "DoWhileStatement", "EnumDeclaration", "ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FunctionDeclaration", "IfStatement", "ImportDeclaration", "InterfaceDeclaration", "LabeledStatement", "MethodDefinition", "ReturnStatement", "SwitchStatement", "ThrowStatement", "TryStatement", "TSDeclareFunction", "TSEnumDeclaration", "TSImportEqualsDeclaration", "TSInterfaceDeclaration", "TSModuleDeclaration", "TSNamespaceExportDeclaration", "TypeAlias", "VariableDeclaration", "WhileStatement", "WithStatement"]);
function $M(t) {
  let e = 0, { node: r } = t;
  for (; r; ) {
    let n = t.getParentNode(e++);
    if ((n == null ? void 0 : n.type) === "ForStatement" && n.init === r)
      return !0;
    r = n;
  }
  return !1;
}
function BM(t) {
  return am(t, (e) => e.type === "ObjectTypeAnnotation" && am(e, (r) => r.type === "FunctionTypeAnnotation"));
}
function IM(t) {
  return In(t);
}
function hl(t) {
  let { parent: e, key: r } = t;
  switch (e.type) {
    case "NGPipeExpression":
      if (r === "arguments" && t.isLast)
        return t.callParent(hl);
      break;
    case "ObjectProperty":
      if (r === "value")
        return t.callParent(() => t.key === "properties" && t.isLast);
      break;
    case "BinaryExpression":
    case "LogicalExpression":
      if (r === "right")
        return t.callParent(hl);
      break;
    case "ConditionalExpression":
      if (r === "alternate")
        return t.callParent(hl);
      break;
    case "UnaryExpression":
      if (e.prefix)
        return t.callParent(hl);
      break;
  }
  return !1;
}
function Ew(t, e) {
  let { node: r, parent: n } = t;
  return r.type === "FunctionExpression" || r.type === "ClassExpression" ? n.type === "ExportDefaultDeclaration" || !gm(t, e) : !Ly(r) || n.type !== "ExportDefaultDeclaration" && gm(t, e) ? !1 : t.call(() => Ew(t, e), ...jS(r));
}
function NM(t) {
  let { node: e, parent: r, grandparent: n, key: i } = t;
  return !!((e.type === "OptionalMemberExpression" || e.type === "OptionalCallExpression") && (i === "object" && r.type === "MemberExpression" || i === "callee" && (r.type === "CallExpression" || r.type === "NewExpression") || r.type === "TSNonNullExpression" && n.type === "MemberExpression" && n.object === r) || t.match(() => e.type === "CallExpression" || e.type === "MemberExpression", (s, a) => a === "expression" && s.type === "ChainExpression") && (t.match(void 0, void 0, (s, a) => a === "callee" && (s.type === "CallExpression" && !s.optional || s.type === "NewExpression") || a === "object" && s.type === "MemberExpression" && !s.optional) || t.match(void 0, void 0, (s, a) => a === "expression" && s.type === "TSNonNullExpression", (s, a) => a === "object" && s.type === "MemberExpression")) || t.match(() => e.type === "CallExpression" || e.type === "MemberExpression", (s, a) => a === "expression" && s.type === "TSNonNullExpression", (s, a) => a === "expression" && s.type === "ChainExpression", (s, a) => a === "object" && s.type === "MemberExpression"));
}
var Da = gm;
function _M(t, e) {
  let r = e - 1;
  r = lo(t, r, { backwards: !0 }), r = uo(t, r, { backwards: !0 }), r = lo(t, r, { backwards: !0 });
  let n = uo(t, r, { backwards: !0 });
  return r !== n;
}
var QM = _M, MM = () => !0;
function Jy(t, e) {
  let r = t.node;
  return r.printed = !0, e.printer.printComment(t, e);
}
function LM(t, e) {
  var r;
  let n = t.node, i = [Jy(t, e)], { printer: s, originalText: a, locStart: o, locEnd: u } = e;
  if ((r = s.isBlockComment) != null && r.call(s, n)) {
    let h = Hr(a, u(n)) ? Hr(a, o(n), { backwards: !0 }) ? ee : de : " ";
    i.push(h);
  } else
    i.push(ee);
  let c = uo(a, lo(a, u(n)));
  return c !== !1 && Hr(a, c) && i.push(ee), i;
}
function RM(t, e, r) {
  var n;
  let i = t.node, s = Jy(t, e), { printer: a, originalText: o, locStart: u } = e, c = (n = a.isBlockComment) == null ? void 0 : n.call(a, i);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || Hr(o, u(i), { backwards: !0 })) {
    let h = QM(o, u(i));
    return { doc: Q1([ee, h ? ee : "", s]), isBlock: c, hasLineSuffix: !0 };
  }
  return !c || r != null && r.hasLineSuffix ? { doc: [Q1([" ", s]), ui], isBlock: c, hasLineSuffix: !0 } : { doc: [" ", s], isBlock: c, hasLineSuffix: !1 };
}
function yt(t, e, r = {}) {
  let { node: n } = t;
  if (!Ve(n == null ? void 0 : n.comments))
    return "";
  let { indent: i = !1, marker: s, filter: a = MM } = r, o = [];
  if (t.each(({ node: c }) => {
    c.leading || c.trailing || c.marker !== s || !a(c) || o.push(Jy(t, e));
  }, "comments"), o.length === 0)
    return "";
  let u = Re(ee, o);
  return i ? te([ee, u]) : u;
}
function Aw(t, e) {
  let r = t.node;
  if (!r)
    return {};
  let n = e[Symbol.for("printedComments")];
  if ((r.comments || []).filter((o) => !n.has(o)).length === 0)
    return { leading: "", trailing: "" };
  let i = [], s = [], a;
  return t.each(() => {
    let o = t.node;
    if (n != null && n.has(o))
      return;
    let { leading: u, trailing: c } = o;
    u ? i.push(LM(t, e)) : c && (a = RM(t, e, a), s.push(a.doc));
  }, "comments"), { leading: i, trailing: s };
}
function Bn(t, e, r) {
  let { leading: n, trailing: i } = Aw(t, r);
  return !n && !i ? e : cm(e, (s) => [n, s, i]);
}
var jM = class extends Error {
  constructor(r, n, i = "type") {
    super(`Unexpected ${n} node ${i}: ${JSON.stringify(r[i])}.`);
    wn(this, "name", "UnexpectedNodeError");
    this.node = r;
  }
}, $o = jM;
function ZM(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var En, WM = class {
  constructor(e) {
    A9(this, En, void 0), T9(this, En, new Set(e));
  }
  getLeadingWhitespaceCount(e) {
    let r = Yi(this, En), n = 0;
    for (let i = 0; i < e.length && r.has(e.charAt(i)); i++)
      n++;
    return n;
  }
  getTrailingWhitespaceCount(e) {
    let r = Yi(this, En), n = 0;
    for (let i = e.length - 1; i >= 0 && r.has(e.charAt(i)); i--)
      n++;
    return n;
  }
  getLeadingWhitespace(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(0, r);
  }
  getTrailingWhitespace(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(e.length - r);
  }
  hasLeadingWhitespace(e) {
    return Yi(this, En).has(e.charAt(0));
  }
  hasTrailingWhitespace(e) {
    return Yi(this, En).has(ze(!1, e, -1));
  }
  trimStart(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(r);
  }
  trimEnd(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(0, e.length - r);
  }
  trim(e) {
    return this.trimEnd(this.trimStart(e));
  }
  split(e, r = !1) {
    let n = `[${ZM([...Yi(this, En)].join(""))}]+`, i = new RegExp(r ? `(${n})` : n);
    return e.split(i);
  }
  hasWhitespaceCharacter(e) {
    let r = Yi(this, En);
    return Array.prototype.some.call(e, (n) => r.has(n));
  }
  hasNonWhitespaceCharacter(e) {
    let r = Yi(this, En);
    return Array.prototype.some.call(e, (n) => !r.has(n));
  }
  isWhitespaceOnly(e) {
    let r = Yi(this, En);
    return Array.prototype.every.call(e, (n) => r.has(n));
  }
};
En = /* @__PURE__ */ new WeakMap();
var qM = WM, Jc = new qM(` 
\r	`), Yd = (t) => t === "" || t === de || t === ee || t === K;
function XM(t, e, r) {
  var n, i, s;
  let { node: a } = t;
  if (a.type === "JSXElement" && aL(a))
    return [r("openingElement"), r("closingElement")];
  let o = a.type === "JSXElement" ? r("openingElement") : r("openingFragment"), u = a.type === "JSXElement" ? r("closingElement") : r("closingFragment");
  if (a.children.length === 1 && a.children[0].type === "JSXExpressionContainer" && (a.children[0].expression.type === "TemplateLiteral" || a.children[0].expression.type === "TaggedTemplateExpression"))
    return [o, ...t.map(r, "children"), u];
  a.children = a.children.map((A) => oL(A) ? { type: "JSXText", value: " ", raw: " " } : A);
  let c = a.children.some(Lt), h = a.children.filter((A) => A.type === "JSXExpressionContainer").length > 1, p = a.type === "JSXElement" && a.openingElement.attributes.length > 1, m = mr(o) || c || p || h, g = t.parent.rootMarker === "mdx", O = e.singleQuote ? "{' '}" : '{" "}', b = g ? " " : Fe([O, K], " "), D = ((i = (n = a.openingElement) == null ? void 0 : n.name) == null ? void 0 : i.name) === "fbt", S = VM(t, e, r, b, D), x = a.children.some((A) => Vl(A));
  for (let A = S.length - 2; A >= 0; A--) {
    let P = S[A] === "" && S[A + 1] === "", $ = S[A] === ee && S[A + 1] === "" && S[A + 2] === ee, B = (S[A] === K || S[A] === ee) && S[A + 1] === "" && S[A + 2] === b, _ = S[A] === b && S[A + 1] === "" && (S[A + 2] === K || S[A + 2] === ee), M = S[A] === b && S[A + 1] === "" && S[A + 2] === b, Y = S[A] === K && S[A + 1] === "" && S[A + 2] === ee || S[A] === ee && S[A + 1] === "" && S[A + 2] === K;
    $ && x || P || B || M || Y ? S.splice(A, 2) : _ && S.splice(A + 1, 2);
  }
  for (; S.length > 0 && Yd(ze(!1, S, -1)); )
    S.pop();
  for (; S.length > 1 && Yd(S[0]) && Yd(S[1]); )
    S.shift(), S.shift();
  let w = [];
  for (let [A, P] of S.entries()) {
    if (P === b) {
      if (A === 1 && S[A - 1] === "") {
        if (S.length === 2) {
          w.push(O);
          continue;
        }
        w.push([O, ee]);
        continue;
      } else if (A === S.length - 1) {
        w.push(O);
        continue;
      } else if (S[A - 1] === "" && S[A - 2] === ee) {
        w.push(O);
        continue;
      }
    }
    w.push(P), mr(P) && (m = !0);
  }
  let T = x ? qy(w) : Z(w, { shouldBreak: !0 });
  if (((s = e.cursorNode) == null ? void 0 : s.type) === "JSXText" && a.children.includes(e.cursorNode) && (T = [M1, T, M1]), g)
    return T;
  let C = Z([o, te([ee, T]), ee, u]);
  return m ? C : Ws([Z([o, ...S, u]), C]);
}
function VM(t, e, r, n, i) {
  let s = [];
  return t.each(({ node: a, next: o }) => {
    if (a.type === "JSXText") {
      let u = mn(a);
      if (Vl(a)) {
        let c = Jc.split(u, !0);
        c[0] === "" && (s.push(""), c.shift(), /\n/.test(c[0]) ? s.push(W1(i, c[1], a, o)) : s.push(n), c.shift());
        let h;
        if (ze(!1, c, -1) === "" && (c.pop(), h = c.pop()), c.length === 0)
          return;
        for (let [p, m] of c.entries())
          p % 2 === 1 ? s.push(de) : s.push(m);
        h !== void 0 ? /\n/.test(h) ? s.push(W1(i, ze(!1, s, -1), a, o)) : s.push(n) : s.push(Z1(i, ze(!1, s, -1), a, o));
      } else
        /\n/.test(u) ? u.match(/\n/g).length > 1 && s.push("", ee) : s.push("", n);
    } else {
      let u = r();
      if (s.push(u), o && Vl(o)) {
        let c = Jc.trim(mn(o)), [h] = Jc.split(c);
        s.push(Z1(i, h, a, o));
      } else
        s.push(ee);
    }
  }, "children"), s;
}
function Z1(t, e, r, n) {
  return t ? "" : r.type === "JSXElement" && !r.closingElement || (n == null ? void 0 : n.type) === "JSXElement" && !n.closingElement ? e.length === 1 ? K : ee : K;
}
function W1(t, e, r, n) {
  return t ? ee : e.length === 1 ? r.type === "JSXElement" && !r.closingElement || (n == null ? void 0 : n.type) === "JSXElement" && !n.closingElement ? ee : K : ee;
}
var YM = /* @__PURE__ */ new Set(["ArrayExpression", "TupleExpression", "JSXAttribute", "JSXElement", "JSXExpressionContainer", "JSXFragment", "ExpressionStatement", "CallExpression", "OptionalCallExpression", "ConditionalExpression", "JsExpressionRoot"]);
function UM(t, e, r) {
  let { parent: n } = t;
  if (YM.has(n.type))
    return e;
  let i = t.match(void 0, (a) => a.type === "ArrowFunctionExpression", qe, (a) => a.type === "JSXExpressionContainer"), s = Da(t, r);
  return Z([s ? "" : Fe("("), te([K, e]), K, s ? "" : Fe(")")], { shouldBreak: i });
}
function zM(t, e, r) {
  let { node: n } = t, i = [];
  if (i.push(r("name")), n.value) {
    let s;
    if (Tr(n.value)) {
      let a = mn(n.value), o = Yr(!1, Yr(!1, a.slice(1, -1), "&apos;", "'"), "&quot;", '"'), u = _S(o, e.jsxSingleQuote);
      o = u === '"' ? Yr(!1, o, '"', "&quot;") : Yr(!1, o, "'", "&apos;"), s = t.call(() => Bn(t, ta(u + o + u), e), "value");
    } else
      s = r("value");
    i.push("=", s);
  }
  return i;
}
function GM(t, e, r) {
  let { node: n } = t, i = (s, a) => s.type === "JSXEmptyExpression" || !ae(s) && (Kt(s) || In(s) || s.type === "ArrowFunctionExpression" || s.type === "AwaitExpression" && (i(s.argument, s) || s.argument.type === "JSXElement") || qe(s) || s.type === "ChainExpression" && qe(s.expression) || s.type === "FunctionExpression" || s.type === "TemplateLiteral" || s.type === "TaggedTemplateExpression" || s.type === "DoExpression" || Lt(a) && (s.type === "ConditionalExpression" || wi(s)));
  return i(n.expression, t.parent) ? Z(["{", r("expression"), Ci, "}"]) : Z(["{", te([K, r("expression")]), K, Ci, "}"]);
}
function HM(t, e, r) {
  var n, i;
  let { node: s } = t, a = ae(s.name) || ae(s.typeParameters) || ae(s.typeArguments);
  if (s.selfClosing && s.attributes.length === 0 && !a)
    return ["<", r("name"), s.typeArguments ? r("typeArguments") : r("typeParameters"), " />"];
  if (((n = s.attributes) == null ? void 0 : n.length) === 1 && s.attributes[0].value && Tr(s.attributes[0].value) && !s.attributes[0].value.value.includes(`
`) && !a && !ae(s.attributes[0]))
    return Z(["<", r("name"), s.typeArguments ? r("typeArguments") : r("typeParameters"), " ", ...t.map(r, "attributes"), s.selfClosing ? " />" : ">"]);
  let o = (i = s.attributes) == null ? void 0 : i.some((c) => c.value && Tr(c.value) && c.value.value.includes(`
`)), u = e.singleAttributePerLine && s.attributes.length > 1 ? ee : de;
  return Z(["<", r("name"), s.typeArguments ? r("typeArguments") : r("typeParameters"), te(t.map(() => [u, r()], "attributes")), ...JM(s, e, a)], { shouldBreak: o });
}
function JM(t, e, r) {
  return t.selfClosing ? [de, "/>"] : KM(t, e, r) ? [">"] : [K, ">"];
}
function KM(t, e, r) {
  let n = t.attributes.length > 0 && ae(ze(!1, t.attributes, -1), fe.Trailing);
  return t.attributes.length === 0 && !r || (e.bracketSameLine || e.jsxBracketSameLine) && (!r || t.attributes.length > 0) && !n;
}
function eL(t, e, r) {
  let { node: n } = t, i = [];
  i.push("</");
  let s = r("name");
  return ae(n.name, fe.Leading | fe.Line) ? i.push(te([ee, s]), ee) : ae(n.name, fe.Leading | fe.Block) ? i.push(" ", s) : i.push(s), i.push(">"), i;
}
function tL(t, e) {
  let { node: r } = t, n = ae(r), i = ae(r, fe.Line), s = r.type === "JSXOpeningFragment";
  return [s ? "<" : "</", te([i ? ee : n && !s ? " " : "", yt(t, e)]), i ? ee : "", ">"];
}
function rL(t, e, r) {
  let n = Bn(t, XM(t, e, r), e);
  return UM(t, n, e);
}
function nL(t, e) {
  let { node: r } = t, n = ae(r, fe.Line);
  return [yt(t, e, { indent: n }), n ? ee : ""];
}
function iL(t, e, r) {
  let { node: n } = t;
  return ["{", t.call(({ node: i }) => {
    let s = ["...", r()];
    return !ae(i) || !xw(t) ? s : [te([K, Bn(t, s, e)]), K];
  }, n.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
}
function sL(t, e, r) {
  let { node: n } = t;
  if (n.type.startsWith("JSX"))
    switch (n.type) {
      case "JSXAttribute":
        return zM(t, e, r);
      case "JSXIdentifier":
        return n.name;
      case "JSXNamespacedName":
        return Re(":", [r("namespace"), r("name")]);
      case "JSXMemberExpression":
        return Re(".", [r("object"), r("property")]);
      case "JSXSpreadAttribute":
      case "JSXSpreadChild":
        return iL(t, e, r);
      case "JSXExpressionContainer":
        return GM(t, e, r);
      case "JSXFragment":
      case "JSXElement":
        return rL(t, e, r);
      case "JSXOpeningElement":
        return HM(t, e, r);
      case "JSXClosingElement":
        return eL(t, e, r);
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        return tL(t, e);
      case "JSXEmptyExpression":
        return nL(t, e);
      case "JSXText":
        throw new Error("JSXText should be handled by JSXElement");
      default:
        throw new $o(n, "JSX");
    }
}
function aL(t) {
  if (t.children.length === 0)
    return !0;
  if (t.children.length > 1)
    return !1;
  let e = t.children[0];
  return e.type === "JSXText" && !Vl(e);
}
function Vl(t) {
  return t.type === "JSXText" && (Jc.hasNonWhitespaceCharacter(mn(t)) || !/\n/.test(mn(t)));
}
function oL(t) {
  return t.type === "JSXExpressionContainer" && Tr(t.expression) && t.expression.value === " " && !ae(t.expression);
}
function lL(t) {
  let { node: e, parent: r } = t;
  if (!Lt(e) || !Lt(r))
    return !1;
  let { index: n, siblings: i } = t, s;
  for (let a = n; a > 0; a--) {
    let o = i[a - 1];
    if (!(o.type === "JSXText" && !Vl(o))) {
      s = o;
      break;
    }
  }
  return (s == null ? void 0 : s.type) === "JSXExpressionContainer" && s.expression.type === "JSXEmptyExpression" && Yp(s.expression);
}
function uL(t) {
  return Yp(t.node) || lL(t);
}
var Tw = uL, cL = 0;
function kw(t, e, r) {
  var n;
  let { node: i, parent: s, grandparent: a, key: o } = t, u = o !== "body" && (s.type === "IfStatement" || s.type === "WhileStatement" || s.type === "SwitchStatement" || s.type === "DoWhileStatement"), c = i.operator === "|>" && ((n = t.root.extra) == null ? void 0 : n.__isUsingHackPipeline), h = ym(t, r, e, !1, u);
  if (u)
    return h;
  if (c)
    return Z(h);
  if (qe(s) && s.callee === i || s.type === "UnaryExpression" || ft(s) && !s.computed)
    return Z([te([K, ...h]), K]);
  let p = s.type === "ReturnStatement" || s.type === "ThrowStatement" || s.type === "JSXExpressionContainer" && a.type === "JSXAttribute" || i.operator !== "|" && s.type === "JsExpressionRoot" || i.type !== "NGPipeExpression" && (s.type === "NGRoot" && e.parser === "__ng_binding" || s.type === "NGMicrosyntaxExpression" && a.type === "NGMicrosyntax" && a.body.length === 1) || i === s.body && s.type === "ArrowFunctionExpression" || i !== s.body && s.type === "ForStatement" || s.type === "ConditionalExpression" && a.type !== "ReturnStatement" && a.type !== "ThrowStatement" && !qe(a) || s.type === "TemplateLiteral", m = s.type === "AssignmentExpression" || s.type === "VariableDeclarator" || s.type === "ClassProperty" || s.type === "PropertyDefinition" || s.type === "TSAbstractPropertyDefinition" || s.type === "ClassPrivateProperty" || Mi(s), g = wi(i.left) && Zy(i.operator, i.left.operator);
  if (p || Yl(i) && !g || !Yl(i) && m)
    return Z(h);
  if (h.length === 0)
    return "";
  let O = Lt(i.right), b = h.findIndex((C) => typeof C != "string" && !Array.isArray(C) && C.type === yn), D = h.slice(0, b === -1 ? 1 : b + 1), S = h.slice(D.length, O ? -1 : void 0), x = Symbol("logicalChain-" + ++cL), w = Z([...D, te(S)], { id: x });
  if (!O)
    return w;
  let T = ze(!1, h, -1);
  return Z([w, Up(T, { groupId: x })]);
}
function ym(t, e, r, n, i) {
  var s;
  let { node: a } = t;
  if (!wi(a))
    return [Z(e())];
  let o = [];
  Zy(a.operator, a.left.operator) ? o = t.call((D) => ym(D, e, r, !0, i), "left") : o.push(Z(e("left")));
  let u = Yl(a), c = (a.operator === "|>" || a.type === "NGPipeExpression" || hL(t, r)) && !Js(r.originalText, a.right), h = a.type === "NGPipeExpression" ? "|" : a.operator, p = a.type === "NGPipeExpression" && a.arguments.length > 0 ? Z(te([K, ": ", Re([de, ": "], t.map(() => li(2, Z(e())), "arguments"))])) : "", m;
  if (u)
    m = [h, " ", e("right"), p];
  else {
    let D = h === "|>" && ((s = t.root.extra) != null && s.__isUsingHackPipeline) ? t.call((S) => ym(S, e, r, !0, i), "right") : e("right");
    m = [c ? de : "", h, c ? " " : de, D, p];
  }
  let { parent: g } = t, O = ae(a.left, fe.Trailing | fe.Line), b = O || !(i && a.type === "LogicalExpression") && g.type !== a.type && a.left.type !== a.type && a.right.type !== a.type;
  if (o.push(c ? "" : " ", b ? Z(m, { shouldBreak: O }) : m), n && ae(a)) {
    let D = Xy(Bn(t, o, r));
    return Array.isArray(D) || D.type === oi ? ow(D) : [D];
  }
  return o;
}
function Yl(t) {
  return t.type !== "LogicalExpression" ? !1 : !!(In(t.right) && t.right.properties.length > 0 || Kt(t.right) && t.right.elements.length > 0 || Lt(t.right));
}
var q1 = (t) => t.type === "BinaryExpression" && t.operator === "|";
function hL(t, e) {
  return (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && q1(t.node) && !t.hasAncestor((r) => !q1(r) && r.type !== "JsExpressionRoot");
}
function pL(t, e, r) {
  let { node: n } = t;
  if (n.type.startsWith("NG"))
    switch (n.type) {
      case "NGRoot":
        return [r("node"), ae(n.node) ? " //" + Ua(n.node)[0].value.trimEnd() : ""];
      case "NGPipeExpression":
        return kw(t, e, r);
      case "NGChainedExpression":
        return Z(Re([";", de], t.map(() => fL(t) ? r() : ["(", r(), ")"], "expressions")));
      case "NGEmptyExpression":
        return "";
      case "NGMicrosyntax":
        return t.map(() => [t.isFirst ? "" : X1(t) ? " " : [";", de], r()], "body");
      case "NGMicrosyntaxKey":
        return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);
      case "NGMicrosyntaxExpression":
        return [r("expression"), n.alias === null ? "" : [" as ", r("alias")]];
      case "NGMicrosyntaxKeyedExpression": {
        let { index: i, parent: s } = t, a = X1(t) || (i === 1 && (n.key.name === "then" || n.key.name === "else" || n.key.name === "as") || (i === 2 || i === 3) && (n.key.name === "else" && s.body[i - 1].type === "NGMicrosyntaxKeyedExpression" && s.body[i - 1].key.name === "then" || n.key.name === "track")) && s.body[0].type === "NGMicrosyntaxExpression";
        return [r("key"), a ? " " : ": ", r("expression")];
      }
      case "NGMicrosyntaxLet":
        return ["let ", r("key"), n.value === null ? "" : [" = ", r("value")]];
      case "NGMicrosyntaxAs":
        return [r("key"), " as ", r("alias")];
      default:
        throw new $o(n, "Angular");
    }
}
function X1({ node: t, index: e }) {
  return t.type === "NGMicrosyntaxKeyedExpression" && t.key.name === "of" && e === 1;
}
var dL = tt(["CallExpression", "OptionalCallExpression", "AssignmentExpression"]);
function fL({ node: t }) {
  return am(t, dL);
}
function Pw(t, e, r) {
  let { node: n } = t;
  return Z([Re(de, t.map(r, "decorators")), Fw(n, e) ? ee : de]);
}
function mL(t, e, r) {
  return $w(t.node) ? [Re(ee, t.map(r, "declaration", "decorators")), ee] : "";
}
function gL(t, e, r) {
  let { node: n, parent: i } = t, { decorators: s } = n;
  if (!Ve(s) || $w(i) || Tw(t))
    return "";
  let a = n.type === "ClassExpression" || n.type === "ClassDeclaration" || Fw(n, e);
  return [t.key === "declaration" && b4(i) ? ee : a ? ui : "", Re(de, t.map(r, "decorators")), de];
}
function Fw(t, e) {
  return t.decorators.some((r) => Hr(e.originalText, Ye(r)));
}
function $w(t) {
  var e;
  if (t.type !== "ExportDefaultDeclaration" && t.type !== "ExportNamedDeclaration" && t.type !== "DeclareExportDeclaration")
    return !1;
  let r = (e = t.declaration) == null ? void 0 : e.decorators;
  return Ve(r) && Zp(t, r[0]);
}
var Eh = class extends Error {
  constructor() {
    super(...arguments);
    wn(this, "name", "ArgExpansionBailout");
  }
};
function yL(t, e, r) {
  let { node: n } = t, i = gn(n);
  if (i.length === 0)
    return ["(", yt(t, e), ")"];
  if (bL(i))
    return ["(", r(["arguments", 0]), ", ", r(["arguments", 1]), ")"];
  let s = !1, a = i.length - 1, o = [];
  Wy(t, ({ node: p }, m) => {
    let g = r();
    m === a || (Es(p, e) ? (s = !0, g = [g, ",", ee, ee]) : g = [g, ",", de]), o.push(g);
  });
  let u = !(n.type === "ImportExpression" || n.callee.type === "Import") && Cs(e, "all") ? "," : "";
  function c() {
    return Z(["(", te([de, ...o]), u, de, ")"], { shouldBreak: !0 });
  }
  if (s || t.parent.type !== "Decorator" && k4(i))
    return c();
  if (xL(i)) {
    let p = o.slice(1);
    if (p.some(mr))
      return c();
    let m;
    try {
      m = r(N1(n, 0), { expandFirstArg: !0 });
    } catch (g) {
      if (g instanceof Eh)
        return c();
      throw g;
    }
    return mr(m) ? [ui, Ws([["(", Z(m, { shouldBreak: !0 }), ", ", ...p, ")"], c()])] : Ws([["(", m, ", ", ...p, ")"], ["(", Z(m, { shouldBreak: !0 }), ", ", ...p, ")"], c()]);
  }
  if (OL(i, o, e)) {
    let p = o.slice(0, -1);
    if (p.some(mr))
      return c();
    let m;
    try {
      m = r(N1(n, -1), { expandLastArg: !0 });
    } catch (g) {
      if (g instanceof Eh)
        return c();
      throw g;
    }
    return mr(m) ? [ui, Ws([["(", ...p, Z(m, { shouldBreak: !0 }), ")"], c()])] : Ws([["(", ...p, m, ")"], ["(", ...p, Z(m, { shouldBreak: !0 }), ")"], c()]);
  }
  let h = ["(", te([K, ...o]), Fe(u), K, ")"];
  return JS(t) ? h : Z(h, { shouldBreak: o.some(mr) || s });
}
function Al(t, e = !1) {
  return In(t) && (t.properties.length > 0 || ae(t)) || Kt(t) && (t.elements.length > 0 || ae(t)) || t.type === "TSTypeAssertion" && Al(t.expression) || Hn(t) && Al(t.expression) || t.type === "FunctionExpression" || t.type === "ArrowFunctionExpression" && (!t.returnType || !t.returnType.typeAnnotation || t.returnType.typeAnnotation.type !== "TSTypeReference" || DL(t.body)) && (t.body.type === "BlockStatement" || t.body.type === "ArrowFunctionExpression" && Al(t.body, !0) || In(t.body) || Kt(t.body) || !e && (qe(t.body) || t.body.type === "ConditionalExpression") || Lt(t.body)) || t.type === "DoExpression" || t.type === "ModuleExpression";
}
function OL(t, e, r) {
  var n, i;
  let s = ze(!1, t, -1);
  if (t.length === 1) {
    let o = ze(!1, e, -1);
    if ((n = o.label) != null && n.embed && ((i = o.label) == null ? void 0 : i.hug) !== !1)
      return !0;
  }
  let a = ze(!1, t, -2);
  return !ae(s, fe.Leading) && !ae(s, fe.Trailing) && Al(s) && (!a || a.type !== s.type) && (t.length !== 2 || a.type !== "ArrowFunctionExpression" || !Kt(s)) && !(t.length > 1 && iC(s, r));
}
function xL(t) {
  if (t.length !== 2)
    return !1;
  let [e, r] = t;
  return e.type === "ModuleExpression" && vL(r) ? !0 : !ae(e) && (e.type === "FunctionExpression" || e.type === "ArrowFunctionExpression" && e.body.type === "BlockStatement") && r.type !== "FunctionExpression" && r.type !== "ArrowFunctionExpression" && r.type !== "ConditionalExpression" && Bw(r) && !Al(r);
}
function Bw(t) {
  var e;
  if (t.type === "ParenthesizedExpression")
    return Bw(t.expression);
  if (Hn(t) || t.type === "TypeCastExpression") {
    let { typeAnnotation: r } = t;
    return r.type === "TypeAnnotation" && (r = r.typeAnnotation), r.type === "TSArrayType" && (r = r.elementType, r.type === "TSArrayType" && (r = r.elementType)), (r.type === "GenericTypeAnnotation" || r.type === "TSTypeReference") && ((e = r.typeParameters) == null ? void 0 : e.params.length) === 1 && (r = r.typeParameters.params[0]), Ry(r) && kn(t.expression, 1);
  }
  return co(t) && gn(t).length > 1 ? !1 : wi(t) ? kn(t.left, 1) && kn(t.right, 1) : WS(t) || kn(t);
}
function bL(t) {
  return t.length === 2 && t[0].type === "ArrowFunctionExpression" && cr(t[0]).length === 0 && t[0].body.type === "BlockStatement" && t[1].type === "ArrayExpression" && !t.some((e) => ae(e));
}
function DL(t) {
  return t.type === "BlockStatement" && (t.body.some((e) => e.type !== "EmptyStatement") || ae(t, fe.Dangling));
}
function vL(t) {
  return t.type === "ObjectExpression" && t.properties.length === 1 && Mi(t.properties[0]) && t.properties[0].key.type === "Identifier" && t.properties[0].key.name === "type" && Tr(t.properties[0].value) && t.properties[0].value.value === "module";
}
var Om = yL, SL = (t) => ((t.type === "ChainExpression" || t.type === "TSNonNullExpression") && (t = t.expression), qe(t) && gn(t).length > 0);
function wL(t, e, r) {
  var n;
  let i = r("object"), s = Iw(t, e, r), { node: a } = t, o = t.findAncestor((h) => !(ft(h) || h.type === "TSNonNullExpression")), u = t.findAncestor((h) => !(h.type === "ChainExpression" || h.type === "TSNonNullExpression")), c = o && (o.type === "NewExpression" || o.type === "BindExpression" || o.type === "AssignmentExpression" && o.left.type !== "Identifier") || a.computed || a.object.type === "Identifier" && a.property.type === "Identifier" && !ft(u) || (u.type === "AssignmentExpression" || u.type === "VariableDeclarator") && (SL(a.object) || ((n = i.label) == null ? void 0 : n.memberChain));
  return Tu(i.label, [i, c ? s : Z(te([K, s]))]);
}
function Iw(t, e, r) {
  let n = r("property"), { node: i } = t, s = gr(t);
  return i.computed ? !i.property || fs(i.property) ? [s, "[", n, "]"] : Z([s, "[", te([K, n]), K, "]"]) : [s, ".", n];
}
function Nw(t, e, r) {
  if (t.node.type === "ChainExpression")
    return t.call(() => Nw(t, e, r), "expression");
  let { parent: n } = t, i = !n || n.type === "ExpressionStatement", s = [];
  function a(R) {
    let { originalText: q } = e, X = ku(q, Ye(R));
    return q.charAt(X) === ")" ? X !== !1 && My(q, X + 1) : Es(R, e);
  }
  function o(R) {
    let { node: q } = R;
    if (q.type === "ChainExpression")
      return R.call(() => o(R), "expression");
    if (qe(q) && (Qa(q.callee) || qe(q.callee))) {
      let X = a(q);
      s.unshift({ node: q, hasTrailingEmptyLine: X, printed: [Bn(R, [gr(R), ra(R, e, r), Om(R, e, r)], e), X ? ee : ""] }), R.call((H) => o(H), "callee");
    } else
      Qa(q) ? (s.unshift({ node: q, needsParens: Da(R, e), printed: Bn(R, ft(q) ? Iw(R, e, r) : rC(R, e, r), e) }), R.call((X) => o(X), "object")) : q.type === "TSNonNullExpression" ? (s.unshift({ node: q, printed: Bn(R, "!", e) }), R.call((X) => o(X), "expression")) : s.unshift({ node: q, printed: r() });
  }
  let { node: u } = t;
  s.unshift({ node: u, printed: [gr(t), ra(t, e, r), Om(t, e, r)] }), u.callee && t.call((R) => o(R), "callee");
  let c = [], h = [s[0]], p = 1;
  for (; p < s.length && (s[p].node.type === "TSNonNullExpression" || qe(s[p].node) || ft(s[p].node) && s[p].node.computed && fs(s[p].node.property)); ++p)
    h.push(s[p]);
  if (!qe(s[0].node))
    for (; p + 1 < s.length && Qa(s[p].node) && Qa(s[p + 1].node); ++p)
      h.push(s[p]);
  c.push(h), h = [];
  let m = !1;
  for (; p < s.length; ++p) {
    if (m && Qa(s[p].node)) {
      if (s[p].node.computed && fs(s[p].node.property)) {
        h.push(s[p]);
        continue;
      }
      c.push(h), h = [], m = !1;
    }
    (qe(s[p].node) || s[p].node.type === "ImportExpression") && (m = !0), h.push(s[p]), ae(s[p].node, fe.Trailing) && (c.push(h), h = [], m = !1);
  }
  h.length > 0 && c.push(h);
  function g(R) {
    return /^[A-Z]|^[$_]+$/.test(R);
  }
  function O(R) {
    return R.length <= e.tabWidth;
  }
  function b(R) {
    var q;
    let X = (q = R[1][0]) == null ? void 0 : q.node.computed;
    if (R[0].length === 1) {
      let ye = R[0][0].node;
      return ye.type === "ThisExpression" || ye.type === "Identifier" && (g(ye.name) || i && O(ye.name) || X);
    }
    let H = ze(!1, R[0], -1).node;
    return ft(H) && H.property.type === "Identifier" && (g(H.property.name) || X);
  }
  let D = c.length >= 2 && !ae(c[1][0].node) && b(c);
  function S(R) {
    let q = R.map((X) => X.printed);
    return R.length > 0 && ze(!1, R, -1).needsParens ? ["(", ...q, ")"] : q;
  }
  function x(R) {
    return R.length === 0 ? "" : te([ee, Re(ee, R.map(S))]);
  }
  let w = c.map(S), T = w, C = D ? 3 : 2, A = c.flat(), P = A.slice(1, -1).some((R) => ae(R.node, fe.Leading)) || A.slice(0, -1).some((R) => ae(R.node, fe.Trailing)) || c[C] && ae(c[C][0].node, fe.Leading);
  if (c.length <= C && !P && !c.some((R) => ze(!1, R, -1).hasTrailingEmptyLine))
    return JS(t) ? T : Z(T);
  let $ = ze(!1, c[D ? 1 : 0], -1).node, B = !qe($) && a($), _ = [S(c[0]), D ? c.slice(1, 2).map(S) : "", B ? ee : "", x(c.slice(D ? 2 : 1))], M = s.map(({ node: R }) => R).filter(qe);
  function Y() {
    let R = ze(!1, ze(!1, c, -1), -1).node, q = ze(!1, w, -1);
    return qe(R) && mr(q) && M.slice(0, -1).some((X) => X.arguments.some(ql));
  }
  let J;
  return P || M.length > 2 && M.some((R) => !R.arguments.every((q) => kn(q))) || w.slice(0, -1).some(mr) || Y() ? J = Z(_) : J = [mr(T) || B ? ui : "", Ws([T, _])], Tu({ memberChain: !0 }, J);
}
var CL = Nw;
function _w(t, e, r) {
  var n;
  let { node: i, parent: s } = t, a = i.type === "NewExpression", o = i.type === "ImportExpression", u = gr(t), c = gn(i), h = c.length === 1 && GS(c[0], e.originalText);
  if (h || c.length > 0 && !a && !o && (AL(i, s) || Vp(i, s))) {
    let m = [];
    if (Wy(t, () => {
      m.push(r());
    }), !(h && (n = m[0].label) != null && n.embed))
      return [a ? "new " : "", r("callee"), u, ra(t, e, r), "(", Re(", ", m), ")"];
  }
  if (!o && !a && Qa(i.callee) && !t.call((m) => Da(m, e), "callee", ...i.callee.type === "ChainExpression" ? ["expression"] : []))
    return CL(t, e, r);
  let p = [a ? "new " : "", o ? EL(i) : r("callee"), u, ra(t, e, r), Om(t, e, r)];
  return o || qe(i.callee) ? Z(p) : p;
}
function EL(t) {
  return t.phase ? `import.${t.phase}` : "import";
}
function AL(t, e) {
  if (t.callee.type !== "Identifier")
    return !1;
  if (t.callee.name === "require") {
    let r = gn(t);
    return r.length === 1 && Tr(r[0]) || r.length > 1;
  }
  if (t.callee.name === "define") {
    let r = gn(t);
    return e.type === "ExpressionStatement" && (r.length === 1 || r.length === 2 && r[0].type === "ArrayExpression" || r.length === 3 && Tr(r[0]) && r[1].type === "ArrayExpression");
  }
  return !1;
}
function Pu(t, e, r, n, i, s) {
  let a = PL(t, e, r, n, s), o = s ? r(s, { assignmentLayout: a }) : "";
  switch (a) {
    case "break-after-operator":
      return Z([Z(n), i, Z(te([de, o]))]);
    case "never-break-after-operator":
      return Z([Z(n), i, " ", o]);
    case "fluid": {
      let u = Symbol("assignment");
      return Z([Z(n), i, Z(te(de), { id: u }), Ci, Up(o, { groupId: u })]);
    }
    case "break-lhs":
      return Z([n, i, " ", Z(o)]);
    case "chain":
      return [Z(n), i, de, o];
    case "chain-tail":
      return [Z(n), i, te([de, o])];
    case "chain-tail-arrow-chain":
      return [Z(n), i, o];
    case "only-left":
      return n;
  }
}
function TL(t, e, r) {
  let { node: n } = t;
  return Pu(t, e, r, r("left"), [" ", n.operator], "right");
}
function kL(t, e, r) {
  return Pu(t, e, r, r("id"), " =", "init");
}
function PL(t, e, r, n, i) {
  let { node: s } = t, a = s[i];
  if (!a)
    return "only-left";
  let o = !Kc(a);
  if (t.match(Kc, Qw, (h) => !o || h.type !== "ExpressionStatement" && h.type !== "VariableDeclaration"))
    return o ? a.type === "ArrowFunctionExpression" && a.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
  if (!o && Kc(a.right) || Js(e.originalText, a))
    return "break-after-operator";
  if (a.type === "CallExpression" && a.callee.name === "require" || e.parser === "json5" || e.parser === "jsonc" || e.parser === "json")
    return "never-break-after-operator";
  let u = K4(n);
  if ($L(s) || _L(s) || Mw(s) && u)
    return "break-lhs";
  let c = ML(s, n, e);
  return t.call(() => FL(t, e, r, c), i) ? "break-after-operator" : BL(s) ? "break-lhs" : !u && (c || a.type === "TemplateLiteral" || a.type === "TaggedTemplateExpression" || a.type === "BooleanLiteral" || fs(a) || a.type === "ClassExpression") ? "never-break-after-operator" : "fluid";
}
function FL(t, e, r, n) {
  let i = t.node;
  if (wi(i) && !Yl(i))
    return !0;
  switch (i.type) {
    case "StringLiteralTypeAnnotation":
    case "SequenceExpression":
      return !0;
    case "TSConditionalType":
    case "ConditionalTypeAnnotation":
      if (!e.experimentalTernaries && !jL(i))
        break;
      return !0;
    case "ConditionalExpression": {
      if (!e.experimentalTernaries) {
        let { test: c } = i;
        return wi(c) && !Yl(c);
      }
      let { consequent: o, alternate: u } = i;
      return o.type === "ConditionalExpression" || u.type === "ConditionalExpression";
    }
    case "ClassExpression":
      return Ve(i.decorators);
  }
  if (n)
    return !1;
  let s = i, a = [];
  for (; ; )
    if (s.type === "UnaryExpression" || s.type === "AwaitExpression" || s.type === "YieldExpression" && s.argument !== null)
      s = s.argument, a.push("argument");
    else if (s.type === "TSNonNullExpression")
      s = s.expression, a.push("expression");
    else
      break;
  return !!(Tr(s) || t.call(() => Lw(t, e, r), ...a));
}
function $L(t) {
  if (Qw(t)) {
    let e = t.left || t.id;
    return e.type === "ObjectPattern" && e.properties.length > 2 && e.properties.some((r) => {
      var n;
      return Mi(r) && (!r.shorthand || ((n = r.value) == null ? void 0 : n.type) === "AssignmentPattern");
    });
  }
  return !1;
}
function Kc(t) {
  return t.type === "AssignmentExpression";
}
function Qw(t) {
  return Kc(t) || t.type === "VariableDeclarator";
}
function BL(t) {
  let e = NL(t);
  if (Ve(e)) {
    let r = t.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
    if (e.length > 1 && e.some((n) => n[r] || n.default))
      return !0;
  }
  return !1;
}
var IL = tt(["TSTypeAliasDeclaration", "TypeAlias"]);
function NL(t) {
  var e;
  if (IL(t))
    return (e = t.typeParameters) == null ? void 0 : e.params;
}
function _L(t) {
  if (t.type !== "VariableDeclarator")
    return !1;
  let { typeAnnotation: e } = t.id;
  if (!e || !e.typeAnnotation)
    return !1;
  let r = V1(e.typeAnnotation);
  return Ve(r) && r.length > 1 && r.some((n) => Ve(V1(n)) || n.type === "TSConditionalType");
}
function Mw(t) {
  var e;
  return t.type === "VariableDeclarator" && ((e = t.init) == null ? void 0 : e.type) === "ArrowFunctionExpression";
}
var QL = tt(["TSTypeReference", "GenericTypeAnnotation"]);
function V1(t) {
  var e;
  if (QL(t))
    return (e = t.typeParameters) == null ? void 0 : e.params;
}
function Lw(t, e, r, n = !1) {
  var i;
  let { node: s } = t, a = () => Lw(t, e, r, !0);
  if (s.type === "ChainExpression" || s.type === "TSNonNullExpression")
    return t.call(a, "expression");
  if (qe(s)) {
    if ((i = _w(t, e, r).label) != null && i.memberChain)
      return !1;
    let o = gn(s);
    return !(o.length === 0 || o.length === 1 && jy(o[0], e)) || LL(s, r) ? !1 : t.call(a, "callee");
  }
  return ft(s) ? t.call(a, "object") : n && (s.type === "Identifier" || s.type === "ThisExpression");
}
function ML(t, e, r) {
  return Mi(t) ? (e = Xy(e), typeof e == "string" && oo(e) < r.tabWidth + 3) : !1;
}
function LL(t, e) {
  let r = RL(t);
  if (Ve(r)) {
    if (r.length > 1)
      return !0;
    if (r.length === 1) {
      let i = r[0];
      if (Ks(i) || ew(i) || i.type === "TSTypeLiteral" || i.type === "ObjectTypeAnnotation")
        return !0;
    }
    let n = t.typeParameters ? "typeParameters" : "typeArguments";
    if (mr(e(n)))
      return !0;
  }
  return !1;
}
function RL(t) {
  var e;
  return (e = t.typeParameters ?? t.typeArguments) == null ? void 0 : e.params;
}
function jL(t) {
  function e(r) {
    switch (r.type) {
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "TSFunctionType":
      case "TSTypeReference":
        return !!r.typeParameters;
      default:
        return !1;
    }
  }
  return e(t.checkType) || e(t.extendsType);
}
function Fu(t, e, r, n, i) {
  let s = t.node, a = cr(s), o = i ? ra(t, r, e) : "";
  if (a.length === 0)
    return [o, "(", yt(t, r, { filter: (g) => Ei(r.originalText, Ye(g)) === ")" }), ")"];
  let { parent: u } = t, c = Vp(u), h = Rw(s), p = [];
  if (N4(t, (g, O) => {
    let b = O === a.length - 1;
    b && s.rest && p.push("..."), p.push(e()), !b && (p.push(","), c || h ? p.push(" ") : Es(a[O], r) ? p.push(ee, ee) : p.push(de));
  }), n && !WL(t)) {
    if (mr(o) || mr(p))
      throw new Eh();
    return Z([um(o), "(", um(p), ")"]);
  }
  let m = a.every((g) => !Ve(g.decorators));
  return h && m ? [o, "(", ...p, ")"] : c ? [o, "(", ...p, ")"] : (XS(u) || v4(u) || u.type === "TypeAlias" || u.type === "UnionTypeAnnotation" || u.type === "IntersectionTypeAnnotation" || u.type === "FunctionTypeAnnotation" && u.returnType === s) && a.length === 1 && a[0].name === null && s.this !== a[0] && a[0].typeAnnotation && s.typeParameters === null && Ry(a[0].typeAnnotation) && !s.rest ? r.arrowParens === "always" ? ["(", ...p, ")"] : p : [o, "(", te([K, ...p]), Fe(!I4(s) && Cs(r, "all") ? "," : ""), K, ")"];
}
function Rw(t) {
  if (!t)
    return !1;
  let e = cr(t);
  if (e.length !== 1)
    return !1;
  let [r] = e;
  return !ae(r) && (r.type === "ObjectPattern" || r.type === "ArrayPattern" || r.type === "Identifier" && r.typeAnnotation && (r.typeAnnotation.type === "TypeAnnotation" || r.typeAnnotation.type === "TSTypeAnnotation") && ms(r.typeAnnotation.typeAnnotation) || r.type === "FunctionTypeParam" && ms(r.typeAnnotation) && r !== t.rest || r.type === "AssignmentPattern" && (r.left.type === "ObjectPattern" || r.left.type === "ArrayPattern") && (r.right.type === "Identifier" || In(r.right) && r.right.properties.length === 0 || Kt(r.right) && r.right.elements.length === 0));
}
function ZL(t) {
  let e;
  return t.returnType ? (e = t.returnType, e.typeAnnotation && (e = e.typeAnnotation)) : t.typeAnnotation && (e = t.typeAnnotation), e;
}
function zp(t, e) {
  var r;
  let n = ZL(t);
  if (!n)
    return !1;
  let i = (r = t.typeParameters) == null ? void 0 : r.params;
  if (i) {
    if (i.length > 1)
      return !1;
    if (i.length === 1) {
      let s = i[0];
      if (s.constraint || s.default)
        return !1;
    }
  }
  return cr(t).length === 1 && (ms(n) || mr(e));
}
function WL(t) {
  return t.match((e) => e.type === "ArrowFunctionExpression" && e.body.type === "BlockStatement", (e, r) => {
    if (e.type === "CallExpression" && r === "arguments" && e.arguments.length === 1 && e.callee.type === "CallExpression") {
      let n = e.callee.callee;
      return n.type === "Identifier" || n.type === "MemberExpression" && !n.computed && n.object.type === "Identifier" && n.property.type === "Identifier";
    }
    return !1;
  }, (e, r) => e.type === "VariableDeclarator" && r === "init" || e.type === "ExportDefaultDeclaration" && r === "declaration" || e.type === "TSExportAssignment" && r === "expression" || e.type === "AssignmentExpression" && r === "right" && e.left.type === "MemberExpression" && e.left.object.type === "Identifier" && e.left.object.name === "module" && e.left.property.type === "Identifier" && e.left.property.name === "exports", (e) => e.type !== "VariableDeclaration" || e.kind === "const" && e.declarations.length === 1);
}
function qL(t) {
  let e = cr(t);
  return e.length > 1 && e.some((r) => r.type === "TSParameterProperty");
}
var XL = tt(["VoidTypeAnnotation", "TSVoidKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword"]), VL = tt(["ObjectTypeAnnotation", "TSTypeLiteral", "GenericTypeAnnotation", "TSTypeReference"]);
function YL(t) {
  let { types: e } = t;
  if (e.some((n) => ae(n)))
    return !1;
  let r = e.find((n) => VL(n));
  return r ? e.every((n) => n === r || XL(n)) : !1;
}
function jw(t) {
  return Ry(t) || ms(t) ? !0 : Ks(t) ? YL(t) : !1;
}
function UL(t, e, r) {
  let n = e.semi ? ";" : "", { node: i } = t, s = [On(t), "opaque type ", r("id"), r("typeParameters")];
  return i.supertype && s.push(": ", r("supertype")), i.impltype && s.push(" = ", r("impltype")), s.push(n), s;
}
function Zw(t, e, r) {
  let n = e.semi ? ";" : "", { node: i } = t, s = [On(t)];
  s.push("type ", r("id"), r("typeParameters"));
  let a = i.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
  return [Pu(t, e, r, s, " =", a), n];
}
function Ww(t, e, r) {
  let n = !1;
  return Z(t.map(({ isFirst: i, previous: s, node: a, index: o }) => {
    let u = r();
    if (i)
      return u;
    let c = ms(a), h = ms(s);
    return h && c ? [" & ", n ? te(u) : u] : !h && !c ? te([" &", de, u]) : (o > 1 && (n = !0), [" & ", o > 1 ? te(u) : u]);
  }, "types"));
}
function qw(t, e, r) {
  let { node: n } = t, { parent: i } = t, s = i.type !== "TypeParameterInstantiation" && (i.type !== "TSConditionalType" || !e.experimentalTernaries) && (i.type !== "ConditionalTypeAnnotation" || !e.experimentalTernaries) && i.type !== "TSTypeParameterInstantiation" && i.type !== "GenericTypeAnnotation" && i.type !== "TSTypeReference" && i.type !== "TSTypeAssertion" && i.type !== "TupleTypeAnnotation" && i.type !== "TSTupleType" && !(i.type === "FunctionTypeParam" && !i.name && t.grandparent.this !== i) && !((i.type === "TypeAlias" || i.type === "VariableDeclarator" || i.type === "TSTypeAliasDeclaration") && Js(e.originalText, n)), a = jw(n), o = t.map((h) => {
    let p = r();
    return a || (p = li(2, p)), Bn(h, p, e);
  }, "types");
  if (a)
    return Re(" | ", o);
  let u = s && !Js(e.originalText, n), c = [Fe([u ? de : "", "| "]), Re([de, "| "], o)];
  return Da(t, e) ? Z([te(c), K]) : (i.type === "TupleTypeAnnotation" || i.type === "TSTupleType") && i[i.type === "TupleTypeAnnotation" && i.types ? "types" : "elementTypes"].length > 1 ? Z([te([Fe(["(", K]), c]), K, Fe(")")]) : Z(s ? te(c) : c);
}
function zL(t) {
  var e;
  let { node: r, parent: n } = t;
  return r.type === "FunctionTypeAnnotation" && (XS(n) || !((n.type === "ObjectTypeProperty" || n.type === "ObjectTypeInternalSlot") && !n.variance && !n.optional && Zp(n, r) || n.type === "ObjectTypeCallProperty" || ((e = t.getParentNode(2)) == null ? void 0 : e.type) === "DeclareFunction"));
}
function Xw(t, e, r) {
  let { node: n } = t, i = [Gp(t)];
  (n.type === "TSConstructorType" || n.type === "TSConstructSignatureDeclaration") && i.push("new ");
  let s = Fu(t, r, e, !1, !0), a = [];
  return n.type === "FunctionTypeAnnotation" ? a.push(zL(t) ? " => " : ": ", r("returnType")) : a.push(Gt(t, r, n.returnType ? "returnType" : "typeAnnotation")), zp(n, a) && (s = Z(s)), i.push(s, a), Z(i);
}
function Vw(t, e, r) {
  return [r("objectType"), gr(t), "[", r("indexType"), "]"];
}
function Yw(t, e, r) {
  return ["infer ", r("typeParameter")];
}
function Y1(t, e, r) {
  let { node: n } = t;
  return [n.postfix ? "" : r, Gt(t, e), n.postfix ? r : ""];
}
function Uw(t, e, r) {
  let { node: n } = t;
  return ["...", ...n.type === "TupleTypeSpreadElement" && n.label ? [r("label"), ": "] : [], r("typeAnnotation")];
}
function zw(t, e, r) {
  let { node: n } = t;
  return [n.variance ? r("variance") : "", r("label"), n.optional ? "?" : "", ": ", r("elementType")];
}
var GL = /* @__PURE__ */ new WeakSet();
function Gt(t, e, r = "typeAnnotation") {
  let { node: { [r]: n } } = t;
  if (!n)
    return "";
  let i = !1;
  if (n.type === "TSTypeAnnotation" || n.type === "TypeAnnotation") {
    let s = t.call(Gw, r);
    (s === "=>" || s === ":" && ae(n, fe.Leading)) && (i = !0), GL.add(n);
  }
  return i ? [" ", e(r)] : e(r);
}
var Gw = (t) => t.match((e) => e.type === "TSTypeAnnotation", (e, r) => (r === "returnType" || r === "typeAnnotation") && (e.type === "TSFunctionType" || e.type === "TSConstructorType")) ? "=>" : t.match((e) => e.type === "TSTypeAnnotation", (e, r) => r === "typeAnnotation" && (e.type === "TSJSDocNullableType" || e.type === "TSJSDocNonNullableType" || e.type === "TSTypePredicate")) || t.match((e) => e.type === "TypeAnnotation", (e, r) => r === "typeAnnotation" && e.type === "Identifier", (e, r) => r === "id" && e.type === "DeclareFunction") || t.match((e) => e.type === "TypeAnnotation", (e, r) => r === "bound" && e.type === "TypeParameter" && e.usesExtendsBound) ? "" : ":";
function Hw(t, e, r) {
  let n = Gw(t);
  return n ? [n, " ", r("typeAnnotation")] : r("typeAnnotation");
}
function Jw(t) {
  return [t("elementType"), "[]"];
}
function Kw({ node: t }, e) {
  let r = t.type === "TSTypeQuery" ? "exprName" : "argument", n = t.type === "TSTypeQuery" ? "typeParameters" : "typeArguments";
  return ["typeof ", e(r), e(n)];
}
function eC(t, e) {
  let { node: r } = t;
  return [r.asserts ? "asserts " : "", e("parameterName"), r.typeAnnotation ? [" is ", Gt(t, e)] : ""];
}
function gr(t) {
  let { node: e } = t;
  return !e.optional || e.type === "Identifier" && e === t.parent.key ? "" : qe(e) || ft(e) && e.computed || e.type === "OptionalIndexedAccessType" ? "?." : "?";
}
function tC(t) {
  return t.node.definite || t.match(void 0, (e, r) => r === "id" && e.type === "VariableDeclarator" && e.definite) ? "!" : "";
}
var HL = /* @__PURE__ */ new Set(["DeclareClass", "DeclareFunction", "DeclareVariable", "DeclareExportDeclaration", "DeclareExportAllDeclaration", "DeclareOpaqueType", "DeclareTypeAlias", "DeclareEnum", "DeclareInterface"]);
function On(t) {
  let { node: e } = t;
  return e.declare || HL.has(e.type) && t.parent.type !== "DeclareExportDeclaration" ? "declare " : "";
}
var JL = /* @__PURE__ */ new Set(["TSAbstractMethodDefinition", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
function Gp({ node: t }) {
  return t.abstract || JL.has(t.type) ? "abstract " : "";
}
function ra(t, e, r) {
  let n = t.node;
  return n.typeArguments ? r("typeArguments") : n.typeParameters ? r("typeParameters") : "";
}
function rC(t, e, r) {
  return ["::", r("callee")];
}
function Ui(t, e, r) {
  return t.type === "EmptyStatement" ? ";" : t.type === "BlockStatement" || r ? [" ", e] : te([de, e]);
}
function nC(t, e) {
  return ["...", e("argument"), Gt(t, e)];
}
function Ah(t) {
  return t.accessibility ? t.accessibility + " " : "";
}
function KL(t, e, r, n) {
  let { node: i } = t;
  return ae(i, fe.Dangling) ? Z([r, yt(t, e, { indent: !0 }), K, n]) : [r, n];
}
function Ky(t, e, r) {
  let { node: n } = t, i = [], s = n.type === "TupleExpression" ? "#[" : "[", a = "]", o = n.type === "TupleTypeAnnotation" && n.types ? "types" : n.type === "TSTupleType" || n.type === "TupleTypeAnnotation" ? "elementTypes" : "elements", u = n[o];
  if (u.length === 0)
    i.push(KL(t, e, s, a));
  else {
    let c = ze(!1, u, -1), h = (c == null ? void 0 : c.type) !== "RestElement", p = c === null, m = Symbol("array"), g = !e.__inJestEach && u.length > 1 && u.every((D, S, x) => {
      let w = D == null ? void 0 : D.type;
      if (!Kt(D) && !In(D))
        return !1;
      let T = x[S + 1];
      if (T && w !== T.type)
        return !1;
      let C = Kt(D) ? "elements" : "properties";
      return D[C] && D[C].length > 1;
    }), O = iC(n, e), b = h ? p ? "," : Cs(e) ? O ? Fe(",", "", { groupId: m }) : Fe(",") : "" : "";
    i.push(Z([s, te([K, O ? tR(t, e, r, b) : [eR(t, e, o, r), b], yt(t, e)]), K, a], { shouldBreak: g, id: m }));
  }
  return i.push(gr(t), Gt(t, r)), i;
}
function iC(t, e) {
  return Kt(t) && t.elements.length > 1 && t.elements.every((r) => r && (fs(r) || ZS(r) && !ae(r.argument)) && !ae(r, fe.Trailing | fe.Line, (n) => !Hr(e.originalText, mt(n), { backwards: !0 })));
}
function sC({ node: t }, { originalText: e }) {
  let r = (i) => _y(e, Qy(e, i)), n = (i) => e[i] === "," ? i : n(r(i + 1));
  return My(e, n(Ye(t)));
}
function eR(t, e, r, n) {
  let i = [];
  return t.each(({ node: s, isLast: a }) => {
    i.push(s ? Z(n()) : ""), a || i.push([",", de, s && sC(t, e) ? K : ""]);
  }, r), i;
}
function tR(t, e, r, n) {
  let i = [];
  return t.each(({ isLast: s, next: a }) => {
    i.push([r(), s ? n : ","]), s || i.push(sC(t, e) ? [ee, ee] : ae(a, fe.Leading | fe.Line) ? ee : de);
  }, "elements"), qy(i);
}
var aC = new Proxy(() => {
}, { get: () => aC }), oC = aC;
function rR(t) {
  return t.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
}
var ns = rR, Oc = /* @__PURE__ */ new WeakMap();
function $u(t, e, r) {
  let { node: n } = t;
  if (n.computed)
    return ["[", r("key"), "]"];
  let { parent: i } = t, { key: s } = n;
  if (e.quoteProps === "consistent" && !Oc.has(i)) {
    let a = (i.properties || i.body || i.members).some((o) => !o.computed && o.key && Tr(o.key) && !$1(o, e));
    Oc.set(i, a);
  }
  if ((s.type === "Identifier" || fs(s) && zS(ns(mn(s))) && String(s.value) === ns(mn(s)) && !(e.parser === "typescript" || e.parser === "babel-ts")) && (e.parser === "json" || e.parser === "jsonc" || e.quoteProps === "consistent" && Oc.get(i))) {
    let a = Wl(JSON.stringify(s.type === "Identifier" ? s.name : s.value.toString()), e);
    return t.call((o) => Bn(o, a, e), "key");
  }
  return $1(n, e) && (e.quoteProps === "as-needed" || e.quoteProps === "consistent" && !Oc.get(i)) ? t.call((a) => Bn(a, /^\d/.test(s.value) ? ns(s.value) : s.value, e), "key") : r("key");
}
function U1(t, e, r) {
  let { node: n } = t;
  return n.shorthand ? r("value") : Pu(t, e, r, $u(t, e, r), ":", "value");
}
var nR = ({ node: t, key: e, parent: r }) => e === "value" && t.type === "FunctionExpression" && (r.type === "ObjectMethod" || r.type === "ClassMethod" || r.type === "ClassPrivateMethod" || r.type === "MethodDefinition" || r.type === "TSAbstractMethodDefinition" || r.type === "TSDeclareMethod" || r.type === "Property" && Xp(r));
function lC(t, e, r, n) {
  if (nR(t))
    return e0(t, r, e);
  let { node: i } = t, s = !1;
  if ((i.type === "FunctionDeclaration" || i.type === "FunctionExpression") && n != null && n.expandLastArg) {
    let { parent: h } = t;
    qe(h) && (gn(h).length > 1 || cr(i).every((p) => p.type === "Identifier" && !p.typeAnnotation)) && (s = !0);
  }
  let a = [On(t), i.async ? "async " : "", `function${i.generator ? "*" : ""} `, i.id ? e("id") : ""], o = Fu(t, e, r, s), u = t0(t, e), c = zp(i, u);
  return a.push(ra(t, r, e), Z([c ? Z(o) : o, u]), i.body ? " " : "", e("body")), r.semi && (i.declare || !i.body) && a.push(";"), a;
}
function xm(t, e, r) {
  let { node: n } = t, { kind: i } = n, s = n.value || n, a = [];
  return !i || i === "init" || i === "method" || i === "constructor" ? s.async && a.push("async ") : (oC.ok(i === "get" || i === "set"), a.push(i, " ")), s.generator && a.push("*"), a.push($u(t, e, r), n.optional || n.key.optional ? "?" : "", n === s ? e0(t, e, r) : r("value")), a;
}
function e0(t, e, r) {
  let { node: n } = t, i = Fu(t, r, e), s = t0(t, r), a = qL(n), o = zp(n, s), u = [ra(t, e, r), Z([a ? Z(i, { shouldBreak: !0 }) : o ? Z(i) : i, s])];
  return n.body ? u.push(" ", r("body")) : u.push(e.semi ? ";" : ""), u;
}
function iR(t) {
  let e = cr(t);
  return e.length === 1 && !t.typeParameters && !ae(t, fe.Dangling) && e[0].type === "Identifier" && !e[0].typeAnnotation && !ae(e[0]) && !e[0].optional && !t.predicate && !t.returnType;
}
function uC(t, e) {
  if (e.arrowParens === "always")
    return !1;
  if (e.arrowParens === "avoid") {
    let { node: r } = t;
    return iR(r);
  }
  return !1;
}
function t0(t, e) {
  let { node: r } = t, n = [Gt(t, e, "returnType")];
  return r.predicate && n.push(e("predicate")), n;
}
function cC(t, e, r) {
  let { node: n } = t, i = e.semi ? ";" : "", s = [];
  if (n.argument) {
    let u = r("argument");
    oR(e, n.argument) ? u = ["(", te([ee, u]), ee, ")"] : (wi(n.argument) || n.argument.type === "SequenceExpression" || e.experimentalTernaries && n.argument.type === "ConditionalExpression" && (n.argument.consequent.type === "ConditionalExpression" || n.argument.alternate.type === "ConditionalExpression")) && (u = Z([Fe("("), te([K, u]), K, Fe(")")])), s.push(" ", u);
  }
  let a = ae(n, fe.Dangling), o = i && a && ae(n, fe.Last | fe.Line);
  return o && s.push(i), a && s.push(" ", yt(t, e)), o || s.push(i), s;
}
function sR(t, e, r) {
  return ["return", cC(t, e, r)];
}
function aR(t, e, r) {
  return ["throw", cC(t, e, r)];
}
function oR(t, e) {
  if (Js(t.originalText, e) || ae(e, fe.Leading, (r) => gs(t.originalText, mt(r), Ye(r))) && !Lt(e))
    return !0;
  if (Ly(e)) {
    let r = e, n;
    for (; n = x4(r); )
      if (r = n, Js(t.originalText, r))
        return !0;
  }
  return !1;
}
var Ud = /* @__PURE__ */ new WeakMap();
function hC(t) {
  return Ud.has(t) || Ud.set(t, t.type === "ConditionalExpression" && !fr(t, (e) => e.type === "ObjectExpression")), Ud.get(t);
}
var pC = (t) => t.type === "SequenceExpression";
function lR(t, e, r, n = {}) {
  let i = [], s, a = [], o = !1, u = !n.expandLastArg && t.node.body.type === "ArrowFunctionExpression", c;
  (function D() {
    let { node: S } = t, x = uR(t, e, r, n);
    if (i.length === 0)
      i.push(x);
    else {
      let { leading: w, trailing: T } = Aw(t, e);
      i.push([w, x]), a.unshift(T);
    }
    u && (o || (o = S.returnType && cr(S).length > 0 || S.typeParameters || cr(S).some((w) => w.type !== "Identifier"))), !u || S.body.type !== "ArrowFunctionExpression" ? (s = r("body", n), c = S.body) : t.call(D, "body");
  })();
  let h = !Js(e.originalText, c) && (pC(c) || cR(c, s, e) || !o && hC(c)), p = t.key === "callee" && co(t.parent), m = Symbol("arrow-chain"), g = hR(t, n, { signatureDocs: i, shouldBreak: o }), O, b = !1;
  return u && (p || n.assignmentLayout) && (b = !0, O = n.assignmentLayout === "chain-tail-arrow-chain" || p && !h), s = pR(t, e, n, { bodyDoc: s, bodyComments: a, functionBody: c, shouldPutBodyOnSameLine: h }), Z([Z(b ? te([K, g]) : g, { shouldBreak: O, id: m }), " =>", u ? Up(s, { groupId: m }) : Z(s), u && p ? Fe(K, "", { groupId: m }) : ""]);
}
function uR(t, e, r, n) {
  let { node: i } = t, s = [];
  if (i.async && s.push("async "), uC(t, e))
    s.push(r(["params", 0]));
  else {
    let o = n.expandLastArg || n.expandFirstArg, u = t0(t, r);
    if (o) {
      if (mr(u))
        throw new Eh();
      u = Z(um(u));
    }
    s.push(Z([Fu(t, r, e, o, !0), u]));
  }
  let a = yt(t, e, { filter(o) {
    let u = ku(e.originalText, Ye(o));
    return u !== !1 && e.originalText.slice(u, u + 2) === "=>";
  } });
  return a && s.push(" ", a), s;
}
function cR(t, e, r) {
  var n, i;
  return Kt(t) || In(t) || t.type === "ArrowFunctionExpression" || t.type === "DoExpression" || t.type === "BlockStatement" || Lt(t) || ((n = e.label) == null ? void 0 : n.hug) !== !1 && (((i = e.label) == null ? void 0 : i.embed) || GS(t, r.originalText));
}
function hR(t, e, { signatureDocs: r, shouldBreak: n }) {
  if (r.length === 1)
    return r[0];
  let { parent: i, key: s } = t;
  return s !== "callee" && co(i) || wi(i) ? Z([r[0], " =>", te([de, Re([" =>", de], r.slice(1))])], { shouldBreak: n }) : s === "callee" && co(i) || e.assignmentLayout ? Z(Re([" =>", de], r), { shouldBreak: n }) : Z(te(Re([" =>", de], r)), { shouldBreak: n });
}
function pR(t, e, r, { bodyDoc: n, bodyComments: i, functionBody: s, shouldPutBodyOnSameLine: a }) {
  let { node: o, parent: u } = t, c = r.expandLastArg && Cs(e, "all") ? Fe(",") : "", h = (r.expandLastArg || u.type === "JSXExpressionContainer") && !ae(o) ? K : "";
  return a && hC(s) ? [" ", Z([Fe("", "("), te([K, n]), Fe("", ")"), c, h]), i] : (pC(s) && (n = Z(["(", te([K, n]), K, ")"])), a ? [" ", n, i] : [te([de, n, i]), c, h]);
}
var dR = (t, e, r) => {
  if (!(t && e == null)) {
    if (e.findLast)
      return e.findLast(r);
    for (let n = e.length - 1; n >= 0; n--) {
      let i = e[n];
      if (r(i, n, e))
        return i;
    }
  }
}, fR = dR;
function bm(t, e, r, n) {
  let { node: i } = t, s = [], a = fR(!1, i[n], (o) => o.type !== "EmptyStatement");
  return t.each(({ node: o }) => {
    o.type !== "EmptyStatement" && (s.push(r()), o !== a && (s.push(ee), Es(o, e) && s.push(ee)));
  }, n), s;
}
function dC(t, e, r) {
  let { node: n } = t, i = [];
  n.type === "StaticBlock" && i.push("static "), i.push("{");
  let s = fC(t, e, r);
  if (s)
    i.push(te([ee, s]), ee);
  else {
    let { parent: a } = t, o = t.grandparent;
    a.type === "ArrowFunctionExpression" || a.type === "FunctionExpression" || a.type === "FunctionDeclaration" || a.type === "ObjectMethod" || a.type === "ClassMethod" || a.type === "ClassPrivateMethod" || a.type === "ForStatement" || a.type === "WhileStatement" || a.type === "DoWhileStatement" || a.type === "DoExpression" || a.type === "CatchClause" && !o.finalizer || a.type === "TSModuleDeclaration" || a.type === "TSDeclareFunction" || n.type === "StaticBlock" || i.push(ee);
  }
  return i.push("}"), i;
}
function fC(t, e, r) {
  var n;
  let { node: i } = t, s = Ve(i.directives), a = i.body.some((c) => c.type !== "EmptyStatement"), o = ae(i, fe.Dangling);
  if (!s && !a && !o)
    return "";
  let u = [];
  return s && (u.push(bm(t, e, r, "directives")), (a || o) && (u.push(ee), Es(ze(!1, i.directives, -1), e) && u.push(ee))), a && u.push(bm(t, e, r, "body")), o && u.push(yt(t, e)), i.type === "Program" && ((n = t.parent) == null ? void 0 : n.type) !== "ModuleExpression" && u.push(ee), u;
}
function mR(t) {
  let e = /* @__PURE__ */ new WeakMap();
  return function(r) {
    return e.has(r) || e.set(r, Symbol(t)), e.get(r);
  };
}
var mC = mR;
function gR(t) {
  switch (t) {
    case null:
      return "";
    case "PlusOptional":
      return "+?";
    case "MinusOptional":
      return "-?";
    case "Optional":
      return "?";
  }
}
function yR(t, e, r) {
  let { node: n } = t;
  return Z([n.variance ? r("variance") : "", "[", te([r("keyTparam"), " in ", r("sourceType")]), "]", gR(n.optional), ": ", r("propType")]);
}
function gC(t, e) {
  return t === "+" || t === "-" ? t + e : e;
}
function OR(t, e, r) {
  let { node: n } = t, i = gs(e.originalText, mt(n), mt(n.typeParameter));
  return Z(["{", te([e.bracketSpacing ? de : K, Z([r("typeParameter"), n.optional ? gC(n.optional, "?") : "", n.typeAnnotation ? ": " : "", r("typeAnnotation")]), e.semi ? Fe(";") : ""]), yt(t, e), e.bracketSpacing ? de : K, "}"], { shouldBreak: i });
}
var r0 = mC("typeParameters");
function xR(t, e, r) {
  let { node: n } = t;
  return cr(n).length === 1 && n.type.startsWith("TS") && !n[r][0].constraint && t.parent.type === "ArrowFunctionExpression" && !(e.filepath && /\.ts$/.test(e.filepath));
}
function Tl(t, e, r, n) {
  let { node: i } = t;
  if (!i[n])
    return "";
  if (!Array.isArray(i[n]))
    return r(n);
  let s = t.getNode(2), a = s && Vp(s), o = t.match((c) => !(c[n].length === 1 && ms(c[n][0])), void 0, (c, h) => h === "typeAnnotation", (c) => c.type === "Identifier", Mw);
  if (i[n].length === 0 || !o && (a || i[n].length === 1 && (i[n][0].type === "NullableTypeAnnotation" || jw(i[n][0]))))
    return ["<", Re(", ", t.map(r, n)), bR(t, e), ">"];
  let u = i.type === "TSTypeParameterInstantiation" ? "" : xR(t, e, n) ? "," : Cs(e) ? Fe(",") : "";
  return Z(["<", te([K, Re([",", de], t.map(r, n))]), u, K, ">"], { id: r0(i) });
}
function bR(t, e) {
  let { node: r } = t;
  if (!ae(r, fe.Dangling))
    return "";
  let n = !ae(r, fe.Line), i = yt(t, e, { indent: !n });
  return n ? i : [i, ee];
}
function yC(t, e, r) {
  let { node: n, parent: i } = t, s = [n.type === "TSTypeParameter" && n.const ? "const " : ""], a = n.type === "TSTypeParameter" ? r("name") : n.name;
  if (i.type === "TSMappedType")
    return i.readonly && s.push(gC(i.readonly, "readonly"), " "), s.push("[", a), n.constraint && s.push(" in ", r("constraint")), i.nameType && s.push(" as ", t.callParent(() => r("nameType"))), s.push("]"), s;
  if (n.variance && s.push(r("variance")), n.in && s.push("in "), n.out && s.push("out "), s.push(a), n.bound && (n.usesExtendsBound && s.push(" extends "), s.push(Gt(t, r, "bound"))), n.constraint) {
    let o = Symbol("constraint");
    s.push(" extends", Z(te(de), { id: o }), Ci, Up(r("constraint"), { groupId: o }));
  }
  return n.default && s.push(" = ", r("default")), Z(s);
}
var OC = tt(["ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
function xC(t, e, r) {
  let { node: n } = t, i = [On(t), Gp(t), "class"], s = ae(n.id, fe.Trailing) || ae(n.typeParameters, fe.Trailing) || ae(n.superClass) || Ve(n.extends) || Ve(n.mixins) || Ve(n.implements), a = [], o = [];
  if (n.id && a.push(" ", r("id")), a.push(r("typeParameters")), n.superClass) {
    let u = [vR(t, e, r), r("superTypeParameters")], c = t.call((h) => ["extends ", Bn(h, u, e)], "superClass");
    s ? o.push(de, Z(c)) : o.push(" ", c);
  } else
    o.push(zd(t, e, r, "extends"));
  if (o.push(zd(t, e, r, "mixins"), zd(t, e, r, "implements")), s) {
    let u;
    vC(n) ? u = [...a, te(o)] : u = te([...a, o]), i.push(Z(u, { id: bC(n) }));
  } else
    i.push(...a, ...o);
  return i.push(" ", r("body")), i;
}
var bC = mC("heritageGroup");
function DC(t) {
  return Fe(ee, "", { groupId: bC(t) });
}
function DR(t) {
  return ["extends", "mixins", "implements"].reduce((e, r) => e + (Array.isArray(t[r]) ? t[r].length : 0), t.superClass ? 1 : 0) > 1;
}
function vC(t) {
  return t.typeParameters && !ae(t.typeParameters, fe.Trailing | fe.Line) && !DR(t);
}
function zd(t, e, r, n) {
  let { node: i } = t;
  if (!Ve(i[n]))
    return "";
  let s = yt(t, e, { marker: n });
  return [vC(i) ? Fe(" ", de, { groupId: r0(i.typeParameters) }) : de, s, s && ee, n, Z(te([de, Re([",", de], t.map(r, n))]))];
}
function vR(t, e, r) {
  let n = r("superClass"), { parent: i } = t;
  return i.type === "AssignmentExpression" ? Z(Fe(["(", te([K, n]), K, ")"], n)) : n;
}
function SC(t, e, r) {
  let { node: n } = t, i = [];
  return Ve(n.decorators) && i.push(Pw(t, e, r)), i.push(Ah(n)), n.static && i.push("static "), i.push(Gp(t)), n.override && i.push("override "), i.push(xm(t, e, r)), i;
}
function wC(t, e, r) {
  let { node: n } = t, i = [], s = e.semi ? ";" : "";
  Ve(n.decorators) && i.push(Pw(t, e, r)), i.push(Ah(n), On(t)), n.static && i.push("static "), i.push(Gp(t)), n.override && i.push("override "), n.readonly && i.push("readonly "), n.variance && i.push(r("variance")), (n.type === "ClassAccessorProperty" || n.type === "AccessorProperty" || n.type === "TSAbstractAccessorProperty") && i.push("accessor "), i.push($u(t, e, r), gr(t), tC(t), Gt(t, r));
  let a = n.type === "TSAbstractPropertyDefinition" || n.type === "TSAbstractAccessorProperty";
  return [Pu(t, e, r, i, " =", a ? void 0 : "value"), s];
}
function SR(t, e, r) {
  let { node: n } = t, i = [];
  return t.each(({ node: s, next: a, isLast: o }) => {
    i.push(r()), !e.semi && OC(s) && wR(s, a) && i.push(";"), o || (i.push(ee), Es(s, e) && i.push(ee));
  }, "body"), ae(n, fe.Dangling) && i.push(yt(t, e)), [Ve(n.body) ? DC(t.parent) : "", "{", i.length > 0 ? [te([ee, i]), ee] : "", "}"];
}
function wR(t, e) {
  var r;
  let { type: n, name: i } = t.key;
  if (!t.computed && n === "Identifier" && (i === "static" || i === "get" || i === "set") && !t.value && !t.typeAnnotation)
    return !0;
  if (!e || e.static || e.accessibility)
    return !1;
  if (!e.computed) {
    let s = (r = e.key) == null ? void 0 : r.name;
    if (s === "in" || s === "instanceof")
      return !0;
  }
  if (OC(e) && e.variance && !e.static && !e.declare)
    return !0;
  switch (e.type) {
    case "ClassProperty":
    case "PropertyDefinition":
    case "TSAbstractPropertyDefinition":
      return e.computed;
    case "MethodDefinition":
    case "TSAbstractMethodDefinition":
    case "ClassMethod":
    case "ClassPrivateMethod": {
      if ((e.value ? e.value.async : e.async) || e.kind === "get" || e.kind === "set")
        return !1;
      let s = e.value ? e.value.generator : e.generator;
      return !!(e.computed || s);
    }
    case "TSIndexSignature":
      return !0;
  }
  return !1;
}
function CR(t, e) {
  if (e.semi || EC(t, e) || TC(t, e))
    return !1;
  let { node: r, key: n, parent: i } = t;
  return !!(r.type === "ExpressionStatement" && (n === "body" && (i.type === "Program" || i.type === "BlockStatement" || i.type === "StaticBlock" || i.type === "TSModuleBlock") || n === "consequent" && i.type === "SwitchCase") && t.call(() => CC(t, e), "expression"));
}
function CC(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "ParenthesizedExpression":
    case "TypeCastExpression":
    case "ArrayExpression":
    case "ArrayPattern":
    case "TemplateLiteral":
    case "TemplateElement":
    case "RegExpLiteral":
      return !0;
    case "ArrowFunctionExpression":
      if (!uC(t, e))
        return !0;
      break;
    case "UnaryExpression": {
      let { prefix: n, operator: i } = r;
      if (n && (i === "+" || i === "-"))
        return !0;
      break;
    }
    case "BindExpression":
      if (!r.object)
        return !0;
      break;
    case "Literal":
      if (r.regex)
        return !0;
      break;
    default:
      if (Lt(r))
        return !0;
  }
  return Da(t, e) ? !0 : Ly(r) ? t.call(() => CC(t, e), ...jS(r)) : !1;
}
function EC({ node: t, parent: e }, r) {
  return (r.parentParser === "markdown" || r.parentParser === "mdx") && t.type === "ExpressionStatement" && Lt(t.expression) && e.type === "Program" && e.body.length === 1;
}
function AC(t) {
  switch (t.type) {
    case "MemberExpression":
      switch (t.property.type) {
        case "Identifier":
        case "NumericLiteral":
        case "StringLiteral":
          return AC(t.object);
      }
      return !1;
    case "Identifier":
      return !0;
    default:
      return !1;
  }
}
function TC({ node: t, parent: e }, r) {
  return (r.parser === "__vue_event_binding" || r.parser === "__vue_ts_event_binding") && t.type === "ExpressionStatement" && e.type === "Program" && e.body.length === 1;
}
function ER(t, e, r) {
  let n = [r("expression")];
  return TC(t, e) ? AC(t.node.expression) && n.push(";") : EC(t, e) || e.semi && n.push(";"), n;
}
function AR(t, e, r) {
  if (e.__isVueBindings || e.__isVueForBindingLeft) {
    let n = t.map(r, "program", "body", 0, "params");
    if (n.length === 1)
      return n[0];
    let i = Re([",", de], n);
    return e.__isVueForBindingLeft ? ["(", te([K, Z(i)]), K, ")"] : i;
  }
  if (e.__isEmbeddedTypescriptGenericParameters) {
    let n = t.map(r, "program", "body", 0, "typeParameters", "params");
    return Re([",", de], n);
  }
}
function TR(t, e) {
  let { node: r } = t;
  switch (r.type) {
    case "RegExpLiteral":
      return z1(r);
    case "BigIntLiteral":
      return Dm(r.extra.raw);
    case "NumericLiteral":
      return ns(r.extra.raw);
    case "StringLiteral":
      return ta(Wl(r.extra.raw, e));
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return String(r.value);
    case "DecimalLiteral":
      return ns(r.value) + "m";
    case "DirectiveLiteral":
      return G1(r.extra.raw, e);
    case "Literal": {
      if (r.regex)
        return z1(r.regex);
      if (r.bigint)
        return Dm(r.raw);
      if (r.decimal)
        return ns(r.decimal) + "m";
      let { value: n } = r;
      return typeof n == "number" ? ns(r.raw) : typeof n == "string" ? kR(t) ? G1(r.raw, e) : ta(Wl(r.raw, e)) : String(n);
    }
  }
}
function kR(t) {
  if (t.key !== "expression")
    return;
  let { parent: e } = t;
  return e.type === "ExpressionStatement" && e.directive;
}
function Dm(t) {
  return t.toLowerCase();
}
function z1({ pattern: t, flags: e }) {
  return e = [...e].sort().join(""), `/${t}/${e}`;
}
function G1(t, e) {
  let r = t.slice(1, -1);
  if (r.includes('"') || r.includes("'"))
    return t;
  let n = e.singleQuote ? "'" : '"';
  return n + r + n;
}
function PR(t, e, r) {
  let n = t.originalText.slice(e, r);
  for (let i of t[Symbol.for("comments")]) {
    let s = mt(i);
    if (s > r)
      break;
    let a = Ye(i);
    if (a < e)
      continue;
    let o = a - s;
    n = n.slice(0, s - e) + " ".repeat(o) + n.slice(a - e);
  }
  return n;
}
var n0 = PR;
function FR(t, e, r) {
  let { node: n } = t;
  return ["import", n.module ? " module" : "", n.phase ? ` ${n.phase}` : "", FC(n), BC(t, e, r), $C(t, e, r), NC(t, e, r), e.semi ? ";" : ""];
}
var kC = (t) => t.type === "ExportDefaultDeclaration" || t.type === "DeclareExportDeclaration" && t.default;
function PC(t, e, r) {
  let { node: n } = t, i = [mL(t, e, r), On(t), "export", kC(n) ? " default" : ""], { declaration: s, exported: a } = n;
  return ae(n, fe.Dangling) && (i.push(" ", yt(t, e)), HS(n) && i.push(ee)), s ? i.push(" ", r("declaration")) : (i.push(IR(n)), n.type === "ExportAllDeclaration" || n.type === "DeclareExportAllDeclaration" ? (i.push(" *"), a && i.push(" as ", r("exported"))) : i.push(BC(t, e, r)), i.push($C(t, e, r), NC(t, e, r))), i.push(BR(n, e)), i;
}
var $R = tt(["ClassDeclaration", "FunctionDeclaration", "TSInterfaceDeclaration", "DeclareClass", "DeclareFunction", "TSDeclareFunction", "EnumDeclaration"]);
function BR(t, e) {
  return e.semi && (!t.declaration || kC(t) && !$R(t.declaration)) ? ";" : "";
}
function i0(t, e = !0) {
  return t && t !== "value" ? `${e ? " " : ""}${t}${e ? "" : " "}` : "";
}
function FC(t, e) {
  return i0(t.importKind, e);
}
function IR(t) {
  return i0(t.exportKind);
}
function $C(t, e, r) {
  let { node: n } = t;
  if (!n.source)
    return "";
  let i = [];
  return IC(n, e) && i.push(" from"), i.push(" ", r("source")), i;
}
function BC(t, e, r) {
  let { node: n } = t;
  if (!IC(n, e))
    return "";
  let i = [" "];
  if (Ve(n.specifiers)) {
    let s = [], a = [];
    t.each(() => {
      let o = t.node.type;
      if (o === "ExportNamespaceSpecifier" || o === "ExportDefaultSpecifier" || o === "ImportNamespaceSpecifier" || o === "ImportDefaultSpecifier")
        s.push(r());
      else if (o === "ExportSpecifier" || o === "ImportSpecifier")
        a.push(r());
      else
        throw new $o(n, "specifier");
    }, "specifiers"), i.push(Re(", ", s)), a.length > 0 && (s.length > 0 && i.push(", "), a.length > 1 || s.length > 0 || n.specifiers.some((o) => ae(o)) ? i.push(Z(["{", te([e.bracketSpacing ? de : K, Re([",", de], a)]), Fe(Cs(e) ? "," : ""), e.bracketSpacing ? de : K, "}"])) : i.push(["{", e.bracketSpacing ? " " : "", ...a, e.bracketSpacing ? " " : "", "}"]));
  } else
    i.push("{}");
  return i;
}
function IC(t, e) {
  return t.type !== "ImportDeclaration" || Ve(t.specifiers) || t.importKind === "type" ? !0 : n0(e, mt(t), mt(t.source)).trimEnd().endsWith("from");
}
function NR(t, e) {
  var r, n;
  if ((r = t.extra) != null && r.deprecatedAssertSyntax)
    return "assert";
  let i = n0(e, Ye(t.source), (n = t.attributes) != null && n[0] ? mt(t.attributes[0]) : Ye(t)).trimStart();
  return i.startsWith("assert") ? "assert" : i.startsWith("with") || Ve(t.attributes) ? "with" : void 0;
}
function NC(t, e, r) {
  let { node: n } = t;
  if (!n.source)
    return "";
  let i = NR(n, e);
  if (!i)
    return "";
  let s = [` ${i} {`];
  return Ve(n.attributes) && (e.bracketSpacing && s.push(" "), s.push(Re(", ", t.map(r, "attributes"))), e.bracketSpacing && s.push(" ")), s.push("}"), s;
}
function _R(t, e, r) {
  let { node: n } = t, { type: i } = n, s = i.startsWith("Import"), a = s ? "imported" : "local", o = s ? "local" : "exported", u = n[a], c = n[o], h = "", p = "";
  return i === "ExportNamespaceSpecifier" || i === "ImportNamespaceSpecifier" ? h = "*" : u && (h = r(a)), c && !QR(n) && (p = r(o)), [i0(i === "ImportSpecifier" ? n.importKind : n.exportKind, !1), h, h && p ? " as " : "", p];
}
function QR(t) {
  if (t.type !== "ImportSpecifier" && t.type !== "ExportSpecifier")
    return !1;
  let { local: e, [t.type === "ImportSpecifier" ? "imported" : "exported"]: r } = t;
  if (e.type !== r.type || !a4(e, r))
    return !1;
  if (Tr(e))
    return e.value === r.value && mn(e) === mn(r);
  switch (e.type) {
    case "Identifier":
      return e.name === r.name;
    default:
      return !1;
  }
}
function Hp(t, e, r) {
  var n;
  let i = e.semi ? ";" : "", { node: s } = t, a = s.type === "ObjectTypeAnnotation", o = s.type === "TSEnumDeclaration" || s.type === "EnumBooleanBody" || s.type === "EnumNumberBody" || s.type === "EnumStringBody" || s.type === "EnumSymbolBody", u = [s.type === "TSTypeLiteral" || o ? "members" : s.type === "TSInterfaceBody" ? "body" : "properties"];
  a && u.push("indexers", "callProperties", "internalSlots");
  let c = u.flatMap((A) => t.map(({ node: P }) => ({ node: P, printed: r(), loc: mt(P) }), A));
  u.length > 1 && c.sort((A, P) => A.loc - P.loc);
  let { parent: h, key: p } = t, m = a && p === "body" && (h.type === "InterfaceDeclaration" || h.type === "DeclareInterface" || h.type === "DeclareClass"), g = s.type === "TSInterfaceBody" || o || m || s.type === "ObjectPattern" && h.type !== "FunctionDeclaration" && h.type !== "FunctionExpression" && h.type !== "ArrowFunctionExpression" && h.type !== "ObjectMethod" && h.type !== "ClassMethod" && h.type !== "ClassPrivateMethod" && h.type !== "AssignmentPattern" && h.type !== "CatchClause" && s.properties.some((A) => A.value && (A.value.type === "ObjectPattern" || A.value.type === "ArrayPattern")) || s.type !== "ObjectPattern" && c.length > 0 && gs(e.originalText, mt(s), c[0].loc), O = m ? ";" : s.type === "TSInterfaceBody" || s.type === "TSTypeLiteral" ? Fe(i, ";") : ",", b = s.type === "RecordExpression" ? "#{" : s.exact ? "{|" : "{", D = s.exact ? "|}" : "}", S = [], x = c.map((A) => {
    let P = [...S, Z(A.printed)];
    return S = [O, de], (A.node.type === "TSPropertySignature" || A.node.type === "TSMethodSignature" || A.node.type === "TSConstructSignatureDeclaration" || A.node.type === "TSCallSignatureDeclaration") && ae(A.node, fe.PrettierIgnore) && S.shift(), Es(A.node, e) && S.push(ee), P;
  });
  if (s.inexact || s.hasUnknownMembers) {
    let A;
    if (ae(s, fe.Dangling)) {
      let P = ae(s, fe.Line);
      A = [yt(t, e), P || Hr(e.originalText, Ye(ze(!1, Ua(s), -1))) ? ee : de, "..."];
    } else
      A = ["..."];
    x.push([...S, ...A]);
  }
  let w = (n = ze(!1, c, -1)) == null ? void 0 : n.node, T = !(s.inexact || s.hasUnknownMembers || w && (w.type === "RestElement" || (w.type === "TSPropertySignature" || w.type === "TSCallSignatureDeclaration" || w.type === "TSMethodSignature" || w.type === "TSConstructSignatureDeclaration") && ae(w, fe.PrettierIgnore))), C;
  if (x.length === 0) {
    if (!ae(s, fe.Dangling))
      return [b, D, Gt(t, r)];
    C = Z([b, yt(t, e, { indent: !0 }), K, D, gr(t), Gt(t, r)]);
  } else
    C = [m && Ve(s.properties) ? DC(h) : "", b, te([e.bracketSpacing ? de : K, ...x]), Fe(T && (O !== "," || Cs(e)) ? O : ""), e.bracketSpacing ? de : K, D, gr(t), Gt(t, r)];
  return t.match((A) => A.type === "ObjectPattern" && !Ve(A.decorators), Gd) || ms(s) && (t.match(void 0, (A, P) => P === "typeAnnotation", (A, P) => P === "typeAnnotation", Gd) || t.match(void 0, (A, P) => A.type === "FunctionTypeParam" && P === "typeAnnotation", Gd)) || !g && t.match((A) => A.type === "ObjectPattern", (A) => A.type === "AssignmentExpression" || A.type === "VariableDeclarator") ? C : Z(C, { shouldBreak: g });
}
function Gd(t, e) {
  return (e === "params" || e === "parameters" || e === "this" || e === "rest") && Rw(t);
}
function MR(t) {
  let e = [t];
  for (let r = 0; r < e.length; r++) {
    let n = e[r];
    for (let i of ["test", "consequent", "alternate"]) {
      let s = n[i];
      if (Lt(s))
        return !0;
      s.type === "ConditionalExpression" && e.push(s);
    }
  }
  return !1;
}
function LR(t, e, r) {
  let { node: n } = t, i = n.type === "ConditionalExpression", s = i ? "alternate" : "falseType", { parent: a } = t, o = i ? r("test") : [r("checkType"), " ", "extends", " ", r("extendsType")];
  return a.type === n.type && a[s] === n ? li(2, o) : o;
}
var RR = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
function jR(t) {
  let { node: e } = t;
  if (e.type !== "ConditionalExpression")
    return !1;
  let r, n = e;
  for (let i = 0; !r; i++) {
    let s = t.getParentNode(i);
    if (s.type === "ChainExpression" && s.expression === n || qe(s) && s.callee === n || ft(s) && s.object === n || s.type === "TSNonNullExpression" && s.expression === n) {
      n = s;
      continue;
    }
    s.type === "NewExpression" && s.callee === n || Hn(s) && s.expression === n ? (r = t.getParentNode(i + 1), n = s) : r = s;
  }
  return n === e ? !1 : r[RR.get(r.type)] === n;
}
function ZR(t, e, r) {
  let { node: n } = t, i = n.type === "ConditionalExpression", s = i ? "consequent" : "trueType", a = i ? "alternate" : "falseType", o = i ? ["test"] : ["checkType", "extendsType"], u = n[s], c = n[a], h = [], p = !1, { parent: m } = t, g = m.type === n.type && o.some((B) => m[B] === n), O = m.type === n.type && !g, b, D, S = 0;
  do
    D = b || n, b = t.getParentNode(S), S++;
  while (b && b.type === n.type && o.every((B) => b[B] !== D));
  let x = b || m, w = D;
  if (i && (Lt(n[o[0]]) || Lt(u) || Lt(c) || MR(w))) {
    p = !0, O = !0;
    let B = (M) => [Fe("("), te([K, M]), K, Fe(")")], _ = (M) => M.type === "NullLiteral" || M.type === "Literal" && M.value === null || M.type === "Identifier" && M.name === "undefined";
    h.push(" ? ", _(u) ? r(s) : B(r(s)), " : ", c.type === n.type || _(c) ? r(a) : B(r(a)));
  } else {
    let B = (M) => e.useTabs ? te(r(M)) : li(2, r(M)), _ = [de, "? ", u.type === n.type ? Fe("", "(") : "", B(s), u.type === n.type ? Fe("", ")") : "", de, ": ", B(a)];
    h.push(m.type !== n.type || m[a] === n || g ? _ : e.useTabs ? iw(te(_)) : li(Math.max(0, e.tabWidth - 2), _));
  }
  let T = [s, a, ...o].some((B) => ae(n[B], (_) => xn(_) && gs(e.originalText, mt(_), Ye(_)))), C = (B) => m === x ? Z(B, { shouldBreak: T }) : T ? [B, ui] : B, A = !p && (ft(m) || m.type === "NGPipeExpression" && m.left === n) && !m.computed, P = jR(t), $ = C([LR(t, e, r), O ? h : te(h), i && A && !P ? K : ""]);
  return g || P ? Z([te([K, $]), K]) : $;
}
function WR(t, e) {
  return (ft(e) || e.type === "NGPipeExpression" && e.left === t) && !e.computed;
}
function qR(t, e, r, n) {
  return [...t.map((i) => Ua(i)), Ua(e), Ua(r)].flat().some((i) => xn(i) && gs(n.originalText, mt(i), Ye(i)));
}
var XR = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
function VR(t) {
  let { node: e } = t;
  if (e.type !== "ConditionalExpression")
    return !1;
  let r, n = e;
  for (let i = 0; !r; i++) {
    let s = t.getParentNode(i);
    if (s.type === "ChainExpression" && s.expression === n || qe(s) && s.callee === n || ft(s) && s.object === n || s.type === "TSNonNullExpression" && s.expression === n) {
      n = s;
      continue;
    }
    s.type === "NewExpression" && s.callee === n || Hn(s) && s.expression === n ? (r = t.getParentNode(i + 1), n = s) : r = s;
  }
  return n === e ? !1 : r[XR.get(r.type)] === n;
}
var Hd = (t) => [Fe("("), te([K, t]), K, Fe(")")];
function s0(t, e, r, n) {
  if (!e.experimentalTernaries)
    return ZR(t, e, r);
  let { node: i } = t, s = i.type === "ConditionalExpression", a = i.type === "TSConditionalType" || i.type === "ConditionalTypeAnnotation", o = s ? "consequent" : "trueType", u = s ? "alternate" : "falseType", c = s ? ["test"] : ["checkType", "extendsType"], h = i[o], p = i[u], m = c.map((we) => i[we]), { parent: g } = t, O = g.type === i.type, b = O && c.some((we) => g[we] === i), D = O && g[u] === i, S = h.type === i.type, x = p.type === i.type, w = x || D, T = e.tabWidth > 2 || e.useTabs, C, A, P = 0;
  do
    A = C || i, C = t.getParentNode(P), P++;
  while (C && C.type === i.type && c.every((we) => C[we] !== A));
  let $ = C || g, B = n && n.assignmentLayout && n.assignmentLayout !== "break-after-operator" && (g.type === "AssignmentExpression" || g.type === "VariableDeclarator" || g.type === "ClassProperty" || g.type === "PropertyDefinition" || g.type === "ClassPrivateProperty" || g.type === "ObjectProperty" || g.type === "Property"), _ = (g.type === "ReturnStatement" || g.type === "ThrowStatement") && !(S || x), M = s && $.type === "JSXExpressionContainer" && t.grandparent.type !== "JSXAttribute", Y = VR(t), J = WR(i, g), R = a && Da(t, e), q = T ? e.useTabs ? "	" : " ".repeat(e.tabWidth - 1) : "", X = qR(m, h, p, e) || S || x, H = !w && !O && !a && (M ? h.type === "NullLiteral" || h.type === "Literal" && h.value === null : jy(h, e) && F1(i.test, 3)), ye = w || D || a && !O || O && s && F1(i.test, 1) || H, Ce = [];
  !S && ae(h, fe.Dangling) && t.call((we) => {
    Ce.push(yt(we, e), ee);
  }, "consequent");
  let Se = [];
  ae(i.test, fe.Dangling) && t.call((we) => {
    Se.push(yt(we, e));
  }, "test"), !x && ae(p, fe.Dangling) && t.call((we) => {
    Se.push(yt(we, e));
  }, "alternate"), ae(i, fe.Dangling) && Se.push(yt(t, e));
  let Ne = Symbol("test"), Te = Symbol("consequent"), Me = Symbol("test-and-consequent"), Ee = s ? [Hd(r("test")), i.test.type === "ConditionalExpression" ? ui : ""] : [r("checkType"), " ", "extends", " ", i.extendsType.type === "TSConditionalType" || i.extendsType.type === "ConditionalTypeAnnotation" || i.extendsType.type === "TSMappedType" ? r("extendsType") : Z(Hd(r("extendsType")))], nt = Z([Ee, " ?"], { id: Ne }), se = r(o), V = te([S || M && (Lt(h) || O || w) ? ee : de, Ce, se]), W = ye ? Z([nt, w ? V : Fe(V, Z(V, { id: Te }), { groupId: Ne })], { id: Me }) : [nt, V], j = r(u), le = H ? Fe(j, iw(Hd(j)), { groupId: Me }) : j, De = [W, Se.length > 0 ? [te([ee, Se]), ee] : x ? ee : H ? Fe(de, " ", { groupId: Me }) : de, ":", x ? " " : T ? ye ? Fe(q, Fe(w || H ? " " : q, " "), { groupId: Me }) : Fe(q, " ") : " ", x ? le : Z([te(le), M && !H ? K : ""]), J && !Y ? K : "", X ? ui : ""];
  return B && !X ? Z(te([K, Z(De)])) : B || _ ? Z(te(De)) : Y || a && b ? Z([te([K, De]), R ? K : ""]) : g === $ ? Z(De) : De;
}
function YR(t, e, r, n) {
  let { node: i } = t;
  if (qp(i))
    return TR(t, e);
  let s = e.semi ? ";" : "", a = [];
  switch (i.type) {
    case "JsExpressionRoot":
      return r("node");
    case "JsonRoot":
      return [r("node"), ee];
    case "File":
      return AR(t, e, r) ?? r("program");
    case "Program":
      return fC(t, e, r);
    case "EmptyStatement":
      return "";
    case "ExpressionStatement":
      return ER(t, e, r);
    case "ChainExpression":
      return r("expression");
    case "ParenthesizedExpression":
      return !ae(i.expression) && (In(i.expression) || Kt(i.expression)) ? ["(", r("expression"), ")"] : Z(["(", te([K, r("expression")]), K, ")"]);
    case "AssignmentExpression":
      return TL(t, e, r);
    case "VariableDeclarator":
      return kL(t, e, r);
    case "BinaryExpression":
    case "LogicalExpression":
      return kw(t, e, r);
    case "AssignmentPattern":
      return [r("left"), " = ", r("right")];
    case "OptionalMemberExpression":
    case "MemberExpression":
      return wL(t, e, r);
    case "MetaProperty":
      return [r("meta"), ".", r("property")];
    case "BindExpression":
      return i.object && a.push(r("object")), a.push(Z(te([K, rC(t, e, r)]))), a;
    case "Identifier":
      return [i.name, gr(t), tC(t), Gt(t, r)];
    case "V8IntrinsicIdentifier":
      return ["%", i.name];
    case "SpreadElement":
    case "SpreadElementPattern":
    case "SpreadPropertyPattern":
    case "RestElement":
      return nC(t, r);
    case "FunctionDeclaration":
    case "FunctionExpression":
      return lC(t, r, e, n);
    case "ArrowFunctionExpression":
      return lR(t, e, r, n);
    case "YieldExpression":
      return a.push("yield"), i.delegate && a.push("*"), i.argument && a.push(" ", r("argument")), a;
    case "AwaitExpression":
      if (a.push("await"), i.argument) {
        a.push(" ", r("argument"));
        let { parent: o } = t;
        if (qe(o) && o.callee === i || ft(o) && o.object === i) {
          a = [te([K, ...a]), K];
          let u = t.findAncestor((c) => c.type === "AwaitExpression" || c.type === "BlockStatement");
          if ((u == null ? void 0 : u.type) !== "AwaitExpression" || !fr(u.argument, (c) => c === i))
            return Z(a);
        }
      }
      return a;
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ExportAllDeclaration":
      return PC(t, e, r);
    case "ImportDeclaration":
      return FR(t, e, r);
    case "ImportSpecifier":
    case "ExportSpecifier":
    case "ImportNamespaceSpecifier":
    case "ExportNamespaceSpecifier":
    case "ImportDefaultSpecifier":
    case "ExportDefaultSpecifier":
      return _R(t, e, r);
    case "ImportAttribute":
      return [r("key"), ": ", r("value")];
    case "Import":
      return "import";
    case "BlockStatement":
    case "StaticBlock":
      return dC(t, e, r);
    case "ClassBody":
      return SR(t, e, r);
    case "ThrowStatement":
      return aR(t, e, r);
    case "ReturnStatement":
      return sR(t, e, r);
    case "NewExpression":
    case "ImportExpression":
    case "OptionalCallExpression":
    case "CallExpression":
      return _w(t, e, r);
    case "ObjectExpression":
    case "ObjectPattern":
    case "RecordExpression":
      return Hp(t, e, r);
    case "Property":
      return Xp(i) ? xm(t, e, r) : U1(t, e, r);
    case "ObjectProperty":
      return U1(t, e, r);
    case "ObjectMethod":
      return xm(t, e, r);
    case "Decorator":
      return ["@", r("expression")];
    case "ArrayExpression":
    case "ArrayPattern":
    case "TupleExpression":
      return Ky(t, e, r);
    case "SequenceExpression": {
      let { parent: o } = t;
      if (o.type === "ExpressionStatement" || o.type === "ForStatement") {
        let u = [];
        return t.each(({ isFirst: c }) => {
          c ? u.push(r()) : u.push(",", te([de, r()]));
        }, "expressions"), Z(u);
      }
      return Z(Re([",", de], t.map(r, "expressions")));
    }
    case "ThisExpression":
      return "this";
    case "Super":
      return "super";
    case "Directive":
      return [r("value"), s];
    case "UnaryExpression":
      return a.push(i.operator), /[a-z]$/.test(i.operator) && a.push(" "), ae(i.argument) ? a.push(Z(["(", te([K, r("argument")]), K, ")"])) : a.push(r("argument")), a;
    case "UpdateExpression":
      return a.push(r("argument"), i.operator), i.prefix && a.reverse(), a;
    case "ConditionalExpression":
      return s0(t, e, r, n);
    case "VariableDeclaration": {
      let o = t.map(r, "declarations"), u = t.parent, c = u.type === "ForStatement" || u.type === "ForInStatement" || u.type === "ForOfStatement", h = i.declarations.some((m) => m.init), p;
      return o.length === 1 && !ae(i.declarations[0]) ? p = o[0] : o.length > 0 && (p = te(o[0])), a = [On(t), i.kind, p ? [" ", p] : "", te(o.slice(1).map((m) => [",", h && !c ? ee : de, m]))], c && u.body !== i || a.push(s), Z(a);
    }
    case "WithStatement":
      return Z(["with (", r("object"), ")", Ui(i.body, r("body"))]);
    case "IfStatement": {
      let o = Ui(i.consequent, r("consequent")), u = Z(["if (", Z([te([K, r("test")]), K]), ")", o]);
      if (a.push(u), i.alternate) {
        let c = ae(i.consequent, fe.Trailing | fe.Line) || HS(i), h = i.consequent.type === "BlockStatement" && !c;
        a.push(h ? " " : ee), ae(i, fe.Dangling) && a.push(yt(t, e), c ? ee : " "), a.push("else", Z(Ui(i.alternate, r("alternate"), i.alternate.type === "IfStatement")));
      }
      return a;
    }
    case "ForStatement": {
      let o = Ui(i.body, r("body")), u = yt(t, e), c = u ? [u, K] : "";
      return !i.init && !i.test && !i.update ? [c, Z(["for (;;)", o])] : [c, Z(["for (", Z([te([K, r("init"), ";", de, r("test"), ";", de, r("update")]), K]), ")", o])];
    }
    case "WhileStatement":
      return Z(["while (", Z([te([K, r("test")]), K]), ")", Ui(i.body, r("body"))]);
    case "ForInStatement":
      return Z(["for (", r("left"), " in ", r("right"), ")", Ui(i.body, r("body"))]);
    case "ForOfStatement":
      return Z(["for", i.await ? " await" : "", " (", r("left"), " of ", r("right"), ")", Ui(i.body, r("body"))]);
    case "DoWhileStatement": {
      let o = Ui(i.body, r("body"));
      return a = [Z(["do", o])], i.body.type === "BlockStatement" ? a.push(" ") : a.push(ee), a.push("while (", Z([te([K, r("test")]), K]), ")", s), a;
    }
    case "DoExpression":
      return [i.async ? "async " : "", "do ", r("body")];
    case "BreakStatement":
    case "ContinueStatement":
      return a.push(i.type === "BreakStatement" ? "break" : "continue"), i.label && a.push(" ", r("label")), a.push(s), a;
    case "LabeledStatement":
      return i.body.type === "EmptyStatement" ? [r("label"), ":;"] : [r("label"), ": ", r("body")];
    case "TryStatement":
      return ["try ", r("block"), i.handler ? [" ", r("handler")] : "", i.finalizer ? [" finally ", r("finalizer")] : ""];
    case "CatchClause":
      if (i.param) {
        let o = ae(i.param, (c) => !xn(c) || c.leading && Hr(e.originalText, Ye(c)) || c.trailing && Hr(e.originalText, mt(c), { backwards: !0 })), u = r("param");
        return ["catch ", o ? ["(", te([K, u]), K, ") "] : ["(", u, ") "], r("body")];
      }
      return ["catch ", r("body")];
    case "SwitchStatement":
      return [Z(["switch (", te([K, r("discriminant")]), K, ")"]), " {", i.cases.length > 0 ? te([ee, Re(ee, t.map(({ node: o, isLast: u }) => [r(), !u && Es(o, e) ? ee : ""], "cases"))]) : "", ee, "}"];
    case "SwitchCase": {
      i.test ? a.push("case ", r("test"), ":") : a.push("default:"), ae(i, fe.Dangling) && a.push(" ", yt(t, e));
      let o = i.consequent.filter((u) => u.type !== "EmptyStatement");
      if (o.length > 0) {
        let u = bm(t, e, r, "consequent");
        a.push(o.length === 1 && o[0].type === "BlockStatement" ? [" ", u] : te([ee, u]));
      }
      return a;
    }
    case "DebuggerStatement":
      return ["debugger", s];
    case "ClassDeclaration":
    case "ClassExpression":
      return xC(t, e, r);
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "MethodDefinition":
      return SC(t, e, r);
    case "ClassProperty":
    case "PropertyDefinition":
    case "ClassPrivateProperty":
    case "ClassAccessorProperty":
    case "AccessorProperty":
      return wC(t, e, r);
    case "TemplateElement":
      return ta(i.value.raw);
    case "TemplateLiteral":
      return Dw(t, r, e);
    case "TaggedTemplateExpression":
      return Y6(r);
    case "PrivateIdentifier":
      return ["#", i.name];
    case "PrivateName":
      return ["#", r("id")];
    case "TopicReference":
      return "%";
    case "ArgumentPlaceholder":
      return "?";
    case "ModuleExpression": {
      a.push("module {");
      let o = r("body");
      return o && a.push(te([ee, o]), ee), a.push("}"), a;
    }
    case "InterpreterDirective":
    default:
      throw new $o(i, "ESTree");
  }
}
function _C(t, e, r) {
  let { parent: n, node: i, key: s } = t, a = [r("expression")];
  switch (i.type) {
    case "AsConstExpression":
      a.push(" as const");
      break;
    case "AsExpression":
    case "TSAsExpression":
      a.push(" as ", r("typeAnnotation"));
      break;
    case "SatisfiesExpression":
    case "TSSatisfiesExpression":
      a.push(" satisfies ", r("typeAnnotation"));
      break;
  }
  return s === "callee" && qe(n) || s === "object" && ft(n) ? Z([te([K, ...a]), K]) : a;
}
function QC(t, e, r) {
  return Hp(t, r, e);
}
function MC(t, e) {
  let { node: r } = t, n = e("id");
  r.computed && (n = ["[", n, "]"]);
  let i = "";
  return r.initializer && (i = e("initializer")), r.init && (i = e("init")), i ? [n, " = ", i] : n;
}
function UR(t, e, r) {
  let { node: n } = t, i;
  if (n.type === "EnumSymbolBody" || n.explicitType)
    switch (n.type) {
      case "EnumBooleanBody":
        i = "boolean";
        break;
      case "EnumNumberBody":
        i = "number";
        break;
      case "EnumStringBody":
        i = "string";
        break;
      case "EnumSymbolBody":
        i = "symbol";
        break;
    }
  return [i ? `of ${i} ` : "", QC(t, e, r)];
}
function LC(t, e, r) {
  let { node: n } = t;
  return [On(t), n.const ? "const " : "", "enum ", e("id"), " ", n.type === "TSEnumDeclaration" ? QC(t, e, r) : e("body")];
}
function RC(t, e, r) {
  let { node: n } = t, i = [On(t), "interface"], s = [], a = [];
  n.type !== "InterfaceTypeAnnotation" && s.push(" ", r("id"), r("typeParameters"));
  let o = n.typeParameters && !ae(n.typeParameters, fe.Trailing | fe.Line);
  return Ve(n.extends) && a.push(o ? Fe(" ", de, { groupId: r0(n.typeParameters) }) : de, "extends ", (n.extends.length === 1 ? F4 : te)(Re([",", de], t.map(r, "extends")))), ae(n.id, fe.Trailing) || Ve(n.extends) ? o ? i.push(Z([...s, te(a)])) : i.push(Z(te([...s, ...a]))) : i.push(...s, ...a), i.push(" ", r("body")), Z(i);
}
function zR(t, e, r) {
  let { node: n } = t;
  if (LS(n))
    return n.type.slice(0, -14).toLowerCase();
  let i = e.semi ? ";" : "";
  switch (n.type) {
    case "DeclareClass":
      return xC(t, e, r);
    case "DeclareFunction":
      return [On(t), "function ", r("id"), r("predicate"), i];
    case "DeclareModule":
      return ["declare module ", r("id"), " ", r("body")];
    case "DeclareModuleExports":
      return ["declare module.exports", Gt(t, r), i];
    case "DeclareVariable":
      return [On(t), n.kind ?? "var", " ", r("id"), i];
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
      return PC(t, e, r);
    case "DeclareOpaqueType":
    case "OpaqueType":
      return UL(t, e, r);
    case "DeclareTypeAlias":
    case "TypeAlias":
      return Zw(t, e, r);
    case "IntersectionTypeAnnotation":
      return Ww(t, e, r);
    case "UnionTypeAnnotation":
      return qw(t, e, r);
    case "ConditionalTypeAnnotation":
      return s0(t, e, r);
    case "InferTypeAnnotation":
      return Yw(t, e, r);
    case "FunctionTypeAnnotation":
      return Xw(t, e, r);
    case "TupleTypeAnnotation":
      return Ky(t, e, r);
    case "TupleTypeLabeledElement":
      return zw(t, e, r);
    case "TupleTypeSpreadElement":
      return Uw(t, e, r);
    case "GenericTypeAnnotation":
      return [r("id"), Tl(t, e, r, "typeParameters")];
    case "IndexedAccessType":
    case "OptionalIndexedAccessType":
      return Vw(t, e, r);
    case "TypeAnnotation":
      return Hw(t, e, r);
    case "TypeParameter":
      return yC(t, e, r);
    case "TypeofTypeAnnotation":
      return Kw(t, r);
    case "ExistsTypeAnnotation":
      return "*";
    case "ArrayTypeAnnotation":
      return Jw(r);
    case "DeclareEnum":
    case "EnumDeclaration":
      return LC(t, r, e);
    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
      return UR(t, r, e);
    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumStringMember":
    case "EnumDefaultedMember":
      return MC(t, r);
    case "FunctionTypeParam": {
      let s = n.name ? r("name") : t.parent.this === n ? "this" : "";
      return [s, gr(t), s ? ": " : "", r("typeAnnotation")];
    }
    case "DeclareInterface":
    case "InterfaceDeclaration":
    case "InterfaceTypeAnnotation":
      return RC(t, e, r);
    case "ClassImplements":
    case "InterfaceExtends":
      return [r("id"), r("typeParameters")];
    case "NullableTypeAnnotation":
      return ["?", r("typeAnnotation")];
    case "Variance": {
      let { kind: s } = n;
      return oC.ok(s === "plus" || s === "minus"), s === "plus" ? "+" : "-";
    }
    case "KeyofTypeAnnotation":
      return ["keyof ", r("argument")];
    case "ObjectTypeCallProperty":
      return [n.static ? "static " : "", r("value")];
    case "ObjectTypeMappedTypeProperty":
      return yR(t, e, r);
    case "ObjectTypeIndexer":
      return [n.static ? "static " : "", n.variance ? r("variance") : "", "[", r("id"), n.id ? ": " : "", r("key"), "]: ", r("value")];
    case "ObjectTypeProperty": {
      let s = "";
      return n.proto ? s = "proto " : n.static && (s = "static "), [s, n.kind !== "init" ? n.kind + " " : "", n.variance ? r("variance") : "", $u(t, e, r), gr(t), Xp(n) ? "" : ": ", r("value")];
    }
    case "ObjectTypeAnnotation":
      return Hp(t, e, r);
    case "ObjectTypeInternalSlot":
      return [n.static ? "static " : "", "[[", r("id"), "]]", gr(t), n.method ? "" : ": ", r("value")];
    case "ObjectTypeSpreadProperty":
      return nC(t, r);
    case "QualifiedTypeofIdentifier":
    case "QualifiedTypeIdentifier":
      return [r("qualification"), ".", r("id")];
    case "NullLiteralTypeAnnotation":
      return "null";
    case "BooleanLiteralTypeAnnotation":
      return String(n.value);
    case "StringLiteralTypeAnnotation":
      return ta(Wl(mn(n), e));
    case "NumberLiteralTypeAnnotation":
      return ns(n.raw ?? n.extra.raw);
    case "BigIntLiteralTypeAnnotation":
      return Dm(n.raw ?? n.extra.raw);
    case "TypeCastExpression":
      return ["(", r("expression"), Gt(t, r), ")"];
    case "TypePredicate":
      return eC(t, r);
    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation":
      return Tl(t, e, r, "params");
    case "InferredPredicate":
    case "DeclaredPredicate":
      return [t.key === "predicate" && t.parent.type !== "DeclareFunction" && !t.parent.returnType ? ": " : " ", "%checks", ...n.type === "DeclaredPredicate" ? ["(", r("value"), ")"] : []];
    case "AsExpression":
    case "AsConstExpression":
    case "SatisfiesExpression":
      return _C(t, e, r);
  }
}
function GR(t, e, r) {
  var n;
  let { node: i } = t;
  if (!i.type.startsWith("TS"))
    return;
  if (RS(i))
    return i.type.slice(2, -7).toLowerCase();
  let s = e.semi ? ";" : "", a = [];
  switch (i.type) {
    case "TSThisType":
      return "this";
    case "TSTypeAssertion": {
      let o = !(Kt(i.expression) || In(i.expression)), u = Z(["<", te([K, r("typeAnnotation")]), K, ">"]), c = [Fe("("), te([K, r("expression")]), K, Fe(")")];
      return o ? Ws([[u, r("expression")], [u, Z(c, { shouldBreak: !0 })], [u, r("expression")]]) : Z([u, r("expression")]);
    }
    case "TSDeclareFunction":
      return lC(t, r, e);
    case "TSExportAssignment":
      return ["export = ", r("expression"), s];
    case "TSModuleBlock":
      return dC(t, e, r);
    case "TSInterfaceBody":
    case "TSTypeLiteral":
      return Hp(t, e, r);
    case "TSTypeAliasDeclaration":
      return Zw(t, e, r);
    case "TSQualifiedName":
      return [r("left"), ".", r("right")];
    case "TSAbstractMethodDefinition":
    case "TSDeclareMethod":
      return SC(t, e, r);
    case "TSAbstractAccessorProperty":
    case "TSAbstractPropertyDefinition":
      return wC(t, e, r);
    case "TSInterfaceHeritage":
    case "TSClassImplements":
    case "TSExpressionWithTypeArguments":
    case "TSInstantiationExpression":
      return [r("expression"), r("typeParameters")];
    case "TSTemplateLiteralType":
      return Dw(t, r, e);
    case "TSNamedTupleMember":
      return zw(t, e, r);
    case "TSRestType":
      return Uw(t, e, r);
    case "TSOptionalType":
      return [r("typeAnnotation"), "?"];
    case "TSInterfaceDeclaration":
      return RC(t, e, r);
    case "TSTypeParameterDeclaration":
    case "TSTypeParameterInstantiation":
      return Tl(t, e, r, "params");
    case "TSTypeParameter":
      return yC(t, e, r);
    case "TSAsExpression":
    case "TSSatisfiesExpression":
      return _C(t, e, r);
    case "TSArrayType":
      return Jw(r);
    case "TSPropertySignature":
      return [i.readonly ? "readonly " : "", $u(t, e, r), gr(t), Gt(t, r)];
    case "TSParameterProperty":
      return [Ah(i), i.static ? "static " : "", i.override ? "override " : "", i.readonly ? "readonly " : "", r("parameter")];
    case "TSTypeQuery":
      return Kw(t, r);
    case "TSIndexSignature": {
      let o = i.parameters.length > 1 ? Fe(Cs(e) ? "," : "") : "", u = Z([te([K, Re([", ", K], t.map(r, "parameters"))]), o, K]), c = t.parent.type === "ClassBody" && t.key === "body";
      return [c && i.static ? "static " : "", i.readonly ? "readonly " : "", "[", i.parameters ? u : "", "]", Gt(t, r), c ? s : ""];
    }
    case "TSTypePredicate":
      return eC(t, r);
    case "TSNonNullExpression":
      return [r("expression"), "!"];
    case "TSImportType":
      return [i.isTypeOf ? "typeof " : "", "import(", r("argument"), ")", i.qualifier ? [".", r("qualifier")] : "", Tl(t, e, r, i.typeArguments ? "typeArguments" : "typeParameters")];
    case "TSLiteralType":
      return r("literal");
    case "TSIndexedAccessType":
      return Vw(t, e, r);
    case "TSTypeOperator":
      return [i.operator, " ", r("typeAnnotation")];
    case "TSMappedType":
      return OR(t, e, r);
    case "TSMethodSignature": {
      let o = i.kind && i.kind !== "method" ? `${i.kind} ` : "";
      a.push(Ah(i), o, i.computed ? "[" : "", r("key"), i.computed ? "]" : "", gr(t));
      let u = Fu(t, r, e, !1, !0), c = i.returnType ? "returnType" : "typeAnnotation", h = i[c], p = h ? Gt(t, r, c) : "", m = zp(i, p);
      return a.push(m ? Z(u) : u), h && a.push(Z(p)), Z(a);
    }
    case "TSNamespaceExportDeclaration":
      return ["export as namespace ", r("id"), e.semi ? ";" : ""];
    case "TSEnumDeclaration":
      return LC(t, r, e);
    case "TSEnumMember":
      return MC(t, r);
    case "TSImportEqualsDeclaration":
      return [i.isExport ? "export " : "", "import ", FC(i, !1), r("id"), " = ", r("moduleReference"), e.semi ? ";" : ""];
    case "TSExternalModuleReference":
      return ["require(", r("expression"), ")"];
    case "TSModuleDeclaration": {
      let { parent: o } = t, u = o.type === "TSModuleDeclaration", c = ((n = i.body) == null ? void 0 : n.type) === "TSModuleDeclaration";
      if (u)
        a.push(".");
      else if (a.push(On(t)), !(i.kind === "global" || i.global)) {
        let h = i.kind ?? (Tr(i.id) || n0(e, mt(i), mt(i.id)).trim().endsWith("module") ? "module" : "namespace");
        a.push(h, " ");
      }
      return a.push(r("id")), c ? a.push(r("body")) : i.body ? a.push(" ", Z(r("body"))) : a.push(s), a;
    }
    case "TSConditionalType":
      return s0(t, e, r);
    case "TSInferType":
      return Yw(t, e, r);
    case "TSIntersectionType":
      return Ww(t, e, r);
    case "TSUnionType":
      return qw(t, e, r);
    case "TSFunctionType":
    case "TSCallSignatureDeclaration":
    case "TSConstructorType":
    case "TSConstructSignatureDeclaration":
      return Xw(t, e, r);
    case "TSTupleType":
      return Ky(t, e, r);
    case "TSTypeReference":
      return [r("typeName"), Tl(t, e, r, "typeParameters")];
    case "TSTypeAnnotation":
      return Hw(t, e, r);
    case "TSEmptyBodyFunctionExpression":
      return e0(t, e, r);
    case "TSJSDocAllType":
      return "*";
    case "TSJSDocUnknownType":
      return "?";
    case "TSJSDocNullableType":
      return Y1(t, r, "?");
    case "TSJSDocNonNullableType":
      return Y1(t, r, "!");
    case "TSParenthesizedType":
    default:
      throw new $o(i, "TypeScript");
  }
}
function HR(t, e, r, n) {
  if (Tw(t))
    return PM(t, e);
  for (let i of [pL, sL, zR, GR, YR]) {
    let s = i(t, e, r, n);
    if (s !== void 0)
      return s;
  }
}
var JR = tt(["ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "ClassPrivateProperty", "MethodDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod"]);
function KR(t, e, r, n) {
  var i;
  t.isRoot && ((i = e.__onHtmlBindingRoot) == null || i.call(e, t.node, e));
  let s = HR(t, e, r, n);
  if (!s)
    return "";
  let { node: a } = t;
  if (JR(a))
    return s;
  let o = Ve(a.decorators), u = gL(t, e, r), c = a.type === "ClassExpression";
  if (o && !c)
    return cm(s, (m) => Z([u, m]));
  let h = Da(t, e), p = CR(t, e);
  return !u && !h && !p ? s : cm(s, (m) => [p ? ";" : "", h ? "(" : "", h && c && o ? [te([de, u, m]), de] : [u, m], h ? ")" : ""]);
}
var ej = KR, tj = { avoidAstMutation: !0 }, rj = [{ linguistLanguageId: 174, name: "JSON.stringify", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"], parsers: ["json-stringify"], vscodeLanguageIds: ["json"] }, { linguistLanguageId: 174, name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".all-contributorsrc", ".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "flake.lock", "mcmod.info", ".babelrc", ".jscsrc", ".jshintrc", ".jslintrc", ".swcrc"], parsers: ["json"], vscodeLanguageIds: ["json"] }, { linguistLanguageId: 423, name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".code-workspace", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [], parsers: ["jsonc"], vscodeLanguageIds: ["jsonc"] }, { linguistLanguageId: 175, name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", parsers: ["json5"], vscodeLanguageIds: ["json5"] }], jC = {};
jp(jC, { getVisitorKeys: () => aj, massageAstNode: () => ZC, print: () => oj });
var nj = { JsonRoot: ["node"], ArrayExpression: ["elements"], ObjectExpression: ["properties"], ObjectProperty: ["key", "value"], UnaryExpression: ["argument"], NullLiteral: [], BooleanLiteral: [], StringLiteral: [], NumericLiteral: [], Identifier: [], TemplateLiteral: ["quasis"], TemplateElement: [] }, ij = nj, sj = QS(ij), aj = sj;
function oj(t, e, r) {
  let { node: n } = t;
  switch (n.type) {
    case "JsonRoot":
      return [r("node"), ee];
    case "ArrayExpression": {
      if (n.elements.length === 0)
        return "[]";
      let i = t.map(() => t.node === null ? "null" : r(), "elements");
      return ["[", te([ee, Re([",", ee], i)]), ee, "]"];
    }
    case "ObjectExpression":
      return n.properties.length === 0 ? "{}" : ["{", te([ee, Re([",", ee], t.map(r, "properties"))]), ee, "}"];
    case "ObjectProperty":
      return [r("key"), ": ", r("value")];
    case "UnaryExpression":
      return [n.operator === "+" ? "" : n.operator, r("argument")];
    case "NullLiteral":
      return "null";
    case "BooleanLiteral":
      return n.value ? "true" : "false";
    case "StringLiteral":
      return JSON.stringify(n.value);
    case "NumericLiteral":
      return H1(t) ? JSON.stringify(String(n.value)) : JSON.stringify(n.value);
    case "Identifier":
      return H1(t) ? JSON.stringify(n.name) : n.name;
    case "TemplateLiteral":
      return r(["quasis", 0]);
    case "TemplateElement":
      return JSON.stringify(n.value.cooked);
    default:
      throw new $o(n, "JSON");
  }
}
function H1(t) {
  return t.key === "key" && t.parent.type === "ObjectProperty";
}
var lj = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
function ZC(t, e) {
  let { type: r } = t;
  if (r === "ObjectProperty") {
    let { key: n } = t;
    n.type === "Identifier" ? e.key = { type: "StringLiteral", value: n.name } : n.type === "NumericLiteral" && (e.key = { type: "StringLiteral", value: String(n.value) });
    return;
  }
  if (r === "UnaryExpression" && t.operator === "+")
    return e.argument;
  if (r === "ArrayExpression") {
    for (let [n, i] of t.elements.entries())
      i === null && e.elements.splice(n, 0, { type: "NullLiteral" });
    return;
  }
  if (r === "TemplateLiteral")
    return { type: "StringLiteral", value: t.quasis[0].value.cooked };
}
ZC.ignoredProperties = lj;
var xc = { bracketSpacing: { category: "Common", type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: !1, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: !1, description: "Enforce single attribute per line in HTML, Vue and JSX." } }, Is = "JavaScript", uj = { arrowParens: { category: Is, type: "choice", default: "always", description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: xc.bracketSameLine, bracketSpacing: xc.bracketSpacing, jsxBracketSameLine: { category: Is, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { category: Is, type: "boolean", default: !0, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, experimentalTernaries: { category: Is, type: "boolean", default: !1, description: "Use curious ternaries, with the question mark after the condition.", oppositeDescription: "Default behavior of ternaries; keep question marks on the same line as the consequent." }, singleQuote: xc.singleQuote, jsxSingleQuote: { category: Is, type: "boolean", default: !1, description: "Use single quotes in JSX." }, quoteProps: { category: Is, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { category: Is, type: "choice", default: "all", description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "all", description: "Trailing commas wherever possible (including function arguments)." }, { value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }] }, singleAttributePerLine: xc.singleAttributePerLine }, cj = uj, hj = { estree: NS, "estree-json": jC }, pj = [...P9, ...rj], dj = IS, fj = Object.create, a0 = Object.defineProperty, mj = Object.getOwnPropertyDescriptor, gj = Object.getOwnPropertyNames, yj = Object.getPrototypeOf, Oj = Object.prototype.hasOwnProperty, WC = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), xj = (t, e) => {
  for (var r in e)
    a0(t, r, { get: e[r], enumerable: !0 });
}, bj = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of gj(e))
      !Oj.call(t, i) && i !== r && a0(t, i, { get: () => e[i], enumerable: !(n = mj(e, i)) || n.enumerable });
  return t;
}, o0 = (t, e, r) => (r = t != null ? fj(yj(t)) : {}, bj(e || !t || !t.__esModule ? a0(r, "default", { value: t, enumerable: !0 }) : r, t)), qC = WC((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(d, l) {
    if (d == null)
      return {};
    var f = {}, y = Object.keys(d), v, E;
    for (E = 0; E < y.length; E++)
      v = y[E], !(l.indexOf(v) >= 0) && (f[v] = d[v]);
    return f;
  }
  var r = class {
    constructor(d, l, f) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = d, this.column = l, this.index = f;
    }
  }, n = class {
    constructor(d, l) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = d, this.end = l;
    }
  };
  function i(d, l) {
    let { line: f, column: y, index: v } = d;
    return new r(f, y + l, v + l);
  }
  var s = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", a = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: s }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: s } }, o = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, u = ({ type: d, prefix: l }) => d === "UpdateExpression" ? o.UpdateExpression[String(l)] : o[d], c = { AccessorIsGenerator: ({ kind: d }) => `A ${d}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: d }) => `Missing initializer in ${d} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: d }) => `\`${d}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", DynamicImportPhaseRequiresImportExpressions: ({ phase: d }) => `'import.${d}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: d, exportName: l }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${d}' as '${l}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: d }) => `'${d === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: d }) => `Unsyntactic ${d === "BreakStatement" ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: ({ importName: d }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${d}" as foo }\`?`, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: ({ maxArgumentCount: d }) => `\`import()\` requires exactly ${d === 1 ? "one argument" : "one or two arguments"}.`, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: d }) => `Expected number in radix ${d}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: d }) => `Escape sequence in keyword ${d}.`, InvalidIdentifier: ({ identifierName: d }) => `Invalid identifier ${d}.`, InvalidLhs: ({ ancestor: d }) => `Invalid left-hand side in ${u(d)}.`, InvalidLhsBinding: ({ ancestor: d }) => `Binding invalid left-hand side in ${u(d)}.`, InvalidLhsOptionalChaining: ({ ancestor: d }) => `Invalid optional chaining in the left-hand side of ${u(d)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: d }) => `Unexpected character '${d}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: d }) => `Private name #${d} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: d }) => `Label '${d}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: d }) => `This experimental syntax requires enabling the parser plugin: ${d.map((l) => JSON.stringify(l)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: d }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${d.map((l) => JSON.stringify(l)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: d }) => `Duplicate key "${d}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: d }) => `An export name cannot include a lone surrogate, found '\\u${d.toString(16)}'.`, ModuleExportUndefined: ({ localName: d }) => `Export '${d}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: d }) => `Private names are only allowed in property accesses (\`obj.#${d}\`) or in \`in\` expressions (\`#${d} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: d }) => `Duplicate private name #${d}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: d }) => `Unexpected keyword '${d}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: d }) => `Unexpected reserved word '${d}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: d, unexpected: l }) => `Unexpected token${l ? ` '${l}'.` : ""}${d ? `, expected "${d}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: d, onlyValidPropertyName: l }) => `The only valid meta property for ${d} is ${d}.${l}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: d }) => `Identifier '${d}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, h = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: d }) => `Assigning to '${d}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: d }) => `Binding '${d}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, p = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), m = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: d }) => `Invalid topic token ${d}. In order to use ${d} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${d}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: d }) => `Hack-style pipe body cannot be an unparenthesized ${u({ type: d })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }, g = ["toMessage"], O = ["message"];
  function b(d, l, f) {
    Object.defineProperty(d, l, { enumerable: !1, configurable: !0, value: f });
  }
  function D(d) {
    let { toMessage: l } = d, f = e(d, g);
    return function y(v, E) {
      let k = new SyntaxError();
      return Object.assign(k, f, { loc: v, pos: v.index }), "missingPlugin" in E && Object.assign(k, { missingPlugin: E.missingPlugin }), b(k, "clone", function(F = {}) {
        var N;
        let { line: I, column: U, index: ne } = (N = F.loc) != null ? N : v;
        return y(new r(I, U, ne), Object.assign({}, E, F.details));
      }), b(k, "details", E), Object.defineProperty(k, "message", { configurable: !0, get() {
        let F = `${l(E)} (${v.line}:${v.column})`;
        return this.message = F, F;
      }, set(F) {
        Object.defineProperty(this, "message", { value: F, writable: !0 });
      } }), k;
    };
  }
  function S(d, l) {
    if (Array.isArray(d))
      return (y) => S(y, d[0]);
    let f = {};
    for (let y of Object.keys(d)) {
      let v = d[y], E = typeof v == "string" ? { message: () => v } : typeof v == "function" ? { message: v } : v, { message: k } = E, F = e(E, O), N = typeof k == "string" ? () => k : k;
      f[y] = D(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: y, toMessage: N }, l ? { syntaxPlugin: l } : {}, F));
    }
    return f;
  }
  var x = Object.assign({}, S(a), S(c), S(h), S`pipelineOperator`(m)), { defineProperty: w } = Object, T = (d, l) => w(d, l, { enumerable: !1, value: d[l] });
  function C(d) {
    return d.loc.start && T(d.loc.start, "index"), d.loc.end && T(d.loc.end, "index"), d;
  }
  var A = (d) => class extends d {
    parse() {
      let l = C(super.parse());
      return this.options.tokens && (l.tokens = l.tokens.map(C)), l;
    }
    parseRegExpLiteral({ pattern: l, flags: f }) {
      let y = null;
      try {
        y = new RegExp(l, f);
      } catch {
      }
      let v = this.estreeParseLiteral(y);
      return v.regex = { pattern: l, flags: f }, v;
    }
    parseBigIntLiteral(l) {
      let f;
      try {
        f = BigInt(l);
      } catch {
        f = null;
      }
      let y = this.estreeParseLiteral(f);
      return y.bigint = String(y.value || l), y;
    }
    parseDecimalLiteral(l) {
      let f = this.estreeParseLiteral(null);
      return f.decimal = String(f.value || l), f;
    }
    estreeParseLiteral(l) {
      return this.parseLiteral(l, "Literal");
    }
    parseStringLiteral(l) {
      return this.estreeParseLiteral(l);
    }
    parseNumericLiteral(l) {
      return this.estreeParseLiteral(l);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(l) {
      return this.estreeParseLiteral(l);
    }
    directiveToStmt(l) {
      let f = l.value;
      delete l.value, f.type = "Literal", f.raw = f.extra.raw, f.value = f.extra.expressionValue;
      let y = l;
      return y.type = "ExpressionStatement", y.expression = f, y.directive = f.extra.rawValue, delete f.extra, y;
    }
    initFunction(l, f) {
      super.initFunction(l, f), l.expression = !1;
    }
    checkDeclaration(l) {
      l != null && this.isObjectProperty(l) ? this.checkDeclaration(l.value) : super.checkDeclaration(l);
    }
    getObjectOrClassMethodParams(l) {
      return l.value.params;
    }
    isValidDirective(l) {
      var f;
      return l.type === "ExpressionStatement" && l.expression.type === "Literal" && typeof l.expression.value == "string" && !((f = l.expression.extra) != null && f.parenthesized);
    }
    parseBlockBody(l, f, y, v, E) {
      super.parseBlockBody(l, f, y, v, E);
      let k = l.directives.map((F) => this.directiveToStmt(F));
      l.body = k.concat(l.body), delete l.directives;
    }
    pushClassMethod(l, f, y, v, E, k) {
      this.parseMethod(f, y, v, E, k, "ClassMethod", !0), f.typeParameters && (f.value.typeParameters = f.typeParameters, delete f.typeParameters), l.body.push(f);
    }
    parsePrivateName() {
      let l = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(l) : l;
    }
    convertPrivateNameToPrivateIdentifier(l) {
      let f = super.getPrivateNameSV(l);
      return l = l, delete l.id, l.name = f, l.type = "PrivateIdentifier", l;
    }
    isPrivateName(l) {
      return this.getPluginOption("estree", "classFeatures") ? l.type === "PrivateIdentifier" : super.isPrivateName(l);
    }
    getPrivateNameSV(l) {
      return this.getPluginOption("estree", "classFeatures") ? l.name : super.getPrivateNameSV(l);
    }
    parseLiteral(l, f) {
      let y = super.parseLiteral(l, f);
      return y.raw = y.extra.raw, delete y.extra, y;
    }
    parseFunctionBody(l, f, y = !1) {
      super.parseFunctionBody(l, f, y), l.expression = l.body.type !== "BlockStatement";
    }
    parseMethod(l, f, y, v, E, k, F = !1) {
      let N = this.startNode();
      return N.kind = l.kind, N = super.parseMethod(N, f, y, v, E, k, F), N.type = "FunctionExpression", delete N.kind, l.value = N, k === "ClassPrivateMethod" && (l.computed = !1), this.finishNode(l, "MethodDefinition");
    }
    parseClassProperty(...l) {
      let f = super.parseClassProperty(...l);
      return this.getPluginOption("estree", "classFeatures") && (f.type = "PropertyDefinition"), f;
    }
    parseClassPrivateProperty(...l) {
      let f = super.parseClassPrivateProperty(...l);
      return this.getPluginOption("estree", "classFeatures") && (f.type = "PropertyDefinition", f.computed = !1), f;
    }
    parseObjectMethod(l, f, y, v, E) {
      let k = super.parseObjectMethod(l, f, y, v, E);
      return k && (k.type = "Property", k.kind === "method" && (k.kind = "init"), k.shorthand = !1), k;
    }
    parseObjectProperty(l, f, y, v) {
      let E = super.parseObjectProperty(l, f, y, v);
      return E && (E.kind = "init", E.type = "Property"), E;
    }
    isValidLVal(l, f, y) {
      return l === "Property" ? "value" : super.isValidLVal(l, f, y);
    }
    isAssignable(l, f) {
      return l != null && this.isObjectProperty(l) ? this.isAssignable(l.value, f) : super.isAssignable(l, f);
    }
    toAssignable(l, f = !1) {
      if (l != null && this.isObjectProperty(l)) {
        let { key: y, value: v } = l;
        this.isPrivateName(y) && this.classScope.usePrivateName(this.getPrivateNameSV(y), y.loc.start), this.toAssignable(v, f);
      } else
        super.toAssignable(l, f);
    }
    toAssignableObjectExpressionProp(l, f, y) {
      l.kind === "get" || l.kind === "set" ? this.raise(x.PatternHasAccessor, l.key) : l.method ? this.raise(x.PatternHasMethod, l.key) : super.toAssignableObjectExpressionProp(l, f, y);
    }
    finishCallExpression(l, f) {
      let y = super.finishCallExpression(l, f);
      if (y.callee.type === "Import") {
        if (y.type = "ImportExpression", y.source = y.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          var v, E;
          y.options = (v = y.arguments[1]) != null ? v : null, y.attributes = (E = y.arguments[1]) != null ? E : null;
        }
        delete y.arguments, delete y.callee;
      }
      return y;
    }
    toReferencedArguments(l) {
      l.type !== "ImportExpression" && super.toReferencedArguments(l);
    }
    parseExport(l, f) {
      let y = this.state.lastTokStartLoc, v = super.parseExport(l, f);
      switch (v.type) {
        case "ExportAllDeclaration":
          v.exported = null;
          break;
        case "ExportNamedDeclaration":
          v.specifiers.length === 1 && v.specifiers[0].type === "ExportNamespaceSpecifier" && (v.type = "ExportAllDeclaration", v.exported = v.specifiers[0].exported, delete v.specifiers);
        case "ExportDefaultDeclaration":
          {
            var E;
            let { declaration: k } = v;
            (k == null ? void 0 : k.type) === "ClassDeclaration" && ((E = k.decorators) == null ? void 0 : E.length) > 0 && k.start === v.start && this.resetStartLocation(v, y);
          }
          break;
      }
      return v;
    }
    parseSubscript(l, f, y, v) {
      let E = super.parseSubscript(l, f, y, v);
      if (v.optionalChainMember) {
        if ((E.type === "OptionalMemberExpression" || E.type === "OptionalCallExpression") && (E.type = E.type.substring(8)), v.stop) {
          let k = this.startNodeAtNode(E);
          return k.expression = E, this.finishNode(k, "ChainExpression");
        }
      } else
        (E.type === "MemberExpression" || E.type === "CallExpression") && (E.optional = !1);
      return E;
    }
    isOptionalMemberExpression(l) {
      return l.type === "ChainExpression" ? l.expression.type === "MemberExpression" : super.isOptionalMemberExpression(l);
    }
    hasPropertyAsPrivateName(l) {
      return l.type === "ChainExpression" && (l = l.expression), super.hasPropertyAsPrivateName(l);
    }
    isObjectProperty(l) {
      return l.type === "Property" && l.kind === "init" && !l.method;
    }
    isObjectMethod(l) {
      return l.method || l.kind === "get" || l.kind === "set";
    }
    finishNodeAt(l, f, y) {
      return C(super.finishNodeAt(l, f, y));
    }
    resetStartLocation(l, f) {
      super.resetStartLocation(l, f), C(l);
    }
    resetEndLocation(l, f = this.state.lastTokEndLoc) {
      super.resetEndLocation(l, f), C(l);
    }
  }, P = class {
    constructor(d, l) {
      this.token = void 0, this.preserveSpace = void 0, this.token = d, this.preserveSpace = !!l;
    }
  }, $ = { brace: new P("{"), j_oTag: new P("<tag"), j_cTag: new P("</tag"), j_expr: new P("<tag>...</tag>", !0) };
  $.template = new P("`", !0);
  var B = !0, _ = !0, M = !0, Y = !0, J = !0, R = !0, q = class {
    constructor(d, l = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = d, this.keyword = l.keyword, this.beforeExpr = !!l.beforeExpr, this.startsExpr = !!l.startsExpr, this.rightAssociative = !!l.rightAssociative, this.isLoop = !!l.isLoop, this.isAssign = !!l.isAssign, this.prefix = !!l.prefix, this.postfix = !!l.postfix, this.binop = l.binop != null ? l.binop : null, this.updateContext = null;
    }
  }, X = /* @__PURE__ */ new Map();
  function H(d, l = {}) {
    l.keyword = d;
    let f = se(d, l);
    return X.set(d, f), f;
  }
  function ye(d, l) {
    return se(d, { beforeExpr: B, binop: l });
  }
  var Ce = -1, Se = [], Ne = [], Te = [], Me = [], Ee = [], nt = [];
  function se(d, l = {}) {
    var f, y, v, E;
    return ++Ce, Ne.push(d), Te.push((f = l.binop) != null ? f : -1), Me.push((y = l.beforeExpr) != null ? y : !1), Ee.push((v = l.startsExpr) != null ? v : !1), nt.push((E = l.prefix) != null ? E : !1), Se.push(new q(d, l)), Ce;
  }
  function V(d, l = {}) {
    var f, y, v, E;
    return ++Ce, X.set(d, Ce), Ne.push(d), Te.push((f = l.binop) != null ? f : -1), Me.push((y = l.beforeExpr) != null ? y : !1), Ee.push((v = l.startsExpr) != null ? v : !1), nt.push((E = l.prefix) != null ? E : !1), Se.push(new q("name", l)), Ce;
  }
  var W = { bracketL: se("[", { beforeExpr: B, startsExpr: _ }), bracketHashL: se("#[", { beforeExpr: B, startsExpr: _ }), bracketBarL: se("[|", { beforeExpr: B, startsExpr: _ }), bracketR: se("]"), bracketBarR: se("|]"), braceL: se("{", { beforeExpr: B, startsExpr: _ }), braceBarL: se("{|", { beforeExpr: B, startsExpr: _ }), braceHashL: se("#{", { beforeExpr: B, startsExpr: _ }), braceR: se("}"), braceBarR: se("|}"), parenL: se("(", { beforeExpr: B, startsExpr: _ }), parenR: se(")"), comma: se(",", { beforeExpr: B }), semi: se(";", { beforeExpr: B }), colon: se(":", { beforeExpr: B }), doubleColon: se("::", { beforeExpr: B }), dot: se("."), question: se("?", { beforeExpr: B }), questionDot: se("?."), arrow: se("=>", { beforeExpr: B }), template: se("template"), ellipsis: se("...", { beforeExpr: B }), backQuote: se("`", { startsExpr: _ }), dollarBraceL: se("${", { beforeExpr: B, startsExpr: _ }), templateTail: se("...`", { startsExpr: _ }), templateNonTail: se("...${", { beforeExpr: B, startsExpr: _ }), at: se("@"), hash: se("#", { startsExpr: _ }), interpreterDirective: se("#!..."), eq: se("=", { beforeExpr: B, isAssign: Y }), assign: se("_=", { beforeExpr: B, isAssign: Y }), slashAssign: se("_=", { beforeExpr: B, isAssign: Y }), xorAssign: se("_=", { beforeExpr: B, isAssign: Y }), moduloAssign: se("_=", { beforeExpr: B, isAssign: Y }), incDec: se("++/--", { prefix: J, postfix: R, startsExpr: _ }), bang: se("!", { beforeExpr: B, prefix: J, startsExpr: _ }), tilde: se("~", { beforeExpr: B, prefix: J, startsExpr: _ }), doubleCaret: se("^^", { startsExpr: _ }), doubleAt: se("@@", { startsExpr: _ }), pipeline: ye("|>", 0), nullishCoalescing: ye("??", 1), logicalOR: ye("||", 1), logicalAND: ye("&&", 2), bitwiseOR: ye("|", 3), bitwiseXOR: ye("^", 4), bitwiseAND: ye("&", 5), equality: ye("==/!=/===/!==", 6), lt: ye("</>/<=/>=", 7), gt: ye("</>/<=/>=", 7), relational: ye("</>/<=/>=", 7), bitShift: ye("<</>>/>>>", 8), bitShiftL: ye("<</>>/>>>", 8), bitShiftR: ye("<</>>/>>>", 8), plusMin: se("+/-", { beforeExpr: B, binop: 9, prefix: J, startsExpr: _ }), modulo: se("%", { binop: 10, startsExpr: _ }), star: se("*", { binop: 10 }), slash: ye("/", 10), exponent: se("**", { beforeExpr: B, binop: 11, rightAssociative: !0 }), _in: H("in", { beforeExpr: B, binop: 7 }), _instanceof: H("instanceof", { beforeExpr: B, binop: 7 }), _break: H("break"), _case: H("case", { beforeExpr: B }), _catch: H("catch"), _continue: H("continue"), _debugger: H("debugger"), _default: H("default", { beforeExpr: B }), _else: H("else", { beforeExpr: B }), _finally: H("finally"), _function: H("function", { startsExpr: _ }), _if: H("if"), _return: H("return", { beforeExpr: B }), _switch: H("switch"), _throw: H("throw", { beforeExpr: B, prefix: J, startsExpr: _ }), _try: H("try"), _var: H("var"), _const: H("const"), _with: H("with"), _new: H("new", { beforeExpr: B, startsExpr: _ }), _this: H("this", { startsExpr: _ }), _super: H("super", { startsExpr: _ }), _class: H("class", { startsExpr: _ }), _extends: H("extends", { beforeExpr: B }), _export: H("export"), _import: H("import", { startsExpr: _ }), _null: H("null", { startsExpr: _ }), _true: H("true", { startsExpr: _ }), _false: H("false", { startsExpr: _ }), _typeof: H("typeof", { beforeExpr: B, prefix: J, startsExpr: _ }), _void: H("void", { beforeExpr: B, prefix: J, startsExpr: _ }), _delete: H("delete", { beforeExpr: B, prefix: J, startsExpr: _ }), _do: H("do", { isLoop: M, beforeExpr: B }), _for: H("for", { isLoop: M }), _while: H("while", { isLoop: M }), _as: V("as", { startsExpr: _ }), _assert: V("assert", { startsExpr: _ }), _async: V("async", { startsExpr: _ }), _await: V("await", { startsExpr: _ }), _defer: V("defer", { startsExpr: _ }), _from: V("from", { startsExpr: _ }), _get: V("get", { startsExpr: _ }), _let: V("let", { startsExpr: _ }), _meta: V("meta", { startsExpr: _ }), _of: V("of", { startsExpr: _ }), _sent: V("sent", { startsExpr: _ }), _set: V("set", { startsExpr: _ }), _source: V("source", { startsExpr: _ }), _static: V("static", { startsExpr: _ }), _using: V("using", { startsExpr: _ }), _yield: V("yield", { startsExpr: _ }), _asserts: V("asserts", { startsExpr: _ }), _checks: V("checks", { startsExpr: _ }), _exports: V("exports", { startsExpr: _ }), _global: V("global", { startsExpr: _ }), _implements: V("implements", { startsExpr: _ }), _intrinsic: V("intrinsic", { startsExpr: _ }), _infer: V("infer", { startsExpr: _ }), _is: V("is", { startsExpr: _ }), _mixins: V("mixins", { startsExpr: _ }), _proto: V("proto", { startsExpr: _ }), _require: V("require", { startsExpr: _ }), _satisfies: V("satisfies", { startsExpr: _ }), _keyof: V("keyof", { startsExpr: _ }), _readonly: V("readonly", { startsExpr: _ }), _unique: V("unique", { startsExpr: _ }), _abstract: V("abstract", { startsExpr: _ }), _declare: V("declare", { startsExpr: _ }), _enum: V("enum", { startsExpr: _ }), _module: V("module", { startsExpr: _ }), _namespace: V("namespace", { startsExpr: _ }), _interface: V("interface", { startsExpr: _ }), _type: V("type", { startsExpr: _ }), _opaque: V("opaque", { startsExpr: _ }), name: se("name", { startsExpr: _ }), string: se("string", { startsExpr: _ }), num: se("num", { startsExpr: _ }), bigint: se("bigint", { startsExpr: _ }), decimal: se("decimal", { startsExpr: _ }), regexp: se("regexp", { startsExpr: _ }), privateName: se("#name", { startsExpr: _ }), eof: se("eof"), jsxName: se("jsxName"), jsxText: se("jsxText", { beforeExpr: !0 }), jsxTagStart: se("jsxTagStart", { startsExpr: !0 }), jsxTagEnd: se("jsxTagEnd"), placeholder: se("%%", { startsExpr: !0 }) };
  function j(d) {
    return d >= 93 && d <= 132;
  }
  function le(d) {
    return d <= 92;
  }
  function De(d) {
    return d >= 58 && d <= 132;
  }
  function we(d) {
    return d >= 58 && d <= 136;
  }
  function Dt(d) {
    return Me[d];
  }
  function it(d) {
    return Ee[d];
  }
  function ht(d) {
    return d >= 29 && d <= 33;
  }
  function It(d) {
    return d >= 129 && d <= 131;
  }
  function Dn(d) {
    return d >= 90 && d <= 92;
  }
  function tr(d) {
    return d >= 58 && d <= 92;
  }
  function rr(d) {
    return d >= 39 && d <= 59;
  }
  function kt(d) {
    return d === 34;
  }
  function $r(d) {
    return nt[d];
  }
  function br(d) {
    return d >= 121 && d <= 123;
  }
  function tn(d) {
    return d >= 124 && d <= 130;
  }
  function Br(d) {
    return Ne[d];
  }
  function Li(d) {
    return Te[d];
  }
  function Sa(d) {
    return d === 57;
  }
  function Ir(d) {
    return d >= 24 && d <= 25;
  }
  function Nt(d) {
    return Se[d];
  }
  Se[8].updateContext = (d) => {
    d.pop();
  }, Se[5].updateContext = Se[7].updateContext = Se[23].updateContext = (d) => {
    d.push($.brace);
  }, Se[22].updateContext = (d) => {
    d[d.length - 1] === $.template ? d.pop() : d.push($.template);
  }, Se[142].updateContext = (d) => {
    d.push($.j_expr, $.j_oTag);
  };
  var vn = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", Ps = "-----------------------------------------------------------------------------------------------------------------------------------------------------", L = new RegExp("[" + vn + "]"), ie = new RegExp("[" + vn + Ps + "]");
  vn = Ps = null;
  var pe = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], Be = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function Ue(d, l) {
    let f = 65536;
    for (let y = 0, v = l.length; y < v; y += 2) {
      if (f += l[y], f > d)
        return !1;
      if (f += l[y + 1], f >= d)
        return !0;
    }
    return !1;
  }
  function _e(d) {
    return d < 65 ? d === 36 : d <= 90 ? !0 : d < 97 ? d === 95 : d <= 122 ? !0 : d <= 65535 ? d >= 170 && L.test(String.fromCharCode(d)) : Ue(d, pe);
  }
  function Ie(d) {
    return d < 48 ? d === 36 : d < 58 ? !0 : d < 65 ? !1 : d <= 90 ? !0 : d < 97 ? d === 95 : d <= 122 ? !0 : d <= 65535 ? d >= 170 && ie.test(String.fromCharCode(d)) : Ue(d, pe) || Ue(d, Be);
  }
  var ke = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, _t = new Set(ke.keyword), Dr = new Set(ke.strict), Je = new Set(ke.strictBind);
  function gt(d, l) {
    return l && d === "await" || d === "enum";
  }
  function Ct(d, l) {
    return gt(d, l) || Dr.has(d);
  }
  function Sn(d) {
    return Je.has(d);
  }
  function pr(d, l) {
    return Ct(d, l) || Sn(d);
  }
  function Nr(d) {
    return _t.has(d);
  }
  function rn(d, l, f) {
    return d === 64 && l === 64 && _e(f);
  }
  var Ri = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function _r(d) {
    return Ri.has(d);
  }
  var gi = class {
    constructor(d) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = d;
    }
  }, yi = class {
    constructor(d, l) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = d, this.inModule = l;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let d = this.currentThisScopeFlags();
      return (d & 64) > 0 && (d & 2) === 0;
    }
    get inStaticBlock() {
      for (let d = this.scopeStack.length - 1; ; d--) {
        let { flags: l } = this.scopeStack[d];
        if (l & 128)
          return !0;
        if (l & 451)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(d) {
      return new gi(d);
    }
    enter(d) {
      this.scopeStack.push(this.createScope(d));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(d) {
      return !!(d.flags & 130 || !this.parser.inModule && d.flags & 1);
    }
    declareName(d, l, f) {
      let y = this.currentScope();
      if (l & 8 || l & 16) {
        this.checkRedeclarationInScope(y, d, l, f);
        let v = y.names.get(d) || 0;
        l & 16 ? v = v | 4 : (y.firstLexicalName || (y.firstLexicalName = d), v = v | 2), y.names.set(d, v), l & 8 && this.maybeExportDefined(y, d);
      } else if (l & 4)
        for (let v = this.scopeStack.length - 1; v >= 0 && (y = this.scopeStack[v], this.checkRedeclarationInScope(y, d, l, f), y.names.set(d, (y.names.get(d) || 0) | 1), this.maybeExportDefined(y, d), !(y.flags & 387)); --v)
          ;
      this.parser.inModule && y.flags & 1 && this.undefinedExports.delete(d);
    }
    maybeExportDefined(d, l) {
      this.parser.inModule && d.flags & 1 && this.undefinedExports.delete(l);
    }
    checkRedeclarationInScope(d, l, f, y) {
      this.isRedeclaredInScope(d, l, f) && this.parser.raise(x.VarRedeclaration, y, { identifierName: l });
    }
    isRedeclaredInScope(d, l, f) {
      if (!(f & 1))
        return !1;
      if (f & 8)
        return d.names.has(l);
      let y = d.names.get(l);
      return f & 16 ? (y & 2) > 0 || !this.treatFunctionsAsVarInScope(d) && (y & 1) > 0 : (y & 2) > 0 && !(d.flags & 8 && d.firstLexicalName === l) || !this.treatFunctionsAsVarInScope(d) && (y & 4) > 0;
    }
    checkLocalExport(d) {
      let { name: l } = d;
      this.scopeStack[0].names.has(l) || this.undefinedExports.set(l, d.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let d = this.scopeStack.length - 1; ; d--) {
        let { flags: l } = this.scopeStack[d];
        if (l & 387)
          return l;
      }
    }
    currentThisScopeFlags() {
      for (let d = this.scopeStack.length - 1; ; d--) {
        let { flags: l } = this.scopeStack[d];
        if (l & 451 && !(l & 4))
          return l;
      }
    }
  }, wa = class extends gi {
    constructor(...d) {
      super(...d), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, Ca = class extends yi {
    createScope(d) {
      return new wa(d);
    }
    declareName(d, l, f) {
      let y = this.currentScope();
      if (l & 2048) {
        this.checkRedeclarationInScope(y, d, l, f), this.maybeExportDefined(y, d), y.declareFunctions.add(d);
        return;
      }
      super.declareName(d, l, f);
    }
    isRedeclaredInScope(d, l, f) {
      if (super.isRedeclaredInScope(d, l, f))
        return !0;
      if (f & 2048 && !d.declareFunctions.has(l)) {
        let y = d.names.get(l);
        return (y & 4) > 0 || (y & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(d) {
      this.scopeStack[0].declareFunctions.has(d.name) || super.checkLocalExport(d);
    }
  }, zu = class {
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    hasPlugin(d) {
      if (typeof d == "string")
        return this.plugins.has(d);
      {
        let [l, f] = d;
        if (!this.hasPlugin(l))
          return !1;
        let y = this.plugins.get(l);
        for (let v of Object.keys(f))
          if ((y == null ? void 0 : y[v]) !== f[v])
            return !1;
        return !0;
      }
    }
    getPluginOption(d, l) {
      var f;
      return (f = this.plugins.get(d)) == null ? void 0 : f[l];
    }
  };
  function ji(d, l) {
    d.trailingComments === void 0 ? d.trailingComments = l : d.trailingComments.unshift(...l);
  }
  function Fs(d, l) {
    d.leadingComments === void 0 ? d.leadingComments = l : d.leadingComments.unshift(...l);
  }
  function Oi(d, l) {
    d.innerComments === void 0 ? d.innerComments = l : d.innerComments.unshift(...l);
  }
  function jo(d, l, f) {
    let y = null, v = l.length;
    for (; y === null && v > 0; )
      y = l[--v];
    y === null || y.start > f.start ? Oi(d, f.comments) : ji(y, f.comments);
  }
  var fP = class extends zu {
    addComment(d) {
      this.filename && (d.loc.filename = this.filename);
      let { commentsLen: l } = this.state;
      this.comments.length != l && (this.comments.length = l), this.comments.push(d), this.state.commentsLen++;
    }
    processComment(d) {
      let { commentStack: l } = this.state, f = l.length;
      if (f === 0)
        return;
      let y = f - 1, v = l[y];
      v.start === d.end && (v.leadingNode = d, y--);
      let { start: E } = d;
      for (; y >= 0; y--) {
        let k = l[y], F = k.end;
        if (F > E)
          k.containingNode = d, this.finalizeComment(k), l.splice(y, 1);
        else {
          F === E && (k.trailingNode = d);
          break;
        }
      }
    }
    finalizeComment(d) {
      let { comments: l } = d;
      if (d.leadingNode !== null || d.trailingNode !== null)
        d.leadingNode !== null && ji(d.leadingNode, l), d.trailingNode !== null && Fs(d.trailingNode, l);
      else {
        let { containingNode: f, start: y } = d;
        if (this.input.charCodeAt(y - 1) === 44)
          switch (f.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              jo(f, f.properties, d);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              jo(f, f.arguments, d);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              jo(f, f.params, d);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              jo(f, f.elements, d);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              jo(f, f.specifiers, d);
              break;
            default:
              Oi(f, l);
          }
        else
          Oi(f, l);
      }
    }
    finalizeRemainingComments() {
      let { commentStack: d } = this.state;
      for (let l = d.length - 1; l >= 0; l--)
        this.finalizeComment(d[l]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(d) {
      let { commentStack: l } = this.state, { length: f } = l;
      if (f === 0)
        return;
      let y = l[f - 1];
      y.leadingNode === d && (y.leadingNode = null);
    }
    resetPreviousIdentifierLeadingComments(d) {
      let { commentStack: l } = this.state, { length: f } = l;
      f !== 0 && (l[f - 1].trailingNode === d ? l[f - 1].trailingNode = null : f >= 2 && l[f - 2].trailingNode === d && (l[f - 2].trailingNode = null));
    }
    takeSurroundingComments(d, l, f) {
      let { commentStack: y } = this.state, v = y.length;
      if (v === 0)
        return;
      let E = v - 1;
      for (; E >= 0; E--) {
        let k = y[E], F = k.end;
        if (k.start === f)
          k.leadingNode = d;
        else if (F === l)
          k.trailingNode = d;
        else if (F < l)
          break;
      }
    }
  }, tO = /\r\n?|[\n\u2028\u2029]/, Gu = new RegExp(tO.source, "g");
  function Zo(d) {
    switch (d) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  var gd = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Hu = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, rO = new RegExp("(?=(" + Hu.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
  function mP(d) {
    switch (d) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  var gP = class XC {
    constructor() {
      this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [$.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(l) {
      l ? this.flags |= 1 : this.flags &= -2;
    }
    init({ strictMode: l, sourceType: f, startLine: y, startColumn: v }) {
      this.strict = l === !1 ? !1 : l === !0 ? !0 : f === "module", this.curLine = y, this.lineStart = -v, this.startLoc = this.endLoc = new r(y, v, 0);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(l) {
      l ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(l) {
      l ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(l) {
      l ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(l) {
      l ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(l) {
      l ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(l) {
      l ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(l) {
      l ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(l) {
      l ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(l) {
      l ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(l) {
      l ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(l) {
      l ? this.flags |= 2048 : this.flags &= -2049;
    }
    curPosition() {
      return new r(this.curLine, this.pos - this.lineStart, this.pos);
    }
    clone() {
      let l = new XC();
      return l.flags = this.flags, l.curLine = this.curLine, l.lineStart = this.lineStart, l.startLoc = this.startLoc, l.endLoc = this.endLoc, l.errors = this.errors.slice(), l.potentialArrowAt = this.potentialArrowAt, l.noArrowAt = this.noArrowAt.slice(), l.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), l.topicContext = this.topicContext, l.labels = this.labels.slice(), l.commentsLen = this.commentsLen, l.commentStack = this.commentStack.slice(), l.pos = this.pos, l.type = this.type, l.value = this.value, l.start = this.start, l.end = this.end, l.lastTokEndLoc = this.lastTokEndLoc, l.lastTokStartLoc = this.lastTokStartLoc, l.context = this.context.slice(), l.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, l.strictErrors = this.strictErrors, l.tokensLength = this.tokensLength, l;
    }
  }, yP = function(d) {
    return d >= 48 && d <= 57;
  }, nO = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Ju = { bin: (d) => d === 48 || d === 49, oct: (d) => d >= 48 && d <= 55, dec: (d) => d >= 48 && d <= 57, hex: (d) => d >= 48 && d <= 57 || d >= 65 && d <= 70 || d >= 97 && d <= 102 };
  function iO(d, l, f, y, v, E) {
    let k = f, F = y, N = v, I = "", U = null, ne = f, { length: he } = l;
    for (; ; ) {
      if (f >= he) {
        E.unterminated(k, F, N), I += l.slice(ne, f);
        break;
      }
      let ce = l.charCodeAt(f);
      if (OP(d, ce, l, f)) {
        I += l.slice(ne, f);
        break;
      }
      if (ce === 92) {
        I += l.slice(ne, f);
        let He = xP(l, f, y, v, d === "template", E);
        He.ch === null && !U ? U = { pos: f, lineStart: y, curLine: v } : I += He.ch, { pos: f, lineStart: y, curLine: v } = He, ne = f;
      } else
        ce === 8232 || ce === 8233 ? (++f, ++v, y = f) : ce === 10 || ce === 13 ? d === "template" ? (I += l.slice(ne, f) + `
`, ++f, ce === 13 && l.charCodeAt(f) === 10 && ++f, ++v, ne = y = f) : E.unterminated(k, F, N) : ++f;
    }
    return { pos: f, str: I, firstInvalidLoc: U, lineStart: y, curLine: v, containsInvalid: !!U };
  }
  function OP(d, l, f, y) {
    return d === "template" ? l === 96 || l === 36 && f.charCodeAt(y + 1) === 123 : l === (d === "double" ? 34 : 39);
  }
  function xP(d, l, f, y, v, E) {
    let k = !v;
    l++;
    let F = (I) => ({ pos: l, ch: I, lineStart: f, curLine: y }), N = d.charCodeAt(l++);
    switch (N) {
      case 110:
        return F(`
`);
      case 114:
        return F("\r");
      case 120: {
        let I;
        return { code: I, pos: l } = yd(d, l, f, y, 2, !1, k, E), F(I === null ? null : String.fromCharCode(I));
      }
      case 117: {
        let I;
        return { code: I, pos: l } = aO(d, l, f, y, k, E), F(I === null ? null : String.fromCodePoint(I));
      }
      case 116:
        return F("	");
      case 98:
        return F("\b");
      case 118:
        return F("\v");
      case 102:
        return F("\f");
      case 13:
        d.charCodeAt(l) === 10 && ++l;
      case 10:
        f = l, ++y;
      case 8232:
      case 8233:
        return F("");
      case 56:
      case 57:
        if (v)
          return F(null);
        E.strictNumericEscape(l - 1, f, y);
      default:
        if (N >= 48 && N <= 55) {
          let I = l - 1, U = d.slice(I, l + 2).match(/^[0-7]+/)[0], ne = parseInt(U, 8);
          ne > 255 && (U = U.slice(0, -1), ne = parseInt(U, 8)), l += U.length - 1;
          let he = d.charCodeAt(l);
          if (U !== "0" || he === 56 || he === 57) {
            if (v)
              return F(null);
            E.strictNumericEscape(I, f, y);
          }
          return F(String.fromCharCode(ne));
        }
        return F(String.fromCharCode(N));
    }
  }
  function yd(d, l, f, y, v, E, k, F) {
    let N = l, I;
    return { n: I, pos: l } = sO(d, l, f, y, 16, v, E, !1, F, !k), I === null && (k ? F.invalidEscapeSequence(N, f, y) : l = N - 1), { code: I, pos: l };
  }
  function sO(d, l, f, y, v, E, k, F, N, I) {
    let U = l, ne = v === 16 ? nO.hex : nO.decBinOct, he = v === 16 ? Ju.hex : v === 10 ? Ju.dec : v === 8 ? Ju.oct : Ju.bin, ce = !1, He = 0;
    for (let Ge = 0, Pt = E ?? 1 / 0; Ge < Pt; ++Ge) {
      let nr = d.charCodeAt(l), Qr;
      if (nr === 95 && F !== "bail") {
        let vd = d.charCodeAt(l - 1), Sd = d.charCodeAt(l + 1);
        if (F) {
          if (Number.isNaN(Sd) || !he(Sd) || ne.has(vd) || ne.has(Sd)) {
            if (I)
              return { n: null, pos: l };
            N.unexpectedNumericSeparator(l, f, y);
          }
        } else {
          if (I)
            return { n: null, pos: l };
          N.numericSeparatorInEscapeSequence(l, f, y);
        }
        ++l;
        continue;
      }
      if (nr >= 97 ? Qr = nr - 97 + 10 : nr >= 65 ? Qr = nr - 65 + 10 : yP(nr) ? Qr = nr - 48 : Qr = 1 / 0, Qr >= v) {
        if (Qr <= 9 && I)
          return { n: null, pos: l };
        if (Qr <= 9 && N.invalidDigit(l, f, y, v))
          Qr = 0;
        else if (k)
          Qr = 0, ce = !0;
        else
          break;
      }
      ++l, He = He * v + Qr;
    }
    return l === U || E != null && l - U !== E || ce ? { n: null, pos: l } : { n: He, pos: l };
  }
  function aO(d, l, f, y, v, E) {
    let k = d.charCodeAt(l), F;
    if (k === 123) {
      if (++l, { code: F, pos: l } = yd(d, l, f, y, d.indexOf("}", l) - l, !0, v, E), ++l, F !== null && F > 1114111)
        if (v)
          E.invalidCodePoint(l, f, y);
        else
          return { code: null, pos: l };
    } else
      ({ code: F, pos: l } = yd(d, l, f, y, 4, !1, v, E));
    return { code: F, pos: l };
  }
  function Wo(d, l, f) {
    return new r(f, d - l, d);
  }
  var bP = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), Zi = class {
    constructor(d) {
      this.type = d.type, this.value = d.value, this.start = d.start, this.end = d.end, this.loc = new n(d.startLoc, d.endLoc);
    }
  }, DP = class extends fP {
    constructor(d, l) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (f, y, v, E) => this.options.errorRecovery ? (this.raise(x.InvalidDigit, Wo(f, y, v), { radix: E }), !0) : !1, numericSeparatorInEscapeSequence: this.errorBuilder(x.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(x.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(x.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(x.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (f, y, v) => {
        this.recordStrictModeErrors(x.StrictNumericEscape, Wo(f, y, v));
      }, unterminated: (f, y, v) => {
        throw this.raise(x.UnterminatedString, Wo(f - 1, y, v));
      } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(x.StrictNumericEscape), unterminated: (f, y, v) => {
        throw this.raise(x.UnterminatedTemplate, Wo(f, y, v));
      } }), this.state = new gP(), this.state.init(d), this.input = l, this.length = l.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(d) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(d), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Zi(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(d) {
      return this.match(d) ? (this.next(), !0) : !1;
    }
    match(d) {
      return this.state.type === d;
    }
    createLookaheadState(d) {
      return { pos: d.pos, value: null, type: d.type, start: d.start, end: d.end, context: [this.curContext()], inType: d.inType, startLoc: d.startLoc, lastTokEndLoc: d.lastTokEndLoc, curLine: d.curLine, lineStart: d.lineStart, curPosition: d.curPosition };
    }
    lookahead() {
      let d = this.state;
      this.state = this.createLookaheadState(d), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let l = this.state;
      return this.state = d, l;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(d) {
      return gd.lastIndex = d, gd.test(this.input) ? gd.lastIndex : d;
    }
    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(d) {
      return Hu.lastIndex = d, Hu.test(this.input) ? Hu.lastIndex : d;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(d) {
      let l = this.input.charCodeAt(d);
      if ((l & 64512) === 55296 && ++d < this.input.length) {
        let f = this.input.charCodeAt(d);
        (f & 64512) === 56320 && (l = 65536 + ((l & 1023) << 10) + (f & 1023));
      }
      return l;
    }
    setStrict(d) {
      this.state.strict = d, d && (this.state.strictErrors.forEach(([l, f]) => this.raise(l, f)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
        this.finishToken(139);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(d) {
      let l;
      this.isLookahead || (l = this.state.curPosition());
      let f = this.state.pos, y = this.input.indexOf(d, f + 2);
      if (y === -1)
        throw this.raise(x.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = y + d.length, Gu.lastIndex = f + 2; Gu.test(this.input) && Gu.lastIndex <= y; )
        ++this.state.curLine, this.state.lineStart = Gu.lastIndex;
      if (this.isLookahead)
        return;
      let v = { type: "CommentBlock", value: this.input.slice(f + 2, y), start: f, end: y + d.length, loc: new n(l, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(v), v;
    }
    skipLineComment(d) {
      let l = this.state.pos, f;
      this.isLookahead || (f = this.state.curPosition());
      let y = this.input.charCodeAt(this.state.pos += d);
      if (this.state.pos < this.length)
        for (; !Zo(y) && ++this.state.pos < this.length; )
          y = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead)
        return;
      let v = this.state.pos, E = { type: "CommentLine", value: this.input.slice(l + d, v), start: l, end: v, loc: new n(f, this.state.curPosition()) };
      return this.options.tokens && this.pushToken(E), E;
    }
    skipSpace() {
      let d = this.state.pos, l = [];
      e:
        for (; this.state.pos < this.length; ) {
          let f = this.input.charCodeAt(this.state.pos);
          switch (f) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  let y = this.skipBlockComment("*/");
                  y !== void 0 && (this.addComment(y), this.options.attachComment && l.push(y));
                  break;
                }
                case 47: {
                  let y = this.skipLineComment(2);
                  y !== void 0 && (this.addComment(y), this.options.attachComment && l.push(y));
                  break;
                }
                default:
                  break e;
              }
              break;
            default:
              if (mP(f))
                ++this.state.pos;
              else if (f === 45 && !this.inModule && this.options.annexB) {
                let y = this.state.pos;
                if (this.input.charCodeAt(y + 1) === 45 && this.input.charCodeAt(y + 2) === 62 && (d === 0 || this.state.lineStart > d)) {
                  let v = this.skipLineComment(3);
                  v !== void 0 && (this.addComment(v), this.options.attachComment && l.push(v));
                } else
                  break e;
              } else if (f === 60 && !this.inModule && this.options.annexB) {
                let y = this.state.pos;
                if (this.input.charCodeAt(y + 1) === 33 && this.input.charCodeAt(y + 2) === 45 && this.input.charCodeAt(y + 3) === 45) {
                  let v = this.skipLineComment(4);
                  v !== void 0 && (this.addComment(v), this.options.attachComment && l.push(v));
                } else
                  break e;
              } else
                break e;
          }
        }
      if (l.length > 0) {
        let f = this.state.pos, y = { start: d, end: f, comments: l, leadingNode: null, trailingNode: null, containingNode: null };
        this.state.commentStack.push(y);
      }
    }
    finishToken(d, l) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let f = this.state.type;
      this.state.type = d, this.state.value = l, this.isLookahead || this.updateContext(f);
    }
    replaceToken(d) {
      this.state.type = d, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let d = this.state.pos + 1, l = this.codePointAtPos(d);
      if (l >= 48 && l <= 57)
        throw this.raise(x.UnexpectedDigitAfterHash, this.state.curPosition());
      if (l === 123 || l === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(l === 123 ? x.RecordExpressionHashIncorrectStartSyntaxType : x.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
        this.state.pos += 2, l === 123 ? this.finishToken(7) : this.finishToken(1);
      } else
        _e(l) ? (++this.state.pos, this.finishToken(138, this.readWord1(l))) : l === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let d = this.input.charCodeAt(this.state.pos + 1);
      if (d >= 48 && d <= 57) {
        this.readNumber(!0);
        return;
      }
      d === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2)
        return !1;
      let d = this.input.charCodeAt(this.state.pos + 1);
      if (d !== 33)
        return !1;
      let l = this.state.pos;
      for (this.state.pos += 1; !Zo(d) && ++this.state.pos < this.length; )
        d = this.input.charCodeAt(this.state.pos);
      let f = this.input.slice(l + 2, this.state.pos);
      return this.finishToken(28, f), !0;
    }
    readToken_mult_modulo(d) {
      let l = d === 42 ? 55 : 54, f = 1, y = this.input.charCodeAt(this.state.pos + 1);
      d === 42 && y === 42 && (f++, y = this.input.charCodeAt(this.state.pos + 2), l = 57), y === 61 && !this.state.inType && (f++, l = d === 37 ? 33 : 30), this.finishOp(l, f);
    }
    readToken_pipe_amp(d) {
      let l = this.input.charCodeAt(this.state.pos + 1);
      if (l === d) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(d === 124 ? 41 : 42, 2);
        return;
      }
      if (d === 124) {
        if (l === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && l === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(x.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && l === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(x.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (l === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(d === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let d = this.input.charCodeAt(this.state.pos + 1);
      d === 61 && !this.state.inType ? this.finishOp(32, 2) : d === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(d) {
      let l = this.input.charCodeAt(this.state.pos + 1);
      if (l === d) {
        this.finishOp(34, 2);
        return;
      }
      l === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let { pos: d } = this.state, l = this.input.charCodeAt(d + 1);
      if (l === 60) {
        if (this.input.charCodeAt(d + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (l === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let { pos: d } = this.state, l = this.input.charCodeAt(d + 1);
      if (l === 62) {
        let f = this.input.charCodeAt(d + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(d + f) === 61) {
          this.finishOp(30, f + 1);
          return;
        }
        this.finishOp(52, f);
        return;
      }
      if (l === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(d) {
      let l = this.input.charCodeAt(this.state.pos + 1);
      if (l === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (d === 61 && l === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(d === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let d = this.input.charCodeAt(this.state.pos + 1), l = this.input.charCodeAt(this.state.pos + 2);
      d === 63 ? l === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : d === 46 && !(l >= 48 && l <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(d) {
      switch (d) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(x.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(x.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let l = this.input.charCodeAt(this.state.pos + 1);
          if (l === 120 || l === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (l === 111 || l === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (l === 98 || l === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(d);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(d);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(d);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(d);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(d);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (_e(d)) {
            this.readWord(d);
            return;
          }
      }
      throw this.raise(x.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(d) });
    }
    finishOp(d, l) {
      let f = this.input.slice(this.state.pos, this.state.pos + l);
      this.state.pos += l, this.finishToken(d, f);
    }
    readRegexp() {
      let d = this.state.startLoc, l = this.state.start + 1, f, y, { pos: v } = this.state;
      for (; ; ++v) {
        if (v >= this.length)
          throw this.raise(x.UnterminatedRegExp, i(d, 1));
        let N = this.input.charCodeAt(v);
        if (Zo(N))
          throw this.raise(x.UnterminatedRegExp, i(d, 1));
        if (f)
          f = !1;
        else {
          if (N === 91)
            y = !0;
          else if (N === 93 && y)
            y = !1;
          else if (N === 47 && !y)
            break;
          f = N === 92;
        }
      }
      let E = this.input.slice(l, v);
      ++v;
      let k = "", F = () => i(d, v + 2 - l);
      for (; v < this.length; ) {
        let N = this.codePointAtPos(v), I = String.fromCharCode(N);
        if (bP.has(N))
          N === 118 ? k.includes("u") && this.raise(x.IncompatibleRegExpUVFlags, F()) : N === 117 && k.includes("v") && this.raise(x.IncompatibleRegExpUVFlags, F()), k.includes(I) && this.raise(x.DuplicateRegExpFlags, F());
        else if (Ie(N) || N === 92)
          this.raise(x.MalformedRegExpFlags, F());
        else
          break;
        ++v, k += I;
      }
      this.state.pos = v, this.finishToken(137, { pattern: E, flags: k });
    }
    readInt(d, l, f = !1, y = !0) {
      let { n: v, pos: E } = sO(this.input, this.state.pos, this.state.lineStart, this.state.curLine, d, l, f, y, this.errorHandlers_readInt, !1);
      return this.state.pos = E, v;
    }
    readRadixNumber(d) {
      let l = this.state.curPosition(), f = !1;
      this.state.pos += 2;
      let y = this.readInt(d);
      y == null && this.raise(x.InvalidDigit, i(l, 2), { radix: d });
      let v = this.input.charCodeAt(this.state.pos);
      if (v === 110)
        ++this.state.pos, f = !0;
      else if (v === 109)
        throw this.raise(x.InvalidDecimal, l);
      if (_e(this.codePointAtPos(this.state.pos)))
        throw this.raise(x.NumberIdentifier, this.state.curPosition());
      if (f) {
        let E = this.input.slice(l.index, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(135, E);
        return;
      }
      this.finishToken(134, y);
    }
    readNumber(d) {
      let l = this.state.pos, f = this.state.curPosition(), y = !1, v = !1, E = !1, k = !1, F = !1;
      !d && this.readInt(10) === null && this.raise(x.InvalidNumber, this.state.curPosition());
      let N = this.state.pos - l >= 2 && this.input.charCodeAt(l) === 48;
      if (N) {
        let he = this.input.slice(l, this.state.pos);
        if (this.recordStrictModeErrors(x.StrictOctalLiteral, f), !this.state.strict) {
          let ce = he.indexOf("_");
          ce > 0 && this.raise(x.ZeroDigitNumericSeparator, i(f, ce));
        }
        F = N && !/[89]/.test(he);
      }
      let I = this.input.charCodeAt(this.state.pos);
      if (I === 46 && !F && (++this.state.pos, this.readInt(10), y = !0, I = this.input.charCodeAt(this.state.pos)), (I === 69 || I === 101) && !F && (I = this.input.charCodeAt(++this.state.pos), (I === 43 || I === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(x.InvalidOrMissingExponent, f), y = !0, k = !0, I = this.input.charCodeAt(this.state.pos)), I === 110 && ((y || N) && this.raise(x.InvalidBigIntLiteral, f), ++this.state.pos, v = !0), I === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (k || N) && this.raise(x.InvalidDecimal, f), ++this.state.pos, E = !0), _e(this.codePointAtPos(this.state.pos)))
        throw this.raise(x.NumberIdentifier, this.state.curPosition());
      let U = this.input.slice(l, this.state.pos).replace(/[_mn]/g, "");
      if (v) {
        this.finishToken(135, U);
        return;
      }
      if (E) {
        this.finishToken(136, U);
        return;
      }
      let ne = F ? parseInt(U, 8) : parseFloat(U);
      this.finishToken(134, ne);
    }
    readCodePoint(d) {
      let { code: l, pos: f } = aO(this.input, this.state.pos, this.state.lineStart, this.state.curLine, d, this.errorHandlers_readCodePoint);
      return this.state.pos = f, l;
    }
    readString(d) {
      let { str: l, pos: f, curLine: y, lineStart: v } = iO(d === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = f + 1, this.state.lineStart = v, this.state.curLine = y, this.finishToken(133, l);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let d = this.input[this.state.pos], { str: l, firstInvalidLoc: f, pos: y, curLine: v, lineStart: E } = iO("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = y + 1, this.state.lineStart = E, this.state.curLine = v, f && (this.state.firstInvalidTemplateEscapePos = new r(f.curLine, f.pos - f.lineStart, f.pos)), this.input.codePointAt(y) === 96 ? this.finishToken(24, f ? null : d + l + "`") : (this.state.pos++, this.finishToken(25, f ? null : d + l + "${"));
    }
    recordStrictModeErrors(d, l) {
      let f = l.index;
      this.state.strict && !this.state.strictErrors.has(f) ? this.raise(d, l) : this.state.strictErrors.set(f, [d, l]);
    }
    readWord1(d) {
      this.state.containsEsc = !1;
      let l = "", f = this.state.pos, y = this.state.pos;
      for (d !== void 0 && (this.state.pos += d <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let v = this.codePointAtPos(this.state.pos);
        if (Ie(v))
          this.state.pos += v <= 65535 ? 1 : 2;
        else if (v === 92) {
          this.state.containsEsc = !0, l += this.input.slice(y, this.state.pos);
          let E = this.state.curPosition(), k = this.state.pos === f ? _e : Ie;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(x.MissingUnicodeEscape, this.state.curPosition()), y = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let F = this.readCodePoint(!0);
          F !== null && (k(F) || this.raise(x.EscapedCharNotAnIdentifier, E), l += String.fromCodePoint(F)), y = this.state.pos;
        } else
          break;
      }
      return l + this.input.slice(y, this.state.pos);
    }
    readWord(d) {
      let l = this.readWord1(d), f = X.get(l);
      f !== void 0 ? this.finishToken(f, Br(f)) : this.finishToken(132, l);
    }
    checkKeywordEscapes() {
      let { type: d } = this.state;
      tr(d) && this.state.containsEsc && this.raise(x.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: Br(d) });
    }
    raise(d, l, f = {}) {
      let y = l instanceof r ? l : l.loc.start, v = d(y, f);
      if (!this.options.errorRecovery)
        throw v;
      return this.isLookahead || this.state.errors.push(v), v;
    }
    raiseOverwrite(d, l, f = {}) {
      let y = l instanceof r ? l : l.loc.start, v = y.index, E = this.state.errors;
      for (let k = E.length - 1; k >= 0; k--) {
        let F = E[k];
        if (F.loc.index === v)
          return E[k] = d(y, f);
        if (F.loc.index < v)
          break;
      }
      return this.raise(d, l, f);
    }
    updateContext(d) {
    }
    unexpected(d, l) {
      throw this.raise(x.UnexpectedToken, d ?? this.state.startLoc, { expected: l ? Br(l) : null });
    }
    expectPlugin(d, l) {
      if (this.hasPlugin(d))
        return !0;
      throw this.raise(x.MissingPlugin, l ?? this.state.startLoc, { missingPlugin: [d] });
    }
    expectOnePlugin(d) {
      if (!d.some((l) => this.hasPlugin(l)))
        throw this.raise(x.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: d });
    }
    errorBuilder(d) {
      return (l, f, y) => {
        this.raise(d, Wo(l, f, y));
      };
    }
  }, vP = class {
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, SP = class {
    constructor(d) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = d;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new vP());
    }
    exit() {
      let d = this.stack.pop(), l = this.current();
      for (let [f, y] of Array.from(d.undefinedPrivateNames))
        l ? l.undefinedPrivateNames.has(f) || l.undefinedPrivateNames.set(f, y) : this.parser.raise(x.InvalidPrivateFieldResolution, y, { identifierName: f });
    }
    declarePrivateName(d, l, f) {
      let { privateNames: y, loneAccessors: v, undefinedPrivateNames: E } = this.current(), k = y.has(d);
      if (l & 3) {
        let F = k && v.get(d);
        if (F) {
          let N = F & 4, I = l & 4, U = F & 3, ne = l & 3;
          k = U === ne || N !== I, k || v.delete(d);
        } else
          k || v.set(d, l);
      }
      k && this.parser.raise(x.PrivateNameRedeclaration, f, { identifierName: d }), y.add(d), E.delete(d);
    }
    usePrivateName(d, l) {
      let f;
      for (f of this.stack)
        if (f.privateNames.has(d))
          return;
      f ? f.undefinedPrivateNames.set(d, l) : this.parser.raise(x.InvalidPrivateFieldResolution, l, { identifierName: d });
    }
  }, Ku = class {
    constructor(d = 0) {
      this.type = d;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, oO = class extends Ku {
    constructor(d) {
      super(d), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(d, l) {
      let f = l.index;
      this.declarationErrors.set(f, [d, l]);
    }
    clearDeclarationError(d) {
      this.declarationErrors.delete(d);
    }
    iterateErrors(d) {
      this.declarationErrors.forEach(d);
    }
  }, wP = class {
    constructor(d) {
      this.parser = void 0, this.stack = [new Ku()], this.parser = d;
    }
    enter(d) {
      this.stack.push(d);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(d, l) {
      let f = l.loc.start, { stack: y } = this, v = y.length - 1, E = y[v];
      for (; !E.isCertainlyParameterDeclaration(); ) {
        if (E.canBeArrowParameterDeclaration())
          E.recordDeclarationError(d, f);
        else
          return;
        E = y[--v];
      }
      this.parser.raise(d, f);
    }
    recordArrowParameterBindingError(d, l) {
      let { stack: f } = this, y = f[f.length - 1], v = l.loc.start;
      if (y.isCertainlyParameterDeclaration())
        this.parser.raise(d, v);
      else if (y.canBeArrowParameterDeclaration())
        y.recordDeclarationError(d, v);
      else
        return;
    }
    recordAsyncArrowParametersError(d) {
      let { stack: l } = this, f = l.length - 1, y = l[f];
      for (; y.canBeArrowParameterDeclaration(); )
        y.type === 2 && y.recordDeclarationError(x.AwaitBindingIdentifier, d), y = l[--f];
    }
    validateAsPattern() {
      let { stack: d } = this, l = d[d.length - 1];
      l.canBeArrowParameterDeclaration() && l.iterateErrors(([f, y]) => {
        this.parser.raise(f, y);
        let v = d.length - 2, E = d[v];
        for (; E.canBeArrowParameterDeclaration(); )
          E.clearDeclarationError(y.index), E = d[--v];
      });
    }
  };
  function CP() {
    return new Ku(3);
  }
  function EP() {
    return new oO(1);
  }
  function AP() {
    return new oO(2);
  }
  function lO() {
    return new Ku();
  }
  var TP = class {
    constructor() {
      this.stacks = [];
    }
    enter(d) {
      this.stacks.push(d);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function ec(d, l) {
    return (d ? 2 : 0) | (l ? 1 : 0);
  }
  var kP = class extends DP {
    addExtra(d, l, f, y = !0) {
      if (!d)
        return;
      let v = d.extra = d.extra || {};
      y ? v[l] = f : Object.defineProperty(v, l, { enumerable: y, value: f });
    }
    isContextual(d) {
      return this.state.type === d && !this.state.containsEsc;
    }
    isUnparsedContextual(d, l) {
      let f = d + l.length;
      if (this.input.slice(d, f) === l) {
        let y = this.input.charCodeAt(f);
        return !(Ie(y) || (y & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(d) {
      let l = this.nextTokenStart();
      return this.isUnparsedContextual(l, d);
    }
    eatContextual(d) {
      return this.isContextual(d) ? (this.next(), !0) : !1;
    }
    expectContextual(d, l) {
      if (!this.eatContextual(d)) {
        if (l != null)
          throw this.raise(l, this.state.startLoc);
        this.unexpected(null, d);
      }
    }
    canInsertSemicolon() {
      return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return tO.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
    }
    hasFollowingLineBreak() {
      return rO.lastIndex = this.state.end, rO.test(this.input);
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(d = !0) {
      (d ? this.isLineTerminator() : this.eat(13)) || this.raise(x.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(d, l) {
      this.eat(d) || this.unexpected(l, d);
    }
    tryParse(d, l = this.state.clone()) {
      let f = { node: null };
      try {
        let y = d((v = null) => {
          throw f.node = v, f;
        });
        if (this.state.errors.length > l.errors.length) {
          let v = this.state;
          return this.state = l, this.state.tokensLength = v.tokensLength, { node: y, error: v.errors[l.errors.length], thrown: !1, aborted: !1, failState: v };
        }
        return { node: y, error: null, thrown: !1, aborted: !1, failState: null };
      } catch (y) {
        let v = this.state;
        if (this.state = l, y instanceof SyntaxError)
          return { node: null, error: y, thrown: !0, aborted: !1, failState: v };
        if (y === f)
          return { node: f.node, error: null, thrown: !1, aborted: !0, failState: v };
        throw y;
      }
    }
    checkExpressionErrors(d, l) {
      if (!d)
        return !1;
      let { shorthandAssignLoc: f, doubleProtoLoc: y, privateKeyLoc: v, optionalParametersLoc: E } = d, k = !!f || !!y || !!E || !!v;
      if (!l)
        return k;
      f != null && this.raise(x.InvalidCoverInitializedName, f), y != null && this.raise(x.DuplicateProto, y), v != null && this.raise(x.UnexpectedPrivateField, v), E != null && this.unexpected(E);
    }
    isLiteralPropertyName() {
      return we(this.state.type);
    }
    isPrivateName(d) {
      return d.type === "PrivateName";
    }
    getPrivateNameSV(d) {
      return d.id.name;
    }
    hasPropertyAsPrivateName(d) {
      return (d.type === "MemberExpression" || d.type === "OptionalMemberExpression") && this.isPrivateName(d.property);
    }
    isObjectProperty(d) {
      return d.type === "ObjectProperty";
    }
    isObjectMethod(d) {
      return d.type === "ObjectMethod";
    }
    initializeScopes(d = this.options.sourceType === "module") {
      let l = this.state.labels;
      this.state.labels = [];
      let f = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let y = this.inModule;
      this.inModule = d;
      let v = this.scope, E = this.getScopeHandler();
      this.scope = new E(this, d);
      let k = this.prodParam;
      this.prodParam = new TP();
      let F = this.classScope;
      this.classScope = new SP(this);
      let N = this.expressionScope;
      return this.expressionScope = new wP(this), () => {
        this.state.labels = l, this.exportedIdentifiers = f, this.inModule = y, this.scope = v, this.prodParam = k, this.classScope = F, this.expressionScope = N;
      };
    }
    enterInitialScopes() {
      let d = 0;
      this.inModule && (d |= 2), this.scope.enter(1), this.prodParam.enter(d);
    }
    checkDestructuringPrivate(d) {
      let { privateKeyLoc: l } = d;
      l !== null && this.expectPlugin("destructuringPrivate", l);
    }
  }, tc = class {
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
    }
  }, rc = class {
    constructor(d, l, f) {
      this.type = "", this.start = l, this.end = 0, this.loc = new n(f), d != null && d.options.ranges && (this.range = [l, 0]), d != null && d.filename && (this.loc.filename = d.filename);
    }
  }, Od = rc.prototype;
  Od.__clone = function() {
    let d = new rc(void 0, this.start, this.loc.start), l = Object.keys(this);
    for (let f = 0, y = l.length; f < y; f++) {
      let v = l[f];
      v !== "leadingComments" && v !== "trailingComments" && v !== "innerComments" && (d[v] = this[v]);
    }
    return d;
  };
  function PP(d) {
    return xi(d);
  }
  function xi(d) {
    let { type: l, start: f, end: y, loc: v, range: E, extra: k, name: F } = d, N = Object.create(Od);
    return N.type = l, N.start = f, N.end = y, N.loc = v, N.range = E, N.extra = k, N.name = F, l === "Placeholder" && (N.expectedNode = d.expectedNode), N;
  }
  function FP(d) {
    let { type: l, start: f, end: y, loc: v, range: E, extra: k } = d;
    if (l === "Placeholder")
      return PP(d);
    let F = Object.create(Od);
    return F.type = l, F.start = f, F.end = y, F.loc = v, F.range = E, d.raw !== void 0 ? F.raw = d.raw : F.extra = k, F.value = d.value, F;
  }
  var $P = class extends kP {
    startNode() {
      let d = this.state.startLoc;
      return new rc(this, d.index, d);
    }
    startNodeAt(d) {
      return new rc(this, d.index, d);
    }
    startNodeAtNode(d) {
      return this.startNodeAt(d.loc.start);
    }
    finishNode(d, l) {
      return this.finishNodeAt(d, l, this.state.lastTokEndLoc);
    }
    finishNodeAt(d, l, f) {
      return d.type = l, d.end = f.index, d.loc.end = f, this.options.ranges && (d.range[1] = f.index), this.options.attachComment && this.processComment(d), d;
    }
    resetStartLocation(d, l) {
      d.start = l.index, d.loc.start = l, this.options.ranges && (d.range[0] = l.index);
    }
    resetEndLocation(d, l = this.state.lastTokEndLoc) {
      d.end = l.index, d.loc.end = l, this.options.ranges && (d.range[1] = l.index);
    }
    resetStartLocationFromNode(d, l) {
      this.resetStartLocation(d, l.loc.start);
    }
  }, BP = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), ve = S`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: d }) => `Cannot overwrite reserved type ${d}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: d, enumName: l }) => `Boolean enum members need to be initialized. Use either \`${d} = true,\` or \`${d} = false,\` in enum \`${l}\`.`, EnumDuplicateMemberName: ({ memberName: d, enumName: l }) => `Enum member names need to be unique, but the name \`${d}\` has already been used before in enum \`${l}\`.`, EnumInconsistentMemberValues: ({ enumName: d }) => `Enum \`${d}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: d, enumName: l }) => `Enum type \`${d}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${l}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: d }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${d}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: d, memberName: l, explicitType: f }) => `Enum \`${d}\` has type \`${f}\`, so the initializer of \`${l}\` needs to be a ${f} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: d, memberName: l }) => `Symbol enum members cannot be initialized. Use \`${l},\` in enum \`${d}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: d, memberName: l }) => `The enum member initializer for \`${l}\` needs to be a literal (either a boolean, number, or string) in enum \`${d}\`.`, EnumInvalidMemberName: ({ enumName: d, memberName: l, suggestion: f }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${l}\`, consider using \`${f}\`, in enum \`${d}\`.`, EnumNumberMemberNotInitialized: ({ enumName: d, memberName: l }) => `Number enum members need to be initialized, e.g. \`${l} = 1\` in enum \`${d}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: d }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${d}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: d }) => `Unexpected reserved type ${d}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: d, suggestion: l }) => `\`declare export ${d}\` is not supported. Use \`${l}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
  function IP(d) {
    return d.type === "DeclareExportAllDeclaration" || d.type === "DeclareExportDeclaration" && (!d.declaration || d.declaration.type !== "TypeAlias" && d.declaration.type !== "InterfaceDeclaration");
  }
  function uO(d) {
    return d.importKind === "type" || d.importKind === "typeof";
  }
  var NP = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
  function _P(d, l) {
    let f = [], y = [];
    for (let v = 0; v < d.length; v++)
      (l(d[v], v, d) ? f : y).push(d[v]);
    return [f, y];
  }
  var QP = /\*?\s*@((?:no)?flow)\b/, MP = (d) => class extends d {
    constructor(...l) {
      super(...l), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return Ca;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }
    finishToken(l, f) {
      l !== 133 && l !== 13 && l !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(l, f);
    }
    addComment(l) {
      if (this.flowPragma === void 0) {
        let f = QP.exec(l.value);
        if (f)
          if (f[1] === "flow")
            this.flowPragma = "flow";
          else if (f[1] === "noflow")
            this.flowPragma = "noflow";
          else
            throw new Error("Unexpected flow pragma");
      }
      super.addComment(l);
    }
    flowParseTypeInitialiser(l) {
      let f = this.state.inType;
      this.state.inType = !0, this.expect(l || 14);
      let y = this.flowParseType();
      return this.state.inType = f, y;
    }
    flowParsePredicate() {
      let l = this.startNode(), f = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > f.index + 1 && this.raise(ve.UnexpectedSpaceBetweenModuloChecks, f), this.eat(10) ? (l.value = super.parseExpression(), this.expect(11), this.finishNode(l, "DeclaredPredicate")) : this.finishNode(l, "InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let l = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let f = null, y = null;
      return this.match(54) ? (this.state.inType = l, y = this.flowParsePredicate()) : (f = this.flowParseType(), this.state.inType = l, this.match(54) && (y = this.flowParsePredicate())), [f, y];
    }
    flowParseDeclareClass(l) {
      return this.next(), this.flowParseInterfaceish(l, !0), this.finishNode(l, "DeclareClass");
    }
    flowParseDeclareFunction(l) {
      this.next();
      let f = l.id = this.parseIdentifier(), y = this.startNode(), v = this.startNode();
      this.match(47) ? y.typeParameters = this.flowParseTypeParameterDeclaration() : y.typeParameters = null, this.expect(10);
      let E = this.flowParseFunctionTypeParams();
      return y.params = E.params, y.rest = E.rest, y.this = E._this, this.expect(11), [y.returnType, l.predicate] = this.flowParseTypeAndPredicateInitialiser(), v.typeAnnotation = this.finishNode(y, "FunctionTypeAnnotation"), f.typeAnnotation = this.finishNode(v, "TypeAnnotation"), this.resetEndLocation(f), this.semicolon(), this.scope.declareName(l.id.name, 2048, l.id.loc.start), this.finishNode(l, "DeclareFunction");
    }
    flowParseDeclare(l, f) {
      if (this.match(80))
        return this.flowParseDeclareClass(l);
      if (this.match(68))
        return this.flowParseDeclareFunction(l);
      if (this.match(74))
        return this.flowParseDeclareVariable(l);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(l) : (f && this.raise(ve.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(l));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(l);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(l);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(l);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(l, f);
      this.unexpected();
    }
    flowParseDeclareVariable(l) {
      return this.next(), l.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(l.id.name, 5, l.id.loc.start), this.semicolon(), this.finishNode(l, "DeclareVariable");
    }
    flowParseDeclareModule(l) {
      this.scope.enter(0), this.match(133) ? l.id = super.parseExprAtom() : l.id = this.parseIdentifier();
      let f = l.body = this.startNode(), y = f.body = [];
      for (this.expect(5); !this.match(8); ) {
        let k = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(ve.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(k)) : (this.expectContextual(125, ve.UnsupportedStatementInDeclareModule), k = this.flowParseDeclare(k, !0)), y.push(k);
      }
      this.scope.exit(), this.expect(8), this.finishNode(f, "BlockStatement");
      let v = null, E = !1;
      return y.forEach((k) => {
        IP(k) ? (v === "CommonJS" && this.raise(ve.AmbiguousDeclareModuleKind, k), v = "ES") : k.type === "DeclareModuleExports" && (E && this.raise(ve.DuplicateDeclareModuleExports, k), v === "ES" && this.raise(ve.AmbiguousDeclareModuleKind, k), v = "CommonJS", E = !0);
      }), l.kind = v || "CommonJS", this.finishNode(l, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(l, f) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? l.declaration = this.flowParseDeclare(this.startNode()) : (l.declaration = this.flowParseType(), this.semicolon()), l.default = !0, this.finishNode(l, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !f) {
        let y = this.state.value;
        throw this.raise(ve.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: y, suggestion: NP[y] });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return l.declaration = this.flowParseDeclare(this.startNode()), l.default = !1, this.finishNode(l, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return l = this.parseExport(l, null), l.type === "ExportNamedDeclaration" && (l.type = "ExportDeclaration", l.default = !1, delete l.exportKind), l.type = "Declare" + l.type, l;
      this.unexpected();
    }
    flowParseDeclareModuleExports(l) {
      return this.next(), this.expectContextual(111), l.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(l, "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(l) {
      this.next();
      let f = this.flowParseTypeAlias(l);
      return f.type = "DeclareTypeAlias", f;
    }
    flowParseDeclareOpaqueType(l) {
      this.next();
      let f = this.flowParseOpaqueType(l, !0);
      return f.type = "DeclareOpaqueType", f;
    }
    flowParseDeclareInterface(l) {
      return this.next(), this.flowParseInterfaceish(l, !1), this.finishNode(l, "DeclareInterface");
    }
    flowParseInterfaceish(l, f) {
      if (l.id = this.flowParseRestrictedIdentifier(!f, !0), this.scope.declareName(l.id.name, f ? 17 : 8201, l.id.loc.start), this.match(47) ? l.typeParameters = this.flowParseTypeParameterDeclaration() : l.typeParameters = null, l.extends = [], this.eat(81))
        do
          l.extends.push(this.flowParseInterfaceExtends());
        while (!f && this.eat(12));
      if (f) {
        if (l.implements = [], l.mixins = [], this.eatContextual(117))
          do
            l.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            l.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      l.body = this.flowParseObjectType({ allowStatic: f, allowExact: !1, allowSpread: !1, allowProto: f, allowInexact: !1 });
    }
    flowParseInterfaceExtends() {
      let l = this.startNode();
      return l.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? l.typeParameters = this.flowParseTypeParameterInstantiation() : l.typeParameters = null, this.finishNode(l, "InterfaceExtends");
    }
    flowParseInterface(l) {
      return this.flowParseInterfaceish(l, !1), this.finishNode(l, "InterfaceDeclaration");
    }
    checkNotUnderscore(l) {
      l === "_" && this.raise(ve.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(l, f, y) {
      BP.has(l) && this.raise(y ? ve.AssignReservedType : ve.UnexpectedReservedType, f, { reservedType: l });
    }
    flowParseRestrictedIdentifier(l, f) {
      return this.checkReservedType(this.state.value, this.state.startLoc, f), this.parseIdentifier(l);
    }
    flowParseTypeAlias(l) {
      return l.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(l.id.name, 8201, l.id.loc.start), this.match(47) ? l.typeParameters = this.flowParseTypeParameterDeclaration() : l.typeParameters = null, l.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(l, "TypeAlias");
    }
    flowParseOpaqueType(l, f) {
      return this.expectContextual(130), l.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(l.id.name, 8201, l.id.loc.start), this.match(47) ? l.typeParameters = this.flowParseTypeParameterDeclaration() : l.typeParameters = null, l.supertype = null, this.match(14) && (l.supertype = this.flowParseTypeInitialiser(14)), l.impltype = null, f || (l.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(l, "OpaqueType");
    }
    flowParseTypeParameter(l = !1) {
      let f = this.state.startLoc, y = this.startNode(), v = this.flowParseVariance(), E = this.flowParseTypeAnnotatableIdentifier();
      return y.name = E.name, y.variance = v, y.bound = E.typeAnnotation, this.match(29) ? (this.eat(29), y.default = this.flowParseType()) : l && this.raise(ve.MissingTypeParamDefault, f), this.finishNode(y, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let l = this.state.inType, f = this.startNode();
      f.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let y = !1;
      do {
        let v = this.flowParseTypeParameter(y);
        f.params.push(v), v.default && (y = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = l, this.finishNode(f, "TypeParameterDeclaration");
    }
    flowParseTypeParameterInstantiation() {
      let l = this.startNode(), f = this.state.inType;
      l.params = [], this.state.inType = !0, this.expect(47);
      let y = this.state.noAnonFunctionType;
      for (this.state.noAnonFunctionType = !1; !this.match(48); )
        l.params.push(this.flowParseType()), this.match(48) || this.expect(12);
      return this.state.noAnonFunctionType = y, this.expect(48), this.state.inType = f, this.finishNode(l, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      let l = this.startNode(), f = this.state.inType;
      for (l.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        l.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = f, this.finishNode(l, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let l = this.startNode();
      if (this.expectContextual(129), l.extends = [], this.eat(81))
        do
          l.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return l.body = this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !1, allowProto: !1, allowInexact: !1 }), this.finishNode(l, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(l, f, y) {
      return l.static = f, this.lookahead().type === 14 ? (l.id = this.flowParseObjectPropertyKey(), l.key = this.flowParseTypeInitialiser()) : (l.id = null, l.key = this.flowParseType()), this.expect(3), l.value = this.flowParseTypeInitialiser(), l.variance = y, this.finishNode(l, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(l, f) {
      return l.static = f, l.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (l.method = !0, l.optional = !1, l.value = this.flowParseObjectTypeMethodish(this.startNodeAt(l.loc.start))) : (l.method = !1, this.eat(17) && (l.optional = !0), l.value = this.flowParseTypeInitialiser()), this.finishNode(l, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(l) {
      for (l.params = [], l.rest = null, l.typeParameters = null, l.this = null, this.match(47) && (l.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (l.this = this.flowParseFunctionTypeParam(!0), l.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        l.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (l.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), l.returnType = this.flowParseTypeInitialiser(), this.finishNode(l, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(l, f) {
      let y = this.startNode();
      return l.static = f, l.value = this.flowParseObjectTypeMethodish(y), this.finishNode(l, "ObjectTypeCallProperty");
    }
    flowParseObjectType({ allowStatic: l, allowExact: f, allowSpread: y, allowProto: v, allowInexact: E }) {
      let k = this.state.inType;
      this.state.inType = !0;
      let F = this.startNode();
      F.callProperties = [], F.properties = [], F.indexers = [], F.internalSlots = [];
      let N, I, U = !1;
      for (f && this.match(6) ? (this.expect(6), N = 9, I = !0) : (this.expect(5), N = 8, I = !1), F.exact = I; !this.match(N); ) {
        let he = !1, ce = null, He = null, Ge = this.startNode();
        if (v && this.isContextual(118)) {
          let nr = this.lookahead();
          nr.type !== 14 && nr.type !== 17 && (this.next(), ce = this.state.startLoc, l = !1);
        }
        if (l && this.isContextual(106)) {
          let nr = this.lookahead();
          nr.type !== 14 && nr.type !== 17 && (this.next(), he = !0);
        }
        let Pt = this.flowParseVariance();
        if (this.eat(0))
          ce != null && this.unexpected(ce), this.eat(0) ? (Pt && this.unexpected(Pt.loc.start), F.internalSlots.push(this.flowParseObjectTypeInternalSlot(Ge, he))) : F.indexers.push(this.flowParseObjectTypeIndexer(Ge, he, Pt));
        else if (this.match(10) || this.match(47))
          ce != null && this.unexpected(ce), Pt && this.unexpected(Pt.loc.start), F.callProperties.push(this.flowParseObjectTypeCallProperty(Ge, he));
        else {
          let nr = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let vd = this.lookahead();
            we(vd.type) && (nr = this.state.value, this.next());
          }
          let Qr = this.flowParseObjectTypeProperty(Ge, he, ce, Pt, nr, y, E ?? !I);
          Qr === null ? (U = !0, He = this.state.lastTokStartLoc) : F.properties.push(Qr);
        }
        this.flowObjectTypeSemicolon(), He && !this.match(8) && !this.match(9) && this.raise(ve.UnexpectedExplicitInexactInObject, He);
      }
      this.expect(N), y && (F.inexact = U);
      let ne = this.finishNode(F, "ObjectTypeAnnotation");
      return this.state.inType = k, ne;
    }
    flowParseObjectTypeProperty(l, f, y, v, E, k, F) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (k ? F || this.raise(ve.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(ve.InexactInsideNonObject, this.state.lastTokStartLoc), v && this.raise(ve.InexactVariance, v), null) : (k || this.raise(ve.UnexpectedSpreadType, this.state.lastTokStartLoc), y != null && this.unexpected(y), v && this.raise(ve.SpreadVariance, v), l.argument = this.flowParseType(), this.finishNode(l, "ObjectTypeSpreadProperty"));
      {
        l.key = this.flowParseObjectPropertyKey(), l.static = f, l.proto = y != null, l.kind = E;
        let N = !1;
        return this.match(47) || this.match(10) ? (l.method = !0, y != null && this.unexpected(y), v && this.unexpected(v.loc.start), l.value = this.flowParseObjectTypeMethodish(this.startNodeAt(l.loc.start)), (E === "get" || E === "set") && this.flowCheckGetterSetterParams(l), !k && l.key.name === "constructor" && l.value.this && this.raise(ve.ThisParamBannedInConstructor, l.value.this)) : (E !== "init" && this.unexpected(), l.method = !1, this.eat(17) && (N = !0), l.value = this.flowParseTypeInitialiser(), l.variance = v), l.optional = N, this.finishNode(l, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(l) {
      let f = l.kind === "get" ? 0 : 1, y = l.value.params.length + (l.value.rest ? 1 : 0);
      l.value.this && this.raise(l.kind === "get" ? ve.GetterMayNotHaveThisParam : ve.SetterMayNotHaveThisParam, l.value.this), y !== f && this.raise(l.kind === "get" ? x.BadGetterArity : x.BadSetterArity, l), l.kind === "set" && l.value.rest && this.raise(x.BadSetterRestParameter, l);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(l, f) {
      l != null || (l = this.state.startLoc);
      let y = f || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let v = this.startNodeAt(l);
        v.qualification = y, v.id = this.flowParseRestrictedIdentifier(!0), y = this.finishNode(v, "QualifiedTypeIdentifier");
      }
      return y;
    }
    flowParseGenericType(l, f) {
      let y = this.startNodeAt(l);
      return y.typeParameters = null, y.id = this.flowParseQualifiedTypeIdentifier(l, f), this.match(47) && (y.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(y, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let l = this.startNode();
      return this.expect(87), l.argument = this.flowParsePrimaryType(), this.finishNode(l, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let l = this.startNode();
      for (l.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (l.types.push(this.flowParseType()), !this.match(3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(l, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(l) {
      let f = null, y = !1, v = null, E = this.startNode(), k = this.lookahead(), F = this.state.type === 78;
      return k.type === 14 || k.type === 17 ? (F && !l && this.raise(ve.ThisParamMustBeFirst, E), f = this.parseIdentifier(F), this.eat(17) && (y = !0, F && this.raise(ve.ThisParamMayNotBeOptional, E)), v = this.flowParseTypeInitialiser()) : v = this.flowParseType(), E.name = f, E.optional = y, E.typeAnnotation = v, this.finishNode(E, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(l) {
      let f = this.startNodeAt(l.loc.start);
      return f.name = null, f.optional = !1, f.typeAnnotation = l, this.finishNode(f, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(l = []) {
      let f = null, y = null;
      for (this.match(78) && (y = this.flowParseFunctionTypeParam(!0), y.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
        l.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (f = this.flowParseFunctionTypeParam(!1)), { params: l, rest: f, _this: y };
    }
    flowIdentToTypeAnnotation(l, f, y) {
      switch (y.name) {
        case "any":
          return this.finishNode(f, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(f, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(f, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(f, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(f, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(f, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(f, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(y.name), this.flowParseGenericType(l, y);
      }
    }
    flowParsePrimaryType() {
      let l = this.state.startLoc, f = this.startNode(), y, v, E = !1, k = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !0, allowProto: !1, allowInexact: !0 });
        case 6:
          return this.flowParseObjectType({ allowStatic: !1, allowExact: !0, allowSpread: !0, allowProto: !1, allowInexact: !1 });
        case 0:
          return this.state.noAnonFunctionType = !1, v = this.flowParseTupleType(), this.state.noAnonFunctionType = k, v;
        case 47:
          return f.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), y = this.flowParseFunctionTypeParams(), f.params = y.params, f.rest = y.rest, f.this = y._this, this.expect(11), this.expect(19), f.returnType = this.flowParseType(), this.finishNode(f, "FunctionTypeAnnotation");
        case 10:
          if (this.next(), !this.match(11) && !this.match(21))
            if (j(this.state.type) || this.match(78)) {
              let F = this.lookahead().type;
              E = F !== 17 && F !== 14;
            } else
              E = !0;
          if (E) {
            if (this.state.noAnonFunctionType = !1, v = this.flowParseType(), this.state.noAnonFunctionType = k, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), v;
            this.eat(12);
          }
          return v ? y = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(v)]) : y = this.flowParseFunctionTypeParams(), f.params = y.params, f.rest = y.rest, f.this = y._this, this.expect(11), this.expect(19), f.returnType = this.flowParseType(), f.typeParameters = null, this.finishNode(f, "FunctionTypeAnnotation");
        case 133:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return f.value = this.match(85), this.next(), this.finishNode(f, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(134))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", f);
            if (this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", f);
            throw this.raise(ve.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          this.unexpected();
          return;
        case 134:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 135:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(f, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(f, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(f, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(f, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (tr(this.state.type)) {
            let F = Br(this.state.type);
            return this.next(), super.createIdentifier(f, F);
          } else if (j(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(l, f, this.parseIdentifier());
      }
      this.unexpected();
    }
    flowParsePostfixType() {
      let l = this.state.startLoc, f = this.flowParsePrimaryType(), y = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let v = this.startNodeAt(l), E = this.eat(18);
        y = y || E, this.expect(0), !E && this.match(3) ? (v.elementType = f, this.next(), f = this.finishNode(v, "ArrayTypeAnnotation")) : (v.objectType = f, v.indexType = this.flowParseType(), this.expect(3), y ? (v.optional = E, f = this.finishNode(v, "OptionalIndexedAccessType")) : f = this.finishNode(v, "IndexedAccessType"));
      }
      return f;
    }
    flowParsePrefixType() {
      let l = this.startNode();
      return this.eat(17) ? (l.typeAnnotation = this.flowParsePrefixType(), this.finishNode(l, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let l = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let f = this.startNodeAt(l.loc.start);
        return f.params = [this.reinterpretTypeAsFunctionTypeParam(l)], f.rest = null, f.this = null, f.returnType = this.flowParseType(), f.typeParameters = null, this.finishNode(f, "FunctionTypeAnnotation");
      }
      return l;
    }
    flowParseIntersectionType() {
      let l = this.startNode();
      this.eat(45);
      let f = this.flowParseAnonFunctionWithoutParens();
      for (l.types = [f]; this.eat(45); )
        l.types.push(this.flowParseAnonFunctionWithoutParens());
      return l.types.length === 1 ? f : this.finishNode(l, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let l = this.startNode();
      this.eat(43);
      let f = this.flowParseIntersectionType();
      for (l.types = [f]; this.eat(43); )
        l.types.push(this.flowParseIntersectionType());
      return l.types.length === 1 ? f : this.finishNode(l, "UnionTypeAnnotation");
    }
    flowParseType() {
      let l = this.state.inType;
      this.state.inType = !0;
      let f = this.flowParseUnionType();
      return this.state.inType = l, f;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let l = this.state.startLoc, f = this.parseIdentifier();
        return this.flowParseGenericType(l, f);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let l = this.startNode();
      return l.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(l, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(l) {
      let f = l ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (f.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(f)), f;
    }
    typeCastToParameter(l) {
      return l.expression.typeAnnotation = l.typeAnnotation, this.resetEndLocation(l.expression, l.typeAnnotation.loc.end), l.expression;
    }
    flowParseVariance() {
      let l = null;
      return this.match(53) ? (l = this.startNode(), this.state.value === "+" ? l.kind = "plus" : l.kind = "minus", this.next(), this.finishNode(l, "Variance")) : l;
    }
    parseFunctionBody(l, f, y = !1) {
      if (f) {
        this.forwardNoArrowParamsConversionAt(l, () => super.parseFunctionBody(l, !0, y));
        return;
      }
      super.parseFunctionBody(l, !1, y);
    }
    parseFunctionBodyAndFinish(l, f, y = !1) {
      if (this.match(14)) {
        let v = this.startNode();
        [v.typeAnnotation, l.predicate] = this.flowParseTypeAndPredicateInitialiser(), l.returnType = v.typeAnnotation ? this.finishNode(v, "TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(l, f, y);
    }
    parseStatementLike(l) {
      if (this.state.strict && this.isContextual(129)) {
        let y = this.lookahead();
        if (De(y.type)) {
          let v = this.startNode();
          return this.next(), this.flowParseInterface(v);
        }
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        let y = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(y);
      }
      let f = super.parseStatementLike(l);
      return this.flowPragma === void 0 && !this.isValidDirective(f) && (this.flowPragma = null), f;
    }
    parseExpressionStatement(l, f, y) {
      if (f.type === "Identifier") {
        if (f.name === "declare") {
          if (this.match(80) || j(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(l);
        } else if (j(this.state.type)) {
          if (f.name === "interface")
            return this.flowParseInterface(l);
          if (f.name === "type")
            return this.flowParseTypeAlias(l);
          if (f.name === "opaque")
            return this.flowParseOpaqueType(l, !1);
        }
      }
      return super.parseExpressionStatement(l, f, y);
    }
    shouldParseExportDeclaration() {
      let { type: l } = this.state;
      return It(l) || this.shouldParseEnums() && l === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let { type: l } = this.state;
      return It(l) || this.shouldParseEnums() && l === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual(126)) {
        let l = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(l);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(l, f, y) {
      if (!this.match(17))
        return l;
      if (this.state.maybeInArrowParameters) {
        let ne = this.lookaheadCharCode();
        if (ne === 44 || ne === 61 || ne === 58 || ne === 41)
          return this.setOptionalParametersError(y), l;
      }
      this.expect(17);
      let v = this.state.clone(), E = this.state.noArrowAt, k = this.startNodeAt(f), { consequent: F, failed: N } = this.tryParseConditionalConsequent(), [I, U] = this.getArrowLikeExpressions(F);
      if (N || U.length > 0) {
        let ne = [...E];
        if (U.length > 0) {
          this.state = v, this.state.noArrowAt = ne;
          for (let he = 0; he < U.length; he++)
            ne.push(U[he].start);
          ({ consequent: F, failed: N } = this.tryParseConditionalConsequent()), [I, U] = this.getArrowLikeExpressions(F);
        }
        N && I.length > 1 && this.raise(ve.AmbiguousConditionalArrow, v.startLoc), N && I.length === 1 && (this.state = v, ne.push(I[0].start), this.state.noArrowAt = ne, { consequent: F, failed: N } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(F, !0), this.state.noArrowAt = E, this.expect(14), k.test = l, k.consequent = F, k.alternate = this.forwardNoArrowParamsConversionAt(k, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(k, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let l = this.parseMaybeAssignAllowIn(), f = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), { consequent: l, failed: f };
    }
    getArrowLikeExpressions(l, f) {
      let y = [l], v = [];
      for (; y.length !== 0; ) {
        let E = y.pop();
        E.type === "ArrowFunctionExpression" ? (E.typeParameters || !E.returnType ? this.finishArrowValidation(E) : v.push(E), y.push(E.body)) : E.type === "ConditionalExpression" && (y.push(E.consequent), y.push(E.alternate));
      }
      return f ? (v.forEach((E) => this.finishArrowValidation(E)), [v, []]) : _P(v, (E) => E.params.every((k) => this.isAssignable(k, !0)));
    }
    finishArrowValidation(l) {
      var f;
      this.toAssignableList(l.params, (f = l.extra) == null ? void 0 : f.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(l, !1, !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(l, f) {
      let y;
      return this.state.noArrowParamsConversionAt.indexOf(l.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), y = f(), this.state.noArrowParamsConversionAt.pop()) : y = f(), y;
    }
    parseParenItem(l, f) {
      if (l = super.parseParenItem(l, f), this.eat(17) && (l.optional = !0, this.resetEndLocation(l)), this.match(14)) {
        let y = this.startNodeAt(f);
        return y.expression = l, y.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(y, "TypeCastExpression");
      }
      return l;
    }
    assertModuleNodeAllowed(l) {
      l.type === "ImportDeclaration" && (l.importKind === "type" || l.importKind === "typeof") || l.type === "ExportNamedDeclaration" && l.exportKind === "type" || l.type === "ExportAllDeclaration" && l.exportKind === "type" || super.assertModuleNodeAllowed(l);
    }
    parseExportDeclaration(l) {
      if (this.isContextual(130)) {
        l.exportKind = "type";
        let f = this.startNode();
        return this.next(), this.match(5) ? (l.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(l), null) : this.flowParseTypeAlias(f);
      } else if (this.isContextual(131)) {
        l.exportKind = "type";
        let f = this.startNode();
        return this.next(), this.flowParseOpaqueType(f, !1);
      } else if (this.isContextual(129)) {
        l.exportKind = "type";
        let f = this.startNode();
        return this.next(), this.flowParseInterface(f);
      } else if (this.shouldParseEnums() && this.isContextual(126)) {
        l.exportKind = "value";
        let f = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(f);
      } else
        return super.parseExportDeclaration(l);
    }
    eatExportStar(l) {
      return super.eatExportStar(l) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (l.exportKind = "type", this.next(), this.next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(l) {
      let { startLoc: f } = this.state, y = super.maybeParseExportNamespaceSpecifier(l);
      return y && l.exportKind === "type" && this.unexpected(f), y;
    }
    parseClassId(l, f, y) {
      super.parseClassId(l, f, y), this.match(47) && (l.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(l, f, y) {
      let { startLoc: v } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(l, f))
          return;
        f.declare = !0;
      }
      super.parseClassMember(l, f, y), f.declare && (f.type !== "ClassProperty" && f.type !== "ClassPrivateProperty" && f.type !== "PropertyDefinition" ? this.raise(ve.DeclareClassElement, v) : f.value && this.raise(ve.DeclareClassFieldInitializer, f.value));
    }
    isIterator(l) {
      return l === "iterator" || l === "asyncIterator";
    }
    readIterator() {
      let l = super.readWord1(), f = "@@" + l;
      (!this.isIterator(l) || !this.state.inType) && this.raise(x.InvalidIdentifier, this.state.curPosition(), { identifierName: f }), this.finishToken(132, f);
    }
    getTokenFromCode(l) {
      let f = this.input.charCodeAt(this.state.pos + 1);
      l === 123 && f === 124 ? this.finishOp(6, 2) : this.state.inType && (l === 62 || l === 60) ? this.finishOp(l === 62 ? 48 : 47, 1) : this.state.inType && l === 63 ? f === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : rn(l, f, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(l);
    }
    isAssignable(l, f) {
      return l.type === "TypeCastExpression" ? this.isAssignable(l.expression, f) : super.isAssignable(l, f);
    }
    toAssignable(l, f = !1) {
      !f && l.type === "AssignmentExpression" && l.left.type === "TypeCastExpression" && (l.left = this.typeCastToParameter(l.left)), super.toAssignable(l, f);
    }
    toAssignableList(l, f, y) {
      for (let v = 0; v < l.length; v++) {
        let E = l[v];
        (E == null ? void 0 : E.type) === "TypeCastExpression" && (l[v] = this.typeCastToParameter(E));
      }
      super.toAssignableList(l, f, y);
    }
    toReferencedList(l, f) {
      for (let v = 0; v < l.length; v++) {
        var y;
        let E = l[v];
        E && E.type === "TypeCastExpression" && !((y = E.extra) != null && y.parenthesized) && (l.length > 1 || !f) && this.raise(ve.TypeCastInPattern, E.typeAnnotation);
      }
      return l;
    }
    parseArrayLike(l, f, y, v) {
      let E = super.parseArrayLike(l, f, y, v);
      return f && !this.state.maybeInArrowParameters && this.toReferencedList(E.elements), E;
    }
    isValidLVal(l, f, y) {
      return l === "TypeCastExpression" || super.isValidLVal(l, f, y);
    }
    parseClassProperty(l) {
      return this.match(14) && (l.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(l);
    }
    parseClassPrivateProperty(l) {
      return this.match(14) && (l.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(l);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(l) {
      return !this.match(14) && super.isNonstaticConstructor(l);
    }
    pushClassMethod(l, f, y, v, E, k) {
      if (f.variance && this.unexpected(f.variance.loc.start), delete f.variance, this.match(47) && (f.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(l, f, y, v, E, k), f.params && E) {
        let F = f.params;
        F.length > 0 && this.isThisParam(F[0]) && this.raise(ve.ThisParamBannedInConstructor, f);
      } else if (f.type === "MethodDefinition" && E && f.value.params) {
        let F = f.value.params;
        F.length > 0 && this.isThisParam(F[0]) && this.raise(ve.ThisParamBannedInConstructor, f);
      }
    }
    pushClassPrivateMethod(l, f, y, v) {
      f.variance && this.unexpected(f.variance.loc.start), delete f.variance, this.match(47) && (f.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(l, f, y, v);
    }
    parseClassSuper(l) {
      if (super.parseClassSuper(l), l.superClass && this.match(47) && (l.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
        this.next();
        let f = l.implements = [];
        do {
          let y = this.startNode();
          y.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? y.typeParameters = this.flowParseTypeParameterInstantiation() : y.typeParameters = null, f.push(this.finishNode(y, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(l) {
      super.checkGetterSetterParams(l);
      let f = this.getObjectOrClassMethodParams(l);
      if (f.length > 0) {
        let y = f[0];
        this.isThisParam(y) && l.kind === "get" ? this.raise(ve.GetterMayNotHaveThisParam, y) : this.isThisParam(y) && this.raise(ve.SetterMayNotHaveThisParam, y);
      }
    }
    parsePropertyNamePrefixOperator(l) {
      l.variance = this.flowParseVariance();
    }
    parseObjPropValue(l, f, y, v, E, k, F) {
      l.variance && this.unexpected(l.variance.loc.start), delete l.variance;
      let N;
      this.match(47) && !k && (N = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let I = super.parseObjPropValue(l, f, y, v, E, k, F);
      return N && ((I.value || I).typeParameters = N), I;
    }
    parseAssignableListItemTypes(l) {
      return this.eat(17) && (l.type !== "Identifier" && this.raise(ve.PatternIsOptional, l), this.isThisParam(l) && this.raise(ve.ThisParamMayNotBeOptional, l), l.optional = !0), this.match(14) ? l.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(l) && this.raise(ve.ThisParamAnnotationRequired, l), this.match(29) && this.isThisParam(l) && this.raise(ve.ThisParamNoDefault, l), this.resetEndLocation(l), l;
    }
    parseMaybeDefault(l, f) {
      let y = super.parseMaybeDefault(l, f);
      return y.type === "AssignmentPattern" && y.typeAnnotation && y.right.start < y.typeAnnotation.start && this.raise(ve.TypeBeforeInitializer, y.typeAnnotation), y;
    }
    checkImportReflection(l) {
      super.checkImportReflection(l), l.module && l.importKind !== "value" && this.raise(ve.ImportReflectionHasImportType, l.specifiers[0].loc.start);
    }
    parseImportSpecifierLocal(l, f, y) {
      f.local = uO(l) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), l.specifiers.push(this.finishImportSpecifier(f, y));
    }
    isPotentialImportPhase(l) {
      if (super.isPotentialImportPhase(l))
        return !0;
      if (this.isContextual(130)) {
        if (!l)
          return !0;
        let f = this.lookaheadCharCode();
        return f === 123 || f === 42;
      }
      return !l && this.isContextual(87);
    }
    applyImportPhase(l, f, y, v) {
      if (super.applyImportPhase(l, f, y, v), f) {
        if (!y && this.match(65))
          return;
        l.exportKind = y === "type" ? y : "value";
      } else
        y === "type" && this.match(55) && this.unexpected(), l.importKind = y === "type" || y === "typeof" ? y : "value";
    }
    parseImportSpecifier(l, f, y, v, E) {
      let k = l.imported, F = null;
      k.type === "Identifier" && (k.name === "type" ? F = "type" : k.name === "typeof" && (F = "typeof"));
      let N = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let U = this.parseIdentifier(!0);
        F !== null && !De(this.state.type) ? (l.imported = U, l.importKind = F, l.local = xi(U)) : (l.imported = k, l.importKind = null, l.local = this.parseIdentifier());
      } else {
        if (F !== null && De(this.state.type))
          l.imported = this.parseIdentifier(!0), l.importKind = F;
        else {
          if (f)
            throw this.raise(x.ImportBindingIsString, l, { importName: k.value });
          l.imported = k, l.importKind = null;
        }
        this.eatContextual(93) ? l.local = this.parseIdentifier() : (N = !0, l.local = xi(l.imported));
      }
      let I = uO(l);
      return y && I && this.raise(ve.ImportTypeShorthandOnlyInPureImport, l), (y || I) && this.checkReservedType(l.local.name, l.local.loc.start, !0), N && !y && !I && this.checkReservedWord(l.local.name, l.loc.start, !0, !0), this.finishImportSpecifier(l, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(l, f) {
      let y = l.kind;
      y !== "get" && y !== "set" && this.match(47) && (l.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(l, f);
    }
    parseVarId(l, f) {
      super.parseVarId(l, f), this.match(14) && (l.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(l.id));
    }
    parseAsyncArrowFromCallExpression(l, f) {
      if (this.match(14)) {
        let y = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, l.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = y;
      }
      return super.parseAsyncArrowFromCallExpression(l, f);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(l, f) {
      var y;
      let v = null, E;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (v = this.state.clone(), E = this.tryParse(() => super.parseMaybeAssign(l, f), v), !E.error)
          return E.node;
        let { context: N } = this.state, I = N[N.length - 1];
        (I === $.j_oTag || I === $.j_expr) && N.pop();
      }
      if ((y = E) != null && y.error || this.match(47)) {
        var k, F;
        v = v || this.state.clone();
        let N, I = this.tryParse((ne) => {
          var he;
          N = this.flowParseTypeParameterDeclaration();
          let ce = this.forwardNoArrowParamsConversionAt(N, () => {
            let Ge = super.parseMaybeAssign(l, f);
            return this.resetStartLocationFromNode(Ge, N), Ge;
          });
          (he = ce.extra) != null && he.parenthesized && ne();
          let He = this.maybeUnwrapTypeCastExpression(ce);
          return He.type !== "ArrowFunctionExpression" && ne(), He.typeParameters = N, this.resetStartLocationFromNode(He, N), ce;
        }, v), U = null;
        if (I.node && this.maybeUnwrapTypeCastExpression(I.node).type === "ArrowFunctionExpression") {
          if (!I.error && !I.aborted)
            return I.node.async && this.raise(ve.UnexpectedTypeParameterBeforeAsyncArrowFunction, N), I.node;
          U = I.node;
        }
        if ((k = E) != null && k.node)
          return this.state = E.failState, E.node;
        if (U)
          return this.state = I.failState, U;
        throw (F = E) != null && F.thrown ? E.error : I.thrown ? I.error : this.raise(ve.UnexpectedTokenAfterTypeParameter, N);
      }
      return super.parseMaybeAssign(l, f);
    }
    parseArrow(l) {
      if (this.match(14)) {
        let f = this.tryParse(() => {
          let y = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let v = this.startNode();
          return [v.typeAnnotation, l.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = y, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), v;
        });
        if (f.thrown)
          return null;
        f.error && (this.state = f.failState), l.returnType = f.node.typeAnnotation ? this.finishNode(f.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(l);
    }
    shouldParseArrow(l) {
      return this.match(14) || super.shouldParseArrow(l);
    }
    setArrowFunctionParameters(l, f) {
      this.state.noArrowParamsConversionAt.indexOf(l.start) !== -1 ? l.params = f : super.setArrowFunctionParameters(l, f);
    }
    checkParams(l, f, y, v = !0) {
      if (!(y && this.state.noArrowParamsConversionAt.indexOf(l.start) !== -1)) {
        for (let E = 0; E < l.params.length; E++)
          this.isThisParam(l.params[E]) && E > 0 && this.raise(ve.ThisParamMustBeFirst, l.params[E]);
        super.checkParams(l, f, y, v);
      }
    }
    parseParenAndDistinguishExpression(l) {
      return super.parseParenAndDistinguishExpression(l && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }
    parseSubscripts(l, f, y) {
      if (l.type === "Identifier" && l.name === "async" && this.state.noArrowAt.indexOf(f.index) !== -1) {
        this.next();
        let v = this.startNodeAt(f);
        v.callee = l, v.arguments = super.parseCallExpressionArguments(11, !1), l = this.finishNode(v, "CallExpression");
      } else if (l.type === "Identifier" && l.name === "async" && this.match(47)) {
        let v = this.state.clone(), E = this.tryParse((F) => this.parseAsyncArrowWithTypeParameters(f) || F(), v);
        if (!E.error && !E.aborted)
          return E.node;
        let k = this.tryParse(() => super.parseSubscripts(l, f, y), v);
        if (k.node && !k.error)
          return k.node;
        if (E.node)
          return this.state = E.failState, E.node;
        if (k.node)
          return this.state = k.failState, k.node;
        throw E.error || k.error;
      }
      return super.parseSubscripts(l, f, y);
    }
    parseSubscript(l, f, y, v) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (v.optionalChainMember = !0, y)
          return v.stop = !0, l;
        this.next();
        let E = this.startNodeAt(f);
        return E.callee = l, E.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), E.arguments = this.parseCallExpressionArguments(11, !1), E.optional = !0, this.finishCallExpression(E, !0);
      } else if (!y && this.shouldParseTypes() && this.match(47)) {
        let E = this.startNodeAt(f);
        E.callee = l;
        let k = this.tryParse(() => (E.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), E.arguments = super.parseCallExpressionArguments(11, !1), v.optionalChainMember && (E.optional = !1), this.finishCallExpression(E, v.optionalChainMember)));
        if (k.node)
          return k.error && (this.state = k.failState), k.node;
      }
      return super.parseSubscript(l, f, y, v);
    }
    parseNewCallee(l) {
      super.parseNewCallee(l);
      let f = null;
      this.shouldParseTypes() && this.match(47) && (f = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), l.typeArguments = f;
    }
    parseAsyncArrowWithTypeParameters(l) {
      let f = this.startNodeAt(l);
      if (this.parseFunctionParams(f, !1), !!this.parseArrow(f))
        return super.parseArrowExpression(f, void 0, !0);
    }
    readToken_mult_modulo(l) {
      let f = this.input.charCodeAt(this.state.pos + 1);
      if (l === 42 && f === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(l);
    }
    readToken_pipe_amp(l) {
      let f = this.input.charCodeAt(this.state.pos + 1);
      if (l === 124 && f === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(l);
    }
    parseTopLevel(l, f) {
      let y = super.parseTopLevel(l, f);
      return this.state.hasFlowComment && this.raise(ve.UnterminatedFlowComment, this.state.curPosition()), y;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(ve.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let l = this.skipFlowComment();
        l && (this.state.pos += l, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let { pos: l } = this.state, f = 2;
      for (; [32, 9].includes(this.input.charCodeAt(l + f)); )
        f++;
      let y = this.input.charCodeAt(f + l), v = this.input.charCodeAt(f + l + 1);
      return y === 58 && v === 58 ? f + 2 : this.input.slice(f + l, f + l + 12) === "flow-include" ? f + 12 : y === 58 && v !== 58 ? f : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(x.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(l, { enumName: f, memberName: y }) {
      this.raise(ve.EnumBooleanMemberNotInitialized, l, { memberName: y, enumName: f });
    }
    flowEnumErrorInvalidMemberInitializer(l, f) {
      return this.raise(f.explicitType ? f.explicitType === "symbol" ? ve.EnumInvalidMemberInitializerSymbolType : ve.EnumInvalidMemberInitializerPrimaryType : ve.EnumInvalidMemberInitializerUnknownType, l, f);
    }
    flowEnumErrorNumberMemberNotInitialized(l, f) {
      this.raise(ve.EnumNumberMemberNotInitialized, l, f);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(l, f) {
      this.raise(ve.EnumStringMemberInconsistentlyInitialized, l, f);
    }
    flowEnumMemberInit() {
      let l = this.state.startLoc, f = () => this.match(12) || this.match(8);
      switch (this.state.type) {
        case 134: {
          let y = this.parseNumericLiteral(this.state.value);
          return f() ? { type: "number", loc: y.loc.start, value: y } : { type: "invalid", loc: l };
        }
        case 133: {
          let y = this.parseStringLiteral(this.state.value);
          return f() ? { type: "string", loc: y.loc.start, value: y } : { type: "invalid", loc: l };
        }
        case 85:
        case 86: {
          let y = this.parseBooleanLiteral(this.match(85));
          return f() ? { type: "boolean", loc: y.loc.start, value: y } : { type: "invalid", loc: l };
        }
        default:
          return { type: "invalid", loc: l };
      }
    }
    flowEnumMemberRaw() {
      let l = this.state.startLoc, f = this.parseIdentifier(!0), y = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: l };
      return { id: f, init: y };
    }
    flowEnumCheckExplicitTypeMismatch(l, f, y) {
      let { explicitType: v } = f;
      v !== null && v !== y && this.flowEnumErrorInvalidMemberInitializer(l, f);
    }
    flowEnumMembers({ enumName: l, explicitType: f }) {
      let y = /* @__PURE__ */ new Set(), v = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, E = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          E = !0;
          break;
        }
        let k = this.startNode(), { id: F, init: N } = this.flowEnumMemberRaw(), I = F.name;
        if (I === "")
          continue;
        /^[a-z]/.test(I) && this.raise(ve.EnumInvalidMemberName, F, { memberName: I, suggestion: I[0].toUpperCase() + I.slice(1), enumName: l }), y.has(I) && this.raise(ve.EnumDuplicateMemberName, F, { memberName: I, enumName: l }), y.add(I);
        let U = { enumName: l, explicitType: f, memberName: I };
        switch (k.id = F, N.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(N.loc, U, "boolean"), k.init = N.value, v.booleanMembers.push(this.finishNode(k, "EnumBooleanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(N.loc, U, "number"), k.init = N.value, v.numberMembers.push(this.finishNode(k, "EnumNumberMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(N.loc, U, "string"), k.init = N.value, v.stringMembers.push(this.finishNode(k, "EnumStringMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(N.loc, U);
          case "none":
            switch (f) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(N.loc, U);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(N.loc, U);
                break;
              default:
                v.defaultedMembers.push(this.finishNode(k, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return { members: v, hasUnknownMembers: E };
    }
    flowEnumStringMembers(l, f, { enumName: y }) {
      if (l.length === 0)
        return f;
      if (f.length === 0)
        return l;
      if (f.length > l.length) {
        for (let v of l)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(v, { enumName: y });
        return f;
      } else {
        for (let v of f)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(v, { enumName: y });
        return l;
      }
    }
    flowEnumParseExplicitType({ enumName: l }) {
      if (!this.eatContextual(102))
        return null;
      if (!j(this.state.type))
        throw this.raise(ve.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: l });
      let { value: f } = this.state;
      return this.next(), f !== "boolean" && f !== "number" && f !== "string" && f !== "symbol" && this.raise(ve.EnumInvalidExplicitType, this.state.startLoc, { enumName: l, invalidEnumType: f }), f;
    }
    flowEnumBody(l, f) {
      let y = f.name, v = f.loc.start, E = this.flowEnumParseExplicitType({ enumName: y });
      this.expect(5);
      let { members: k, hasUnknownMembers: F } = this.flowEnumMembers({ enumName: y, explicitType: E });
      switch (l.hasUnknownMembers = F, E) {
        case "boolean":
          return l.explicitType = !0, l.members = k.booleanMembers, this.expect(8), this.finishNode(l, "EnumBooleanBody");
        case "number":
          return l.explicitType = !0, l.members = k.numberMembers, this.expect(8), this.finishNode(l, "EnumNumberBody");
        case "string":
          return l.explicitType = !0, l.members = this.flowEnumStringMembers(k.stringMembers, k.defaultedMembers, { enumName: y }), this.expect(8), this.finishNode(l, "EnumStringBody");
        case "symbol":
          return l.members = k.defaultedMembers, this.expect(8), this.finishNode(l, "EnumSymbolBody");
        default: {
          let N = () => (l.members = [], this.expect(8), this.finishNode(l, "EnumStringBody"));
          l.explicitType = !1;
          let I = k.booleanMembers.length, U = k.numberMembers.length, ne = k.stringMembers.length, he = k.defaultedMembers.length;
          if (!I && !U && !ne && !he)
            return N();
          if (!I && !U)
            return l.members = this.flowEnumStringMembers(k.stringMembers, k.defaultedMembers, { enumName: y }), this.expect(8), this.finishNode(l, "EnumStringBody");
          if (!U && !ne && I >= he) {
            for (let ce of k.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(ce.loc.start, { enumName: y, memberName: ce.id.name });
            return l.members = k.booleanMembers, this.expect(8), this.finishNode(l, "EnumBooleanBody");
          } else if (!I && !ne && U >= he) {
            for (let ce of k.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(ce.loc.start, { enumName: y, memberName: ce.id.name });
            return l.members = k.numberMembers, this.expect(8), this.finishNode(l, "EnumNumberBody");
          } else
            return this.raise(ve.EnumInconsistentMemberValues, v, { enumName: y }), N();
        }
      }
    }
    flowParseEnumDeclaration(l) {
      let f = this.parseIdentifier();
      return l.id = f, l.body = this.flowEnumBody(this.startNode(), f), this.finishNode(l, "EnumDeclaration");
    }
    isLookaheadToken_lt() {
      let l = this.nextTokenStart();
      if (this.input.charCodeAt(l) === 60) {
        let f = this.input.charCodeAt(l + 1);
        return f !== 60 && f !== 61;
      }
      return !1;
    }
    maybeUnwrapTypeCastExpression(l) {
      return l.type === "TypeCastExpression" ? l.expression : l;
    }
  }, $s = S`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: d }) => `Expected corresponding JSX closing tag for <${d}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: d, HTMLEntity: l }) => `Unexpected token \`${d}\`. Did you mean \`${l}\` or \`{'${d}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
  function Wi(d) {
    return d ? d.type === "JSXOpeningFragment" || d.type === "JSXClosingFragment" : !1;
  }
  function Ea(d) {
    if (d.type === "JSXIdentifier")
      return d.name;
    if (d.type === "JSXNamespacedName")
      return d.namespace.name + ":" + d.name.name;
    if (d.type === "JSXMemberExpression")
      return Ea(d.object) + "." + Ea(d.property);
    throw new Error("Node had unexpected type: " + d.type);
  }
  var LP = (d) => class extends d {
    jsxReadToken() {
      let l = "", f = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise($s.UnterminatedJsxContent, this.state.startLoc);
        let y = this.input.charCodeAt(this.state.pos);
        switch (y) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              y === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(y);
              return;
            }
            l += this.input.slice(f, this.state.pos), this.finishToken(141, l);
            return;
          case 38:
            l += this.input.slice(f, this.state.pos), l += this.jsxReadEntity(), f = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            Zo(y) ? (l += this.input.slice(f, this.state.pos), l += this.jsxReadNewLine(!0), f = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(l) {
      let f = this.input.charCodeAt(this.state.pos), y;
      return ++this.state.pos, f === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, y = l ? `
` : `\r
`) : y = String.fromCharCode(f), ++this.state.curLine, this.state.lineStart = this.state.pos, y;
    }
    jsxReadString(l) {
      let f = "", y = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(x.UnterminatedString, this.state.startLoc);
        let v = this.input.charCodeAt(this.state.pos);
        if (v === l)
          break;
        v === 38 ? (f += this.input.slice(y, this.state.pos), f += this.jsxReadEntity(), y = this.state.pos) : Zo(v) ? (f += this.input.slice(y, this.state.pos), f += this.jsxReadNewLine(!1), y = this.state.pos) : ++this.state.pos;
      }
      f += this.input.slice(y, this.state.pos++), this.finishToken(133, f);
    }
    jsxReadEntity() {
      let l = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let f = 10;
        this.codePointAtPos(this.state.pos) === 120 && (f = 16, ++this.state.pos);
        let y = this.readInt(f, void 0, !1, "bail");
        if (y !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(y);
      } else {
        let f = 0, y = !1;
        for (; f++ < 10 && this.state.pos < this.length && !(y = this.codePointAtPos(this.state.pos) == 59); )
          ++this.state.pos;
        if (y) {
          this.input.slice(l, this.state.pos);
          let v;
          ++this.state.pos;
        }
      }
      return this.state.pos = l, "&";
    }
    jsxReadWord() {
      let l, f = this.state.pos;
      do
        l = this.input.charCodeAt(++this.state.pos);
      while (Ie(l) || l === 45);
      this.finishToken(140, this.input.slice(f, this.state.pos));
    }
    jsxParseIdentifier() {
      let l = this.startNode();
      return this.match(140) ? l.name = this.state.value : tr(this.state.type) ? l.name = Br(this.state.type) : this.unexpected(), this.next(), this.finishNode(l, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let l = this.state.startLoc, f = this.jsxParseIdentifier();
      if (!this.eat(14))
        return f;
      let y = this.startNodeAt(l);
      return y.namespace = f, y.name = this.jsxParseIdentifier(), this.finishNode(y, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let l = this.state.startLoc, f = this.jsxParseNamespacedName();
      if (f.type === "JSXNamespacedName")
        return f;
      for (; this.eat(16); ) {
        let y = this.startNodeAt(l);
        y.object = f, y.property = this.jsxParseIdentifier(), f = this.finishNode(y, "JSXMemberExpression");
      }
      return f;
    }
    jsxParseAttributeValue() {
      let l;
      switch (this.state.type) {
        case 5:
          return l = this.startNode(), this.setContext($.brace), this.next(), l = this.jsxParseExpressionContainer(l, $.j_oTag), l.expression.type === "JSXEmptyExpression" && this.raise($s.AttributeIsEmpty, l), l;
        case 142:
        case 133:
          return this.parseExprAtom();
        default:
          throw this.raise($s.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let l = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(l, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(l) {
      return this.next(), l.expression = this.parseExpression(), this.setContext($.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(l, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(l, f) {
      if (this.match(8))
        l.expression = this.jsxParseEmptyExpression();
      else {
        let y = this.parseExpression();
        l.expression = y;
      }
      return this.setContext(f), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(l, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let l = this.startNode();
      return this.match(5) ? (this.setContext($.brace), this.next(), this.expect(21), l.argument = this.parseMaybeAssignAllowIn(), this.setContext($.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(l, "JSXSpreadAttribute")) : (l.name = this.jsxParseNamespacedName(), l.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(l, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(l) {
      let f = this.startNodeAt(l);
      return this.eat(143) ? this.finishNode(f, "JSXOpeningFragment") : (f.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(f));
    }
    jsxParseOpeningElementAfterName(l) {
      let f = [];
      for (; !this.match(56) && !this.match(143); )
        f.push(this.jsxParseAttribute());
      return l.attributes = f, l.selfClosing = this.eat(56), this.expect(143), this.finishNode(l, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(l) {
      let f = this.startNodeAt(l);
      return this.eat(143) ? this.finishNode(f, "JSXClosingFragment") : (f.name = this.jsxParseElementName(), this.expect(143), this.finishNode(f, "JSXClosingElement"));
    }
    jsxParseElementAt(l) {
      let f = this.startNodeAt(l), y = [], v = this.jsxParseOpeningElementAt(l), E = null;
      if (!v.selfClosing) {
        e:
          for (; ; )
            switch (this.state.type) {
              case 142:
                if (l = this.state.startLoc, this.next(), this.eat(56)) {
                  E = this.jsxParseClosingElementAt(l);
                  break e;
                }
                y.push(this.jsxParseElementAt(l));
                break;
              case 141:
                y.push(this.parseExprAtom());
                break;
              case 5: {
                let k = this.startNode();
                this.setContext($.brace), this.next(), this.match(21) ? y.push(this.jsxParseSpreadChild(k)) : y.push(this.jsxParseExpressionContainer(k, $.j_expr));
                break;
              }
              default:
                this.unexpected();
            }
        Wi(v) && !Wi(E) && E !== null ? this.raise($s.MissingClosingTagFragment, E) : !Wi(v) && Wi(E) ? this.raise($s.MissingClosingTagElement, E, { openingTagName: Ea(v.name) }) : !Wi(v) && !Wi(E) && Ea(E.name) !== Ea(v.name) && this.raise($s.MissingClosingTagElement, E, { openingTagName: Ea(v.name) });
      }
      if (Wi(v) ? (f.openingFragment = v, f.closingFragment = E) : (f.openingElement = v, f.closingElement = E), f.children = y, this.match(47))
        throw this.raise($s.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return Wi(v) ? this.finishNode(f, "JSXFragment") : this.finishNode(f, "JSXElement");
    }
    jsxParseElement() {
      let l = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(l);
    }
    setContext(l) {
      let { context: f } = this.state;
      f[f.length - 1] = l;
    }
    parseExprAtom(l) {
      return this.match(141) ? this.parseLiteral(this.state.value, "JSXText") : this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(l);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(l) {
      let f = this.curContext();
      if (f === $.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (f === $.j_oTag || f === $.j_cTag) {
        if (_e(l)) {
          this.jsxReadWord();
          return;
        }
        if (l === 62) {
          ++this.state.pos, this.finishToken(143);
          return;
        }
        if ((l === 34 || l === 39) && f === $.j_oTag) {
          this.jsxReadString(l);
          return;
        }
      }
      if (l === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(142);
        return;
      }
      super.getTokenFromCode(l);
    }
    updateContext(l) {
      let { context: f, type: y } = this.state;
      if (y === 56 && l === 142)
        f.splice(-2, 2, $.j_cTag), this.state.canStartJSXElement = !1;
      else if (y === 142)
        f.push($.j_oTag);
      else if (y === 143) {
        let v = f[f.length - 1];
        v === $.j_oTag && l === 56 || v === $.j_cTag ? (f.pop(), this.state.canStartJSXElement = f[f.length - 1] === $.j_expr) : (this.setContext($.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = Dt(y);
    }
  }, RP = class extends gi {
    constructor(...d) {
      super(...d), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, jP = class extends yi {
    constructor(...d) {
      super(...d), this.importsStack = [];
    }
    createScope(d) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new RP(d);
    }
    enter(d) {
      d == 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(d);
    }
    exit() {
      let d = super.exit();
      return d == 256 && this.importsStack.pop(), d;
    }
    hasImport(d, l) {
      let f = this.importsStack.length;
      if (this.importsStack[f - 1].has(d))
        return !0;
      if (!l && f > 1) {
        for (let y = 0; y < f - 1; y++)
          if (this.importsStack[y].has(d))
            return !0;
      }
      return !1;
    }
    declareName(d, l, f) {
      if (l & 4096) {
        this.hasImport(d, !0) && this.parser.raise(x.VarRedeclaration, f, { identifierName: d }), this.importsStack[this.importsStack.length - 1].add(d);
        return;
      }
      let y = this.currentScope(), v = y.tsNames.get(d) || 0;
      if (l & 1024) {
        this.maybeExportDefined(y, d), y.tsNames.set(d, v | 16);
        return;
      }
      super.declareName(d, l, f), l & 2 && (l & 1 || (this.checkRedeclarationInScope(y, d, l, f), this.maybeExportDefined(y, d)), v = v | 1), l & 256 && (v = v | 2), l & 512 && (v = v | 4), l & 128 && (v = v | 8), v && y.tsNames.set(d, v);
    }
    isRedeclaredInScope(d, l, f) {
      let y = d.tsNames.get(l);
      if ((y & 2) > 0) {
        if (f & 256) {
          let v = !!(f & 512), E = (y & 4) > 0;
          return v !== E;
        }
        return !0;
      }
      return f & 128 && (y & 8) > 0 ? d.names.get(l) & 2 ? !!(f & 1) : !1 : f & 2 && (y & 1) > 0 ? !0 : super.isRedeclaredInScope(d, l, f);
    }
    checkLocalExport(d) {
      let { name: l } = d;
      if (this.hasImport(l))
        return;
      let f = this.scopeStack.length;
      for (let y = f - 1; y >= 0; y--) {
        let v = this.scopeStack[y].tsNames.get(l);
        if ((v & 1) > 0 || (v & 16) > 0)
          return;
      }
      super.checkLocalExport(d);
    }
  }, ZP = (d, l) => Object.hasOwnProperty.call(d, l) && d[l], cO = (d) => d.type === "ParenthesizedExpression" ? cO(d.expression) : d, WP = class extends $P {
    toAssignable(d, l = !1) {
      var f, y;
      let v;
      switch ((d.type === "ParenthesizedExpression" || (f = d.extra) != null && f.parenthesized) && (v = cO(d), l ? v.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(x.InvalidParenthesizedAssignment, d) : v.type !== "MemberExpression" && !this.isOptionalMemberExpression(v) && this.raise(x.InvalidParenthesizedAssignment, d) : this.raise(x.InvalidParenthesizedAssignment, d)), d.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          d.type = "ObjectPattern";
          for (let k = 0, F = d.properties.length, N = F - 1; k < F; k++) {
            var E;
            let I = d.properties[k], U = k === N;
            this.toAssignableObjectExpressionProp(I, U, l), U && I.type === "RestElement" && (E = d.extra) != null && E.trailingCommaLoc && this.raise(x.RestTrailingComma, d.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let { key: k, value: F } = d;
          this.isPrivateName(k) && this.classScope.usePrivateName(this.getPrivateNameSV(k), k.loc.start), this.toAssignable(F, l);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
        case "ArrayExpression":
          d.type = "ArrayPattern", this.toAssignableList(d.elements, (y = d.extra) == null ? void 0 : y.trailingCommaLoc, l);
          break;
        case "AssignmentExpression":
          d.operator !== "=" && this.raise(x.MissingEqInAssignment, d.left.loc.end), d.type = "AssignmentPattern", delete d.operator, this.toAssignable(d.left, l);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(v, l);
          break;
      }
    }
    toAssignableObjectExpressionProp(d, l, f) {
      if (d.type === "ObjectMethod")
        this.raise(d.kind === "get" || d.kind === "set" ? x.PatternHasAccessor : x.PatternHasMethod, d.key);
      else if (d.type === "SpreadElement") {
        d.type = "RestElement";
        let y = d.argument;
        this.checkToRestConversion(y, !1), this.toAssignable(y, f), l || this.raise(x.RestTrailingComma, d);
      } else
        this.toAssignable(d, f);
    }
    toAssignableList(d, l, f) {
      let y = d.length - 1;
      for (let v = 0; v <= y; v++) {
        let E = d[v];
        if (E) {
          if (E.type === "SpreadElement") {
            E.type = "RestElement";
            let k = E.argument;
            this.checkToRestConversion(k, !0), this.toAssignable(k, f);
          } else
            this.toAssignable(E, f);
          E.type === "RestElement" && (v < y ? this.raise(x.RestTrailingComma, E) : l && this.raise(x.RestTrailingComma, l));
        }
      }
    }
    isAssignable(d, l) {
      switch (d.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          return !0;
        case "ObjectExpression": {
          let f = d.properties.length - 1;
          return d.properties.every((y, v) => y.type !== "ObjectMethod" && (v === f || y.type !== "SpreadElement") && this.isAssignable(y));
        }
        case "ObjectProperty":
          return this.isAssignable(d.value);
        case "SpreadElement":
          return this.isAssignable(d.argument);
        case "ArrayExpression":
          return d.elements.every((f) => f === null || this.isAssignable(f));
        case "AssignmentExpression":
          return d.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(d.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !l;
        default:
          return !1;
      }
    }
    toReferencedList(d, l) {
      return d;
    }
    toReferencedListDeep(d, l) {
      this.toReferencedList(d, l);
      for (let f of d)
        (f == null ? void 0 : f.type) === "ArrayExpression" && this.toReferencedListDeep(f.elements);
    }
    parseSpread(d) {
      let l = this.startNode();
      return this.next(), l.argument = this.parseMaybeAssignAllowIn(d, void 0), this.finishNode(l, "SpreadElement");
    }
    parseRestBinding() {
      let d = this.startNode();
      return this.next(), d.argument = this.parseBindingAtom(), this.finishNode(d, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let d = this.startNode();
          return this.next(), d.elements = this.parseBindingList(3, 93, 1), this.finishNode(d, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
      }
      return this.parseIdentifier();
    }
    parseBindingList(d, l, f) {
      let y = f & 1, v = [], E = !0;
      for (; !this.eat(d); )
        if (E ? E = !1 : this.expect(12), y && this.match(12))
          v.push(null);
        else {
          if (this.eat(d))
            break;
          if (this.match(21)) {
            if (v.push(this.parseAssignableListItemTypes(this.parseRestBinding(), f)), !this.checkCommaAfterRest(l)) {
              this.expect(d);
              break;
            }
          } else {
            let k = [];
            for (this.match(26) && this.hasPlugin("decorators") && this.raise(x.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
              k.push(this.parseDecorator());
            v.push(this.parseAssignableListItem(f, k));
          }
        }
      return v;
    }
    parseBindingRestProperty(d) {
      return this.next(), d.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(d, "RestElement");
    }
    parseBindingProperty() {
      let d = this.startNode(), { type: l, startLoc: f } = this.state;
      return l === 21 ? this.parseBindingRestProperty(d) : (l === 138 ? (this.expectPlugin("destructuringPrivate", f), this.classScope.usePrivateName(this.state.value, f), d.key = this.parsePrivateName()) : this.parsePropertyName(d), d.method = !1, this.parseObjPropValue(d, f, !1, !1, !0, !1));
    }
    parseAssignableListItem(d, l) {
      let f = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(f, d);
      let y = this.parseMaybeDefault(f.loc.start, f);
      return l.length && (f.decorators = l), y;
    }
    parseAssignableListItemTypes(d, l) {
      return d;
    }
    parseMaybeDefault(d, l) {
      var f;
      if (d != null || (d = this.state.startLoc), l = (f = l) != null ? f : this.parseBindingAtom(), !this.eat(29))
        return l;
      let y = this.startNodeAt(d);
      return y.left = l, y.right = this.parseMaybeAssignAllowIn(), this.finishNode(y, "AssignmentPattern");
    }
    isValidLVal(d, l, f) {
      return ZP({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, d);
    }
    isOptionalMemberExpression(d) {
      return d.type === "OptionalMemberExpression";
    }
    checkLVal(d, { in: l, binding: f = 64, checkClashes: y = !1, strictModeChanged: v = !1, hasParenthesizedAncestor: E = !1 }) {
      var k;
      let F = d.type;
      if (this.isObjectMethod(d))
        return;
      let N = this.isOptionalMemberExpression(d);
      if (N || F === "MemberExpression") {
        N && (this.expectPlugin("optionalChainingAssign", d.loc.start), l.type !== "AssignmentExpression" && this.raise(x.InvalidLhsOptionalChaining, d, { ancestor: l })), f !== 64 && this.raise(x.InvalidPropertyBindingPattern, d);
        return;
      }
      if (F === "Identifier") {
        this.checkIdentifier(d, f, v);
        let { name: ce } = d;
        y && (y.has(ce) ? this.raise(x.ParamDupe, d) : y.add(ce));
        return;
      }
      let I = this.isValidLVal(F, !(E || (k = d.extra) != null && k.parenthesized) && l.type === "AssignmentExpression", f);
      if (I === !0)
        return;
      if (I === !1) {
        let ce = f === 64 ? x.InvalidLhs : x.InvalidLhsBinding;
        this.raise(ce, d, { ancestor: l });
        return;
      }
      let [U, ne] = Array.isArray(I) ? I : [I, F === "ParenthesizedExpression"], he = F === "ArrayPattern" || F === "ObjectPattern" ? { type: F } : l;
      for (let ce of [].concat(d[U]))
        ce && this.checkLVal(ce, { in: he, binding: f, checkClashes: y, strictModeChanged: v, hasParenthesizedAncestor: ne });
    }
    checkIdentifier(d, l, f = !1) {
      this.state.strict && (f ? pr(d.name, this.inModule) : Sn(d.name)) && (l === 64 ? this.raise(x.StrictEvalArguments, d, { referenceName: d.name }) : this.raise(x.StrictEvalArgumentsBinding, d, { bindingName: d.name })), l & 8192 && d.name === "let" && this.raise(x.LetInLexicalBinding, d), l & 64 || this.declareNameFromIdentifier(d, l);
    }
    declareNameFromIdentifier(d, l) {
      this.scope.declareName(d.name, l, d.loc.start);
    }
    checkToRestConversion(d, l) {
      switch (d.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(d.expression, l);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (l)
            break;
        default:
          this.raise(x.InvalidRestAssignmentPattern, d);
      }
    }
    checkCommaAfterRest(d) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === d ? x.RestTrailingComma : x.ElementAfterRest, this.state.startLoc), !0) : !1;
    }
  }, qP = (d, l) => Object.hasOwnProperty.call(d, l) && d[l];
  function XP(d) {
    if (d == null)
      throw new Error(`Unexpected ${d} value.`);
    return d;
  }
  function hO(d) {
    if (!d)
      throw new Error("Assert fail");
  }
  var ge = S`typescript`({ AbstractMethodHasImplementation: ({ methodName: d }) => `Method '${d}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: d }) => `Property '${d}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: d }) => `'declare' is not allowed in ${d}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: d }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier: d }) => `Duplicate modifier: '${d}'.`, EmptyHeritageClauseType: ({ token: d }) => `'${d}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: d }) => `'${d[0]}' modifier cannot be used with '${d[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: d }) => `Index signatures cannot have an accessibility modifier ('${d}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier: d }) => `'${d}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: d }) => `'${d}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: d }) => `'${d}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: d }) => `'${d[0]}' modifier must precede '${d[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: d }) => `Private elements cannot have an accessibility modifier ('${d}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: d }) => `Single type parameter ${d} should have a trailing comma. Example usage: <${d},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: d }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${d}.` });
  function VP(d) {
    switch (d) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  function pO(d) {
    return d === "private" || d === "public" || d === "protected";
  }
  function YP(d) {
    return d === "in" || d === "out";
  }
  var UP = (d) => class extends d {
    constructor(...l) {
      super(...l), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: ge.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: ge.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: ge.InvalidModifierOnTypeParameter });
    }
    getScopeHandler() {
      return jP;
    }
    tsIsIdentifier() {
      return j(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }
    tsNextTokenCanFollowModifier() {
      return this.next(), this.tsTokenCanFollowModifier();
    }
    tsParseModifier(l, f) {
      if (!j(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let y = this.state.value;
      if (l.indexOf(y) !== -1) {
        if (f && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return y;
      }
    }
    tsParseModifiers({ allowedModifiers: l, disallowedModifiers: f, stopOnStartOfClassStaticBlock: y, errorTemplate: v = ge.InvalidModifierOnTypeMember }, E) {
      let k = (N, I, U, ne) => {
        I === U && E[ne] && this.raise(ge.InvalidModifiersOrder, N, { orderedModifiers: [U, ne] });
      }, F = (N, I, U, ne) => {
        (E[U] && I === ne || E[ne] && I === U) && this.raise(ge.IncompatibleModifiers, N, { modifiers: [U, ne] });
      };
      for (; ; ) {
        let { startLoc: N } = this.state, I = this.tsParseModifier(l.concat(f ?? []), y);
        if (!I)
          break;
        pO(I) ? E.accessibility ? this.raise(ge.DuplicateAccessibilityModifier, N, { modifier: I }) : (k(N, I, I, "override"), k(N, I, I, "static"), k(N, I, I, "readonly"), E.accessibility = I) : YP(I) ? (E[I] && this.raise(ge.DuplicateModifier, N, { modifier: I }), E[I] = !0, k(N, I, "in", "out")) : (Object.hasOwnProperty.call(E, I) ? this.raise(ge.DuplicateModifier, N, { modifier: I }) : (k(N, I, "static", "readonly"), k(N, I, "static", "override"), k(N, I, "override", "readonly"), k(N, I, "abstract", "override"), F(N, I, "declare", "override"), F(N, I, "static", "abstract")), E[I] = !0), f != null && f.includes(I) && this.raise(v, N, { modifier: I });
      }
    }
    tsIsListTerminator(l) {
      switch (l) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(l, f) {
      let y = [];
      for (; !this.tsIsListTerminator(l); )
        y.push(f());
      return y;
    }
    tsParseDelimitedList(l, f, y) {
      return XP(this.tsParseDelimitedListWorker(l, f, !0, y));
    }
    tsParseDelimitedListWorker(l, f, y, v) {
      let E = [], k = -1;
      for (; !this.tsIsListTerminator(l); ) {
        k = -1;
        let F = f();
        if (F == null)
          return;
        if (E.push(F), this.eat(12)) {
          k = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(l))
          break;
        y && this.expect(12);
        return;
      }
      return v && (v.value = k), E;
    }
    tsParseBracketedList(l, f, y, v, E) {
      v || (y ? this.expect(0) : this.expect(47));
      let k = this.tsParseDelimitedList(l, f, E);
      return y ? this.expect(3) : this.expect(48), k;
    }
    tsParseImportType() {
      let l = this.startNode();
      return this.expect(83), this.expect(10), this.match(133) || this.raise(ge.UnsupportedImportTypeArgument, this.state.startLoc), l.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (l.qualifier = this.tsParseEntityName()), this.match(47) && (l.typeParameters = this.tsParseTypeArguments()), this.finishNode(l, "TSImportType");
    }
    tsParseEntityName(l = !0) {
      let f = this.parseIdentifier(l);
      for (; this.eat(16); ) {
        let y = this.startNodeAtNode(f);
        y.left = f, y.right = this.parseIdentifier(l), f = this.finishNode(y, "TSQualifiedName");
      }
      return f;
    }
    tsParseTypeReference() {
      let l = this.startNode();
      return l.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (l.typeParameters = this.tsParseTypeArguments()), this.finishNode(l, "TSTypeReference");
    }
    tsParseThisTypePredicate(l) {
      this.next();
      let f = this.startNodeAtNode(l);
      return f.parameterName = l, f.typeAnnotation = this.tsParseTypeAnnotation(!1), f.asserts = !1, this.finishNode(f, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let l = this.startNode();
      return this.next(), this.finishNode(l, "TSThisType");
    }
    tsParseTypeQuery() {
      let l = this.startNode();
      return this.expect(87), this.match(83) ? l.exprName = this.tsParseImportType() : l.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (l.typeParameters = this.tsParseTypeArguments()), this.finishNode(l, "TSTypeQuery");
    }
    tsParseTypeParameter(l) {
      let f = this.startNode();
      return l(f), f.name = this.tsParseTypeParameterName(), f.constraint = this.tsEatThenParseType(81), f.default = this.tsEatThenParseType(29), this.finishNode(f, "TSTypeParameter");
    }
    tsTryParseTypeParameters(l) {
      if (this.match(47))
        return this.tsParseTypeParameters(l);
    }
    tsParseTypeParameters(l) {
      let f = this.startNode();
      this.match(47) || this.match(142) ? this.next() : this.unexpected();
      let y = { value: -1 };
      return f.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, l), !1, !0, y), f.params.length === 0 && this.raise(ge.EmptyTypeParameters, f), y.value !== -1 && this.addExtra(f, "trailingComma", y.value), this.finishNode(f, "TSTypeParameterDeclaration");
    }
    tsFillSignature(l, f) {
      let y = l === 19, v = "parameters", E = "typeAnnotation";
      f.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), f[v] = this.tsParseBindingListForSignature(), y ? f[E] = this.tsParseTypeOrTypePredicateAnnotation(l) : this.match(l) && (f[E] = this.tsParseTypeOrTypePredicateAnnotation(l));
    }
    tsParseBindingListForSignature() {
      let l = super.parseBindingList(11, 41, 2);
      for (let f of l) {
        let { type: y } = f;
        (y === "AssignmentPattern" || y === "TSParameterProperty") && this.raise(ge.UnsupportedSignatureParameterKind, f, { type: y });
      }
      return l;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(l, f) {
      return this.tsFillSignature(14, f), this.tsParseTypeMemberSemicolon(), this.finishNode(f, l);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), j(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(l) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let f = this.parseIdentifier();
      f.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(f), this.expect(3), l.parameters = [f];
      let y = this.tsTryParseTypeAnnotation();
      return y && (l.typeAnnotation = y), this.tsParseTypeMemberSemicolon(), this.finishNode(l, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(l, f) {
      this.eat(17) && (l.optional = !0);
      let y = l;
      if (this.match(10) || this.match(47)) {
        f && this.raise(ge.ReadonlyForMethodSignature, l);
        let v = y;
        v.kind && this.match(47) && this.raise(ge.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, v), this.tsParseTypeMemberSemicolon();
        let E = "parameters", k = "typeAnnotation";
        if (v.kind === "get")
          v[E].length > 0 && (this.raise(x.BadGetterArity, this.state.curPosition()), this.isThisParam(v[E][0]) && this.raise(ge.AccesorCannotDeclareThisParameter, this.state.curPosition()));
        else if (v.kind === "set") {
          if (v[E].length !== 1)
            this.raise(x.BadSetterArity, this.state.curPosition());
          else {
            let F = v[E][0];
            this.isThisParam(F) && this.raise(ge.AccesorCannotDeclareThisParameter, this.state.curPosition()), F.type === "Identifier" && F.optional && this.raise(ge.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), F.type === "RestElement" && this.raise(ge.SetAccesorCannotHaveRestParameter, this.state.curPosition());
          }
          v[k] && this.raise(ge.SetAccesorCannotHaveReturnType, v[k]);
        } else
          v.kind = "method";
        return this.finishNode(v, "TSMethodSignature");
      } else {
        let v = y;
        f && (v.readonly = !0);
        let E = this.tsTryParseTypeAnnotation();
        return E && (v.typeAnnotation = E), this.tsParseTypeMemberSemicolon(), this.finishNode(v, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let l = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", l);
      if (this.match(77)) {
        let y = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", l) : (l.key = this.createIdentifier(y, "new"), this.tsParsePropertyOrMethodSignature(l, !1));
      }
      return this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, l), this.tsTryParseIndexSignature(l) || (super.parsePropertyName(l), !l.computed && l.key.type === "Identifier" && (l.key.name === "get" || l.key.name === "set") && this.tsTokenCanFollowModifier() && (l.kind = l.key.name, super.parsePropertyName(l)), this.tsParsePropertyOrMethodSignature(l, !!l.readonly));
    }
    tsParseTypeLiteral() {
      let l = this.startNode();
      return l.members = this.tsParseObjectTypeMembers(), this.finishNode(l, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let l = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), l;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedTypeParameter() {
      let l = this.startNode();
      return l.name = this.tsParseTypeParameterName(), l.constraint = this.tsExpectThenParseType(58), this.finishNode(l, "TSTypeParameter");
    }
    tsParseMappedType() {
      let l = this.startNode();
      return this.expect(5), this.match(53) ? (l.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (l.readonly = !0), this.expect(0), l.typeParameter = this.tsParseMappedTypeParameter(), l.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (l.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (l.optional = !0), l.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(l, "TSMappedType");
    }
    tsParseTupleType() {
      let l = this.startNode();
      l.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let f = !1;
      return l.elementTypes.forEach((y) => {
        let { type: v } = y;
        f && v !== "TSRestType" && v !== "TSOptionalType" && !(v === "TSNamedTupleMember" && y.optional) && this.raise(ge.OptionalTypeBeforeRequired, y), f || (f = v === "TSNamedTupleMember" && y.optional || v === "TSOptionalType");
      }), this.finishNode(l, "TSTupleType");
    }
    tsParseTupleElementType() {
      let { startLoc: l } = this.state, f = this.eat(21), y, v, E, k, F = De(this.state.type) ? this.lookaheadCharCode() : null;
      if (F === 58)
        y = !0, E = !1, v = this.parseIdentifier(!0), this.expect(14), k = this.tsParseType();
      else if (F === 63) {
        E = !0;
        let N = this.state.startLoc, I = this.state.value, U = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (y = !0, v = this.createIdentifier(this.startNodeAt(N), I), this.expect(17), this.expect(14), k = this.tsParseType()) : (y = !1, k = U, this.expect(17));
      } else
        k = this.tsParseType(), E = this.eat(17), y = this.eat(14);
      if (y) {
        let N;
        v ? (N = this.startNodeAtNode(v), N.optional = E, N.label = v, N.elementType = k, this.eat(17) && (N.optional = !0, this.raise(ge.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (N = this.startNodeAtNode(k), N.optional = E, this.raise(ge.InvalidTupleMemberLabel, k), N.label = k, N.elementType = this.tsParseType()), k = this.finishNode(N, "TSNamedTupleMember");
      } else if (E) {
        let N = this.startNodeAtNode(k);
        N.typeAnnotation = k, k = this.finishNode(N, "TSOptionalType");
      }
      if (f) {
        let N = this.startNodeAt(l);
        N.typeAnnotation = k, k = this.finishNode(N, "TSRestType");
      }
      return k;
    }
    tsParseParenthesizedType() {
      let l = this.startNode();
      return this.expect(10), l.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(l, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(l, f) {
      let y = this.startNode();
      return l === "TSConstructorType" && (y.abstract = !!f, f && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, y)), this.finishNode(y, l);
    }
    tsParseLiteralTypeNode() {
      let l = this.startNode();
      switch (this.state.type) {
        case 134:
        case 135:
        case 133:
        case 85:
        case 86:
          l.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(l, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      let l = this.startNode();
      return l.literal = super.parseTemplate(!1), this.finishNode(l, "TSLiteralType");
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let l = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(l) : l;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 133:
        case 134:
        case 135:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let l = this.startNode(), f = this.lookahead();
            return f.type !== 134 && f.type !== 135 && this.unexpected(), l.literal = this.parseMaybeUnary(), this.finishNode(l, "TSLiteralType");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let { type: l } = this.state;
          if (j(l) || l === 88 || l === 84) {
            let f = l === 88 ? "TSVoidKeyword" : l === 84 ? "TSNullKeyword" : VP(this.state.value);
            if (f !== void 0 && this.lookaheadCharCode() !== 46) {
              let y = this.startNode();
              return this.next(), this.finishNode(y, f);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let l = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let f = this.startNodeAtNode(l);
          f.elementType = l, this.expect(3), l = this.finishNode(f, "TSArrayType");
        } else {
          let f = this.startNodeAtNode(l);
          f.objectType = l, f.indexType = this.tsParseType(), this.expect(3), l = this.finishNode(f, "TSIndexedAccessType");
        }
      return l;
    }
    tsParseTypeOperator() {
      let l = this.startNode(), f = this.state.value;
      return this.next(), l.operator = f, l.typeAnnotation = this.tsParseTypeOperatorOrHigher(), f === "readonly" && this.tsCheckTypeAnnotationForReadOnly(l), this.finishNode(l, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(l) {
      switch (l.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(ge.UnexpectedReadonly, l);
      }
    }
    tsParseInferType() {
      let l = this.startNode();
      this.expectContextual(115);
      let f = this.startNode();
      return f.name = this.tsParseTypeParameterName(), f.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), l.typeParameter = this.finishNode(f, "TSTypeParameter"), this.finishNode(l, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let l = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return l;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return br(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(l, f, y) {
      let v = this.startNode(), E = this.eat(y), k = [];
      do
        k.push(f());
      while (this.eat(y));
      return k.length === 1 && !E ? k[0] : (v.types = k, this.finishNode(v, l));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (j(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let { errors: l } = this.state, f = l.length;
        try {
          return this.parseObjectLike(8, !0), l.length === f;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let { errors: l } = this.state, f = l.length;
        try {
          return super.parseBindingList(3, 93, 1), l.length === f;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(l) {
      return this.tsInType(() => {
        let f = this.startNode();
        this.expect(l);
        let y = this.startNode(), v = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (v && this.match(78)) {
          let F = this.tsParseThisTypeOrThisTypePredicate();
          return F.type === "TSThisType" ? (y.parameterName = F, y.asserts = !0, y.typeAnnotation = null, F = this.finishNode(y, "TSTypePredicate")) : (this.resetStartLocationFromNode(F, y), F.asserts = !0), f.typeAnnotation = F, this.finishNode(f, "TSTypeAnnotation");
        }
        let E = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!E)
          return v ? (y.parameterName = this.parseIdentifier(), y.asserts = v, y.typeAnnotation = null, f.typeAnnotation = this.finishNode(y, "TSTypePredicate"), this.finishNode(f, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, f);
        let k = this.tsParseTypeAnnotation(!1);
        return y.parameterName = E, y.typeAnnotation = k, y.asserts = v, f.typeAnnotation = this.finishNode(y, "TSTypePredicate"), this.finishNode(f, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let l = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), l;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let l = this.state.containsEsc;
      return this.next(), !j(this.state.type) && !this.match(78) ? !1 : (l && this.raise(x.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), !0);
    }
    tsParseTypeAnnotation(l = !0, f = this.startNode()) {
      return this.tsInType(() => {
        l && this.expect(14), f.typeAnnotation = this.tsParseType();
      }), this.finishNode(f, "TSTypeAnnotation");
    }
    tsParseType() {
      hO(this.state.inType);
      let l = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return l;
      let f = this.startNodeAtNode(l);
      return f.checkType = l, f.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), f.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), f.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(f, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.lookahead().type === 77;
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ge.ReservedTypeAssertion, this.state.startLoc);
      let l = this.startNode();
      return l.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), l.expression = this.parseMaybeUnary(), this.finishNode(l, "TSTypeAssertion");
    }
    tsParseHeritageClause(l) {
      let f = this.state.startLoc, y = this.tsParseDelimitedList("HeritageClauseElement", () => {
        let v = this.startNode();
        return v.expression = this.tsParseEntityName(), this.match(47) && (v.typeParameters = this.tsParseTypeArguments()), this.finishNode(v, "TSExpressionWithTypeArguments");
      });
      return y.length || this.raise(ge.EmptyHeritageClauseType, f, { token: l }), y;
    }
    tsParseInterfaceDeclaration(l, f = {}) {
      if (this.hasFollowingLineBreak())
        return null;
      this.expectContextual(129), f.declare && (l.declare = !0), j(this.state.type) ? (l.id = this.parseIdentifier(), this.checkIdentifier(l.id, 130)) : (l.id = null, this.raise(ge.MissingInterfaceName, this.state.startLoc)), l.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (l.extends = this.tsParseHeritageClause("extends"));
      let y = this.startNode();
      return y.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), l.body = this.finishNode(y, "TSInterfaceBody"), this.finishNode(l, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(l) {
      return l.id = this.parseIdentifier(), this.checkIdentifier(l.id, 2), l.typeAnnotation = this.tsInType(() => {
        if (l.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
          let f = this.startNode();
          return this.next(), this.finishNode(f, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(l, "TSTypeAliasDeclaration");
    }
    tsInNoContext(l) {
      let f = this.state.context;
      this.state.context = [f[0]];
      try {
        return l();
      } finally {
        this.state.context = f;
      }
    }
    tsInType(l) {
      let f = this.state.inType;
      this.state.inType = !0;
      try {
        return l();
      } finally {
        this.state.inType = f;
      }
    }
    tsInDisallowConditionalTypesContext(l) {
      let f = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return l();
      } finally {
        this.state.inDisallowConditionalTypesContext = f;
      }
    }
    tsInAllowConditionalTypesContext(l) {
      let f = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return l();
      } finally {
        this.state.inDisallowConditionalTypesContext = f;
      }
    }
    tsEatThenParseType(l) {
      if (this.match(l))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(l) {
      return this.tsInType(() => (this.expect(l), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let l = this.startNode();
      return l.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (l.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(l, "TSEnumMember");
    }
    tsParseEnumDeclaration(l, f = {}) {
      return f.const && (l.const = !0), f.declare && (l.declare = !0), this.expectContextual(126), l.id = this.parseIdentifier(), this.checkIdentifier(l.id, l.const ? 8971 : 8459), this.expect(5), l.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(l, "TSEnumDeclaration");
    }
    tsParseModuleBlock() {
      let l = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(l.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(l, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(l, f = !1) {
      if (l.id = this.parseIdentifier(), f || this.checkIdentifier(l.id, 1024), this.eat(16)) {
        let y = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(y, !0), l.body = y;
      } else
        this.scope.enter(256), this.prodParam.enter(0), l.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(l, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(l) {
      return this.isContextual(112) ? (l.global = !0, l.id = this.parseIdentifier()) : this.match(133) ? l.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), l.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(l, "TSModuleDeclaration");
    }
    tsParseImportEqualsDeclaration(l, f, y) {
      l.isExport = y || !1, l.id = f || this.parseIdentifier(), this.checkIdentifier(l.id, 4096), this.expect(29);
      let v = this.tsParseModuleReference();
      return l.importKind === "type" && v.type !== "TSExternalModuleReference" && this.raise(ge.ImportAliasHasImportType, v), l.moduleReference = v, this.semicolon(), this.finishNode(l, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
    }
    tsParseExternalModuleReference() {
      let l = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), l.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(l, "TSExternalModuleReference");
    }
    tsLookAhead(l) {
      let f = this.state.clone(), y = l();
      return this.state = f, y;
    }
    tsTryParseAndCatch(l) {
      let f = this.tryParse((y) => l() || y());
      if (!(f.aborted || !f.node))
        return f.error && (this.state = f.failState), f.node;
    }
    tsTryParse(l) {
      let f = this.state.clone(), y = l();
      if (y !== void 0 && y !== !1)
        return y;
      this.state = f;
    }
    tsTryParseDeclare(l) {
      if (this.isLineTerminator())
        return;
      let f = this.state.type, y;
      return this.isContextual(100) && (f = 74, y = "let"), this.tsInAmbientContext(() => {
        switch (f) {
          case 68:
            return l.declare = !0, super.parseFunctionStatement(l, !1, !1);
          case 80:
            return l.declare = !0, this.parseClass(l, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(l, { declare: !0 });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(l);
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (l.declare = !0, this.parseVarStatement(l, y || this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(l, { const: !0, declare: !0 }));
          case 129: {
            let v = this.tsParseInterfaceDeclaration(l, { declare: !0 });
            if (v)
              return v;
          }
          default:
            if (j(f))
              return this.tsParseDeclaration(l, this.state.value, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
    }
    tsParseExpressionStatement(l, f, y) {
      switch (f.name) {
        case "declare": {
          let v = this.tsTryParseDeclare(l);
          return v && (v.declare = !0), v;
        }
        case "global":
          if (this.match(5)) {
            this.scope.enter(256), this.prodParam.enter(0);
            let v = l;
            return v.global = !0, v.id = f, v.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(v, "TSModuleDeclaration");
          }
          break;
        default:
          return this.tsParseDeclaration(l, f.name, !1, y);
      }
    }
    tsParseDeclaration(l, f, y, v) {
      switch (f) {
        case "abstract":
          if (this.tsCheckLineTerminator(y) && (this.match(80) || j(this.state.type)))
            return this.tsParseAbstractDeclaration(l, v);
          break;
        case "module":
          if (this.tsCheckLineTerminator(y)) {
            if (this.match(133))
              return this.tsParseAmbientExternalModuleDeclaration(l);
            if (j(this.state.type))
              return this.tsParseModuleOrNamespaceDeclaration(l);
          }
          break;
        case "namespace":
          if (this.tsCheckLineTerminator(y) && j(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(l);
          break;
        case "type":
          if (this.tsCheckLineTerminator(y) && j(this.state.type))
            return this.tsParseTypeAliasDeclaration(l);
          break;
      }
    }
    tsCheckLineTerminator(l) {
      return l ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(l) {
      if (!this.match(47))
        return;
      let f = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let y = this.tsTryParseAndCatch(() => {
        let v = this.startNodeAt(l);
        return v.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(v), v.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), v;
      });
      if (this.state.maybeInArrowParameters = f, !!y)
        return super.parseArrowExpression(y, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let l = this.startNode();
      return l.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), l.params.length === 0 ? this.raise(ge.EmptyTypeArguments, l) : !this.state.inType && this.curContext() === $.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(l, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return tn(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseAssignableListItem(l, f) {
      let y = this.state.startLoc, v = {};
      this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, v);
      let E = v.accessibility, k = v.override, F = v.readonly;
      !(l & 4) && (E || F || k) && this.raise(ge.UnexpectedParameterModifier, y);
      let N = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(N, l);
      let I = this.parseMaybeDefault(N.loc.start, N);
      if (E || F || k) {
        let U = this.startNodeAt(y);
        return f.length && (U.decorators = f), E && (U.accessibility = E), F && (U.readonly = F), k && (U.override = k), I.type !== "Identifier" && I.type !== "AssignmentPattern" && this.raise(ge.UnsupportedParameterPropertyKind, U), U.parameter = I, this.finishNode(U, "TSParameterProperty");
      }
      return f.length && (N.decorators = f), I;
    }
    isSimpleParameter(l) {
      return l.type === "TSParameterProperty" && super.isSimpleParameter(l.parameter) || super.isSimpleParameter(l);
    }
    tsDisallowOptionalPattern(l) {
      for (let f of l.params)
        f.type !== "Identifier" && f.optional && !this.state.isAmbientContext && this.raise(ge.PatternIsOptional, f);
    }
    setArrowFunctionParameters(l, f, y) {
      super.setArrowFunctionParameters(l, f, y), this.tsDisallowOptionalPattern(l);
    }
    parseFunctionBodyAndFinish(l, f, y = !1) {
      this.match(14) && (l.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let v = f === "FunctionDeclaration" ? "TSDeclareFunction" : f === "ClassMethod" || f === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return v && !this.match(5) && this.isLineTerminator() ? this.finishNode(l, v) : v === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(ge.DeclareFunctionHasImplementation, l), l.declare) ? super.parseFunctionBodyAndFinish(l, v, y) : (this.tsDisallowOptionalPattern(l), super.parseFunctionBodyAndFinish(l, f, y));
    }
    registerFunctionStatementId(l) {
      !l.body && l.id ? this.checkIdentifier(l.id, 1024) : super.registerFunctionStatementId(l);
    }
    tsCheckForInvalidTypeCasts(l) {
      l.forEach((f) => {
        (f == null ? void 0 : f.type) === "TSTypeCastExpression" && this.raise(ge.UnexpectedTypeAnnotation, f.typeAnnotation);
      });
    }
    toReferencedList(l, f) {
      return this.tsCheckForInvalidTypeCasts(l), l;
    }
    parseArrayLike(l, f, y, v) {
      let E = super.parseArrayLike(l, f, y, v);
      return E.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(E.elements), E;
    }
    parseSubscript(l, f, y, v) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let k = this.startNodeAt(f);
        return k.expression = l, this.finishNode(k, "TSNonNullExpression");
      }
      let E = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (y)
          return v.stop = !0, l;
        v.optionalChainMember = E = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let k, F = this.tsTryParseAndCatch(() => {
          if (!y && this.atPossibleAsyncArrow(l)) {
            let ne = this.tsTryParseGenericAsyncArrowFunction(f);
            if (ne)
              return ne;
          }
          let N = this.tsParseTypeArgumentsInExpression();
          if (!N)
            return;
          if (E && !this.match(10)) {
            k = this.state.curPosition();
            return;
          }
          if (Ir(this.state.type)) {
            let ne = super.parseTaggedTemplateExpression(l, f, v);
            return ne.typeParameters = N, ne;
          }
          if (!y && this.eat(10)) {
            let ne = this.startNodeAt(f);
            return ne.callee = l, ne.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(ne.arguments), ne.typeParameters = N, v.optionalChainMember && (ne.optional = E), this.finishCallExpression(ne, v.optionalChainMember);
          }
          let I = this.state.type;
          if (I === 48 || I === 52 || I !== 10 && it(I) && !this.hasPrecedingLineBreak())
            return;
          let U = this.startNodeAt(f);
          return U.expression = l, U.typeParameters = N, this.finishNode(U, "TSInstantiationExpression");
        });
        if (k && this.unexpected(k, 10), F)
          return F.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(ge.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), F;
      }
      return super.parseSubscript(l, f, y, v);
    }
    parseNewCallee(l) {
      var f;
      super.parseNewCallee(l);
      let { callee: y } = l;
      y.type === "TSInstantiationExpression" && !((f = y.extra) != null && f.parenthesized) && (l.typeParameters = y.typeParameters, l.callee = y.expression);
    }
    parseExprOp(l, f, y) {
      let v;
      if (Li(58) > y && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (v = this.isContextual(120)))) {
        let E = this.startNodeAt(f);
        return E.expression = l, E.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (v && this.raise(x.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(E, v ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(E, f, y);
      }
      return super.parseExprOp(l, f, y);
    }
    checkReservedWord(l, f, y, v) {
      this.state.isAmbientContext || super.checkReservedWord(l, f, y, v);
    }
    checkImportReflection(l) {
      super.checkImportReflection(l), l.module && l.importKind !== "value" && this.raise(ge.ImportReflectionHasImportType, l.specifiers[0].loc.start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(l) {
      if (super.isPotentialImportPhase(l))
        return !0;
      if (this.isContextual(130)) {
        let f = this.lookaheadCharCode();
        return l ? f === 123 || f === 42 : f !== 61;
      }
      return !l && this.isContextual(87);
    }
    applyImportPhase(l, f, y, v) {
      super.applyImportPhase(l, f, y, v), f ? l.exportKind = y === "type" ? "type" : "value" : l.importKind = y === "type" || y === "typeof" ? y : "value";
    }
    parseImport(l) {
      if (this.match(133))
        return l.importKind = "value", super.parseImport(l);
      let f;
      if (j(this.state.type) && this.lookaheadCharCode() === 61)
        return l.importKind = "value", this.tsParseImportEqualsDeclaration(l);
      if (this.isContextual(130)) {
        let y = this.parseMaybeImportPhase(l, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(l, y);
        f = super.parseImportSpecifiersAndAfter(l, y);
      } else
        f = super.parseImport(l);
      return f.importKind === "type" && f.specifiers.length > 1 && f.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(ge.TypeImportCannotSpecifyDefaultAndNamed, f), f;
    }
    parseExport(l, f) {
      if (this.match(83)) {
        this.next();
        let y = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? y = this.parseMaybeImportPhase(l, !1) : l.importKind = "value", this.tsParseImportEqualsDeclaration(l, y, !0);
      } else if (this.eat(29)) {
        let y = l;
        return y.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(y, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let y = l;
        return this.expectContextual(128), y.id = this.parseIdentifier(), this.semicolon(), this.finishNode(y, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(l, f);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.lookahead().type === 80;
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let l = this.startNode();
        return this.next(), l.abstract = !0, this.parseClass(l, !0, !0);
      }
      if (this.match(129)) {
        let l = this.tsParseInterfaceDeclaration(this.startNode());
        if (l)
          return l;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(l, f, y = !1) {
      let { isAmbientContext: v } = this.state, E = super.parseVarStatement(l, f, y || v);
      if (!v)
        return E;
      for (let { id: k, init: F } of E.declarations)
        F && (f !== "const" || k.typeAnnotation ? this.raise(ge.InitializerNotAllowedInAmbientContext, F) : GP(F, this.hasPlugin("estree")) || this.raise(ge.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, F));
      return E;
    }
    parseStatementContent(l, f) {
      if (this.match(75) && this.isLookaheadContextual("enum")) {
        let y = this.startNode();
        return this.expect(75), this.tsParseEnumDeclaration(y, { const: !0 });
      }
      if (this.isContextual(126))
        return this.tsParseEnumDeclaration(this.startNode());
      if (this.isContextual(129)) {
        let y = this.tsParseInterfaceDeclaration(this.startNode());
        if (y)
          return y;
      }
      return super.parseStatementContent(l, f);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(l, f) {
      return f.some((y) => pO(y) ? l.accessibility === y : !!l[y]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(l, f, y) {
      let v = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({ allowedModifiers: v, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: !0, errorTemplate: ge.InvalidModifierOnTypeParameterPositions }, f);
      let E = () => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(f, v) && this.raise(ge.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(l, f)) : this.parseClassMemberWithIsStatic(l, f, y, !!f.static);
      };
      f.declare ? this.tsInAmbientContext(E) : E();
    }
    parseClassMemberWithIsStatic(l, f, y, v) {
      let E = this.tsTryParseIndexSignature(f);
      if (E) {
        l.body.push(E), f.abstract && this.raise(ge.IndexSignatureHasAbstract, f), f.accessibility && this.raise(ge.IndexSignatureHasAccessibility, f, { modifier: f.accessibility }), f.declare && this.raise(ge.IndexSignatureHasDeclare, f), f.override && this.raise(ge.IndexSignatureHasOverride, f);
        return;
      }
      !this.state.inAbstractClass && f.abstract && this.raise(ge.NonAbstractClassHasAbstractMethod, f), f.override && (y.hadSuperClass || this.raise(ge.OverrideNotInSubClass, f)), super.parseClassMemberWithIsStatic(l, f, y, v);
    }
    parsePostMemberNameModifiers(l) {
      this.eat(17) && (l.optional = !0), l.readonly && this.match(10) && this.raise(ge.ClassMethodHasReadonly, l), l.declare && this.match(10) && this.raise(ge.ClassMethodHasDeclare, l);
    }
    parseExpressionStatement(l, f, y) {
      return (f.type === "Identifier" ? this.tsParseExpressionStatement(l, f, y) : void 0) || super.parseExpressionStatement(l, f, y);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(l, f, y) {
      if (!this.state.maybeInArrowParameters || !this.match(17))
        return super.parseConditional(l, f, y);
      let v = this.tryParse(() => super.parseConditional(l, f));
      return v.node ? (v.error && (this.state = v.failState), v.node) : (v.error && super.setOptionalParametersError(y, v.error), l);
    }
    parseParenItem(l, f) {
      if (l = super.parseParenItem(l, f), this.eat(17) && (l.optional = !0, this.resetEndLocation(l)), this.match(14)) {
        let y = this.startNodeAt(f);
        return y.expression = l, y.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(y, "TSTypeCastExpression");
      }
      return l;
    }
    parseExportDeclaration(l) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(l));
      let f = this.state.startLoc, y = this.eatContextual(125);
      if (y && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(ge.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let v = j(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(l);
      return v ? ((v.type === "TSInterfaceDeclaration" || v.type === "TSTypeAliasDeclaration" || y) && (l.exportKind = "type"), y && (this.resetStartLocation(v, f), v.declare = !0), v) : null;
    }
    parseClassId(l, f, y, v) {
      if ((!f || y) && this.isContextual(113))
        return;
      super.parseClassId(l, f, y, l.declare ? 1024 : 8331);
      let E = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      E && (l.typeParameters = E);
    }
    parseClassPropertyAnnotation(l) {
      l.optional || (this.eat(35) ? l.definite = !0 : this.eat(17) && (l.optional = !0));
      let f = this.tsTryParseTypeAnnotation();
      f && (l.typeAnnotation = f);
    }
    parseClassProperty(l) {
      if (this.parseClassPropertyAnnotation(l), this.state.isAmbientContext && !(l.readonly && !l.typeAnnotation) && this.match(29) && this.raise(ge.DeclareClassFieldHasInitializer, this.state.startLoc), l.abstract && this.match(29)) {
        let { key: f } = l;
        this.raise(ge.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: f.type === "Identifier" && !l.computed ? f.name : `[${this.input.slice(f.start, f.end)}]` });
      }
      return super.parseClassProperty(l);
    }
    parseClassPrivateProperty(l) {
      return l.abstract && this.raise(ge.PrivateElementHasAbstract, l), l.accessibility && this.raise(ge.PrivateElementHasAccessibility, l, { modifier: l.accessibility }), this.parseClassPropertyAnnotation(l), super.parseClassPrivateProperty(l);
    }
    parseClassAccessorProperty(l) {
      return this.parseClassPropertyAnnotation(l), l.optional && this.raise(ge.AccessorCannotBeOptional, l), super.parseClassAccessorProperty(l);
    }
    pushClassMethod(l, f, y, v, E, k) {
      let F = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      F && E && this.raise(ge.ConstructorHasTypeParameters, F);
      let { declare: N = !1, kind: I } = f;
      N && (I === "get" || I === "set") && this.raise(ge.DeclareAccessor, f, { kind: I }), F && (f.typeParameters = F), super.pushClassMethod(l, f, y, v, E, k);
    }
    pushClassPrivateMethod(l, f, y, v) {
      let E = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      E && (f.typeParameters = E), super.pushClassPrivateMethod(l, f, y, v);
    }
    declareClassPrivateMethodInScope(l, f) {
      l.type !== "TSDeclareMethod" && (l.type === "MethodDefinition" && !l.value.body || super.declareClassPrivateMethodInScope(l, f));
    }
    parseClassSuper(l) {
      super.parseClassSuper(l), l.superClass && (this.match(47) || this.match(51)) && (l.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (l.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(l, f, y, v, E, k, F) {
      let N = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return N && (l.typeParameters = N), super.parseObjPropValue(l, f, y, v, E, k, F);
    }
    parseFunctionParams(l, f) {
      let y = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      y && (l.typeParameters = y), super.parseFunctionParams(l, f);
    }
    parseVarId(l, f) {
      super.parseVarId(l, f), l.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (l.definite = !0);
      let y = this.tsTryParseTypeAnnotation();
      y && (l.id.typeAnnotation = y, this.resetEndLocation(l.id));
    }
    parseAsyncArrowFromCallExpression(l, f) {
      return this.match(14) && (l.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(l, f);
    }
    parseMaybeAssign(l, f) {
      var y, v, E, k, F;
      let N, I, U;
      if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
        if (N = this.state.clone(), I = this.tryParse(() => super.parseMaybeAssign(l, f), N), !I.error)
          return I.node;
        let { context: ce } = this.state, He = ce[ce.length - 1];
        (He === $.j_oTag || He === $.j_expr) && ce.pop();
      }
      if (!((y = I) != null && y.error) && !this.match(47))
        return super.parseMaybeAssign(l, f);
      (!N || N === this.state) && (N = this.state.clone());
      let ne, he = this.tryParse((ce) => {
        var He, Ge;
        ne = this.tsParseTypeParameters(this.tsParseConstModifier);
        let Pt = super.parseMaybeAssign(l, f);
        return (Pt.type !== "ArrowFunctionExpression" || (He = Pt.extra) != null && He.parenthesized) && ce(), ((Ge = ne) == null ? void 0 : Ge.params.length) !== 0 && this.resetStartLocationFromNode(Pt, ne), Pt.typeParameters = ne, Pt;
      }, N);
      if (!he.error && !he.aborted)
        return ne && this.reportReservedArrowTypeParam(ne), he.node;
      if (!I && (hO(!this.hasPlugin("jsx")), U = this.tryParse(() => super.parseMaybeAssign(l, f), N), !U.error))
        return U.node;
      if ((v = I) != null && v.node)
        return this.state = I.failState, I.node;
      if (he.node)
        return this.state = he.failState, ne && this.reportReservedArrowTypeParam(ne), he.node;
      if ((E = U) != null && E.node)
        return this.state = U.failState, U.node;
      throw ((k = I) == null ? void 0 : k.error) || he.error || ((F = U) == null ? void 0 : F.error);
    }
    reportReservedArrowTypeParam(l) {
      var f;
      l.params.length === 1 && !l.params[0].constraint && !((f = l.extra) != null && f.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ge.ReservedArrowTypeParam, l);
    }
    parseMaybeUnary(l, f) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(l, f);
    }
    parseArrow(l) {
      if (this.match(14)) {
        let f = this.tryParse((y) => {
          let v = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && y(), v;
        });
        if (f.aborted)
          return;
        f.thrown || (f.error && (this.state = f.failState), l.returnType = f.node);
      }
      return super.parseArrow(l);
    }
    parseAssignableListItemTypes(l, f) {
      if (!(f & 2))
        return l;
      this.eat(17) && (l.optional = !0);
      let y = this.tsTryParseTypeAnnotation();
      return y && (l.typeAnnotation = y), this.resetEndLocation(l), l;
    }
    isAssignable(l, f) {
      switch (l.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(l.expression, f);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(l, f);
      }
    }
    toAssignable(l, f = !1) {
      switch (l.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(l, f);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          f ? this.expressionScope.recordArrowParameterBindingError(ge.UnexpectedTypeCastInParameter, l) : this.raise(ge.UnexpectedTypeCastInParameter, l), this.toAssignable(l.expression, f);
          break;
        case "AssignmentExpression":
          !f && l.left.type === "TSTypeCastExpression" && (l.left = this.typeCastToParameter(l.left));
        default:
          super.toAssignable(l, f);
      }
    }
    toAssignableParenthesizedExpression(l, f) {
      switch (l.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(l.expression, f);
          break;
        default:
          super.toAssignable(l, f);
      }
    }
    checkToRestConversion(l, f) {
      switch (l.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(l.expression, !1);
          break;
        default:
          super.checkToRestConversion(l, f);
      }
    }
    isValidLVal(l, f, y) {
      return qP({ TSTypeCastExpression: !0, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (y !== 64 || !f) && ["expression", !0], TSSatisfiesExpression: (y !== 64 || !f) && ["expression", !0], TSTypeAssertion: (y !== 64 || !f) && ["expression", !0] }, l) || super.isValidLVal(l, f, y);
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(l) {
      if (this.match(47) || this.match(51)) {
        let f = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let y = super.parseMaybeDecoratorArguments(l);
          return y.typeParameters = f, y;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(l);
    }
    checkCommaAfterRest(l) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === l ? (this.next(), !1) : super.checkCommaAfterRest(l);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(l, f) {
      let y = super.parseMaybeDefault(l, f);
      return y.type === "AssignmentPattern" && y.typeAnnotation && y.right.start < y.typeAnnotation.start && this.raise(ge.TypeAnnotationAfterAssign, y.typeAnnotation), y;
    }
    getTokenFromCode(l) {
      if (this.state.inType) {
        if (l === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (l === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(l);
    }
    reScan_lt_gt() {
      let { type: l } = this.state;
      l === 47 ? (this.state.pos -= 1, this.readToken_lt()) : l === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let { type: l } = this.state;
      return l === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : l;
    }
    toAssignableList(l, f, y) {
      for (let v = 0; v < l.length; v++) {
        let E = l[v];
        (E == null ? void 0 : E.type) === "TSTypeCastExpression" && (l[v] = this.typeCastToParameter(E));
      }
      super.toAssignableList(l, f, y);
    }
    typeCastToParameter(l) {
      return l.expression.typeAnnotation = l.typeAnnotation, this.resetEndLocation(l.expression, l.typeAnnotation.loc.end), l.expression;
    }
    shouldParseArrow(l) {
      return this.match(14) ? l.every((f) => this.isAssignable(f, !0)) : super.shouldParseArrow(l);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(l) {
      if (this.match(47) || this.match(51)) {
        let f = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        f && (l.typeParameters = f);
      }
      return super.jsxParseOpeningElementAfterName(l);
    }
    getGetterSetterExpectedParamCount(l) {
      let f = super.getGetterSetterExpectedParamCount(l), y = this.getObjectOrClassMethodParams(l)[0];
      return y && this.isThisParam(y) ? f + 1 : f;
    }
    parseCatchClauseParam() {
      let l = super.parseCatchClauseParam(), f = this.tsTryParseTypeAnnotation();
      return f && (l.typeAnnotation = f, this.resetEndLocation(l)), l;
    }
    tsInAmbientContext(l) {
      let f = this.state.isAmbientContext;
      this.state.isAmbientContext = !0;
      try {
        return l();
      } finally {
        this.state.isAmbientContext = f;
      }
    }
    parseClass(l, f, y) {
      let v = this.state.inAbstractClass;
      this.state.inAbstractClass = !!l.abstract;
      try {
        return super.parseClass(l, f, y);
      } finally {
        this.state.inAbstractClass = v;
      }
    }
    tsParseAbstractDeclaration(l, f) {
      if (this.match(80))
        return l.abstract = !0, this.maybeTakeDecorators(f, this.parseClass(l, !0, !1));
      if (this.isContextual(129)) {
        if (!this.hasFollowingLineBreak())
          return l.abstract = !0, this.raise(ge.NonClassMethodPropertyHasAbstractModifer, l), this.tsParseInterfaceDeclaration(l);
      } else
        this.unexpected(null, 80);
    }
    parseMethod(l, f, y, v, E, k, F) {
      let N = super.parseMethod(l, f, y, v, E, k, F);
      if (N.abstract && (this.hasPlugin("estree") ? N.value.body : N.body)) {
        let { key: I } = N;
        this.raise(ge.AbstractMethodHasImplementation, N, { methodName: I.type === "Identifier" && !N.computed ? I.name : `[${this.input.slice(I.start, I.end)}]` });
      }
      return N;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(l, f, y, v) {
      return !f && v ? (this.parseTypeOnlyImportExportSpecifier(l, !1, y), this.finishNode(l, "ExportSpecifier")) : (l.exportKind = "value", super.parseExportSpecifier(l, f, y, v));
    }
    parseImportSpecifier(l, f, y, v, E) {
      return !f && v ? (this.parseTypeOnlyImportExportSpecifier(l, !0, y), this.finishNode(l, "ImportSpecifier")) : (l.importKind = "value", super.parseImportSpecifier(l, f, y, v, y ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(l, f, y) {
      let v = f ? "imported" : "local", E = f ? "local" : "exported", k = l[v], F, N = !1, I = !0, U = k.loc.start;
      if (this.isContextual(93)) {
        let he = this.parseIdentifier();
        if (this.isContextual(93)) {
          let ce = this.parseIdentifier();
          De(this.state.type) ? (N = !0, k = he, F = f ? this.parseIdentifier() : this.parseModuleExportName(), I = !1) : (F = ce, I = !1);
        } else
          De(this.state.type) ? (I = !1, F = f ? this.parseIdentifier() : this.parseModuleExportName()) : (N = !0, k = he);
      } else
        De(this.state.type) && (N = !0, f ? (k = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(k.name, k.loc.start, !0, !0)) : k = this.parseModuleExportName());
      N && y && this.raise(f ? ge.TypeModifierIsUsedInTypeImports : ge.TypeModifierIsUsedInTypeExports, U), l[v] = k, l[E] = F;
      let ne = f ? "importKind" : "exportKind";
      l[ne] = N ? "type" : "value", I && this.eatContextual(93) && (l[E] = f ? this.parseIdentifier() : this.parseModuleExportName()), l[E] || (l[E] = xi(l[v])), f && this.checkIdentifier(l[E], N ? 4098 : 4096);
    }
  };
  function zP(d) {
    if (d.type !== "MemberExpression")
      return !1;
    let { computed: l, property: f } = d;
    return l && f.type !== "StringLiteral" && (f.type !== "TemplateLiteral" || f.expressions.length > 0) ? !1 : fO(d.object);
  }
  function GP(d, l) {
    var f;
    let { type: y } = d;
    if ((f = d.extra) != null && f.parenthesized)
      return !1;
    if (l) {
      if (y === "Literal") {
        let { value: v } = d;
        if (typeof v == "string" || typeof v == "boolean")
          return !0;
      }
    } else if (y === "StringLiteral" || y === "BooleanLiteral")
      return !0;
    return !!(dO(d, l) || HP(d, l) || y === "TemplateLiteral" && d.expressions.length === 0 || zP(d));
  }
  function dO(d, l) {
    return l ? d.type === "Literal" && (typeof d.value == "number" || "bigint" in d) : d.type === "NumericLiteral" || d.type === "BigIntLiteral";
  }
  function HP(d, l) {
    if (d.type === "UnaryExpression") {
      let { operator: f, argument: y } = d;
      if (f === "-" && dO(y, l))
        return !0;
    }
    return !1;
  }
  function fO(d) {
    return d.type === "Identifier" ? !0 : d.type !== "MemberExpression" || d.computed ? !1 : fO(d.object);
  }
  var mO = S`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), JP = (d) => class extends d {
    parsePlaceholder(l) {
      if (this.match(144)) {
        let f = this.startNode();
        return this.next(), this.assertNoSpace(), f.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(f, l);
      }
    }
    finishPlaceholder(l, f) {
      let y = !!(l.expectedNode && l.type === "Placeholder");
      return l.expectedNode = f, y ? l : this.finishNode(l, "Placeholder");
    }
    getTokenFromCode(l) {
      l === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(l);
    }
    parseExprAtom(l) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(l);
    }
    parseIdentifier(l) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(l);
    }
    checkReservedWord(l, f, y, v) {
      l !== void 0 && super.checkReservedWord(l, f, y, v);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(l, f, y) {
      return l === "Placeholder" || super.isValidLVal(l, f, y);
    }
    toAssignable(l, f) {
      l && l.type === "Placeholder" && l.expectedNode === "Expression" ? l.expectedNode = "Pattern" : super.toAssignable(l, f);
    }
    chStartsBindingIdentifier(l, f) {
      return !!(super.chStartsBindingIdentifier(l, f) || this.lookahead().type === 144);
    }
    verifyBreakContinue(l, f) {
      l.label && l.label.type === "Placeholder" || super.verifyBreakContinue(l, f);
    }
    parseExpressionStatement(l, f) {
      var y;
      if (f.type !== "Placeholder" || (y = f.extra) != null && y.parenthesized)
        return super.parseExpressionStatement(l, f);
      if (this.match(14)) {
        let v = l;
        return v.label = this.finishPlaceholder(f, "Identifier"), this.next(), v.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(v, "LabeledStatement");
      }
      return this.semicolon(), l.name = f.name, this.finishPlaceholder(l, "Statement");
    }
    parseBlock(l, f, y) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(l, f, y);
    }
    parseFunctionId(l) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(l);
    }
    parseClass(l, f, y) {
      let v = f ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let E = this.state.strict, k = this.parsePlaceholder("Identifier");
      if (k)
        if (this.match(81) || this.match(144) || this.match(5))
          l.id = k;
        else {
          if (y || !f)
            return l.id = null, l.body = this.finishPlaceholder(k, "ClassBody"), this.finishNode(l, v);
          throw this.raise(mO.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(l, f, y);
      return super.parseClassSuper(l), l.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!l.superClass, E), this.finishNode(l, v);
    }
    parseExport(l, f) {
      let y = this.parsePlaceholder("Identifier");
      if (!y)
        return super.parseExport(l, f);
      if (!this.isContextual(98) && !this.match(12))
        return l.specifiers = [], l.source = null, l.declaration = this.finishPlaceholder(y, "Declaration"), this.finishNode(l, "ExportNamedDeclaration");
      this.expectPlugin("exportDefaultFrom");
      let v = this.startNode();
      return v.exported = y, l.specifiers = [this.finishNode(v, "ExportDefaultSpecifier")], super.parseExport(l, f);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let l = this.nextTokenStart();
        if (this.isUnparsedContextual(l, "from") && this.input.startsWith(Br(144), this.nextTokenStartSince(l + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(l, f) {
      var y;
      return (y = l.specifiers) != null && y.length ? !0 : super.maybeParseExportDefaultSpecifier(l, f);
    }
    checkExport(l) {
      let { specifiers: f } = l;
      f != null && f.length && (l.specifiers = f.filter((y) => y.exported.type === "Placeholder")), super.checkExport(l), l.specifiers = f;
    }
    parseImport(l) {
      let f = this.parsePlaceholder("Identifier");
      if (!f)
        return super.parseImport(l);
      if (l.specifiers = [], !this.isContextual(98) && !this.match(12))
        return l.source = this.finishPlaceholder(f, "StringLiteral"), this.semicolon(), this.finishNode(l, "ImportDeclaration");
      let y = this.startNodeAtNode(f);
      return y.local = f, l.specifiers.push(this.finishNode(y, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(l) || this.parseNamedImportSpecifiers(l)), this.expectContextual(98), l.source = this.parseImportSource(), this.semicolon(), this.finishNode(l, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.state.lastTokEndLoc.index && this.raise(mO.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, KP = (d) => class extends d {
    parseV8Intrinsic() {
      if (this.match(54)) {
        let l = this.state.startLoc, f = this.startNode();
        if (this.next(), j(this.state.type)) {
          let y = this.parseIdentifierName(), v = this.createIdentifier(f, y);
          if (v.type = "V8IntrinsicIdentifier", this.match(10))
            return v;
        }
        this.unexpected(l);
      }
    }
    parseExprAtom(l) {
      return this.parseV8Intrinsic() || super.parseExprAtom(l);
    }
  };
  function Et(d, l) {
    let [f, y] = typeof l == "string" ? [l, {}] : l, v = Object.keys(y), E = v.length === 0;
    return d.some((k) => {
      if (typeof k == "string")
        return E && k === f;
      {
        let [F, N] = k;
        if (F !== f)
          return !1;
        for (let I of v)
          if (N[I] !== y[I])
            return !1;
        return !0;
      }
    });
  }
  function qi(d, l, f) {
    let y = d.find((v) => Array.isArray(v) ? v[0] === l : v === l);
    return y && Array.isArray(y) && y.length > 1 ? y[1][f] : null;
  }
  var gO = ["minimal", "fsharp", "hack", "smart"], yO = ["^^", "@@", "^", "%", "#"], OO = ["hash", "bar"];
  function eF(d) {
    if (Et(d, "decorators")) {
      if (Et(d, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let l = qi(d, "decorators", "decoratorsBeforeExport");
      if (l != null && typeof l != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let f = qi(d, "decorators", "allowCallParenthesized");
      if (f != null && typeof f != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (Et(d, "flow") && Et(d, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (Et(d, "placeholders") && Et(d, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (Et(d, "pipelineOperator")) {
      let l = qi(d, "pipelineOperator", "proposal");
      if (!gO.includes(l)) {
        let y = gO.map((v) => `"${v}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${y}.`);
      }
      let f = Et(d, ["recordAndTuple", { syntaxType: "hash" }]);
      if (l === "hack") {
        if (Et(d, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (Et(d, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let y = qi(d, "pipelineOperator", "topicToken");
        if (!yO.includes(y)) {
          let v = yO.map((E) => `"${E}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${v}.`);
        }
        if (y === "#" && f)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      } else if (l === "smart" && f)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (Et(d, "moduleAttributes")) {
      if (Et(d, "importAssertions") || Et(d, "importAttributes"))
        throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
      if (qi(d, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (Et(d, "importAssertions") && Et(d, "importAttributes"))
      throw new Error("Cannot combine importAssertions and importAttributes plugins.");
    if (Et(d, "recordAndTuple") && qi(d, "recordAndTuple", "syntaxType") != null && !OO.includes(qi(d, "recordAndTuple", "syntaxType")))
      throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + OO.map((l) => `'${l}'`).join(", "));
    if (Et(d, "asyncDoExpressions") && !Et(d, "doExpressions")) {
      let l = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw l.missingPlugins = "doExpressions", l;
    }
    if (Et(d, "optionalChainingAssign") && qi(d, "optionalChainingAssign", "version") !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
  }
  var xO = { estree: A, jsx: LP, flow: MP, typescript: UP, v8intrinsic: KP, placeholders: JP }, tF = Object.keys(xO), xd = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: !1, allowReturnOutsideFunction: !1, allowNewTargetOutsideFunction: !1, allowImportExportEverywhere: !1, allowSuperOutsideMethod: !1, allowUndeclaredExports: !1, plugins: [], strictMode: null, ranges: !1, tokens: !1, createImportExpressions: !1, createParenthesizedExpressions: !1, errorRecovery: !1, attachComment: !0, annexB: !0 };
  function rF(d) {
    if (d == null)
      return Object.assign({}, xd);
    if (d.annexB != null && d.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    let l = {};
    for (let y of Object.keys(xd)) {
      var f;
      l[y] = (f = d[y]) != null ? f : xd[y];
    }
    return l;
  }
  var nF = class extends WP {
    checkProto(d, l, f, y) {
      if (d.type === "SpreadElement" || this.isObjectMethod(d) || d.computed || d.shorthand)
        return;
      let v = d.key;
      if ((v.type === "Identifier" ? v.name : v.value) === "__proto__") {
        if (l) {
          this.raise(x.RecordNoProto, v);
          return;
        }
        f.used && (y ? y.doubleProtoLoc === null && (y.doubleProtoLoc = v.loc.start) : this.raise(x.DuplicateProto, v)), f.used = !0;
      }
    }
    shouldExitDescending(d, l) {
      return d.type === "ArrowFunctionExpression" && d.start === l;
    }
    getExpression() {
      this.enterInitialScopes(), this.nextToken();
      let d = this.parseExpression();
      return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), d.comments = this.comments, d.errors = this.state.errors, this.options.tokens && (d.tokens = this.tokens), d;
    }
    parseExpression(d, l) {
      return d ? this.disallowInAnd(() => this.parseExpressionBase(l)) : this.allowInAnd(() => this.parseExpressionBase(l));
    }
    parseExpressionBase(d) {
      let l = this.state.startLoc, f = this.parseMaybeAssign(d);
      if (this.match(12)) {
        let y = this.startNodeAt(l);
        for (y.expressions = [f]; this.eat(12); )
          y.expressions.push(this.parseMaybeAssign(d));
        return this.toReferencedList(y.expressions), this.finishNode(y, "SequenceExpression");
      }
      return f;
    }
    parseMaybeAssignDisallowIn(d, l) {
      return this.disallowInAnd(() => this.parseMaybeAssign(d, l));
    }
    parseMaybeAssignAllowIn(d, l) {
      return this.allowInAnd(() => this.parseMaybeAssign(d, l));
    }
    setOptionalParametersError(d, l) {
      var f;
      d.optionalParametersLoc = (f = l == null ? void 0 : l.loc) != null ? f : this.state.startLoc;
    }
    parseMaybeAssign(d, l) {
      let f = this.state.startLoc;
      if (this.isContextual(108) && this.prodParam.hasYield) {
        let k = this.parseYield();
        return l && (k = l.call(this, k, f)), k;
      }
      let y;
      d ? y = !1 : (d = new tc(), y = !0);
      let { type: v } = this.state;
      (v === 10 || j(v)) && (this.state.potentialArrowAt = this.state.start);
      let E = this.parseMaybeConditional(d);
      if (l && (E = l.call(this, E, f)), ht(this.state.type)) {
        let k = this.startNodeAt(f), F = this.state.value;
        if (k.operator = F, this.match(29)) {
          this.toAssignable(E, !0), k.left = E;
          let N = f.index;
          d.doubleProtoLoc != null && d.doubleProtoLoc.index >= N && (d.doubleProtoLoc = null), d.shorthandAssignLoc != null && d.shorthandAssignLoc.index >= N && (d.shorthandAssignLoc = null), d.privateKeyLoc != null && d.privateKeyLoc.index >= N && (this.checkDestructuringPrivate(d), d.privateKeyLoc = null);
        } else
          k.left = E;
        return this.next(), k.right = this.parseMaybeAssign(), this.checkLVal(E, { in: this.finishNode(k, "AssignmentExpression") }), k;
      } else
        y && this.checkExpressionErrors(d, !0);
      return E;
    }
    parseMaybeConditional(d) {
      let l = this.state.startLoc, f = this.state.potentialArrowAt, y = this.parseExprOps(d);
      return this.shouldExitDescending(y, f) ? y : this.parseConditional(y, l, d);
    }
    parseConditional(d, l, f) {
      if (this.eat(17)) {
        let y = this.startNodeAt(l);
        return y.test = d, y.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), y.alternate = this.parseMaybeAssign(), this.finishNode(y, "ConditionalExpression");
      }
      return d;
    }
    parseMaybeUnaryOrPrivate(d) {
      return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(d);
    }
    parseExprOps(d) {
      let l = this.state.startLoc, f = this.state.potentialArrowAt, y = this.parseMaybeUnaryOrPrivate(d);
      return this.shouldExitDescending(y, f) ? y : this.parseExprOp(y, l, -1);
    }
    parseExprOp(d, l, f) {
      if (this.isPrivateName(d)) {
        let v = this.getPrivateNameSV(d);
        (f >= Li(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(x.PrivateInExpectedIn, d, { identifierName: v }), this.classScope.usePrivateName(v, d.loc.start);
      }
      let y = this.state.type;
      if (rr(y) && (this.prodParam.hasIn || !this.match(58))) {
        let v = Li(y);
        if (v > f) {
          if (y === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return d;
            this.checkPipelineAtInfixOperator(d, l);
          }
          let E = this.startNodeAt(l);
          E.left = d, E.operator = this.state.value;
          let k = y === 41 || y === 42, F = y === 40;
          if (F && (v = Li(42)), this.next(), y === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(x.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          E.right = this.parseExprOpRightExpr(y, v);
          let N = this.finishNode(E, k || F ? "LogicalExpression" : "BinaryExpression"), I = this.state.type;
          if (F && (I === 41 || I === 42) || k && I === 40)
            throw this.raise(x.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(N, l, f);
        }
      }
      return d;
    }
    parseExprOpRightExpr(d, l) {
      let f = this.state.startLoc;
      switch (d) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "smart":
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108))
                  throw this.raise(x.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(d, l), f);
              });
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(l));
          }
        default:
          return this.parseExprOpBaseRightExpr(d, l);
      }
    }
    parseExprOpBaseRightExpr(d, l) {
      let f = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), f, Sa(d) ? l - 1 : l);
    }
    parseHackPipeBody() {
      var d;
      let { startLoc: l } = this.state, f = this.parseMaybeAssign();
      return p.has(f.type) && !((d = f.extra) != null && d.parenthesized) && this.raise(x.PipeUnparenthesizedBody, l, { type: f.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(x.PipeTopicUnused, l), f;
    }
    checkExponentialAfterUnary(d) {
      this.match(57) && this.raise(x.UnexpectedTokenUnaryExponentiation, d.argument);
    }
    parseMaybeUnary(d, l) {
      let f = this.state.startLoc, y = this.isContextual(96);
      if (y && this.isAwaitAllowed()) {
        this.next();
        let F = this.parseAwait(f);
        return l || this.checkExponentialAfterUnary(F), F;
      }
      let v = this.match(34), E = this.startNode();
      if ($r(this.state.type)) {
        E.operator = this.state.value, E.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let F = this.match(89);
        if (this.next(), E.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(d, !0), this.state.strict && F) {
          let N = E.argument;
          N.type === "Identifier" ? this.raise(x.StrictDelete, E) : this.hasPropertyAsPrivateName(N) && this.raise(x.DeletePrivateField, E);
        }
        if (!v)
          return l || this.checkExponentialAfterUnary(E), this.finishNode(E, "UnaryExpression");
      }
      let k = this.parseUpdate(E, v, d);
      if (y) {
        let { type: F } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? it(F) : it(F) && !this.match(54)) && !this.isAmbiguousAwait())
          return this.raiseOverwrite(x.AwaitNotInAsyncContext, f), this.parseAwait(f);
      }
      return k;
    }
    parseUpdate(d, l, f) {
      if (l) {
        let E = d;
        return this.checkLVal(E.argument, { in: this.finishNode(E, "UpdateExpression") }), d;
      }
      let y = this.state.startLoc, v = this.parseExprSubscripts(f);
      if (this.checkExpressionErrors(f, !1))
        return v;
      for (; kt(this.state.type) && !this.canInsertSemicolon(); ) {
        let E = this.startNodeAt(y);
        E.operator = this.state.value, E.prefix = !1, E.argument = v, this.next(), this.checkLVal(v, { in: v = this.finishNode(E, "UpdateExpression") });
      }
      return v;
    }
    parseExprSubscripts(d) {
      let l = this.state.startLoc, f = this.state.potentialArrowAt, y = this.parseExprAtom(d);
      return this.shouldExitDescending(y, f) ? y : this.parseSubscripts(y, l);
    }
    parseSubscripts(d, l, f) {
      let y = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(d), stop: !1 };
      do
        d = this.parseSubscript(d, l, f, y), y.maybeAsyncArrow = !1;
      while (!y.stop);
      return d;
    }
    parseSubscript(d, l, f, y) {
      let { type: v } = this.state;
      if (!f && v === 15)
        return this.parseBind(d, l, f, y);
      if (Ir(v))
        return this.parseTaggedTemplateExpression(d, l, y);
      let E = !1;
      if (v === 18) {
        if (f && (this.raise(x.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return y.stop = !0, d;
        y.optionalChainMember = E = !0, this.next();
      }
      if (!f && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(d, l, y, E);
      {
        let k = this.eat(0);
        return k || E || this.eat(16) ? this.parseMember(d, l, y, k, E) : (y.stop = !0, d);
      }
    }
    parseMember(d, l, f, y, v) {
      let E = this.startNodeAt(l);
      return E.object = d, E.computed = y, y ? (E.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (d.type === "Super" && this.raise(x.SuperPrivateField, l), this.classScope.usePrivateName(this.state.value, this.state.startLoc), E.property = this.parsePrivateName()) : E.property = this.parseIdentifier(!0), f.optionalChainMember ? (E.optional = v, this.finishNode(E, "OptionalMemberExpression")) : this.finishNode(E, "MemberExpression");
    }
    parseBind(d, l, f, y) {
      let v = this.startNodeAt(l);
      return v.object = d, this.next(), v.callee = this.parseNoCallExpr(), y.stop = !0, this.parseSubscripts(this.finishNode(v, "BindExpression"), l, f);
    }
    parseCoverCallAndAsyncArrowHead(d, l, f, y) {
      let v = this.state.maybeInArrowParameters, E = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let k = this.startNodeAt(l);
      k.callee = d;
      let { maybeAsyncArrow: F, optionalChainMember: N } = f;
      F && (this.expressionScope.enter(AP()), E = new tc()), N && (k.optional = y), y ? k.arguments = this.parseCallExpressionArguments(11) : k.arguments = this.parseCallExpressionArguments(11, d.type === "Import", d.type !== "Super", k, E);
      let I = this.finishCallExpression(k, N);
      return F && this.shouldParseAsyncArrow() && !y ? (f.stop = !0, this.checkDestructuringPrivate(E), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), I = this.parseAsyncArrowFromCallExpression(this.startNodeAt(l), I)) : (F && (this.checkExpressionErrors(E, !0), this.expressionScope.exit()), this.toReferencedArguments(I)), this.state.maybeInArrowParameters = v, I;
    }
    toReferencedArguments(d, l) {
      this.toReferencedListDeep(d.arguments, l);
    }
    parseTaggedTemplateExpression(d, l, f) {
      let y = this.startNodeAt(l);
      return y.tag = d, y.quasi = this.parseTemplate(!0), f.optionalChainMember && this.raise(x.OptionalChainingNoTemplate, l), this.finishNode(y, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(d) {
      return d.type === "Identifier" && d.name === "async" && this.state.lastTokEndLoc.index === d.end && !this.canInsertSemicolon() && d.end - d.start === 5 && d.start === this.state.potentialArrowAt;
    }
    expectImportAttributesPlugin() {
      this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
    }
    finishCallExpression(d, l) {
      if (d.callee.type === "Import")
        if (d.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), d.arguments.length === 0 || d.arguments.length > 2)
          this.raise(x.ImportCallArity, d, { maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
        else
          for (let f of d.arguments)
            f.type === "SpreadElement" && this.raise(x.ImportCallSpreadArgument, f);
      return this.finishNode(d, l ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(d, l, f, y, v) {
      let E = [], k = !0, F = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(d); ) {
        if (k)
          k = !1;
        else if (this.expect(12), this.match(d)) {
          l && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(x.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), y && this.addTrailingCommaExtraToNode(y), this.next();
          break;
        }
        E.push(this.parseExprListItem(!1, v, f));
      }
      return this.state.inFSharpPipelineDirectBody = F, E;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(d, l) {
      var f;
      return this.resetPreviousNodeTrailingComments(l), this.expect(19), this.parseArrowExpression(d, l.arguments, !0, (f = l.extra) == null ? void 0 : f.trailingCommaLoc), l.innerComments && Oi(d, l.innerComments), l.callee.trailingComments && Oi(d, l.callee.trailingComments), d;
    }
    parseNoCallExpr() {
      let d = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), d, !0);
    }
    parseExprAtom(d) {
      let l, f = null, { type: y } = this.state;
      switch (y) {
        case 79:
          return this.parseSuper();
        case 83:
          return l = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(l) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(l) : this.finishNode(l, "Import") : (this.raise(x.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(l, "Import"));
        case 78:
          return l = this.startNode(), this.next(), this.finishNode(l, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 134:
          return this.parseNumericLiteral(this.state.value);
        case 135:
          return this.parseBigIntLiteral(this.state.value);
        case 136:
          return this.parseDecimalLiteral(this.state.value);
        case 133:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let v = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(v);
        }
        case 2:
        case 1:
          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
        case 0:
          return this.parseArrayLike(3, !0, !1, d);
        case 6:
        case 7:
          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
        case 5:
          return this.parseObjectLike(8, !1, !1, d);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          f = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(f, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          l = this.startNode(), this.next(), l.object = null;
          let v = l.callee = this.parseNoCallExpr();
          if (v.type === "MemberExpression")
            return this.finishNode(l, "BindExpression");
          throw this.raise(x.UnsupportedBind, v);
        }
        case 138:
          return this.raise(x.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let v = this.getPluginOption("pipelineOperator", "proposal");
          if (v)
            return this.parseTopicReference(v);
          this.unexpected();
          break;
        }
        case 47: {
          let v = this.input.codePointAt(this.nextTokenStart());
          _e(v) || v === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
          break;
        }
        default:
          if (j(y)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let v = this.state.potentialArrowAt === this.state.start, E = this.state.containsEsc, k = this.parseIdentifier();
            if (!E && k.name === "async" && !this.canInsertSemicolon()) {
              let { type: F } = this.state;
              if (F === 68)
                return this.resetPreviousNodeTrailingComments(k), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(k));
              if (j(F))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(k)) : k;
              if (F === 90)
                return this.resetPreviousNodeTrailingComments(k), this.parseDo(this.startNodeAtNode(k), !0);
            }
            return v && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(k), [k], !1)) : k;
          } else
            this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(d, l) {
      let f = this.getPluginOption("pipelineOperator", "proposal");
      if (f)
        return this.state.type = d, this.state.value = l, this.state.pos--, this.state.end--, this.state.endLoc = i(this.state.endLoc, -1), this.parseTopicReference(f);
      this.unexpected();
    }
    parseTopicReference(d) {
      let l = this.startNode(), f = this.state.startLoc, y = this.state.type;
      return this.next(), this.finishTopicReference(l, f, d, y);
    }
    finishTopicReference(d, l, f, y) {
      if (this.testTopicReferenceConfiguration(f, l, y)) {
        let v = f === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
        return this.topicReferenceIsAllowedInCurrentContext() || this.raise(f === "smart" ? x.PrimaryTopicNotAllowed : x.PipeTopicUnbound, l), this.registerTopicReference(), this.finishNode(d, v);
      } else
        throw this.raise(x.PipeTopicUnconfiguredToken, l, { token: Br(y) });
    }
    testTopicReferenceConfiguration(d, l, f) {
      switch (d) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", { topicToken: Br(f) }]);
        case "smart":
          return f === 27;
        default:
          throw this.raise(x.PipeTopicRequiresHackPipes, l);
      }
    }
    parseAsyncArrowUnaryFunction(d) {
      this.prodParam.enter(ec(!0, this.prodParam.hasYield));
      let l = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(x.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(d, l, !0);
    }
    parseDo(d, l) {
      this.expectPlugin("doExpressions"), l && this.expectPlugin("asyncDoExpressions"), d.async = l, this.next();
      let f = this.state.labels;
      return this.state.labels = [], l ? (this.prodParam.enter(2), d.body = this.parseBlock(), this.prodParam.exit()) : d.body = this.parseBlock(), this.state.labels = f, this.finishNode(d, "DoExpression");
    }
    parseSuper() {
      let d = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(x.SuperNotAllowed, d) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(x.UnexpectedSuper, d), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(x.UnsupportedSuper, d), this.finishNode(d, "Super");
    }
    parsePrivateName() {
      let d = this.startNode(), l = this.startNodeAt(i(this.state.startLoc, 1)), f = this.state.value;
      return this.next(), d.id = this.createIdentifier(l, f), this.finishNode(d, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let d = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let l = this.createIdentifier(this.startNodeAtNode(d), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(d, l, "sent");
      }
      return this.parseFunction(d);
    }
    parseMetaProperty(d, l, f) {
      d.meta = l;
      let y = this.state.containsEsc;
      return d.property = this.parseIdentifier(!0), (d.property.name !== f || y) && this.raise(x.UnsupportedMetaProperty, d.property, { target: l.name, onlyValidPropertyName: f }), this.finishNode(d, "MetaProperty");
    }
    parseImportMetaProperty(d) {
      let l = this.createIdentifier(this.startNodeAtNode(d), "import");
      if (this.next(), this.isContextual(101))
        this.inModule || this.raise(x.ImportMetaOutsideModule, l), this.sawUnambiguousESM = !0;
      else if (this.isContextual(105) || this.isContextual(97)) {
        let f = this.isContextual(105);
        if (f || this.unexpected(), this.expectPlugin(f ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
          throw this.raise(x.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
        return this.next(), d.phase = f ? "source" : "defer", this.parseImportCall(d);
      }
      return this.parseMetaProperty(d, l, "meta");
    }
    parseLiteralAtNode(d, l, f) {
      return this.addExtra(f, "rawValue", d), this.addExtra(f, "raw", this.input.slice(f.start, this.state.end)), f.value = d, this.next(), this.finishNode(f, l);
    }
    parseLiteral(d, l) {
      let f = this.startNode();
      return this.parseLiteralAtNode(d, l, f);
    }
    parseStringLiteral(d) {
      return this.parseLiteral(d, "StringLiteral");
    }
    parseNumericLiteral(d) {
      return this.parseLiteral(d, "NumericLiteral");
    }
    parseBigIntLiteral(d) {
      return this.parseLiteral(d, "BigIntLiteral");
    }
    parseDecimalLiteral(d) {
      return this.parseLiteral(d, "DecimalLiteral");
    }
    parseRegExpLiteral(d) {
      let l = this.parseLiteral(d.value, "RegExpLiteral");
      return l.pattern = d.pattern, l.flags = d.flags, l;
    }
    parseBooleanLiteral(d) {
      let l = this.startNode();
      return l.value = d, this.next(), this.finishNode(l, "BooleanLiteral");
    }
    parseNullLiteral() {
      let d = this.startNode();
      return this.next(), this.finishNode(d, "NullLiteral");
    }
    parseParenAndDistinguishExpression(d) {
      let l = this.state.startLoc, f;
      this.next(), this.expressionScope.enter(EP());
      let y = this.state.maybeInArrowParameters, v = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let E = this.state.startLoc, k = [], F = new tc(), N = !0, I, U;
      for (; !this.match(11); ) {
        if (N)
          N = !1;
        else if (this.expect(12, F.optionalParametersLoc === null ? null : F.optionalParametersLoc), this.match(11)) {
          U = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let ce = this.state.startLoc;
          if (I = this.state.startLoc, k.push(this.parseParenItem(this.parseRestBinding(), ce)), !this.checkCommaAfterRest(41))
            break;
        } else
          k.push(this.parseMaybeAssignAllowIn(F, this.parseParenItem));
      }
      let ne = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = y, this.state.inFSharpPipelineDirectBody = v;
      let he = this.startNodeAt(l);
      return d && this.shouldParseArrow(k) && (he = this.parseArrow(he)) ? (this.checkDestructuringPrivate(F), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(he, k, !1), he) : (this.expressionScope.exit(), k.length || this.unexpected(this.state.lastTokStartLoc), U && this.unexpected(U), I && this.unexpected(I), this.checkExpressionErrors(F, !0), this.toReferencedListDeep(k, !0), k.length > 1 ? (f = this.startNodeAt(E), f.expressions = k, this.finishNode(f, "SequenceExpression"), this.resetEndLocation(f, ne)) : f = k[0], this.wrapParenthesis(l, f));
    }
    wrapParenthesis(d, l) {
      if (!this.options.createParenthesizedExpressions)
        return this.addExtra(l, "parenthesized", !0), this.addExtra(l, "parenStart", d.index), this.takeSurroundingComments(l, d.index, this.state.lastTokEndLoc.index), l;
      let f = this.startNodeAt(d);
      return f.expression = l, this.finishNode(f, "ParenthesizedExpression");
    }
    shouldParseArrow(d) {
      return !this.canInsertSemicolon();
    }
    parseArrow(d) {
      if (this.eat(19))
        return d;
    }
    parseParenItem(d, l) {
      return d;
    }
    parseNewOrNewTarget() {
      let d = this.startNode();
      if (this.next(), this.match(16)) {
        let l = this.createIdentifier(this.startNodeAtNode(d), "new");
        this.next();
        let f = this.parseMetaProperty(d, l, "target");
        return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(x.UnexpectedNewTarget, f), f;
      }
      return this.parseNew(d);
    }
    parseNew(d) {
      if (this.parseNewCallee(d), this.eat(10)) {
        let l = this.parseExprList(11);
        this.toReferencedList(l), d.arguments = l;
      } else
        d.arguments = [];
      return this.finishNode(d, "NewExpression");
    }
    parseNewCallee(d) {
      let l = this.match(83), f = this.parseNoCallExpr();
      d.callee = f, l && (f.type === "Import" || f.type === "ImportExpression") && this.raise(x.ImportCallNotNewExpression, f);
    }
    parseTemplateElement(d) {
      let { start: l, startLoc: f, end: y, value: v } = this.state, E = l + 1, k = this.startNodeAt(i(f, 1));
      v === null && (d || this.raise(x.InvalidEscapeSequenceTemplate, i(this.state.firstInvalidTemplateEscapePos, 1)));
      let F = this.match(24), N = F ? -1 : -2, I = y + N;
      k.value = { raw: this.input.slice(E, I).replace(/\r\n?/g, `
`), cooked: v === null ? null : v.slice(1, N) }, k.tail = F, this.next();
      let U = this.finishNode(k, "TemplateElement");
      return this.resetEndLocation(U, i(this.state.lastTokEndLoc, N)), U;
    }
    parseTemplate(d) {
      let l = this.startNode();
      l.expressions = [];
      let f = this.parseTemplateElement(d);
      for (l.quasis = [f]; !f.tail; )
        l.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), l.quasis.push(f = this.parseTemplateElement(d));
      return this.finishNode(l, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(d, l, f, y) {
      f && this.expectPlugin("recordAndTuple");
      let v = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let E = /* @__PURE__ */ Object.create(null), k = !0, F = this.startNode();
      for (F.properties = [], this.next(); !this.match(d); ) {
        if (k)
          k = !1;
        else if (this.expect(12), this.match(d)) {
          this.addTrailingCommaExtraToNode(F);
          break;
        }
        let I;
        l ? I = this.parseBindingProperty() : (I = this.parsePropertyDefinition(y), this.checkProto(I, f, E, y)), f && !this.isObjectProperty(I) && I.type !== "SpreadElement" && this.raise(x.InvalidRecordProperty, I), I.shorthand && this.addExtra(I, "shorthand", !0), F.properties.push(I);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = v;
      let N = "ObjectExpression";
      return l ? N = "ObjectPattern" : f && (N = "RecordExpression"), this.finishNode(F, N);
    }
    addTrailingCommaExtraToNode(d) {
      this.addExtra(d, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(d, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(d) {
      return !d.computed && d.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(d) {
      let l = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(x.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          l.push(this.parseDecorator());
      let f = this.startNode(), y = !1, v = !1, E;
      if (this.match(21))
        return l.length && this.unexpected(), this.parseSpread();
      l.length && (f.decorators = l, l = []), f.method = !1, d && (E = this.state.startLoc);
      let k = this.eat(55);
      this.parsePropertyNamePrefixOperator(f);
      let F = this.state.containsEsc, N = this.parsePropertyName(f, d);
      if (!k && !F && this.maybeAsyncOrAccessorProp(f)) {
        let I = N.name;
        I === "async" && !this.hasPrecedingLineBreak() && (y = !0, this.resetPreviousNodeTrailingComments(N), k = this.eat(55), this.parsePropertyName(f)), (I === "get" || I === "set") && (v = !0, this.resetPreviousNodeTrailingComments(N), f.kind = I, this.match(55) && (k = !0, this.raise(x.AccessorIsGenerator, this.state.curPosition(), { kind: I }), this.next()), this.parsePropertyName(f));
      }
      return this.parseObjPropValue(f, E, k, y, !1, v, d);
    }
    getGetterSetterExpectedParamCount(d) {
      return d.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(d) {
      return d.params;
    }
    checkGetterSetterParams(d) {
      var l;
      let f = this.getGetterSetterExpectedParamCount(d), y = this.getObjectOrClassMethodParams(d);
      y.length !== f && this.raise(d.kind === "get" ? x.BadGetterArity : x.BadSetterArity, d), d.kind === "set" && ((l = y[y.length - 1]) == null ? void 0 : l.type) === "RestElement" && this.raise(x.BadSetterRestParameter, d);
    }
    parseObjectMethod(d, l, f, y, v) {
      if (v) {
        let E = this.parseMethod(d, l, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(E), E;
      }
      if (f || l || this.match(10))
        return y && this.unexpected(), d.kind = "method", d.method = !0, this.parseMethod(d, l, f, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(d, l, f, y) {
      if (d.shorthand = !1, this.eat(14))
        return d.value = f ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(y), this.finishNode(d, "ObjectProperty");
      if (!d.computed && d.key.type === "Identifier") {
        if (this.checkReservedWord(d.key.name, d.key.loc.start, !0, !1), f)
          d.value = this.parseMaybeDefault(l, xi(d.key));
        else if (this.match(29)) {
          let v = this.state.startLoc;
          y != null ? y.shorthandAssignLoc === null && (y.shorthandAssignLoc = v) : this.raise(x.InvalidCoverInitializedName, v), d.value = this.parseMaybeDefault(l, xi(d.key));
        } else
          d.value = xi(d.key);
        return d.shorthand = !0, this.finishNode(d, "ObjectProperty");
      }
    }
    parseObjPropValue(d, l, f, y, v, E, k) {
      let F = this.parseObjectMethod(d, f, y, v, E) || this.parseObjectProperty(d, l, v, k);
      return F || this.unexpected(), F;
    }
    parsePropertyName(d, l) {
      if (this.eat(0))
        d.computed = !0, d.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let { type: f, value: y } = this.state, v;
        if (De(f))
          v = this.parseIdentifier(!0);
        else
          switch (f) {
            case 134:
              v = this.parseNumericLiteral(y);
              break;
            case 133:
              v = this.parseStringLiteral(y);
              break;
            case 135:
              v = this.parseBigIntLiteral(y);
              break;
            case 136:
              v = this.parseDecimalLiteral(y);
              break;
            case 138: {
              let E = this.state.startLoc;
              l != null ? l.privateKeyLoc === null && (l.privateKeyLoc = E) : this.raise(x.UnexpectedPrivateField, E), v = this.parsePrivateName();
              break;
            }
            default:
              this.unexpected();
          }
        d.key = v, f !== 138 && (d.computed = !1);
      }
      return d.key;
    }
    initFunction(d, l) {
      d.id = null, d.generator = !1, d.async = l;
    }
    parseMethod(d, l, f, y, v, E, k = !1) {
      this.initFunction(d, f), d.generator = l, this.scope.enter(18 | (k ? 64 : 0) | (v ? 32 : 0)), this.prodParam.enter(ec(f, d.generator)), this.parseFunctionParams(d, y);
      let F = this.parseFunctionBodyAndFinish(d, E, !0);
      return this.prodParam.exit(), this.scope.exit(), F;
    }
    parseArrayLike(d, l, f, y) {
      f && this.expectPlugin("recordAndTuple");
      let v = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let E = this.startNode();
      return this.next(), E.elements = this.parseExprList(d, !f, y, E), this.state.inFSharpPipelineDirectBody = v, this.finishNode(E, f ? "TupleExpression" : "ArrayExpression");
    }
    parseArrowExpression(d, l, f, y) {
      this.scope.enter(6);
      let v = ec(f, !1);
      !this.match(5) && this.prodParam.hasIn && (v |= 8), this.prodParam.enter(v), this.initFunction(d, f);
      let E = this.state.maybeInArrowParameters;
      return l && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(d, l, y)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(d, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = E, this.finishNode(d, "ArrowFunctionExpression");
    }
    setArrowFunctionParameters(d, l, f) {
      this.toAssignableList(l, f, !1), d.params = l;
    }
    parseFunctionBodyAndFinish(d, l, f = !1) {
      return this.parseFunctionBody(d, !1, f), this.finishNode(d, l);
    }
    parseFunctionBody(d, l, f = !1) {
      let y = l && !this.match(5);
      if (this.expressionScope.enter(lO()), y)
        d.body = this.parseMaybeAssign(), this.checkParams(d, !1, l, !1);
      else {
        let v = this.state.strict, E = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), d.body = this.parseBlock(!0, !1, (k) => {
          let F = !this.isSimpleParamList(d.params);
          k && F && this.raise(x.IllegalLanguageModeDirective, (d.kind === "method" || d.kind === "constructor") && d.key ? d.key.loc.end : d);
          let N = !v && this.state.strict;
          this.checkParams(d, !this.state.strict && !l && !f && !F, l, N), this.state.strict && d.id && this.checkIdentifier(d.id, 65, N);
        }), this.prodParam.exit(), this.state.labels = E;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(d) {
      return d.type === "Identifier";
    }
    isSimpleParamList(d) {
      for (let l = 0, f = d.length; l < f; l++)
        if (!this.isSimpleParameter(d[l]))
          return !1;
      return !0;
    }
    checkParams(d, l, f, y = !0) {
      let v = !l && /* @__PURE__ */ new Set(), E = { type: "FormalParameters" };
      for (let k of d.params)
        this.checkLVal(k, { in: E, binding: 5, checkClashes: v, strictModeChanged: y });
    }
    parseExprList(d, l, f, y) {
      let v = [], E = !0;
      for (; !this.eat(d); ) {
        if (E)
          E = !1;
        else if (this.expect(12), this.match(d)) {
          y && this.addTrailingCommaExtraToNode(y), this.next();
          break;
        }
        v.push(this.parseExprListItem(l, f));
      }
      return v;
    }
    parseExprListItem(d, l, f) {
      let y;
      if (this.match(12))
        d || this.raise(x.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), y = null;
      else if (this.match(21)) {
        let v = this.state.startLoc;
        y = this.parseParenItem(this.parseSpread(l), v);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), f || this.raise(x.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let v = this.startNode();
        this.next(), y = this.finishNode(v, "ArgumentPlaceholder");
      } else
        y = this.parseMaybeAssignAllowIn(l, this.parseParenItem);
      return y;
    }
    parseIdentifier(d) {
      let l = this.startNode(), f = this.parseIdentifierName(d);
      return this.createIdentifier(l, f);
    }
    createIdentifier(d, l) {
      return d.name = l, d.loc.identifierName = l, this.finishNode(d, "Identifier");
    }
    parseIdentifierName(d) {
      let l, { startLoc: f, type: y } = this.state;
      De(y) ? l = this.state.value : this.unexpected();
      let v = le(y);
      return d ? v && this.replaceToken(132) : this.checkReservedWord(l, f, v, !1), this.next(), l;
    }
    checkReservedWord(d, l, f, y) {
      if (!(d.length > 10 || !_r(d))) {
        if (f && Nr(d)) {
          this.raise(x.UnexpectedKeyword, l, { keyword: d });
          return;
        }
        if ((this.state.strict ? y ? pr : Ct : gt)(d, this.inModule)) {
          this.raise(x.UnexpectedReservedWord, l, { reservedWord: d });
          return;
        } else if (d === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(x.YieldBindingIdentifier, l);
            return;
          }
        } else if (d === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(x.AwaitBindingIdentifier, l);
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(x.AwaitBindingIdentifierInStaticBlock, l);
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError(l);
        } else if (d === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(x.ArgumentsInClass, l);
          return;
        }
      }
    }
    isAwaitAllowed() {
      return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
    }
    parseAwait(d) {
      let l = this.startNodeAt(d);
      return this.expressionScope.recordParameterInitializerError(x.AwaitExpressionFormalParameter, l), this.eat(55) && this.raise(x.ObsoleteAwaitStar, l), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (l.argument = this.parseMaybeUnary(null, !0)), this.finishNode(l, "AwaitExpression");
    }
    isAmbiguousAwait() {
      if (this.hasPrecedingLineBreak())
        return !0;
      let { type: d } = this.state;
      return d === 53 || d === 10 || d === 0 || Ir(d) || d === 102 && !this.state.containsEsc || d === 137 || d === 56 || this.hasPlugin("v8intrinsic") && d === 54;
    }
    parseYield() {
      let d = this.startNode();
      this.expressionScope.recordParameterInitializerError(x.YieldInParameter, d), this.next();
      let l = !1, f = null;
      if (!this.hasPrecedingLineBreak())
        switch (l = this.eat(55), this.state.type) {
          case 13:
          case 139:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!l)
              break;
          default:
            f = this.parseMaybeAssign();
        }
      return d.delegate = l, d.argument = f, this.finishNode(d, "YieldExpression");
    }
    parseImportCall(d) {
      return this.next(), d.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (d.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (d.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(d, "ImportExpression");
    }
    checkPipelineAtInfixOperator(d, l) {
      this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && d.type === "SequenceExpression" && this.raise(x.PipelineHeadSequenceExpression, l);
    }
    parseSmartPipelineBodyInStyle(d, l) {
      if (this.isSimpleReference(d)) {
        let f = this.startNodeAt(l);
        return f.callee = d, this.finishNode(f, "PipelineBareFunction");
      } else {
        let f = this.startNodeAt(l);
        return this.checkSmartPipeTopicBodyEarlyErrors(l), f.expression = d, this.finishNode(f, "PipelineTopicExpression");
      }
    }
    isSimpleReference(d) {
      switch (d.type) {
        case "MemberExpression":
          return !d.computed && this.isSimpleReference(d.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(d) {
      if (this.match(19))
        throw this.raise(x.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(x.PipelineTopicUnused, d);
    }
    withTopicBindingContext(d) {
      let l = this.state.topicContext;
      this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
      try {
        return d();
      } finally {
        this.state.topicContext = l;
      }
    }
    withSmartMixTopicForbiddingContext(d) {
      if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
        let l = this.state.topicContext;
        this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
        try {
          return d();
        } finally {
          this.state.topicContext = l;
        }
      } else
        return d();
    }
    withSoloAwaitPermittingContext(d) {
      let l = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return d();
      } finally {
        this.state.soloAwait = l;
      }
    }
    allowInAnd(d) {
      let l = this.prodParam.currentFlags();
      if (8 & ~l) {
        this.prodParam.enter(l | 8);
        try {
          return d();
        } finally {
          this.prodParam.exit();
        }
      }
      return d();
    }
    disallowInAnd(d) {
      let l = this.prodParam.currentFlags();
      if (8 & l) {
        this.prodParam.enter(l & -9);
        try {
          return d();
        } finally {
          this.prodParam.exit();
        }
      }
      return d();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(d) {
      let l = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let f = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let y = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), l, d);
      return this.state.inFSharpPipelineDirectBody = f, y;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let d = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let l = this.startNodeAt(this.state.endLoc);
      this.next();
      let f = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        d.body = this.parseProgram(l, 8, "module");
      } finally {
        f();
      }
      return this.finishNode(d, "ModuleExpression");
    }
    parsePropertyNamePrefixOperator(d) {
    }
  }, bd = { kind: 1 }, iF = { kind: 2 }, sF = /[\uD800-\uDFFF]/u, Dd = /in(?:stanceof)?/y;
  function aF(d, l) {
    for (let f = 0; f < d.length; f++) {
      let y = d[f], { type: v } = y;
      if (typeof v == "number") {
        {
          if (v === 138) {
            let { loc: E, start: k, value: F, end: N } = y, I = k + 1, U = i(E.start, 1);
            d.splice(f, 1, new Zi({ type: Nt(27), value: "#", start: k, end: I, startLoc: E.start, endLoc: U }), new Zi({ type: Nt(132), value: F, start: I, end: N, startLoc: U, endLoc: E.end })), f++;
            continue;
          }
          if (Ir(v)) {
            let { loc: E, start: k, value: F, end: N } = y, I = k + 1, U = i(E.start, 1), ne;
            l.charCodeAt(k) === 96 ? ne = new Zi({ type: Nt(22), value: "`", start: k, end: I, startLoc: E.start, endLoc: U }) : ne = new Zi({ type: Nt(8), value: "}", start: k, end: I, startLoc: E.start, endLoc: U });
            let he, ce, He, Ge;
            v === 24 ? (ce = N - 1, He = i(E.end, -1), he = F === null ? null : F.slice(1, -1), Ge = new Zi({ type: Nt(22), value: "`", start: ce, end: N, startLoc: He, endLoc: E.end })) : (ce = N - 2, He = i(E.end, -2), he = F === null ? null : F.slice(1, -2), Ge = new Zi({ type: Nt(23), value: "${", start: ce, end: N, startLoc: He, endLoc: E.end })), d.splice(f, 1, ne, new Zi({ type: Nt(20), value: he, start: I, end: ce, startLoc: U, endLoc: He }), Ge), f += 2;
            continue;
          }
        }
        y.type = Nt(v);
      }
    }
    return d;
  }
  var oF = class extends nF {
    parseTopLevel(d, l) {
      return d.program = this.parseProgram(l), d.comments = this.comments, this.options.tokens && (d.tokens = aF(this.tokens, this.input)), this.finishNode(d, "File");
    }
    parseProgram(d, l = 139, f = this.options.sourceType) {
      if (d.sourceType = f, d.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(d, !0, !0, l), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
        for (let [v, E] of Array.from(this.scope.undefinedExports))
          this.raise(x.ModuleExportUndefined, E, { localName: v });
      let y;
      return l === 139 ? y = this.finishNode(d, "Program") : y = this.finishNodeAt(d, "Program", i(this.state.startLoc, -1)), y;
    }
    stmtToDirective(d) {
      let l = d;
      l.type = "Directive", l.value = l.expression, delete l.expression;
      let f = l.value, y = f.value, v = this.input.slice(f.start, f.end), E = f.value = v.slice(1, -1);
      return this.addExtra(f, "raw", v), this.addExtra(f, "rawValue", E), this.addExtra(f, "expressionValue", y), f.type = "DirectiveLiteral", l;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let d = this.startNode();
      return d.value = this.state.value, this.next(), this.finishNode(d, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    chStartsBindingIdentifier(d, l) {
      if (_e(d)) {
        if (Dd.lastIndex = l, Dd.test(this.input)) {
          let f = this.codePointAtPos(Dd.lastIndex);
          if (!Ie(f) && f !== 92)
            return !1;
        }
        return !0;
      } else
        return d === 92;
    }
    chStartsBindingPattern(d) {
      return d === 91 || d === 123;
    }
    hasFollowingBindingAtom() {
      let d = this.nextTokenStart(), l = this.codePointAtPos(d);
      return this.chStartsBindingPattern(l) || this.chStartsBindingIdentifier(l, d);
    }
    hasInLineFollowingBindingIdentifier() {
      let d = this.nextTokenInLineStart(), l = this.codePointAtPos(d);
      return this.chStartsBindingIdentifier(l, d);
    }
    startsUsingForOf() {
      let { type: d, containsEsc: l } = this.lookahead();
      if (d === 102 && !l)
        return !1;
      if (j(d) && !this.hasFollowingLineBreak())
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    startsAwaitUsing() {
      let d = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(d, "using")) {
        d = this.nextTokenInLineStartSince(d + 5);
        let l = this.codePointAtPos(d);
        if (this.chStartsBindingIdentifier(l, d))
          return this.expectPlugin("explicitResourceManagement"), !0;
      }
      return !1;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(d = !1) {
      let l = 0;
      return this.options.annexB && !this.state.strict && (l |= 4, d && (l |= 8)), this.parseStatementLike(l);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(d) {
      let l = null;
      return this.match(26) && (l = this.parseDecorators(!0)), this.parseStatementContent(d, l);
    }
    parseStatementContent(d, l) {
      let f = this.state.type, y = this.startNode(), v = !!(d & 2), E = !!(d & 4), k = d & 1;
      switch (f) {
        case 60:
          return this.parseBreakContinueStatement(y, !0);
        case 63:
          return this.parseBreakContinueStatement(y, !1);
        case 64:
          return this.parseDebuggerStatement(y);
        case 90:
          return this.parseDoWhileStatement(y);
        case 91:
          return this.parseForStatement(y);
        case 68:
          if (this.lookaheadCharCode() === 46)
            break;
          return E || this.raise(this.state.strict ? x.StrictFunction : this.options.annexB ? x.SloppyFunctionAnnexB : x.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(y, !1, !v && E);
        case 80:
          return v || this.unexpected(), this.parseClass(this.maybeTakeDecorators(l, y), !0);
        case 69:
          return this.parseIfStatement(y);
        case 70:
          return this.parseReturnStatement(y);
        case 71:
          return this.parseSwitchStatement(y);
        case 72:
          return this.parseThrowStatement(y);
        case 73:
          return this.parseTryStatement(y);
        case 96:
          if (!this.state.containsEsc && this.startsAwaitUsing())
            return this.isAwaitAllowed() ? v || this.raise(x.UnexpectedLexicalDeclaration, y) : this.raise(x.AwaitUsingNotInAsyncContext, y), this.next(), this.parseVarStatement(y, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
            break;
          return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(x.UnexpectedUsingDeclaration, this.state.startLoc) : v || this.raise(x.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(y, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let I = this.nextTokenStart(), U = this.codePointAtPos(I);
          if (U !== 91 && (!v && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(U, I) && U !== 123))
            break;
        }
        case 75:
          v || this.raise(x.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let I = this.state.value;
          return this.parseVarStatement(y, I);
        }
        case 92:
          return this.parseWhileStatement(y);
        case 76:
          return this.parseWithStatement(y);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(y);
        case 83: {
          let I = this.lookaheadCharCode();
          if (I === 40 || I === 46)
            break;
        }
        case 82: {
          !this.options.allowImportExportEverywhere && !k && this.raise(x.UnexpectedImportExport, this.state.startLoc), this.next();
          let I;
          return f === 83 ? (I = this.parseImport(y), I.type === "ImportDeclaration" && (!I.importKind || I.importKind === "value") && (this.sawUnambiguousESM = !0)) : (I = this.parseExport(y, l), (I.type === "ExportNamedDeclaration" && (!I.exportKind || I.exportKind === "value") || I.type === "ExportAllDeclaration" && (!I.exportKind || I.exportKind === "value") || I.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(I), I;
        }
        default:
          if (this.isAsyncFunction())
            return v || this.raise(x.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(y, !0, !v && E);
      }
      let F = this.state.value, N = this.parseExpression();
      return j(f) && N.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(y, F, N, d) : this.parseExpressionStatement(y, N, l);
    }
    assertModuleNodeAllowed(d) {
      !this.options.allowImportExportEverywhere && !this.inModule && this.raise(x.ImportOutsideModule, d);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
    }
    maybeTakeDecorators(d, l, f) {
      return d && (l.decorators && l.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(x.DecoratorsBeforeAfterExport, l.decorators[0]), l.decorators.unshift(...d)) : l.decorators = d, this.resetStartLocationFromNode(l, d[0]), f && this.resetStartLocationFromNode(f, l)), l;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(d) {
      let l = [];
      do
        l.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        d || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(x.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(x.UnexpectedLeadingDecorator, this.state.startLoc);
      return l;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let d = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let l = this.state.startLoc, f;
        if (this.match(10)) {
          let y = this.state.startLoc;
          this.next(), f = this.parseExpression(), this.expect(11), f = this.wrapParenthesis(y, f);
          let v = this.state.startLoc;
          d.expression = this.parseMaybeDecoratorArguments(f), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && d.expression !== f && this.raise(x.DecoratorArgumentsOutsideParentheses, v);
        } else {
          for (f = this.parseIdentifier(!1); this.eat(16); ) {
            let y = this.startNodeAt(l);
            y.object = f, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), y.property = this.parsePrivateName()) : y.property = this.parseIdentifier(!0), y.computed = !1, f = this.finishNode(y, "MemberExpression");
          }
          d.expression = this.parseMaybeDecoratorArguments(f);
        }
      } else
        d.expression = this.parseExprSubscripts();
      return this.finishNode(d, "Decorator");
    }
    parseMaybeDecoratorArguments(d) {
      if (this.eat(10)) {
        let l = this.startNodeAtNode(d);
        return l.callee = d, l.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(l.arguments), this.finishNode(l, "CallExpression");
      }
      return d;
    }
    parseBreakContinueStatement(d, l) {
      return this.next(), this.isLineTerminator() ? d.label = null : (d.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(d, l), this.finishNode(d, l ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(d, l) {
      let f;
      for (f = 0; f < this.state.labels.length; ++f) {
        let y = this.state.labels[f];
        if ((d.label == null || y.name === d.label.name) && (y.kind != null && (l || y.kind === 1) || d.label && l))
          break;
      }
      if (f === this.state.labels.length) {
        let y = l ? "BreakStatement" : "ContinueStatement";
        this.raise(x.IllegalBreakContinue, d, { type: y });
      }
    }
    parseDebuggerStatement(d) {
      return this.next(), this.semicolon(), this.finishNode(d, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let d = this.parseExpression();
      return this.expect(11), d;
    }
    parseDoWhileStatement(d) {
      return this.next(), this.state.labels.push(bd), d.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), d.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(d, "DoWhileStatement");
    }
    parseForStatement(d) {
      this.next(), this.state.labels.push(bd);
      let l = null;
      if (this.isAwaitAllowed() && this.eatContextual(96) && (l = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
        return l !== null && this.unexpected(l), this.parseFor(d, null);
      let f = this.isContextual(100);
      {
        let F = this.isContextual(96) && this.startsAwaitUsing(), N = F || this.isContextual(107) && this.startsUsingForOf(), I = f && this.hasFollowingBindingAtom() || N;
        if (this.match(74) || this.match(75) || I) {
          let U = this.startNode(), ne;
          F ? (ne = "await using", this.isAwaitAllowed() || this.raise(x.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : ne = this.state.value, this.next(), this.parseVar(U, !0, ne);
          let he = this.finishNode(U, "VariableDeclaration"), ce = this.match(58);
          return ce && N && this.raise(x.ForInUsing, he), (ce || this.isContextual(102)) && he.declarations.length === 1 ? this.parseForIn(d, he, l) : (l !== null && this.unexpected(l), this.parseFor(d, he));
        }
      }
      let y = this.isContextual(95), v = new tc(), E = this.parseExpression(!0, v), k = this.isContextual(102);
      if (k && (f && this.raise(x.ForOfLet, E), l === null && y && E.type === "Identifier" && this.raise(x.ForOfAsync, E)), k || this.match(58)) {
        this.checkDestructuringPrivate(v), this.toAssignable(E, !0);
        let F = k ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(E, { in: { type: F } }), this.parseForIn(d, E, l);
      } else
        this.checkExpressionErrors(v, !0);
      return l !== null && this.unexpected(l), this.parseFor(d, E);
    }
    parseFunctionStatement(d, l, f) {
      return this.next(), this.parseFunction(d, 1 | (f ? 2 : 0) | (l ? 8 : 0));
    }
    parseIfStatement(d) {
      return this.next(), d.test = this.parseHeaderExpression(), d.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), d.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(d, "IfStatement");
    }
    parseReturnStatement(d) {
      return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(x.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? d.argument = null : (d.argument = this.parseExpression(), this.semicolon()), this.finishNode(d, "ReturnStatement");
    }
    parseSwitchStatement(d) {
      this.next(), d.discriminant = this.parseHeaderExpression();
      let l = d.cases = [];
      this.expect(5), this.state.labels.push(iF), this.scope.enter(0);
      let f;
      for (let y; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let v = this.match(61);
          f && this.finishNode(f, "SwitchCase"), l.push(f = this.startNode()), f.consequent = [], this.next(), v ? f.test = this.parseExpression() : (y && this.raise(x.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), y = !0, f.test = null), this.expect(14);
        } else
          f ? f.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), f && this.finishNode(f, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(d, "SwitchStatement");
    }
    parseThrowStatement(d) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(x.NewlineAfterThrow, this.state.lastTokEndLoc), d.argument = this.parseExpression(), this.semicolon(), this.finishNode(d, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let d = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && d.type === "Identifier" ? 8 : 0), this.checkLVal(d, { in: { type: "CatchClause" }, binding: 9 }), d;
    }
    parseTryStatement(d) {
      if (this.next(), d.block = this.parseBlock(), d.handler = null, this.match(62)) {
        let l = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), l.param = this.parseCatchClauseParam(), this.expect(11)) : (l.param = null, this.scope.enter(0)), l.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), d.handler = this.finishNode(l, "CatchClause");
      }
      return d.finalizer = this.eat(67) ? this.parseBlock() : null, !d.handler && !d.finalizer && this.raise(x.NoCatchOrFinally, d), this.finishNode(d, "TryStatement");
    }
    parseVarStatement(d, l, f = !1) {
      return this.next(), this.parseVar(d, !1, l, f), this.semicolon(), this.finishNode(d, "VariableDeclaration");
    }
    parseWhileStatement(d) {
      return this.next(), d.test = this.parseHeaderExpression(), this.state.labels.push(bd), d.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(d, "WhileStatement");
    }
    parseWithStatement(d) {
      return this.state.strict && this.raise(x.StrictWith, this.state.startLoc), this.next(), d.object = this.parseHeaderExpression(), d.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(d, "WithStatement");
    }
    parseEmptyStatement(d) {
      return this.next(), this.finishNode(d, "EmptyStatement");
    }
    parseLabeledStatement(d, l, f, y) {
      for (let E of this.state.labels)
        E.name === l && this.raise(x.LabelRedeclaration, f, { labelName: l });
      let v = Dn(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let E = this.state.labels.length - 1; E >= 0; E--) {
        let k = this.state.labels[E];
        if (k.statementStart === d.start)
          k.statementStart = this.state.start, k.kind = v;
        else
          break;
      }
      return this.state.labels.push({ name: l, kind: v, statementStart: this.state.start }), d.body = y & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), d.label = f, this.finishNode(d, "LabeledStatement");
    }
    parseExpressionStatement(d, l, f) {
      return d.expression = l, this.semicolon(), this.finishNode(d, "ExpressionStatement");
    }
    parseBlock(d = !1, l = !0, f) {
      let y = this.startNode();
      return d && this.state.strictErrors.clear(), this.expect(5), l && this.scope.enter(0), this.parseBlockBody(y, d, !1, 8, f), l && this.scope.exit(), this.finishNode(y, "BlockStatement");
    }
    isValidDirective(d) {
      return d.type === "ExpressionStatement" && d.expression.type === "StringLiteral" && !d.expression.extra.parenthesized;
    }
    parseBlockBody(d, l, f, y, v) {
      let E = d.body = [], k = d.directives = [];
      this.parseBlockOrModuleBlockBody(E, l ? k : void 0, f, y, v);
    }
    parseBlockOrModuleBlockBody(d, l, f, y, v) {
      let E = this.state.strict, k = !1, F = !1;
      for (; !this.match(y); ) {
        let N = f ? this.parseModuleItem() : this.parseStatementListItem();
        if (l && !F) {
          if (this.isValidDirective(N)) {
            let I = this.stmtToDirective(N);
            l.push(I), !k && I.value.value === "use strict" && (k = !0, this.setStrict(!0));
            continue;
          }
          F = !0, this.state.strictErrors.clear();
        }
        d.push(N);
      }
      v == null || v.call(this, k), E || this.setStrict(!1), this.next();
    }
    parseFor(d, l) {
      return d.init = l, this.semicolon(!1), d.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), d.update = this.match(11) ? null : this.parseExpression(), this.expect(11), d.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(d, "ForStatement");
    }
    parseForIn(d, l, f) {
      let y = this.match(58);
      return this.next(), y ? f !== null && this.unexpected(f) : d.await = f !== null, l.type === "VariableDeclaration" && l.declarations[0].init != null && (!y || !this.options.annexB || this.state.strict || l.kind !== "var" || l.declarations[0].id.type !== "Identifier") && this.raise(x.ForInOfLoopInitializer, l, { type: y ? "ForInStatement" : "ForOfStatement" }), l.type === "AssignmentPattern" && this.raise(x.InvalidLhs, l, { ancestor: { type: "ForStatement" } }), d.left = l, d.right = y ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), d.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(d, y ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(d, l, f, y = !1) {
      let v = d.declarations = [];
      for (d.kind = f; ; ) {
        let E = this.startNode();
        if (this.parseVarId(E, f), E.init = this.eat(29) ? l ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, E.init === null && !y && (E.id.type !== "Identifier" && !(l && (this.match(58) || this.isContextual(102))) ? this.raise(x.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" }) : f === "const" && !(this.match(58) || this.isContextual(102)) && this.raise(x.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "const" })), v.push(this.finishNode(E, "VariableDeclarator")), !this.eat(12))
          break;
      }
      return d;
    }
    parseVarId(d, l) {
      let f = this.parseBindingAtom();
      this.checkLVal(f, { in: { type: "VariableDeclarator" }, binding: l === "var" ? 5 : 8201 }), d.id = f;
    }
    parseAsyncFunctionExpression(d) {
      return this.parseFunction(d, 8);
    }
    parseFunction(d, l = 0) {
      let f = l & 2, y = !!(l & 1), v = y && !(l & 4), E = !!(l & 8);
      this.initFunction(d, E), this.match(55) && (f && this.raise(x.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), d.generator = !0), y && (d.id = this.parseFunctionId(v));
      let k = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(ec(E, d.generator)), y || (d.id = this.parseFunctionId()), this.parseFunctionParams(d, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(d, y ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), y && !f && this.registerFunctionStatementId(d), this.state.maybeInArrowParameters = k, d;
    }
    parseFunctionId(d) {
      return d || j(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(d, l) {
      this.expect(10), this.expressionScope.enter(CP()), d.params = this.parseBindingList(11, 41, 2 | (l ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(d) {
      d.id && this.scope.declareName(d.id.name, !this.options.annexB || this.state.strict || d.generator || d.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, d.id.loc.start);
    }
    parseClass(d, l, f) {
      this.next();
      let y = this.state.strict;
      return this.state.strict = !0, this.parseClassId(d, l, f), this.parseClassSuper(d), d.body = this.parseClassBody(!!d.superClass, y), this.finishNode(d, l ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    isNonstaticConstructor(d) {
      return !d.computed && !d.static && (d.key.name === "constructor" || d.key.value === "constructor");
    }
    parseClassBody(d, l) {
      this.classScope.enter();
      let f = { hadConstructor: !1, hadSuperClass: d }, y = [], v = this.startNode();
      if (v.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (y.length > 0)
              throw this.raise(x.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            y.push(this.parseDecorator());
            continue;
          }
          let E = this.startNode();
          y.length && (E.decorators = y, this.resetStartLocationFromNode(E, y[0]), y = []), this.parseClassMember(v, E, f), E.kind === "constructor" && E.decorators && E.decorators.length > 0 && this.raise(x.DecoratorConstructor, E);
        }
      }), this.state.strict = l, this.next(), y.length)
        throw this.raise(x.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(v, "ClassBody");
    }
    parseClassMemberFromModifier(d, l) {
      let f = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let y = l;
        return y.kind = "method", y.computed = !1, y.key = f, y.static = !1, this.pushClassMethod(d, y, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let y = l;
        return y.computed = !1, y.key = f, y.static = !1, d.body.push(this.parseClassProperty(y)), !0;
      }
      return this.resetPreviousNodeTrailingComments(f), !1;
    }
    parseClassMember(d, l, f) {
      let y = this.isContextual(106);
      if (y) {
        if (this.parseClassMemberFromModifier(d, l))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(d, l);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(d, l, f, y);
    }
    parseClassMemberWithIsStatic(d, l, f, y) {
      let v = l, E = l, k = l, F = l, N = l, I = v, U = v;
      if (l.static = y, this.parsePropertyNamePrefixOperator(l), this.eat(55)) {
        I.kind = "method";
        let Ge = this.match(138);
        if (this.parseClassElementName(I), Ge) {
          this.pushClassPrivateMethod(d, E, !0, !1);
          return;
        }
        this.isNonstaticConstructor(v) && this.raise(x.ConstructorIsGenerator, v.key), this.pushClassMethod(d, v, !0, !1, !1, !1);
        return;
      }
      let ne = j(this.state.type) && !this.state.containsEsc, he = this.match(138), ce = this.parseClassElementName(l), He = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(U), this.isClassMethod()) {
        if (I.kind = "method", he) {
          this.pushClassPrivateMethod(d, E, !1, !1);
          return;
        }
        let Ge = this.isNonstaticConstructor(v), Pt = !1;
        Ge && (v.kind = "constructor", f.hadConstructor && !this.hasPlugin("typescript") && this.raise(x.DuplicateConstructor, ce), Ge && this.hasPlugin("typescript") && l.override && this.raise(x.OverrideOnConstructor, ce), f.hadConstructor = !0, Pt = f.hadSuperClass), this.pushClassMethod(d, v, !1, !1, Ge, Pt);
      } else if (this.isClassProperty())
        he ? this.pushClassPrivateProperty(d, F) : this.pushClassProperty(d, k);
      else if (ne && ce.name === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(ce);
        let Ge = this.eat(55);
        U.optional && this.unexpected(He), I.kind = "method";
        let Pt = this.match(138);
        this.parseClassElementName(I), this.parsePostMemberNameModifiers(U), Pt ? this.pushClassPrivateMethod(d, E, Ge, !0) : (this.isNonstaticConstructor(v) && this.raise(x.ConstructorIsAsync, v.key), this.pushClassMethod(d, v, Ge, !0, !1, !1));
      } else if (ne && (ce.name === "get" || ce.name === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(ce), I.kind = ce.name;
        let Ge = this.match(138);
        this.parseClassElementName(v), Ge ? this.pushClassPrivateMethod(d, E, !1, !1) : (this.isNonstaticConstructor(v) && this.raise(x.ConstructorIsAccessor, v.key), this.pushClassMethod(d, v, !1, !1, !1, !1)), this.checkGetterSetterParams(v);
      } else if (ne && ce.name === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(ce);
        let Ge = this.match(138);
        this.parseClassElementName(k), this.pushClassAccessorProperty(d, N, Ge);
      } else
        this.isLineTerminator() ? he ? this.pushClassPrivateProperty(d, F) : this.pushClassProperty(d, k) : this.unexpected();
    }
    parseClassElementName(d) {
      let { type: l, value: f } = this.state;
      if ((l === 132 || l === 133) && d.static && f === "prototype" && this.raise(x.StaticPrototype, this.state.startLoc), l === 138) {
        f === "constructor" && this.raise(x.ConstructorClassPrivateField, this.state.startLoc);
        let y = this.parsePrivateName();
        return d.key = y, y;
      }
      return this.parsePropertyName(d);
    }
    parseClassStaticBlock(d, l) {
      var f;
      this.scope.enter(208);
      let y = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let v = l.body = [];
      this.parseBlockOrModuleBlockBody(v, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = y, d.body.push(this.finishNode(l, "StaticBlock")), (f = l.decorators) != null && f.length && this.raise(x.DecoratorStaticBlock, l);
    }
    pushClassProperty(d, l) {
      !l.computed && (l.key.name === "constructor" || l.key.value === "constructor") && this.raise(x.ConstructorClassField, l.key), d.body.push(this.parseClassProperty(l));
    }
    pushClassPrivateProperty(d, l) {
      let f = this.parseClassPrivateProperty(l);
      d.body.push(f), this.classScope.declarePrivateName(this.getPrivateNameSV(f.key), 0, f.key.loc.start);
    }
    pushClassAccessorProperty(d, l, f) {
      if (!f && !l.computed) {
        let v = l.key;
        (v.name === "constructor" || v.value === "constructor") && this.raise(x.ConstructorClassField, v);
      }
      let y = this.parseClassAccessorProperty(l);
      d.body.push(y), f && this.classScope.declarePrivateName(this.getPrivateNameSV(y.key), 0, y.key.loc.start);
    }
    pushClassMethod(d, l, f, y, v, E) {
      d.body.push(this.parseMethod(l, f, y, v, E, "ClassMethod", !0));
    }
    pushClassPrivateMethod(d, l, f, y) {
      let v = this.parseMethod(l, f, y, !1, !1, "ClassPrivateMethod", !0);
      d.body.push(v);
      let E = v.kind === "get" ? v.static ? 6 : 2 : v.kind === "set" ? v.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(v, E);
    }
    declareClassPrivateMethodInScope(d, l) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(d.key), l, d.key.loc.start);
    }
    parsePostMemberNameModifiers(d) {
    }
    parseClassPrivateProperty(d) {
      return this.parseInitializer(d), this.semicolon(), this.finishNode(d, "ClassPrivateProperty");
    }
    parseClassProperty(d) {
      return this.parseInitializer(d), this.semicolon(), this.finishNode(d, "ClassProperty");
    }
    parseClassAccessorProperty(d) {
      return this.parseInitializer(d), this.semicolon(), this.finishNode(d, "ClassAccessorProperty");
    }
    parseInitializer(d) {
      this.scope.enter(80), this.expressionScope.enter(lO()), this.prodParam.enter(0), d.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(d, l, f, y = 8331) {
      if (j(this.state.type))
        d.id = this.parseIdentifier(), l && this.declareNameFromIdentifier(d.id, y);
      else if (f || !l)
        d.id = null;
      else
        throw this.raise(x.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(d) {
      d.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(d, l) {
      let f = this.parseMaybeImportPhase(d, !0), y = this.maybeParseExportDefaultSpecifier(d, f), v = !y || this.eat(12), E = v && this.eatExportStar(d), k = E && this.maybeParseExportNamespaceSpecifier(d), F = v && (!k || this.eat(12)), N = y || E;
      if (E && !k) {
        if (y && this.unexpected(), l)
          throw this.raise(x.UnsupportedDecoratorExport, d);
        return this.parseExportFrom(d, !0), this.finishNode(d, "ExportAllDeclaration");
      }
      let I = this.maybeParseExportNamedSpecifiers(d);
      y && v && !E && !I && this.unexpected(null, 5), k && F && this.unexpected(null, 98);
      let U;
      if (N || I) {
        if (U = !1, l)
          throw this.raise(x.UnsupportedDecoratorExport, d);
        this.parseExportFrom(d, N);
      } else
        U = this.maybeParseExportDeclaration(d);
      if (N || I || U) {
        var ne;
        let he = d;
        if (this.checkExport(he, !0, !1, !!he.source), ((ne = he.declaration) == null ? void 0 : ne.type) === "ClassDeclaration")
          this.maybeTakeDecorators(l, he.declaration, he);
        else if (l)
          throw this.raise(x.UnsupportedDecoratorExport, d);
        return this.finishNode(he, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let he = d, ce = this.parseExportDefaultExpression();
        if (he.declaration = ce, ce.type === "ClassDeclaration")
          this.maybeTakeDecorators(l, ce, he);
        else if (l)
          throw this.raise(x.UnsupportedDecoratorExport, d);
        return this.checkExport(he, !0, !0), this.finishNode(he, "ExportDefaultDeclaration");
      }
      this.unexpected(null, 5);
    }
    eatExportStar(d) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(d, l) {
      if (l || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", l == null ? void 0 : l.loc.start);
        let f = l || this.parseIdentifier(!0), y = this.startNodeAtNode(f);
        return y.exported = f, d.specifiers = [this.finishNode(y, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(d) {
      if (this.isContextual(93)) {
        d.specifiers || (d.specifiers = []);
        let l = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), l.exported = this.parseModuleExportName(), d.specifiers.push(this.finishNode(l, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(d) {
      if (this.match(5)) {
        d.specifiers || (d.specifiers = []);
        let l = d.exportKind === "type";
        return d.specifiers.push(...this.parseExportSpecifiers(l)), d.source = null, d.declaration = null, this.hasPlugin("importAssertions") && (d.assertions = []), !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(d) {
      return this.shouldParseExportDeclaration() ? (d.specifiers = [], d.source = null, this.hasPlugin("importAssertions") && (d.assertions = []), d.declaration = this.parseExportDeclaration(d), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95))
        return !1;
      let d = this.nextTokenInLineStart();
      return this.isUnparsedContextual(d, "function");
    }
    parseExportDefaultExpression() {
      let d = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(d, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(d, 13);
      if (this.match(80))
        return this.parseClass(d, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(x.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet())
        throw this.raise(x.UnsupportedDefaultExport, this.state.startLoc);
      let l = this.parseMaybeAssignAllowIn();
      return this.semicolon(), l;
    }
    parseExportDeclaration(d) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let { type: d } = this.state;
      if (j(d)) {
        if (d === 95 && !this.state.containsEsc || d === 100)
          return !1;
        if ((d === 130 || d === 129) && !this.state.containsEsc) {
          let { type: y } = this.lookahead();
          if (j(y) && y !== 98 || y === 5)
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let l = this.nextTokenStart(), f = this.isUnparsedContextual(l, "from");
      if (this.input.charCodeAt(l) === 44 || j(this.state.type) && f)
        return !0;
      if (this.match(65) && f) {
        let y = this.input.charCodeAt(this.nextTokenStartSince(l + 4));
        return y === 34 || y === 39;
      }
      return !1;
    }
    parseExportFrom(d, l) {
      this.eatContextual(98) ? (d.source = this.parseImportSource(), this.checkExport(d), this.maybeParseImportAttributes(d), this.checkJSONModuleImport(d)) : l && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let { type: d } = this.state;
      return d === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(x.DecoratorBeforeExport, this.state.startLoc), !0) : d === 74 || d === 75 || d === 68 || d === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(d, l, f, y) {
      if (l) {
        var v;
        if (f) {
          if (this.checkDuplicateExports(d, "default"), this.hasPlugin("exportDefaultFrom")) {
            var E;
            let k = d.declaration;
            k.type === "Identifier" && k.name === "from" && k.end - k.start === 4 && !((E = k.extra) != null && E.parenthesized) && this.raise(x.ExportDefaultFromAsIdentifier, k);
          }
        } else if ((v = d.specifiers) != null && v.length)
          for (let k of d.specifiers) {
            let { exported: F } = k, N = F.type === "Identifier" ? F.name : F.value;
            if (this.checkDuplicateExports(k, N), !y && k.local) {
              let { local: I } = k;
              I.type !== "Identifier" ? this.raise(x.ExportBindingIsString, k, { localName: I.value, exportName: N }) : (this.checkReservedWord(I.name, I.loc.start, !0, !1), this.scope.checkLocalExport(I));
            }
          }
        else if (d.declaration) {
          if (d.declaration.type === "FunctionDeclaration" || d.declaration.type === "ClassDeclaration") {
            let k = d.declaration.id;
            if (!k)
              throw new Error("Assertion failure");
            this.checkDuplicateExports(d, k.name);
          } else if (d.declaration.type === "VariableDeclaration")
            for (let k of d.declaration.declarations)
              this.checkDeclaration(k.id);
        }
      }
    }
    checkDeclaration(d) {
      if (d.type === "Identifier")
        this.checkDuplicateExports(d, d.name);
      else if (d.type === "ObjectPattern")
        for (let l of d.properties)
          this.checkDeclaration(l);
      else if (d.type === "ArrayPattern")
        for (let l of d.elements)
          l && this.checkDeclaration(l);
      else
        d.type === "ObjectProperty" ? this.checkDeclaration(d.value) : d.type === "RestElement" ? this.checkDeclaration(d.argument) : d.type === "AssignmentPattern" && this.checkDeclaration(d.left);
    }
    checkDuplicateExports(d, l) {
      this.exportedIdentifiers.has(l) && (l === "default" ? this.raise(x.DuplicateDefaultExport, d) : this.raise(x.DuplicateExport, d, { exportName: l })), this.exportedIdentifiers.add(l);
    }
    parseExportSpecifiers(d) {
      let l = [], f = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (f)
          f = !1;
        else if (this.expect(12), this.eat(8))
          break;
        let y = this.isContextual(130), v = this.match(133), E = this.startNode();
        E.local = this.parseModuleExportName(), l.push(this.parseExportSpecifier(E, v, d, y));
      }
      return l;
    }
    parseExportSpecifier(d, l, f, y) {
      return this.eatContextual(93) ? d.exported = this.parseModuleExportName() : l ? d.exported = FP(d.local) : d.exported || (d.exported = xi(d.local)), this.finishNode(d, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(133)) {
        let d = this.parseStringLiteral(this.state.value), l = d.value.match(sF);
        return l && this.raise(x.ModuleExportNameHasLoneSurrogate, d, { surrogateCharCode: l[0].charCodeAt(0) }), d;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(d) {
      return d.assertions != null ? d.assertions.some(({ key: l, value: f }) => f.value === "json" && (l.type === "Identifier" ? l.name === "type" : l.value === "type")) : !1;
    }
    checkImportReflection(d) {
      let { specifiers: l } = d, f = l.length === 1 ? l[0].type : null;
      if (d.phase === "source")
        f !== "ImportDefaultSpecifier" && this.raise(x.SourcePhaseImportRequiresDefault, l[0].loc.start);
      else if (d.phase === "defer")
        f !== "ImportNamespaceSpecifier" && this.raise(x.DeferImportRequiresNamespace, l[0].loc.start);
      else if (d.module) {
        var y;
        f !== "ImportDefaultSpecifier" && this.raise(x.ImportReflectionNotBinding, l[0].loc.start), ((y = d.assertions) == null ? void 0 : y.length) > 0 && this.raise(x.ImportReflectionHasAssertion, l[0].loc.start);
      }
    }
    checkJSONModuleImport(d) {
      if (this.isJSONModuleImport(d) && d.type !== "ExportAllDeclaration") {
        let { specifiers: l } = d;
        if (l != null) {
          let f = l.find((y) => {
            let v;
            if (y.type === "ExportSpecifier" ? v = y.local : y.type === "ImportSpecifier" && (v = y.imported), v !== void 0)
              return v.type === "Identifier" ? v.name !== "default" : v.value !== "default";
          });
          f !== void 0 && this.raise(x.ImportJSONBindingNotDefault, f.loc.start);
        }
      }
    }
    isPotentialImportPhase(d) {
      return d ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(d, l, f, y) {
      l || (f === "module" ? (this.expectPlugin("importReflection", y), d.module = !0) : this.hasPlugin("importReflection") && (d.module = !1), f === "source" ? (this.expectPlugin("sourcePhaseImports", y), d.phase = "source") : f === "defer" ? (this.expectPlugin("deferredImportEvaluation", y), d.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (d.phase = null));
    }
    parseMaybeImportPhase(d, l) {
      if (!this.isPotentialImportPhase(l))
        return this.applyImportPhase(d, l, null), null;
      let f = this.parseIdentifier(!0), { type: y } = this.state;
      return (De(y) ? y !== 98 || this.lookaheadCharCode() === 102 : y !== 12) ? (this.resetPreviousIdentifierLeadingComments(f), this.applyImportPhase(d, l, f.name, f.loc.start), null) : (this.applyImportPhase(d, l, null), f);
    }
    isPrecedingIdImportPhase(d) {
      let { type: l } = this.state;
      return j(l) ? l !== 98 || this.lookaheadCharCode() === 102 : l !== 12;
    }
    parseImport(d) {
      return this.match(133) ? this.parseImportSourceAndAttributes(d) : this.parseImportSpecifiersAndAfter(d, this.parseMaybeImportPhase(d, !1));
    }
    parseImportSpecifiersAndAfter(d, l) {
      d.specifiers = [];
      let f = !this.maybeParseDefaultImportSpecifier(d, l) || this.eat(12), y = f && this.maybeParseStarImportSpecifier(d);
      return f && !y && this.parseNamedImportSpecifiers(d), this.expectContextual(98), this.parseImportSourceAndAttributes(d);
    }
    parseImportSourceAndAttributes(d) {
      return d.specifiers != null || (d.specifiers = []), d.source = this.parseImportSource(), this.maybeParseImportAttributes(d), this.checkImportReflection(d), this.checkJSONModuleImport(d), this.semicolon(), this.finishNode(d, "ImportDeclaration");
    }
    parseImportSource() {
      return this.match(133) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(d, l, f) {
      l.local = this.parseIdentifier(), d.specifiers.push(this.finishImportSpecifier(l, f));
    }
    finishImportSpecifier(d, l, f = 8201) {
      return this.checkLVal(d.local, { in: { type: l }, binding: f }), this.finishNode(d, l);
    }
    parseImportAttributes() {
      this.expect(5);
      let d = [], l = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let f = this.startNode(), y = this.state.value;
        if (l.has(y) && this.raise(x.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: y }), l.add(y), this.match(133) ? f.key = this.parseStringLiteral(y) : f.key = this.parseIdentifier(!0), this.expect(14), !this.match(133))
          throw this.raise(x.ModuleAttributeInvalidValue, this.state.startLoc);
        f.value = this.parseStringLiteral(this.state.value), d.push(this.finishNode(f, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), d;
    }
    parseModuleAttributes() {
      let d = [], l = /* @__PURE__ */ new Set();
      do {
        let f = this.startNode();
        if (f.key = this.parseIdentifier(!0), f.key.name !== "type" && this.raise(x.ModuleAttributeDifferentFromType, f.key), l.has(f.key.name) && this.raise(x.ModuleAttributesWithDuplicateKeys, f.key, { key: f.key.name }), l.add(f.key.name), this.expect(14), !this.match(133))
          throw this.raise(x.ModuleAttributeInvalidValue, this.state.startLoc);
        f.value = this.parseStringLiteral(this.state.value), d.push(this.finishNode(f, "ImportAttribute"));
      } while (this.eat(12));
      return d;
    }
    maybeParseImportAttributes(d) {
      let l, f = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? l = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), l = this.parseImportAttributes()), f = !0;
      } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
        this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(x.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(d, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), l = this.parseImportAttributes();
      else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
        l = [];
      else if (this.hasPlugin("moduleAttributes"))
        l = [];
      else
        return;
      !f && this.hasPlugin("importAssertions") ? d.assertions = l : d.attributes = l;
    }
    maybeParseDefaultImportSpecifier(d, l) {
      if (l) {
        let f = this.startNodeAtNode(l);
        return f.local = l, d.specifiers.push(this.finishImportSpecifier(f, "ImportDefaultSpecifier")), !0;
      } else if (De(this.state.type))
        return this.parseImportSpecifierLocal(d, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(d) {
      if (this.match(55)) {
        let l = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(d, l, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(d) {
      let l = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (l)
          l = !1;
        else {
          if (this.eat(14))
            throw this.raise(x.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8))
            break;
        }
        let f = this.startNode(), y = this.match(133), v = this.isContextual(130);
        f.imported = this.parseModuleExportName();
        let E = this.parseImportSpecifier(f, y, d.importKind === "type" || d.importKind === "typeof", v, void 0);
        d.specifiers.push(E);
      }
    }
    parseImportSpecifier(d, l, f, y, v) {
      if (this.eatContextual(93))
        d.local = this.parseIdentifier();
      else {
        let { imported: E } = d;
        if (l)
          throw this.raise(x.ImportBindingIsString, d, { importName: E.value });
        this.checkReservedWord(E.name, d.loc.start, !0, !0), d.local || (d.local = xi(E));
      }
      return this.finishImportSpecifier(d, "ImportSpecifier", v);
    }
    isThisParam(d) {
      return d.type === "Identifier" && d.name === "this";
    }
  }, bO = class extends oF {
    constructor(d, l) {
      d = rF(d), super(d, l), this.options = d, this.initializeScopes(), this.plugins = lF(this.options.plugins), this.filename = d.sourceFilename;
    }
    getScopeHandler() {
      return yi;
    }
    parse() {
      this.enterInitialScopes();
      let d = this.startNode(), l = this.startNode();
      return this.nextToken(), d.errors = null, this.parseTopLevel(d, l), d.errors = this.state.errors, d.comments.length = this.state.commentsLen, d;
    }
  };
  function lF(d) {
    let l = /* @__PURE__ */ new Map();
    for (let f of d) {
      let [y, v] = Array.isArray(f) ? f : [f, {}];
      l.has(y) || l.set(y, v || {});
    }
    return l;
  }
  function uF(d, l) {
    var f;
    if (((f = l) == null ? void 0 : f.sourceType) === "unambiguous") {
      l = Object.assign({}, l);
      try {
        l.sourceType = "module";
        let y = qo(l, d), v = y.parse();
        if (y.sawUnambiguousESM)
          return v;
        if (y.ambiguousScriptDifferentAst)
          try {
            return l.sourceType = "script", qo(l, d).parse();
          } catch {
          }
        else
          v.program.sourceType = "script";
        return v;
      } catch (y) {
        try {
          return l.sourceType = "script", qo(l, d).parse();
        } catch {
        }
        throw y;
      }
    } else
      return qo(l, d).parse();
  }
  function cF(d, l) {
    let f = qo(l, d);
    return f.options.strictMode && (f.state.strict = !0), f.getExpression();
  }
  function hF(d) {
    let l = {};
    for (let f of Object.keys(d))
      l[f] = Nt(d[f]);
    return l;
  }
  var pF = hF(W);
  function qo(d, l) {
    let f = bO;
    return d != null && d.plugins && (eF(d.plugins), f = dF(d.plugins)), new f(d, l);
  }
  var DO = {};
  function dF(d) {
    let l = tF.filter((v) => Et(d, v)), f = l.join("/"), y = DO[f];
    if (!y) {
      y = bO;
      for (let v of l)
        y = xO[v](y);
      DO[f] = y;
    }
    return y;
  }
  t.parse = uF, t.parseExpression = cF, t.tokTypes = pF;
}), Dj = WC((t) => {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = h, t.parse = m, t.parseWithComments = g, t.print = O, t.strip = p;
  var e = /\*\/$/, r = /^\/\*\*?/, n = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, s = /^(\r?\n)+/, a = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, o = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, u = /(\r?\n|^) *\* ?/g, c = [];
  function h(D) {
    let S = D.match(n);
    return S ? S[0].trimLeft() : "";
  }
  function p(D) {
    let S = D.match(n);
    return S && S[0] ? D.substring(S[0].length) : D;
  }
  function m(D) {
    return g(D).pragmas;
  }
  function g(D) {
    let S = `
`;
    D = D.replace(r, "").replace(e, "").replace(u, "$1");
    let x = "";
    for (; x !== D; )
      x = D, D = D.replace(a, `${S}$1 $2${S}`);
    D = D.replace(s, "").trimRight();
    let w = /* @__PURE__ */ Object.create(null), T = D.replace(o, "").replace(s, "").trimRight(), C;
    for (; C = o.exec(D); ) {
      let A = C[2].replace(i, "");
      typeof w[C[1]] == "string" || Array.isArray(w[C[1]]) ? w[C[1]] = c.concat(w[C[1]], A) : w[C[1]] = A;
    }
    return { comments: T, pragmas: w };
  }
  function O({ comments: D = "", pragmas: S = {} }) {
    let x = `
`, w = "/**", T = " *", C = " */", A = Object.keys(S), P = A.flatMap((B) => b(B, S[B])).map((B) => `${T} ${B}${x}`).join("");
    if (!D) {
      if (A.length === 0)
        return "";
      if (A.length === 1 && !Array.isArray(S[A[0]])) {
        let B = S[A[0]];
        return `${w} ${b(A[0], B)[0]}${C}`;
      }
    }
    let $ = D.split(x).map((B) => `${T} ${B}`).join(x) + x;
    return w + x + (D ? $ : "") + (D && A.length ? T + x : "") + P + C;
  }
  function b(D, S) {
    return c.concat(S).map((x) => `@${D} ${x}`.trim());
  }
}), VC = {};
xj(VC, { parsers: () => OZ });
var J1 = o0(qC(), 1);
function YC(t) {
  return (e, r, n) => {
    let i = !!(n != null && n.backwards);
    if (r === !1)
      return !1;
    let { length: s } = e, a = r;
    for (; a >= 0 && a < s; ) {
      let o = e.charAt(a);
      if (t instanceof RegExp) {
        if (!t.test(o))
          return a;
      } else if (!t.includes(o))
        return a;
      i ? a-- : a++;
    }
    return a === -1 || a === s ? a : !1;
  };
}
var vj = YC(" 	"), Sj = YC(/[^\n\r]/);
function wj(t, e) {
  if (e === !1)
    return !1;
  if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
    for (let r = e + 2; r < t.length; ++r)
      if (t.charAt(r) === "*" && t.charAt(r + 1) === "/")
        return r + 2;
  }
  return e;
}
var Cj = wj;
function Ej(t, e, r) {
  let n = !!(r != null && r.backwards);
  if (e === !1)
    return !1;
  let i = t.charAt(e);
  if (n) {
    if (t.charAt(e - 1) === "\r" && i === `
`)
      return e - 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e - 1;
  } else {
    if (i === "\r" && t.charAt(e + 1) === `
`)
      return e + 2;
    if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
      return e + 1;
  }
  return e;
}
var Aj = Ej;
function Tj(t, e) {
  return e === !1 ? !1 : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? Sj(t, e) : e;
}
var kj = Tj;
function Pj(t, e) {
  let r = null, n = e;
  for (; n !== r; )
    r = n, n = vj(t, n), n = Cj(t, n), n = kj(t, n), n = Aj(t, n);
  return n;
}
var Fj = Pj;
function $j(t) {
  let e = [];
  for (let r of t)
    try {
      return r();
    } catch (n) {
      e.push(n);
    }
  throw Object.assign(new Error("All combinations failed"), { errors: e });
}
var Bj = $j;
function Ij(t) {
  if (!t.startsWith("#!"))
    return "";
  let e = t.indexOf(`
`);
  return e === -1 ? t : t.slice(0, e);
}
var UC = Ij, Nj = (t, e, r) => {
  if (!(t && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, K1 = Nj;
function _j(t) {
  return Array.isArray(t) && t.length > 0;
}
var l0 = _j;
function Tn(t) {
  var e, r, n;
  let i = ((e = t.range) == null ? void 0 : e[0]) ?? t.start, s = (n = ((r = t.declaration) == null ? void 0 : r.decorators) ?? t.decorators) == null ? void 0 : n[0];
  return s ? Math.min(Tn(s), i) : i;
}
function ts(t) {
  var e;
  return ((e = t.range) == null ? void 0 : e[1]) ?? t.end;
}
function Qj(t) {
  let e = new Set(t);
  return (r) => e.has(r == null ? void 0 : r.type);
}
var Mj = Qj, Lj = Mj(["Block", "CommentBlock", "MultiLine"]), vm = Lj;
function Rj(t) {
  let e = `*${t.value}*`.split(`
`);
  return e.length > 1 && e.every((r) => r.trimStart()[0] === "*");
}
var ex = Rj;
function jj(t) {
  return vm(t) && t.value[0] === "*" && /@(?:type|satisfies)\b/.test(t.value);
}
var Zj = jj, el = null;
function kl(t) {
  if (el !== null && typeof el.property) {
    let e = el;
    return el = kl.prototype = null, e;
  }
  return el = kl.prototype = t ?? /* @__PURE__ */ Object.create(null), new kl();
}
var Wj = 10;
for (let t = 0; t <= Wj; t++)
  kl();
function qj(t) {
  return kl(t);
}
function Xj(t, e = "type") {
  qj(t);
  function r(n) {
    let i = n[e], s = t[i];
    if (!Array.isArray(s))
      throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: n });
    return s;
  }
  return r;
}
var Vj = Xj, Yj = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value", "optional", "static", "method"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareEnum: ["id", "body"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], AsConstExpression: ["expression"], SatisfiesExpression: ["expression", "typeAnnotation"] }, Uj = Vj(Yj), zj = Uj;
function Sm(t, e) {
  if (!(t !== null && typeof t == "object"))
    return t;
  if (Array.isArray(t)) {
    for (let n = 0; n < t.length; n++)
      t[n] = Sm(t[n], e);
    return t;
  }
  let r = zj(t);
  for (let n = 0; n < r.length; n++)
    t[r[n]] = Sm(t[r[n]], e);
  return e(t) || t;
}
var Jd = Sm;
function Gj(t, e) {
  let { parser: r, text: n } = e;
  if (t.type === "File" && t.program.interpreter) {
    let { program: { interpreter: i }, comments: s } = t;
    delete t.program.interpreter, s.unshift(i);
  }
  if (r === "babel") {
    let i = /* @__PURE__ */ new Set();
    t = Jd(t, (s) => {
      var a;
      (a = s.leadingComments) != null && a.some(Zj) && i.add(Tn(s));
    }), t = Jd(t, (s) => {
      if (s.type === "ParenthesizedExpression") {
        let { expression: a } = s;
        if (a.type === "TypeCastExpression")
          return a.range = [...s.range], a;
        let o = Tn(s);
        if (!i.has(o))
          return a.extra = { ...a.extra, parenthesized: !0 }, a;
      }
    });
  }
  if (t = Jd(t, (i) => {
    var s;
    switch (i.type) {
      case "LogicalExpression":
        if (zC(i))
          return wm(i);
        break;
      case "VariableDeclaration": {
        let a = K1(!1, i.declarations, -1);
        a != null && a.init && n[ts(a)] !== ";" && (i.range = [Tn(i), ts(a)]);
        break;
      }
      case "TSParenthesizedType":
        return i.typeAnnotation;
      case "TSTypeParameter":
        if (typeof i.name == "string") {
          let a = Tn(i);
          i.name = { type: "Identifier", name: i.name, range: [a, a + i.name.length] };
        }
        break;
      case "TopicReference":
        t.extra = { ...t.extra, __isUsingHackPipeline: !0 };
        break;
      case "ExportAllDeclaration":
        if (r === "meriyah" && ((s = i.exported) == null ? void 0 : s.type) === "Identifier") {
          let { exported: a } = i, o = n.slice(Tn(a), ts(a));
          (o.startsWith('"') || o.startsWith("'")) && (i.exported = { ...i.exported, type: "Literal", value: i.exported.name, raw: o });
        }
        break;
      case "TSUnionType":
      case "TSIntersectionType":
        if (i.types.length === 1)
          return i.types[0];
        break;
    }
  }), l0(t.comments)) {
    let i = K1(!1, t.comments, -1);
    for (let s = t.comments.length - 2; s >= 0; s--) {
      let a = t.comments[s];
      ts(a) === Tn(i) && vm(a) && vm(i) && ex(a) && ex(i) && (t.comments.splice(s + 1, 1), a.value += "*//*" + i.value, a.range = [Tn(a), ts(i)]), i = a;
    }
  }
  return t.type === "Program" && (t.range = [0, n.length]), t;
}
function zC(t) {
  return t.type === "LogicalExpression" && t.right.type === "LogicalExpression" && t.operator === t.right.operator;
}
function wm(t) {
  return zC(t) ? wm({ type: "LogicalExpression", operator: t.operator, left: wm({ type: "LogicalExpression", operator: t.operator, left: t.left, right: t.right.left, range: [Tn(t.left), ts(t.right.left)] }), right: t.right.right, range: [Tn(t), ts(t)] }) : t;
}
var Hj = Gj;
function Jj(t, e) {
  let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
var GC = Jj;
function Kj(t) {
  let { message: e, loc: { line: r, column: n }, reasonCode: i } = t, s = t;
  (i === "MissingPlugin" || i === "MissingOneOfPlugins") && (e = "Unexpected token.", s = void 0);
  let a = ` (${r}:${n})`;
  return e.endsWith(a) && (e = e.slice(0, -a.length)), GC(e, { loc: { start: { line: r, column: n + 1 } }, cause: s });
}
var HC = Kj, tx = o0(Dj(), 1);
function eZ(t) {
  let e = UC(t);
  e && (t = t.slice(e.length + 1));
  let r = (0, tx.extract)(t), { pragmas: n, comments: i } = (0, tx.parseWithComments)(r);
  return { shebang: e, text: t, pragmas: n, comments: i };
}
function tZ(t) {
  let { pragmas: e } = eZ(t);
  return Object.prototype.hasOwnProperty.call(e, "prettier") || Object.prototype.hasOwnProperty.call(e, "format");
}
function rZ(t) {
  return t = typeof t == "function" ? { parse: t } : t, { astFormat: "estree", hasPragma: tZ, locStart: Tn, locEnd: ts, ...t };
}
var pl = rZ;
function nZ(t) {
  let { filepath: e } = t;
  if (e) {
    if (e = e.toLowerCase(), e.endsWith(".cjs"))
      return "script";
    if (e.endsWith(".mjs"))
      return "module";
  }
}
var iZ = nZ;
function sZ(t, e) {
  let { type: r = "JsExpressionRoot", rootMarker: n, text: i } = e, { tokens: s, comments: a } = t;
  return delete t.tokens, delete t.comments, { tokens: s, comments: a, type: r, node: t, range: [0, i.length], rootMarker: n };
}
var JC = sZ, Bo = (t) => pl(hZ(t)), aZ = { sourceType: "module", allowImportExportEverywhere: !0, allowReturnOutsideFunction: !0, allowNewTargetOutsideFunction: !0, allowSuperOutsideMethod: !0, allowUndeclaredExports: !0, errorRecovery: !0, createParenthesizedExpressions: !0, createImportExpressions: !0, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", "decorators", "decimal", "moduleBlocks", "asyncDoExpressions", "regexpUnicodeSets", "destructuringPrivate", "decoratorAutoAccessors", "importReflection", "explicitResourceManagement", ["importAttributes", { deprecatedAssertSyntax: !0 }], "sourcePhaseImports", "deferredImportEvaluation", ["optionalChainingAssign", { version: "2023-07" }]], tokens: !0, ranges: !0 }, oZ = ["recordAndTuple", { syntaxType: "hash" }], rx = "v8intrinsic", nx = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], ri = (t, e = aZ) => ({ ...e, plugins: [...e.plugins, ...t] }), lZ = /@(?:no)?flow\b/;
function uZ(t, e) {
  var r;
  if ((r = e.filepath) != null && r.endsWith(".js.flow"))
    return !0;
  let n = UC(t);
  n && (t = t.slice(n.length));
  let i = Fj(t, 0);
  return i !== !1 && (t = t.slice(0, i)), lZ.test(t);
}
function cZ(t, e, r) {
  let n = t(e, r), i = n.errors.find((s) => !pZ.has(s.reasonCode));
  if (i)
    throw i;
  return n;
}
function hZ({ isExpression: t = !1, optionsCombinations: e }) {
  return (r, n = {}) => {
    if ((n.parser === "babel" || n.parser === "__babel_estree") && uZ(r, n))
      return n.parser = "babel-flow", eE.parse(r, n);
    let i = e;
    (n.__babelSourceType ?? iZ(n)) === "script" && (i = i.map((u) => ({ ...u, sourceType: "script" }))), /#[[{]/.test(r) && (i = i.map((u) => ri([oZ], u)));
    let s = /%[A-Z]/.test(r);
    r.includes("|>") ? i = (s ? [...nx, rx] : nx).flatMap((u) => i.map((c) => ri([u], c))) : s && (i = i.map((u) => ri([rx], u)));
    let a = t ? J1.parseExpression : J1.parse, o;
    try {
      o = Bj(i.map((u) => () => cZ(a, r, u)));
    } catch ({ errors: [u] }) {
      throw HC(u);
    }
    return t && (o = JC(o, { text: r, rootMarker: n.rootMarker })), Hj(o, { parser: "babel", text: r });
  };
}
var pZ = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "DuplicateAccessibilityModifier", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), KC = [ri(["jsx"])], ix = Bo({ optionsCombinations: KC }), sx = Bo({ optionsCombinations: [ri(["jsx", "typescript"]), ri(["typescript"])] }), ax = Bo({ isExpression: !0, optionsCombinations: [ri(["jsx"])] }), ox = Bo({ isExpression: !0, optionsCombinations: [ri(["typescript"])] }), eE = Bo({ optionsCombinations: [ri(["jsx", ["flow", { all: !0, enums: !0 }], "flowComments"])] }), dZ = Bo({ optionsCombinations: KC.map((t) => ri(["estree"], t)) }), fZ = { babel: ix, "babel-flow": eE, "babel-ts": sx, __js_expression: ax, __ts_expression: ox, __vue_expression: ax, __vue_ts_expression: ox, __vue_event_binding: ix, __vue_ts_event_binding: sx, __babel_estree: dZ }, mZ = o0(qC(), 1);
function tE(t = {}) {
  let { allowComments: e = !0 } = t;
  return function(r) {
    let n;
    try {
      n = (0, mZ.parseExpression)(r, { tokens: !0, ranges: !0, attachComment: !1 });
    } catch (i) {
      throw HC(i);
    }
    if (!e && l0(n.comments))
      throw Hi(n.comments[0], "Comment");
    return Ma(n), JC(n, { type: "JsonRoot", text: r });
  };
}
function Hi(t, e) {
  let [r, n] = [t.loc.start, t.loc.end].map(({ line: i, column: s }) => ({ line: i, column: s + 1 }));
  return GC(`${e} is not allowed in JSON.`, { loc: { start: r, end: n } });
}
function Ma(t) {
  switch (t.type) {
    case "ArrayExpression":
      for (let e of t.elements)
        e !== null && Ma(e);
      return;
    case "ObjectExpression":
      for (let e of t.properties)
        Ma(e);
      return;
    case "ObjectProperty":
      if (t.computed)
        throw Hi(t.key, "Computed key");
      if (t.shorthand)
        throw Hi(t.key, "Shorthand property");
      t.key.type !== "Identifier" && Ma(t.key), Ma(t.value);
      return;
    case "UnaryExpression": {
      let { operator: e, argument: r } = t;
      if (e !== "+" && e !== "-")
        throw Hi(t, `Operator '${t.operator}'`);
      if (r.type === "NumericLiteral" || r.type === "Identifier" && (r.name === "Infinity" || r.name === "NaN"))
        return;
      throw Hi(r, `Operator '${e}' before '${r.type}'`);
    }
    case "Identifier":
      if (t.name !== "Infinity" && t.name !== "NaN" && t.name !== "undefined")
        throw Hi(t, `Identifier '${t.name}'`);
      return;
    case "TemplateLiteral":
      if (l0(t.expressions))
        throw Hi(t.expressions[0], "'TemplateLiteral' with expression");
      for (let e of t.quasis)
        Ma(e);
      return;
    case "NullLiteral":
    case "BooleanLiteral":
    case "NumericLiteral":
    case "StringLiteral":
    case "TemplateElement":
      return;
    default:
      throw Hi(t, `'${t.type}'`);
  }
}
var Kd = tE(), gZ = { json: pl({ parse: Kd, hasPragma() {
  return !0;
} }), json5: pl(Kd), jsonc: pl(Kd), "json-stringify": pl({ parse: tE({ allowComments: !1 }), astFormat: "estree-json" }) }, yZ = gZ, OZ = { ...fZ, ...yZ }, xZ = VC;
const bZ = async (t, e) => {
  if (!XD(e))
    return t;
  const r = e === "js" ? "babel" : e;
  return await RB.format(t, {
    parser: r,
    plugins: [O9, _5, dj, xZ],
    tabWidth: 2,
    htmlWhitespaceSensitivity: "ignore"
  });
}, rE = (t, e = { mustBeOpen: !0 }) => Object.values(t).filter((r) => !e.mustBeOpen || r.open && e.mustBeOpen).sort((r, n) => r.name.localeCompare(n.name)), st = {
  REPLACE_PROJECT: "REPLACE_PROJECT",
  NEW_FILE: "NEW_FILE",
  RENAME_FILE: "RENAME_FILE",
  SAVE_FILE: "SAVE_FILE",
  OPEN_FILE: "OPEN_FILE",
  ACTIVATE_FILE: "ACTIVATE_FILE",
  MOVE_FILE: "MOVE_FILE",
  CLOSE_FILE: "CLOSE_FILE",
  DELETE_FILE: "DELETE_FILE",
  NEW_FOLDER: "NEW_FOLDER",
  TOGGLE_OPEN_FOLDER: "TOGGLE_OPEN_FOLDER",
  DELETE_FOLDER: "DELETE_FOLDER",
  RENAME_FOLDER: "RENAME_FOLDER"
}, DZ = "Add your changes to ${fileName}", vZ = (t) => String(Math.max(...t.map((e) => Number(e.id))) + 1), SZ = (t) => String(Math.max(...t.map((e) => Number(e.id))) + 1), u0 = (t, e) => e.reduce((r, n) => (n.parentId === t && r.push(n.id, ...u0(n.id, e)), r), []), wZ = (t, e, r) => {
  const n = new Set(
    r ? [t, ...u0(t, r)] : [t]
  );
  return e.reduce((i, s) => (n.has(s.folderId) && i.push(s.id), i), []);
}, CZ = (t) => Ke(() => {
  const e = {
    replaceProject: (r, n) => {
      t({
        type: st.REPLACE_PROJECT,
        payload: { project: r, shouldNotifyProjectUpdate: n }
      });
    },
    newFile: ({
      fileId: r,
      fileName: n,
      folderId: i = Vs,
      contents: s = DZ
    }) => {
      t({
        type: st.NEW_FILE,
        payload: {
          fileId: r,
          fileName: n,
          folderId: i,
          contents: s.replace(/\${fileName}/g, n)
        }
      }), e.setActiveFile(r);
    },
    renameFile: (r, n) => {
      t({
        type: st.RENAME_FILE,
        payload: { fileId: r, newName: n }
      });
    },
    saveFile: (r, n) => {
      t({
        type: st.SAVE_FILE,
        payload: { fileId: r, contents: n }
      });
    },
    openFile: (r) => {
      t({
        type: st.OPEN_FILE,
        payload: { fileId: r }
      });
    },
    closeFile: (r) => {
      t({
        type: st.CLOSE_FILE,
        payload: { fileId: r }
      });
    },
    deleteFile: (r) => {
      t({
        type: st.DELETE_FILE,
        payload: { fileId: r }
      });
    },
    setActiveFile: (r) => {
      t({
        type: st.ACTIVATE_FILE,
        payload: { fileId: r }
      });
    },
    moveFile: (r, n) => {
      t({
        type: st.MOVE_FILE,
        payload: { fileId: r, folderId: n }
      });
    },
    newFolder: ({
      folderId: r,
      folderName: n,
      parentId: i = Vs
    }) => {
      t({
        type: st.NEW_FOLDER,
        payload: { folderId: r, folderName: n, parentId: i }
      });
    },
    renameFolder: (r, n) => {
      t({
        type: st.RENAME_FOLDER,
        payload: { folderId: r, newName: n }
      });
    },
    toggleOpenFolder: (r) => {
      t({
        type: st.TOGGLE_OPEN_FOLDER,
        payload: { folderId: r }
      });
    },
    deleteFolder: (r) => {
      t({
        type: st.DELETE_FOLDER,
        payload: { folderId: r }
      });
    }
  };
  return e;
}, [t]), EZ = (t, e) => {
  var r;
  switch (e.type) {
    case st.REPLACE_PROJECT: {
      const {
        project: n,
        shouldNotifyProjectUpdate: i
      } = e.payload;
      return t !== n && (i.current = !1), n;
    }
    case st.NEW_FILE: {
      const { fileId: n, fileName: i, folderId: s, contents: a = "" } = e.payload, o = { ...t, files: { ...t.files } }, [u, c] = i.split(".");
      return o.files[n] = {
        id: n,
        name: i,
        language: c || "html",
        contents: a,
        folderId: s
      }, o;
    }
    case st.RENAME_FILE: {
      const { fileId: n, newName: i } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], name: i }
        }
      };
    }
    case st.SAVE_FILE: {
      const { fileId: n, contents: i } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], contents: i }
        }
      };
    }
    case st.OPEN_FILE:
    case st.ACTIVATE_FILE: {
      const { fileId: n } = e.payload, i = (r = Object.values(t.files).filter(
        (a) => a.active
      )) == null ? void 0 : r[0];
      if ((i == null ? void 0 : i.id) === n)
        return t;
      const s = {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], active: !0, open: !0 }
        }
      };
      return i && (s.files[i.id] = {
        ...s.files[i.id],
        active: !1
      }), s;
    }
    case st.CLOSE_FILE: {
      const { fileId: n } = e.payload, i = t.files[n], s = {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], open: !1, active: !1 }
        }
      };
      if (i.active) {
        const a = rE(t.files, {
          mustBeOpen: !0
        }), o = a.findIndex((c) => c.id === i.id);
        let u;
        o > 0 ? u = a[o - 1].id : o < a.length - 1 && (u = a[o + 1].id), u && (s.files[u] = {
          ...s.files[u],
          active: !0
        });
      }
      return s;
    }
    case st.DELETE_FILE: {
      const { fileId: n } = e.payload, i = {
        ...t,
        files: {
          ...t.files
        }
      };
      return delete i.files[n], i;
    }
    case st.MOVE_FILE: {
      const { fileId: n, folderId: i } = e.payload;
      return {
        ...t,
        files: {
          ...t.files,
          [n]: { ...t.files[n], folderId: i }
        }
      };
    }
    case st.NEW_FOLDER: {
      const { folderId: n, folderName: i, parentId: s } = e.payload, a = { ...t, folders: { ...t.folders } };
      return a.folders[n] = {
        id: n,
        name: i,
        parentId: s
      }, a;
    }
    case st.TOGGLE_OPEN_FOLDER: {
      const { folderId: n } = e.payload;
      return {
        ...t,
        folders: {
          ...t.folders,
          [n]: {
            ...t.folders[n],
            open: !t.folders[n].open
          }
        }
      };
    }
    case st.DELETE_FOLDER: {
      const { folderId: n } = e.payload, i = {
        ...t,
        folders: {
          ...t.folders
        }
      }, s = new Set(
        u0(n, Object.values(t.folders))
      ), a = new Set(
        wZ(
          n,
          Object.values(t.files),
          Object.values(t.folders)
        )
      );
      return delete i.folders[n], Object.values(i.folders).filter((o) => s.has(o.id)).forEach((o) => delete i.folders[o.id]), a.size && (i.files = { ...i.files }, Object.values(i.files).filter((o) => a.has(o.id)).forEach((o) => delete i.files[o.id])), i;
    }
    case st.RENAME_FOLDER: {
      const { folderId: n, newName: i } = e.payload;
      return {
        ...t,
        folders: {
          ...t.folders,
          [n]: { ...t.folders[n], name: i }
        }
      };
    }
    default:
      return t;
  }
}, AZ = ({ setActivePane: t, activePane: e }) => {
  const {
    config: { leftNav: r }
  } = kr();
  return !r || !r.length ? null : /* @__PURE__ */ z.jsx("div", { className: "nav-bar", children: r.map((n) => /* @__PURE__ */ z.jsx(
    "div",
    {
      onClick: () => t(n.component),
      style: {
        cursor: "pointer",
        color: n.component === e ? "#0093a4" : void 0
      },
      children: /* @__PURE__ */ z.jsx("i", { className: `fa-regular fa-2xl ${n.icon}` })
    },
    n.icon
  )) });
}, TZ = () => {
  const {
    config: { sideBar: t }
  } = kr();
  return /* @__PURE__ */ z.jsx("div", { className: "left-side-bar", children: t.map((e) => /* @__PURE__ */ z.jsxs("div", { onClick: e.action, style: { cursor: "pointer" }, children: [
    /* @__PURE__ */ z.jsx("i", { className: `fa-regular fa-2xl ${e.icon}` }),
    e.label
  ] }, e.icon)) });
}, nE = ({
  parentId: t,
  folders: e,
  files: r,
  newFolderPrompt: n,
  newFilePrompt: i,
  moveFilePrompt: s,
  renameFilePrompt: a,
  renameFolderPrompt: o
}) => {
  const {
    openFile: u,
    deleteFile: c,
    toggleOpenFolder: h,
    deleteFolder: p
  } = kr();
  return /* @__PURE__ */ z.jsxs(z.Fragment, { children: [
    Object.values(e).filter((m) => m.parentId === t).sort((m, g) => m.name.localeCompare(g.name)).map((m) => {
      const g = /* @__PURE__ */ z.jsx(
        "i",
        {
          className: m.open ? "fa-solid fa-caret-down" : "fa-solid fa-caret-right"
        }
      );
      return /* @__PURE__ */ z.jsxs("li", { children: [
        /* @__PURE__ */ z.jsxs("span", { className: "label", children: [
          /* @__PURE__ */ z.jsxs("span", { className: "title", children: [
            /* @__PURE__ */ z.jsx(
              "span",
              {
                className: "caret-container",
                onClick: () => h(m.id),
                children: g
              }
            ),
            /* @__PURE__ */ z.jsx("span", { children: m.name })
          ] }),
          /* @__PURE__ */ z.jsxs("span", { className: "button-bar", children: [
            /* @__PURE__ */ z.jsx("span", { onClick: () => o(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-pencil" }) }),
            /* @__PURE__ */ z.jsx("span", { onClick: () => n(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-folder-plus" }) }),
            /* @__PURE__ */ z.jsx("span", { onClick: () => i(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-plus" }) }),
            /* @__PURE__ */ z.jsx("span", { onClick: () => p(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-trash" }) })
          ] })
        ] }),
        m.open && /* @__PURE__ */ z.jsx("ul", { children: /* @__PURE__ */ z.jsx(
          nE,
          {
            folders: e,
            newFolderPrompt: n,
            parentId: m.id,
            files: r,
            newFilePrompt: i,
            moveFilePrompt: s,
            renameFilePrompt: a,
            renameFolderPrompt: o
          }
        ) })
      ] }, m.id + m.open);
    }),
    Object.values(r).filter((m) => m.folderId === t).sort((m, g) => m.name.localeCompare(g.name)).map((m) => /* @__PURE__ */ z.jsx("li", { children: /* @__PURE__ */ z.jsxs("span", { className: "label", children: [
      /* @__PURE__ */ z.jsx("span", { onClick: () => u(m.id), children: m.name }),
      /* @__PURE__ */ z.jsxs("span", { className: "button-bar", children: [
        /* @__PURE__ */ z.jsx("span", { onClick: () => s(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-arrow-right" }) }),
        /* @__PURE__ */ z.jsx("span", { onClick: () => a(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-pencil" }) }),
        /* @__PURE__ */ z.jsx("span", { onClick: () => c(m.id), children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-trash" }) })
      ] })
    ] }) }, m.id))
  ] });
}, kZ = () => {
  const {
    project: t,
    newFile: e,
    renameFile: r,
    moveFile: n,
    renameFolder: i,
    newFolder: s
  } = kr(), a = (p = Vs) => {
    const m = SZ(Object.values(t.folders)), g = window.prompt("Please name your new folder");
    if (!g)
      return;
    if (Object.values(t.folders).some(
      (b) => b.name === g && b.parentId === p
    )) {
      alert("Folder already exists");
      return;
    }
    s({ parentId: p, folderName: g, folderId: m });
  }, o = (p = Vs) => {
    var S;
    const m = (S = window.prompt("Please name your new file")) == null ? void 0 : S.replace(/[^\w.]+/g, "");
    if (!m)
      return;
    if (Object.values(t.files).some(
      (x) => x.name === m && x.folderId === p
    )) {
      alert("File already exists");
      return;
    }
    const [O, b] = m.split(".");
    if (!b) {
      window.alert("Files must have extensions");
      return;
    }
    const D = vZ(Object.values(t.files));
    e({
      fileId: D,
      fileName: m,
      folderId: p
    });
  }, u = (p) => {
    const m = t.files[p], g = window.prompt("Please enter your destination folder") ?? "";
    try {
      const O = VD(g.split("/"), {
        folders: Object.values(t.folders),
        required: !0
      });
      if (Object.values(t.files).some(
        (D) => D.name === m.name && D.folderId === O
      )) {
        alert("File already exists");
        return;
      }
      n(p, O);
    } catch (O) {
      window.alert(YD(O));
    }
  }, c = (p) => {
    const m = t.files[p], g = window.prompt("Rename file", m.name);
    if (g === null || g === m.name)
      return;
    if (Object.values(t.files).some(
      (b) => b.name === g && b.folderId === m.folderId
    )) {
      alert("File already exists");
      return;
    }
    r(p, g);
  }, h = (p) => {
    const m = t.folders[p], g = window.prompt("Rename folder", m.name);
    if (g === null || g === m.name)
      return;
    if (Object.values(t.folders).some(
      (b) => b.name === g && b.parentId === m.parentId
    )) {
      alert("Folder already exists");
      return;
    }
    i(m.id, g);
  };
  return /* @__PURE__ */ z.jsxs("div", { children: [
    /* @__PURE__ */ z.jsxs("div", { className: "files-toolbar", children: [
      /* @__PURE__ */ z.jsxs("button", { type: "button", onClick: () => a(), children: [
        /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-folder" }),
        " New Folder"
      ] }),
      /* @__PURE__ */ z.jsxs("button", { type: "button", onClick: () => o(), children: [
        /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-file" }),
        " New File"
      ] })
    ] }),
    /* @__PURE__ */ z.jsx("ul", { children: /* @__PURE__ */ z.jsx(
      nE,
      {
        parentId: Vs,
        folders: t.folders,
        newFolderPrompt: a,
        files: t.files,
        newFilePrompt: o,
        moveFilePrompt: u,
        renameFilePrompt: c,
        renameFolderPrompt: h
      }
    ) })
  ] });
}, PZ = () => {
  const {
    config: { instructions: t }
  } = kr();
  return /* @__PURE__ */ z.jsx("div", { className: "instructions", children: t });
}, FZ = () => /* @__PURE__ */ z.jsx("div", { children: "Search is not yet implemented. Sorry." }), $Z = {
  Instructions: PZ,
  Files: kZ,
  Search: FZ
}, BZ = () => {
  const { config: t } = kr(), [e, r] = At(
    t.activeLeftNav || t.leftNav[0].component
  ), n = $Z[e];
  return /* @__PURE__ */ z.jsxs(
    "div",
    {
      className: "left-pane-outer",
      style: { gridTemplateColumns: t.showSideBar ? "1fr 9fr" : "1fr" },
      children: [
        t.showSideBar && /* @__PURE__ */ z.jsx(TZ, {}),
        /* @__PURE__ */ z.jsxs("div", { className: "left-pane-inner", children: [
          /* @__PURE__ */ z.jsx(AZ, { setActivePane: r, activePane: e }),
          /* @__PURE__ */ z.jsx("div", { className: "left-main", children: /* @__PURE__ */ z.jsx(n, {}) })
        ] })
      ]
    }
  );
};
function IZ() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  return Ke(
    () => (n) => {
      e.forEach((i) => i(n));
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    e
  );
}
const Jp = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
function Io(t) {
  const e = Object.prototype.toString.call(t);
  return e === "[object Window]" || // In Electron context the Window object serializes to [object global]
  e === "[object global]";
}
function c0(t) {
  return "nodeType" in t;
}
function Fr(t) {
  var e, r;
  return t ? Io(t) ? t : c0(t) && (e = (r = t.ownerDocument) == null ? void 0 : r.defaultView) != null ? e : window : window;
}
function h0(t) {
  const {
    Document: e
  } = Fr(t);
  return t instanceof e;
}
function Bu(t) {
  return Io(t) ? !1 : t instanceof Fr(t).HTMLElement;
}
function iE(t) {
  return t instanceof Fr(t).SVGElement;
}
function No(t) {
  return t ? Io(t) ? t.document : c0(t) ? h0(t) ? t : Bu(t) || iE(t) ? t.ownerDocument : document : document : document;
}
const Nn = Jp ? gF : Qe;
function p0(t) {
  const e = et(t);
  return Nn(() => {
    e.current = t;
  }), Ht(function() {
    for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
      n[i] = arguments[i];
    return e.current == null ? void 0 : e.current(...n);
  }, []);
}
function NZ() {
  const t = et(null), e = Ht((n, i) => {
    t.current = setInterval(n, i);
  }, []), r = Ht(() => {
    t.current !== null && (clearInterval(t.current), t.current = null);
  }, []);
  return [e, r];
}
function Ul(t, e) {
  e === void 0 && (e = [t]);
  const r = et(t);
  return Nn(() => {
    r.current !== t && (r.current = t);
  }, e), r;
}
function Iu(t, e) {
  const r = et();
  return Ke(
    () => {
      const n = t(r.current);
      return r.current = n, n;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...e]
  );
}
function Th(t) {
  const e = p0(t), r = et(null), n = Ht(
    (i) => {
      i !== r.current && (e == null || e(i, r.current)), r.current = i;
    },
    //eslint-disable-next-line
    []
  );
  return [r, n];
}
function Cm(t) {
  const e = et();
  return Qe(() => {
    e.current = t;
  }, [t]), e.current;
}
let ef = {};
function Nu(t, e) {
  return Ke(() => {
    if (e)
      return e;
    const r = ef[t] == null ? 0 : ef[t] + 1;
    return ef[t] = r, t + "-" + r;
  }, [t, e]);
}
function sE(t) {
  return function(e) {
    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
      n[i - 1] = arguments[i];
    return n.reduce((s, a) => {
      const o = Object.entries(a);
      for (const [u, c] of o) {
        const h = s[u];
        h != null && (s[u] = h + t * c);
      }
      return s;
    }, {
      ...e
    });
  };
}
const za = /* @__PURE__ */ sE(1), zl = /* @__PURE__ */ sE(-1);
function _Z(t) {
  return "clientX" in t && "clientY" in t;
}
function d0(t) {
  if (!t)
    return !1;
  const {
    KeyboardEvent: e
  } = Fr(t.target);
  return e && t instanceof e;
}
function QZ(t) {
  if (!t)
    return !1;
  const {
    TouchEvent: e
  } = Fr(t.target);
  return e && t instanceof e;
}
function Em(t) {
  if (QZ(t)) {
    if (t.touches && t.touches.length) {
      const {
        clientX: e,
        clientY: r
      } = t.touches[0];
      return {
        x: e,
        y: r
      };
    } else if (t.changedTouches && t.changedTouches.length) {
      const {
        clientX: e,
        clientY: r
      } = t.changedTouches[0];
      return {
        x: e,
        y: r
      };
    }
  }
  return _Z(t) ? {
    x: t.clientX,
    y: t.clientY
  } : null;
}
const Gl = /* @__PURE__ */ Object.freeze({
  Translate: {
    toString(t) {
      if (!t)
        return;
      const {
        x: e,
        y: r
      } = t;
      return "translate3d(" + (e ? Math.round(e) : 0) + "px, " + (r ? Math.round(r) : 0) + "px, 0)";
    }
  },
  Scale: {
    toString(t) {
      if (!t)
        return;
      const {
        scaleX: e,
        scaleY: r
      } = t;
      return "scaleX(" + e + ") scaleY(" + r + ")";
    }
  },
  Transform: {
    toString(t) {
      if (t)
        return [Gl.Translate.toString(t), Gl.Scale.toString(t)].join(" ");
    }
  },
  Transition: {
    toString(t) {
      let {
        property: e,
        duration: r,
        easing: n
      } = t;
      return e + " " + r + "ms " + n;
    }
  }
}), lx = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
function MZ(t) {
  return t.matches(lx) ? t : t.querySelector(lx);
}
const LZ = {
  display: "none"
};
function RZ(t) {
  let {
    id: e,
    value: r
  } = t;
  return sr.createElement("div", {
    id: e,
    style: LZ
  }, r);
}
function jZ(t) {
  let {
    id: e,
    announcement: r,
    ariaLiveType: n = "assertive"
  } = t;
  const i = {
    position: "fixed",
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: "hidden",
    clip: "rect(0 0 0 0)",
    clipPath: "inset(100%)",
    whiteSpace: "nowrap"
  };
  return sr.createElement("div", {
    id: e,
    style: i,
    role: "status",
    "aria-live": n,
    "aria-atomic": !0
  }, r);
}
function ZZ() {
  const [t, e] = At("");
  return {
    announce: Ht((n) => {
      n != null && e(n);
    }, []),
    announcement: t
  };
}
const aE = /* @__PURE__ */ bo(null);
function WZ(t) {
  const e = hs(aE);
  Qe(() => {
    if (!e)
      throw new Error("useDndMonitor must be used within a children of <DndContext>");
    return e(t);
  }, [t, e]);
}
function qZ() {
  const [t] = At(() => /* @__PURE__ */ new Set()), e = Ht((n) => (t.add(n), () => t.delete(n)), [t]);
  return [Ht((n) => {
    let {
      type: i,
      event: s
    } = n;
    t.forEach((a) => {
      var o;
      return (o = a[i]) == null ? void 0 : o.call(a, s);
    });
  }, [t]), e];
}
const XZ = {
  draggable: `
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `
}, VZ = {
  onDragStart(t) {
    let {
      active: e
    } = t;
    return "Picked up draggable item " + e.id + ".";
  },
  onDragOver(t) {
    let {
      active: e,
      over: r
    } = t;
    return r ? "Draggable item " + e.id + " was moved over droppable area " + r.id + "." : "Draggable item " + e.id + " is no longer over a droppable area.";
  },
  onDragEnd(t) {
    let {
      active: e,
      over: r
    } = t;
    return r ? "Draggable item " + e.id + " was dropped over droppable area " + r.id : "Draggable item " + e.id + " was dropped.";
  },
  onDragCancel(t) {
    let {
      active: e
    } = t;
    return "Dragging was cancelled. Draggable item " + e.id + " was dropped.";
  }
};
function YZ(t) {
  let {
    announcements: e = VZ,
    container: r,
    hiddenTextDescribedById: n,
    screenReaderInstructions: i = XZ
  } = t;
  const {
    announce: s,
    announcement: a
  } = ZZ(), o = Nu("DndLiveRegion"), [u, c] = At(!1);
  if (Qe(() => {
    c(!0);
  }, []), WZ(Ke(() => ({
    onDragStart(p) {
      let {
        active: m
      } = p;
      s(e.onDragStart({
        active: m
      }));
    },
    onDragMove(p) {
      let {
        active: m,
        over: g
      } = p;
      e.onDragMove && s(e.onDragMove({
        active: m,
        over: g
      }));
    },
    onDragOver(p) {
      let {
        active: m,
        over: g
      } = p;
      s(e.onDragOver({
        active: m,
        over: g
      }));
    },
    onDragEnd(p) {
      let {
        active: m,
        over: g
      } = p;
      s(e.onDragEnd({
        active: m,
        over: g
      }));
    },
    onDragCancel(p) {
      let {
        active: m,
        over: g
      } = p;
      s(e.onDragCancel({
        active: m,
        over: g
      }));
    }
  }), [s, e])), !u)
    return null;
  const h = sr.createElement(sr.Fragment, null, sr.createElement(RZ, {
    id: n,
    value: i.draggable
  }), sr.createElement(jZ, {
    id: o,
    announcement: a
  }));
  return r ? bF(h, r) : h;
}
var $t;
(function(t) {
  t.DragStart = "dragStart", t.DragMove = "dragMove", t.DragEnd = "dragEnd", t.DragCancel = "dragCancel", t.DragOver = "dragOver", t.RegisterDroppable = "registerDroppable", t.SetDroppableDisabled = "setDroppableDisabled", t.UnregisterDroppable = "unregisterDroppable";
})($t || ($t = {}));
function kh() {
}
function ux(t, e) {
  return Ke(
    () => ({
      sensor: t,
      options: e ?? {}
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [t, e]
  );
}
function UZ() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  return Ke(
    () => [...e].filter((n) => n != null),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...e]
  );
}
const _n = /* @__PURE__ */ Object.freeze({
  x: 0,
  y: 0
});
function oE(t, e) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function lE(t, e) {
  let {
    data: {
      value: r
    }
  } = t, {
    data: {
      value: n
    }
  } = e;
  return r - n;
}
function zZ(t, e) {
  let {
    data: {
      value: r
    }
  } = t, {
    data: {
      value: n
    }
  } = e;
  return n - r;
}
function cx(t) {
  let {
    left: e,
    top: r,
    height: n,
    width: i
  } = t;
  return [{
    x: e,
    y: r
  }, {
    x: e + i,
    y: r
  }, {
    x: e,
    y: r + n
  }, {
    x: e + i,
    y: r + n
  }];
}
function uE(t, e) {
  if (!t || t.length === 0)
    return null;
  const [r] = t;
  return e ? r[e] : r;
}
function hx(t, e, r) {
  return e === void 0 && (e = t.left), r === void 0 && (r = t.top), {
    x: e + t.width * 0.5,
    y: r + t.height * 0.5
  };
}
const GZ = (t) => {
  let {
    collisionRect: e,
    droppableRects: r,
    droppableContainers: n
  } = t;
  const i = hx(e, e.left, e.top), s = [];
  for (const a of n) {
    const {
      id: o
    } = a, u = r.get(o);
    if (u) {
      const c = oE(hx(u), i);
      s.push({
        id: o,
        data: {
          droppableContainer: a,
          value: c
        }
      });
    }
  }
  return s.sort(lE);
}, HZ = (t) => {
  let {
    collisionRect: e,
    droppableRects: r,
    droppableContainers: n
  } = t;
  const i = cx(e), s = [];
  for (const a of n) {
    const {
      id: o
    } = a, u = r.get(o);
    if (u) {
      const c = cx(u), h = i.reduce((m, g, O) => m + oE(c[O], g), 0), p = Number((h / 4).toFixed(4));
      s.push({
        id: o,
        data: {
          droppableContainer: a,
          value: p
        }
      });
    }
  }
  return s.sort(lE);
};
function JZ(t, e) {
  const r = Math.max(e.top, t.top), n = Math.max(e.left, t.left), i = Math.min(e.left + e.width, t.left + t.width), s = Math.min(e.top + e.height, t.top + t.height), a = i - n, o = s - r;
  if (n < i && r < s) {
    const u = e.width * e.height, c = t.width * t.height, h = a * o, p = h / (u + c - h);
    return Number(p.toFixed(4));
  }
  return 0;
}
const KZ = (t) => {
  let {
    collisionRect: e,
    droppableRects: r,
    droppableContainers: n
  } = t;
  const i = [];
  for (const s of n) {
    const {
      id: a
    } = s, o = r.get(a);
    if (o) {
      const u = JZ(o, e);
      u > 0 && i.push({
        id: a,
        data: {
          droppableContainer: s,
          value: u
        }
      });
    }
  }
  return i.sort(zZ);
};
function eW(t, e, r) {
  return {
    ...t,
    scaleX: e && r ? e.width / r.width : 1,
    scaleY: e && r ? e.height / r.height : 1
  };
}
function cE(t, e) {
  return t && e ? {
    x: t.left - e.left,
    y: t.top - e.top
  } : _n;
}
function tW(t) {
  return function(r) {
    for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
      i[s - 1] = arguments[s];
    return i.reduce((a, o) => ({
      ...a,
      top: a.top + t * o.y,
      bottom: a.bottom + t * o.y,
      left: a.left + t * o.x,
      right: a.right + t * o.x
    }), {
      ...r
    });
  };
}
const rW = /* @__PURE__ */ tW(1);
function nW(t) {
  if (t.startsWith("matrix3d(")) {
    const e = t.slice(9, -1).split(/, /);
    return {
      x: +e[12],
      y: +e[13],
      scaleX: +e[0],
      scaleY: +e[5]
    };
  } else if (t.startsWith("matrix(")) {
    const e = t.slice(7, -1).split(/, /);
    return {
      x: +e[4],
      y: +e[5],
      scaleX: +e[0],
      scaleY: +e[3]
    };
  }
  return null;
}
function iW(t, e, r) {
  const n = nW(e);
  if (!n)
    return t;
  const {
    scaleX: i,
    scaleY: s,
    x: a,
    y: o
  } = n, u = t.left - a - (1 - i) * parseFloat(r), c = t.top - o - (1 - s) * parseFloat(r.slice(r.indexOf(" ") + 1)), h = i ? t.width / i : t.width, p = s ? t.height / s : t.height;
  return {
    width: h,
    height: p,
    top: c,
    right: u + h,
    bottom: c + p,
    left: u
  };
}
const sW = {
  ignoreTransform: !1
};
function _o(t, e) {
  e === void 0 && (e = sW);
  let r = t.getBoundingClientRect();
  if (e.ignoreTransform) {
    const {
      transform: c,
      transformOrigin: h
    } = Fr(t).getComputedStyle(t);
    c && (r = iW(r, c, h));
  }
  const {
    top: n,
    left: i,
    width: s,
    height: a,
    bottom: o,
    right: u
  } = r;
  return {
    top: n,
    left: i,
    width: s,
    height: a,
    bottom: o,
    right: u
  };
}
function px(t) {
  return _o(t, {
    ignoreTransform: !0
  });
}
function aW(t) {
  const e = t.innerWidth, r = t.innerHeight;
  return {
    top: 0,
    left: 0,
    right: e,
    bottom: r,
    width: e,
    height: r
  };
}
function oW(t, e) {
  return e === void 0 && (e = Fr(t).getComputedStyle(t)), e.position === "fixed";
}
function lW(t, e) {
  e === void 0 && (e = Fr(t).getComputedStyle(t));
  const r = /(auto|scroll|overlay)/;
  return ["overflow", "overflowX", "overflowY"].some((i) => {
    const s = e[i];
    return typeof s == "string" ? r.test(s) : !1;
  });
}
function Kp(t, e) {
  const r = [];
  function n(i) {
    if (e != null && r.length >= e || !i)
      return r;
    if (h0(i) && i.scrollingElement != null && !r.includes(i.scrollingElement))
      return r.push(i.scrollingElement), r;
    if (!Bu(i) || iE(i) || r.includes(i))
      return r;
    const s = Fr(t).getComputedStyle(i);
    return i !== t && lW(i, s) && r.push(i), oW(i, s) ? r : n(i.parentNode);
  }
  return t ? n(t) : r;
}
function hE(t) {
  const [e] = Kp(t, 1);
  return e ?? null;
}
function tf(t) {
  return !Jp || !t ? null : Io(t) ? t : c0(t) ? h0(t) || t === No(t).scrollingElement ? window : Bu(t) ? t : null : null;
}
function pE(t) {
  return Io(t) ? t.scrollX : t.scrollLeft;
}
function dE(t) {
  return Io(t) ? t.scrollY : t.scrollTop;
}
function Am(t) {
  return {
    x: pE(t),
    y: dE(t)
  };
}
var Mt;
(function(t) {
  t[t.Forward = 1] = "Forward", t[t.Backward = -1] = "Backward";
})(Mt || (Mt = {}));
function fE(t) {
  return !Jp || !t ? !1 : t === document.scrollingElement;
}
function mE(t) {
  const e = {
    x: 0,
    y: 0
  }, r = fE(t) ? {
    height: window.innerHeight,
    width: window.innerWidth
  } : {
    height: t.clientHeight,
    width: t.clientWidth
  }, n = {
    x: t.scrollWidth - r.width,
    y: t.scrollHeight - r.height
  }, i = t.scrollTop <= e.y, s = t.scrollLeft <= e.x, a = t.scrollTop >= n.y, o = t.scrollLeft >= n.x;
  return {
    isTop: i,
    isLeft: s,
    isBottom: a,
    isRight: o,
    maxScroll: n,
    minScroll: e
  };
}
const uW = {
  x: 0.2,
  y: 0.2
};
function cW(t, e, r, n, i) {
  let {
    top: s,
    left: a,
    right: o,
    bottom: u
  } = r;
  n === void 0 && (n = 10), i === void 0 && (i = uW);
  const {
    isTop: c,
    isBottom: h,
    isLeft: p,
    isRight: m
  } = mE(t), g = {
    x: 0,
    y: 0
  }, O = {
    x: 0,
    y: 0
  }, b = {
    height: e.height * i.y,
    width: e.width * i.x
  };
  return !c && s <= e.top + b.height ? (g.y = Mt.Backward, O.y = n * Math.abs((e.top + b.height - s) / b.height)) : !h && u >= e.bottom - b.height && (g.y = Mt.Forward, O.y = n * Math.abs((e.bottom - b.height - u) / b.height)), !m && o >= e.right - b.width ? (g.x = Mt.Forward, O.x = n * Math.abs((e.right - b.width - o) / b.width)) : !p && a <= e.left + b.width && (g.x = Mt.Backward, O.x = n * Math.abs((e.left + b.width - a) / b.width)), {
    direction: g,
    speed: O
  };
}
function hW(t) {
  if (t === document.scrollingElement) {
    const {
      innerWidth: s,
      innerHeight: a
    } = window;
    return {
      top: 0,
      left: 0,
      right: s,
      bottom: a,
      width: s,
      height: a
    };
  }
  const {
    top: e,
    left: r,
    right: n,
    bottom: i
  } = t.getBoundingClientRect();
  return {
    top: e,
    left: r,
    right: n,
    bottom: i,
    width: t.clientWidth,
    height: t.clientHeight
  };
}
function gE(t) {
  return t.reduce((e, r) => za(e, Am(r)), _n);
}
function pW(t) {
  return t.reduce((e, r) => e + pE(r), 0);
}
function dW(t) {
  return t.reduce((e, r) => e + dE(r), 0);
}
function fW(t, e) {
  if (e === void 0 && (e = _o), !t)
    return;
  const {
    top: r,
    left: n,
    bottom: i,
    right: s
  } = e(t);
  hE(t) && (i <= 0 || s <= 0 || r >= window.innerHeight || n >= window.innerWidth) && t.scrollIntoView({
    block: "center",
    inline: "center"
  });
}
const mW = [["x", ["left", "right"], pW], ["y", ["top", "bottom"], dW]];
class f0 {
  constructor(e, r) {
    this.rect = void 0, this.width = void 0, this.height = void 0, this.top = void 0, this.bottom = void 0, this.right = void 0, this.left = void 0;
    const n = Kp(r), i = gE(n);
    this.rect = {
      ...e
    }, this.width = e.width, this.height = e.height;
    for (const [s, a, o] of mW)
      for (const u of a)
        Object.defineProperty(this, u, {
          get: () => {
            const c = o(n), h = i[s] - c;
            return this.rect[u] + h;
          },
          enumerable: !0
        });
    Object.defineProperty(this, "rect", {
      enumerable: !1
    });
  }
}
class Pl {
  constructor(e) {
    this.target = void 0, this.listeners = [], this.removeAll = () => {
      this.listeners.forEach((r) => {
        var n;
        return (n = this.target) == null ? void 0 : n.removeEventListener(...r);
      });
    }, this.target = e;
  }
  add(e, r, n) {
    var i;
    (i = this.target) == null || i.addEventListener(e, r, n), this.listeners.push([e, r, n]);
  }
}
function gW(t) {
  const {
    EventTarget: e
  } = Fr(t);
  return t instanceof e ? t : No(t);
}
function rf(t, e) {
  const r = Math.abs(t.x), n = Math.abs(t.y);
  return typeof e == "number" ? Math.sqrt(r ** 2 + n ** 2) > e : "x" in e && "y" in e ? r > e.x && n > e.y : "x" in e ? r > e.x : "y" in e ? n > e.y : !1;
}
var sn;
(function(t) {
  t.Click = "click", t.DragStart = "dragstart", t.Keydown = "keydown", t.ContextMenu = "contextmenu", t.Resize = "resize", t.SelectionChange = "selectionchange", t.VisibilityChange = "visibilitychange";
})(sn || (sn = {}));
function dx(t) {
  t.preventDefault();
}
function yW(t) {
  t.stopPropagation();
}
var Ze;
(function(t) {
  t.Space = "Space", t.Down = "ArrowDown", t.Right = "ArrowRight", t.Left = "ArrowLeft", t.Up = "ArrowUp", t.Esc = "Escape", t.Enter = "Enter";
})(Ze || (Ze = {}));
const yE = {
  start: [Ze.Space, Ze.Enter],
  cancel: [Ze.Esc],
  end: [Ze.Space, Ze.Enter]
}, OW = (t, e) => {
  let {
    currentCoordinates: r
  } = e;
  switch (t.code) {
    case Ze.Right:
      return {
        ...r,
        x: r.x + 25
      };
    case Ze.Left:
      return {
        ...r,
        x: r.x - 25
      };
    case Ze.Down:
      return {
        ...r,
        y: r.y + 25
      };
    case Ze.Up:
      return {
        ...r,
        y: r.y - 25
      };
  }
};
class m0 {
  constructor(e) {
    this.props = void 0, this.autoScrollEnabled = !1, this.referenceCoordinates = void 0, this.listeners = void 0, this.windowListeners = void 0, this.props = e;
    const {
      event: {
        target: r
      }
    } = e;
    this.props = e, this.listeners = new Pl(No(r)), this.windowListeners = new Pl(Fr(r)), this.handleKeyDown = this.handleKeyDown.bind(this), this.handleCancel = this.handleCancel.bind(this), this.attach();
  }
  attach() {
    this.handleStart(), this.windowListeners.add(sn.Resize, this.handleCancel), this.windowListeners.add(sn.VisibilityChange, this.handleCancel), setTimeout(() => this.listeners.add(sn.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const {
      activeNode: e,
      onStart: r
    } = this.props, n = e.node.current;
    n && fW(n), r(_n);
  }
  handleKeyDown(e) {
    if (d0(e)) {
      const {
        active: r,
        context: n,
        options: i
      } = this.props, {
        keyboardCodes: s = yE,
        coordinateGetter: a = OW,
        scrollBehavior: o = "smooth"
      } = i, {
        code: u
      } = e;
      if (s.end.includes(u)) {
        this.handleEnd(e);
        return;
      }
      if (s.cancel.includes(u)) {
        this.handleCancel(e);
        return;
      }
      const {
        collisionRect: c
      } = n.current, h = c ? {
        x: c.left,
        y: c.top
      } : _n;
      this.referenceCoordinates || (this.referenceCoordinates = h);
      const p = a(e, {
        active: r,
        context: n.current,
        currentCoordinates: h
      });
      if (p) {
        const m = zl(p, h), g = {
          x: 0,
          y: 0
        }, {
          scrollableAncestors: O
        } = n.current;
        for (const b of O) {
          const D = e.code, {
            isTop: S,
            isRight: x,
            isLeft: w,
            isBottom: T,
            maxScroll: C,
            minScroll: A
          } = mE(b), P = hW(b), $ = {
            x: Math.min(D === Ze.Right ? P.right - P.width / 2 : P.right, Math.max(D === Ze.Right ? P.left : P.left + P.width / 2, p.x)),
            y: Math.min(D === Ze.Down ? P.bottom - P.height / 2 : P.bottom, Math.max(D === Ze.Down ? P.top : P.top + P.height / 2, p.y))
          }, B = D === Ze.Right && !x || D === Ze.Left && !w, _ = D === Ze.Down && !T || D === Ze.Up && !S;
          if (B && $.x !== p.x) {
            const M = b.scrollLeft + m.x, Y = D === Ze.Right && M <= C.x || D === Ze.Left && M >= A.x;
            if (Y && !m.y) {
              b.scrollTo({
                left: M,
                behavior: o
              });
              return;
            }
            Y ? g.x = b.scrollLeft - M : g.x = D === Ze.Right ? b.scrollLeft - C.x : b.scrollLeft - A.x, g.x && b.scrollBy({
              left: -g.x,
              behavior: o
            });
            break;
          } else if (_ && $.y !== p.y) {
            const M = b.scrollTop + m.y, Y = D === Ze.Down && M <= C.y || D === Ze.Up && M >= A.y;
            if (Y && !m.x) {
              b.scrollTo({
                top: M,
                behavior: o
              });
              return;
            }
            Y ? g.y = b.scrollTop - M : g.y = D === Ze.Down ? b.scrollTop - C.y : b.scrollTop - A.y, g.y && b.scrollBy({
              top: -g.y,
              behavior: o
            });
            break;
          }
        }
        this.handleMove(e, za(zl(p, this.referenceCoordinates), g));
      }
    }
  }
  handleMove(e, r) {
    const {
      onMove: n
    } = this.props;
    e.preventDefault(), n(r);
  }
  handleEnd(e) {
    const {
      onEnd: r
    } = this.props;
    e.preventDefault(), this.detach(), r();
  }
  handleCancel(e) {
    const {
      onCancel: r
    } = this.props;
    e.preventDefault(), this.detach(), r();
  }
  detach() {
    this.listeners.removeAll(), this.windowListeners.removeAll();
  }
}
m0.activators = [{
  eventName: "onKeyDown",
  handler: (t, e, r) => {
    let {
      keyboardCodes: n = yE,
      onActivation: i
    } = e, {
      active: s
    } = r;
    const {
      code: a
    } = t.nativeEvent;
    if (n.start.includes(a)) {
      const o = s.activatorNode.current;
      return o && t.target !== o ? !1 : (t.preventDefault(), i == null || i({
        event: t.nativeEvent
      }), !0);
    }
    return !1;
  }
}];
function fx(t) {
  return !!(t && "distance" in t);
}
function mx(t) {
  return !!(t && "delay" in t);
}
class g0 {
  constructor(e, r, n) {
    var i;
    n === void 0 && (n = gW(e.event.target)), this.props = void 0, this.events = void 0, this.autoScrollEnabled = !0, this.document = void 0, this.activated = !1, this.initialCoordinates = void 0, this.timeoutId = null, this.listeners = void 0, this.documentListeners = void 0, this.windowListeners = void 0, this.props = e, this.events = r;
    const {
      event: s
    } = e, {
      target: a
    } = s;
    this.props = e, this.events = r, this.document = No(a), this.documentListeners = new Pl(this.document), this.listeners = new Pl(n), this.windowListeners = new Pl(Fr(a)), this.initialCoordinates = (i = Em(s)) != null ? i : _n, this.handleStart = this.handleStart.bind(this), this.handleMove = this.handleMove.bind(this), this.handleEnd = this.handleEnd.bind(this), this.handleCancel = this.handleCancel.bind(this), this.handleKeydown = this.handleKeydown.bind(this), this.removeTextSelection = this.removeTextSelection.bind(this), this.attach();
  }
  attach() {
    const {
      events: e,
      props: {
        options: {
          activationConstraint: r,
          bypassActivationConstraint: n
        }
      }
    } = this;
    if (this.listeners.add(e.move.name, this.handleMove, {
      passive: !1
    }), this.listeners.add(e.end.name, this.handleEnd), this.windowListeners.add(sn.Resize, this.handleCancel), this.windowListeners.add(sn.DragStart, dx), this.windowListeners.add(sn.VisibilityChange, this.handleCancel), this.windowListeners.add(sn.ContextMenu, dx), this.documentListeners.add(sn.Keydown, this.handleKeydown), r) {
      if (n != null && n({
        event: this.props.event,
        activeNode: this.props.activeNode,
        options: this.props.options
      }))
        return this.handleStart();
      if (mx(r)) {
        this.timeoutId = setTimeout(this.handleStart, r.delay);
        return;
      }
      if (fx(r))
        return;
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll(), this.windowListeners.removeAll(), setTimeout(this.documentListeners.removeAll, 50), this.timeoutId !== null && (clearTimeout(this.timeoutId), this.timeoutId = null);
  }
  handleStart() {
    const {
      initialCoordinates: e
    } = this, {
      onStart: r
    } = this.props;
    e && (this.activated = !0, this.documentListeners.add(sn.Click, yW, {
      capture: !0
    }), this.removeTextSelection(), this.documentListeners.add(sn.SelectionChange, this.removeTextSelection), r(e));
  }
  handleMove(e) {
    var r;
    const {
      activated: n,
      initialCoordinates: i,
      props: s
    } = this, {
      onMove: a,
      options: {
        activationConstraint: o
      }
    } = s;
    if (!i)
      return;
    const u = (r = Em(e)) != null ? r : _n, c = zl(i, u);
    if (!n && o) {
      if (fx(o)) {
        if (o.tolerance != null && rf(c, o.tolerance))
          return this.handleCancel();
        if (rf(c, o.distance))
          return this.handleStart();
      }
      return mx(o) && rf(c, o.tolerance) ? this.handleCancel() : void 0;
    }
    e.cancelable && e.preventDefault(), a(u);
  }
  handleEnd() {
    const {
      onEnd: e
    } = this.props;
    this.detach(), e();
  }
  handleCancel() {
    const {
      onCancel: e
    } = this.props;
    this.detach(), e();
  }
  handleKeydown(e) {
    e.code === Ze.Esc && this.handleCancel();
  }
  removeTextSelection() {
    var e;
    (e = this.document.getSelection()) == null || e.removeAllRanges();
  }
}
const xW = {
  move: {
    name: "pointermove"
  },
  end: {
    name: "pointerup"
  }
};
class y0 extends g0 {
  constructor(e) {
    const {
      event: r
    } = e, n = No(r.target);
    super(e, xW, n);
  }
}
y0.activators = [{
  eventName: "onPointerDown",
  handler: (t, e) => {
    let {
      nativeEvent: r
    } = t, {
      onActivation: n
    } = e;
    return !r.isPrimary || r.button !== 0 ? !1 : (n == null || n({
      event: r
    }), !0);
  }
}];
const bW = {
  move: {
    name: "mousemove"
  },
  end: {
    name: "mouseup"
  }
};
var Tm;
(function(t) {
  t[t.RightClick = 2] = "RightClick";
})(Tm || (Tm = {}));
class DW extends g0 {
  constructor(e) {
    super(e, bW, No(e.event.target));
  }
}
DW.activators = [{
  eventName: "onMouseDown",
  handler: (t, e) => {
    let {
      nativeEvent: r
    } = t, {
      onActivation: n
    } = e;
    return r.button === Tm.RightClick ? !1 : (n == null || n({
      event: r
    }), !0);
  }
}];
const nf = {
  move: {
    name: "touchmove"
  },
  end: {
    name: "touchend"
  }
};
class vW extends g0 {
  constructor(e) {
    super(e, nf);
  }
  static setup() {
    return window.addEventListener(nf.move.name, e, {
      capture: !1,
      passive: !1
    }), function() {
      window.removeEventListener(nf.move.name, e);
    };
    function e() {
    }
  }
}
vW.activators = [{
  eventName: "onTouchStart",
  handler: (t, e) => {
    let {
      nativeEvent: r
    } = t, {
      onActivation: n
    } = e;
    const {
      touches: i
    } = r;
    return i.length > 1 ? !1 : (n == null || n({
      event: r
    }), !0);
  }
}];
var Fl;
(function(t) {
  t[t.Pointer = 0] = "Pointer", t[t.DraggableRect = 1] = "DraggableRect";
})(Fl || (Fl = {}));
var Ph;
(function(t) {
  t[t.TreeOrder = 0] = "TreeOrder", t[t.ReversedTreeOrder = 1] = "ReversedTreeOrder";
})(Ph || (Ph = {}));
function SW(t) {
  let {
    acceleration: e,
    activator: r = Fl.Pointer,
    canScroll: n,
    draggingRect: i,
    enabled: s,
    interval: a = 5,
    order: o = Ph.TreeOrder,
    pointerCoordinates: u,
    scrollableAncestors: c,
    scrollableAncestorRects: h,
    delta: p,
    threshold: m
  } = t;
  const g = CW({
    delta: p,
    disabled: !s
  }), [O, b] = NZ(), D = et({
    x: 0,
    y: 0
  }), S = et({
    x: 0,
    y: 0
  }), x = Ke(() => {
    switch (r) {
      case Fl.Pointer:
        return u ? {
          top: u.y,
          bottom: u.y,
          left: u.x,
          right: u.x
        } : null;
      case Fl.DraggableRect:
        return i;
    }
  }, [r, i, u]), w = et(null), T = Ht(() => {
    const A = w.current;
    if (!A)
      return;
    const P = D.current.x * S.current.x, $ = D.current.y * S.current.y;
    A.scrollBy(P, $);
  }, []), C = Ke(() => o === Ph.TreeOrder ? [...c].reverse() : c, [o, c]);
  Qe(
    () => {
      if (!s || !c.length || !x) {
        b();
        return;
      }
      for (const A of C) {
        if ((n == null ? void 0 : n(A)) === !1)
          continue;
        const P = c.indexOf(A), $ = h[P];
        if (!$)
          continue;
        const {
          direction: B,
          speed: _
        } = cW(A, $, x, e, m);
        for (const M of ["x", "y"])
          g[M][B[M]] || (_[M] = 0, B[M] = 0);
        if (_.x > 0 || _.y > 0) {
          b(), w.current = A, O(T, a), D.current = _, S.current = B;
          return;
        }
      }
      D.current = {
        x: 0,
        y: 0
      }, S.current = {
        x: 0,
        y: 0
      }, b();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      e,
      T,
      n,
      b,
      s,
      a,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(x),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(g),
      O,
      c,
      C,
      h,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(m)
    ]
  );
}
const wW = {
  x: {
    [Mt.Backward]: !1,
    [Mt.Forward]: !1
  },
  y: {
    [Mt.Backward]: !1,
    [Mt.Forward]: !1
  }
};
function CW(t) {
  let {
    delta: e,
    disabled: r
  } = t;
  const n = Cm(e);
  return Iu((i) => {
    if (r || !n || !i)
      return wW;
    const s = {
      x: Math.sign(e.x - n.x),
      y: Math.sign(e.y - n.y)
    };
    return {
      x: {
        [Mt.Backward]: i.x[Mt.Backward] || s.x === -1,
        [Mt.Forward]: i.x[Mt.Forward] || s.x === 1
      },
      y: {
        [Mt.Backward]: i.y[Mt.Backward] || s.y === -1,
        [Mt.Forward]: i.y[Mt.Forward] || s.y === 1
      }
    };
  }, [r, e, n]);
}
function EW(t, e) {
  const r = e !== null ? t.get(e) : void 0, n = r ? r.node.current : null;
  return Iu((i) => {
    var s;
    return e === null ? null : (s = n ?? i) != null ? s : null;
  }, [n, e]);
}
function AW(t, e) {
  return Ke(() => t.reduce((r, n) => {
    const {
      sensor: i
    } = n, s = i.activators.map((a) => ({
      eventName: a.eventName,
      handler: e(a.handler, n)
    }));
    return [...r, ...s];
  }, []), [t, e]);
}
var Hl;
(function(t) {
  t[t.Always = 0] = "Always", t[t.BeforeDragging = 1] = "BeforeDragging", t[t.WhileDragging = 2] = "WhileDragging";
})(Hl || (Hl = {}));
var km;
(function(t) {
  t.Optimized = "optimized";
})(km || (km = {}));
const gx = /* @__PURE__ */ new Map();
function TW(t, e) {
  let {
    dragging: r,
    dependencies: n,
    config: i
  } = e;
  const [s, a] = At(null), {
    frequency: o,
    measure: u,
    strategy: c
  } = i, h = et(t), p = D(), m = Ul(p), g = Ht(function(S) {
    S === void 0 && (S = []), !m.current && a((x) => x === null ? S : x.concat(S.filter((w) => !x.includes(w))));
  }, [m]), O = et(null), b = Iu((S) => {
    if (p && !r)
      return gx;
    if (!S || S === gx || h.current !== t || s != null) {
      const x = /* @__PURE__ */ new Map();
      for (let w of t) {
        if (!w)
          continue;
        if (s && s.length > 0 && !s.includes(w.id) && w.rect.current) {
          x.set(w.id, w.rect.current);
          continue;
        }
        const T = w.node.current, C = T ? new f0(u(T), T) : null;
        w.rect.current = C, C && x.set(w.id, C);
      }
      return x;
    }
    return S;
  }, [t, s, r, p, u]);
  return Qe(() => {
    h.current = t;
  }, [t]), Qe(
    () => {
      p || g();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [r, p]
  ), Qe(
    () => {
      s && s.length > 0 && a(null);
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [JSON.stringify(s)]
  ), Qe(
    () => {
      p || typeof o != "number" || O.current !== null || (O.current = setTimeout(() => {
        g(), O.current = null;
      }, o));
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [o, p, g, ...n]
  ), {
    droppableRects: b,
    measureDroppableContainers: g,
    measuringScheduled: s != null
  };
  function D() {
    switch (c) {
      case Hl.Always:
        return !1;
      case Hl.BeforeDragging:
        return r;
      default:
        return !r;
    }
  }
}
function OE(t, e) {
  return Iu((r) => t ? r || (typeof e == "function" ? e(t) : t) : null, [e, t]);
}
function kW(t, e) {
  return OE(t, e);
}
function PW(t) {
  let {
    callback: e,
    disabled: r
  } = t;
  const n = p0(e), i = Ke(() => {
    if (r || typeof window > "u" || typeof window.MutationObserver > "u")
      return;
    const {
      MutationObserver: s
    } = window;
    return new s(n);
  }, [n, r]);
  return Qe(() => () => i == null ? void 0 : i.disconnect(), [i]), i;
}
function ed(t) {
  let {
    callback: e,
    disabled: r
  } = t;
  const n = p0(e), i = Ke(
    () => {
      if (r || typeof window > "u" || typeof window.ResizeObserver > "u")
        return;
      const {
        ResizeObserver: s
      } = window;
      return new s(n);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [r]
  );
  return Qe(() => () => i == null ? void 0 : i.disconnect(), [i]), i;
}
function FW(t) {
  return new f0(_o(t), t);
}
function yx(t, e, r) {
  e === void 0 && (e = FW);
  const [n, i] = op(o, null), s = PW({
    callback(u) {
      if (t)
        for (const c of u) {
          const {
            type: h,
            target: p
          } = c;
          if (h === "childList" && p instanceof HTMLElement && p.contains(t)) {
            i();
            break;
          }
        }
    }
  }), a = ed({
    callback: i
  });
  return Nn(() => {
    i(), t ? (a == null || a.observe(t), s == null || s.observe(document.body, {
      childList: !0,
      subtree: !0
    })) : (a == null || a.disconnect(), s == null || s.disconnect());
  }, [t]), n;
  function o(u) {
    if (!t)
      return null;
    if (t.isConnected === !1) {
      var c;
      return (c = u ?? r) != null ? c : null;
    }
    const h = e(t);
    return JSON.stringify(u) === JSON.stringify(h) ? u : h;
  }
}
function $W(t) {
  const e = OE(t);
  return cE(t, e);
}
const Ox = [];
function BW(t) {
  const e = et(t), r = Iu((n) => t ? n && n !== Ox && t && e.current && t.parentNode === e.current.parentNode ? n : Kp(t) : Ox, [t]);
  return Qe(() => {
    e.current = t;
  }, [t]), r;
}
function IW(t) {
  const [e, r] = At(null), n = et(t), i = Ht((s) => {
    const a = tf(s.target);
    a && r((o) => o ? (o.set(a, Am(a)), new Map(o)) : null);
  }, []);
  return Qe(() => {
    const s = n.current;
    if (t !== s) {
      a(s);
      const o = t.map((u) => {
        const c = tf(u);
        return c ? (c.addEventListener("scroll", i, {
          passive: !0
        }), [c, Am(c)]) : null;
      }).filter((u) => u != null);
      r(o.length ? new Map(o) : null), n.current = t;
    }
    return () => {
      a(t), a(s);
    };
    function a(o) {
      o.forEach((u) => {
        const c = tf(u);
        c == null || c.removeEventListener("scroll", i);
      });
    }
  }, [i, t]), Ke(() => t.length ? e ? Array.from(e.values()).reduce((s, a) => za(s, a), _n) : gE(t) : _n, [t, e]);
}
function xx(t, e) {
  e === void 0 && (e = []);
  const r = et(null);
  return Qe(
    () => {
      r.current = null;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    e
  ), Qe(() => {
    const n = t !== _n;
    n && !r.current && (r.current = t), !n && r.current && (r.current = null);
  }, [t]), r.current ? zl(t, r.current) : _n;
}
function NW(t) {
  Qe(
    () => {
      if (!Jp)
        return;
      const e = t.map((r) => {
        let {
          sensor: n
        } = r;
        return n.setup == null ? void 0 : n.setup();
      });
      return () => {
        for (const r of e)
          r == null || r();
      };
    },
    // TO-DO: Sensors length could theoretically change which would not be a valid dependency
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t.map((e) => {
      let {
        sensor: r
      } = e;
      return r;
    })
  );
}
function _W(t, e) {
  return Ke(() => t.reduce((r, n) => {
    let {
      eventName: i,
      handler: s
    } = n;
    return r[i] = (a) => {
      s(a, e);
    }, r;
  }, {}), [t, e]);
}
function xE(t) {
  return Ke(() => t ? aW(t) : null, [t]);
}
const sf = [];
function QW(t, e) {
  e === void 0 && (e = _o);
  const [r] = t, n = xE(r ? Fr(r) : null), [i, s] = op(o, sf), a = ed({
    callback: s
  });
  return t.length > 0 && i === sf && s(), Nn(() => {
    t.length ? t.forEach((u) => a == null ? void 0 : a.observe(u)) : (a == null || a.disconnect(), s());
  }, [t]), i;
  function o() {
    return t.length ? t.map((u) => fE(u) ? n : new f0(e(u), u)) : sf;
  }
}
function MW(t) {
  if (!t)
    return null;
  if (t.children.length > 1)
    return t;
  const e = t.children[0];
  return Bu(e) ? e : t;
}
function LW(t) {
  let {
    measure: e
  } = t;
  const [r, n] = At(null), i = Ht((c) => {
    for (const {
      target: h
    } of c)
      if (Bu(h)) {
        n((p) => {
          const m = e(h);
          return p ? {
            ...p,
            width: m.width,
            height: m.height
          } : m;
        });
        break;
      }
  }, [e]), s = ed({
    callback: i
  }), a = Ht((c) => {
    const h = MW(c);
    s == null || s.disconnect(), h && (s == null || s.observe(h)), n(h ? e(h) : null);
  }, [e, s]), [o, u] = Th(a);
  return Ke(() => ({
    nodeRef: o,
    rect: r,
    setRef: u
  }), [r, o, u]);
}
const RW = [{
  sensor: y0,
  options: {}
}, {
  sensor: m0,
  options: {}
}], jW = {
  current: {}
}, eh = {
  draggable: {
    measure: px
  },
  droppable: {
    measure: px,
    strategy: Hl.WhileDragging,
    frequency: km.Optimized
  },
  dragOverlay: {
    measure: _o
  }
};
class $l extends Map {
  get(e) {
    var r;
    return e != null && (r = super.get(e)) != null ? r : void 0;
  }
  toArray() {
    return Array.from(this.values());
  }
  getEnabled() {
    return this.toArray().filter((e) => {
      let {
        disabled: r
      } = e;
      return !r;
    });
  }
  getNodeFor(e) {
    var r, n;
    return (r = (n = this.get(e)) == null ? void 0 : n.node.current) != null ? r : void 0;
  }
}
const ZW = {
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  collisions: null,
  containerNodeRect: null,
  draggableNodes: /* @__PURE__ */ new Map(),
  droppableRects: /* @__PURE__ */ new Map(),
  droppableContainers: /* @__PURE__ */ new $l(),
  over: null,
  dragOverlay: {
    nodeRef: {
      current: null
    },
    rect: null,
    setRef: kh
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  measuringConfiguration: eh,
  measureDroppableContainers: kh,
  windowRect: null,
  measuringScheduled: !1
}, WW = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ""
  },
  dispatch: kh,
  draggableNodes: /* @__PURE__ */ new Map(),
  over: null,
  measureDroppableContainers: kh
}, td = /* @__PURE__ */ bo(WW), bE = /* @__PURE__ */ bo(ZW);
function qW() {
  return {
    draggable: {
      active: null,
      initialCoordinates: {
        x: 0,
        y: 0
      },
      nodes: /* @__PURE__ */ new Map(),
      translate: {
        x: 0,
        y: 0
      }
    },
    droppable: {
      containers: new $l()
    }
  };
}
function XW(t, e) {
  switch (e.type) {
    case $t.DragStart:
      return {
        ...t,
        draggable: {
          ...t.draggable,
          initialCoordinates: e.initialCoordinates,
          active: e.active
        }
      };
    case $t.DragMove:
      return t.draggable.active ? {
        ...t,
        draggable: {
          ...t.draggable,
          translate: {
            x: e.coordinates.x - t.draggable.initialCoordinates.x,
            y: e.coordinates.y - t.draggable.initialCoordinates.y
          }
        }
      } : t;
    case $t.DragEnd:
    case $t.DragCancel:
      return {
        ...t,
        draggable: {
          ...t.draggable,
          active: null,
          initialCoordinates: {
            x: 0,
            y: 0
          },
          translate: {
            x: 0,
            y: 0
          }
        }
      };
    case $t.RegisterDroppable: {
      const {
        element: r
      } = e, {
        id: n
      } = r, i = new $l(t.droppable.containers);
      return i.set(n, r), {
        ...t,
        droppable: {
          ...t.droppable,
          containers: i
        }
      };
    }
    case $t.SetDroppableDisabled: {
      const {
        id: r,
        key: n,
        disabled: i
      } = e, s = t.droppable.containers.get(r);
      if (!s || n !== s.key)
        return t;
      const a = new $l(t.droppable.containers);
      return a.set(r, {
        ...s,
        disabled: i
      }), {
        ...t,
        droppable: {
          ...t.droppable,
          containers: a
        }
      };
    }
    case $t.UnregisterDroppable: {
      const {
        id: r,
        key: n
      } = e, i = t.droppable.containers.get(r);
      if (!i || n !== i.key)
        return t;
      const s = new $l(t.droppable.containers);
      return s.delete(r), {
        ...t,
        droppable: {
          ...t.droppable,
          containers: s
        }
      };
    }
    default:
      return t;
  }
}
function VW(t) {
  let {
    disabled: e
  } = t;
  const {
    active: r,
    activatorEvent: n,
    draggableNodes: i
  } = hs(td), s = Cm(n), a = Cm(r == null ? void 0 : r.id);
  return Qe(() => {
    if (!e && !n && s && a != null) {
      if (!d0(s) || document.activeElement === s.target)
        return;
      const o = i.get(a);
      if (!o)
        return;
      const {
        activatorNode: u,
        node: c
      } = o;
      if (!u.current && !c.current)
        return;
      requestAnimationFrame(() => {
        for (const h of [u.current, c.current]) {
          if (!h)
            continue;
          const p = MZ(h);
          if (p) {
            p.focus();
            break;
          }
        }
      });
    }
  }, [n, e, i, a, s]), null;
}
function YW(t, e) {
  let {
    transform: r,
    ...n
  } = e;
  return t != null && t.length ? t.reduce((i, s) => s({
    transform: i,
    ...n
  }), r) : r;
}
function UW(t) {
  return Ke(
    () => ({
      draggable: {
        ...eh.draggable,
        ...t == null ? void 0 : t.draggable
      },
      droppable: {
        ...eh.droppable,
        ...t == null ? void 0 : t.droppable
      },
      dragOverlay: {
        ...eh.dragOverlay,
        ...t == null ? void 0 : t.dragOverlay
      }
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [t == null ? void 0 : t.draggable, t == null ? void 0 : t.droppable, t == null ? void 0 : t.dragOverlay]
  );
}
function zW(t) {
  let {
    activeNode: e,
    measure: r,
    initialRect: n,
    config: i = !0
  } = t;
  const s = et(!1), {
    x: a,
    y: o
  } = typeof i == "boolean" ? {
    x: i,
    y: i
  } : i;
  Nn(() => {
    if (!a && !o || !e) {
      s.current = !1;
      return;
    }
    if (s.current || !n)
      return;
    const c = e == null ? void 0 : e.node.current;
    if (!c || c.isConnected === !1)
      return;
    const h = r(c), p = cE(h, n);
    if (a || (p.x = 0), o || (p.y = 0), s.current = !0, Math.abs(p.x) > 0 || Math.abs(p.y) > 0) {
      const m = hE(c);
      m && m.scrollBy({
        top: p.y,
        left: p.x
      });
    }
  }, [e, a, o, n, r]);
}
const DE = /* @__PURE__ */ bo({
  ..._n,
  scaleX: 1,
  scaleY: 1
});
var Ji;
(function(t) {
  t[t.Uninitialized = 0] = "Uninitialized", t[t.Initializing = 1] = "Initializing", t[t.Initialized = 2] = "Initialized";
})(Ji || (Ji = {}));
const GW = /* @__PURE__ */ yF(function(e) {
  var r, n, i, s;
  let {
    id: a,
    accessibility: o,
    autoScroll: u = !0,
    children: c,
    sensors: h = RW,
    collisionDetection: p = KZ,
    measuring: m,
    modifiers: g,
    ...O
  } = e;
  const b = op(XW, void 0, qW), [D, S] = b, [x, w] = qZ(), [T, C] = At(Ji.Uninitialized), A = T === Ji.Initialized, {
    draggable: {
      active: P,
      nodes: $,
      translate: B
    },
    droppable: {
      containers: _
    }
  } = D, M = P ? $.get(P) : null, Y = et({
    initial: null,
    translated: null
  }), J = Ke(() => {
    var Je;
    return P != null ? {
      id: P,
      // It's possible for the active node to unmount while dragging
      data: (Je = M == null ? void 0 : M.data) != null ? Je : jW,
      rect: Y
    } : null;
  }, [P, M]), R = et(null), [q, X] = At(null), [H, ye] = At(null), Ce = Ul(O, Object.values(O)), Se = Nu("DndDescribedBy", a), Ne = Ke(() => _.getEnabled(), [_]), Te = UW(m), {
    droppableRects: Me,
    measureDroppableContainers: Ee,
    measuringScheduled: nt
  } = TW(Ne, {
    dragging: A,
    dependencies: [B.x, B.y],
    config: Te.droppable
  }), se = EW($, P), V = Ke(() => H ? Em(H) : null, [H]), W = Dr(), j = kW(se, Te.draggable.measure);
  zW({
    activeNode: P ? $.get(P) : null,
    config: W.layoutShiftCompensation,
    initialRect: j,
    measure: Te.draggable.measure
  });
  const le = yx(se, Te.draggable.measure, j), De = yx(se ? se.parentElement : null), we = et({
    activatorEvent: null,
    active: null,
    activeNode: se,
    collisionRect: null,
    collisions: null,
    droppableRects: Me,
    draggableNodes: $,
    draggingNode: null,
    draggingNodeRect: null,
    droppableContainers: _,
    over: null,
    scrollableAncestors: [],
    scrollAdjustedTranslate: null
  }), Dt = _.getNodeFor((r = we.current.over) == null ? void 0 : r.id), it = LW({
    measure: Te.dragOverlay.measure
  }), ht = (n = it.nodeRef.current) != null ? n : se, It = A ? (i = it.rect) != null ? i : le : null, Dn = !!(it.nodeRef.current && it.rect), tr = $W(Dn ? null : le), rr = xE(ht ? Fr(ht) : null), kt = BW(A ? Dt ?? se : null), $r = QW(kt), br = YW(g, {
    transform: {
      x: B.x - tr.x,
      y: B.y - tr.y,
      scaleX: 1,
      scaleY: 1
    },
    activatorEvent: H,
    active: J,
    activeNodeRect: le,
    containerNodeRect: De,
    draggingNodeRect: It,
    over: we.current.over,
    overlayNodeRect: it.rect,
    scrollableAncestors: kt,
    scrollableAncestorRects: $r,
    windowRect: rr
  }), tn = V ? za(V, B) : null, Br = IW(kt), Li = xx(Br), Sa = xx(Br, [le]), Ir = za(br, Li), Nt = It ? rW(It, br) : null, vn = J && Nt ? p({
    active: J,
    collisionRect: Nt,
    droppableRects: Me,
    droppableContainers: Ne,
    pointerCoordinates: tn
  }) : null, Ps = uE(vn, "id"), [L, ie] = At(null), pe = Dn ? br : za(br, Sa), Be = eW(pe, (s = L == null ? void 0 : L.rect) != null ? s : null, le), Ue = Ht(
    (Je, gt) => {
      let {
        sensor: Ct,
        options: Sn
      } = gt;
      if (R.current == null)
        return;
      const pr = $.get(R.current);
      if (!pr)
        return;
      const Nr = Je.nativeEvent, rn = new Ct({
        active: R.current,
        activeNode: pr,
        event: Nr,
        options: Sn,
        // Sensors need to be instantiated with refs for arguments that change over time
        // otherwise they are frozen in time with the stale arguments
        context: we,
        onStart(_r) {
          const gi = R.current;
          if (gi == null)
            return;
          const yi = $.get(gi);
          if (!yi)
            return;
          const {
            onDragStart: wa
          } = Ce.current, Ca = {
            active: {
              id: gi,
              data: yi.data,
              rect: Y
            }
          };
          Xo(() => {
            wa == null || wa(Ca), C(Ji.Initializing), S({
              type: $t.DragStart,
              initialCoordinates: _r,
              active: gi
            }), x({
              type: "onDragStart",
              event: Ca
            });
          });
        },
        onMove(_r) {
          S({
            type: $t.DragMove,
            coordinates: _r
          });
        },
        onEnd: Ri($t.DragEnd),
        onCancel: Ri($t.DragCancel)
      });
      Xo(() => {
        X(rn), ye(Je.nativeEvent);
      });
      function Ri(_r) {
        return async function() {
          const {
            active: yi,
            collisions: wa,
            over: Ca,
            scrollAdjustedTranslate: zu
          } = we.current;
          let ji = null;
          if (yi && zu) {
            const {
              cancelDrop: Fs
            } = Ce.current;
            ji = {
              activatorEvent: Nr,
              active: yi,
              collisions: wa,
              delta: zu,
              over: Ca
            }, _r === $t.DragEnd && typeof Fs == "function" && await Promise.resolve(Fs(ji)) && (_r = $t.DragCancel);
          }
          R.current = null, Xo(() => {
            S({
              type: _r
            }), C(Ji.Uninitialized), ie(null), X(null), ye(null);
            const Fs = _r === $t.DragEnd ? "onDragEnd" : "onDragCancel";
            if (ji) {
              const Oi = Ce.current[Fs];
              Oi == null || Oi(ji), x({
                type: Fs,
                event: ji
              });
            }
          });
        };
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [$]
  ), _e = Ht((Je, gt) => (Ct, Sn) => {
    const pr = Ct.nativeEvent, Nr = $.get(Sn);
    if (
      // Another sensor is already instantiating
      R.current !== null || // No active draggable
      !Nr || // Event has already been captured
      pr.dndKit || pr.defaultPrevented
    )
      return;
    const rn = {
      active: Nr
    };
    Je(Ct, gt.options, rn) === !0 && (pr.dndKit = {
      capturedBy: gt.sensor
    }, R.current = Sn, Ue(Ct, gt));
  }, [$, Ue]), Ie = AW(h, _e);
  NW(h), Nn(() => {
    le && T === Ji.Initializing && C(Ji.Initialized);
  }, [le, T]), Qe(
    () => {
      const {
        onDragMove: Je
      } = Ce.current, {
        active: gt,
        activatorEvent: Ct,
        collisions: Sn,
        over: pr
      } = we.current;
      if (!gt || !Ct)
        return;
      const Nr = {
        active: gt,
        activatorEvent: Ct,
        collisions: Sn,
        delta: {
          x: Ir.x,
          y: Ir.y
        },
        over: pr
      };
      Xo(() => {
        Je == null || Je(Nr), x({
          type: "onDragMove",
          event: Nr
        });
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [Ir.x, Ir.y]
  ), Qe(
    () => {
      const {
        active: Je,
        activatorEvent: gt,
        collisions: Ct,
        droppableContainers: Sn,
        scrollAdjustedTranslate: pr
      } = we.current;
      if (!Je || R.current == null || !gt || !pr)
        return;
      const {
        onDragOver: Nr
      } = Ce.current, rn = Sn.get(Ps), Ri = rn && rn.rect.current ? {
        id: rn.id,
        rect: rn.rect.current,
        data: rn.data,
        disabled: rn.disabled
      } : null, _r = {
        active: Je,
        activatorEvent: gt,
        collisions: Ct,
        delta: {
          x: pr.x,
          y: pr.y
        },
        over: Ri
      };
      Xo(() => {
        ie(Ri), Nr == null || Nr(_r), x({
          type: "onDragOver",
          event: _r
        });
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [Ps]
  ), Nn(() => {
    we.current = {
      activatorEvent: H,
      active: J,
      activeNode: se,
      collisionRect: Nt,
      collisions: vn,
      droppableRects: Me,
      draggableNodes: $,
      draggingNode: ht,
      draggingNodeRect: It,
      droppableContainers: _,
      over: L,
      scrollableAncestors: kt,
      scrollAdjustedTranslate: Ir
    }, Y.current = {
      initial: It,
      translated: Nt
    };
  }, [J, se, vn, Nt, $, ht, It, Me, _, L, kt, Ir]), SW({
    ...W,
    delta: B,
    draggingRect: Nt,
    pointerCoordinates: tn,
    scrollableAncestors: kt,
    scrollableAncestorRects: $r
  });
  const ke = Ke(() => ({
    active: J,
    activeNode: se,
    activeNodeRect: le,
    activatorEvent: H,
    collisions: vn,
    containerNodeRect: De,
    dragOverlay: it,
    draggableNodes: $,
    droppableContainers: _,
    droppableRects: Me,
    over: L,
    measureDroppableContainers: Ee,
    scrollableAncestors: kt,
    scrollableAncestorRects: $r,
    measuringConfiguration: Te,
    measuringScheduled: nt,
    windowRect: rr
  }), [J, se, le, H, vn, De, it, $, _, Me, L, Ee, kt, $r, Te, nt, rr]), _t = Ke(() => ({
    activatorEvent: H,
    activators: Ie,
    active: J,
    activeNodeRect: le,
    ariaDescribedById: {
      draggable: Se
    },
    dispatch: S,
    draggableNodes: $,
    over: L,
    measureDroppableContainers: Ee
  }), [H, Ie, J, le, S, Se, $, L, Ee]);
  return sr.createElement(aE.Provider, {
    value: w
  }, sr.createElement(td.Provider, {
    value: _t
  }, sr.createElement(bE.Provider, {
    value: ke
  }, sr.createElement(DE.Provider, {
    value: Be
  }, c)), sr.createElement(VW, {
    disabled: (o == null ? void 0 : o.restoreFocus) === !1
  })), sr.createElement(YZ, {
    ...o,
    hiddenTextDescribedById: Se
  }));
  function Dr() {
    const Je = (q == null ? void 0 : q.autoScrollEnabled) === !1, gt = typeof u == "object" ? u.enabled === !1 : u === !1, Ct = A && !Je && !gt;
    return typeof u == "object" ? {
      ...u,
      enabled: Ct
    } : {
      enabled: Ct
    };
  }
}), HW = /* @__PURE__ */ bo(null), bx = "button", JW = "Droppable";
function KW(t) {
  let {
    id: e,
    data: r,
    disabled: n = !1,
    attributes: i
  } = t;
  const s = Nu(JW), {
    activators: a,
    activatorEvent: o,
    active: u,
    activeNodeRect: c,
    ariaDescribedById: h,
    draggableNodes: p,
    over: m
  } = hs(td), {
    role: g = bx,
    roleDescription: O = "draggable",
    tabIndex: b = 0
  } = i ?? {}, D = (u == null ? void 0 : u.id) === e, S = hs(D ? DE : HW), [x, w] = Th(), [T, C] = Th(), A = _W(a, e), P = Ul(r);
  Nn(
    () => (p.set(e, {
      id: e,
      key: s,
      node: x,
      activatorNode: T,
      data: P
    }), () => {
      const B = p.get(e);
      B && B.key === s && p.delete(e);
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [p, e]
  );
  const $ = Ke(() => ({
    role: g,
    tabIndex: b,
    "aria-disabled": n,
    "aria-pressed": D && g === bx ? !0 : void 0,
    "aria-roledescription": O,
    "aria-describedby": h.draggable
  }), [n, g, b, D, O, h.draggable]);
  return {
    active: u,
    activatorEvent: o,
    activeNodeRect: c,
    attributes: $,
    isDragging: D,
    listeners: n ? void 0 : A,
    node: x,
    over: m,
    setNodeRef: w,
    setActivatorNodeRef: C,
    transform: S
  };
}
function eq() {
  return hs(bE);
}
const tq = "Droppable", rq = {
  timeout: 25
};
function nq(t) {
  let {
    data: e,
    disabled: r = !1,
    id: n,
    resizeObserverConfig: i
  } = t;
  const s = Nu(tq), {
    active: a,
    dispatch: o,
    over: u,
    measureDroppableContainers: c
  } = hs(td), h = et({
    disabled: r
  }), p = et(!1), m = et(null), g = et(null), {
    disabled: O,
    updateMeasurementsFor: b,
    timeout: D
  } = {
    ...rq,
    ...i
  }, S = Ul(b ?? n), x = Ht(
    () => {
      if (!p.current) {
        p.current = !0;
        return;
      }
      g.current != null && clearTimeout(g.current), g.current = setTimeout(() => {
        c(Array.isArray(S.current) ? S.current : [S.current]), g.current = null;
      }, D);
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [D]
  ), w = ed({
    callback: x,
    disabled: O || !a
  }), T = Ht(($, B) => {
    w && (B && (w.unobserve(B), p.current = !1), $ && w.observe($));
  }, [w]), [C, A] = Th(T), P = Ul(e);
  return Qe(() => {
    !w || !C.current || (w.disconnect(), p.current = !1, w.observe(C.current));
  }, [C, w]), Nn(
    () => (o({
      type: $t.RegisterDroppable,
      element: {
        id: n,
        key: s,
        disabled: r,
        node: C,
        rect: m,
        data: P
      }
    }), () => o({
      type: $t.UnregisterDroppable,
      key: s,
      id: n
    })),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [n]
  ), Qe(() => {
    r !== h.current.disabled && (o({
      type: $t.SetDroppableDisabled,
      id: n,
      key: s,
      disabled: r
    }), h.current.disabled = r);
  }, [n, s, r, o]), {
    active: a,
    rect: m,
    isOver: (u == null ? void 0 : u.id) === n,
    node: C,
    over: u,
    setNodeRef: A
  };
}
function O0(t, e, r) {
  const n = t.slice();
  return n.splice(r < 0 ? n.length + r : r, 0, n.splice(e, 1)[0]), n;
}
function iq(t, e) {
  return t.reduce((r, n, i) => {
    const s = e.get(n);
    return s && (r[i] = s), r;
  }, Array(t.length));
}
function bc(t) {
  return t !== null && t >= 0;
}
function sq(t, e) {
  if (t === e)
    return !0;
  if (t.length !== e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function aq(t) {
  return typeof t == "boolean" ? {
    draggable: t,
    droppable: t
  } : t;
}
const Dc = {
  scaleX: 1,
  scaleY: 1
}, oq = (t) => {
  var e;
  let {
    rects: r,
    activeNodeRect: n,
    activeIndex: i,
    overIndex: s,
    index: a
  } = t;
  const o = (e = r[i]) != null ? e : n;
  if (!o)
    return null;
  const u = lq(r, a, i);
  if (a === i) {
    const c = r[s];
    return c ? {
      x: i < s ? c.left + c.width - (o.left + o.width) : c.left - o.left,
      y: 0,
      ...Dc
    } : null;
  }
  return a > i && a <= s ? {
    x: -o.width - u,
    y: 0,
    ...Dc
  } : a < i && a >= s ? {
    x: o.width + u,
    y: 0,
    ...Dc
  } : {
    x: 0,
    y: 0,
    ...Dc
  };
};
function lq(t, e, r) {
  const n = t[e], i = t[e - 1], s = t[e + 1];
  return !n || !i && !s ? 0 : r < e ? i ? n.left - (i.left + i.width) : s.left - (n.left + n.width) : s ? s.left - (n.left + n.width) : n.left - (i.left + i.width);
}
const vE = (t) => {
  let {
    rects: e,
    activeIndex: r,
    overIndex: n,
    index: i
  } = t;
  const s = O0(e, n, r), a = e[i], o = s[i];
  return !o || !a ? null : {
    x: o.left - a.left,
    y: o.top - a.top,
    scaleX: o.width / a.width,
    scaleY: o.height / a.height
  };
}, SE = "Sortable", wE = /* @__PURE__ */ sr.createContext({
  activeIndex: -1,
  containerId: SE,
  disableTransforms: !1,
  items: [],
  overIndex: -1,
  useDragOverlay: !1,
  sortedRects: [],
  strategy: vE,
  disabled: {
    draggable: !1,
    droppable: !1
  }
});
function uq(t) {
  let {
    children: e,
    id: r,
    items: n,
    strategy: i = vE,
    disabled: s = !1
  } = t;
  const {
    active: a,
    dragOverlay: o,
    droppableRects: u,
    over: c,
    measureDroppableContainers: h
  } = eq(), p = Nu(SE, r), m = o.rect !== null, g = Ke(() => n.map((A) => typeof A == "object" && "id" in A ? A.id : A), [n]), O = a != null, b = a ? g.indexOf(a.id) : -1, D = c ? g.indexOf(c.id) : -1, S = et(g), x = !sq(g, S.current), w = D !== -1 && b === -1 || x, T = aq(s);
  Nn(() => {
    x && O && h(g);
  }, [x, g, O, h]), Qe(() => {
    S.current = g;
  }, [g]);
  const C = Ke(
    () => ({
      activeIndex: b,
      containerId: p,
      disabled: T,
      disableTransforms: w,
      items: g,
      overIndex: D,
      useDragOverlay: m,
      sortedRects: iq(g, u),
      strategy: i
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [b, p, T.draggable, T.droppable, w, g, D, u, m, i]
  );
  return sr.createElement(wE.Provider, {
    value: C
  }, e);
}
const cq = (t) => {
  let {
    id: e,
    items: r,
    activeIndex: n,
    overIndex: i
  } = t;
  return O0(r, n, i).indexOf(e);
}, hq = (t) => {
  let {
    containerId: e,
    isSorting: r,
    wasDragging: n,
    index: i,
    items: s,
    newIndex: a,
    previousItems: o,
    previousContainerId: u,
    transition: c
  } = t;
  return !c || !n || o !== s && i === a ? !1 : r ? !0 : a !== i && e === u;
}, pq = {
  duration: 200,
  easing: "ease"
}, CE = "transform", dq = /* @__PURE__ */ Gl.Transition.toString({
  property: CE,
  duration: 0,
  easing: "linear"
}), fq = {
  roleDescription: "sortable"
};
function mq(t) {
  let {
    disabled: e,
    index: r,
    node: n,
    rect: i
  } = t;
  const [s, a] = At(null), o = et(r);
  return Nn(() => {
    if (!e && r !== o.current && n.current) {
      const u = i.current;
      if (u) {
        const c = _o(n.current, {
          ignoreTransform: !0
        }), h = {
          x: u.left - c.left,
          y: u.top - c.top,
          scaleX: u.width / c.width,
          scaleY: u.height / c.height
        };
        (h.x || h.y) && a(h);
      }
    }
    r !== o.current && (o.current = r);
  }, [e, r, n, i]), Qe(() => {
    s && a(null);
  }, [s]), s;
}
function gq(t) {
  let {
    animateLayoutChanges: e = hq,
    attributes: r,
    disabled: n,
    data: i,
    getNewIndex: s = cq,
    id: a,
    strategy: o,
    resizeObserverConfig: u,
    transition: c = pq
  } = t;
  const {
    items: h,
    containerId: p,
    activeIndex: m,
    disabled: g,
    disableTransforms: O,
    sortedRects: b,
    overIndex: D,
    useDragOverlay: S,
    strategy: x
  } = hs(wE), w = yq(n, g), T = h.indexOf(a), C = Ke(() => ({
    sortable: {
      containerId: p,
      index: T,
      items: h
    },
    ...i
  }), [p, i, T, h]), A = Ke(() => h.slice(h.indexOf(a)), [h, a]), {
    rect: P,
    node: $,
    isOver: B,
    setNodeRef: _
  } = nq({
    id: a,
    data: C,
    disabled: w.droppable,
    resizeObserverConfig: {
      updateMeasurementsFor: A,
      ...u
    }
  }), {
    active: M,
    activatorEvent: Y,
    activeNodeRect: J,
    attributes: R,
    setNodeRef: q,
    listeners: X,
    isDragging: H,
    over: ye,
    setActivatorNodeRef: Ce,
    transform: Se
  } = KW({
    id: a,
    data: C,
    attributes: {
      ...fq,
      ...r
    },
    disabled: w.draggable
  }), Ne = IZ(_, q), Te = !!M, Me = Te && !O && bc(m) && bc(D), Ee = !S && H, nt = Ee && Me ? Se : null, V = Me ? nt ?? (o ?? x)({
    rects: b,
    activeNodeRect: J,
    activeIndex: m,
    overIndex: D,
    index: T
  }) : null, W = bc(m) && bc(D) ? s({
    id: a,
    items: h,
    activeIndex: m,
    overIndex: D
  }) : T, j = M == null ? void 0 : M.id, le = et({
    activeId: j,
    items: h,
    newIndex: W,
    containerId: p
  }), De = h !== le.current.items, we = e({
    active: M,
    containerId: p,
    isDragging: H,
    isSorting: Te,
    id: a,
    index: T,
    items: h,
    newIndex: le.current.newIndex,
    previousItems: le.current.items,
    previousContainerId: le.current.containerId,
    transition: c,
    wasDragging: le.current.activeId != null
  }), Dt = mq({
    disabled: !we,
    index: T,
    node: $,
    rect: P
  });
  return Qe(() => {
    Te && le.current.newIndex !== W && (le.current.newIndex = W), p !== le.current.containerId && (le.current.containerId = p), h !== le.current.items && (le.current.items = h);
  }, [Te, W, p, h]), Qe(() => {
    if (j === le.current.activeId)
      return;
    if (j && !le.current.activeId) {
      le.current.activeId = j;
      return;
    }
    const ht = setTimeout(() => {
      le.current.activeId = j;
    }, 50);
    return () => clearTimeout(ht);
  }, [j]), {
    active: M,
    activeIndex: m,
    attributes: R,
    data: C,
    rect: P,
    index: T,
    newIndex: W,
    items: h,
    isOver: B,
    isSorting: Te,
    isDragging: H,
    listeners: X,
    node: $,
    overIndex: D,
    over: ye,
    setNodeRef: Ne,
    setActivatorNodeRef: Ce,
    setDroppableNodeRef: _,
    setDraggableNodeRef: q,
    transform: Dt ?? V,
    transition: it()
  };
  function it() {
    if (
      // Temporarily disable transitions for a single frame to set up derived transforms
      Dt || // Or to prevent items jumping to back to their "new" position when items change
      De && le.current.newIndex === T
    )
      return dq;
    if (!(Ee && !d0(Y) || !c) && (Te || we))
      return Gl.Transition.toString({
        ...c,
        property: CE
      });
  }
}
function yq(t, e) {
  var r, n;
  return typeof t == "boolean" ? {
    draggable: t,
    // Backwards compatibility
    droppable: !1
  } : {
    draggable: (r = t == null ? void 0 : t.draggable) != null ? r : e.draggable,
    droppable: (n = t == null ? void 0 : t.droppable) != null ? n : e.droppable
  };
}
function Fh(t) {
  if (!t)
    return !1;
  const e = t.data.current;
  return !!(e && "sortable" in e && typeof e.sortable == "object" && "containerId" in e.sortable && "items" in e.sortable && "index" in e.sortable);
}
const Oq = [Ze.Down, Ze.Right, Ze.Up, Ze.Left], xq = (t, e) => {
  let {
    context: {
      active: r,
      collisionRect: n,
      droppableRects: i,
      droppableContainers: s,
      over: a,
      scrollableAncestors: o
    }
  } = e;
  if (Oq.includes(t.code)) {
    if (t.preventDefault(), !r || !n)
      return;
    const u = [];
    s.getEnabled().forEach((p) => {
      if (!p || p != null && p.disabled)
        return;
      const m = i.get(p.id);
      if (m)
        switch (t.code) {
          case Ze.Down:
            n.top < m.top && u.push(p);
            break;
          case Ze.Up:
            n.top > m.top && u.push(p);
            break;
          case Ze.Left:
            n.left > m.left && u.push(p);
            break;
          case Ze.Right:
            n.left < m.left && u.push(p);
            break;
        }
    });
    const c = HZ({
      active: r,
      collisionRect: n,
      droppableRects: i,
      droppableContainers: u,
      pointerCoordinates: null
    });
    let h = uE(c, "id");
    if (h === (a == null ? void 0 : a.id) && c.length > 1 && (h = c[1].id), h != null) {
      const p = s.get(r.id), m = s.get(h), g = m ? i.get(m.id) : null, O = m == null ? void 0 : m.node.current;
      if (O && g && p && m) {
        const D = Kp(O).some((A, P) => o[P] !== A), S = EE(p, m), x = bq(p, m), w = D || !S ? {
          x: 0,
          y: 0
        } : {
          x: x ? n.width - g.width : 0,
          y: x ? n.height - g.height : 0
        }, T = {
          x: g.left,
          y: g.top
        };
        return w.x && w.y ? T : zl(T, w);
      }
    }
  }
};
function EE(t, e) {
  return !Fh(t) || !Fh(e) ? !1 : t.data.current.sortable.containerId === e.data.current.sortable.containerId;
}
function bq(t, e) {
  return !Fh(t) || !Fh(e) || !EE(t, e) ? !1 : t.data.current.sortable.index < e.data.current.sortable.index;
}
const Dq = (t) => {
  let {
    transform: e
  } = t;
  return {
    ...e,
    y: 0
  };
};
function vq(t, e, r) {
  const n = {
    ...t
  };
  return e.top + t.y <= r.top ? n.y = r.top - e.top : e.bottom + t.y >= r.top + r.height && (n.y = r.top + r.height - e.bottom), e.left + t.x <= r.left ? n.x = r.left - e.left : e.right + t.x >= r.left + r.width && (n.x = r.left + r.width - e.right), n;
}
const Sq = (t) => {
  let {
    containerNodeRect: e,
    draggingNodeRect: r,
    transform: n
  } = t;
  return !r || !e ? n : vq(n, r, e);
}, wq = ({
  file: t
}) => {
  const { closeFile: e, setActiveFile: r } = kr(), { attributes: n, listeners: i, setNodeRef: s, transform: a, transition: o } = gq({ id: t.id }), u = {
    transform: Gl.Transform.toString(a),
    transition: o
  };
  return /* @__PURE__ */ z.jsx("div", { ref: s, style: u, ...n, ...i, children: /* @__PURE__ */ z.jsxs("div", { className: `file-tab ${t.active ? "active" : ""}`, children: [
    /* @__PURE__ */ z.jsxs("span", { onClick: () => r(t.id), children: [
      /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-file" }),
      "",
      t.name
    ] }),
    /* @__PURE__ */ z.jsx(
      "button",
      {
        type: "button",
        className: "inline-button",
        onClick: () => e(t.id),
        children: /* @__PURE__ */ z.jsx("i", { className: "fa-solid fa-x" })
      }
    )
  ] }, t.id) });
}, Cq = () => {
  const { project: t } = kr(), e = rE(t.files, { mustBeOpen: !0 }), [r, n] = At(e), i = UZ(
    ux(y0),
    ux(m0, {
      coordinateGetter: xq
    })
  );
  function s(a) {
    const { active: o, over: u } = a;
    o.id !== u.id && n((c) => {
      const h = c.indexOf(c.find((m) => m.id === o.id)), p = c.indexOf(c.find((m) => m.id === u.id));
      return O0(c, h, p);
    });
  }
  return /* @__PURE__ */ z.jsx("div", { className: "files-nav-bar", children: /* @__PURE__ */ z.jsx(
    GW,
    {
      onDragEnd: s,
      sensors: i,
      collisionDetection: GZ,
      modifiers: [Sq, Dq],
      children: /* @__PURE__ */ z.jsx(uq, { items: r, strategy: oq, children: r.map((a) => /* @__PURE__ */ z.jsx(wq, { file: a }, a.id)) })
    }
  ) });
};
function Pm() {
  return Pm = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
    }
    return t;
  }, Pm.apply(this, arguments);
}
function Eq(t, e) {
  if (t == null)
    return {};
  var r = {}, n = Object.keys(t), i, s;
  for (s = 0; s < n.length; s++)
    i = n[s], !(e.indexOf(i) >= 0) && (r[i] = t[i]);
  return r;
}
class Xe {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, r, n) {
    [e, r] = ho(this, e, r);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), n.length && n.decompose(
      0,
      n.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      r,
      this.length,
      i,
      1
      /* Open.From */
    ), zn.from(i, this.length - (r - e) + n.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, r = this.length) {
    [e, r] = ho(this, e, r);
    let n = [];
    return this.decompose(e, r, n, 0), zn.from(n, r - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let r = this.scanIdentical(e, 1), n = this.length - this.scanIdentical(e, -1), i = new Bl(this), s = new Bl(e);
    for (let a = r, o = r; ; ) {
      if (i.next(a), s.next(a), a = 0, i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)
        return !1;
      if (o += i.value.length, i.done || o >= n)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Bl(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, r = this.length) {
    return new AE(this, e, r);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, r) {
    let n;
    if (e == null)
      n = this.iter();
    else {
      r == null && (r = this.lines + 1);
      let i = this.line(e).from;
      n = this.iterRange(i, Math.max(i, r == this.lines + 1 ? this.length : r <= 1 ? 0 : this.line(r - 1).to));
    }
    return new TE(n);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? Xe.empty : e.length <= 32 ? new vt(e) : zn.from(vt.split(e, []));
  }
}
class vt extends Xe {
  constructor(e, r = Aq(e)) {
    super(), this.text = e, this.length = r;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, r, n, i) {
    for (let s = 0; ; s++) {
      let a = this.text[s], o = i + a.length;
      if ((r ? n : o) >= e)
        return new Tq(i, o, n, a);
      i = o + 1, n++;
    }
  }
  decompose(e, r, n, i) {
    let s = e <= 0 && r >= this.length ? this : new vt(Dx(this.text, e, r), Math.min(r, this.length) - Math.max(0, e));
    if (i & 1) {
      let a = n.pop(), o = th(s.text, a.text.slice(), 0, s.length);
      if (o.length <= 32)
        n.push(new vt(o, a.length + s.length));
      else {
        let u = o.length >> 1;
        n.push(new vt(o.slice(0, u)), new vt(o.slice(u)));
      }
    } else
      n.push(s);
  }
  replace(e, r, n) {
    if (!(n instanceof vt))
      return super.replace(e, r, n);
    [e, r] = ho(this, e, r);
    let i = th(this.text, th(n.text, Dx(this.text, 0, e)), r), s = this.length + n.length - (r - e);
    return i.length <= 32 ? new vt(i, s) : zn.from(vt.split(i, []), s);
  }
  sliceString(e, r = this.length, n = `
`) {
    [e, r] = ho(this, e, r);
    let i = "";
    for (let s = 0, a = 0; s <= r && a < this.text.length; a++) {
      let o = this.text[a], u = s + o.length;
      s > e && a && (i += n), e < u && r > s && (i += o.slice(Math.max(0, e - s), r - s)), s = u + 1;
    }
    return i;
  }
  flatten(e) {
    for (let r of this.text)
      e.push(r);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, r) {
    let n = [], i = -1;
    for (let s of e)
      n.push(s), i += s.length + 1, n.length == 32 && (r.push(new vt(n, i)), n = [], i = -1);
    return i > -1 && r.push(new vt(n, i)), r;
  }
}
class zn extends Xe {
  constructor(e, r) {
    super(), this.children = e, this.length = r, this.lines = 0;
    for (let n of e)
      this.lines += n.lines;
  }
  lineInner(e, r, n, i) {
    for (let s = 0; ; s++) {
      let a = this.children[s], o = i + a.length, u = n + a.lines - 1;
      if ((r ? u : o) >= e)
        return a.lineInner(e, r, n, i);
      i = o + 1, n = u + 1;
    }
  }
  decompose(e, r, n, i) {
    for (let s = 0, a = 0; a <= r && s < this.children.length; s++) {
      let o = this.children[s], u = a + o.length;
      if (e <= u && r >= a) {
        let c = i & ((a <= e ? 1 : 0) | (u >= r ? 2 : 0));
        a >= e && u <= r && !c ? n.push(o) : o.decompose(e - a, r - a, n, c);
      }
      a = u + 1;
    }
  }
  replace(e, r, n) {
    if ([e, r] = ho(this, e, r), n.lines < this.lines)
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let a = this.children[i], o = s + a.length;
        if (e >= s && r <= o) {
          let u = a.replace(e - s, r - s, n), c = this.lines - a.lines + u.lines;
          if (u.lines < c >> 4 && u.lines > c >> 6) {
            let h = this.children.slice();
            return h[i] = u, new zn(h, this.length - (r - e) + n.length);
          }
          return super.replace(s, o, u);
        }
        s = o + 1;
      }
    return super.replace(e, r, n);
  }
  sliceString(e, r = this.length, n = `
`) {
    [e, r] = ho(this, e, r);
    let i = "";
    for (let s = 0, a = 0; s < this.children.length && a <= r; s++) {
      let o = this.children[s], u = a + o.length;
      a > e && s && (i += n), e < u && r > a && (i += o.sliceString(e - a, r - a, n)), a = u + 1;
    }
    return i;
  }
  flatten(e) {
    for (let r of this.children)
      r.flatten(e);
  }
  scanIdentical(e, r) {
    if (!(e instanceof zn))
      return 0;
    let n = 0, [i, s, a, o] = r > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += r, s += r) {
      if (i == a || s == o)
        return n;
      let u = this.children[i], c = e.children[s];
      if (u != c)
        return n + u.scanIdentical(c, r);
      n += u.length + 1;
    }
  }
  static from(e, r = e.reduce((n, i) => n + i.length + 1, -1)) {
    let n = 0;
    for (let g of e)
      n += g.lines;
    if (n < 32) {
      let g = [];
      for (let O of e)
        O.flatten(g);
      return new vt(g, r);
    }
    let i = Math.max(
      32,
      n >> 5
      /* Tree.BranchShift */
    ), s = i << 1, a = i >> 1, o = [], u = 0, c = -1, h = [];
    function p(g) {
      let O;
      if (g.lines > s && g instanceof zn)
        for (let b of g.children)
          p(b);
      else
        g.lines > a && (u > a || !u) ? (m(), o.push(g)) : g instanceof vt && u && (O = h[h.length - 1]) instanceof vt && g.lines + O.lines <= 32 ? (u += g.lines, c += g.length + 1, h[h.length - 1] = new vt(O.text.concat(g.text), O.length + 1 + g.length)) : (u + g.lines > i && m(), u += g.lines, c += g.length + 1, h.push(g));
    }
    function m() {
      u != 0 && (o.push(h.length == 1 ? h[0] : zn.from(h, c)), c = -1, u = h.length = 0);
    }
    for (let g of e)
      p(g);
    return m(), o.length == 1 ? o[0] : new zn(o, r);
  }
}
Xe.empty = /* @__PURE__ */ new vt([""], 0);
function Aq(t) {
  let e = -1;
  for (let r of t)
    e += r.length + 1;
  return e;
}
function th(t, e, r = 0, n = 1e9) {
  for (let i = 0, s = 0, a = !0; s < t.length && i <= n; s++) {
    let o = t[s], u = i + o.length;
    u >= r && (u > n && (o = o.slice(0, n - i)), i < r && (o = o.slice(r - i)), a ? (e[e.length - 1] += o, a = !1) : e.push(o)), i = u + 1;
  }
  return e;
}
function Dx(t, e, r) {
  return th(t, [""], e, r);
}
class Bl {
  constructor(e, r = 1) {
    this.dir = r, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [r > 0 ? 1 : (e instanceof vt ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, r) {
    for (this.done = this.lineBreak = !1; ; ) {
      let n = this.nodes.length - 1, i = this.nodes[n], s = this.offsets[n], a = s >> 1, o = i instanceof vt ? i.text.length : i.children.length;
      if (a == (r > 0 ? o : 0)) {
        if (n == 0)
          return this.done = !0, this.value = "", this;
        r > 0 && this.offsets[n - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (r > 0 ? 0 : 1)) {
        if (this.offsets[n] += r, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof vt) {
        let u = i.text[a + (r < 0 ? -1 : 0)];
        if (this.offsets[n] += r, u.length > Math.max(0, e))
          return this.value = e == 0 ? u : r > 0 ? u.slice(e) : u.slice(0, u.length - e), this;
        e -= u.length;
      } else {
        let u = i.children[a + (r < 0 ? -1 : 0)];
        e > u.length ? (e -= u.length, this.offsets[n] += r) : (r < 0 && this.offsets[n]--, this.nodes.push(u), this.offsets.push(r > 0 ? 1 : (u instanceof vt ? u.text.length : u.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class AE {
  constructor(e, r, n) {
    this.value = "", this.done = !1, this.cursor = new Bl(e, r > n ? -1 : 1), this.pos = r > n ? e.length : 0, this.from = Math.min(r, n), this.to = Math.max(r, n);
  }
  nextInner(e, r) {
    if (r < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, r < 0 ? this.pos - this.to : this.from - this.pos);
    let n = r < 0 ? this.pos - this.from : this.to - this.pos;
    e > n && (e = n), n -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * r, this.value = i.length <= n ? i : r < 0 ? i.slice(i.length - n) : i.slice(0, n), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class TE {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: r, lineBreak: n, value: i } = this.inner.next(e);
    return r && this.afterBreak ? (this.value = "", this.afterBreak = !1) : r ? (this.done = !0, this.value = "") : n ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Xe.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Bl.prototype[Symbol.iterator] = AE.prototype[Symbol.iterator] = TE.prototype[Symbol.iterator] = function() {
  return this;
});
class Tq {
  /**
  @internal
  */
  constructor(e, r, n, i) {
    this.from = e, this.to = r, this.number = n, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function ho(t, e, r) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, r))];
}
let Ga = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
for (let t = 1; t < Ga.length; t++)
  Ga[t] += Ga[t - 1];
function kq(t) {
  for (let e = 1; e < Ga.length; e += 2)
    if (Ga[e] > t)
      return Ga[e - 1] <= t;
  return !1;
}
function vx(t) {
  return t >= 127462 && t <= 127487;
}
const Sx = 8205;
function Ut(t, e, r = !0, n = !0) {
  return (r ? kE : Pq)(t, e, n);
}
function kE(t, e, r) {
  if (e == t.length)
    return e;
  e && PE(t.charCodeAt(e)) && FE(t.charCodeAt(e - 1)) && e--;
  let n = Wt(t, e);
  for (e += ln(n); e < t.length; ) {
    let i = Wt(t, e);
    if (n == Sx || i == Sx || r && kq(i))
      e += ln(i), n = i;
    else if (vx(i)) {
      let s = 0, a = e - 2;
      for (; a >= 0 && vx(Wt(t, a)); )
        s++, a -= 2;
      if (s % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function Pq(t, e, r) {
  for (; e > 0; ) {
    let n = kE(t, e - 2, r);
    if (n < e)
      return n;
    e--;
  }
  return 0;
}
function PE(t) {
  return t >= 56320 && t < 57344;
}
function FE(t) {
  return t >= 55296 && t < 56320;
}
function Wt(t, e) {
  let r = t.charCodeAt(e);
  if (!FE(r) || e + 1 == t.length)
    return r;
  let n = t.charCodeAt(e + 1);
  return PE(n) ? (r - 55296 << 10) + (n - 56320) + 65536 : r;
}
function x0(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function ln(t) {
  return t < 65536 ? 1 : 2;
}
const Fm = /\r\n?|\n/;
var Vt = /* @__PURE__ */ function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
}(Vt || (Vt = {}));
class ni {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2)
      e += this.sections[r];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2) {
      let n = this.sections[r + 1];
      e += n < 0 ? this.sections[r] : n;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let r = 0, n = 0, i = 0; r < this.sections.length; ) {
      let s = this.sections[r++], a = this.sections[r++];
      a < 0 ? (e(n, i, s), i += s) : i += a, n += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, r = !1) {
    $m(this, e, r);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let r = 0; r < this.sections.length; ) {
      let n = this.sections[r++], i = this.sections[r++];
      i < 0 ? e.push(n, i) : e.push(i, n);
    }
    return new ni(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : $E(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, r = !1) {
    return e.empty ? this : Bm(this, e, r);
  }
  mapPos(e, r = -1, n = Vt.Simple) {
    let i = 0, s = 0;
    for (let a = 0; a < this.sections.length; ) {
      let o = this.sections[a++], u = this.sections[a++], c = i + o;
      if (u < 0) {
        if (c > e)
          return s + (e - i);
        s += o;
      } else {
        if (n != Vt.Simple && c >= e && (n == Vt.TrackDel && i < e && c > e || n == Vt.TrackBefore && i < e || n == Vt.TrackAfter && c > e))
          return null;
        if (c > e || c == e && r < 0 && !o)
          return e == i || r < 0 ? s : s + u;
        s += u;
      }
      i = c;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, r = e) {
    for (let n = 0, i = 0; n < this.sections.length && i <= r; ) {
      let s = this.sections[n++], a = this.sections[n++], o = i + s;
      if (a >= 0 && i <= r && o >= e)
        return i < e && o > r ? "cover" : !0;
      i = o;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let r = 0; r < this.sections.length; ) {
      let n = this.sections[r++], i = this.sections[r++];
      e += (e ? " " : "") + n + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((r) => typeof r != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ni(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new ni(e);
  }
}
class Bt extends ni {
  constructor(e, r) {
    super(e), this.inserted = r;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return $m(this, (r, n, i, s, a) => e = e.replace(i, i + (n - r), a), !1), e;
  }
  mapDesc(e, r = !1) {
    return Bm(this, e, r, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let r = this.sections.slice(), n = [];
    for (let i = 0, s = 0; i < r.length; i += 2) {
      let a = r[i], o = r[i + 1];
      if (o >= 0) {
        r[i] = o, r[i + 1] = a;
        let u = i >> 1;
        for (; n.length < u; )
          n.push(Xe.empty);
        n.push(a ? e.slice(s, s + a) : Xe.empty);
      }
      s += a;
    }
    return new Bt(r, n);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : $E(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, r = !1) {
    return e.empty ? this : Bm(this, e, r, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, r = !1) {
    $m(this, e, r);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return ni.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let r = [], n = [], i = [], s = new Jl(this);
    e:
      for (let a = 0, o = 0; ; ) {
        let u = a == e.length ? 1e9 : e[a++];
        for (; o < u || o == u && s.len == 0; ) {
          if (s.done)
            break e;
          let h = Math.min(s.len, u - o);
          ir(i, h, -1);
          let p = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
          ir(r, h, p), p > 0 && is(n, r, s.text), s.forward(h), o += h;
        }
        let c = e[a++];
        for (; o < c; ) {
          if (s.done)
            break e;
          let h = Math.min(s.len, c - o);
          ir(r, h, -1), ir(i, h, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(h), o += h;
        }
      }
    return {
      changes: new Bt(r, n),
      filtered: ni.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let r = 0; r < this.sections.length; r += 2) {
      let n = this.sections[r], i = this.sections[r + 1];
      i < 0 ? e.push(n) : i == 0 ? e.push([n]) : e.push([n].concat(this.inserted[r >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, r, n) {
    let i = [], s = [], a = 0, o = null;
    function u(h = !1) {
      if (!h && !i.length)
        return;
      a < r && ir(i, r - a, -1);
      let p = new Bt(i, s);
      o = o ? o.compose(p.map(o)) : p, i = [], s = [], a = 0;
    }
    function c(h) {
      if (Array.isArray(h))
        for (let p of h)
          c(p);
      else if (h instanceof Bt) {
        if (h.length != r)
          throw new RangeError(`Mismatched change set length (got ${h.length}, expected ${r})`);
        u(), o = o ? o.compose(h.map(o)) : h;
      } else {
        let { from: p, to: m = p, insert: g } = h;
        if (p > m || p < 0 || m > r)
          throw new RangeError(`Invalid change range ${p} to ${m} (in doc of length ${r})`);
        let O = g ? typeof g == "string" ? Xe.of(g.split(n || Fm)) : g : Xe.empty, b = O.length;
        if (p == m && b == 0)
          return;
        p < a && u(), p > a && ir(i, p - a, -1), ir(i, m - p, b), is(s, i, O), a = m;
      }
    }
    return c(e), u(!o), o;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new Bt(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let r = [], n = [];
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (typeof s == "number")
        r.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((a, o) => o && typeof a != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          r.push(s[0], 0);
        else {
          for (; n.length < i; )
            n.push(Xe.empty);
          n[i] = Xe.of(s.slice(1)), r.push(s[0], n[i].length);
        }
      }
    }
    return new Bt(r, n);
  }
  /**
  @internal
  */
  static createSet(e, r) {
    return new Bt(e, r);
  }
}
function ir(t, e, r, n = !1) {
  if (e == 0 && r <= 0)
    return;
  let i = t.length - 2;
  i >= 0 && r <= 0 && r == t[i + 1] ? t[i] += e : e == 0 && t[i] == 0 ? t[i + 1] += r : n ? (t[i] += e, t[i + 1] += r) : t.push(e, r);
}
function is(t, e, r) {
  if (r.length == 0)
    return;
  let n = e.length - 2 >> 1;
  if (n < t.length)
    t[t.length - 1] = t[t.length - 1].append(r);
  else {
    for (; t.length < n; )
      t.push(Xe.empty);
    t.push(r);
  }
}
function $m(t, e, r) {
  let n = t.inserted;
  for (let i = 0, s = 0, a = 0; a < t.sections.length; ) {
    let o = t.sections[a++], u = t.sections[a++];
    if (u < 0)
      i += o, s += o;
    else {
      let c = i, h = s, p = Xe.empty;
      for (; c += o, h += u, u && n && (p = p.append(n[a - 2 >> 1])), !(r || a == t.sections.length || t.sections[a + 1] < 0); )
        o = t.sections[a++], u = t.sections[a++];
      e(i, c, s, h, p), i = c, s = h;
    }
  }
}
function Bm(t, e, r, n = !1) {
  let i = [], s = n ? [] : null, a = new Jl(t), o = new Jl(e);
  for (let u = -1; ; )
    if (a.ins == -1 && o.ins == -1) {
      let c = Math.min(a.len, o.len);
      ir(i, c, -1), a.forward(c), o.forward(c);
    } else if (o.ins >= 0 && (a.ins < 0 || u == a.i || a.off == 0 && (o.len < a.len || o.len == a.len && !r))) {
      let c = o.len;
      for (ir(i, o.ins, -1); c; ) {
        let h = Math.min(a.len, c);
        a.ins >= 0 && u < a.i && a.len <= h && (ir(i, 0, a.ins), s && is(s, i, a.text), u = a.i), a.forward(h), c -= h;
      }
      o.next();
    } else if (a.ins >= 0) {
      let c = 0, h = a.len;
      for (; h; )
        if (o.ins == -1) {
          let p = Math.min(h, o.len);
          c += p, h -= p, o.forward(p);
        } else if (o.ins == 0 && o.len < h)
          h -= o.len, o.next();
        else
          break;
      ir(i, c, u < a.i ? a.ins : 0), s && u < a.i && is(s, i, a.text), u = a.i, a.forward(a.len - h);
    } else {
      if (a.done && o.done)
        return s ? Bt.createSet(i, s) : ni.create(i);
      throw new Error("Mismatched change set lengths");
    }
}
function $E(t, e, r = !1) {
  let n = [], i = r ? [] : null, s = new Jl(t), a = new Jl(e);
  for (let o = !1; ; ) {
    if (s.done && a.done)
      return i ? Bt.createSet(n, i) : ni.create(n);
    if (s.ins == 0)
      ir(n, s.len, 0, o), s.next();
    else if (a.len == 0 && !a.done)
      ir(n, 0, a.ins, o), i && is(i, n, a.text), a.next();
    else {
      if (s.done || a.done)
        throw new Error("Mismatched change set lengths");
      {
        let u = Math.min(s.len2, a.len), c = n.length;
        if (s.ins == -1) {
          let h = a.ins == -1 ? -1 : a.off ? 0 : a.ins;
          ir(n, u, h, o), i && h && is(i, n, a.text);
        } else
          a.ins == -1 ? (ir(n, s.off ? 0 : s.len, u, o), i && is(i, n, s.textBit(u))) : (ir(n, s.off ? 0 : s.len, a.off ? 0 : a.ins, o), i && !a.off && is(i, n, a.text));
        o = (s.ins > u || a.ins >= 0 && a.len > u) && (o || n.length > c), s.forward2(u), a.forward(u);
      }
    }
  }
}
class Jl {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, r = this.i - 2 >> 1;
    return r >= e.length ? Xe.empty : e[r];
  }
  textBit(e) {
    let { inserted: r } = this.set, n = this.i - 2 >> 1;
    return n >= r.length && !e ? Xe.empty : r[n].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class qs {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.flags = n;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, r = -1) {
    let n, i;
    return this.empty ? n = i = e.mapPos(this.from, r) : (n = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), n == this.from && i == this.to ? this : new qs(n, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, r = e) {
    if (e <= this.anchor && r >= this.anchor)
      return G.range(e, r);
    let n = Math.abs(e - this.anchor) > Math.abs(r - this.anchor) ? e : r;
    return G.range(this.anchor, n);
  }
  /**
  Compare this range to another range.
  */
  eq(e, r = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!r || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return G.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new qs(e, r, n);
  }
}
class G {
  constructor(e, r) {
    this.ranges = e, this.mainIndex = r;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, r = -1) {
    return e.empty ? this : G.create(this.ranges.map((n) => n.map(e, r)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, r = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let n = 0; n < this.ranges.length; n++)
      if (!this.ranges[n].eq(e.ranges[n], r))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new G([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, r = !0) {
    return G.create([e].concat(this.ranges), r ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, r = this.mainIndex) {
    let n = this.ranges.slice();
    return n[r] = e, G.create(n, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new G(e.ranges.map((r) => qs.fromJSON(r)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, r = e) {
    return new G([G.range(e, r)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, r = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let n = 0, i = 0; i < e.length; i++) {
      let s = e[i];
      if (s.empty ? s.from <= n : s.from < n)
        return G.normalized(e.slice(), r);
      n = s.to;
    }
    return new G(e, r);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, r = 0, n, i) {
    return qs.create(e, e, (r == 0 ? 0 : r < 0 ? 8 : 16) | (n == null ? 7 : Math.min(6, n)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, r, n, i) {
    let s = (n ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return r < e ? qs.create(r, e, 48 | s) : qs.create(e, r, (r > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, r = 0) {
    let n = e[r];
    e.sort((i, s) => i.from - s.from), r = e.indexOf(n);
    for (let i = 1; i < e.length; i++) {
      let s = e[i], a = e[i - 1];
      if (s.empty ? s.from <= a.to : s.from < a.to) {
        let o = a.from, u = Math.max(s.to, a.to);
        i <= r && r--, e.splice(--i, 2, s.anchor > s.head ? G.range(u, o) : G.range(o, u));
      }
    }
    return new G(e, r);
  }
}
function BE(t, e) {
  for (let r of t.ranges)
    if (r.to > e)
      throw new RangeError("Selection points outside of document");
}
let b0 = 0;
class me {
  constructor(e, r, n, i, s) {
    this.combine = e, this.compareInput = r, this.compare = n, this.isStatic = i, this.id = b0++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new me(e.combine || ((r) => r), e.compareInput || ((r, n) => r === n), e.compare || (e.combine ? (r, n) => r === n : D0), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new rh([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new rh(e, this, 1, r);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new rh(e, this, 2, r);
  }
  from(e, r) {
    return r || (r = (n) => n), this.compute([e], (n) => r(n.field(e)));
  }
}
function D0(t, e) {
  return t == e || t.length == e.length && t.every((r, n) => r === e[n]);
}
class rh {
  constructor(e, r, n, i) {
    this.dependencies = e, this.facet = r, this.type = n, this.value = i, this.id = b0++;
  }
  dynamicSlot(e) {
    var r;
    let n = this.value, i = this.facet.compareInput, s = this.id, a = e[s] >> 1, o = this.type == 2, u = !1, c = !1, h = [];
    for (let p of this.dependencies)
      p == "doc" ? u = !0 : p == "selection" ? c = !0 : ((r = e[p.id]) !== null && r !== void 0 ? r : 1) & 1 || h.push(e[p.id]);
    return {
      create(p) {
        return p.values[a] = n(p), 1;
      },
      update(p, m) {
        if (u && m.docChanged || c && (m.docChanged || m.selection) || Im(p, h)) {
          let g = n(p);
          if (o ? !wx(g, p.values[a], i) : !i(g, p.values[a]))
            return p.values[a] = g, 1;
        }
        return 0;
      },
      reconfigure: (p, m) => {
        let g, O = m.config.address[s];
        if (O != null) {
          let b = Bh(m, O);
          if (this.dependencies.every((D) => D instanceof me ? m.facet(D) === p.facet(D) : D instanceof Rt ? m.field(D, !1) == p.field(D, !1) : !0) || (o ? wx(g = n(p), b, i) : i(g = n(p), b)))
            return p.values[a] = b, 0;
        } else
          g = n(p);
        return p.values[a] = g, 1;
      }
    };
  }
}
function wx(t, e, r) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!r(t[n], e[n]))
      return !1;
  return !0;
}
function Im(t, e) {
  let r = !1;
  for (let n of e)
    Il(t, n) & 1 && (r = !0);
  return r;
}
function Fq(t, e, r) {
  let n = r.map((u) => t[u.id]), i = r.map((u) => u.type), s = n.filter((u) => !(u & 1)), a = t[e.id] >> 1;
  function o(u) {
    let c = [];
    for (let h = 0; h < n.length; h++) {
      let p = Bh(u, n[h]);
      if (i[h] == 2)
        for (let m of p)
          c.push(m);
      else
        c.push(p);
    }
    return e.combine(c);
  }
  return {
    create(u) {
      for (let c of n)
        Il(u, c);
      return u.values[a] = o(u), 1;
    },
    update(u, c) {
      if (!Im(u, s))
        return 0;
      let h = o(u);
      return e.compare(h, u.values[a]) ? 0 : (u.values[a] = h, 1);
    },
    reconfigure(u, c) {
      let h = Im(u, n), p = c.config.facets[e.id], m = c.facet(e);
      if (p && !h && D0(r, p))
        return u.values[a] = m, 0;
      let g = o(u);
      return e.compare(g, m) ? (u.values[a] = m, 0) : (u.values[a] = g, 1);
    }
  };
}
const Cx = /* @__PURE__ */ me.define({ static: !0 });
class Rt {
  constructor(e, r, n, i, s) {
    this.id = e, this.createF = r, this.updateF = n, this.compareF = i, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let r = new Rt(b0++, e.create, e.update, e.compare || ((n, i) => n === i), e);
    return e.provide && (r.provides = e.provide(r)), r;
  }
  create(e) {
    let r = e.facet(Cx).find((n) => n.field == this);
    return ((r == null ? void 0 : r.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let r = e[this.id] >> 1;
    return {
      create: (n) => (n.values[r] = this.create(n), 1),
      update: (n, i) => {
        let s = n.values[r], a = this.updateF(s, i);
        return this.compareF(s, a) ? 0 : (n.values[r] = a, 1);
      },
      reconfigure: (n, i) => i.config.address[this.id] != null ? (n.values[r] = i.field(this), 0) : (n.values[r] = this.create(n), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Cx.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Ls = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function tl(t) {
  return (e) => new IE(e, t);
}
const va = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ tl(Ls.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ tl(Ls.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ tl(Ls.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ tl(Ls.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ tl(Ls.lowest)
};
class IE {
  constructor(e, r) {
    this.inner = e, this.prec = r;
  }
}
class rd {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new Nm(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return rd.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class Nm {
  constructor(e, r) {
    this.compartment = e, this.inner = r;
  }
}
class $h {
  constructor(e, r, n, i, s, a) {
    for (this.base = e, this.compartments = r, this.dynamicSlots = n, this.address = i, this.staticValues = s, this.facets = a, this.statusTemplate = []; this.statusTemplate.length < n.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let r = this.address[e.id];
    return r == null ? e.default : this.staticValues[r >> 1];
  }
  static resolve(e, r, n) {
    let i = [], s = /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ new Map();
    for (let m of $q(e, r, a))
      m instanceof Rt ? i.push(m) : (s[m.facet.id] || (s[m.facet.id] = [])).push(m);
    let o = /* @__PURE__ */ Object.create(null), u = [], c = [];
    for (let m of i)
      o[m.id] = c.length << 1, c.push((g) => m.slot(g));
    let h = n == null ? void 0 : n.config.facets;
    for (let m in s) {
      let g = s[m], O = g[0].facet, b = h && h[m] || [];
      if (g.every(
        (D) => D.type == 0
        /* Provider.Static */
      ))
        if (o[O.id] = u.length << 1 | 1, D0(b, g))
          u.push(n.facet(O));
        else {
          let D = O.combine(g.map((S) => S.value));
          u.push(n && O.compare(D, n.facet(O)) ? n.facet(O) : D);
        }
      else {
        for (let D of g)
          D.type == 0 ? (o[D.id] = u.length << 1 | 1, u.push(D.value)) : (o[D.id] = c.length << 1, c.push((S) => D.dynamicSlot(S)));
        o[O.id] = c.length << 1, c.push((D) => Fq(D, O, g));
      }
    }
    let p = c.map((m) => m(o));
    return new $h(e, a, p, o, u, s);
  }
}
function $q(t, e, r) {
  let n = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function s(a, o) {
    let u = i.get(a);
    if (u != null) {
      if (u <= o)
        return;
      let c = n[u].indexOf(a);
      c > -1 && n[u].splice(c, 1), a instanceof Nm && r.delete(a.compartment);
    }
    if (i.set(a, o), Array.isArray(a))
      for (let c of a)
        s(c, o);
    else if (a instanceof Nm) {
      if (r.has(a.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(a.compartment) || a.inner;
      r.set(a.compartment, c), s(c, o);
    } else if (a instanceof IE)
      s(a.inner, a.prec);
    else if (a instanceof Rt)
      n[o].push(a), a.provides && s(a.provides, o);
    else if (a instanceof rh)
      n[o].push(a), a.facet.extensions && s(a.facet.extensions, Ls.default);
    else {
      let c = a.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${a}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(c, o);
    }
  }
  return s(t, Ls.default), n.reduce((a, o) => a.concat(o));
}
function Il(t, e) {
  if (e & 1)
    return 2;
  let r = e >> 1, n = t.status[r];
  if (n == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (n & 2)
    return n;
  t.status[r] = 4;
  let i = t.computeSlot(t, t.config.dynamicSlots[r]);
  return t.status[r] = 2 | i;
}
function Bh(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const NE = /* @__PURE__ */ me.define(), _m = /* @__PURE__ */ me.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), _E = /* @__PURE__ */ me.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), QE = /* @__PURE__ */ me.define(), ME = /* @__PURE__ */ me.define(), LE = /* @__PURE__ */ me.define(), RE = /* @__PURE__ */ me.define({
  combine: (t) => t.length ? t[0] : !1
});
class pi {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new Bq();
  }
}
class Bq {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new pi(this, e);
  }
}
class Iq {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new Ae(this, e);
  }
}
class Ae {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let r = this.type.map(this.value, e);
    return r === void 0 ? void 0 : r == this.value ? this : new Ae(this.type, r);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new Iq(e.map || ((r) => r));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, r) {
    if (!e.length)
      return e;
    let n = [];
    for (let i of e) {
      let s = i.map(r);
      s && n.push(s);
    }
    return n;
  }
}
Ae.reconfigure = /* @__PURE__ */ Ae.define();
Ae.appendConfig = /* @__PURE__ */ Ae.define();
class Tt {
  constructor(e, r, n, i, s, a) {
    this.startState = e, this.changes = r, this.selection = n, this.effects = i, this.annotations = s, this.scrollIntoView = a, this._doc = null, this._state = null, n && BE(n, r.newLength), s.some((o) => o.type == Tt.time) || (this.annotations = s.concat(Tt.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, r, n, i, s, a) {
    return new Tt(e, r, n, i, s, a);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let r of this.annotations)
      if (r.type == e)
        return r.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let r = this.annotation(Tt.userEvent);
    return !!(r && (r == e || r.length > e.length && r.slice(0, e.length) == e && r[e.length] == "."));
  }
}
Tt.time = /* @__PURE__ */ pi.define();
Tt.userEvent = /* @__PURE__ */ pi.define();
Tt.addToHistory = /* @__PURE__ */ pi.define();
Tt.remote = /* @__PURE__ */ pi.define();
function Nq(t, e) {
  let r = [];
  for (let n = 0, i = 0; ; ) {
    let s, a;
    if (n < t.length && (i == e.length || e[i] >= t[n]))
      s = t[n++], a = t[n++];
    else if (i < e.length)
      s = e[i++], a = e[i++];
    else
      return r;
    !r.length || r[r.length - 1] < s ? r.push(s, a) : r[r.length - 1] < a && (r[r.length - 1] = a);
  }
}
function jE(t, e, r) {
  var n;
  let i, s, a;
  return r ? (i = e.changes, s = Bt.empty(e.changes.length), a = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes), s = t.changes.mapDesc(e.changes, !0), a = t.changes.compose(i)), {
    changes: a,
    selection: e.selection ? e.selection.map(s) : (n = t.selection) === null || n === void 0 ? void 0 : n.map(i),
    effects: Ae.mapEffects(t.effects, i).concat(Ae.mapEffects(e.effects, s)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function Qm(t, e, r) {
  let n = e.selection, i = Ha(e.annotations);
  return e.userEvent && (i = i.concat(Tt.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Bt ? e.changes : Bt.of(e.changes || [], r, t.facet(_E)),
    selection: n && (n instanceof G ? n : G.single(n.anchor, n.head)),
    effects: Ha(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function ZE(t, e, r) {
  let n = Qm(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (r = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (r = !1);
    let a = !!e[s].sequential;
    n = jE(n, Qm(t, e[s], a ? n.changes.newLength : t.doc.length), a);
  }
  let i = Tt.create(t, n.changes, n.selection, n.effects, n.annotations, n.scrollIntoView);
  return Qq(r ? _q(i) : i);
}
function _q(t) {
  let e = t.startState, r = !0;
  for (let i of e.facet(QE)) {
    let s = i(t);
    if (s === !1) {
      r = !1;
      break;
    }
    Array.isArray(s) && (r = r === !0 ? s : Nq(r, s));
  }
  if (r !== !0) {
    let i, s;
    if (r === !1)
      s = t.changes.invertedDesc, i = Bt.empty(e.doc.length);
    else {
      let a = t.changes.filter(r);
      i = a.changes, s = a.filtered.mapDesc(a.changes).invertedDesc;
    }
    t = Tt.create(e, i, t.selection && t.selection.map(s), Ae.mapEffects(t.effects, s), t.annotations, t.scrollIntoView);
  }
  let n = e.facet(ME);
  for (let i = n.length - 1; i >= 0; i--) {
    let s = n[i](t);
    s instanceof Tt ? t = s : Array.isArray(s) && s.length == 1 && s[0] instanceof Tt ? t = s[0] : t = ZE(e, Ha(s), !1);
  }
  return t;
}
function Qq(t) {
  let e = t.startState, r = e.facet(LE), n = t;
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](t);
    s && Object.keys(s).length && (n = jE(n, Qm(e, s, t.changes.newLength), !0));
  }
  return n == t ? t : Tt.create(e, t.changes, t.selection, n.effects, n.annotations, n.scrollIntoView);
}
const Mq = [];
function Ha(t) {
  return t == null ? Mq : Array.isArray(t) ? t : [t];
}
var dt = /* @__PURE__ */ function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
}(dt || (dt = {}));
const Lq = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Mm;
try {
  Mm = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function Rq(t) {
  if (Mm)
    return Mm.test(t);
  for (let e = 0; e < t.length; e++) {
    let r = t[e];
    if (/\w/.test(r) || r > "" && (r.toUpperCase() != r.toLowerCase() || Lq.test(r)))
      return !0;
  }
  return !1;
}
function jq(t) {
  return (e) => {
    if (!/\S/.test(e))
      return dt.Space;
    if (Rq(e))
      return dt.Word;
    for (let r = 0; r < t.length; r++)
      if (e.indexOf(t[r]) > -1)
        return dt.Word;
    return dt.Other;
  };
}
class Le {
  constructor(e, r, n, i, s, a) {
    this.config = e, this.doc = r, this.selection = n, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = s, a && (a._state = this);
    for (let o = 0; o < this.config.dynamicSlots.length; o++)
      Il(this, o << 1);
    this.computeSlot = null;
  }
  field(e, r = !0) {
    let n = this.config.address[e.id];
    if (n == null) {
      if (r)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Il(this, n), Bh(this, n);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return ZE(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let r = this.config, { base: n, compartments: i } = r;
    for (let o of e.effects)
      o.is(rd.reconfigure) ? (r && (i = /* @__PURE__ */ new Map(), r.compartments.forEach((u, c) => i.set(c, u)), r = null), i.set(o.value.compartment, o.value.extension)) : o.is(Ae.reconfigure) ? (r = null, n = o.value) : o.is(Ae.appendConfig) && (r = null, n = Ha(n).concat(o.value));
    let s;
    r ? s = e.startState.values.slice() : (r = $h.resolve(n, i, this), s = new Le(r, this.doc, this.selection, r.dynamicSlots.map(() => null), (u, c) => c.reconfigure(u, this), null).values);
    let a = e.startState.facet(_m) ? e.newSelection : e.newSelection.asSingle();
    new Le(r, e.newDoc, a, s, (o, u) => u.update(o, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((r) => ({
      changes: { from: r.from, to: r.to, insert: e },
      range: G.cursor(r.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let r = this.selection, n = e(r.ranges[0]), i = this.changes(n.changes), s = [n.range], a = Ha(n.effects);
    for (let o = 1; o < r.ranges.length; o++) {
      let u = e(r.ranges[o]), c = this.changes(u.changes), h = c.map(i);
      for (let m = 0; m < o; m++)
        s[m] = s[m].map(h);
      let p = i.mapDesc(c, !0);
      s.push(u.range.map(p)), i = i.compose(h), a = Ae.mapEffects(a, h).concat(Ae.mapEffects(Ha(u.effects), p));
    }
    return {
      changes: i,
      selection: G.create(s, r.mainIndex),
      effects: a
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof Bt ? e : Bt.of(e, this.doc.length, this.facet(Le.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return Xe.of(e.split(this.facet(Le.lineSeparator) || Fm));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, r = this.doc.length) {
    return this.doc.sliceString(e, r, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let r = this.config.address[e.id];
    return r == null ? e.default : (Il(this, r), Bh(this, r));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let r = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let n in e) {
        let i = e[n];
        i instanceof Rt && this.config.address[i.id] != null && (r[n] = i.spec.toJSON(this.field(e[n]), this));
      }
    return r;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, r = {}, n) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (n) {
      for (let s in n)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let a = n[s], o = e[s];
          i.push(a.init((u) => a.spec.fromJSON(o, u)));
        }
    }
    return Le.create({
      doc: e.doc,
      selection: G.fromJSON(e.selection),
      extensions: r.extensions ? i.concat([r.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let r = $h.resolve(e.extensions || [], /* @__PURE__ */ new Map()), n = e.doc instanceof Xe ? e.doc : Xe.of((e.doc || "").split(r.staticFacet(Le.lineSeparator) || Fm)), i = e.selection ? e.selection instanceof G ? e.selection : G.single(e.selection.anchor, e.selection.head) : G.single(0);
    return BE(i, n.length), r.staticFacet(_m) || (i = i.asSingle()), new Le(r, n, i, r.dynamicSlots.map(() => null), (s, a) => a.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(Le.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(Le.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(RE);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...r) {
    for (let n of this.facet(Le.phrases))
      if (Object.prototype.hasOwnProperty.call(n, e)) {
        e = n[e];
        break;
      }
    return r.length && (e = e.replace(/\$(\$|\d*)/g, (n, i) => {
      if (i == "$")
        return "$";
      let s = +(i || 1);
      return !s || s > r.length ? n : r[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, r, n = -1) {
    let i = [];
    for (let s of this.facet(NE))
      for (let a of s(this, r, n))
        Object.prototype.hasOwnProperty.call(a, e) && i.push(a[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return jq(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: r, from: n, length: i } = this.doc.lineAt(e), s = this.charCategorizer(e), a = e - n, o = e - n;
    for (; a > 0; ) {
      let u = Ut(r, a, !1);
      if (s(r.slice(u, a)) != dt.Word)
        break;
      a = u;
    }
    for (; o < i; ) {
      let u = Ut(r, o);
      if (s(r.slice(o, u)) != dt.Word)
        break;
      o = u;
    }
    return a == o ? null : G.range(a + n, o + n);
  }
}
Le.allowMultipleSelections = _m;
Le.tabSize = /* @__PURE__ */ me.define({
  combine: (t) => t.length ? t[0] : 4
});
Le.lineSeparator = _E;
Le.readOnly = RE;
Le.phrases = /* @__PURE__ */ me.define({
  compare(t, e) {
    let r = Object.keys(t), n = Object.keys(e);
    return r.length == n.length && r.every((i) => t[i] == e[i]);
  }
});
Le.languageData = NE;
Le.changeFilter = QE;
Le.transactionFilter = ME;
Le.transactionExtender = LE;
rd.reconfigure = /* @__PURE__ */ Ae.define();
function di(t, e, r = {}) {
  let n = {};
  for (let i of t)
    for (let s of Object.keys(i)) {
      let a = i[s], o = n[s];
      if (o === void 0)
        n[s] = a;
      else if (!(o === a || a === void 0))
        if (Object.hasOwnProperty.call(r, s))
          n[s] = r[s](o, a);
        else
          throw new Error("Config merge conflict for field " + s);
    }
  for (let i in e)
    n[i] === void 0 && (n[i] = e[i]);
  return n;
}
class na {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, r = e) {
    return Lm.create(e, r, this);
  }
}
na.prototype.startSide = na.prototype.endSide = 0;
na.prototype.point = !1;
na.prototype.mapMode = Vt.TrackDel;
let Lm = class WE {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.value = n;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new WE(e, r, n);
  }
};
function Rm(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class v0 {
  constructor(e, r, n, i) {
    this.from = e, this.to = r, this.value = n, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, r, n, i = 0) {
    let s = n ? this.to : this.from;
    for (let a = i, o = s.length; ; ) {
      if (a == o)
        return a;
      let u = a + o >> 1, c = s[u] - e || (n ? this.value[u].endSide : this.value[u].startSide) - r;
      if (u == a)
        return c >= 0 ? a : o;
      c >= 0 ? o = u : a = u + 1;
    }
  }
  between(e, r, n, i) {
    for (let s = this.findIndex(r, -1e9, !0), a = this.findIndex(n, 1e9, !1, s); s < a; s++)
      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, r) {
    let n = [], i = [], s = [], a = -1, o = -1;
    for (let u = 0; u < this.value.length; u++) {
      let c = this.value[u], h = this.from[u] + e, p = this.to[u] + e, m, g;
      if (h == p) {
        let O = r.mapPos(h, c.startSide, c.mapMode);
        if (O == null || (m = g = O, c.startSide != c.endSide && (g = r.mapPos(h, c.endSide), g < m)))
          continue;
      } else if (m = r.mapPos(h, c.startSide), g = r.mapPos(p, c.endSide), m > g || m == g && c.startSide > 0 && c.endSide <= 0)
        continue;
      (g - m || c.endSide - c.startSide) < 0 || (a < 0 && (a = m), c.point && (o = Math.max(o, g - m)), n.push(c), i.push(m - a), s.push(g - a));
    }
    return { mapped: n.length ? new v0(i, s, n, o) : null, pos: a };
  }
}
class We {
  constructor(e, r, n, i) {
    this.chunkPos = e, this.chunk = r, this.nextLayer = n, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, r, n, i) {
    return new We(e, r, n, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let r of this.chunk)
      e += r.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: r = [], sort: n = !1, filterFrom: i = 0, filterTo: s = this.length } = e, a = e.filter;
    if (r.length == 0 && !a)
      return this;
    if (n && (r = r.slice().sort(Rm)), this.isEmpty)
      return r.length ? We.of(r) : this;
    let o = new qE(this, null, -1).goto(0), u = 0, c = [], h = new ys();
    for (; o.value || u < r.length; )
      if (u < r.length && (o.from - r[u].from || o.startSide - r[u].value.startSide) >= 0) {
        let p = r[u++];
        h.addInner(p.from, p.to, p.value) || c.push(p);
      } else
        o.rangeIndex == 1 && o.chunkIndex < this.chunk.length && (u == r.length || this.chunkEnd(o.chunkIndex) < r[u].from) && (!a || i > this.chunkEnd(o.chunkIndex) || s < this.chunkPos[o.chunkIndex]) && h.addChunk(this.chunkPos[o.chunkIndex], this.chunk[o.chunkIndex]) ? o.nextChunk() : ((!a || i > o.to || s < o.from || a(o.from, o.to, o.value)) && (h.addInner(o.from, o.to, o.value) || c.push(Lm.create(o.from, o.to, o.value))), o.next());
    return h.finishInner(this.nextLayer.isEmpty && !c.length ? We.empty : this.nextLayer.update({ add: c, filter: a, filterFrom: i, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let r = [], n = [], i = -1;
    for (let a = 0; a < this.chunk.length; a++) {
      let o = this.chunkPos[a], u = this.chunk[a], c = e.touchesRange(o, o + u.length);
      if (c === !1)
        i = Math.max(i, u.maxPoint), r.push(u), n.push(e.mapPos(o));
      else if (c === !0) {
        let { mapped: h, pos: p } = u.map(o, e);
        h && (i = Math.max(i, h.maxPoint), r.push(h), n.push(p));
      }
    }
    let s = this.nextLayer.map(e);
    return r.length == 0 ? s : new We(n, r, s || We.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, r, n) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i], a = this.chunk[i];
        if (r >= s && e <= s + a.length && a.between(s, e - s, r - s, n) === !1)
          return;
      }
      this.nextLayer.between(e, r, n);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Kl.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, r = 0) {
    return Kl.from(e).goto(r);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, r, n, i, s = -1) {
    let a = e.filter((p) => p.maxPoint > 0 || !p.isEmpty && p.maxPoint >= s), o = r.filter((p) => p.maxPoint > 0 || !p.isEmpty && p.maxPoint >= s), u = Ex(a, o, n), c = new rl(a, u, s), h = new rl(o, u, s);
    n.iterGaps((p, m, g) => Ax(c, p, h, m, g, i)), n.empty && n.length == 0 && Ax(c, 0, h, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, r, n = 0, i) {
    i == null && (i = 999999999);
    let s = e.filter((h) => !h.isEmpty && r.indexOf(h) < 0), a = r.filter((h) => !h.isEmpty && e.indexOf(h) < 0);
    if (s.length != a.length)
      return !1;
    if (!s.length)
      return !0;
    let o = Ex(s, a), u = new rl(s, o, 0).goto(n), c = new rl(a, o, 0).goto(n);
    for (; ; ) {
      if (u.to != c.to || !jm(u.active, c.active) || u.point && (!c.point || !u.point.eq(c.point)))
        return !1;
      if (u.to > i)
        return !0;
      u.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, r, n, i, s = -1) {
    let a = new rl(e, null, s).goto(r), o = r, u = a.openStart;
    for (; ; ) {
      let c = Math.min(a.to, n);
      if (a.point) {
        let h = a.activeForPoint(a.to), p = a.pointFrom < r ? h.length + 1 : Math.min(h.length, u);
        i.point(o, c, a.point, h, p, a.pointRank), u = Math.min(a.openEnd(c), h.length);
      } else
        c > o && (i.span(o, c, a.active, u), u = a.openEnd(c));
      if (a.to > n)
        return u + (a.point && a.to > n ? 1 : 0);
      o = a.to, a.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, r = !1) {
    let n = new ys();
    for (let i of e instanceof Lm ? [e] : r ? Zq(e) : e)
      n.add(i.from, i.to, i.value);
    return n.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return We.empty;
    let r = e[e.length - 1];
    for (let n = e.length - 2; n >= 0; n--)
      for (let i = e[n]; i != We.empty; i = i.nextLayer)
        r = new We(i.chunkPos, i.chunk, r, Math.max(i.maxPoint, r.maxPoint));
    return r;
  }
}
We.empty = /* @__PURE__ */ new We([], [], null, -1);
function Zq(t) {
  if (t.length > 1)
    for (let e = t[0], r = 1; r < t.length; r++) {
      let n = t[r];
      if (Rm(e, n) > 0)
        return t.slice().sort(Rm);
      e = n;
    }
  return t;
}
We.empty.nextLayer = We.empty;
class ys {
  finishChunk(e) {
    this.chunks.push(new v0(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, r, n) {
    this.addInner(e, r, n) || (this.nextLayer || (this.nextLayer = new ys())).add(e, r, n);
  }
  /**
  @internal
  */
  addInner(e, r, n) {
    let i = e - this.lastTo || n.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || n.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(r - this.chunkStart), this.last = n, this.lastFrom = e, this.lastTo = r, this.value.push(n), n.point && (this.maxPoint = Math.max(this.maxPoint, r - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, r) {
    if ((e - this.lastTo || r.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, r.maxPoint), this.chunks.push(r), this.chunkPos.push(e);
    let n = r.value.length - 1;
    return this.last = r.value[n], this.lastFrom = r.from[n] + e, this.lastTo = r.to[n] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(We.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let r = We.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, r;
  }
}
function Ex(t, e, r) {
  let n = /* @__PURE__ */ new Map();
  for (let s of t)
    for (let a = 0; a < s.chunk.length; a++)
      s.chunk[a].maxPoint <= 0 && n.set(s.chunk[a], s.chunkPos[a]);
  let i = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let a = 0; a < s.chunk.length; a++) {
      let o = n.get(s.chunk[a]);
      o != null && (r ? r.mapPos(o) : o) == s.chunkPos[a] && !(r != null && r.touchesRange(o, o + s.chunk[a].length)) && i.add(s.chunk[a]);
    }
  return i;
}
class qE {
  constructor(e, r, n, i = 0) {
    this.layer = e, this.skip = r, this.minPoint = n, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, r = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, r, !1), this;
  }
  gotoInner(e, r, n) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, n = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], r, !0);
      (!n || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, r) {
    (this.to - e || this.endSide - r) < 0 && this.gotoInner(e, r, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], r = this.layer.chunk[this.chunkIndex], n = e + r.from[this.rangeIndex];
        if (this.from = n, this.to = e + r.to[this.rangeIndex], this.value = r.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Kl {
  constructor(e) {
    this.heap = e;
  }
  static from(e, r = null, n = -1) {
    let i = [];
    for (let s = 0; s < e.length; s++)
      for (let a = e[s]; !a.isEmpty; a = a.nextLayer)
        a.maxPoint >= n && i.push(new qE(a, r, n, s));
    return i.length == 1 ? i[0] : new Kl(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, r = -1e9) {
    for (let n of this.heap)
      n.goto(e, r);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      af(this.heap, n);
    return this.next(), this;
  }
  forward(e, r) {
    for (let n of this.heap)
      n.forward(e, r);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      af(this.heap, n);
    (this.to - e || this.value.endSide - r) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), af(this.heap, 0);
    }
  }
}
function af(t, e) {
  for (let r = t[e]; ; ) {
    let n = (e << 1) + 1;
    if (n >= t.length)
      break;
    let i = t[n];
    if (n + 1 < t.length && i.compare(t[n + 1]) >= 0 && (i = t[n + 1], n++), r.compare(i) < 0)
      break;
    t[n] = r, t[e] = i, e = n;
  }
}
class rl {
  constructor(e, r, n) {
    this.minPoint = n, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Kl.from(e, r, n);
  }
  goto(e, r = -1e9) {
    return this.cursor.goto(e, r), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = r, this.openStart = -1, this.next(), this;
  }
  forward(e, r) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - r) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, r);
  }
  removeActive(e) {
    vc(this.active, e), vc(this.activeTo, e), vc(this.activeRank, e), this.minActive = Tx(this.active, this.activeTo);
  }
  addActive(e) {
    let r = 0, { value: n, to: i, rank: s } = this.cursor;
    for (; r < this.activeRank.length && (s - this.activeRank[r] || i - this.activeTo[r]) > 0; )
      r++;
    Sc(this.active, r, n), Sc(this.activeTo, r, i), Sc(this.activeRank, r, s), e && Sc(e, r, this.cursor.from), this.minActive = Tx(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, r = this.point;
    this.point = null;
    let n = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), n && vc(n, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(n), this.cursor.next();
          else if (r && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (n) {
      this.openStart = 0;
      for (let i = n.length - 1; i >= 0 && n[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let r = [];
    for (let n = this.active.length - 1; n >= 0 && !(this.activeRank[n] < this.pointRank); n--)
      (this.activeTo[n] > e || this.activeTo[n] == e && this.active[n].endSide >= this.point.endSide) && r.push(this.active[n]);
    return r.reverse();
  }
  openEnd(e) {
    let r = 0;
    for (let n = this.activeTo.length - 1; n >= 0 && this.activeTo[n] > e; n--)
      r++;
    return r;
  }
}
function Ax(t, e, r, n, i, s) {
  t.goto(e), r.goto(n);
  let a = n + i, o = n, u = n - e;
  for (; ; ) {
    let c = t.to + u - r.to || t.endSide - r.endSide, h = c < 0 ? t.to + u : r.to, p = Math.min(h, a);
    if (t.point || r.point ? t.point && r.point && (t.point == r.point || t.point.eq(r.point)) && jm(t.activeForPoint(t.to), r.activeForPoint(r.to)) || s.comparePoint(o, p, t.point, r.point) : p > o && !jm(t.active, r.active) && s.compareRange(o, p, t.active, r.active), h > a)
      break;
    o = h, c <= 0 && t.next(), c >= 0 && r.next();
  }
}
function jm(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (t[r] != e[r] && !t[r].eq(e[r]))
      return !1;
  return !0;
}
function vc(t, e) {
  for (let r = e, n = t.length - 1; r < n; r++)
    t[r] = t[r + 1];
  t.pop();
}
function Sc(t, e, r) {
  for (let n = t.length - 1; n >= e; n--)
    t[n + 1] = t[n];
  t[e] = r;
}
function Tx(t, e) {
  let r = -1, n = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - n || t[i].endSide - t[r].endSide) < 0 && (r = i, n = e[i]);
  return r;
}
function Qo(t, e, r = t.length) {
  let n = 0;
  for (let i = 0; i < r; )
    t.charCodeAt(i) == 9 ? (n += e - n % e, i++) : (n++, i = Ut(t, i));
  return n;
}
function Zm(t, e, r, n) {
  for (let i = 0, s = 0; ; ) {
    if (s >= e)
      return i;
    if (i == t.length)
      break;
    s += t.charCodeAt(i) == 9 ? r - s % r : 1, i = Ut(t, i);
  }
  return n === !0 ? -1 : t.length;
}
const Wm = "", kx = typeof Symbol > "u" ? "__" + Wm : Symbol.for(Wm), qm = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), Px = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Os {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, r) {
    this.rules = [];
    let { finish: n } = r || {};
    function i(a) {
      return /^@/.test(a) ? [a] : a.split(/,\s*/);
    }
    function s(a, o, u, c) {
      let h = [], p = /^@(\w+)\b/.exec(a[0]), m = p && p[1] == "keyframes";
      if (p && o == null)
        return u.push(a[0] + ";");
      for (let g in o) {
        let O = o[g];
        if (/&/.test(g))
          s(
            g.split(/,\s*/).map((b) => a.map((D) => b.replace(/&/, D))).reduce((b, D) => b.concat(D)),
            O,
            u
          );
        else if (O && typeof O == "object") {
          if (!p)
            throw new RangeError("The value of a property (" + g + ") should be a primitive value.");
          s(i(g), O, h, m);
        } else
          O != null && h.push(g.replace(/_.*/, "").replace(/[A-Z]/g, (b) => "-" + b.toLowerCase()) + ": " + O + ";");
      }
      (h.length || m) && u.push((n && !p && !c ? a.map(n) : a).join(", ") + " {" + h.join(" ") + "}");
    }
    for (let a in e)
      s(i(a), e[a], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let e = Px[kx] || 1;
    return Px[kx] = e + 1, Wm + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, r, n) {
    let i = e[qm], s = n && n.nonce;
    i ? s && i.setNonce(s) : i = new Wq(e, s), i.mount(Array.isArray(r) ? r : [r]);
  }
}
let Fx = /* @__PURE__ */ new Map();
class Wq {
  constructor(e, r) {
    let n = e.ownerDocument || e, i = n.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = Fx.get(n);
      if (s)
        return e.adoptedStyleSheets = [s.sheet, ...e.adoptedStyleSheets], e[qm] = s;
      this.sheet = new i.CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets], Fx.set(n, this);
    } else {
      this.styleTag = n.createElement("style"), r && this.styleTag.setAttribute("nonce", r);
      let s = e.head || e;
      s.insertBefore(this.styleTag, s.firstChild);
    }
    this.modules = [], e[qm] = this;
  }
  mount(e) {
    let r = this.sheet, n = 0, i = 0;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], o = this.modules.indexOf(a);
      if (o < i && o > -1 && (this.modules.splice(o, 1), i--, o = -1), o == -1) {
        if (this.modules.splice(i++, 0, a), r)
          for (let u = 0; u < a.rules.length; u++)
            r.insertRule(a.rules[u], n++);
      } else {
        for (; i < o; )
          n += this.modules[i++].rules.length;
        n += a.rules.length, i++;
      }
    }
    if (!r) {
      let s = "";
      for (let a = 0; a < this.modules.length; a++)
        s += this.modules[a].getRules() + `
`;
      this.styleTag.textContent = s;
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var xs = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, eu = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, qq = typeof navigator < "u" && /Mac/.test(navigator.platform), Xq = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var qt = 0; qt < 10; qt++)
  xs[48 + qt] = xs[96 + qt] = String(qt);
for (var qt = 1; qt <= 24; qt++)
  xs[qt + 111] = "F" + qt;
for (var qt = 65; qt <= 90; qt++)
  xs[qt] = String.fromCharCode(qt + 32), eu[qt] = String.fromCharCode(qt);
for (var of in xs)
  eu.hasOwnProperty(of) || (eu[of] = xs[of]);
function Vq(t) {
  var e = qq && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || Xq && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", r = !e && t.key || (t.shiftKey ? eu : xs)[t.keyCode] || t.key || "Unidentified";
  return r == "Esc" && (r = "Escape"), r == "Del" && (r = "Delete"), r == "Left" && (r = "ArrowLeft"), r == "Up" && (r = "ArrowUp"), r == "Right" && (r = "ArrowRight"), r == "Down" && (r = "ArrowDown"), r;
}
function Ih(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function Xm(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function Yq(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function nh(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return Xm(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function po(t) {
  return t.nodeType == 3 ? ia(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function Nl(t, e, r, n) {
  return r ? $x(t, e, r, n, -1) || $x(t, e, r, n, 1) : !1;
}
function tu(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function $x(t, e, r, n, i) {
  for (; ; ) {
    if (t == r && e == n)
      return !0;
    if (e == (i < 0 ? 0 : Ai(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let s = t.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = tu(t) + (i < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = i < 0 ? Ai(t) : 0;
    } else
      return !1;
  }
}
function Ai(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function nd(t, e) {
  let r = e ? t.left : t.right;
  return { left: r, right: r, top: t.top, bottom: t.bottom };
}
function Uq(t) {
  return {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function XE(t, e) {
  let r = e.width / t.offsetWidth, n = e.height / t.offsetHeight;
  return (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.width - t.offsetWidth) < 1) && (r = 1), (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.height - t.offsetHeight) < 1) && (n = 1), { scaleX: r, scaleY: n };
}
function zq(t, e, r, n, i, s, a, o) {
  let u = t.ownerDocument, c = u.defaultView || window;
  for (let h = t, p = !1; h && !p; )
    if (h.nodeType == 1) {
      let m, g = h == u.body, O = 1, b = 1;
      if (g)
        m = Uq(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(h).position) && (p = !0), h.scrollHeight <= h.clientHeight && h.scrollWidth <= h.clientWidth) {
          h = h.assignedSlot || h.parentNode;
          continue;
        }
        let x = h.getBoundingClientRect();
        ({ scaleX: O, scaleY: b } = XE(h, x)), m = {
          left: x.left,
          right: x.left + h.clientWidth * O,
          top: x.top,
          bottom: x.top + h.clientHeight * b
        };
      }
      let D = 0, S = 0;
      if (i == "nearest")
        e.top < m.top ? (S = -(m.top - e.top + a), r > 0 && e.bottom > m.bottom + S && (S = e.bottom - m.bottom + S + a)) : e.bottom > m.bottom && (S = e.bottom - m.bottom + a, r < 0 && e.top - S < m.top && (S = -(m.top + S - e.top + a)));
      else {
        let x = e.bottom - e.top, w = m.bottom - m.top;
        S = (i == "center" && x <= w ? e.top + x / 2 - w / 2 : i == "start" || i == "center" && r < 0 ? e.top - a : e.bottom - w + a) - m.top;
      }
      if (n == "nearest" ? e.left < m.left ? (D = -(m.left - e.left + s), r > 0 && e.right > m.right + D && (D = e.right - m.right + D + s)) : e.right > m.right && (D = e.right - m.right + s, r < 0 && e.left < m.left + D && (D = -(m.left + D - e.left + s))) : D = (n == "center" ? e.left + (e.right - e.left) / 2 - (m.right - m.left) / 2 : n == "start" == o ? e.left - s : e.right - (m.right - m.left) + s) - m.left, D || S)
        if (g)
          c.scrollBy(D, S);
        else {
          let x = 0, w = 0;
          if (S) {
            let T = h.scrollTop;
            h.scrollTop += S / b, w = (h.scrollTop - T) * b;
          }
          if (D) {
            let T = h.scrollLeft;
            h.scrollLeft += D / O, x = (h.scrollLeft - T) * O;
          }
          e = {
            left: e.left - x,
            top: e.top - w,
            right: e.right - x,
            bottom: e.bottom - w
          }, x && Math.abs(x - D) < 1 && (n = "nearest"), w && Math.abs(w - S) < 1 && (i = "nearest");
        }
      if (g)
        break;
      h = h.assignedSlot || h.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
}
function Gq(t) {
  let e = t.ownerDocument;
  for (let r = t.parentNode; r && r != e.body; )
    if (r.nodeType == 1) {
      if (r.scrollHeight > r.clientHeight || r.scrollWidth > r.clientWidth)
        return r;
      r = r.assignedSlot || r.parentNode;
    } else if (r.nodeType == 11)
      r = r.host;
    else
      break;
  return null;
}
class Hq {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: r, focusNode: n } = e;
    this.set(r, Math.min(e.anchorOffset, r ? Ai(r) : 0), n, Math.min(e.focusOffset, n ? Ai(n) : 0));
  }
  set(e, r, n, i) {
    this.anchorNode = e, this.anchorOffset = r, this.focusNode = n, this.focusOffset = i;
  }
}
let Ba = null;
function VE(t) {
  if (t.setActive)
    return t.setActive();
  if (Ba)
    return t.focus(Ba);
  let e = [];
  for (let r = t; r && (e.push(r, r.scrollTop, r.scrollLeft), r != r.ownerDocument); r = r.parentNode)
    ;
  if (t.focus(Ba == null ? {
    get preventScroll() {
      return Ba = { preventScroll: !0 }, !0;
    }
  } : void 0), !Ba) {
    Ba = !1;
    for (let r = 0; r < e.length; ) {
      let n = e[r++], i = e[r++], s = e[r++];
      n.scrollTop != i && (n.scrollTop = i), n.scrollLeft != s && (n.scrollLeft = s);
    }
  }
}
let Bx;
function ia(t, e, r = e) {
  let n = Bx || (Bx = document.createRange());
  return n.setEnd(t, r), n.setStart(t, e), n;
}
function Ja(t, e, r) {
  let n = { key: e, code: e, keyCode: r, which: r, cancelable: !0 }, i = new KeyboardEvent("keydown", n);
  i.synthetic = !0, t.dispatchEvent(i);
  let s = new KeyboardEvent("keyup", n);
  return s.synthetic = !0, t.dispatchEvent(s), i.defaultPrevented || s.defaultPrevented;
}
function Jq(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function YE(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function Kq(t, e) {
  let r = e.focusNode, n = e.focusOffset;
  if (!r || e.anchorNode != r || e.anchorOffset != n)
    return !1;
  for (n = Math.min(n, Ai(r)); ; )
    if (n) {
      if (r.nodeType != 1)
        return !1;
      let i = r.childNodes[n - 1];
      i.contentEditable == "false" ? n-- : (r = i, n = Ai(r));
    } else {
      if (r == t)
        return !0;
      n = tu(r), r = r.parentNode;
    }
}
function UE(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
class or {
  constructor(e, r, n = !0) {
    this.node = e, this.offset = r, this.precise = n;
  }
  static before(e, r) {
    return new or(e.parentNode, tu(e), r);
  }
  static after(e, r) {
    return new or(e.parentNode, tu(e) + 1, r);
  }
}
const S0 = [];
class ut {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let r = this.posAtStart;
    for (let n of this.children) {
      if (n == e)
        return r;
      r += n.length + n.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, r) {
    if (this.flags & 2) {
      let n = this.dom, i = null, s;
      for (let a of this.children) {
        if (a.flags & 7) {
          if (!a.dom && (s = i ? i.nextSibling : n.firstChild)) {
            let o = ut.get(s);
            (!o || !o.parent && o.canReuseDOM(a)) && a.reuseDOM(s);
          }
          a.sync(e, r), a.flags &= -8;
        }
        if (s = i ? i.nextSibling : n.firstChild, r && !r.written && r.node == n && s != a.dom && (r.written = !0), a.dom.parentNode == n)
          for (; s && s != a.dom; )
            s = Ix(s);
        else
          n.insertBefore(a.dom, s);
        i = a.dom;
      }
      for (s = i ? i.nextSibling : n.firstChild, s && r && r.node == n && (r.written = !0); s; )
        s = Ix(s);
    } else if (this.flags & 1)
      for (let n of this.children)
        n.flags & 7 && (n.sync(e, r), n.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, r) {
    let n;
    if (e == this.dom)
      n = this.dom.childNodes[r];
    else {
      let i = Ai(e) == 0 ? 0 : r == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? i = -1 : i = 1), e = s;
      }
      i < 0 ? n = e : n = e.nextSibling;
    }
    if (n == this.dom.firstChild)
      return 0;
    for (; n && !ut.get(n); )
      n = n.nextSibling;
    if (!n)
      return this.length;
    for (let i = 0, s = 0; ; i++) {
      let a = this.children[i];
      if (a.dom == n)
        return s;
      s += a.length + a.breakAfter;
    }
  }
  domBoundsAround(e, r, n = 0) {
    let i = -1, s = -1, a = -1, o = -1;
    for (let u = 0, c = n, h = n; u < this.children.length; u++) {
      let p = this.children[u], m = c + p.length;
      if (c < e && m > r)
        return p.domBoundsAround(e, r, c);
      if (m >= e && i == -1 && (i = u, s = c), c > r && p.dom.parentNode == this.dom) {
        a = u, o = h;
        break;
      }
      h = m, c = m + p.breakAfter;
    }
    return {
      from: s,
      to: o < 0 ? n + this.length : o,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: a < this.children.length && a >= 0 ? this.children[a].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let r = this.parent; r; r = r.parent) {
      if (e && (r.flags |= 2), r.flags & 1)
        return;
      r.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let r = e.parent;
      if (!r)
        return e;
      e = r;
    }
  }
  replaceChildren(e, r, n = S0) {
    this.markDirty();
    for (let i = e; i < r; i++) {
      let s = this.children[i];
      s.parent == this && n.indexOf(s) < 0 && s.destroy();
    }
    this.children.splice(e, r - e, ...n);
    for (let i = 0; i < n.length; i++)
      n[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new zE(this.children, e, this.children.length);
  }
  childPos(e, r = 1) {
    return this.childCursor().findPos(e, r);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, r, n, i, s, a) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
ut.prototype.breakAfter = 0;
function Ix(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class zE {
  constructor(e, r, n) {
    this.children = e, this.pos = r, this.i = n, this.off = 0;
  }
  findPos(e, r = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (r > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let n = this.children[--this.i];
      this.pos -= n.length + n.breakAfter;
    }
  }
}
function GE(t, e, r, n, i, s, a, o, u) {
  let { children: c } = t, h = c.length ? c[e] : null, p = s.length ? s[s.length - 1] : null, m = p ? p.breakAfter : a;
  if (!(e == n && h && !a && !m && s.length < 2 && h.merge(r, i, s.length ? p : null, r == 0, o, u))) {
    if (n < c.length) {
      let g = c[n];
      g && (i < g.length || g.breakAfter && (p != null && p.breakAfter)) ? (e == n && (g = g.split(i), i = 0), !m && p && g.merge(0, i, p, !0, 0, u) ? s[s.length - 1] = g : ((i || g.children.length && !g.children[0].length) && g.merge(0, i, null, !1, 0, u), s.push(g))) : g != null && g.breakAfter && (p ? p.breakAfter = 1 : a = 1), n++;
    }
    for (h && (h.breakAfter = a, r > 0 && (!a && s.length && h.merge(r, h.length, s[0], !1, o, 0) ? h.breakAfter = s.shift().breakAfter : (r < h.length || h.children.length && h.children[h.children.length - 1].length == 0) && h.merge(r, h.length, null, !1, o, 0), e++)); e < n && s.length; )
      if (c[n - 1].become(s[s.length - 1]))
        n--, s.pop(), u = s.length ? 0 : o;
      else if (c[e].become(s[0]))
        e++, s.shift(), o = s.length ? 0 : u;
      else
        break;
    !s.length && e && n < c.length && !c[e - 1].breakAfter && c[n].merge(0, 0, c[e - 1], !1, o, u) && e--, (e < n || s.length) && t.replaceChildren(e, n, s);
  }
}
function HE(t, e, r, n, i, s) {
  let a = t.childCursor(), { i: o, off: u } = a.findPos(r, 1), { i: c, off: h } = a.findPos(e, -1), p = e - r;
  for (let m of n)
    p += m.length;
  t.length += p, GE(t, c, h, o, u, n, 0, i, s);
}
let Xr = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Vm = typeof document < "u" ? document : { documentElement: { style: {} } };
const Ym = /* @__PURE__ */ /Edge\/(\d+)/.exec(Xr.userAgent), JE = /* @__PURE__ */ /MSIE \d/.test(Xr.userAgent), Um = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Xr.userAgent), id = !!(JE || Um || Ym), Nx = !id && /* @__PURE__ */ /gecko\/(\d+)/i.test(Xr.userAgent), lf = !id && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Xr.userAgent), _x = "webkitFontSmoothing" in Vm.documentElement.style, KE = !id && /* @__PURE__ */ /Apple Computer/.test(Xr.vendor), Qx = KE && (/* @__PURE__ */ /Mobile\/\w+/.test(Xr.userAgent) || Xr.maxTouchPoints > 2);
var Oe = {
  mac: Qx || /* @__PURE__ */ /Mac/.test(Xr.platform),
  windows: /* @__PURE__ */ /Win/.test(Xr.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Xr.platform),
  ie: id,
  ie_version: JE ? Vm.documentMode || 6 : Um ? +Um[1] : Ym ? +Ym[1] : 0,
  gecko: Nx,
  gecko_version: Nx ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Xr.userAgent) || [0, 0])[1] : 0,
  chrome: !!lf,
  chrome_version: lf ? +lf[1] : 0,
  ios: Qx,
  android: /* @__PURE__ */ /Android\b/.test(Xr.userAgent),
  webkit: _x,
  safari: KE,
  webkit_version: _x ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: Vm.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const eX = 256;
class Ti extends ut {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, r) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (r && r.node == this.dom && (r.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, r, n) {
    return this.flags & 8 || n && (!(n instanceof Ti) || this.length - (r - e) + n.length > eX || n.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (n ? n.text : "") + this.text.slice(r), this.markDirty(), !0);
  }
  split(e) {
    let r = new Ti(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), r.flags |= this.flags & 8, r;
  }
  localPosFromDOM(e, r) {
    return e == this.dom ? r : r ? this.text.length : 0;
  }
  domAtPos(e) {
    return new or(this.dom, e);
  }
  domBoundsAround(e, r, n) {
    return { from: n, to: n + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, r) {
    return tX(this.dom, e, r);
  }
}
class ki extends ut {
  constructor(e, r = [], n = 0) {
    super(), this.mark = e, this.children = r, this.length = n;
    for (let i of r)
      i.setParent(this);
  }
  setAttrs(e) {
    if (YE(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let r in this.mark.attrs)
        e.setAttribute(r, this.mark.attrs[r]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, r);
  }
  merge(e, r, n, i, s, a) {
    return n && (!(n instanceof ki && n.mark.eq(this.mark)) || e && s <= 0 || r < this.length && a <= 0) ? !1 : (HE(this, e, r, n ? n.children.slice() : [], s - 1, a - 1), this.markDirty(), !0);
  }
  split(e) {
    let r = [], n = 0, i = -1, s = 0;
    for (let o of this.children) {
      let u = n + o.length;
      u > e && r.push(n < e ? o.split(e - n) : o), i < 0 && n >= e && (i = s), n = u, s++;
    }
    let a = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new ki(this.mark, r, a);
  }
  domAtPos(e) {
    return eA(this, e);
  }
  coordsAt(e, r) {
    return rA(this, e, r);
  }
}
function tX(t, e, r) {
  let n = t.nodeValue.length;
  e > n && (e = n);
  let i = e, s = e, a = 0;
  e == 0 && r < 0 || e == n && r >= 0 ? Oe.chrome || Oe.gecko || (e ? (i--, a = 1) : s < n && (s++, a = -1)) : r < 0 ? i-- : s < n && s++;
  let o = ia(t, i, s).getClientRects();
  if (!o.length)
    return null;
  let u = o[(a ? a < 0 : r >= 0) ? 0 : o.length - 1];
  return Oe.safari && !a && u.width == 0 && (u = Array.prototype.find.call(o, (c) => c.width) || u), a ? nd(u, a < 0) : u || null;
}
class ss extends ut {
  static create(e, r, n) {
    return new ss(e, r, n);
  }
  constructor(e, r, n) {
    super(), this.widget = e, this.length = r, this.side = n, this.prevWidget = null;
  }
  split(e) {
    let r = ss.create(this.widget, this.length - e, this.side);
    return this.length -= e, r;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, r, n, i, s, a) {
    return n && (!(n instanceof ss) || !this.widget.compare(n.widget) || e > 0 && s <= 0 || r < this.length && a <= 0) ? !1 : (this.length = e + (n ? n.length : 0) + (this.length - r), !0);
  }
  become(e) {
    return e instanceof ss && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Xe.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: r } = e, n = r && r.state.doc, i = this.posAtStart;
    return n ? n.slice(i, i + this.length) : Xe.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? or.before(this.dom) : or.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, r) {
    let n = this.widget.coordsAt(this.dom, e, r);
    if (n)
      return n;
    let i = this.dom.getClientRects(), s = null;
    if (!i.length)
      return null;
    let a = this.side ? this.side < 0 : e > 0;
    for (let o = a ? i.length - 1 : 0; s = i[o], !(e > 0 ? o == 0 : o == i.length - 1 || s.top < s.bottom); o += a ? -1 : 1)
      ;
    return nd(s, !a);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class fo extends ut {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof fo && e.side == this.side;
  }
  split() {
    return new fo(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? or.before(this.dom) : or.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Xe.empty;
  }
  get isHidden() {
    return !0;
  }
}
Ti.prototype.children = ss.prototype.children = fo.prototype.children = S0;
function eA(t, e) {
  let r = t.dom, { children: n } = t, i = 0;
  for (let s = 0; i < n.length; i++) {
    let a = n[i], o = s + a.length;
    if (!(o == s && a.getSide() <= 0)) {
      if (e > s && e < o && a.dom.parentNode == r)
        return a.domAtPos(e - s);
      if (e <= s)
        break;
      s = o;
    }
  }
  for (let s = i; s > 0; s--) {
    let a = n[s - 1];
    if (a.dom.parentNode == r)
      return a.domAtPos(a.length);
  }
  for (let s = i; s < n.length; s++) {
    let a = n[s];
    if (a.dom.parentNode == r)
      return a.domAtPos(0);
  }
  return new or(r, 0);
}
function tA(t, e, r) {
  let n, { children: i } = t;
  r > 0 && e instanceof ki && i.length && (n = i[i.length - 1]) instanceof ki && n.mark.eq(e.mark) ? tA(n, e.children[0], r - 1) : (i.push(e), e.setParent(t)), t.length += e.length;
}
function rA(t, e, r) {
  let n = null, i = -1, s = null, a = -1;
  function o(c, h) {
    for (let p = 0, m = 0; p < c.children.length && m <= h; p++) {
      let g = c.children[p], O = m + g.length;
      O >= h && (g.children.length ? o(g, h - m) : (!s || s.isHidden && r > 0) && (O > h || m == O && g.getSide() > 0) ? (s = g, a = h - m) : (m < h || m == O && g.getSide() < 0 && !g.isHidden) && (n = g, i = h - m)), m = O;
    }
  }
  o(t, e);
  let u = (r < 0 ? n : s) || n || s;
  return u ? u.coordsAt(Math.max(0, u == n ? i : a), r) : rX(t);
}
function rX(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let r = po(e);
  return r[r.length - 1] || null;
}
function zm(t, e) {
  for (let r in t)
    r == "class" && e.class ? e.class += " " + t.class : r == "style" && e.style ? e.style += ";" + t.style : e[r] = t[r];
  return e;
}
const Mx = /* @__PURE__ */ Object.create(null);
function w0(t, e, r) {
  if (t == e)
    return !0;
  t || (t = Mx), e || (e = Mx);
  let n = Object.keys(t), i = Object.keys(e);
  if (n.length - (r && n.indexOf(r) > -1 ? 1 : 0) != i.length - (r && i.indexOf(r) > -1 ? 1 : 0))
    return !1;
  for (let s of n)
    if (s != r && (i.indexOf(s) == -1 || t[s] !== e[s]))
      return !1;
  return !0;
}
function Gm(t, e, r) {
  let n = !1;
  if (e)
    for (let i in e)
      r && i in r || (n = !0, i == "style" ? t.style.cssText = "" : t.removeAttribute(i));
  if (r)
    for (let i in r)
      e && e[i] == r[i] || (n = !0, i == "style" ? t.style.cssText = r[i] : t.setAttribute(i, r[i]));
  return n;
}
function nX(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r = 0; r < t.attributes.length; r++) {
    let n = t.attributes[r];
    e[n.name] = n.value;
  }
  return e;
}
class Ft extends ut {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, r, n, i, s, a) {
    if (n) {
      if (!(n instanceof Ft))
        return !1;
      this.dom || n.transferDOM(this);
    }
    return i && this.setDeco(n ? n.attrs : null), HE(this, e, r, n ? n.children.slice() : [], s, a), !0;
  }
  split(e) {
    let r = new Ft();
    if (r.breakAfter = this.breakAfter, this.length == 0)
      return r;
    let { i: n, off: i } = this.childPos(e);
    i && (r.append(this.children[n].split(i), 0), this.children[n].merge(i, this.children[n].length, null, !1, 0, 0), n++);
    for (let s = n; s < this.children.length; s++)
      r.append(this.children[s], 0);
    for (; n > 0 && this.children[n - 1].length == 0; )
      this.children[--n].destroy();
    return this.children.length = n, this.markDirty(), this.length = e, r;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    w0(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, r) {
    tA(this, e, r);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let r = e.spec.attributes, n = e.spec.class;
    r && (this.attrs = zm(r, this.attrs || {})), n && (this.attrs = zm({ class: n }, this.attrs || {}));
  }
  domAtPos(e) {
    return eA(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    var n;
    this.dom ? this.flags & 4 && (YE(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Gm(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, r);
    let i = this.dom.lastChild;
    for (; i && ut.get(i) instanceof ki; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((n = ut.get(i)) === null || n === void 0 ? void 0 : n.isEditable) == !1 && (!Oe.ios || !this.children.some((s) => s instanceof Ti))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, r;
    for (let n of this.children) {
      if (!(n instanceof Ti) || /[^ -~]/.test(n.text))
        return null;
      let i = po(n.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, r = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: r
    } : null;
  }
  coordsAt(e, r) {
    let n = rA(this, e, r);
    if (!this.children.length && n && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, s = n.bottom - n.top;
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let a = (s - i.textHeight) / 2;
        return { top: n.top + a, bottom: n.bottom - a, left: n.left, right: n.left };
      }
    }
    return n;
  }
  become(e) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(e, r) {
    for (let n = 0, i = 0; n < e.children.length; n++) {
      let s = e.children[n], a = i + s.length;
      if (a >= r) {
        if (s instanceof Ft)
          return s;
        if (a > r)
          break;
      }
      i = a + s.breakAfter;
    }
    return null;
  }
}
class ls extends ut {
  constructor(e, r, n) {
    super(), this.widget = e, this.length = r, this.deco = n, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, r, n, i, s, a) {
    return n && (!(n instanceof ls) || !this.widget.compare(n.widget) || e > 0 && s <= 0 || r < this.length && a <= 0) ? !1 : (this.length = e + (n ? n.length : 0) + (this.length - r), !0);
  }
  domAtPos(e) {
    return e == 0 ? or.before(this.dom) : or.after(this.dom, e == this.length);
  }
  split(e) {
    let r = this.length - e;
    this.length = e;
    let n = new ls(this.widget, r, this.deco);
    return n.breakAfter = this.breakAfter, n;
  }
  get children() {
    return S0;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Xe.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof ls && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, r) {
    return this.widget.coordsAt(this.dom, e, r);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: r, endSide: n } = this.deco;
    return r == n ? !1 : e < 0 ? r < 0 : n > 0;
  }
}
class fi {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, r) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, r, n) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var yr = /* @__PURE__ */ function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
}(yr || (yr = {}));
class be extends na {
  constructor(e, r, n, i) {
    super(), this.startSide = e, this.endSide = r, this.widget = n, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new _u(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let r = Math.max(-1e4, Math.min(1e4, e.side || 0)), n = !!e.block;
    return r += n && !e.inlineOrder ? r > 0 ? 3e8 : -4e8 : r > 0 ? 1e8 : -1e8, new bs(e, r, r, n, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let r = !!e.block, n, i;
    if (e.isBlockGap)
      n = -5e8, i = 4e8;
    else {
      let { start: s, end: a } = nA(e, r);
      n = (s ? r ? -3e8 : -1 : 5e8) - 1, i = (a ? r ? 2e8 : 1 : -6e8) + 1;
    }
    return new bs(e, n, i, r, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Qu(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, r = !1) {
    return We.of(e, r);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
be.none = We.empty;
class _u extends be {
  constructor(e) {
    let { start: r, end: n } = nA(e);
    super(r ? -1 : 5e8, n ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var r, n;
    return this == e || e instanceof _u && this.tagName == e.tagName && (this.class || ((r = this.attrs) === null || r === void 0 ? void 0 : r.class)) == (e.class || ((n = e.attrs) === null || n === void 0 ? void 0 : n.class)) && w0(this.attrs, e.attrs, "class");
  }
  range(e, r = e) {
    if (e >= r)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, r);
  }
}
_u.prototype.point = !1;
class Qu extends be {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Qu && this.spec.class == e.spec.class && w0(this.spec.attributes, e.spec.attributes);
  }
  range(e, r = e) {
    if (r != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, r);
  }
}
Qu.prototype.mapMode = Vt.TrackBefore;
Qu.prototype.point = !0;
class bs extends be {
  constructor(e, r, n, i, s, a) {
    super(r, n, s, e), this.block = i, this.isReplace = a, this.mapMode = i ? r <= 0 ? Vt.TrackBefore : Vt.TrackAfter : Vt.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? yr.WidgetRange : this.startSide <= 0 ? yr.WidgetBefore : yr.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof bs && iX(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, r = e) {
    if (this.isReplace && (e > r || e == r && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && r != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, r);
  }
}
bs.prototype.point = !0;
function nA(t, e = !1) {
  let { inclusiveStart: r, inclusiveEnd: n } = t;
  return r == null && (r = t.inclusive), n == null && (n = t.inclusive), { start: r ?? e, end: n ?? e };
}
function iX(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function Hm(t, e, r, n = 0) {
  let i = r.length - 1;
  i >= 0 && r[i] + n >= t ? r[i] = Math.max(r[i], e) : r.push(t, e);
}
class _l {
  constructor(e, r, n, i) {
    this.doc = e, this.pos = r, this.end = n, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = r;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof ls && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Ft()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(wc(new fo(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof ls) && this.getLine();
  }
  buildText(e, r, n) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: a, done: o } = this.cursor.next(this.skip);
        if (this.skip = 0, o)
          throw new Error("Ran out of text content when drawing inline views");
        if (a) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let i = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(r.slice(r.length - n)), this.getLine().append(wc(new Ti(this.text.slice(this.textOff, this.textOff + i)), r), n), this.atCursorPos = !0, this.textOff += i, e -= i, n = 0;
    }
  }
  span(e, r, n, i) {
    this.buildText(r - e, n, i), this.pos = r, this.openStart < 0 && (this.openStart = i);
  }
  point(e, r, n, i, s, a) {
    if (this.disallowBlockEffectsFor[a] && n instanceof bs) {
      if (n.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (r > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let o = r - e;
    if (n instanceof bs)
      if (n.block)
        n.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new ls(n.widget || new Lx("div"), o, n));
      else {
        let u = ss.create(n.widget || new Lx("span"), o, o ? 0 : n.startSide), c = this.atCursorPos && !u.isEditable && s <= i.length && (e < r || n.startSide > 0), h = !u.isEditable && (e < r || s > i.length || n.startSide <= 0), p = this.getLine();
        this.pendingBuffer == 2 && !c && !u.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), c && (p.append(wc(new fo(1), i), s), s = i.length + Math.max(0, s - i.length)), p.append(wc(u, i), s), this.atCursorPos = h, this.pendingBuffer = h ? e < r || s > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(n);
    o && (this.textOff + o <= this.text.length ? this.textOff += o : (this.skip += o - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = r), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, r, n, i, s) {
    let a = new _l(e, r, n, s);
    return a.openEnd = We.spans(i, r, n, a), a.openStart < 0 && (a.openStart = a.openEnd), a.finish(a.openEnd), a;
  }
}
function wc(t, e) {
  for (let r of e)
    t = new ki(r, [t], t.length);
  return t;
}
class Lx extends fi {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
var ct = /* @__PURE__ */ function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
}(ct || (ct = {}));
const sa = ct.LTR, C0 = ct.RTL;
function iA(t) {
  let e = [];
  for (let r = 0; r < t.length; r++)
    e.push(1 << +t[r]);
  return e;
}
const sX = /* @__PURE__ */ iA("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), aX = /* @__PURE__ */ iA("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Jm = /* @__PURE__ */ Object.create(null), Zn = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), r = /* @__PURE__ */ t.charCodeAt(1);
  Jm[e] = r, Jm[r] = -e;
}
function sA(t) {
  return t <= 247 ? sX[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? aX[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const oX = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class as {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? C0 : sa;
  }
  /**
  @internal
  */
  constructor(e, r, n) {
    this.from = e, this.to = r, this.level = n;
  }
  /**
  @internal
  */
  side(e, r) {
    return this.dir == r == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, r) {
    return e == (this.dir == r);
  }
  /**
  @internal
  */
  static find(e, r, n, i) {
    let s = -1;
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      if (o.from <= r && o.to >= r) {
        if (o.level == n)
          return a;
        (s < 0 || (i != 0 ? i < 0 ? o.from < r : o.to > r : e[s].level > o.level)) && (s = a);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function aA(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++) {
    let n = t[r], i = e[r];
    if (n.from != i.from || n.to != i.to || n.direction != i.direction || !aA(n.inner, i.inner))
      return !1;
  }
  return !0;
}
const rt = [];
function lX(t, e, r, n, i) {
  for (let s = 0; s <= n.length; s++) {
    let a = s ? n[s - 1].to : e, o = s < n.length ? n[s].from : r, u = s ? 256 : i;
    for (let c = a, h = u, p = u; c < o; c++) {
      let m = sA(t.charCodeAt(c));
      m == 512 ? m = h : m == 8 && p == 4 && (m = 16), rt[c] = m == 4 ? 2 : m, m & 7 && (p = m), h = m;
    }
    for (let c = a, h = u, p = u; c < o; c++) {
      let m = rt[c];
      if (m == 128)
        c < o - 1 && h == rt[c + 1] && h & 24 ? m = rt[c] = h : rt[c] = 256;
      else if (m == 64) {
        let g = c + 1;
        for (; g < o && rt[g] == 64; )
          g++;
        let O = c && h == 8 || g < r && rt[g] == 8 ? p == 1 ? 1 : 8 : 256;
        for (let b = c; b < g; b++)
          rt[b] = O;
        c = g - 1;
      } else
        m == 8 && p == 1 && (rt[c] = 1);
      h = m, m & 7 && (p = m);
    }
  }
}
function uX(t, e, r, n, i) {
  let s = i == 1 ? 2 : 1;
  for (let a = 0, o = 0, u = 0; a <= n.length; a++) {
    let c = a ? n[a - 1].to : e, h = a < n.length ? n[a].from : r;
    for (let p = c, m, g, O; p < h; p++)
      if (g = Jm[m = t.charCodeAt(p)])
        if (g < 0) {
          for (let b = o - 3; b >= 0; b -= 3)
            if (Zn[b + 1] == -g) {
              let D = Zn[b + 2], S = D & 2 ? i : D & 4 ? D & 1 ? s : i : 0;
              S && (rt[p] = rt[Zn[b]] = S), o = b;
              break;
            }
        } else {
          if (Zn.length == 189)
            break;
          Zn[o++] = p, Zn[o++] = m, Zn[o++] = u;
        }
      else if ((O = rt[p]) == 2 || O == 1) {
        let b = O == i;
        u = b ? 0 : 1;
        for (let D = o - 3; D >= 0; D -= 3) {
          let S = Zn[D + 2];
          if (S & 2)
            break;
          if (b)
            Zn[D + 2] |= 2;
          else {
            if (S & 4)
              break;
            Zn[D + 2] |= 4;
          }
        }
      }
  }
}
function cX(t, e, r, n) {
  for (let i = 0, s = n; i <= r.length; i++) {
    let a = i ? r[i - 1].to : t, o = i < r.length ? r[i].from : e;
    for (let u = a; u < o; ) {
      let c = rt[u];
      if (c == 256) {
        let h = u + 1;
        for (; ; )
          if (h == o) {
            if (i == r.length)
              break;
            h = r[i++].to, o = i < r.length ? r[i].from : e;
          } else if (rt[h] == 256)
            h++;
          else
            break;
        let p = s == 1, m = (h < e ? rt[h] : n) == 1, g = p == m ? p ? 1 : 2 : n;
        for (let O = h, b = i, D = b ? r[b - 1].to : t; O > u; )
          O == D && (O = r[--b].from, D = b ? r[b - 1].to : t), rt[--O] = g;
        u = h;
      } else
        s = c, u++;
    }
  }
}
function Km(t, e, r, n, i, s, a) {
  let o = n % 2 ? 2 : 1;
  if (n % 2 == i % 2)
    for (let u = e, c = 0; u < r; ) {
      let h = !0, p = !1;
      if (c == s.length || u < s[c].from) {
        let b = rt[u];
        b != o && (h = !1, p = b == 16);
      }
      let m = !h && o == 1 ? [] : null, g = h ? n : n + 1, O = u;
      e:
        for (; ; )
          if (c < s.length && O == s[c].from) {
            if (p)
              break e;
            let b = s[c];
            if (!h)
              for (let D = b.to, S = c + 1; ; ) {
                if (D == r)
                  break e;
                if (S < s.length && s[S].from == D)
                  D = s[S++].to;
                else {
                  if (rt[D] == o)
                    break e;
                  break;
                }
              }
            if (c++, m)
              m.push(b);
            else {
              b.from > u && a.push(new as(u, b.from, g));
              let D = b.direction == sa != !(g % 2);
              eg(t, D ? n + 1 : n, i, b.inner, b.from, b.to, a), u = b.to;
            }
            O = b.to;
          } else {
            if (O == r || (h ? rt[O] != o : rt[O] == o))
              break;
            O++;
          }
      m ? Km(t, u, O, n + 1, i, m, a) : u < O && a.push(new as(u, O, g)), u = O;
    }
  else
    for (let u = r, c = s.length; u > e; ) {
      let h = !0, p = !1;
      if (!c || u > s[c - 1].to) {
        let b = rt[u - 1];
        b != o && (h = !1, p = b == 16);
      }
      let m = !h && o == 1 ? [] : null, g = h ? n : n + 1, O = u;
      e:
        for (; ; )
          if (c && O == s[c - 1].to) {
            if (p)
              break e;
            let b = s[--c];
            if (!h)
              for (let D = b.from, S = c; ; ) {
                if (D == e)
                  break e;
                if (S && s[S - 1].to == D)
                  D = s[--S].from;
                else {
                  if (rt[D - 1] == o)
                    break e;
                  break;
                }
              }
            if (m)
              m.push(b);
            else {
              b.to < u && a.push(new as(b.to, u, g));
              let D = b.direction == sa != !(g % 2);
              eg(t, D ? n + 1 : n, i, b.inner, b.from, b.to, a), u = b.from;
            }
            O = b.from;
          } else {
            if (O == e || (h ? rt[O - 1] != o : rt[O - 1] == o))
              break;
            O--;
          }
      m ? Km(t, O, u, n + 1, i, m, a) : O < u && a.push(new as(O, u, g)), u = O;
    }
}
function eg(t, e, r, n, i, s, a) {
  let o = e % 2 ? 2 : 1;
  lX(t, i, s, n, o), uX(t, i, s, n, o), cX(i, s, n, o), Km(t, i, s, e, r, n, a);
}
function hX(t, e, r) {
  if (!t)
    return [new as(0, 0, e == C0 ? 1 : 0)];
  if (e == sa && !r.length && !oX.test(t))
    return oA(t.length);
  if (r.length)
    for (; t.length > rt.length; )
      rt[rt.length] = 256;
  let n = [], i = e == sa ? 0 : 1;
  return eg(t, i, i, r, 0, t.length, n), n;
}
function oA(t) {
  return [new as(0, t, 0)];
}
let lA = "";
function pX(t, e, r, n, i) {
  var s;
  let a = n.head - t.from, o = as.find(e, a, (s = n.bidiLevel) !== null && s !== void 0 ? s : -1, n.assoc), u = e[o], c = u.side(i, r);
  if (a == c) {
    let m = o += i ? 1 : -1;
    if (m < 0 || m >= e.length)
      return null;
    u = e[o = m], a = u.side(!i, r), c = u.side(i, r);
  }
  let h = Ut(t.text, a, u.forward(i, r));
  (h < u.from || h > u.to) && (h = c), lA = t.text.slice(Math.min(a, h), Math.max(a, h));
  let p = o == (i ? e.length - 1 : 0) ? null : e[o + (i ? 1 : -1)];
  return p && h == c && p.level + (i ? 0 : 1) < u.level ? G.cursor(p.side(!i, r) + t.from, p.forward(i, r) ? 1 : -1, p.level) : G.cursor(h + t.from, u.forward(i, r) ? -1 : 1, u.level);
}
function dX(t, e, r) {
  for (let n = e; n < r; n++) {
    let i = sA(t.charCodeAt(n));
    if (i == 1)
      return sa;
    if (i == 2 || i == 4)
      return C0;
  }
  return sa;
}
const uA = /* @__PURE__ */ me.define(), cA = /* @__PURE__ */ me.define(), hA = /* @__PURE__ */ me.define(), pA = /* @__PURE__ */ me.define(), tg = /* @__PURE__ */ me.define(), dA = /* @__PURE__ */ me.define(), fA = /* @__PURE__ */ me.define(), mA = /* @__PURE__ */ me.define({
  combine: (t) => t.some((e) => e)
}), gA = /* @__PURE__ */ me.define({
  combine: (t) => t.some((e) => e)
});
class Ka {
  constructor(e, r = "nearest", n = "nearest", i = 5, s = 5, a = !1) {
    this.range = e, this.y = r, this.x = n, this.yMargin = i, this.xMargin = s, this.isSnapshot = a;
  }
  map(e) {
    return e.empty ? this : new Ka(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Ka(G.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Cc = /* @__PURE__ */ Ae.define({ map: (t, e) => t.map(e) });
function hn(t, e, r) {
  let n = t.facet(pA);
  n.length ? n[0](e) : window.onerror ? window.onerror(String(e), r, void 0, void 0, e) : r ? console.error(r + ":", e) : console.error(e);
}
const sd = /* @__PURE__ */ me.define({ combine: (t) => t.length ? t[0] : !0 });
let fX = 0;
const dl = /* @__PURE__ */ me.define();
class wt {
  constructor(e, r, n, i, s) {
    this.id = e, this.create = r, this.domEventHandlers = n, this.domEventObservers = i, this.extension = s(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, r) {
    const { eventHandlers: n, eventObservers: i, provide: s, decorations: a } = r || {};
    return new wt(fX++, e, n, i, (o) => {
      let u = [dl.of(o)];
      return a && u.push(ru.of((c) => {
        let h = c.plugin(o);
        return h ? a(h) : be.none;
      })), s && u.push(s(o)), u;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, r) {
    return wt.define((n) => new e(n), r);
  }
}
class uf {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let r = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(r);
          } catch (n) {
            if (hn(r.state, n, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (r) {
        hn(e.state, r, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var r;
    if (!((r = this.value) === null || r === void 0) && r.destroy)
      try {
        this.value.destroy();
      } catch (n) {
        hn(e.state, n, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const yA = /* @__PURE__ */ me.define(), E0 = /* @__PURE__ */ me.define(), ru = /* @__PURE__ */ me.define(), OA = /* @__PURE__ */ me.define(), A0 = /* @__PURE__ */ me.define(), xA = /* @__PURE__ */ me.define();
function Rx(t, e) {
  let r = t.state.facet(xA);
  if (!r.length)
    return r;
  let n = r.map((s) => s instanceof Function ? s(t) : s), i = [];
  return We.spans(n, e.from, e.to, {
    point() {
    },
    span(s, a, o, u) {
      let c = s - e.from, h = a - e.from, p = i;
      for (let m = o.length - 1; m >= 0; m--, u--) {
        let g = o[m].spec.bidiIsolate, O;
        if (g == null && (g = dX(e.text, c, h)), u > 0 && p.length && (O = p[p.length - 1]).to == c && O.direction == g)
          O.to = h, p = O.inner;
        else {
          let b = { from: c, to: h, direction: g, inner: [] };
          p.push(b), p = b.inner;
        }
      }
    }
  }), i;
}
const bA = /* @__PURE__ */ me.define();
function DA(t) {
  let e = 0, r = 0, n = 0, i = 0;
  for (let s of t.state.facet(bA)) {
    let a = s(t);
    a && (a.left != null && (e = Math.max(e, a.left)), a.right != null && (r = Math.max(r, a.right)), a.top != null && (n = Math.max(n, a.top)), a.bottom != null && (i = Math.max(i, a.bottom)));
  }
  return { left: e, right: r, top: n, bottom: i };
}
const fl = /* @__PURE__ */ me.define();
class pn {
  constructor(e, r, n, i) {
    this.fromA = e, this.toA = r, this.fromB = n, this.toB = i;
  }
  join(e) {
    return new pn(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let r = e.length, n = this;
    for (; r > 0; r--) {
      let i = e[r - 1];
      if (!(i.fromA > n.toA)) {
        if (i.toA < n.fromA)
          break;
        n = n.join(i), e.splice(r - 1, 1);
      }
    }
    return e.splice(r, 0, n), e;
  }
  static extendWithRanges(e, r) {
    if (r.length == 0)
      return e;
    let n = [];
    for (let i = 0, s = 0, a = 0, o = 0; ; i++) {
      let u = i == e.length ? null : e[i], c = a - o, h = u ? u.fromB : 1e9;
      for (; s < r.length && r[s] < h; ) {
        let p = r[s], m = r[s + 1], g = Math.max(o, p), O = Math.min(h, m);
        if (g <= O && new pn(g + c, O + c, g, O).addToSet(n), m > h)
          break;
        s += 2;
      }
      if (!u)
        return n;
      new pn(u.fromA, u.toA, u.fromB, u.toB).addToSet(n), a = u.toA, o = u.toB;
    }
  }
}
class Nh {
  constructor(e, r, n) {
    this.view = e, this.state = r, this.transactions = n, this.flags = 0, this.startState = e.state, this.changes = Bt.empty(this.startState.doc.length);
    for (let s of n)
      this.changes = this.changes.compose(s.changes);
    let i = [];
    this.changes.iterChangedRanges((s, a, o, u) => i.push(new pn(s, a, o, u))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new Nh(e, r, n);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class jx extends ut {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Ft()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new pn(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var r;
    let n = e.changedRanges;
    this.minWidth > 0 && n.length && (n.every(({ fromA: c, toA: h }) => h < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let i = -1;
    this.view.inputState.composing >= 0 && (!((r = this.domChanged) === null || r === void 0) && r.newSel ? i = this.domChanged.newSel.head : !DX(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let s = i > -1 ? gX(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: h } = this.hasComposition;
      n = new pn(c, h, e.changes.mapPos(c, -1), e.changes.mapPos(h, 1)).addToSet(n.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (Oe.ie || Oe.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let a = this.decorations, o = this.updateDeco(), u = xX(a, o, e.changes);
    return n = pn.extendWithRanges(n, u), !(this.flags & 7) && n.length == 0 ? !1 : (this.updateInner(n, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, r, n) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, r, n);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let a = Oe.chrome || Oe.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, a), this.flags &= -8, a && (a.written || i.selectionRange.focusNode != a.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (a) => a.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let a of this.children)
        a instanceof ls && a.widget instanceof Zx && s.push(a.dom);
    i.updateGaps(s);
  }
  updateChildren(e, r, n) {
    let i = n ? n.range.addToSet(e.slice()) : e, s = this.childCursor(r);
    for (let a = i.length - 1; ; a--) {
      let o = a >= 0 ? i[a] : null;
      if (!o)
        break;
      let { fromA: u, toA: c, fromB: h, toB: p } = o, m, g, O, b;
      if (n && n.range.fromB < p && n.range.toB > h) {
        let T = _l.build(this.view.state.doc, h, n.range.fromB, this.decorations, this.dynamicDecorationMap), C = _l.build(this.view.state.doc, n.range.toB, p, this.decorations, this.dynamicDecorationMap);
        g = T.breakAtStart, O = T.openStart, b = C.openEnd;
        let A = this.compositionView(n);
        C.breakAtStart ? A.breakAfter = 1 : C.content.length && A.merge(A.length, A.length, C.content[0], !1, C.openStart, 0) && (A.breakAfter = C.content[0].breakAfter, C.content.shift()), T.content.length && A.merge(0, 0, T.content[T.content.length - 1], !0, 0, T.openEnd) && T.content.pop(), m = T.content.concat(A).concat(C.content);
      } else
        ({ content: m, breakAtStart: g, openStart: O, openEnd: b } = _l.build(this.view.state.doc, h, p, this.decorations, this.dynamicDecorationMap));
      let { i: D, off: S } = s.findPos(c, 1), { i: x, off: w } = s.findPos(u, -1);
      GE(this, x, w, D, S, m, g, O, b);
    }
    n && this.fixCompositionDOM(n);
  }
  compositionView(e) {
    let r = new Ti(e.text.nodeValue);
    r.flags |= 8;
    for (let { deco: i } of e.marks)
      r = new ki(i, [r], r.length);
    let n = new Ft();
    return n.append(r, 0), n;
  }
  fixCompositionDOM(e) {
    let r = (s, a) => {
      a.flags |= 8 | (a.children.some(
        (u) => u.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(a);
      let o = ut.get(s);
      o && o != a && (o.dom = null), a.setDOM(s);
    }, n = this.childPos(e.range.fromB, 1), i = this.children[n.i];
    r(e.line, i);
    for (let s = e.marks.length - 1; s >= -1; s--)
      n = i.childPos(n.off, 1), i = i.children[n.i], r(s >= 0 ? e.marks[s].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, r = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let n = this.view.root.activeElement, i = n == this.dom, s = !i && nh(this.dom, this.view.observer.selectionRange) && !(n && this.dom.contains(n));
    if (!(i || r || s))
      return;
    let a = this.forceSelection;
    this.forceSelection = !1;
    let o = this.view.state.selection.main, u = this.moveToLine(this.domAtPos(o.anchor)), c = o.empty ? u : this.moveToLine(this.domAtPos(o.head));
    if (Oe.gecko && o.empty && !this.hasComposition && mX(u)) {
      let p = document.createTextNode("");
      this.view.observer.ignore(() => u.node.insertBefore(p, u.node.childNodes[u.offset] || null)), u = c = new or(p, 0), a = !0;
    }
    let h = this.view.observer.selectionRange;
    (a || !h.focusNode || (!Nl(u.node, u.offset, h.anchorNode, h.anchorOffset) || !Nl(c.node, c.offset, h.focusNode, h.focusOffset)) && !this.suppressWidgetCursorChange(h, o)) && (this.view.observer.ignore(() => {
      Oe.android && Oe.chrome && this.dom.contains(h.focusNode) && bX(h.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let p = Ih(this.view.root);
      if (p)
        if (o.empty) {
          if (Oe.gecko) {
            let m = yX(u.node, u.offset);
            if (m && m != 3) {
              let g = SA(u.node, u.offset, m == 1 ? 1 : -1);
              g && (u = new or(g.node, g.offset));
            }
          }
          p.collapse(u.node, u.offset), o.bidiLevel != null && p.caretBidiLevel !== void 0 && (p.caretBidiLevel = o.bidiLevel);
        } else if (p.extend) {
          p.collapse(u.node, u.offset);
          try {
            p.extend(c.node, c.offset);
          } catch {
          }
        } else {
          let m = document.createRange();
          o.anchor > o.head && ([u, c] = [c, u]), m.setEnd(c.node, c.offset), m.setStart(u.node, u.offset), p.removeAllRanges(), p.addRange(m);
        }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), n && n.focus());
    }), this.view.observer.setSelectionRange(u, c)), this.impreciseAnchor = u.precise ? null : new or(h.anchorNode, h.anchorOffset), this.impreciseHead = c.precise ? null : new or(h.focusNode, h.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, r) {
    return this.hasComposition && r.empty && Nl(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == r.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, r = e.state.selection.main, n = Ih(e.root), { anchorNode: i, anchorOffset: s } = e.observer.selectionRange;
    if (!n || !r.empty || !r.assoc || !n.modify)
      return;
    let a = Ft.find(this, r.head);
    if (!a)
      return;
    let o = a.posAtStart;
    if (r.head == o || r.head == o + a.length)
      return;
    let u = this.coordsAt(r.head, -1), c = this.coordsAt(r.head, 1);
    if (!u || !c || u.bottom > c.top)
      return;
    let h = this.domAtPos(r.head + r.assoc);
    n.collapse(h.node, h.offset), n.modify("move", r.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let p = e.observer.selectionRange;
    e.docView.posFromDOM(p.anchorNode, p.anchorOffset) != r.from && n.collapse(i, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let r = this.dom, n;
    if (e.node != r)
      return e;
    for (let i = e.offset; !n && i < r.childNodes.length; i++) {
      let s = ut.get(r.childNodes[i]);
      s instanceof Ft && (n = s.domAtPos(0));
    }
    for (let i = e.offset - 1; !n && i >= 0; i--) {
      let s = ut.get(r.childNodes[i]);
      s instanceof Ft && (n = s.domAtPos(s.length));
    }
    return n ? new or(n.node, n.offset, !0) : e;
  }
  nearest(e) {
    for (let r = e; r; ) {
      let n = ut.get(r);
      if (n && n.rootView == this)
        return n;
      r = r.parentNode;
    }
    return null;
  }
  posFromDOM(e, r) {
    let n = this.nearest(e);
    if (!n)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return n.localPosFromDOM(e, r) + n.posAtStart;
  }
  domAtPos(e) {
    let { i: r, off: n } = this.childCursor().findPos(e, -1);
    for (; r < this.children.length - 1; ) {
      let i = this.children[r];
      if (n < i.length || i instanceof Ft)
        break;
      r++, n = 0;
    }
    return this.children[r].domAtPos(n);
  }
  coordsAt(e, r) {
    let n = null, i = 0;
    for (let s = this.length, a = this.children.length - 1; a >= 0; a--) {
      let o = this.children[a], u = s - o.breakAfter, c = u - o.length;
      if (u < e)
        break;
      c <= e && (c < e || o.covers(-1)) && (u > e || o.covers(1)) && (!n || o instanceof Ft && !(n instanceof Ft && r >= 0)) && (n = o, i = c), s = c;
    }
    return n ? n.coordsAt(e - i, r) : null;
  }
  coordsForChar(e) {
    let { i: r, off: n } = this.childPos(e, 1), i = this.children[r];
    if (!(i instanceof Ft))
      return null;
    for (; i.children.length; ) {
      let { i: o, off: u } = i.childPos(n, 1);
      for (; ; o++) {
        if (o == i.children.length)
          return null;
        if ((i = i.children[o]).length)
          break;
      }
      n = u;
    }
    if (!(i instanceof Ti))
      return null;
    let s = Ut(i.text, n);
    if (s == n)
      return null;
    let a = ia(i.dom, n, s).getClientRects();
    for (let o = 0; o < a.length; o++) {
      let u = a[o];
      if (o == a.length - 1 || u.top < u.bottom && u.left < u.right)
        return u;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let r = [], { from: n, to: i } = e, s = this.view.contentDOM.clientWidth, a = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, o = -1, u = this.view.textDirection == ct.LTR;
    for (let c = 0, h = 0; h < this.children.length; h++) {
      let p = this.children[h], m = c + p.length;
      if (m > i)
        break;
      if (c >= n) {
        let g = p.dom.getBoundingClientRect();
        if (r.push(g.height), a) {
          let O = p.dom.lastChild, b = O ? po(O) : [];
          if (b.length) {
            let D = b[b.length - 1], S = u ? D.right - g.left : g.right - D.left;
            S > o && (o = S, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = m);
          }
        }
      }
      c = m + p.breakAfter;
    }
    return r;
  }
  textDirectionAt(e) {
    let { i: r } = this.childPos(e, 1);
    return getComputedStyle(this.children[r].dom).direction == "rtl" ? ct.RTL : ct.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof Ft) {
        let a = s.measureTextSize();
        if (a)
          return a;
      }
    let e = document.createElement("div"), r, n, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = po(e.firstChild)[0];
      r = e.getBoundingClientRect().height, n = s ? s.width / 27 : 7, i = s ? s.height : r, e.remove();
    }), { lineHeight: r, charWidth: n, textHeight: i };
  }
  childCursor(e = this.length) {
    let r = this.children.length;
    return r && (e -= this.children[--r].length), new zE(this.children, e, r);
  }
  computeBlockGapDeco() {
    let e = [], r = this.view.viewState;
    for (let n = 0, i = 0; ; i++) {
      let s = i == r.viewports.length ? null : r.viewports[i], a = s ? s.from - 1 : this.length;
      if (a > n) {
        let o = (r.lineBlockAt(a).bottom - r.lineBlockAt(n).top) / this.view.scaleY;
        e.push(be.replace({
          widget: new Zx(o),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(n, a));
      }
      if (!s)
        break;
      n = s.to + 1;
    }
    return be.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(ru).map((i, s) => (this.dynamicDecorationMap[s] = typeof i == "function") ? i(this.view) : i), r = !1, n = this.view.state.facet(OA).map((i, s) => {
      let a = typeof i == "function";
      return a && (r = !0), a ? i(this.view) : i;
    });
    n.length && (this.dynamicDecorationMap[e.length] = r, e.push(We.join(n)));
    for (let i = e.length; i < e.length + 3; i++)
      this.dynamicDecorationMap[i] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    let { range: r } = e, n = this.coordsAt(r.head, r.empty ? r.assoc : r.head > r.anchor ? -1 : 1), i;
    if (!n)
      return;
    !r.empty && (i = this.coordsAt(r.anchor, r.anchor > r.head ? -1 : 1)) && (n = {
      left: Math.min(n.left, i.left),
      top: Math.min(n.top, i.top),
      right: Math.max(n.right, i.right),
      bottom: Math.max(n.bottom, i.bottom)
    });
    let s = DA(this.view), a = {
      left: n.left - s.left,
      top: n.top - s.top,
      right: n.right + s.right,
      bottom: n.bottom + s.bottom
    }, { offsetWidth: o, offsetHeight: u } = this.view.scrollDOM;
    zq(this.view.scrollDOM, a, r.head < r.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, o), -o), Math.max(Math.min(e.yMargin, u), -u), this.view.textDirection == ct.LTR);
  }
}
function mX(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
class Zx extends fi {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
function vA(t, e) {
  let r = t.observer.selectionRange, n = r.focusNode && SA(r.focusNode, r.focusOffset, 0);
  if (!n)
    return null;
  let i = e - n.offset;
  return { from: i, to: i + n.node.nodeValue.length, node: n.node };
}
function gX(t, e, r) {
  let n = vA(t, r);
  if (!n)
    return null;
  let { node: i, from: s, to: a } = n, o = i.nodeValue;
  if (/[\n\r]/.test(o) || t.state.doc.sliceString(n.from, n.to) != o)
    return null;
  let u = e.invertedDesc, c = new pn(u.mapPos(s), u.mapPos(a), s, a), h = [];
  for (let p = i.parentNode; ; p = p.parentNode) {
    let m = ut.get(p);
    if (m instanceof ki)
      h.push({ node: p, deco: m.mark });
    else {
      if (m instanceof Ft || p.nodeName == "DIV" && p.parentNode == t.contentDOM)
        return { range: c, text: i, marks: h, line: p };
      if (p != t.contentDOM)
        h.push({ node: p, deco: new _u({
          inclusive: !0,
          attributes: nX(p),
          tagName: p.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function SA(t, e, r) {
  if (r <= 0)
    for (let n = t, i = e; ; ) {
      if (n.nodeType == 3)
        return { node: n, offset: i };
      if (n.nodeType == 1 && i > 0)
        n = n.childNodes[i - 1], i = Ai(n);
      else
        break;
    }
  if (r >= 0)
    for (let n = t, i = e; ; ) {
      if (n.nodeType == 3)
        return { node: n, offset: i };
      if (n.nodeType == 1 && i < n.childNodes.length && r >= 0)
        n = n.childNodes[i], i = 0;
      else
        break;
    }
  return null;
}
function yX(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let OX = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, r) {
    Hm(e, r, this.changes);
  }
  comparePoint(e, r) {
    Hm(e, r, this.changes);
  }
};
function xX(t, e, r) {
  let n = new OX();
  return We.compare(t, e, r, n), n.changes;
}
function bX(t, e) {
  for (let r = t; r && r != e; r = r.assignedSlot || r.parentNode)
    if (r.nodeType == 1 && r.contentEditable == "false")
      return !0;
  return !1;
}
function DX(t, e) {
  let r = !1;
  return e && t.iterChangedRanges((n, i) => {
    n < e.to && i > e.from && (r = !0);
  }), r;
}
function vX(t, e, r = 1) {
  let n = t.charCategorizer(e), i = t.doc.lineAt(e), s = e - i.from;
  if (i.length == 0)
    return G.cursor(e);
  s == 0 ? r = 1 : s == i.length && (r = -1);
  let a = s, o = s;
  r < 0 ? a = Ut(i.text, s, !1) : o = Ut(i.text, s);
  let u = n(i.text.slice(a, o));
  for (; a > 0; ) {
    let c = Ut(i.text, a, !1);
    if (n(i.text.slice(c, a)) != u)
      break;
    a = c;
  }
  for (; o < i.length; ) {
    let c = Ut(i.text, o);
    if (n(i.text.slice(o, c)) != u)
      break;
    o = c;
  }
  return G.range(a + i.from, o + i.from);
}
function SX(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function wX(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function cf(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function Wx(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function qx(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function rg(t, e, r) {
  let n, i, s, a, o = !1, u, c, h, p;
  for (let O = t.firstChild; O; O = O.nextSibling) {
    let b = po(O);
    for (let D = 0; D < b.length; D++) {
      let S = b[D];
      i && cf(i, S) && (S = Wx(qx(S, i.bottom), i.top));
      let x = SX(e, S), w = wX(r, S);
      if (x == 0 && w == 0)
        return O.nodeType == 3 ? Xx(O, e, r) : rg(O, e, r);
      if (!n || a > w || a == w && s > x) {
        n = O, i = S, s = x, a = w;
        let T = w ? r < S.top ? -1 : 1 : x ? e < S.left ? -1 : 1 : 0;
        o = !T || (T > 0 ? D < b.length - 1 : D > 0);
      }
      x == 0 ? r > S.bottom && (!h || h.bottom < S.bottom) ? (u = O, h = S) : r < S.top && (!p || p.top > S.top) && (c = O, p = S) : h && cf(h, S) ? h = qx(h, S.bottom) : p && cf(p, S) && (p = Wx(p, S.top));
    }
  }
  if (h && h.bottom >= r ? (n = u, i = h) : p && p.top <= r && (n = c, i = p), !n)
    return { node: t, offset: 0 };
  let m = Math.max(i.left, Math.min(i.right, e));
  if (n.nodeType == 3)
    return Xx(n, m, r);
  if (o && n.contentEditable != "false")
    return rg(n, m, r);
  let g = Array.prototype.indexOf.call(t.childNodes, n) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: t, offset: g };
}
function Xx(t, e, r) {
  let n = t.nodeValue.length, i = -1, s = 1e9, a = 0;
  for (let o = 0; o < n; o++) {
    let u = ia(t, o, o + 1).getClientRects();
    for (let c = 0; c < u.length; c++) {
      let h = u[c];
      if (h.top == h.bottom)
        continue;
      a || (a = e - h.left);
      let p = (h.top > r ? h.top - r : r - h.bottom) - 1;
      if (h.left - 1 <= e && h.right + 1 >= e && p < s) {
        let m = e >= (h.left + h.right) / 2, g = m;
        if ((Oe.chrome || Oe.gecko) && ia(t, o).getBoundingClientRect().left == h.right && (g = !m), p <= 0)
          return { node: t, offset: o + (g ? 1 : 0) };
        i = o + (g ? 1 : 0), s = p;
      }
    }
  }
  return { node: t, offset: i > -1 ? i : a > 0 ? t.nodeValue.length : 0 };
}
function wA(t, e, r, n = -1) {
  var i, s;
  let a = t.contentDOM.getBoundingClientRect(), o = a.top + t.viewState.paddingTop, u, { docHeight: c } = t.viewState, { x: h, y: p } = e, m = p - o;
  if (m < 0)
    return 0;
  if (m > c)
    return t.state.doc.length;
  for (let T = t.viewState.heightOracle.textHeight / 2, C = !1; u = t.elementAtHeight(m), u.type != yr.Text; )
    for (; m = n > 0 ? u.bottom + T : u.top - T, !(m >= 0 && m <= c); ) {
      if (C)
        return r ? null : 0;
      C = !0, n = -n;
    }
  p = o + m;
  let g = u.from;
  if (g < t.viewport.from)
    return t.viewport.from == 0 ? 0 : r ? null : Vx(t, a, u, h, p);
  if (g > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : r ? null : Vx(t, a, u, h, p);
  let O = t.dom.ownerDocument, b = t.root.elementFromPoint ? t.root : O, D = b.elementFromPoint(h, p);
  D && !t.contentDOM.contains(D) && (D = null), D || (h = Math.max(a.left + 1, Math.min(a.right - 1, h)), D = b.elementFromPoint(h, p), D && !t.contentDOM.contains(D) && (D = null));
  let S, x = -1;
  if (D && ((i = t.docView.nearest(D)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (O.caretPositionFromPoint) {
      let T = O.caretPositionFromPoint(h, p);
      T && ({ offsetNode: S, offset: x } = T);
    } else if (O.caretRangeFromPoint) {
      let T = O.caretRangeFromPoint(h, p);
      T && ({ startContainer: S, startOffset: x } = T, (!t.contentDOM.contains(S) || Oe.safari && CX(S, x, h) || Oe.chrome && EX(S, x, h)) && (S = void 0));
    }
  }
  if (!S || !t.docView.dom.contains(S)) {
    let T = Ft.find(t.docView, g);
    if (!T)
      return m > u.top + u.height / 2 ? u.to : u.from;
    ({ node: S, offset: x } = rg(T.dom, h, p));
  }
  let w = t.docView.nearest(S);
  if (!w)
    return null;
  if (w.isWidget && ((s = w.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let T = w.dom.getBoundingClientRect();
    return e.y < T.top || e.y <= T.bottom && e.x <= (T.left + T.right) / 2 ? w.posAtStart : w.posAtEnd;
  } else
    return w.localPosFromDOM(S, x) + w.posAtStart;
}
function Vx(t, e, r, n, i) {
  let s = Math.round((n - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && r.height > t.defaultLineHeight * 1.5) {
    let o = t.viewState.heightOracle.textHeight, u = Math.floor((i - r.top - (t.defaultLineHeight - o) * 0.5) / o);
    s += u * t.viewState.heightOracle.lineLength;
  }
  let a = t.state.sliceDoc(r.from, r.to);
  return r.from + Zm(a, s, t.state.tabSize);
}
function CX(t, e, r) {
  let n;
  if (t.nodeType != 3 || e != (n = t.nodeValue.length))
    return !1;
  for (let i = t.nextSibling; i; i = i.nextSibling)
    if (i.nodeType != 1 || i.nodeName != "BR")
      return !1;
  return ia(t, n - 1, n).getBoundingClientRect().left > r;
}
function EX(t, e, r) {
  if (e != 0)
    return !1;
  for (let i = t; ; ) {
    let s = i.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != i)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    i = s;
  }
  let n = t.nodeType == 1 ? t.getBoundingClientRect() : ia(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return r - n.left > 5;
}
function ng(t, e) {
  let r = t.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    for (let n of r.type)
      if (n.to > e || n.to == e && (n.to == r.to || n.type == yr.Text))
        return n;
  }
  return r;
}
function AX(t, e, r, n) {
  let i = ng(t, e.head), s = !n || i.type != yr.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (s) {
    let a = t.dom.getBoundingClientRect(), o = t.textDirectionAt(i.from), u = t.posAtCoords({
      x: r == (o == ct.LTR) ? a.right - 1 : a.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (u != null)
      return G.cursor(u, r ? -1 : 1);
  }
  return G.cursor(r ? i.to : i.from, r ? -1 : 1);
}
function Yx(t, e, r, n) {
  let i = t.state.doc.lineAt(e.head), s = t.bidiSpans(i), a = t.textDirectionAt(i.from);
  for (let o = e, u = null; ; ) {
    let c = pX(i, s, a, o, r), h = lA;
    if (!c) {
      if (i.number == (r ? t.state.doc.lines : 1))
        return o;
      h = `
`, i = t.state.doc.line(i.number + (r ? 1 : -1)), s = t.bidiSpans(i), c = t.visualLineSide(i, !r);
    }
    if (u) {
      if (!u(h))
        return o;
    } else {
      if (!n)
        return c;
      u = n(h);
    }
    o = c;
  }
}
function TX(t, e, r) {
  let n = t.state.charCategorizer(e), i = n(r);
  return (s) => {
    let a = n(s);
    return i == dt.Space && (i = a), i == a;
  };
}
function kX(t, e, r, n) {
  let i = e.head, s = r ? 1 : -1;
  if (i == (r ? t.state.doc.length : 0))
    return G.cursor(i, e.assoc);
  let a = e.goalColumn, o, u = t.contentDOM.getBoundingClientRect(), c = t.coordsAtPos(i, e.assoc || -1), h = t.documentTop;
  if (c)
    a == null && (a = c.left - u.left), o = s < 0 ? c.top : c.bottom;
  else {
    let g = t.viewState.lineBlockAt(i);
    a == null && (a = Math.min(u.right - u.left, t.defaultCharacterWidth * (i - g.from))), o = (s < 0 ? g.top : g.bottom) + h;
  }
  let p = u.left + a, m = n ?? t.viewState.heightOracle.textHeight >> 1;
  for (let g = 0; ; g += 10) {
    let O = o + (m + g) * s, b = wA(t, { x: p, y: O }, !1, s);
    if (O < u.top || O > u.bottom || (s < 0 ? b < i : b > i)) {
      let D = t.docView.coordsForChar(b), S = !D || O < D.top ? -1 : 1;
      return G.cursor(b, S, void 0, a);
    }
  }
}
function ih(t, e, r) {
  for (; ; ) {
    let n = 0;
    for (let i of t)
      i.between(e - 1, e + 1, (s, a, o) => {
        if (e > s && e < a) {
          let u = n || r || (e - s < a - e ? -1 : 1);
          e = u < 0 ? s : a, n = u;
        }
      });
    if (!n)
      return e;
  }
}
function hf(t, e, r) {
  let n = ih(t.state.facet(A0).map((i) => i(t)), r.from, e.head > r.from ? -1 : 1);
  return n == r.from ? r : G.cursor(n, n < r.from ? 1 : -1);
}
class PX {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, Oe.safari && e.contentDOM.addEventListener("input", () => null), Oe.gecko && VX(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !MX(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, r) {
    let n = this.handlers[e];
    if (n) {
      for (let i of n.observers)
        i(this.view, r);
      for (let i of n.handlers) {
        if (r.defaultPrevented)
          break;
        if (i(this.view, r)) {
          r.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let r = FX(e), n = this.handlers, i = this.view.contentDOM;
    for (let s in r)
      if (s != "scroll") {
        let a = !r[s].handlers.length, o = n[s];
        o && a != !o.handlers.length && (i.removeEventListener(s, this.handleEvent), o = null), o || i.addEventListener(s, this.handleEvent, { passive: a });
      }
    for (let s in n)
      s != "scroll" && !r[s] && i.removeEventListener(s, this.handleEvent);
    this.handlers = r;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (e.keyCode != 27 && EA.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), Oe.android && Oe.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let r;
    return Oe.ios && !e.synthetic && !e.altKey && !e.metaKey && ((r = CA.find((n) => n.keyCode == e.keyCode)) && !e.ctrlKey || $X.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = r || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let e = this.pendingIOSKey;
    return e ? (this.pendingIOSKey = void 0, Ja(this.view.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : Oe.safari && !Oe.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function Ux(t, e) {
  return (r, n) => {
    try {
      return e.call(t, n, r);
    } catch (i) {
      hn(r.state, i);
    }
  };
}
function FX(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function r(n) {
    return e[n] || (e[n] = { observers: [], handlers: [] });
  }
  for (let n of t) {
    let i = n.spec;
    if (i && i.domEventHandlers)
      for (let s in i.domEventHandlers) {
        let a = i.domEventHandlers[s];
        a && r(s).handlers.push(Ux(n.value, a));
      }
    if (i && i.domEventObservers)
      for (let s in i.domEventObservers) {
        let a = i.domEventObservers[s];
        a && r(s).observers.push(Ux(n.value, a));
      }
  }
  for (let n in Qn)
    r(n).handlers.push(Qn[n]);
  for (let n in Mn)
    r(n).observers.push(Mn[n]);
  return e;
}
const CA = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], $X = "dthko", EA = [16, 17, 18, 20, 91, 92, 224, 225], Ec = 6;
function Ac(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function BX(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class IX {
  constructor(e, r, n, i) {
    this.view = e, this.startEvent = r, this.style = n, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = r, this.scrollParent = Gq(e.contentDOM), this.atoms = e.state.facet(A0).map((a) => a(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = r.shiftKey, this.multiple = e.state.facet(Le.allowMultipleSelections) && NX(e, r), this.dragging = QX(e, r) && PA(r) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var r;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && BX(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let n = 0, i = 0, s = ((r = this.scrollParent) === null || r === void 0 ? void 0 : r.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, a = DA(this.view);
    e.clientX - a.left <= s.left + Ec ? n = -Ac(s.left - e.clientX) : e.clientX + a.right >= s.right - Ec && (n = Ac(e.clientX - s.right)), e.clientY - a.top <= s.top + Ec ? i = -Ac(s.top - e.clientY) : e.clientY + a.bottom >= s.bottom - Ec && (i = Ac(e.clientY - s.bottom)), this.setScrollSpeed(n, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, r) {
    this.scrollSpeed = { x: e, y: r }, e || r ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let r = null;
    for (let n = 0; n < e.ranges.length; n++) {
      let i = e.ranges[n], s = null;
      if (i.empty) {
        let a = ih(this.atoms, i.from, 0);
        a != i.from && (s = G.cursor(a, -1));
      } else {
        let a = ih(this.atoms, i.from, -1), o = ih(this.atoms, i.to, 1);
        (a != i.from || o != i.to) && (s = G.range(i.from == i.anchor ? a : o, i.from == i.head ? a : o));
      }
      s && (r || (r = e.ranges.slice()), r[n] = s);
    }
    return r ? G.create(r, e.mainIndex) : e;
  }
  select(e) {
    let { view: r } = this, n = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !n.eq(r.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: n,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function NX(t, e) {
  let r = t.state.facet(uA);
  return r.length ? r[0](e) : Oe.mac ? e.metaKey : e.ctrlKey;
}
function _X(t, e) {
  let r = t.state.facet(cA);
  return r.length ? r[0](e) : Oe.mac ? !e.altKey : !e.ctrlKey;
}
function QX(t, e) {
  let { main: r } = t.state.selection;
  if (r.empty)
    return !1;
  let n = Ih(t.root);
  if (!n || n.rangeCount == 0)
    return !0;
  let i = n.getRangeAt(0).getClientRects();
  for (let s = 0; s < i.length; s++) {
    let a = i[s];
    if (a.left <= e.clientX && a.right >= e.clientX && a.top <= e.clientY && a.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function MX(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let r = e.target, n; r != t.contentDOM; r = r.parentNode)
    if (!r || r.nodeType == 11 || (n = ut.get(r)) && n.ignoreEvent(e))
      return !1;
  return !0;
}
const Qn = /* @__PURE__ */ Object.create(null), Mn = /* @__PURE__ */ Object.create(null), AA = Oe.ie && Oe.ie_version < 15 || Oe.ios && Oe.webkit_version < 604;
function LX(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let r = e.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(), setTimeout(() => {
    t.focus(), r.remove(), TA(t, r.value);
  }, 50);
}
function TA(t, e) {
  let { state: r } = t, n, i = 1, s = r.toText(e), a = s.lines == r.selection.ranges.length;
  if (ig != null && r.selection.ranges.every((u) => u.empty) && ig == s.toString()) {
    let u = -1;
    n = r.changeByRange((c) => {
      let h = r.doc.lineAt(c.from);
      if (h.from == u)
        return { range: c };
      u = h.from;
      let p = r.toText((a ? s.line(i++).text : e) + r.lineBreak);
      return {
        changes: { from: h.from, insert: p },
        range: G.cursor(c.from + p.length)
      };
    });
  } else
    a ? n = r.changeByRange((u) => {
      let c = s.line(i++);
      return {
        changes: { from: u.from, to: u.to, insert: c.text },
        range: G.cursor(u.from + c.length)
      };
    }) : n = r.replaceSelection(s);
  t.dispatch(n, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Mn.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
Qn.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (t.inputState.lastEscPress = Date.now()), !1);
Mn.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
Mn.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
Qn.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let r = null;
  for (let n of t.state.facet(hA))
    if (r = n(t, e), r)
      break;
  if (!r && e.button == 0 && (r = ZX(t, e)), r) {
    let n = !t.hasFocus;
    t.inputState.startMouseSelection(new IX(t, e, r, n)), n && t.observer.ignore(() => VE(t.contentDOM));
    let i = t.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  }
  return !1;
};
function zx(t, e, r, n) {
  if (n == 1)
    return G.cursor(e, r);
  if (n == 2)
    return vX(t.state, e, r);
  {
    let i = Ft.find(t.docView, e), s = t.state.doc.lineAt(i ? i.posAtEnd : e), a = i ? i.posAtStart : s.from, o = i ? i.posAtEnd : s.to;
    return o < t.state.doc.length && o == s.to && o++, G.range(a, o);
  }
}
let kA = (t, e) => t >= e.top && t <= e.bottom, Gx = (t, e, r) => kA(e, r) && t >= r.left && t <= r.right;
function RX(t, e, r, n) {
  let i = Ft.find(t.docView, e);
  if (!i)
    return 1;
  let s = e - i.posAtStart;
  if (s == 0)
    return 1;
  if (s == i.length)
    return -1;
  let a = i.coordsAt(s, -1);
  if (a && Gx(r, n, a))
    return -1;
  let o = i.coordsAt(s, 1);
  return o && Gx(r, n, o) ? 1 : a && kA(n, a) ? -1 : 1;
}
function Hx(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: r, bias: RX(t, r, e.clientX, e.clientY) };
}
const jX = Oe.ie && Oe.ie_version <= 11;
let Jx = null, Kx = 0, eb = 0;
function PA(t) {
  if (!jX)
    return t.detail;
  let e = Jx, r = eb;
  return Jx = t, eb = Date.now(), Kx = !e || r > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (Kx + 1) % 3 : 1;
}
function ZX(t, e) {
  let r = Hx(t, e), n = PA(e), i = t.state.selection;
  return {
    update(s) {
      s.docChanged && (r.pos = s.changes.mapPos(r.pos), i = i.map(s.changes));
    },
    get(s, a, o) {
      let u = Hx(t, s), c, h = zx(t, u.pos, u.bias, n);
      if (r.pos != u.pos && !a) {
        let p = zx(t, r.pos, r.bias, n), m = Math.min(p.from, h.from), g = Math.max(p.to, h.to);
        h = m < h.from ? G.range(m, g) : G.range(g, m);
      }
      return a ? i.replaceRange(i.main.extend(h.from, h.to)) : o && n == 1 && i.ranges.length > 1 && (c = WX(i, u.pos)) ? c : o ? i.addRange(h) : G.create([h]);
    }
  };
}
function WX(t, e) {
  for (let r = 0; r < t.ranges.length; r++) {
    let { from: n, to: i } = t.ranges[r];
    if (n <= e && i >= e)
      return G.create(t.ranges.slice(0, r).concat(t.ranges.slice(r + 1)), t.mainIndex == r ? 0 : t.mainIndex - (t.mainIndex > r ? 1 : 0));
  }
  return null;
}
Qn.dragstart = (t, e) => {
  let { selection: { main: r } } = t.state;
  if (e.target.draggable) {
    let i = t.docView.nearest(e.target);
    if (i && i.isWidget) {
      let s = i.posAtStart, a = s + i.length;
      (s >= r.to || a <= r.from) && (r = G.range(s, a));
    }
  }
  let { inputState: n } = t;
  return n.mouseSelection && (n.mouseSelection.dragging = !0), n.draggedContent = r, e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(r.from, r.to)), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Qn.dragend = (t) => (t.inputState.draggedContent = null, !1);
function tb(t, e, r, n) {
  if (!r)
    return;
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = t.inputState, a = n && s && _X(t, e) ? { from: s.from, to: s.to } : null, o = { from: i, insert: r }, u = t.state.changes(a ? [a, o] : o);
  t.focus(), t.dispatch({
    changes: u,
    selection: { anchor: u.mapPos(i, -1), head: u.mapPos(i, 1) },
    userEvent: a ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
Qn.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let r = e.dataTransfer.files;
  if (r && r.length) {
    let n = Array(r.length), i = 0, s = () => {
      ++i == r.length && tb(t, e, n.filter((a) => a != null).join(t.state.lineBreak), !1);
    };
    for (let a = 0; a < r.length; a++) {
      let o = new FileReader();
      o.onerror = s, o.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(o.result) || (n[a] = o.result), s();
      }, o.readAsText(r[a]);
    }
    return !0;
  } else {
    let n = e.dataTransfer.getData("Text");
    if (n)
      return tb(t, e, n, !0), !0;
  }
  return !1;
};
Qn.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let r = AA ? null : e.clipboardData;
  return r ? (TA(t, r.getData("text/plain") || r.getData("text/uri-text")), !0) : (LX(t), !1);
};
function qX(t, e) {
  let r = t.dom.parentNode;
  if (!r)
    return;
  let n = r.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.value = e, n.focus(), n.selectionEnd = e.length, n.selectionStart = 0, setTimeout(() => {
    n.remove(), t.focus();
  }, 50);
}
function XX(t) {
  let e = [], r = [], n = !1;
  for (let i of t.selection.ranges)
    i.empty || (e.push(t.sliceDoc(i.from, i.to)), r.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: s } of t.selection.ranges) {
      let a = t.doc.lineAt(s);
      a.number > i && (e.push(a.text), r.push({ from: a.from, to: Math.min(t.doc.length, a.to + 1) })), i = a.number;
    }
    n = !0;
  }
  return { text: e.join(t.lineBreak), ranges: r, linewise: n };
}
let ig = null;
Qn.copy = Qn.cut = (t, e) => {
  let { text: r, ranges: n, linewise: i } = XX(t.state);
  if (!r && !i)
    return !1;
  ig = i ? r : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: n,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = AA ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", r), !0) : (qX(t, r), !1);
};
const FA = /* @__PURE__ */ pi.define();
function $A(t, e) {
  let r = [];
  for (let n of t.facet(fA)) {
    let i = n(t, e);
    i && r.push(i);
  }
  return r ? t.update({ effects: r, annotations: FA.of(!0) }) : null;
}
function BA(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let r = $A(t.state, e);
      r ? t.dispatch(r) : t.update([]);
    }
  }, 10);
}
Mn.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), BA(t);
};
Mn.blur = (t) => {
  t.observer.clearSelectionRange(), BA(t);
};
Mn.compositionstart = Mn.compositionupdate = (t) => {
  t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0);
};
Mn.compositionend = (t) => {
  t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, Oe.chrome && Oe.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50);
};
Mn.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
Qn.beforeinput = (t, e) => {
  var r;
  let n;
  if (Oe.chrome && Oe.android && (n = CA.find((i) => i.inputType == e.inputType)) && (t.observer.delayAndroidKey(n.key, n.keyCode), n.key == "Backspace" || n.key == "Delete")) {
    let i = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > i + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return !1;
};
const rb = /* @__PURE__ */ new Set();
function VX(t) {
  rb.has(t) || (rb.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const nb = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class YX {
  constructor(e) {
    this.lineWrapping = e, this.doc = Xe.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, r) {
    let n = this.doc.lineAt(r).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (n += Math.max(0, Math.ceil((r - e - n * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * n;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return nb.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let r = !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n];
      i < 0 ? n++ : this.heightSamples[Math.floor(i * 10)] || (r = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return r;
  }
  refresh(e, r, n, i, s, a) {
    let o = nb.indexOf(e) > -1, u = Math.round(r) != Math.round(this.lineHeight) || this.lineWrapping != o;
    if (this.lineWrapping = o, this.lineHeight = r, this.charWidth = n, this.textHeight = i, this.lineLength = s, u) {
      this.heightSamples = {};
      for (let c = 0; c < a.length; c++) {
        let h = a[c];
        h < 0 ? c++ : this.heightSamples[Math.floor(h * 10)] = !0;
      }
    }
    return u;
  }
}
class UX {
  constructor(e, r) {
    this.from = e, this.heights = r, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Gn {
  /**
  @internal
  */
  constructor(e, r, n, i, s) {
    this.from = e, this.length = r, this.top = n, this.height = i, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? yr.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof bs ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let r = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new Gn(this.from, this.length + e.length, this.top, this.height + e.height, r);
  }
}
var lt = /* @__PURE__ */ function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
}(lt || (lt = {}));
const sh = 1e-3;
class Or {
  constructor(e, r, n = 2) {
    this.length = e, this.height = r, this.flags = n;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, r) {
    this.height != r && (Math.abs(this.height - r) > sh && (e.heightChanged = !0), this.height = r);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, r, n) {
    return Or.of(n);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, r) {
    r.push(this);
  }
  decomposeRight(e, r) {
    r.push(this);
  }
  applyChanges(e, r, n, i) {
    let s = this, a = n.doc;
    for (let o = i.length - 1; o >= 0; o--) {
      let { fromA: u, toA: c, fromB: h, toB: p } = i[o], m = s.lineAt(u, lt.ByPosNoHeight, n.setDoc(r), 0, 0), g = m.to >= c ? m : s.lineAt(c, lt.ByPosNoHeight, n, 0, 0);
      for (p += g.to - c, c = g.to; o > 0 && m.from <= i[o - 1].toA; )
        u = i[o - 1].fromA, h = i[o - 1].fromB, o--, u < m.from && (m = s.lineAt(u, lt.ByPosNoHeight, n, 0, 0));
      h += m.from - u, u = m.from;
      let O = T0.build(n.setDoc(a), e, h, p);
      s = s.replace(u, c, O);
    }
    return s.updateHeight(n, 0);
  }
  static empty() {
    return new Zr(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let r = 0, n = e.length, i = 0, s = 0;
    for (; ; )
      if (r == n)
        if (i > s * 2) {
          let o = e[r - 1];
          o.break ? e.splice(--r, 1, o.left, null, o.right) : e.splice(--r, 1, o.left, o.right), n += 1 + o.break, i -= o.size;
        } else if (s > i * 2) {
          let o = e[n];
          o.break ? e.splice(n, 1, o.left, null, o.right) : e.splice(n, 1, o.left, o.right), n += 2 + o.break, s -= o.size;
        } else
          break;
      else if (i < s) {
        let o = e[r++];
        o && (i += o.size);
      } else {
        let o = e[--n];
        o && (s += o.size);
      }
    let a = 0;
    return e[r - 1] == null ? (a = 1, r--) : e[r] == null && (a = 1, n++), new zX(Or.of(e.slice(0, r)), a, Or.of(e.slice(n)));
  }
}
Or.prototype.size = 1;
class IA extends Or {
  constructor(e, r, n) {
    super(e, r), this.deco = n;
  }
  blockAt(e, r, n, i) {
    return new Gn(i, this.length, n, this.height, this.deco || 0);
  }
  lineAt(e, r, n, i, s) {
    return this.blockAt(0, n, i, s);
  }
  forEachLine(e, r, n, i, s, a) {
    e <= s + this.length && r >= s && a(this.blockAt(0, n, i, s));
  }
  updateHeight(e, r = 0, n = !1, i) {
    return i && i.from <= r && i.more && this.setHeight(e, i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Zr extends IA {
  constructor(e, r) {
    super(e, r, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, r, n, i) {
    return new Gn(i, this.length, n, this.height, this.breaks);
  }
  replace(e, r, n) {
    let i = n[0];
    return n.length == 1 && (i instanceof Zr || i instanceof Zt && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof Zt ? i = new Zr(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : Or.of(n);
  }
  updateHeight(e, r = 0, n = !1, i) {
    return i && i.from <= r && i.more ? this.setHeight(e, i.heights[i.index++]) : (n || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Zt extends Or {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, r) {
    let n = e.doc.lineAt(r).number, i = e.doc.lineAt(r + this.length).number, s = i - n + 1, a, o = 0;
    if (e.lineWrapping) {
      let u = Math.min(this.height, e.lineHeight * s);
      a = u / s, this.length > s + 1 && (o = (this.height - u) / (this.length - s - 1));
    } else
      a = this.height / s;
    return { firstLine: n, lastLine: i, perLine: a, perChar: o };
  }
  blockAt(e, r, n, i) {
    let { firstLine: s, lastLine: a, perLine: o, perChar: u } = this.heightMetrics(r, i);
    if (r.lineWrapping) {
      let c = i + Math.round(Math.max(0, Math.min(1, (e - n) / this.height)) * this.length), h = r.doc.lineAt(c), p = o + h.length * u, m = Math.max(n, e - p / 2);
      return new Gn(h.from, h.length, m, p, 0);
    } else {
      let c = Math.max(0, Math.min(a - s, Math.floor((e - n) / o))), { from: h, length: p } = r.doc.line(s + c);
      return new Gn(h, p, n + o * c, o, 0);
    }
  }
  lineAt(e, r, n, i, s) {
    if (r == lt.ByHeight)
      return this.blockAt(e, n, i, s);
    if (r == lt.ByPosNoHeight) {
      let { from: g, to: O } = n.doc.lineAt(e);
      return new Gn(g, O - g, 0, 0, 0);
    }
    let { firstLine: a, perLine: o, perChar: u } = this.heightMetrics(n, s), c = n.doc.lineAt(e), h = o + c.length * u, p = c.number - a, m = i + o * p + u * (c.from - s - p);
    return new Gn(c.from, c.length, Math.max(i, Math.min(m, i + this.height - h)), h, 0);
  }
  forEachLine(e, r, n, i, s, a) {
    e = Math.max(e, s), r = Math.min(r, s + this.length);
    let { firstLine: o, perLine: u, perChar: c } = this.heightMetrics(n, s);
    for (let h = e, p = i; h <= r; ) {
      let m = n.doc.lineAt(h);
      if (h == e) {
        let O = m.number - o;
        p += u * O + c * (e - s - O);
      }
      let g = u + c * m.length;
      a(new Gn(m.from, m.length, p, g, 0)), p += g, h = m.to + 1;
    }
  }
  replace(e, r, n) {
    let i = this.length - r;
    if (i > 0) {
      let s = n[n.length - 1];
      s instanceof Zt ? n[n.length - 1] = new Zt(s.length + i) : n.push(null, new Zt(i - 1));
    }
    if (e > 0) {
      let s = n[0];
      s instanceof Zt ? n[0] = new Zt(e + s.length) : n.unshift(new Zt(e - 1), null);
    }
    return Or.of(n);
  }
  decomposeLeft(e, r) {
    r.push(new Zt(e - 1), null);
  }
  decomposeRight(e, r) {
    r.push(null, new Zt(this.length - e - 1));
  }
  updateHeight(e, r = 0, n = !1, i) {
    let s = r + this.length;
    if (i && i.from <= r + this.length && i.more) {
      let a = [], o = Math.max(r, i.from), u = -1;
      for (i.from > r && a.push(new Zt(i.from - r - 1).updateHeight(e, r)); o <= s && i.more; ) {
        let h = e.doc.lineAt(o).length;
        a.length && a.push(null);
        let p = i.heights[i.index++];
        u == -1 ? u = p : Math.abs(p - u) >= sh && (u = -2);
        let m = new Zr(h, p);
        m.outdated = !1, a.push(m), o += h + 1;
      }
      o <= s && a.push(null, new Zt(s - o).updateHeight(e, o));
      let c = Or.of(a);
      return (u < 0 || Math.abs(c.height - this.height) >= sh || Math.abs(u - this.heightMetrics(e, r).perLine) >= sh) && (e.heightChanged = !0), c;
    } else
      (n || this.outdated) && (this.setHeight(e, e.heightForGap(r, r + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class zX extends Or {
  constructor(e, r, n) {
    super(e.length + r + n.length, e.height + n.height, r | (e.outdated || n.outdated ? 2 : 0)), this.left = e, this.right = n, this.size = e.size + n.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, r, n, i) {
    let s = n + this.left.height;
    return e < s ? this.left.blockAt(e, r, n, i) : this.right.blockAt(e, r, s, i + this.left.length + this.break);
  }
  lineAt(e, r, n, i, s) {
    let a = i + this.left.height, o = s + this.left.length + this.break, u = r == lt.ByHeight ? e < a : e < o, c = u ? this.left.lineAt(e, r, n, i, s) : this.right.lineAt(e, r, n, a, o);
    if (this.break || (u ? c.to < o : c.from > o))
      return c;
    let h = r == lt.ByPosNoHeight ? lt.ByPosNoHeight : lt.ByPos;
    return u ? c.join(this.right.lineAt(o, h, n, a, o)) : this.left.lineAt(o, h, n, i, s).join(c);
  }
  forEachLine(e, r, n, i, s, a) {
    let o = i + this.left.height, u = s + this.left.length + this.break;
    if (this.break)
      e < u && this.left.forEachLine(e, r, n, i, s, a), r >= u && this.right.forEachLine(e, r, n, o, u, a);
    else {
      let c = this.lineAt(u, lt.ByPos, n, i, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, n, i, s, a), c.to >= e && c.from <= r && a(c), r > c.to && this.right.forEachLine(c.to + 1, r, n, o, u, a);
    }
  }
  replace(e, r, n) {
    let i = this.left.length + this.break;
    if (r < i)
      return this.balanced(this.left.replace(e, r, n), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, r - i, n));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let a = s.length;
    for (let o of n)
      s.push(o);
    if (e > 0 && ib(s, a - 1), r < this.length) {
      let o = s.length;
      this.decomposeRight(r, s), ib(s, o);
    }
    return Or.of(s);
  }
  decomposeLeft(e, r) {
    let n = this.left.length;
    if (e <= n)
      return this.left.decomposeLeft(e, r);
    r.push(this.left), this.break && (n++, e >= n && r.push(null)), e > n && this.right.decomposeLeft(e - n, r);
  }
  decomposeRight(e, r) {
    let n = this.left.length, i = n + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, r);
    e < n && this.left.decomposeRight(e, r), this.break && e < i && r.push(null), r.push(this.right);
  }
  balanced(e, r) {
    return e.size > 2 * r.size || r.size > 2 * e.size ? Or.of(this.break ? [e, null, r] : [e, r]) : (this.left = e, this.right = r, this.height = e.height + r.height, this.outdated = e.outdated || r.outdated, this.size = e.size + r.size, this.length = e.length + this.break + r.length, this);
  }
  updateHeight(e, r = 0, n = !1, i) {
    let { left: s, right: a } = this, o = r + s.length + this.break, u = null;
    return i && i.from <= r + s.length && i.more ? u = s = s.updateHeight(e, r, n, i) : s.updateHeight(e, r, n), i && i.from <= o + a.length && i.more ? u = a = a.updateHeight(e, o, n, i) : a.updateHeight(e, o, n), u ? this.balanced(s, a) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function ib(t, e) {
  let r, n;
  t[e] == null && (r = t[e - 1]) instanceof Zt && (n = t[e + 1]) instanceof Zt && t.splice(e - 1, 3, new Zt(r.length + 1 + n.length));
}
const GX = 5;
class T0 {
  constructor(e, r) {
    this.pos = e, this.oracle = r, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, r) {
    if (this.lineStart > -1) {
      let n = Math.min(r, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof Zr ? i.length += n - this.pos : (n > this.pos || !this.isCovered) && this.nodes.push(new Zr(n - this.pos, -1)), this.writtenTo = n, r > n && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = r;
  }
  point(e, r, n) {
    if (e < r || n.heightRelevant) {
      let i = n.widget ? n.widget.estimatedHeight : 0, s = n.widget ? n.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let a = r - e;
      n.block ? this.addBlock(new IA(a, i, n)) : (a || s || i >= GX) && this.addLineDeco(i, s, a);
    } else
      r > e && this.span(e, r);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: r } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = r, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Zr(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, r) {
    let n = new Zt(r - e);
    return this.oracle.doc.lineAt(e).to == r && (n.flags |= 4), n;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Zr)
      return e;
    let r = new Zr(0, -1);
    return this.nodes.push(r), r;
  }
  addBlock(e) {
    this.enterLine();
    let r = e.deco;
    r && r.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, r && r.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, r, n) {
    let i = this.ensureLine();
    i.length += n, i.collapsed += n, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += r, this.writtenTo = this.pos = this.pos + n;
  }
  finish(e) {
    let r = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(r instanceof Zr) && !this.isCovered ? this.nodes.push(new Zr(0, -1)) : (this.writtenTo < this.pos || r == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let n = e;
    for (let i of this.nodes)
      i instanceof Zr && i.updateHeight(this.oracle, n), n += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, r, n, i) {
    let s = new T0(n, e);
    return We.spans(r, n, i, s, 0), s.finish(n);
  }
}
function HX(t, e, r) {
  let n = new JX();
  return We.compare(t, e, r, n, 0), n.changes;
}
class JX {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, r, n, i) {
    (e < r || n && n.heightRelevant || i && i.heightRelevant) && Hm(e, r, this.changes, 5);
  }
}
function KX(t, e) {
  let r = t.getBoundingClientRect(), n = t.ownerDocument, i = n.defaultView || window, s = Math.max(0, r.left), a = Math.min(i.innerWidth, r.right), o = Math.max(0, r.top), u = Math.min(i.innerHeight, r.bottom);
  for (let c = t.parentNode; c && c != n.body; )
    if (c.nodeType == 1) {
      let h = c, p = window.getComputedStyle(h);
      if ((h.scrollHeight > h.clientHeight || h.scrollWidth > h.clientWidth) && p.overflow != "visible") {
        let m = h.getBoundingClientRect();
        s = Math.max(s, m.left), a = Math.min(a, m.right), o = Math.max(o, m.top), u = c == t.parentNode ? m.bottom : Math.min(u, m.bottom);
      }
      c = p.position == "absolute" || p.position == "fixed" ? h.offsetParent : h.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - r.left,
    right: Math.max(s, a) - r.left,
    top: o - (r.top + e),
    bottom: Math.max(o, u) - (r.top + e)
  };
}
function eV(t, e) {
  let r = t.getBoundingClientRect();
  return {
    left: 0,
    right: r.right - r.left,
    top: e,
    bottom: r.bottom - (r.top + e)
  };
}
class pf {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.size = n;
  }
  static same(e, r) {
    if (e.length != r.length)
      return !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n], s = r[n];
      if (i.from != s.from || i.to != s.to || i.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, r) {
    return be.replace({
      widget: new tV(this.size * (r ? e.scaleY : e.scaleX), r)
    }).range(this.from, this.to);
  }
}
class tV extends fi {
  constructor(e, r) {
    super(), this.size = e, this.vertical = r;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class sb {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = ab, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = ct.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let r = e.facet(E0).some((n) => typeof n != "function" && n.class == "cm-lineWrapping");
    this.heightOracle = new YX(r), this.stateDeco = e.facet(ru).filter((n) => typeof n != "function"), this.heightMap = Or.empty().applyChanges(this.stateDeco, Xe.empty, this.heightOracle.setDoc(e.doc), [new pn(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = be.set(this.lineGaps.map((n) => n.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: r } = this.state.selection;
    for (let n = 0; n <= 1; n++) {
      let i = n ? r.head : r.anchor;
      if (!e.some(({ from: s, to: a }) => i >= s && i <= a)) {
        let { from: s, to: a } = this.lineBlockAt(i);
        e.push(new Tc(s, a));
      }
    }
    this.viewports = e.sort((n, i) => n.from - i.from), this.scaler = this.heightMap.height <= 7e6 ? ab : new iV(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : ml(e, this.scaler));
    });
  }
  update(e, r = null) {
    this.state = e.state;
    let n = this.stateDeco;
    this.stateDeco = this.state.facet(ru).filter((h) => typeof h != "function");
    let i = e.changedRanges, s = pn.extendWithRanges(i, HX(n, this.stateDeco, e ? e.changes : Bt.empty(this.state.doc.length))), a = this.heightMap.height, o = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != a && (e.flags |= 2), o ? (this.scrollAnchorPos = e.changes.mapPos(o.from, -1), this.scrollAnchorHeight = o.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let u = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (r && (r.range.head < u.from || r.range.head > u.to) || !this.viewportIsAppropriate(u)) && (u = this.getViewport(0, r));
    let c = !e.changes.empty || e.flags & 2 || u.from != this.viewport.from || u.to != this.viewport.to;
    this.viewport = u, this.updateForViewport(), c && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), r && (this.scrollTarget = r), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(gA) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let r = e.contentDOM, n = window.getComputedStyle(r), i = this.heightOracle, s = n.whiteSpace;
    this.defaultTextDirection = n.direction == "rtl" ? ct.RTL : ct.LTR;
    let a = this.heightOracle.mustRefreshForWrapping(s), o = r.getBoundingClientRect(), u = a || this.mustMeasureContent || this.contentDOMHeight != o.height;
    this.contentDOMHeight = o.height, this.mustMeasureContent = !1;
    let c = 0, h = 0;
    if (o.width && o.height) {
      let { scaleX: T, scaleY: C } = XE(r, o);
      (this.scaleX != T || this.scaleY != C) && (this.scaleX = T, this.scaleY = C, c |= 8, a = u = !0);
    }
    let p = (parseInt(n.paddingTop) || 0) * this.scaleY, m = (parseInt(n.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != p || this.paddingBottom != m) && (this.paddingTop = p, this.paddingBottom = m, c |= 10), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (u = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 8);
    let g = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != g && (this.scrollAnchorHeight = -1, this.scrollTop = g), this.scrolledToBottom = UE(e.scrollDOM);
    let O = (this.printing ? eV : KX)(r, this.paddingTop), b = O.top - this.pixelViewport.top, D = O.bottom - this.pixelViewport.bottom;
    this.pixelViewport = O;
    let S = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (S != this.inView && (this.inView = S, S && (u = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let x = o.width;
    if ((this.contentDOMWidth != x || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = o.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 8), u) {
      let T = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(T) && (a = !0), a || i.lineWrapping && Math.abs(x - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: C, charWidth: A, textHeight: P } = e.docView.measureTextSize();
        a = C > 0 && i.refresh(s, C, A, P, x / A, T), a && (e.docView.minWidth = 0, c |= 8);
      }
      b > 0 && D > 0 ? h = Math.max(b, D) : b < 0 && D < 0 && (h = Math.min(b, D)), i.heightChanged = !1;
      for (let C of this.viewports) {
        let A = C.from == this.viewport.from ? T : e.docView.measureVisibleLineHeights(C);
        this.heightMap = (a ? Or.empty().applyChanges(this.stateDeco, Xe.empty, this.heightOracle, [new pn(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, a, new UX(C.from, A));
      }
      i.heightChanged && (c |= 2);
    }
    let w = !this.viewportIsAppropriate(this.viewport, h) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return w && (this.viewport = this.getViewport(h, this.scrollTarget)), this.updateForViewport(), (c & 2 || w) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(a ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, r) {
    let n = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, s = this.heightOracle, { visibleTop: a, visibleBottom: o } = this, u = new Tc(i.lineAt(a - n * 1e3, lt.ByHeight, s, 0, 0).from, i.lineAt(o + (1 - n) * 1e3, lt.ByHeight, s, 0, 0).to);
    if (r) {
      let { head: c } = r.range;
      if (c < u.from || c > u.to) {
        let h = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), p = i.lineAt(c, lt.ByPos, s, 0, 0), m;
        r.y == "center" ? m = (p.top + p.bottom) / 2 - h / 2 : r.y == "start" || r.y == "nearest" && c < u.from ? m = p.top : m = p.bottom - h, u = new Tc(i.lineAt(m - 1e3 / 2, lt.ByHeight, s, 0, 0).from, i.lineAt(m + h + 1e3 / 2, lt.ByHeight, s, 0, 0).to);
      }
    }
    return u;
  }
  mapViewport(e, r) {
    let n = r.mapPos(e.from, -1), i = r.mapPos(e.to, 1);
    return new Tc(this.heightMap.lineAt(n, lt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, lt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: r }, n = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, lt.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(r, lt.ByPos, this.heightOracle, 0, 0), { visibleTop: a, visibleBottom: o } = this;
    return (e == 0 || i <= a - Math.max(10, Math.min(
      -n,
      250
      /* VP.MaxCoverMargin */
    ))) && (r == this.state.doc.length || s >= o + Math.max(10, Math.min(
      n,
      250
      /* VP.MaxCoverMargin */
    ))) && i > a - 2 * 1e3 && s < o + 2 * 1e3;
  }
  mapLineGaps(e, r) {
    if (!e.length || r.empty)
      return e;
    let n = [];
    for (let i of e)
      r.touchesRange(i.from, i.to) || n.push(new pf(r.mapPos(i.from), r.mapPos(i.to), i.size));
    return n;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, r) {
    let n = this.heightOracle.lineWrapping, i = n ? 1e4 : 2e3, s = i >> 1, a = i << 1;
    if (this.defaultTextDirection != ct.LTR && !n)
      return [];
    let o = [], u = (c, h, p, m) => {
      if (h - c < s)
        return;
      let g = this.state.selection.main, O = [g.from];
      g.empty || O.push(g.to);
      for (let D of O)
        if (D > c && D < h) {
          u(c, D - 10, p, m), u(D + 10, h, p, m);
          return;
        }
      let b = nV(e, (D) => D.from >= p.from && D.to <= p.to && Math.abs(D.from - c) < s && Math.abs(D.to - h) < s && !O.some((S) => D.from < S && D.to > S));
      if (!b) {
        if (h < p.to && r && n && r.visibleRanges.some((D) => D.from <= h && D.to >= h)) {
          let D = r.moveToLineBoundary(G.cursor(h), !1, !0).head;
          D > c && (h = D);
        }
        b = new pf(c, h, this.gapSize(p, c, h, m));
      }
      o.push(b);
    };
    for (let c of this.viewportLines) {
      if (c.length < a)
        continue;
      let h = rV(c.from, c.to, this.stateDeco);
      if (h.total < a)
        continue;
      let p = this.scrollTarget ? this.scrollTarget.range.head : null, m, g;
      if (n) {
        let O = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, b, D;
        if (p != null) {
          let S = Pc(h, p), x = ((this.visibleBottom - this.visibleTop) / 2 + O) / c.height;
          b = S - x, D = S + x;
        } else
          b = (this.visibleTop - c.top - O) / c.height, D = (this.visibleBottom - c.top + O) / c.height;
        m = kc(h, b), g = kc(h, D);
      } else {
        let O = h.total * this.heightOracle.charWidth, b = i * this.heightOracle.charWidth, D, S;
        if (p != null) {
          let x = Pc(h, p), w = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + b) / O;
          D = x - w, S = x + w;
        } else
          D = (this.pixelViewport.left - b) / O, S = (this.pixelViewport.right + b) / O;
        m = kc(h, D), g = kc(h, S);
      }
      m > c.from && u(c.from, m, c, h), g < c.to && u(g, c.to, c, h);
    }
    return o;
  }
  gapSize(e, r, n, i) {
    let s = Pc(i, n) - Pc(i, r);
    return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    pf.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = be.set(e.map((r) => r.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let r = [];
    We.spans(e, this.viewport.from, this.viewport.to, {
      span(i, s) {
        r.push({ from: i, to: s });
      },
      point() {
      }
    }, 20);
    let n = r.length != this.visibleRanges.length || this.visibleRanges.some((i, s) => i.from != r[s].from || i.to != r[s].to);
    return this.visibleRanges = r, n ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((r) => r.from <= e && r.to >= e) || ml(this.heightMap.lineAt(e, lt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return ml(this.heightMap.lineAt(this.scaler.fromDOM(e), lt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let r = this.lineBlockAtHeight(e + 8);
    return r.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? r : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return ml(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Tc {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
function rV(t, e, r) {
  let n = [], i = t, s = 0;
  return We.spans(r, t, e, {
    span() {
    },
    point(a, o) {
      a > i && (n.push({ from: i, to: a }), s += a - i), i = o;
    }
  }, 20), i < e && (n.push({ from: i, to: e }), s += e - i), { total: s, ranges: n };
}
function kc({ total: t, ranges: e }, r) {
  if (r <= 0)
    return e[0].from;
  if (r >= 1)
    return e[e.length - 1].to;
  let n = Math.floor(t * r);
  for (let i = 0; ; i++) {
    let { from: s, to: a } = e[i], o = a - s;
    if (n <= o)
      return s + n;
    n -= o;
  }
}
function Pc(t, e) {
  let r = 0;
  for (let { from: n, to: i } of t.ranges) {
    if (e <= i) {
      r += e - n;
      break;
    }
    r += i - n;
  }
  return r / t.total;
}
function nV(t, e) {
  for (let r of t)
    if (e(r))
      return r;
}
const ab = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1
};
class iV {
  constructor(e, r, n) {
    let i = 0, s = 0, a = 0;
    this.viewports = n.map(({ from: o, to: u }) => {
      let c = r.lineAt(o, lt.ByPos, e, 0, 0).top, h = r.lineAt(u, lt.ByPos, e, 0, 0).bottom;
      return i += h - c, { from: o, to: u, top: c, bottom: h, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (r.height - i);
    for (let o of this.viewports)
      o.domTop = a + (o.top - s) * this.scale, a = o.domBottom = o.domTop + (o.bottom - o.top), s = o.bottom;
  }
  toDOM(e) {
    for (let r = 0, n = 0, i = 0; ; r++) {
      let s = r < this.viewports.length ? this.viewports[r] : null;
      if (!s || e < s.top)
        return i + (e - n) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      n = s.bottom, i = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let r = 0, n = 0, i = 0; ; r++) {
      let s = r < this.viewports.length ? this.viewports[r] : null;
      if (!s || e < s.domTop)
        return n + (e - i) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      n = s.bottom, i = s.domBottom;
    }
  }
}
function ml(t, e) {
  if (e.scale == 1)
    return t;
  let r = e.toDOM(t.top), n = e.toDOM(t.bottom);
  return new Gn(t.from, t.length, r, n - r, Array.isArray(t._content) ? t._content.map((i) => ml(i, e)) : t._content);
}
const Fc = /* @__PURE__ */ me.define({ combine: (t) => t.join(" ") }), sg = /* @__PURE__ */ me.define({ combine: (t) => t.indexOf(!0) > -1 }), ag = /* @__PURE__ */ Os.newName(), NA = /* @__PURE__ */ Os.newName(), _A = /* @__PURE__ */ Os.newName(), QA = { "&light": "." + NA, "&dark": "." + _A };
function og(t, e, r) {
  return new Os(e, {
    finish(n) {
      return /&/.test(n) ? n.replace(/&\w*/, (i) => {
        if (i == "&")
          return t;
        if (!r || !r[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return r[i];
      }) : t + " " + n;
    }
  });
}
const sV = /* @__PURE__ */ og("." + ag, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, QA), gl = "";
class aV {
  constructor(e, r) {
    this.points = e, this.text = "", this.lineSeparator = r.facet(Le.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += gl;
  }
  readRange(e, r) {
    if (!e)
      return this;
    let n = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(n, i);
      let s = this.text.length;
      this.readNode(i);
      let a = i.nextSibling;
      if (a == r)
        break;
      let o = ut.get(i), u = ut.get(a);
      (o && u ? o.breakAfter : (o ? o.breakAfter : ob(i)) || ob(a) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > s) && this.lineBreak(), i = a;
    }
    return this.findPointBefore(n, r), this;
  }
  readTextNode(e) {
    let r = e.nodeValue;
    for (let n of this.points)
      n.node == e && (n.pos = this.text.length + Math.min(n.offset, r.length));
    for (let n = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, a = 1, o;
      if (this.lineSeparator ? (s = r.indexOf(this.lineSeparator, n), a = this.lineSeparator.length) : (o = i.exec(r)) && (s = o.index, a = o[0].length), this.append(r.slice(n, s < 0 ? r.length : s)), s < 0)
        break;
      if (this.lineBreak(), a > 1)
        for (let u of this.points)
          u.node == e && u.pos > this.text.length && (u.pos -= a - 1);
      n = s + a;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let r = ut.get(e), n = r && r.overrideDOMText;
    if (n != null) {
      this.findPointInside(e, n.length);
      for (let i = n.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, r) {
    for (let n of this.points)
      n.node == e && e.childNodes[n.offset] == r && (n.pos = this.text.length);
  }
  findPointInside(e, r) {
    for (let n of this.points)
      (e.nodeType == 3 ? n.node == e : e.contains(n.node)) && (n.pos = this.text.length + (oV(e, n.node, n.offset) ? r : 0));
  }
}
function oV(t, e, r) {
  for (; ; ) {
    if (!e || r < Ai(e))
      return !1;
    if (e == t)
      return !0;
    r = tu(e) + 1, e = e.parentNode;
  }
}
function ob(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
class lb {
  constructor(e, r) {
    this.node = e, this.offset = r, this.pos = -1;
  }
}
class lV {
  constructor(e, r, n, i) {
    this.typeOver = i, this.bounds = null, this.text = "";
    let { impreciseHead: s, impreciseAnchor: a } = e.docView;
    if (e.state.readOnly && r > -1)
      this.newSel = null;
    else if (r > -1 && (this.bounds = e.docView.domBoundsAround(r, n, 0))) {
      let o = s || a ? [] : hV(e), u = new aV(o, e.state);
      u.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = u.text, this.newSel = pV(o, this.bounds.from);
    } else {
      let o = e.observer.selectionRange, u = s && s.node == o.focusNode && s.offset == o.focusOffset || !Xm(e.contentDOM, o.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(o.focusNode, o.focusOffset), c = a && a.node == o.anchorNode && a.offset == o.anchorOffset || !Xm(e.contentDOM, o.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(o.anchorNode, o.anchorOffset), h = e.viewport;
      if ((Oe.ios || Oe.chrome) && e.state.selection.main.empty && u != c && (h.from > 0 || h.to < e.state.doc.length)) {
        let p = Math.min(u, c), m = Math.max(u, c), g = h.from - p, O = h.to - m;
        (g == 0 || g == 1 || p == 0) && (O == 0 || O == -1 || m == e.state.doc.length) && (u = 0, c = e.state.doc.length);
      }
      this.newSel = G.single(c, u);
    }
  }
}
function MA(t, e) {
  let r, { newSel: n } = e, i = t.state.selection.main, s = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: a, to: o } = e.bounds, u = i.from, c = null;
    (s === 8 || Oe.android && e.text.length < o - a) && (u = i.to, c = "end");
    let h = cV(t.state.doc.sliceString(a, o, gl), e.text, u - a, c);
    h && (Oe.chrome && s == 13 && h.toB == h.from + 2 && e.text.slice(h.from, h.toB) == gl + gl && h.toB--, r = {
      from: a + h.from,
      to: a + h.toA,
      insert: Xe.of(e.text.slice(h.from, h.toB).split(gl))
    });
  } else
    n && (!t.hasFocus && t.state.facet(sd) || n.main.eq(i)) && (n = null);
  if (!r && !n)
    return !1;
  if (!r && e.typeOver && !i.empty && n && n.main.empty ? r = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, i.to) } : r && r.from >= i.from && r.to <= i.to && (r.from != i.from || r.to != i.to) && i.to - i.from - (r.to - r.from) <= 4 ? r = {
    from: i.from,
    to: i.to,
    insert: t.state.doc.slice(i.from, r.from).append(r.insert).append(t.state.doc.slice(r.to, i.to))
  } : (Oe.mac || Oe.android) && r && r.from == r.to && r.from == i.head - 1 && /^\. ?$/.test(r.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (n && r.insert.length == 2 && (n = G.single(n.main.anchor - 1, n.main.head - 1)), r = { from: i.from, to: i.to, insert: Xe.of([" "]) }) : Oe.chrome && r && r.from == r.to && r.from == i.head && r.insert.toString() == `
 ` && t.lineWrapping && (n && (n = G.single(n.main.anchor - 1, n.main.head - 1)), r = { from: i.from, to: i.to, insert: Xe.of([" "]) }), r) {
    if (Oe.ios && t.inputState.flushIOSKey() || Oe.android && (r.from == i.from && r.to == i.to && r.insert.length == 1 && r.insert.lines == 2 && Ja(t.contentDOM, "Enter", 13) || (r.from == i.from - 1 && r.to == i.to && r.insert.length == 0 || s == 8 && r.insert.length < r.to - r.from && r.to > i.head) && Ja(t.contentDOM, "Backspace", 8) || r.from == i.from && r.to == i.to + 1 && r.insert.length == 0 && Ja(t.contentDOM, "Delete", 46)))
      return !0;
    let a = r.insert.toString();
    t.inputState.composing >= 0 && t.inputState.composing++;
    let o, u = () => o || (o = uV(t, r, n));
    return t.state.facet(dA).some((c) => c(t, r.from, r.to, a, u)) || t.dispatch(u()), !0;
  } else if (n && !n.main.eq(i)) {
    let a = !1, o = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (a = !0), o = t.inputState.lastSelectionOrigin), t.dispatch({ selection: n, scrollIntoView: a, userEvent: o }), !0;
  } else
    return !1;
}
function uV(t, e, r) {
  let n, i = t.state, s = i.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!r || r.main.empty && r.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let o = s.from < e.from ? i.sliceDoc(s.from, e.from) : "", u = s.to > e.to ? i.sliceDoc(e.to, s.to) : "";
    n = i.replaceSelection(t.state.toText(o + e.insert.sliceString(0, void 0, t.state.lineBreak) + u));
  } else {
    let o = i.changes(e), u = r && r.main.to <= o.newLength ? r.main : void 0;
    if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let c = t.state.sliceDoc(e.from, e.to), h, p = r && vA(t, r.main.head);
      if (p) {
        let O = e.insert.length - (e.to - e.from);
        h = { from: p.from, to: p.to - O };
      } else
        h = t.state.doc.lineAt(s.head);
      let m = s.to - e.to, g = s.to - s.from;
      n = i.changeByRange((O) => {
        if (O.from == s.from && O.to == s.to)
          return { changes: o, range: u || O.map(o) };
        let b = O.to - m, D = b - c.length;
        if (O.to - O.from != g || t.state.sliceDoc(D, b) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        O.to >= h.from && O.from <= h.to)
          return { range: O };
        let S = i.changes({ from: D, to: b, insert: e.insert }), x = O.to - s.to;
        return {
          changes: S,
          range: u ? G.range(Math.max(0, u.anchor + x), Math.max(0, u.head + x)) : O.map(S)
        };
      });
    } else
      n = {
        changes: o,
        selection: u && i.selection.replaceRange(u)
      };
  }
  let a = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, a += ".compose", t.inputState.compositionFirstChange && (a += ".start", t.inputState.compositionFirstChange = !1)), i.update(n, { userEvent: a, scrollIntoView: !0 });
}
function cV(t, e, r, n) {
  let i = Math.min(t.length, e.length), s = 0;
  for (; s < i && t.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == i && t.length == e.length)
    return null;
  let a = t.length, o = e.length;
  for (; a > 0 && o > 0 && t.charCodeAt(a - 1) == e.charCodeAt(o - 1); )
    a--, o--;
  if (n == "end") {
    let u = Math.max(0, s - Math.min(a, o));
    r -= a + u - s;
  }
  if (a < s && t.length < e.length) {
    let u = r <= s && r >= a ? s - r : 0;
    s -= u, o = s + (o - a), a = s;
  } else if (o < s) {
    let u = r <= s && r >= o ? s - r : 0;
    s -= u, a = s + (a - o), o = s;
  }
  return { from: s, toA: a, toB: o };
}
function hV(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: r, anchorOffset: n, focusNode: i, focusOffset: s } = t.observer.selectionRange;
  return r && (e.push(new lb(r, n)), (i != r || s != n) && e.push(new lb(i, s))), e;
}
function pV(t, e) {
  if (t.length == 0)
    return null;
  let r = t[0].pos, n = t.length == 2 ? t[1].pos : r;
  return r > -1 && n > -1 ? G.single(r + e, n + e) : null;
}
const dV = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, df = Oe.ie && Oe.ie_version <= 11;
class fV {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new Hq(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((r) => {
      for (let n of r)
        this.queue.push(n);
      (Oe.ie && Oe.ie_version <= 11 || Oe.ios && e.composing) && r.some((n) => n.type == "childList" && n.removedNodes.length || n.type == "characterData" && n.oldValue.length > n.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), df && (this.onCharData = (r) => {
      this.queue.push({
        target: r.target,
        type: "characterData",
        oldValue: r.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var r;
      ((r = this.view.docView) === null || r === void 0 ? void 0 : r.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((r) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), r.length > 0 && r[r.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((r) => {
      r.length > 0 && r[r.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((r, n) => r != e[n]))) {
      this.gapIntersection.disconnect();
      for (let r of e)
        this.gapIntersection.observe(r);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let r = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: n } = this, i = this.selectionRange;
    if (n.state.facet(sd) ? n.root.activeElement != this.dom : !nh(n.dom, i))
      return;
    let s = i.anchorNode && n.docView.nearest(i.anchorNode);
    if (s && s.ignoreEvent(e)) {
      r || (this.selectionChanged = !1);
      return;
    }
    (Oe.ie && Oe.ie_version <= 11 || Oe.android && Oe.chrome) && !n.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && Nl(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, r = Oe.safari && e.root.nodeType == 11 && Yq(this.dom.ownerDocument) == this.dom && mV(this.view) || Ih(e.root);
    if (!r || this.selectionRange.eq(r))
      return !1;
    let n = nh(this.dom, r);
    return n && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && Kq(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), n && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, r) {
    this.selectionRange.set(e.node, e.offset, r.node, r.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, r = null;
    for (let n = this.dom; n; )
      if (n.nodeType == 1)
        !r && e < this.scrollTargets.length && this.scrollTargets[e] == n ? e++ : r || (r = this.scrollTargets.slice(0, e)), r && r.push(n), n = n.assignedSlot || n.parentNode;
      else if (n.nodeType == 11)
        n = n.host;
      else
        break;
    if (e < this.scrollTargets.length && !r && (r = this.scrollTargets.slice(0, e)), r) {
      for (let n of this.scrollTargets)
        n.removeEventListener("scroll", this.onScroll);
      for (let n of this.scrollTargets = r)
        n.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, dV), df && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), df && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, r) {
    var n;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && Ja(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: r,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((n = this.delayedAndroidKey) === null || n === void 0) && n.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let r = -1, n = -1, i = !1;
    for (let s of e) {
      let a = this.readMutation(s);
      a && (a.typeOver && (i = !0), r == -1 ? { from: r, to: n } = a : (r = Math.min(a.from, r), n = Math.max(a.to, n)));
    }
    return { from: r, to: n, typeOver: i };
  }
  readChange() {
    let { from: e, to: r, typeOver: n } = this.processRecords(), i = this.selectionChanged && nh(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new lV(this.view, e, r, n);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let r = this.readChange();
    if (!r)
      return this.view.requestMeasure(), !1;
    let n = this.view.state, i = MA(this.view, r);
    return this.view.state == n && this.view.update([]), i;
  }
  readMutation(e) {
    let r = this.view.docView.nearest(e.target);
    if (!r || r.ignoreMutation(e))
      return null;
    if (r.markDirty(e.type == "attributes"), e.type == "attributes" && (r.flags |= 4), e.type == "childList") {
      let n = ub(r, e.previousSibling || e.target.previousSibling, -1), i = ub(r, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: n ? r.posAfter(n) : r.posAtStart,
        to: i ? r.posBefore(i) : r.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, r, n;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (r = this.gapIntersection) === null || r === void 0 || r.disconnect(), (n = this.resizeScroll) === null || n === void 0 || n.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function ub(t, e, r) {
  for (; e; ) {
    let n = ut.get(e);
    if (n && n.parent == t)
      return n;
    let i = e.parentNode;
    e = i != t.dom ? i : r > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function mV(t) {
  let e = null;
  function r(u) {
    u.preventDefault(), u.stopImmediatePropagation(), e = u.getTargetRanges()[0];
  }
  if (t.contentDOM.addEventListener("beforeinput", r, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", r, !0), !e)
    return null;
  let n = e.startContainer, i = e.startOffset, s = e.endContainer, a = e.endOffset, o = t.docView.domAtPos(t.state.selection.main.anchor);
  return Nl(o.node, o.offset, s, a) && ([n, i, s, a] = [s, a, n, i]), { anchorNode: n, anchorOffset: i, focusNode: s, focusOffset: a };
}
class ue {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((n) => n.forEach((i) => r(i, this))) || ((n) => this.update(n)), this.dispatch = this.dispatch.bind(this), this._root = e.root || Jq(e.parent) || document, this.viewState = new sb(e.state || Le.create(e)), e.scrollTo && e.scrollTo.is(Cc) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(dl).map((n) => new uf(n));
    for (let n of this.plugins)
      n.update(this);
    this.observer = new fV(this), this.inputState = new PX(this), this.inputState.ensureHandlers(this.plugins), this.docView = new jx(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...e) {
    let r = e.length == 1 && e[0] instanceof Tt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(r, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let r = !1, n = !1, i, s = this.state;
    for (let m of e) {
      if (m.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = m.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let a = this.hasFocus, o = 0, u = null;
    e.some((m) => m.annotation(FA)) ? (this.inputState.notifiedFocused = a, o = 1) : a != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = a, u = $A(s, a), u || (o = 1));
    let c = this.observer.delayedAndroidKey, h = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), h = this.observer.readChange(), (h && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (h = null)) : this.observer.clear(), s.facet(Le.phrases) != this.state.facet(Le.phrases))
      return this.setState(s);
    i = Nh.create(this, s, e), i.flags |= o;
    let p = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let m of e) {
        if (p && (p = p.map(m.changes)), m.scrollIntoView) {
          let { main: g } = m.state.selection;
          p = new Ka(g.empty ? g : G.cursor(g.head, g.head > g.anchor ? -1 : 1));
        }
        for (let g of m.effects)
          g.is(Cc) && (p = g.value.clip(this.state));
      }
      this.viewState.update(i, p), this.bidiCache = _h.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), r = this.docView.update(i), this.state.facet(fl) != this.styleModules && this.mountStyles(), n = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(r, e.some((m) => m.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(Fc) != i.state.facet(Fc) && (this.viewState.mustMeasureContent = !0), (r || n || p || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !i.empty)
      for (let m of this.state.facet(tg))
        try {
          m(i);
        } catch (g) {
          hn(this.state, g, "update listener");
        }
    (u || h) && Promise.resolve().then(() => {
      u && this.state == u.startState && this.dispatch(u), h && !MA(this, h) && c.force && Ja(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let r = this.hasFocus;
    try {
      for (let n of this.plugins)
        n.destroy(this);
      this.viewState = new sb(e), this.plugins = e.facet(dl).map((n) => new uf(n)), this.pluginMap.clear();
      for (let n of this.plugins)
        n.update(this);
      this.docView.destroy(), this.docView = new jx(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    r && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let r = e.startState.facet(dl), n = e.state.facet(dl);
    if (r != n) {
      let i = [];
      for (let s of n) {
        let a = r.indexOf(s);
        if (a < 0)
          i.push(new uf(s));
        else {
          let o = this.plugins[a];
          o.mustUpdate = e, i.push(o);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    r != n && this.inputState.ensureHandlers(this.plugins);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let r = null, n = this.scrollDOM, i = n.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: a } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (a = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let o = 0; ; o++) {
        if (a < 0)
          if (UE(n))
            s = -1, a = this.viewState.heightMap.height;
          else {
            let g = this.viewState.scrollAnchorAt(i);
            s = g.from, a = g.top;
          }
        this.updateState = 1;
        let u = this.viewState.measure(this);
        if (!u && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (o > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        u & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let h = c.map((g) => {
          try {
            return g.read(this);
          } catch (O) {
            return hn(this.state, O), cb;
          }
        }), p = Nh.create(this, this.state, []), m = !1;
        p.flags |= u, r ? r.flags |= u : r = p, this.updateState = 2, p.empty || (this.updatePlugins(p), this.inputState.update(p), this.updateAttrs(), m = this.docView.update(p));
        for (let g = 0; g < c.length; g++)
          if (h[g] != cb)
            try {
              let O = c[g];
              O.write && O.write(h[g], this);
            } catch (O) {
              hn(this.state, O);
            }
        if (m && this.docView.updateSelection(!0), !p.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, a = -1;
              continue;
            } else {
              let O = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - a;
              if (O > 1 || O < -1) {
                i = i + O, n.scrollTop = i / this.scaleY, a = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (r && !r.empty)
      for (let o of this.state.facet(tg))
        o(r);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return ag + " " + (this.state.facet(sg) ? _A : NA) + " " + this.state.facet(Fc);
  }
  updateAttrs() {
    let e = hb(this, yA, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), r = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(sd) ? "true" : "false",
      class: "cm-content",
      style: `${Oe.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (r["aria-readonly"] = "true"), hb(this, E0, r);
    let n = this.observer.ignore(() => {
      let i = Gm(this.contentDOM, this.contentAttrs, r), s = Gm(this.dom, this.editorAttrs, e);
      return i || s;
    });
    return this.editorAttrs = e, this.contentAttrs = r, n;
  }
  showAnnouncements(e) {
    let r = !0;
    for (let n of e)
      for (let i of n.effects)
        if (i.is(ue.announce)) {
          r && (this.announceDOM.textContent = ""), r = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(fl);
    let e = this.state.facet(ue.cspNonce);
    Os.mount(this.root, this.styleModules.concat(sV).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let r = 0; r < this.measureRequests.length; r++)
          if (this.measureRequests[r].key === e.key) {
            this.measureRequests[r] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let r = this.pluginMap.get(e);
    return (r === void 0 || r && r.spec != e) && this.pluginMap.set(e, r = this.plugins.find((n) => n.spec == e) || null), r && r.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, r, n) {
    return hf(this, e, Yx(this, e, r, n));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, r) {
    return hf(this, e, Yx(this, e, r, (n) => TX(this, e.head, n)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, r) {
    let n = this.bidiSpans(e), i = this.textDirectionAt(e.from), s = n[r ? n.length - 1 : 0];
    return G.cursor(s.side(r, i) + e.from, s.forward(!r, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, r, n = !0) {
    return AX(this, e, r, n);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, r, n) {
    return hf(this, e, kX(this, e, r, n));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, r = 0) {
    return this.docView.posFromDOM(e, r);
  }
  posAtCoords(e, r = !0) {
    return this.readMeasured(), wA(this, e, r);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, r = 1) {
    this.readMeasured();
    let n = this.docView.coordsAt(e, r);
    if (!n || n.left == n.right)
      return n;
    let i = this.state.doc.lineAt(e), s = this.bidiSpans(i), a = s[as.find(s, e - i.from, -1, r)];
    return nd(n, a.dir == ct.LTR == r > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(mA) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > gV)
      return oA(e.length);
    let r = this.textDirectionAt(e.from), n;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == r && (s.fresh || aA(s.isolates, n = Rx(this, e))))
        return s.order;
    n || (n = Rx(this, e));
    let i = hX(e.text, r, n);
    return this.bidiCache.push(new _h(e.from, e.to, r, n, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || Oe.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      VE(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, r = {}) {
    return Cc.of(new Ka(typeof e == "number" ? G.cursor(e) : e, r.y, r.x, r.yMargin, r.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: r } = this.scrollDOM, n = this.viewState.scrollAnchorAt(e);
    return Cc.of(new Ka(G.cursor(n.from), "start", "start", n.top - e, r, !0));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return wt.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return wt.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, r) {
    let n = Os.newName(), i = [Fc.of(n), fl.of(og(`.${n}`, e))];
    return r && r.dark && i.push(sg.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return va.lowest(fl.of(og("." + ag, e, QA)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var r;
    let n = e.querySelector(".cm-content"), i = n && ut.get(n) || ut.get(e);
    return ((r = i == null ? void 0 : i.rootView) === null || r === void 0 ? void 0 : r.view) || null;
  }
}
ue.styleModule = fl;
ue.inputHandler = dA;
ue.focusChangeEffect = fA;
ue.perLineTextDirection = mA;
ue.exceptionSink = pA;
ue.updateListener = tg;
ue.editable = sd;
ue.mouseSelectionStyle = hA;
ue.dragMovesSelection = cA;
ue.clickAddsSelectionRange = uA;
ue.decorations = ru;
ue.outerDecorations = OA;
ue.atomicRanges = A0;
ue.bidiIsolatedRanges = xA;
ue.scrollMargins = bA;
ue.darkTheme = sg;
ue.cspNonce = /* @__PURE__ */ me.define({ combine: (t) => t.length ? t[0] : "" });
ue.contentAttributes = E0;
ue.editorAttributes = yA;
ue.lineWrapping = /* @__PURE__ */ ue.contentAttributes.of({ class: "cm-lineWrapping" });
ue.announce = /* @__PURE__ */ Ae.define();
const gV = 4096, cb = {};
class _h {
  constructor(e, r, n, i, s, a) {
    this.from = e, this.to = r, this.dir = n, this.isolates = i, this.fresh = s, this.order = a;
  }
  static update(e, r) {
    if (r.empty && !e.some((s) => s.fresh))
      return e;
    let n = [], i = e.length ? e[e.length - 1].dir : ct.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let a = e[s];
      a.dir == i && !r.touchesRange(a.from, a.to) && n.push(new _h(r.mapPos(a.from, 1), r.mapPos(a.to, -1), a.dir, a.isolates, !1, a.order));
    }
    return n;
  }
}
function hb(t, e, r) {
  for (let n = t.state.facet(e), i = n.length - 1; i >= 0; i--) {
    let s = n[i], a = typeof s == "function" ? s(t) : s;
    a && zm(a, r);
  }
  return r;
}
const yV = Oe.mac ? "mac" : Oe.windows ? "win" : Oe.linux ? "linux" : "key";
function OV(t, e) {
  const r = t.split(/-(?!$)/);
  let n = r[r.length - 1];
  n == "Space" && (n = " ");
  let i, s, a, o;
  for (let u = 0; u < r.length - 1; ++u) {
    const c = r[u];
    if (/^(cmd|meta|m)$/i.test(c))
      o = !0;
    else if (/^a(lt)?$/i.test(c))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      a = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? o = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return i && (n = "Alt-" + n), s && (n = "Ctrl-" + n), o && (n = "Meta-" + n), a && (n = "Shift-" + n), n;
}
function $c(t, e, r) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), r !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const xV = /* @__PURE__ */ va.default(/* @__PURE__ */ ue.domEventHandlers({
  keydown(t, e) {
    return RA(LA(e.state), t, e, "editor");
  }
})), Mu = /* @__PURE__ */ me.define({ enables: xV }), pb = /* @__PURE__ */ new WeakMap();
function LA(t) {
  let e = t.facet(Mu), r = pb.get(e);
  return r || pb.set(e, r = vV(e.reduce((n, i) => n.concat(i), []))), r;
}
function bV(t, e, r) {
  return RA(LA(t.state), e, t, r);
}
let rs = null;
const DV = 4e3;
function vV(t, e = yV) {
  let r = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), i = (a, o) => {
    let u = n[a];
    if (u == null)
      n[a] = o;
    else if (u != o)
      throw new Error("Key binding " + a + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (a, o, u, c, h) => {
    var p, m;
    let g = r[a] || (r[a] = /* @__PURE__ */ Object.create(null)), O = o.split(/ (?!$)/).map((S) => OV(S, e));
    for (let S = 1; S < O.length; S++) {
      let x = O.slice(0, S).join(" ");
      i(x, !0), g[x] || (g[x] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(w) => {
          let T = rs = { view: w, prefix: x, scope: a };
          return setTimeout(() => {
            rs == T && (rs = null);
          }, DV), !0;
        }]
      });
    }
    let b = O.join(" ");
    i(b, !1);
    let D = g[b] || (g[b] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((m = (p = g._any) === null || p === void 0 ? void 0 : p.run) === null || m === void 0 ? void 0 : m.slice()) || []
    });
    u && D.run.push(u), c && (D.preventDefault = !0), h && (D.stopPropagation = !0);
  };
  for (let a of t) {
    let o = a.scope ? a.scope.split(" ") : ["editor"];
    if (a.any)
      for (let c of o) {
        let h = r[c] || (r[c] = /* @__PURE__ */ Object.create(null));
        h._any || (h._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let p in h)
          h[p].run.push(a.any);
      }
    let u = a[e] || a.key;
    if (u)
      for (let c of o)
        s(c, u, a.run, a.preventDefault, a.stopPropagation), a.shift && s(c, "Shift-" + u, a.shift, a.preventDefault, a.stopPropagation);
  }
  return r;
}
function RA(t, e, r, n) {
  let i = Vq(e), s = Wt(i, 0), a = ln(s) == i.length && i != " ", o = "", u = !1, c = !1, h = !1;
  rs && rs.view == r && rs.scope == n && (o = rs.prefix + " ", EA.indexOf(e.keyCode) < 0 && (c = !0, rs = null));
  let p = /* @__PURE__ */ new Set(), m = (D) => {
    if (D) {
      for (let S of D.run)
        if (!p.has(S) && (p.add(S), S(r, e)))
          return D.stopPropagation && (h = !0), !0;
      D.preventDefault && (D.stopPropagation && (h = !0), c = !0);
    }
    return !1;
  }, g = t[n], O, b;
  return g && (m(g[o + $c(i, e, !a)]) ? u = !0 : a && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(Oe.windows && e.ctrlKey && e.altKey) && (O = xs[e.keyCode]) && O != i ? (m(g[o + $c(O, e, !0)]) || e.shiftKey && (b = eu[e.keyCode]) != i && b != O && m(g[o + $c(b, e, !1)])) && (u = !0) : a && e.shiftKey && m(g[o + $c(i, e, !0)]) && (u = !0), !u && m(g._any) && (u = !0)), c && (u = !0), u && h && e.stopPropagation(), u;
}
class Lu {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, r, n, i, s) {
    this.className = e, this.left = r, this.top = n, this.width = i, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, r) {
    return r.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, r, n) {
    if (n.empty) {
      let i = e.coordsAtPos(n.head, n.assoc || 1);
      if (!i)
        return [];
      let s = jA(e);
      return [new Lu(r, i.left - s.left, i.top - s.top, null, i.bottom - i.top)];
    } else
      return SV(e, r, n);
  }
}
function jA(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == ct.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function db(t, e, r) {
  let n = G.cursor(e);
  return {
    from: Math.max(r.from, t.moveToLineBoundary(n, !1, !0).from),
    to: Math.min(r.to, t.moveToLineBoundary(n, !0, !0).from),
    type: yr.Text
  };
}
function SV(t, e, r) {
  if (r.to <= t.viewport.from || r.from >= t.viewport.to)
    return [];
  let n = Math.max(r.from, t.viewport.from), i = Math.min(r.to, t.viewport.to), s = t.textDirection == ct.LTR, a = t.contentDOM, o = a.getBoundingClientRect(), u = jA(t), c = a.querySelector(".cm-line"), h = c && window.getComputedStyle(c), p = o.left + (h ? parseInt(h.paddingLeft) + Math.min(0, parseInt(h.textIndent)) : 0), m = o.right - (h ? parseInt(h.paddingRight) : 0), g = ng(t, n), O = ng(t, i), b = g.type == yr.Text ? g : null, D = O.type == yr.Text ? O : null;
  if (b && (t.lineWrapping || g.widgetLineBreaks) && (b = db(t, n, b)), D && (t.lineWrapping || O.widgetLineBreaks) && (D = db(t, i, D)), b && D && b.from == D.from)
    return x(w(r.from, r.to, b));
  {
    let C = b ? w(r.from, null, b) : T(g, !1), A = D ? w(null, r.to, D) : T(O, !0), P = [];
    return (b || g).to < (D || O).from - (b && D ? 1 : 0) || g.widgetLineBreaks > 1 && C.bottom + t.defaultLineHeight / 2 < A.top ? P.push(S(p, C.bottom, m, A.top)) : C.bottom < A.top && t.elementAtHeight((C.bottom + A.top) / 2).type == yr.Text && (C.bottom = A.top = (C.bottom + A.top) / 2), x(C).concat(P).concat(x(A));
  }
  function S(C, A, P, $) {
    return new Lu(
      e,
      C - u.left,
      A - u.top - 0.01,
      P - C,
      $ - A + 0.01
      /* C.Epsilon */
    );
  }
  function x({ top: C, bottom: A, horizontal: P }) {
    let $ = [];
    for (let B = 0; B < P.length; B += 2)
      $.push(S(P[B], C, P[B + 1], A));
    return $;
  }
  function w(C, A, P) {
    let $ = 1e9, B = -1e9, _ = [];
    function M(R, q, X, H, ye) {
      let Ce = t.coordsAtPos(R, R == P.to ? -2 : 2), Se = t.coordsAtPos(X, X == P.from ? 2 : -2);
      !Ce || !Se || ($ = Math.min(Ce.top, Se.top, $), B = Math.max(Ce.bottom, Se.bottom, B), ye == ct.LTR ? _.push(s && q ? p : Ce.left, s && H ? m : Se.right) : _.push(!s && H ? p : Se.left, !s && q ? m : Ce.right));
    }
    let Y = C ?? P.from, J = A ?? P.to;
    for (let R of t.visibleRanges)
      if (R.to > Y && R.from < J)
        for (let q = Math.max(R.from, Y), X = Math.min(R.to, J); ; ) {
          let H = t.state.doc.lineAt(q);
          for (let ye of t.bidiSpans(H)) {
            let Ce = ye.from + H.from, Se = ye.to + H.from;
            if (Ce >= X)
              break;
            Se > q && M(Math.max(Ce, q), C == null && Ce <= Y, Math.min(Se, X), A == null && Se >= J, ye.dir);
          }
          if (q = H.to + 1, q >= X)
            break;
        }
    return _.length == 0 && M(Y, C == null, J, A == null, t.textDirection), { top: $, bottom: B, horizontal: _ };
  }
  function T(C, A) {
    let P = o.top + (A ? C.top : C.bottom);
    return { top: P, bottom: P, horizontal: [] };
  }
}
function wV(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class CV {
  constructor(e, r) {
    this.view = e, this.layer = r, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), r.above && this.dom.classList.add("cm-layer-above"), r.class && this.dom.classList.add(r.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), r.mount && r.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(ah) != e.state.facet(ah) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  setOrder(e) {
    let r = 0, n = e.facet(ah);
    for (; r < n.length && n[r] != this.layer; )
      r++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - r);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: r } = this.view;
    (e != this.scaleX || r != this.scaleY) && (this.scaleX = e, this.scaleY = r, this.dom.style.transform = `scale(${1 / e}, ${1 / r})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((r, n) => !wV(r, this.drawn[n]))) {
      let r = this.dom.firstChild, n = 0;
      for (let i of e)
        i.update && r && i.constructor && this.drawn[n].constructor && i.update(r, this.drawn[n]) ? (r = r.nextSibling, n++) : this.dom.insertBefore(i.draw(), r);
      for (; r; ) {
        let i = r.nextSibling;
        r.remove(), r = i;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const ah = /* @__PURE__ */ me.define();
function ZA(t) {
  return [
    wt.define((e) => new CV(e, t)),
    ah.of(t)
  ];
}
const WA = !Oe.ios, nu = /* @__PURE__ */ me.define({
  combine(t) {
    return di(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, r) => Math.min(e, r),
      drawRangeCursor: (e, r) => e || r
    });
  }
});
function EV(t = {}) {
  return [
    nu.of(t),
    AV,
    TV,
    kV,
    gA.of(!0)
  ];
}
function qA(t) {
  return t.startState.facet(nu) != t.state.facet(nu);
}
const AV = /* @__PURE__ */ ZA({
  above: !0,
  markers(t) {
    let { state: e } = t, r = e.facet(nu), n = [];
    for (let i of e.selection.ranges) {
      let s = i == e.selection.main;
      if (i.empty ? !s || WA : r.drawRangeCursor) {
        let a = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", o = i.empty ? i : G.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let u of Lu.forRange(t, a, o))
          n.push(u);
      }
    }
    return n;
  },
  update(t, e) {
    t.transactions.some((n) => n.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let r = qA(t);
    return r && fb(t.state, e), t.docChanged || t.selectionSet || r;
  },
  mount(t, e) {
    fb(e.state, t);
  },
  class: "cm-cursorLayer"
});
function fb(t, e) {
  e.style.animationDuration = t.facet(nu).cursorBlinkRate + "ms";
}
const TV = /* @__PURE__ */ ZA({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : Lu.forRange(t, "cm-selectionBackground", e)).reduce((e, r) => e.concat(r));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || qA(t);
  },
  class: "cm-selectionLayer"
}), lg = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
WA && (lg[".cm-line"].caretColor = "transparent !important", lg[".cm-content"] = { caretColor: "transparent !important" });
const kV = /* @__PURE__ */ va.highest(/* @__PURE__ */ ue.theme(lg)), XA = /* @__PURE__ */ Ae.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), yl = /* @__PURE__ */ Rt.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((r, n) => n.is(XA) ? n.value : r, t);
  }
}), PV = /* @__PURE__ */ wt.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let r = t.state.field(yl);
    r == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(yl) != r || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(yl), r = e != null && t.coordsAtPos(e);
    if (!r)
      return null;
    let n = t.scrollDOM.getBoundingClientRect();
    return {
      left: r.left - n.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: r.top - n.top + t.scrollDOM.scrollTop * t.scaleY,
      height: r.bottom - r.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: r } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / r + "px", this.cursor.style.height = t.height / r + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(yl) != t && this.view.dispatch({ effects: XA.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function FV() {
  return [yl, PV];
}
function mb(t, e, r, n, i) {
  e.lastIndex = 0;
  for (let s = t.iterRange(r, n), a = r, o; !s.next().done; a += s.value.length)
    if (!s.lineBreak)
      for (; o = e.exec(s.value); )
        i(a + o.index, o);
}
function $V(t, e) {
  let r = t.visibleRanges;
  if (r.length == 1 && r[0].from == t.viewport.from && r[0].to == t.viewport.to)
    return r;
  let n = [];
  for (let { from: i, to: s } of r)
    i = Math.max(t.state.doc.lineAt(i).from, i - e), s = Math.min(t.state.doc.lineAt(s).to, s + e), n.length && n[n.length - 1].to >= i ? n[n.length - 1].to = s : n.push({ from: i, to: s });
  return n;
}
class BV {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: r, decoration: n, decorate: i, boundary: s, maxLength: a = 1e3 } = e;
    if (!r.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = r, i)
      this.addMatch = (o, u, c, h) => i(h, c, c + o[0].length, o, u);
    else if (typeof n == "function")
      this.addMatch = (o, u, c, h) => {
        let p = n(o, u, c);
        p && h(c, c + o[0].length, p);
      };
    else if (n)
      this.addMatch = (o, u, c, h) => h(c, c + o[0].length, n);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = a;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let r = new ys(), n = r.add.bind(r);
    for (let { from: i, to: s } of $V(e, this.maxLength))
      mb(e.state.doc, this.regexp, i, s, (a, o) => this.addMatch(o, e, a, n));
    return r.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, r) {
    let n = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((s, a, o, u) => {
      u > e.view.viewport.from && o < e.view.viewport.to && (n = Math.min(o, n), i = Math.max(u, i));
    }), e.viewportChanged || i - n > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, r.map(e.changes), n, i) : r;
  }
  updateRange(e, r, n, i) {
    for (let s of e.visibleRanges) {
      let a = Math.max(s.from, n), o = Math.min(s.to, i);
      if (o > a) {
        let u = e.state.doc.lineAt(a), c = u.to < o ? e.state.doc.lineAt(o) : u, h = Math.max(s.from, u.from), p = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; a > u.from; a--)
            if (this.boundary.test(u.text[a - 1 - u.from])) {
              h = a;
              break;
            }
          for (; o < c.to; o++)
            if (this.boundary.test(c.text[o - c.from])) {
              p = o;
              break;
            }
        }
        let m = [], g, O = (b, D, S) => m.push(S.range(b, D));
        if (u == c)
          for (this.regexp.lastIndex = h - u.from; (g = this.regexp.exec(u.text)) && g.index < p - u.from; )
            this.addMatch(g, e, g.index + u.from, O);
        else
          mb(e.state.doc, this.regexp, h, p, (b, D) => this.addMatch(D, e, b, O));
        r = r.update({ filterFrom: h, filterTo: p, filter: (b, D) => b < h || D > p, add: m });
      }
    }
    return r;
  }
}
const ug = /x/.unicode != null ? "gu" : "g", IV = /* @__PURE__ */ new RegExp(`[\0-\b
--\u2028\u2029\uFEFF-]`, ug), NV = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let ff = null;
function _V() {
  var t;
  if (ff == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    ff = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return ff || !1;
}
const oh = /* @__PURE__ */ me.define({
  combine(t) {
    let e = di(t, {
      render: null,
      specialChars: IV,
      addSpecialChars: null
    });
    return (e.replaceTabs = !_V()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, ug)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, ug)), e;
  }
});
function QV(t = {}) {
  return [oh.of(t), MV()];
}
let gb = null;
function MV() {
  return gb || (gb = wt.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = be.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(oh)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new BV({
        regexp: t.specialChars,
        decoration: (e, r, n) => {
          let { doc: i } = r.state, s = Wt(e[0], 0);
          if (s == 9) {
            let a = i.lineAt(n), o = r.state.tabSize, u = Qo(a.text, o, n - a.from);
            return be.replace({
              widget: new ZV((o - u % o) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = be.replace({ widget: new jV(t, s) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(oh);
      t.startState.facet(oh) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const LV = "";
function RV(t) {
  return t >= 32 ? LV : t == 10 ? "" : String.fromCharCode(9216 + t);
}
class jV extends fi {
  constructor(e, r) {
    super(), this.options = e, this.code = r;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let r = RV(this.code), n = e.state.phrase("Control character") + " " + (NV[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, n, r);
    if (i)
      return i;
    let s = document.createElement("span");
    return s.textContent = r, s.title = n, s.setAttribute("aria-label", n), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class ZV extends fi {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function WV() {
  return XV;
}
const qV = /* @__PURE__ */ be.line({ class: "cm-activeLine" }), XV = /* @__PURE__ */ wt.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, r = [];
    for (let n of t.state.selection.ranges) {
      let i = t.lineBlockAt(n.head);
      i.from > e && (r.push(qV.range(i.from)), e = i.from);
    }
    return be.set(r);
  }
}, {
  decorations: (t) => t.decorations
});
class VV extends fi {
  constructor(e) {
    super(), this.content = e;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.className = "cm-placeholder", e.style.pointerEvents = "none", e.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content), typeof this.content == "string" ? e.setAttribute("aria-label", "placeholder " + this.content) : e.setAttribute("aria-hidden", "true"), e;
  }
  coordsAt(e) {
    let r = e.firstChild ? po(e.firstChild) : [];
    if (!r.length)
      return null;
    let n = window.getComputedStyle(e.parentNode), i = nd(r[0], n.direction != "rtl"), s = parseInt(n.lineHeight);
    return i.bottom - i.top > s * 1.5 ? { left: i.left, right: i.right, top: i.top, bottom: i.top + s } : i;
  }
  ignoreEvent() {
    return !1;
  }
}
function YV(t) {
  return wt.fromClass(class {
    constructor(e) {
      this.view = e, this.placeholder = t ? be.set([be.widget({ widget: new VV(t), side: 1 }).range(0)]) : be.none;
    }
    get decorations() {
      return this.view.state.doc.length ? be.none : this.placeholder;
    }
  }, { decorations: (e) => e.decorations });
}
const cg = 2e3;
function UV(t, e, r) {
  let n = Math.min(e.line, r.line), i = Math.max(e.line, r.line), s = [];
  if (e.off > cg || r.off > cg || e.col < 0 || r.col < 0) {
    let a = Math.min(e.off, r.off), o = Math.max(e.off, r.off);
    for (let u = n; u <= i; u++) {
      let c = t.doc.line(u);
      c.length <= o && s.push(G.range(c.from + a, c.to + o));
    }
  } else {
    let a = Math.min(e.col, r.col), o = Math.max(e.col, r.col);
    for (let u = n; u <= i; u++) {
      let c = t.doc.line(u), h = Zm(c.text, a, t.tabSize, !0);
      if (h < 0)
        s.push(G.cursor(c.to));
      else {
        let p = Zm(c.text, o, t.tabSize);
        s.push(G.range(c.from + h, c.from + p));
      }
    }
  }
  return s;
}
function zV(t, e) {
  let r = t.coordsAtPos(t.viewport.from);
  return r ? Math.round(Math.abs((r.left - e) / t.defaultCharacterWidth)) : -1;
}
function yb(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), n = t.state.doc.lineAt(r), i = r - n.from, s = i > cg ? -1 : i == n.length ? zV(t, e.clientX) : Qo(n.text, t.state.tabSize, r - n.from);
  return { line: n.number, col: s, off: i };
}
function GV(t, e) {
  let r = yb(t, e), n = t.state.selection;
  return r ? {
    update(i) {
      if (i.docChanged) {
        let s = i.changes.mapPos(i.startState.doc.line(r.line).from), a = i.state.doc.lineAt(s);
        r = { line: a.number, col: r.col, off: Math.min(r.off, a.length) }, n = n.map(i.changes);
      }
    },
    get(i, s, a) {
      let o = yb(t, i);
      if (!o)
        return n;
      let u = UV(t.state, r, o);
      return u.length ? a ? G.create(u.concat(n.ranges)) : G.create(u) : n;
    }
  } : null;
}
function HV(t) {
  let e = (t == null ? void 0 : t.eventFilter) || ((r) => r.altKey && r.button == 0);
  return ue.mouseSelectionStyle.of((r, n) => e(n) ? GV(r, n) : null);
}
const JV = {
  Alt: [18, (t) => !!t.altKey],
  Control: [17, (t) => !!t.ctrlKey],
  Shift: [16, (t) => !!t.shiftKey],
  Meta: [91, (t) => !!t.metaKey]
}, KV = { style: "cursor: crosshair" };
function eY(t = {}) {
  let [e, r] = JV[t.key || "Alt"], n = wt.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || r(i));
      },
      keyup(i) {
        (i.keyCode == e || !r(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(r(i));
      }
    }
  });
  return [
    n,
    ue.contentAttributes.of((i) => {
      var s;
      return !((s = i.plugin(n)) === null || s === void 0) && s.isDown ? KV : null;
    })
  ];
}
const nl = "-10000px";
class VA {
  constructor(e, r, n, i) {
    this.facet = r, this.createTooltipView = n, this.removeTooltipView = i, this.input = e.state.facet(r), this.tooltips = this.input.filter((a) => a);
    let s = null;
    this.tooltipViews = this.tooltips.map((a) => s = n(a, s));
  }
  update(e, r) {
    var n;
    let i = e.state.facet(this.facet), s = i.filter((u) => u);
    if (i === this.input) {
      for (let u of this.tooltipViews)
        u.update && u.update(e);
      return !1;
    }
    let a = [], o = r ? [] : null;
    for (let u = 0; u < s.length; u++) {
      let c = s[u], h = -1;
      if (c) {
        for (let p = 0; p < this.tooltips.length; p++) {
          let m = this.tooltips[p];
          m && m.create == c.create && (h = p);
        }
        if (h < 0)
          a[u] = this.createTooltipView(c, u ? a[u - 1] : null), o && (o[u] = !!c.above);
        else {
          let p = a[u] = this.tooltipViews[h];
          o && (o[u] = r[h]), p.update && p.update(e);
        }
      }
    }
    for (let u of this.tooltipViews)
      a.indexOf(u) < 0 && (this.removeTooltipView(u), (n = u.destroy) === null || n === void 0 || n.call(u));
    return r && (o.forEach((u, c) => r[c] = u), r.length = o.length), this.input = i, this.tooltips = s, this.tooltipViews = a, !0;
  }
}
function tY(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const mf = /* @__PURE__ */ me.define({
  combine: (t) => {
    var e, r, n;
    return {
      position: Oe.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((r = t.find((i) => i.parent)) === null || r === void 0 ? void 0 : r.parent) || null,
      tooltipSpace: ((n = t.find((i) => i.tooltipSpace)) === null || n === void 0 ? void 0 : n.tooltipSpace) || tY
    };
  }
}), Ob = /* @__PURE__ */ new WeakMap(), k0 = /* @__PURE__ */ wt.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(mf);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new VA(t, P0, (r, n) => this.createTooltip(r, n), (r) => {
      this.resizeObserver && this.resizeObserver.unobserve(r.dom), r.dom.remove();
    }), this.above = this.manager.tooltips.map((r) => !!r.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((r) => {
      Date.now() > this.lastTransaction - 50 && r.length > 0 && r[r.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let r = e || t.geometryChanged, n = t.state.facet(mf);
    if (n.position != this.position && !this.madeAbsolute) {
      this.position = n.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      r = !0;
    }
    if (n.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = n.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      r = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    r && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let r = t.create(this.view), n = e ? e.dom : null;
    if (r.dom.classList.add("cm-tooltip"), t.arrow && !r.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", r.dom.insertBefore(i, n);
    }
    return r.dom.style.position = this.position, r.dom.style.top = nl, r.dom.style.left = "0px", this.container.insertBefore(r.dom, n), r.mount && r.mount(this.view), this.resizeObserver && this.resizeObserver.observe(r.dom), r;
  }
  destroy() {
    var t, e, r;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let n of this.manager.tooltipViews)
      n.dom.remove(), (t = n.destroy) === null || t === void 0 || t.call(n);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (r = this.intersectionObserver) === null || r === void 0 || r.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = this.view.dom.getBoundingClientRect(), e = 1, r = 1, n = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: i } = this.manager.tooltipViews[0];
      if (Oe.gecko)
        n = i.offsetParent != this.container.ownerDocument.body;
      else if (i.style.top == nl && i.style.left == "0px") {
        let s = i.getBoundingClientRect();
        n = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (n || this.position == "absolute")
      if (this.parent) {
        let i = this.parent.getBoundingClientRect();
        i.width && i.height && (e = i.width / this.parent.offsetWidth, r = i.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: r } = this.view.viewState);
    return {
      editor: t,
      parent: this.parent ? this.container.getBoundingClientRect() : t,
      pos: this.manager.tooltips.map((i, s) => {
        let a = this.manager.tooltipViews[s];
        return a.getCoords ? a.getCoords(i.pos) : this.view.coordsAtPos(i.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: i }) => i.getBoundingClientRect()),
      space: this.view.state.facet(mf).tooltipSpace(this.view),
      scaleX: e,
      scaleY: r,
      makeAbsolute: n
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let o of this.manager.tooltipViews)
        o.dom.style.position = "absolute";
    }
    let { editor: r, space: n, scaleX: i, scaleY: s } = t, a = [];
    for (let o = 0; o < this.manager.tooltips.length; o++) {
      let u = this.manager.tooltips[o], c = this.manager.tooltipViews[o], { dom: h } = c, p = t.pos[o], m = t.size[o];
      if (!p || p.bottom <= Math.max(r.top, n.top) || p.top >= Math.min(r.bottom, n.bottom) || p.right < Math.max(r.left, n.left) - 0.1 || p.left > Math.min(r.right, n.right) + 0.1) {
        h.style.top = nl;
        continue;
      }
      let g = u.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, O = g ? 7 : 0, b = m.right - m.left, D = (e = Ob.get(c)) !== null && e !== void 0 ? e : m.bottom - m.top, S = c.offset || nY, x = this.view.textDirection == ct.LTR, w = m.width > n.right - n.left ? x ? n.left : n.right - m.width : x ? Math.min(p.left - (g ? 14 : 0) + S.x, n.right - b) : Math.max(n.left, p.left - b + (g ? 14 : 0) - S.x), T = this.above[o];
      !u.strictSide && (T ? p.top - (m.bottom - m.top) - S.y < n.top : p.bottom + (m.bottom - m.top) + S.y > n.bottom) && T == n.bottom - p.bottom > p.top - n.top && (T = this.above[o] = !T);
      let C = (T ? p.top - n.top : n.bottom - p.bottom) - O;
      if (C < D && c.resize !== !1) {
        if (C < this.view.defaultLineHeight) {
          h.style.top = nl;
          continue;
        }
        Ob.set(c, D), h.style.height = (D = C) / s + "px";
      } else
        h.style.height && (h.style.height = "");
      let A = T ? p.top - D - O - S.y : p.bottom + O + S.y, P = w + b;
      if (c.overlap !== !0)
        for (let $ of a)
          $.left < P && $.right > w && $.top < A + D && $.bottom > A && (A = T ? $.top - D - 2 - O : $.bottom + O + 2);
      if (this.position == "absolute" ? (h.style.top = (A - t.parent.top) / s + "px", h.style.left = (w - t.parent.left) / i + "px") : (h.style.top = A / s + "px", h.style.left = w / i + "px"), g) {
        let $ = p.left + (x ? S.x : -S.x) - (w + 14 - 7);
        g.style.left = $ / i + "px";
      }
      c.overlap !== !0 && a.push({ left: w, top: A, right: P, bottom: A + D }), h.classList.toggle("cm-tooltip-above", T), h.classList.toggle("cm-tooltip-below", !T), c.positioned && c.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = nl;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), rY = /* @__PURE__ */ ue.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), nY = { x: 0, y: 0 }, P0 = /* @__PURE__ */ me.define({
  enables: [k0, rY]
}), Qh = /* @__PURE__ */ me.define({
  combine: (t) => t.reduce((e, r) => e.concat(r), [])
});
class ad {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new ad(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new VA(e, Qh, (r, n) => this.createHostedView(r, n), (r) => r.dom.remove());
  }
  createHostedView(e, r) {
    let n = e.create(this.view);
    return n.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(n.dom, r ? r.dom.nextSibling : this.dom.firstChild), this.mounted && n.mount && n.mount(this.view), n;
  }
  mount(e) {
    for (let r of this.manager.tooltipViews)
      r.mount && r.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let r of this.manager.tooltipViews)
      r.positioned && r.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let r of this.manager.tooltipViews)
      (e = r.destroy) === null || e === void 0 || e.call(r);
  }
  passProp(e) {
    let r;
    for (let n of this.manager.tooltipViews) {
      let i = n[e];
      if (i !== void 0) {
        if (r === void 0)
          r = i;
        else if (r !== i)
          return;
      }
    }
    return r;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const iY = /* @__PURE__ */ P0.compute([Qh], (t) => {
  let e = t.facet(Qh);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((r) => r.pos)),
    end: Math.max(...e.map((r) => {
      var n;
      return (n = r.end) !== null && n !== void 0 ? n : r.pos;
    })),
    create: ad.create,
    above: e[0].above,
    arrow: e.some((r) => r.arrow)
  };
});
class sY {
  constructor(e, r, n, i, s) {
    this.view = e, this.source = r, this.field = n, this.setHover = i, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: r } = this, n = e.docView.nearest(r.target);
    if (!n)
      return;
    let i, s = 1;
    if (n instanceof ss)
      i = n.posAtStart;
    else {
      if (i = e.posAtCoords(r), i == null)
        return;
      let o = e.coordsAtPos(i);
      if (!o || r.y < o.top || r.y > o.bottom || r.x < o.left - e.defaultCharacterWidth || r.x > o.right + e.defaultCharacterWidth)
        return;
      let u = e.bidiSpans(e.state.doc.lineAt(i)).find((h) => h.from <= i && h.to >= i), c = u && u.dir == ct.RTL ? -1 : 1;
      s = r.x < o.left ? -c : c;
    }
    let a = this.source(e, i, s);
    if (a != null && a.then) {
      let o = this.pending = { pos: i };
      a.then((u) => {
        this.pending == o && (this.pending = null, u && !(Array.isArray(u) && !u.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(u) ? u : [u]) }));
      }, (u) => hn(e.state, u, "hover tooltip"));
    } else
      a && !(Array.isArray(a) && !a.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(a) ? a : [a]) });
  }
  get tooltip() {
    let e = this.view.plugin(k0), r = e ? e.manager.tooltips.findIndex((n) => n.create == ad.create) : -1;
    return r > -1 ? e.manager.tooltipViews[r] : null;
  }
  mousemove(e) {
    var r, n;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: s } = this;
    if (i.length && s && !aY(s.dom, e) || this.pending) {
      let { pos: a } = i[0] || this.pending, o = (n = (r = i[0]) === null || r === void 0 ? void 0 : r.end) !== null && n !== void 0 ? n : a;
      (a == o ? this.view.posAtCoords(this.lastMove) != a : !oY(this.view, a, o, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: r } = this;
    if (r.length) {
      let { tooltip: n } = this;
      n && n.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(n.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let r = (n) => {
      e.removeEventListener("mouseleave", r), this.active.length && !this.view.dom.contains(n.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", r);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const Bc = 4;
function aY(t, e) {
  let r = t.getBoundingClientRect();
  return e.clientX >= r.left - Bc && e.clientX <= r.right + Bc && e.clientY >= r.top - Bc && e.clientY <= r.bottom + Bc;
}
function oY(t, e, r, n, i, s) {
  let a = t.scrollDOM.getBoundingClientRect(), o = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (a.left > n || a.right < n || a.top > i || Math.min(a.bottom, o) < i)
    return !1;
  let u = t.posAtCoords({ x: n, y: i }, !1);
  return u >= e && u <= r;
}
function lY(t, e = {}) {
  let r = Ae.define(), n = Rt.define({
    create() {
      return [];
    },
    update(i, s) {
      if (i.length && (e.hideOnChange && (s.docChanged || s.selection) ? i = [] : e.hideOn && (i = i.filter((a) => !e.hideOn(s, a))), s.docChanged))
        for (let a of i) {
          let o = s.changes.mapPos(a.pos, -1, Vt.TrackDel);
          if (o != null) {
            let u = Object.assign(/* @__PURE__ */ Object.create(null), a);
            u.pos = o, u.end != null && (u.end = s.changes.mapPos(u.end));
          }
        }
      for (let a of s.effects)
        a.is(r) && (i = a.value), a.is(uY) && (i = []);
      return i;
    },
    provide: (i) => Qh.from(i)
  });
  return [
    n,
    wt.define((i) => new sY(
      i,
      t,
      n,
      r,
      e.hoverTime || 300
      /* Hover.Time */
    )),
    iY
  ];
}
function YA(t, e) {
  let r = t.plugin(k0);
  if (!r)
    return null;
  let n = r.manager.tooltips.indexOf(e);
  return n < 0 ? null : r.manager.tooltipViews[n];
}
const uY = /* @__PURE__ */ Ae.define(), xb = /* @__PURE__ */ me.define({
  combine(t) {
    let e, r;
    for (let n of t)
      e = e || n.topContainer, r = r || n.bottomContainer;
    return { topContainer: e, bottomContainer: r };
  }
});
function iu(t, e) {
  let r = t.plugin(UA), n = r ? r.specs.indexOf(e) : -1;
  return n > -1 ? r.panels[n] : null;
}
const UA = /* @__PURE__ */ wt.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(su), this.specs = this.input.filter((r) => r), this.panels = this.specs.map((r) => r(t));
    let e = t.state.facet(xb);
    this.top = new Ic(t, !0, e.topContainer), this.bottom = new Ic(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((r) => r.top)), this.bottom.sync(this.panels.filter((r) => !r.top));
    for (let r of this.panels)
      r.dom.classList.add("cm-panel"), r.mount && r.mount();
  }
  update(t) {
    let e = t.state.facet(xb);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new Ic(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Ic(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let r = t.state.facet(su);
    if (r != this.input) {
      let n = r.filter((u) => u), i = [], s = [], a = [], o = [];
      for (let u of n) {
        let c = this.specs.indexOf(u), h;
        c < 0 ? (h = u(t.view), o.push(h)) : (h = this.panels[c], h.update && h.update(t)), i.push(h), (h.top ? s : a).push(h);
      }
      this.specs = n, this.panels = i, this.top.sync(s), this.bottom.sync(a);
      for (let u of o)
        u.dom.classList.add("cm-panel"), u.mount && u.mount();
    } else
      for (let n of this.panels)
        n.update && n.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => ue.scrollMargins.of((e) => {
    let r = e.plugin(t);
    return r && { top: r.top.scrollMargin(), bottom: r.bottom.scrollMargin() };
  })
});
class Ic {
  constructor(e, r, n) {
    this.view = e, this.top = r, this.container = n, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let r of this.panels)
      r.destroy && e.indexOf(r) < 0 && r.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let r = this.container || this.view.dom;
      r.insertBefore(this.dom, this.top ? r.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let r of this.panels)
      if (r.dom.parentNode == this.dom) {
        for (; e != r.dom; )
          e = bb(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(r.dom, e);
    for (; e; )
      e = bb(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function bb(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const su = /* @__PURE__ */ me.define({
  enables: UA
});
class Pi extends na {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
Pi.prototype.elementClass = "";
Pi.prototype.toDOM = void 0;
Pi.prototype.mapMode = Vt.TrackBefore;
Pi.prototype.startSide = Pi.prototype.endSide = -1;
Pi.prototype.point = !0;
const lh = /* @__PURE__ */ me.define(), cY = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => We.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Ql = /* @__PURE__ */ me.define();
function hY(t) {
  return [zA(), Ql.of(Object.assign(Object.assign({}, cY), t))];
}
const hg = /* @__PURE__ */ me.define({
  combine: (t) => t.some((e) => e)
});
function zA(t) {
  let e = [
    pY
  ];
  return t && t.fixed === !1 && e.push(hg.of(!0)), e;
}
const pY = /* @__PURE__ */ wt.fromClass(class {
  constructor(t) {
    this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(Ql).map((e) => new vb(t, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !t.state.facet(hg), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, r = t.view.viewport, n = Math.min(e.to, r.to) - Math.max(e.from, r.from);
      this.syncGutters(n < (r.to - r.from) * 0.8);
    }
    t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(hg) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && this.dom.remove();
    let r = We.iter(this.view.state.facet(lh), this.view.viewport.from), n = [], i = this.gutters.map((s) => new dY(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (n.length && (n = []), Array.isArray(s.type)) {
        let a = !0;
        for (let o of s.type)
          if (o.type == yr.Text && a) {
            pg(r, n, o.from);
            for (let u of i)
              u.line(this.view, o, n);
            a = !1;
          } else if (o.widget)
            for (let u of i)
              u.widget(this.view, o);
      } else if (s.type == yr.Text) {
        pg(r, n, s.from);
        for (let a of i)
          a.line(this.view, s, n);
      } else if (s.widget)
        for (let a of i)
          a.widget(this.view, s);
    for (let s of i)
      s.finish();
    t && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(t) {
    let e = t.startState.facet(Ql), r = t.state.facet(Ql), n = t.docChanged || t.heightChanged || t.viewportChanged || !We.eq(t.startState.facet(lh), t.state.facet(lh), t.view.viewport.from, t.view.viewport.to);
    if (e == r)
      for (let i of this.gutters)
        i.update(t) && (n = !0);
    else {
      n = !0;
      let i = [];
      for (let s of r) {
        let a = e.indexOf(s);
        a < 0 ? i.push(new vb(this.view, s)) : (this.gutters[a].update(t), i.push(this.gutters[a]));
      }
      for (let s of this.gutters)
        s.dom.remove(), i.indexOf(s) < 0 && s.destroy();
      for (let s of i)
        this.dom.appendChild(s.dom);
      this.gutters = i;
    }
    return n;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove();
  }
}, {
  provide: (t) => ue.scrollMargins.of((e) => {
    let r = e.plugin(t);
    return !r || r.gutters.length == 0 || !r.fixed ? null : e.textDirection == ct.LTR ? { left: r.dom.offsetWidth * e.scaleX } : { right: r.dom.offsetWidth * e.scaleX };
  })
});
function Db(t) {
  return Array.isArray(t) ? t : [t];
}
function pg(t, e, r) {
  for (; t.value && t.from <= r; )
    t.from == r && e.push(t.value), t.next();
}
class dY {
  constructor(e, r, n) {
    this.gutter = e, this.height = n, this.i = 0, this.cursor = We.iter(e.markers, r.from);
  }
  addElement(e, r, n) {
    let { gutter: i } = this, s = (r.top - this.height) / e.scaleY, a = r.height / e.scaleY;
    if (this.i == i.elements.length) {
      let o = new GA(e, a, s, n);
      i.elements.push(o), i.dom.appendChild(o.dom);
    } else
      i.elements[this.i].update(e, a, s, n);
    this.height = r.bottom, this.i++;
  }
  line(e, r, n) {
    let i = [];
    pg(this.cursor, i, r.from), n.length && (i = i.concat(n));
    let s = this.gutter.config.lineMarker(e, r, i);
    s && i.unshift(s);
    let a = this.gutter;
    i.length == 0 && !a.config.renderEmptyElements || this.addElement(e, r, i);
  }
  widget(e, r) {
    let n = this.gutter.config.widgetMarker(e, r.widget, r);
    n && this.addElement(e, r, [n]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let r = e.elements.pop();
      e.dom.removeChild(r.dom), r.destroy();
    }
  }
}
class vb {
  constructor(e, r) {
    this.view = e, this.config = r, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let n in r.domEventHandlers)
      this.dom.addEventListener(n, (i) => {
        let s = i.target, a;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let u = s.getBoundingClientRect();
          a = (u.top + u.bottom) / 2;
        } else
          a = i.clientY;
        let o = e.lineBlockAtHeight(a - e.documentTop);
        r.domEventHandlers[n](e, o, i) && i.preventDefault();
      });
    this.markers = Db(r.markers(e)), r.initialSpacer && (this.spacer = new GA(e, 0, 0, [r.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let r = this.markers;
    if (this.markers = Db(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let n = e.view.viewport;
    return !We.eq(this.markers, r, n.from, n.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class GA {
  constructor(e, r, n, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, r, n, i);
  }
  update(e, r, n, i) {
    this.height != r && (this.height = r, this.dom.style.height = r + "px"), this.above != n && (this.dom.style.marginTop = (this.above = n) ? n + "px" : ""), fY(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, r) {
    let n = "cm-gutterElement", i = this.dom.firstChild;
    for (let s = 0, a = 0; ; ) {
      let o = a, u = s < r.length ? r[s++] : null, c = !1;
      if (u) {
        let h = u.elementClass;
        h && (n += " " + h);
        for (let p = a; p < this.markers.length; p++)
          if (this.markers[p].compare(u)) {
            o = p, c = !0;
            break;
          }
      } else
        o = this.markers.length;
      for (; a < o; ) {
        let h = this.markers[a++];
        if (h.toDOM) {
          h.destroy(i);
          let p = i.nextSibling;
          i.remove(), i = p;
        }
      }
      if (!u)
        break;
      u.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(u.toDOM(e), i)), c && a++;
    }
    this.dom.className = n, this.markers = r;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function fY(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!t[r].compare(e[r]))
      return !1;
  return !0;
}
const mY = /* @__PURE__ */ me.define(), Xa = /* @__PURE__ */ me.define({
  combine(t) {
    return di(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, r) {
        let n = Object.assign({}, e);
        for (let i in r) {
          let s = n[i], a = r[i];
          n[i] = s ? (o, u, c) => s(o, u, c) || a(o, u, c) : a;
        }
        return n;
      }
    });
  }
});
class gf extends Pi {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function yf(t, e) {
  return t.state.facet(Xa).formatNumber(e, t.state);
}
const gY = /* @__PURE__ */ Ql.compute([Xa], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(mY);
  },
  lineMarker(e, r, n) {
    return n.some((i) => i.toDOM) ? null : new gf(yf(e, e.state.doc.lineAt(r.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(Xa) != e.state.facet(Xa),
  initialSpacer(e) {
    return new gf(yf(e, Sb(e.state.doc.lines)));
  },
  updateSpacer(e, r) {
    let n = yf(r.view, Sb(r.view.state.doc.lines));
    return n == e.number ? e : new gf(n);
  },
  domEventHandlers: t.facet(Xa).domEventHandlers
}));
function yY(t = {}) {
  return [
    Xa.of(t),
    zA(),
    gY
  ];
}
function Sb(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const OY = /* @__PURE__ */ new class extends Pi {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), xY = /* @__PURE__ */ lh.compute(["selection"], (t) => {
  let e = [], r = -1;
  for (let n of t.selection.ranges) {
    let i = t.doc.lineAt(n.head).from;
    i > r && (r = i, e.push(OY.range(i)));
  }
  return We.of(e);
});
function bY() {
  return xY;
}
const HA = 1024;
let DY = 0;
class un {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
class $e {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = DY++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = xr.match(e)), (r) => {
      let n = e(r);
      return n === void 0 ? null : [this, n];
    };
  }
}
$e.closedBy = new $e({ deserialize: (t) => t.split(" ") });
$e.openedBy = new $e({ deserialize: (t) => t.split(" ") });
$e.group = new $e({ deserialize: (t) => t.split(" ") });
$e.isolate = new $e({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
$e.contextHash = new $e({ perNode: !0 });
$e.lookAhead = new $e({ perNode: !0 });
$e.mounted = new $e({ perNode: !0 });
class au {
  constructor(e, r, n) {
    this.tree = e, this.overlay = r, this.parser = n;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[$e.mounted.id];
  }
}
const vY = /* @__PURE__ */ Object.create(null);
class xr {
  /**
  @internal
  */
  constructor(e, r, n, i = 0) {
    this.name = e, this.props = r, this.id = n, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let r = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : vY, n = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new xr(e.name || "", r, e.id, n);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(i)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          r[s[0].id] = s[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let r = this.prop($e.group);
      return r ? r.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let n in e)
      for (let i of n.split(" "))
        r[i] = e[n];
    return (n) => {
      for (let i = n.prop($e.group), s = -1; s < (i ? i.length : 0); s++) {
        let a = r[s < 0 ? n.name : i[s]];
        if (a)
          return a;
      }
    };
  }
}
xr.none = new xr(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class F0 {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let r = 0; r < e.length; r++)
      if (e[r].id != r)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let r = [];
    for (let n of this.types) {
      let i = null;
      for (let s of e) {
        let a = s(n);
        a && (i || (i = Object.assign({}, n.props)), i[a[0].id] = a[1]);
      }
      r.push(i ? new xr(n.name, i, n.id, n.flags) : n);
    }
    return new F0(r);
  }
}
const Nc = /* @__PURE__ */ new WeakMap(), wb = /* @__PURE__ */ new WeakMap();
var ot;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(ot || (ot = {}));
class Ot {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, r, n, i, s) {
    if (this.type = e, this.children = r, this.positions = n, this.length = i, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [a, o] of s)
        this.props[typeof a == "number" ? a : a.id] = o;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = au.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let r = "";
    for (let n of this.children) {
      let i = n.toString();
      i && (r && (r += ","), r += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (r.length ? "(" + r + ")" : "") : r;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new Mh(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, r = 0, n = 0) {
    let i = Nc.get(this) || this.topNode, s = new Mh(i);
    return s.moveTo(e, r), Nc.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new ur(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, r = 0) {
    let n = ou(Nc.get(this) || this.topNode, e, r, !1);
    return Nc.set(this, n), n;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, r = 0) {
    let n = ou(wb.get(this) || this.topNode, e, r, !0);
    return wb.set(this, n), n;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, r = 0) {
    return CY(this, e, r);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: r, leave: n, from: i = 0, to: s = this.length } = e, a = e.mode || 0, o = (a & ot.IncludeAnonymous) > 0;
    for (let u = this.cursor(a | ot.IncludeAnonymous); ; ) {
      let c = !1;
      if (u.from <= s && u.to >= i && (!o && u.type.isAnonymous || r(u) !== !1)) {
        if (u.firstChild())
          continue;
        c = !0;
      }
      for (; c && n && (o || !u.type.isAnonymous) && n(u), !u.nextSibling(); ) {
        if (!u.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let r in this.props)
        e.push([+r, this.props[r]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : I0(xr.none, this.children, this.positions, 0, this.children.length, 0, this.length, (r, n, i) => new Ot(this.type, r, n, i, this.propValues), e.makeTree || ((r, n, i) => new Ot(xr.none, r, n, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return EY(e);
  }
}
Ot.empty = new Ot(xr.none, [], [], 0);
class $0 {
  constructor(e, r) {
    this.buffer = e, this.index = r;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new $0(this.buffer, this.index);
  }
}
class Ds {
  /**
  Create a tree buffer.
  */
  constructor(e, r, n) {
    this.buffer = e, this.length = r, this.set = n;
  }
  /**
  @internal
  */
  get type() {
    return xr.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let r = 0; r < this.buffer.length; )
      e.push(this.childString(r)), r = this.buffer[r + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let r = this.buffer[e], n = this.buffer[e + 3], i = this.set.types[r], s = i.name;
    if (/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), e += 4, n == e)
      return s;
    let a = [];
    for (; e < n; )
      a.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + a.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, r, n, i, s) {
    let { buffer: a } = this, o = -1;
    for (let u = e; u != r && !(JA(s, i, a[u + 1], a[u + 2]) && (o = u, n > 0)); u = a[u + 3])
      ;
    return o;
  }
  /**
  @internal
  */
  slice(e, r, n) {
    let i = this.buffer, s = new Uint16Array(r - e), a = 0;
    for (let o = e, u = 0; o < r; ) {
      s[u++] = i[o++], s[u++] = i[o++] - n;
      let c = s[u++] = i[o++] - n;
      s[u++] = i[o++] - e, a = Math.max(a, c);
    }
    return new Ds(s, a, this.set);
  }
}
function JA(t, e, r, n) {
  switch (t) {
    case -2:
      return r < e;
    case -1:
      return n >= e && r < e;
    case 0:
      return r < e && n > e;
    case 1:
      return r <= e && n > e;
    case 2:
      return n > e;
    case 4:
      return !0;
  }
}
function ou(t, e, r, n) {
  for (var i; t.from == t.to || (r < 1 ? t.from >= e : t.from > e) || (r > -1 ? t.to <= e : t.to < e); ) {
    let a = !n && t instanceof ur && t.index < 0 ? null : t.parent;
    if (!a)
      return t;
    t = a;
  }
  let s = n ? 0 : ot.IgnoreOverlays;
  if (n)
    for (let a = t, o = a.parent; o; a = o, o = a.parent)
      a instanceof ur && a.index < 0 && ((i = o.enter(e, r, s)) === null || i === void 0 ? void 0 : i.from) != a.from && (t = o);
  for (; ; ) {
    let a = t.enter(e, r, s);
    if (!a)
      return t;
    t = a;
  }
}
class KA {
  cursor(e = 0) {
    return new Mh(this, e);
  }
  getChild(e, r = null, n = null) {
    let i = Cb(this, e, r, n);
    return i.length ? i[0] : null;
  }
  getChildren(e, r = null, n = null) {
    return Cb(this, e, r, n);
  }
  resolve(e, r = 0) {
    return ou(this, e, r, !1);
  }
  resolveInner(e, r = 0) {
    return ou(this, e, r, !0);
  }
  matchContext(e) {
    return dg(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let r = this.childBefore(e), n = this;
    for (; r; ) {
      let i = r.lastChild;
      if (!i || i.to != r.to)
        break;
      i.type.isError && i.from == i.to ? (n = r, r = i.prevSibling) : r = i;
    }
    return n;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class ur extends KA {
  constructor(e, r, n, i) {
    super(), this._tree = e, this.from = r, this.index = n, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, r, n, i, s = 0) {
    for (let a = this; ; ) {
      for (let { children: o, positions: u } = a._tree, c = r > 0 ? o.length : -1; e != c; e += r) {
        let h = o[e], p = u[e] + a.from;
        if (JA(i, n, p, p + h.length)) {
          if (h instanceof Ds) {
            if (s & ot.ExcludeBuffers)
              continue;
            let m = h.findChild(0, h.buffer.length, r, n - p, i);
            if (m > -1)
              return new Jn(new SY(a, h, e, p), null, m);
          } else if (s & ot.IncludeAnonymous || !h.type.isAnonymous || B0(h)) {
            let m;
            if (!(s & ot.IgnoreMounts) && (m = au.get(h)) && !m.overlay)
              return new ur(m.tree, p, e, a);
            let g = new ur(h, p, e, a);
            return s & ot.IncludeAnonymous || !g.type.isAnonymous ? g : g.nextChild(r < 0 ? h.children.length - 1 : 0, r, n, i);
          }
        }
      }
      if (s & ot.IncludeAnonymous || !a.type.isAnonymous || (a.index >= 0 ? e = a.index + r : e = r < 0 ? -1 : a._parent._tree.children.length, a = a._parent, !a))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, n = 0) {
    let i;
    if (!(n & ot.IgnoreOverlays) && (i = au.get(this._tree)) && i.overlay) {
      let s = e - this.from;
      for (let { from: a, to: o } of i.overlay)
        if ((r > 0 ? a <= s : a < s) && (r < 0 ? o >= s : o > s))
          return new ur(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, r, n);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function Cb(t, e, r, n) {
  let i = t.cursor(), s = [];
  if (!i.firstChild())
    return s;
  if (r != null) {
    for (let a = !1; !a; )
      if (a = i.type.is(r), !i.nextSibling())
        return s;
  }
  for (; ; ) {
    if (n != null && i.type.is(n))
      return s;
    if (i.type.is(e) && s.push(i.node), !i.nextSibling())
      return n == null ? s : [];
  }
}
function dg(t, e, r = e.length - 1) {
  for (let n = t.parent; r >= 0; n = n.parent) {
    if (!n)
      return !1;
    if (!n.type.isAnonymous) {
      if (e[r] && e[r] != n.name)
        return !1;
      r--;
    }
  }
  return !0;
}
class SY {
  constructor(e, r, n, i) {
    this.parent = e, this.buffer = r, this.index = n, this.start = i;
  }
}
class Jn extends KA {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, r, n) {
    super(), this.context = e, this._parent = r, this.index = n, this.type = e.buffer.set.types[e.buffer.buffer[n]];
  }
  child(e, r, n) {
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.context.start, n);
    return s < 0 ? null : new Jn(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, n = 0) {
    if (n & ot.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], r > 0 ? 1 : -1, e - this.context.start, r);
    return s < 0 ? null : new Jn(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, r = e.buffer[this.index + 3];
    return r < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Jn(this.context, this._parent, r) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, r = this._parent ? this._parent.index + 4 : 0;
    return this.index == r ? this.externalSibling(-1) : new Jn(this.context, this._parent, e.findChild(
      r,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], r = [], { buffer: n } = this.context, i = this.index + 4, s = n.buffer[this.index + 3];
    if (s > i) {
      let a = n.buffer[this.index + 1];
      e.push(n.slice(i, s, a)), r.push(0);
    }
    return new Ot(this.type, e, r, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function eT(t) {
  if (!t.length)
    return null;
  let e = 0, r = t[0];
  for (let s = 1; s < t.length; s++) {
    let a = t[s];
    (a.from > r.from || a.to < r.to) && (r = a, e = s);
  }
  let n = r instanceof ur && r.index < 0 ? null : r.parent, i = t.slice();
  return n ? i[e] = n : i.splice(e, 1), new wY(i, r);
}
class wY {
  constructor(e, r) {
    this.heads = e, this.node = r;
  }
  get next() {
    return eT(this.heads);
  }
}
function CY(t, e, r) {
  let n = t.resolveInner(e, r), i = null;
  for (let s = n instanceof ur ? n : n.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let a = s.parent;
      (i || (i = [n])).push(a.resolve(e, r)), s = a;
    } else {
      let a = au.get(s.tree);
      if (a && a.overlay && a.overlay[0].from <= e && a.overlay[a.overlay.length - 1].to >= e) {
        let o = new ur(a.tree, a.overlay[0].from + s.from, -1, s);
        (i || (i = [n])).push(ou(o, e, r, !1));
      }
    }
  return i ? eT(i) : n;
}
class Mh {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, r = 0) {
    if (this.mode = r, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof ur)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let n = e._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, r) {
    this.index = e;
    let { start: n, buffer: i } = this.buffer;
    return this.type = r || i.set.types[i.buffer[e]], this.from = n + i.buffer[e + 1], this.to = n + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof ur ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, r, n) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, r, n, this.mode));
    let { buffer: i } = this.buffer, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.buffer.start, n);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, r, n = this.mode) {
    return this.buffer ? n & ot.ExcludeBuffers ? !1 : this.enterChild(1, e, r) : this.yield(this._tree.enter(e, r, n));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & ot.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & ot.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: r } = this.buffer, n = this.stack.length - 1;
    if (e < 0) {
      let i = n < 0 ? 0 : this.stack[n] + 4;
      if (this.index != i)
        return this.yieldBuf(r.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = r.buffer[this.index + 3];
      if (i < (n < 0 ? r.buffer.length : r.buffer[this.stack[n] + 3]))
        return this.yieldBuf(i);
    }
    return n < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let r, n, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (i.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: r, parent: n } = i);
    } else
      ({ index: r, _parent: n } = this._tree);
    for (; n; { index: r, _parent: n } = n)
      if (r > -1)
        for (let s = r + e, a = e < 0 ? -1 : n._tree.children.length; s != a; s += e) {
          let o = n._tree.children[s];
          if (this.mode & ot.IncludeAnonymous || o instanceof Ds || !o.type.isAnonymous || B0(o))
            return !1;
        }
    return !0;
  }
  move(e, r) {
    if (r && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, r = 0) {
    for (; (this.from == this.to || (r < 1 ? this.from >= e : this.from > e) || (r > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, r); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, r = null, n = 0;
    if (e && e.context == this.buffer)
      e:
        for (let i = this.index, s = this.stack.length; s >= 0; ) {
          for (let a = e; a; a = a._parent)
            if (a.index == i) {
              if (i == this.index)
                return a;
              r = a, n = s + 1;
              break e;
            }
          i = this.stack[--s];
        }
    for (let i = n; i < this.stack.length; i++)
      r = new Jn(this.buffer, r, this.stack[i]);
    return this.bufferNode = new Jn(this.buffer, r, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, r) {
    for (let n = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          n++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; i && r && r(this), i = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!n)
          return;
        this.parent(), n--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return dg(this.node, e);
    let { buffer: r } = this.buffer, { types: n } = r.set;
    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0)
        return dg(this.node, e, i);
      let a = n[r.buffer[this.stack[s]]];
      if (!a.isAnonymous) {
        if (e[i] && e[i] != a.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function B0(t) {
  return t.children.some((e) => e instanceof Ds || !e.type.isAnonymous || B0(e));
}
function EY(t) {
  var e;
  let { buffer: r, nodeSet: n, maxBufferLength: i = HA, reused: s = [], minRepeatType: a = n.types.length } = t, o = Array.isArray(r) ? new $0(r, r.length) : r, u = n.types, c = 0, h = 0;
  function p(C, A, P, $, B, _) {
    let { id: M, start: Y, end: J, size: R } = o, q = h;
    for (; R < 0; )
      if (o.next(), R == -1) {
        let Se = s[M];
        P.push(Se), $.push(Y - C);
        return;
      } else if (R == -3) {
        c = M;
        return;
      } else if (R == -4) {
        h = M;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${R}`);
    let X = u[M], H, ye, Ce = Y - C;
    if (J - Y <= i && (ye = D(o.pos - A, B))) {
      let Se = new Uint16Array(ye.size - ye.skip), Ne = o.pos - ye.size, Te = Se.length;
      for (; o.pos > Ne; )
        Te = S(ye.start, Se, Te);
      H = new Ds(Se, J - ye.start, n), Ce = ye.start - C;
    } else {
      let Se = o.pos - R;
      o.next();
      let Ne = [], Te = [], Me = M >= a ? M : -1, Ee = 0, nt = J;
      for (; o.pos > Se; )
        Me >= 0 && o.id == Me && o.size >= 0 ? (o.end <= nt - i && (O(Ne, Te, Y, Ee, o.end, nt, Me, q), Ee = Ne.length, nt = o.end), o.next()) : _ > 2500 ? m(Y, Se, Ne, Te) : p(Y, Se, Ne, Te, Me, _ + 1);
      if (Me >= 0 && Ee > 0 && Ee < Ne.length && O(Ne, Te, Y, Ee, Y, nt, Me, q), Ne.reverse(), Te.reverse(), Me > -1 && Ee > 0) {
        let se = g(X);
        H = I0(X, Ne, Te, 0, Ne.length, 0, J - Y, se, se);
      } else
        H = b(X, Ne, Te, J - Y, q - J);
    }
    P.push(H), $.push(Ce);
  }
  function m(C, A, P, $) {
    let B = [], _ = 0, M = -1;
    for (; o.pos > A; ) {
      let { id: Y, start: J, end: R, size: q } = o;
      if (q > 4)
        o.next();
      else {
        if (M > -1 && J < M)
          break;
        M < 0 && (M = R - i), B.push(Y, J, R), _++, o.next();
      }
    }
    if (_) {
      let Y = new Uint16Array(_ * 4), J = B[B.length - 2];
      for (let R = B.length - 3, q = 0; R >= 0; R -= 3)
        Y[q++] = B[R], Y[q++] = B[R + 1] - J, Y[q++] = B[R + 2] - J, Y[q++] = q;
      P.push(new Ds(Y, B[2] - J, n)), $.push(J - C);
    }
  }
  function g(C) {
    return (A, P, $) => {
      let B = 0, _ = A.length - 1, M, Y;
      if (_ >= 0 && (M = A[_]) instanceof Ot) {
        if (!_ && M.type == C && M.length == $)
          return M;
        (Y = M.prop($e.lookAhead)) && (B = P[_] + M.length + Y);
      }
      return b(C, A, P, $, B);
    };
  }
  function O(C, A, P, $, B, _, M, Y) {
    let J = [], R = [];
    for (; C.length > $; )
      J.push(C.pop()), R.push(A.pop() + P - B);
    C.push(b(n.types[M], J, R, _ - B, Y - _)), A.push(B - P);
  }
  function b(C, A, P, $, B = 0, _) {
    if (c) {
      let M = [$e.contextHash, c];
      _ = _ ? [M].concat(_) : [M];
    }
    if (B > 25) {
      let M = [$e.lookAhead, B];
      _ = _ ? [M].concat(_) : [M];
    }
    return new Ot(C, A, P, $, _);
  }
  function D(C, A) {
    let P = o.fork(), $ = 0, B = 0, _ = 0, M = P.end - i, Y = { size: 0, start: 0, skip: 0 };
    e:
      for (let J = P.pos - C; P.pos > J; ) {
        let R = P.size;
        if (P.id == A && R >= 0) {
          Y.size = $, Y.start = B, Y.skip = _, _ += 4, $ += 4, P.next();
          continue;
        }
        let q = P.pos - R;
        if (R < 0 || q < J || P.start < M)
          break;
        let X = P.id >= a ? 4 : 0, H = P.start;
        for (P.next(); P.pos > q; ) {
          if (P.size < 0)
            if (P.size == -3)
              X += 4;
            else
              break e;
          else
            P.id >= a && (X += 4);
          P.next();
        }
        B = H, $ += R, _ += X;
      }
    return (A < 0 || $ == C) && (Y.size = $, Y.start = B, Y.skip = _), Y.size > 4 ? Y : void 0;
  }
  function S(C, A, P) {
    let { id: $, start: B, end: _, size: M } = o;
    if (o.next(), M >= 0 && $ < a) {
      let Y = P;
      if (M > 4) {
        let J = o.pos - (M - 4);
        for (; o.pos > J; )
          P = S(C, A, P);
      }
      A[--P] = Y, A[--P] = _ - C, A[--P] = B - C, A[--P] = $;
    } else
      M == -3 ? c = $ : M == -4 && (h = $);
    return P;
  }
  let x = [], w = [];
  for (; o.pos > 0; )
    p(t.start || 0, t.bufferStart || 0, x, w, -1, 0);
  let T = (e = t.length) !== null && e !== void 0 ? e : x.length ? w[0] + x[0].length : 0;
  return new Ot(u[t.topID], x.reverse(), w.reverse(), T);
}
const Eb = /* @__PURE__ */ new WeakMap();
function uh(t, e) {
  if (!t.isAnonymous || e instanceof Ds || e.type != t)
    return 1;
  let r = Eb.get(e);
  if (r == null) {
    r = 1;
    for (let n of e.children) {
      if (n.type != t || !(n instanceof Ot)) {
        r = 1;
        break;
      }
      r += uh(t, n);
    }
    Eb.set(e, r);
  }
  return r;
}
function I0(t, e, r, n, i, s, a, o, u) {
  let c = 0;
  for (let O = n; O < i; O++)
    c += uh(t, e[O]);
  let h = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), p = [], m = [];
  function g(O, b, D, S, x) {
    for (let w = D; w < S; ) {
      let T = w, C = b[w], A = uh(t, O[w]);
      for (w++; w < S; w++) {
        let P = uh(t, O[w]);
        if (A + P >= h)
          break;
        A += P;
      }
      if (w == T + 1) {
        if (A > h) {
          let P = O[T];
          g(P.children, P.positions, 0, P.children.length, b[T] + x);
          continue;
        }
        p.push(O[T]);
      } else {
        let P = b[w - 1] + O[w - 1].length - C;
        p.push(I0(t, O, b, T, w, C, P, null, u));
      }
      m.push(C + x - s);
    }
  }
  return g(e, r, n, i, 0), (o || u)(p, m, a);
}
class tT {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, r, n) {
    let i = this.map.get(e);
    i || this.map.set(e, i = /* @__PURE__ */ new Map()), i.set(r, n);
  }
  getBuffer(e, r) {
    let n = this.map.get(e);
    return n && n.get(r);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, r) {
    e instanceof Jn ? this.setBuffer(e.context.buffer, e.index, r) : e instanceof ur && this.map.set(e.tree, r);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof Jn ? this.getBuffer(e.context.buffer, e.index) : e instanceof ur ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, r) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, r) : this.map.set(e.tree, r);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class vi {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, r, n, i, s = !1, a = !1) {
    this.from = e, this.to = r, this.tree = n, this.offset = i, this.open = (s ? 1 : 0) | (a ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, r = [], n = !1) {
    let i = [new vi(0, e.length, e, 0, !1, n)];
    for (let s of r)
      s.to > e.length && i.push(s);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, r, n = 128) {
    if (!r.length)
      return e;
    let i = [], s = 1, a = e.length ? e[0] : null;
    for (let o = 0, u = 0, c = 0; ; o++) {
      let h = o < r.length ? r[o] : null, p = h ? h.fromA : 1e9;
      if (p - u >= n)
        for (; a && a.from < p; ) {
          let m = a;
          if (u >= m.from || p <= m.to || c) {
            let g = Math.max(m.from, u) - c, O = Math.min(m.to, p) - c;
            m = g >= O ? null : new vi(g, O, m.tree, m.offset + c, o > 0, !!h);
          }
          if (m && i.push(m), a.to > p)
            break;
          a = s < e.length ? e[s++] : null;
        }
      if (!h)
        break;
      u = h.toA, c = h.toA - h.toB;
    }
    return i;
  }
}
class rT {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, r, n) {
    return typeof e == "string" && (e = new AY(e)), n = n ? n.length ? n.map((i) => new un(i.from, i.to)) : [new un(0, 0)] : [new un(0, e.length)], this.createParse(e, r || [], n);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, r, n) {
    let i = this.startParse(e, r, n);
    for (; ; ) {
      let s = i.advance();
      if (s)
        return s;
    }
  }
}
class AY {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, r) {
    return this.string.slice(e, r);
  }
}
function TY(t) {
  return (e, r, n, i) => new PY(e, t, r, n, i);
}
class Ab {
  constructor(e, r, n, i, s) {
    this.parser = e, this.parse = r, this.overlay = n, this.target = i, this.from = s;
  }
}
function Tb(t) {
  if (!t.length || t.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(t));
}
class kY {
  constructor(e, r, n, i, s, a, o) {
    this.parser = e, this.predicate = r, this.mounts = n, this.index = i, this.start = s, this.target = a, this.prev = o, this.depth = 0, this.ranges = [];
  }
}
const fg = new $e({ perNode: !0 });
class PY {
  constructor(e, r, n, i, s) {
    this.nest = r, this.input = n, this.fragments = i, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let n = this.baseParse.advance();
      if (!n)
        return null;
      if (this.baseParse = null, this.baseTree = n, this.startInner(), this.stoppedAt != null)
        for (let i of this.inner)
          i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let n = this.baseTree;
      return this.stoppedAt != null && (n = new Ot(n.type, n.children, n.positions, n.length, n.propValues.concat([[fg, this.stoppedAt]]))), n;
    }
    let e = this.inner[this.innerDone], r = e.parse.advance();
    if (r) {
      this.innerDone++;
      let n = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      n[$e.mounted.id] = new au(r, e.overlay, e.parser), e.target.props = n;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let r = this.innerDone; r < this.inner.length; r++)
      this.inner[r].from < e && (e = Math.min(e, this.inner[r].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let r = this.innerDone; r < this.inner.length; r++)
        this.inner[r].parse.stopAt(e);
  }
  startInner() {
    let e = new BY(this.fragments), r = null, n = null, i = new Mh(new ur(this.baseTree, this.ranges[0].from, 0, null), ot.IncludeAnonymous | ot.IgnoreMounts);
    e:
      for (let s, a; ; ) {
        let o = !0, u;
        if (this.stoppedAt != null && i.from >= this.stoppedAt)
          o = !1;
        else if (e.hasNode(i)) {
          if (r) {
            let c = r.mounts.find((h) => h.frag.from <= i.from && h.frag.to >= i.to && h.mount.overlay);
            if (c)
              for (let h of c.mount.overlay) {
                let p = h.from + c.pos, m = h.to + c.pos;
                p >= i.from && m <= i.to && !r.ranges.some((g) => g.from < m && g.to > p) && r.ranges.push({ from: p, to: m });
              }
          }
          o = !1;
        } else if (n && (a = FY(n.ranges, i.from, i.to)))
          o = a != 2;
        else if (!i.type.isAnonymous && (s = this.nest(i, this.input)) && (i.from < i.to || !s.overlay)) {
          i.tree || $Y(i);
          let c = e.findMounts(i.from, s.parser);
          if (typeof s.overlay == "function")
            r = new kY(s.parser, s.overlay, c, this.inner.length, i.from, i.tree, r);
          else {
            let h = Fb(this.ranges, s.overlay || (i.from < i.to ? [new un(i.from, i.to)] : []));
            h.length && Tb(h), (h.length || !s.overlay) && this.inner.push(new Ab(s.parser, h.length ? s.parser.startParse(this.input, $b(c, h), h) : s.parser.startParse(""), s.overlay ? s.overlay.map((p) => new un(p.from - i.from, p.to - i.from)) : null, i.tree, h.length ? h[0].from : i.from)), s.overlay ? h.length && (n = { ranges: h, depth: 0, prev: n }) : o = !1;
          }
        } else
          r && (u = r.predicate(i)) && (u === !0 && (u = new un(i.from, i.to)), u.from < u.to && r.ranges.push(u));
        if (o && i.firstChild())
          r && r.depth++, n && n.depth++;
        else
          for (; !i.nextSibling(); ) {
            if (!i.parent())
              break e;
            if (r && !--r.depth) {
              let c = Fb(this.ranges, r.ranges);
              c.length && (Tb(c), this.inner.splice(r.index, 0, new Ab(r.parser, r.parser.startParse(this.input, $b(r.mounts, c), c), r.ranges.map((h) => new un(h.from - r.start, h.to - r.start)), r.target, c[0].from))), r = r.prev;
            }
            n && !--n.depth && (n = n.prev);
          }
      }
  }
}
function FY(t, e, r) {
  for (let n of t) {
    if (n.from >= r)
      break;
    if (n.to > e)
      return n.from <= e && n.to >= r ? 2 : 1;
  }
  return 0;
}
function kb(t, e, r, n, i, s) {
  if (e < r) {
    let a = t.buffer[e + 1];
    n.push(t.slice(e, r, a)), i.push(a - s);
  }
}
function $Y(t) {
  let { node: e } = t, r = [], n = e.context.buffer;
  do
    r.push(t.index), t.parent();
  while (!t.tree);
  let i = t.tree, s = i.children.indexOf(n), a = i.children[s], o = a.buffer, u = [s];
  function c(h, p, m, g, O, b) {
    let D = r[b], S = [], x = [];
    kb(a, h, D, S, x, g);
    let w = o[D + 1], T = o[D + 2];
    u.push(S.length);
    let C = b ? c(D + 4, o[D + 3], a.set.types[o[D]], w, T - w, b - 1) : e.toTree();
    return S.push(C), x.push(w - g), kb(a, o[D + 3], p, S, x, g), new Ot(m, S, x, O);
  }
  i.children[s] = c(0, o.length, xr.none, 0, a.length, r.length - 1);
  for (let h of u) {
    let p = t.tree.children[h], m = t.tree.positions[h];
    t.yield(new ur(p, m + t.from, h, t._tree));
  }
}
class Pb {
  constructor(e, r) {
    this.offset = r, this.done = !1, this.cursor = e.cursor(ot.IncludeAnonymous | ot.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: r } = this, n = e - this.offset;
    for (; !this.done && r.from < n; )
      r.to >= e && r.enter(n, 1, ot.IgnoreOverlays | ot.ExcludeBuffers) || r.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let r = this.cursor.tree; ; ) {
        if (r == e.tree)
          return !0;
        if (r.children.length && r.positions[0] == 0 && r.children[0] instanceof Ot)
          r = r.children[0];
        else
          break;
      }
    return !1;
  }
}
let BY = class {
  constructor(e) {
    var r;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let n = this.curFrag = e[0];
      this.curTo = (r = n.tree.prop(fg)) !== null && r !== void 0 ? r : n.to, this.inner = new Pb(n.tree, -n.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let r = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = r.tree.prop(fg)) !== null && e !== void 0 ? e : r.to, this.inner = new Pb(r.tree, -r.offset);
    }
  }
  findMounts(e, r) {
    var n;
    let i = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let a = (n = s.tree) === null || n === void 0 ? void 0 : n.prop($e.mounted);
        if (a && a.parser == r)
          for (let o = this.fragI; o < this.fragments.length; o++) {
            let u = this.fragments[o];
            if (u.from >= s.to)
              break;
            u.tree == this.curFrag.tree && i.push({
              frag: u,
              pos: s.from - u.offset,
              mount: a
            });
          }
      }
    }
    return i;
  }
};
function Fb(t, e) {
  let r = null, n = e;
  for (let i = 1, s = 0; i < t.length; i++) {
    let a = t[i - 1].to, o = t[i].from;
    for (; s < n.length; s++) {
      let u = n[s];
      if (u.from >= o)
        break;
      u.to <= a || (r || (n = r = e.slice()), u.from < a ? (r[s] = new un(u.from, a), u.to > o && r.splice(s + 1, 0, new un(o, u.to))) : u.to > o ? r[s--] = new un(o, u.to) : r.splice(s--, 1));
    }
  }
  return n;
}
function IY(t, e, r, n) {
  let i = 0, s = 0, a = !1, o = !1, u = -1e9, c = [];
  for (; ; ) {
    let h = i == t.length ? 1e9 : a ? t[i].to : t[i].from, p = s == e.length ? 1e9 : o ? e[s].to : e[s].from;
    if (a != o) {
      let m = Math.max(u, r), g = Math.min(h, p, n);
      m < g && c.push(new un(m, g));
    }
    if (u = Math.min(h, p), u == 1e9)
      break;
    h == u && (a ? (a = !1, i++) : a = !0), p == u && (o ? (o = !1, s++) : o = !0);
  }
  return c;
}
function $b(t, e) {
  let r = [];
  for (let { pos: n, mount: i, frag: s } of t) {
    let a = n + (i.overlay ? i.overlay[0].from : 0), o = a + i.tree.length, u = Math.max(s.from, a), c = Math.min(s.to, o);
    if (i.overlay) {
      let h = i.overlay.map((m) => new un(m.from + n, m.to + n)), p = IY(e, h, u, c);
      for (let m = 0, g = u; ; m++) {
        let O = m == p.length, b = O ? c : p[m].from;
        if (b > g && r.push(new vi(g, b, i.tree, -a, s.from >= g || s.openStart, s.to <= b || s.openEnd)), O)
          break;
        g = p[m].to;
      }
    } else
      r.push(new vi(u, c, i.tree, -a, s.from >= a || s.openStart, s.to <= o || s.openEnd));
  }
  return r;
}
let NY = 0;
class Un {
  /**
  @internal
  */
  constructor(e, r, n) {
    this.set = e, this.base = r, this.modified = n, this.id = NY++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let r = new Un([], null, []);
    if (r.set.push(r), e)
      for (let n of e.set)
        r.set.push(n);
    return r;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new Lh();
    return (r) => r.modified.indexOf(e) > -1 ? r : Lh.get(r.base || r, r.modified.concat(e).sort((n, i) => n.id - i.id));
  }
}
let _Y = 0;
class Lh {
  constructor() {
    this.instances = [], this.id = _Y++;
  }
  static get(e, r) {
    if (!r.length)
      return e;
    let n = r[0].instances.find((o) => o.base == e && QY(r, o.modified));
    if (n)
      return n;
    let i = [], s = new Un(i, e, r);
    for (let o of r)
      o.instances.push(s);
    let a = MY(r);
    for (let o of e.set)
      if (!o.modified.length)
        for (let u of a)
          i.push(Lh.get(o, u));
    return s;
  }
}
function QY(t, e) {
  return t.length == e.length && t.every((r, n) => r == e[n]);
}
function MY(t) {
  let e = [[]];
  for (let r = 0; r < t.length; r++)
    for (let n = 0, i = e.length; n < i; n++)
      e.push(e[n].concat(t[r]));
  return e.sort((r, n) => n.length - r.length);
}
function Ru(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let n = t[r];
    Array.isArray(n) || (n = [n]);
    for (let i of r.split(" "))
      if (i) {
        let s = [], a = 2, o = i;
        for (let p = 0; ; ) {
          if (o == "..." && p > 0 && p + 3 == i.length) {
            a = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(o);
          if (!m)
            throw new RangeError("Invalid path: " + i);
          if (s.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]), p += m[0].length, p == i.length)
            break;
          let g = i[p++];
          if (p == i.length && g == "!") {
            a = 0;
            break;
          }
          if (g != "/")
            throw new RangeError("Invalid path: " + i);
          o = i.slice(p);
        }
        let u = s.length - 1, c = s[u];
        if (!c)
          throw new RangeError("Invalid path: " + i);
        let h = new Rh(n, a, u > 0 ? s.slice(0, u) : null);
        e[c] = h.sort(e[c]);
      }
  }
  return nT.add(e);
}
const nT = new $e();
class Rh {
  constructor(e, r, n, i) {
    this.tags = e, this.mode = r, this.context = n, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Rh.empty = new Rh([], 2, null);
function iT(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let s of t)
    if (!Array.isArray(s.tag))
      r[s.tag.id] = s.class;
    else
      for (let a of s.tag)
        r[a.id] = s.class;
  let { scope: n, all: i = null } = e || {};
  return {
    style: (s) => {
      let a = i;
      for (let o of s)
        for (let u of o.set) {
          let c = r[u.id];
          if (c) {
            a = a ? a + " " + c : c;
            break;
          }
        }
      return a;
    },
    scope: n
  };
}
function LY(t, e) {
  let r = null;
  for (let n of t) {
    let i = n.style(e);
    i && (r = r ? r + " " + i : i);
  }
  return r;
}
function RY(t, e, r, n = 0, i = t.length) {
  let s = new jY(n, Array.isArray(e) ? e : [e], r);
  s.highlightRange(t.cursor(), n, i, "", s.highlighters), s.flush(i);
}
class jY {
  constructor(e, r, n) {
    this.at = e, this.highlighters = r, this.span = n, this.class = "";
  }
  startSpan(e, r) {
    r != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = r);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, r, n, i, s) {
    let { type: a, from: o, to: u } = e;
    if (o >= n || u <= r)
      return;
    a.isTop && (s = this.highlighters.filter((g) => !g.scope || g.scope(a)));
    let c = i, h = ZY(e) || Rh.empty, p = LY(s, h.tags);
    if (p && (c && (c += " "), c += p, h.mode == 1 && (i += (i ? " " : "") + p)), this.startSpan(Math.max(r, o), c), h.opaque)
      return;
    let m = e.tree && e.tree.prop($e.mounted);
    if (m && m.overlay) {
      let g = e.node.enter(m.overlay[0].from + o, 1), O = this.highlighters.filter((D) => !D.scope || D.scope(m.tree.type)), b = e.firstChild();
      for (let D = 0, S = o; ; D++) {
        let x = D < m.overlay.length ? m.overlay[D] : null, w = x ? x.from + o : u, T = Math.max(r, S), C = Math.min(n, w);
        if (T < C && b)
          for (; e.from < C && (this.highlightRange(e, T, C, i, s), this.startSpan(Math.min(C, e.to), c), !(e.to >= w || !e.nextSibling())); )
            ;
        if (!x || w > n)
          break;
        S = x.to + o, S > r && (this.highlightRange(g.cursor(), Math.max(r, x.from + o), Math.min(n, S), "", O), this.startSpan(Math.min(n, S), c));
      }
      b && e.parent();
    } else if (e.firstChild()) {
      m && (i = "");
      do
        if (!(e.to <= r)) {
          if (e.from >= n)
            break;
          this.highlightRange(e, r, n, i, s), this.startSpan(Math.min(n, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function ZY(t) {
  let e = t.type.prop(nT);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const oe = Un.define, _c = oe(), Ki = oe(), Bb = oe(Ki), Ib = oe(Ki), es = oe(), Qc = oe(es), Of = oe(es), Yn = oe(), Ns = oe(Yn), Wn = oe(), qn = oe(), mg = oe(), il = oe(mg), Mc = oe(), Q = {
  /**
  A comment.
  */
  comment: _c,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: oe(_c),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: oe(_c),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: oe(_c),
  /**
  Any kind of identifier.
  */
  name: Ki,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: oe(Ki),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: Bb,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: oe(Bb),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: Ib,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: oe(Ib),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: oe(Ki),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: oe(Ki),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: oe(Ki),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: oe(Ki),
  /**
  A literal value.
  */
  literal: es,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Qc,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: oe(Qc),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: oe(Qc),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: oe(Qc),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Of,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: oe(Of),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: oe(Of),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: oe(es),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: oe(es),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: oe(es),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: oe(es),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: oe(es),
  /**
  A language keyword.
  */
  keyword: Wn,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: oe(Wn),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: oe(Wn),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: oe(Wn),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: oe(Wn),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: oe(Wn),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: oe(Wn),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: oe(Wn),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: oe(Wn),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: oe(Wn),
  /**
  An operator.
  */
  operator: qn,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: oe(qn),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: oe(qn),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: oe(qn),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: oe(qn),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: oe(qn),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: oe(qn),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: oe(qn),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: oe(qn),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: oe(qn),
  /**
  Program or markup punctuation.
  */
  punctuation: mg,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: oe(mg),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: il,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: oe(il),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: oe(il),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: oe(il),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: oe(il),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Yn,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Ns,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: oe(Ns),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: oe(Ns),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: oe(Ns),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: oe(Ns),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: oe(Ns),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: oe(Ns),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: oe(Yn),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: oe(Yn),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: oe(Yn),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: oe(Yn),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: oe(Yn),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: oe(Yn),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: oe(Yn),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: oe(Yn),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: oe(),
  /**
  Deleted text.
  */
  deleted: oe(),
  /**
  Changed text.
  */
  changed: oe(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: oe(),
  /**
  Metadata or meta-instruction.
  */
  meta: Mc,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: oe(Mc),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: oe(Mc),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: oe(Mc),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Un.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Un.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Un.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Un.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Un.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Un.defineModifier()
};
iT([
  { tag: Q.link, class: "tok-link" },
  { tag: Q.heading, class: "tok-heading" },
  { tag: Q.emphasis, class: "tok-emphasis" },
  { tag: Q.strong, class: "tok-strong" },
  { tag: Q.keyword, class: "tok-keyword" },
  { tag: Q.atom, class: "tok-atom" },
  { tag: Q.bool, class: "tok-bool" },
  { tag: Q.url, class: "tok-url" },
  { tag: Q.labelName, class: "tok-labelName" },
  { tag: Q.inserted, class: "tok-inserted" },
  { tag: Q.deleted, class: "tok-deleted" },
  { tag: Q.literal, class: "tok-literal" },
  { tag: Q.string, class: "tok-string" },
  { tag: Q.number, class: "tok-number" },
  { tag: [Q.regexp, Q.escape, Q.special(Q.string)], class: "tok-string2" },
  { tag: Q.variableName, class: "tok-variableName" },
  { tag: Q.local(Q.variableName), class: "tok-variableName tok-local" },
  { tag: Q.definition(Q.variableName), class: "tok-variableName tok-definition" },
  { tag: Q.special(Q.variableName), class: "tok-variableName2" },
  { tag: Q.definition(Q.propertyName), class: "tok-propertyName tok-definition" },
  { tag: Q.typeName, class: "tok-typeName" },
  { tag: Q.namespace, class: "tok-namespace" },
  { tag: Q.className, class: "tok-className" },
  { tag: Q.macroName, class: "tok-macroName" },
  { tag: Q.propertyName, class: "tok-propertyName" },
  { tag: Q.operator, class: "tok-operator" },
  { tag: Q.comment, class: "tok-comment" },
  { tag: Q.meta, class: "tok-meta" },
  { tag: Q.invalid, class: "tok-invalid" },
  { tag: Q.punctuation, class: "tok-punctuation" }
]);
var xf;
const Va = /* @__PURE__ */ new $e();
function sT(t) {
  return me.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
const N0 = /* @__PURE__ */ new $e();
class $n {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, r, n = [], i = "") {
    this.data = e, this.name = i, Le.prototype.hasOwnProperty("tree") || Object.defineProperty(Le.prototype, "tree", { get() {
      return bt(this);
    } }), this.parser = r, this.extension = [
      vs.of(this),
      Le.languageData.of((s, a, o) => {
        let u = Nb(s, a, o), c = u.type.prop(Va);
        if (!c)
          return [];
        let h = s.facet(c), p = u.type.prop(N0);
        if (p) {
          let m = u.resolve(a - u.from, o);
          for (let g of p)
            if (g.test(m, s)) {
              let O = s.facet(g.facet);
              return g.type == "replace" ? O : O.concat(h);
            }
        }
        return h;
      })
    ].concat(n);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, r, n = -1) {
    return Nb(e, r, n).type.prop(Va) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let r = e.facet(vs);
    if ((r == null ? void 0 : r.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!r || !r.allowsNesting)
      return [];
    let n = [], i = (s, a) => {
      if (s.prop(Va) == this.data) {
        n.push({ from: a, to: a + s.length });
        return;
      }
      let o = s.prop($e.mounted);
      if (o) {
        if (o.tree.prop(Va) == this.data) {
          if (o.overlay)
            for (let u of o.overlay)
              n.push({ from: u.from + a, to: u.to + a });
          else
            n.push({ from: a, to: a + s.length });
          return;
        } else if (o.overlay) {
          let u = n.length;
          if (i(o.tree, o.overlay[0].from + a), n.length > u)
            return;
        }
      }
      for (let u = 0; u < s.children.length; u++) {
        let c = s.children[u];
        c instanceof Ot && i(c, s.positions[u] + a);
      }
    };
    return i(bt(e), 0), n;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
$n.setState = /* @__PURE__ */ Ae.define();
function Nb(t, e, r) {
  let n = t.facet(vs), i = bt(t).topNode;
  if (!n || n.allowsNesting)
    for (let s = i; s; s = s.enter(e, r, ot.ExcludeBuffers))
      s.type.isTop && (i = s);
  return i;
}
class aa extends $n {
  constructor(e, r, n) {
    super(e, r, [], n), this.parser = r;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let r = sT(e.languageData);
    return new aa(r, e.parser.configure({
      props: [Va.add((n) => n.isTop ? r : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, r) {
    return new aa(this.data, this.parser.configure(e), r || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function bt(t) {
  let e = t.field($n.state, !1);
  return e ? e.tree : Ot.empty;
}
class WY {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, r) {
    let n = this.cursorPos - this.string.length;
    return e < n || r >= this.cursorPos ? this.doc.sliceString(e, r) : this.string.slice(e - n, r - n);
  }
}
let sl = null;
class jh {
  constructor(e, r, n = [], i, s, a, o, u) {
    this.parser = e, this.state = r, this.fragments = n, this.tree = i, this.treeLen = s, this.viewport = a, this.skipped = o, this.scheduleOn = u, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new jh(e, r, [], Ot.empty, 0, n, [], null);
  }
  startParse() {
    return this.parser.startParse(new WY(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, r) {
    return r != null && r >= this.state.doc.length && (r = void 0), this.tree != Ot.empty && this.isDone(r ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var n;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), r != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > r) && r < this.state.doc.length && this.parse.stopAt(r); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(vi.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (n = this.parse.stoppedAt) !== null && n !== void 0 ? n : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (r ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, r;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(r = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = r, this.fragments = this.withoutTempSkipped(vi.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let r = sl;
    sl = this;
    try {
      return e();
    } finally {
      sl = r;
    }
  }
  withoutTempSkipped(e) {
    for (let r; r = this.tempSkipped.pop(); )
      e = _b(e, r.from, r.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, r) {
    let { fragments: n, tree: i, treeLen: s, viewport: a, skipped: o } = this;
    if (this.takeTree(), !e.empty) {
      let u = [];
      if (e.iterChangedRanges((c, h, p, m) => u.push({ fromA: c, toA: h, fromB: p, toB: m })), n = vi.applyChanges(n, u), i = Ot.empty, s = 0, a = { from: e.mapPos(a.from, -1), to: e.mapPos(a.to, 1) }, this.skipped.length) {
        o = [];
        for (let c of this.skipped) {
          let h = e.mapPos(c.from, 1), p = e.mapPos(c.to, -1);
          h < p && o.push({ from: h, to: p });
        }
      }
    }
    return new jh(this.parser, r, n, i, s, a, o, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let r = this.skipped.length;
    for (let n = 0; n < this.skipped.length; n++) {
      let { from: i, to: s } = this.skipped[n];
      i < e.to && s > e.from && (this.fragments = _b(this.fragments, i, s), this.skipped.splice(n--, 1));
    }
    return this.skipped.length >= r ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, r) {
    this.skipped.push({ from: e, to: r });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends rT {
      createParse(r, n, i) {
        let s = i[0].from, a = i[i.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let u = sl;
            if (u) {
              for (let c of i)
                u.tempSkipped.push(c);
              e && (u.scheduleOn = u.scheduleOn ? Promise.all([u.scheduleOn, e]) : e);
            }
            return this.parsedPos = a, new Ot(xr.none, [], [], a - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let r = this.fragments;
    return this.treeLen >= e && r.length && r[0].from == 0 && r[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return sl;
  }
}
function _b(t, e, r) {
  return vi.applyChanges(t, [{ fromA: e, toA: r, fromB: e, toB: r }]);
}
class mo {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let r = this.context.changes(e.changes, e.state), n = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), r.viewport.to);
    return r.work(20, n) || r.takeTree(), new mo(r);
  }
  static init(e) {
    let r = Math.min(3e3, e.doc.length), n = jh.create(e.facet(vs).parser, e, { from: 0, to: r });
    return n.work(20, r) || n.takeTree(), new mo(n);
  }
}
$n.state = /* @__PURE__ */ Rt.define({
  create: mo.init,
  update(t, e) {
    for (let r of e.effects)
      if (r.is($n.setState))
        return r.value;
    return e.startState.facet(vs) != e.state.facet(vs) ? mo.init(e.state) : t.apply(e);
  }
});
let aT = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (aT = (t) => {
  let e = -1, r = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(r) : cancelIdleCallback(e);
});
const bf = typeof navigator < "u" && (!((xf = navigator.scheduling) === null || xf === void 0) && xf.isInputPending) ? () => navigator.scheduling.isInputPending() : null, qY = /* @__PURE__ */ wt.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let r = this.view.state.field($n.state).context;
    (r.updateViewport(e.view.viewport) || this.view.viewport.to > r.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(r);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, r = e.field($n.state);
    (r.tree != r.context.tree || !r.context.isDone(e.doc.length)) && (this.working = aT(this.work));
  }
  work(e) {
    this.working = null;
    let r = Date.now();
    if (this.chunkEnd < r && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = r + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: n, viewport: { to: i } } = this.view, s = n.field($n.state);
    if (s.tree == s.context.tree && s.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let a = Date.now() + Math.min(this.chunkBudget, 100, e && !bf ? Math.max(25, e.timeRemaining() - 5) : 1e9), o = s.context.treeLen < i && n.doc.length > i + 1e3, u = s.context.work(() => bf && bf() || Date.now() > a, i + (o ? 0 : 1e5));
    this.chunkBudget -= Date.now() - r, (u || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: $n.setState.of(new mo(s.context)) })), this.chunkBudget > 0 && !(u && !o) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((r) => hn(this.view.state, r)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), vs = /* @__PURE__ */ me.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    $n.state,
    qY,
    ue.contentAttributes.compute([t], (e) => {
      let r = e.facet(t);
      return r && r.name ? { "data-language": r.name } : {};
    })
  ]
});
class od {
  /**
  Create a language support object.
  */
  constructor(e, r = []) {
    this.language = e, this.support = r, this.extension = [e, r];
  }
}
const XY = /* @__PURE__ */ me.define(), ju = /* @__PURE__ */ me.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((r) => r != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function Zh(t) {
  let e = t.facet(ju);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function lu(t, e) {
  let r = "", n = t.tabSize, i = t.facet(ju)[0];
  if (i == "	") {
    for (; e >= n; )
      r += "	", e -= n;
    i = " ";
  }
  for (let s = 0; s < e; s++)
    r += i;
  return r;
}
function _0(t, e) {
  t instanceof Le && (t = new ld(t));
  for (let n of t.state.facet(XY)) {
    let i = n(t, e);
    if (i !== void 0)
      return i;
  }
  let r = bt(t.state);
  return r.length >= e ? VY(t, r, e) : null;
}
class ld {
  /**
  Create an indent context.
  */
  constructor(e, r = {}) {
    this.state = e, this.options = r, this.unit = Zh(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, r = 1) {
    let n = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: s } = this.options;
    return i != null && i >= n.from && i <= n.to ? s && i == e ? { text: "", from: e } : (r < 0 ? i < e : i <= e) ? { text: n.text.slice(i - n.from), from: i } : { text: n.text.slice(0, i - n.from), from: n.from } : n;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, r = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: n, from: i } = this.lineAt(e, r);
    return n.slice(e - i, Math.min(n.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, r = 1) {
    let { text: n, from: i } = this.lineAt(e, r), s = this.countColumn(n, e - i), a = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return a > -1 && (s += a - this.countColumn(n, n.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, r = e.length) {
    return Qo(e, this.state.tabSize, r);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, r = 1) {
    let { text: n, from: i } = this.lineAt(e, r), s = this.options.overrideIndentation;
    if (s) {
      let a = s(i);
      if (a > -1)
        return a;
    }
    return this.countColumn(n, n.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Zu = /* @__PURE__ */ new $e();
function VY(t, e, r) {
  let n = e.resolveStack(r), i = n.node.enterUnfinishedNodesBefore(r);
  if (i != n.node) {
    let s = [];
    for (let a = i; a != n.node; a = a.parent)
      s.push(a);
    for (let a = s.length - 1; a >= 0; a--)
      n = { node: s[a], next: n };
  }
  return oT(n, t, r);
}
function oT(t, e, r) {
  for (let n = t; n; n = n.next) {
    let i = UY(n.node);
    if (i)
      return i(Q0.create(e, r, n));
  }
  return 0;
}
function YY(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function UY(t) {
  let e = t.type.prop(Zu);
  if (e)
    return e;
  let r = t.firstChild, n;
  if (r && (n = r.type.prop($e.closedBy))) {
    let i = t.lastChild, s = i && n.indexOf(i.name) > -1;
    return (a) => lT(a, !0, 1, void 0, s && !YY(a) ? i.from : void 0);
  }
  return t.parent == null ? zY : null;
}
function zY() {
  return 0;
}
class Q0 extends ld {
  constructor(e, r, n) {
    super(e.state, e.options), this.base = e, this.pos = r, this.context = n;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new Q0(e, r, n);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let r = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let n = e.resolve(r.from);
      for (; n.parent && n.parent.from == n.from; )
        n = n.parent;
      if (GY(n, e))
        break;
      r = this.state.doc.lineAt(n.from);
    }
    return this.lineIndent(r.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return oT(this.context.next, this.base, this.pos);
  }
}
function GY(t, e) {
  for (let r = e; r; r = r.parent)
    if (t == r)
      return !0;
  return !1;
}
function HY(t) {
  let e = t.node, r = e.childAfter(e.from), n = e.lastChild;
  if (!r)
    return null;
  let i = t.options.simulateBreak, s = t.state.doc.lineAt(r.from), a = i == null || i <= s.from ? s.to : Math.min(s.to, i);
  for (let o = r.to; ; ) {
    let u = e.childAfter(o);
    if (!u || u == n)
      return null;
    if (!u.type.isSkipped)
      return u.from < a ? r : null;
    o = u.to;
  }
}
function JY({ closing: t, align: e = !0, units: r = 1 }) {
  return (n) => lT(n, e, r, t);
}
function lT(t, e, r, n, i) {
  let s = t.textAfter, a = s.match(/^\s*/)[0].length, o = n && s.slice(a, a + n.length) == n || i == t.pos + a, u = e ? HY(t) : null;
  return u ? o ? t.column(u.from) : t.column(u.to) : t.baseIndent + (o ? 0 : t.unit * r);
}
const KY = (t) => t.baseIndent;
function eo({ except: t, units: e = 1 } = {}) {
  return (r) => {
    let n = t && t.test(r.textAfter);
    return r.baseIndent + (n ? 0 : e * r.unit);
  };
}
const eU = 200;
function tU() {
  return Le.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let r = t.newDoc, { head: n } = t.newSelection.main, i = r.lineAt(n);
    if (n > i.from + eU)
      return t;
    let s = r.sliceString(i.from, n);
    if (!e.some((c) => c.test(s)))
      return t;
    let { state: a } = t, o = -1, u = [];
    for (let { head: c } of a.selection.ranges) {
      let h = a.doc.lineAt(c);
      if (h.from == o)
        continue;
      o = h.from;
      let p = _0(a, h.from);
      if (p == null)
        continue;
      let m = /^\s*/.exec(h.text)[0], g = lu(a, p);
      m != g && u.push({ from: h.from, to: h.from + m.length, insert: g });
    }
    return u.length ? [t, { changes: u, sequential: !0 }] : t;
  });
}
const rU = /* @__PURE__ */ me.define(), Wu = /* @__PURE__ */ new $e();
function M0(t) {
  let e = t.firstChild, r = t.lastChild;
  return e && e.to < r.from ? { from: e.to, to: r.type.isError ? t.to : r.from } : null;
}
function nU(t, e, r) {
  let n = bt(t);
  if (n.length < r)
    return null;
  let i = n.resolveStack(r, 1), s = null;
  for (let a = i; a; a = a.next) {
    let o = a.node;
    if (o.to <= r || o.from > r)
      continue;
    if (s && o.from < e)
      break;
    let u = o.type.prop(Wu);
    if (u && (o.to < n.length - 50 || n.length == t.doc.length || !iU(o))) {
      let c = u(o, t);
      c && c.from <= r && c.from >= e && c.to > r && (s = c);
    }
  }
  return s;
}
function iU(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function Wh(t, e, r) {
  for (let n of t.facet(rU)) {
    let i = n(t, e, r);
    if (i)
      return i;
  }
  return nU(t, e, r);
}
function uT(t, e) {
  let r = e.mapPos(t.from, 1), n = e.mapPos(t.to, -1);
  return r >= n ? void 0 : { from: r, to: n };
}
const ud = /* @__PURE__ */ Ae.define({ map: uT }), qu = /* @__PURE__ */ Ae.define({ map: uT });
function cT(t) {
  let e = [];
  for (let { head: r } of t.state.selection.ranges)
    e.some((n) => n.from <= r && n.to >= r) || e.push(t.lineBlockAt(r));
  return e;
}
const oa = /* @__PURE__ */ Rt.define({
  create() {
    return be.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let r of e.effects)
      if (r.is(ud) && !sU(t, r.value.from, r.value.to)) {
        let { preparePlaceholder: n } = e.state.facet(L0), i = n ? be.replace({ widget: new pU(n(e.state, r.value)) }) : Qb;
        t = t.update({ add: [i.range(r.value.from, r.value.to)] });
      } else
        r.is(qu) && (t = t.update({
          filter: (n, i) => r.value.from != n || r.value.to != i,
          filterFrom: r.value.from,
          filterTo: r.value.to
        }));
    if (e.selection) {
      let r = !1, { head: n } = e.selection.main;
      t.between(n, n, (i, s) => {
        i < n && s > n && (r = !0);
      }), r && (t = t.update({
        filterFrom: n,
        filterTo: n,
        filter: (i, s) => s <= n || i >= n
      }));
    }
    return t;
  },
  provide: (t) => ue.decorations.from(t),
  toJSON(t, e) {
    let r = [];
    return t.between(0, e.doc.length, (n, i) => {
      r.push(n, i);
    }), r;
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let r = 0; r < t.length; ) {
      let n = t[r++], i = t[r++];
      if (typeof n != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(Qb.range(n, i));
    }
    return be.set(e, !0);
  }
});
function qh(t, e, r) {
  var n;
  let i = null;
  return (n = t.field(oa, !1)) === null || n === void 0 || n.between(e, r, (s, a) => {
    (!i || i.from > s) && (i = { from: s, to: a });
  }), i;
}
function sU(t, e, r) {
  let n = !1;
  return t.between(e, e, (i, s) => {
    i == e && s == r && (n = !0);
  }), n;
}
function hT(t, e) {
  return t.field(oa, !1) ? e : e.concat(Ae.appendConfig.of(dT()));
}
const aU = (t) => {
  for (let e of cT(t)) {
    let r = Wh(t.state, e.from, e.to);
    if (r)
      return t.dispatch({ effects: hT(t.state, [ud.of(r), pT(t, r)]) }), !0;
  }
  return !1;
}, oU = (t) => {
  if (!t.state.field(oa, !1))
    return !1;
  let e = [];
  for (let r of cT(t)) {
    let n = qh(t.state, r.from, r.to);
    n && e.push(qu.of(n), pT(t, n, !1));
  }
  return e.length && t.dispatch({ effects: e }), e.length > 0;
};
function pT(t, e, r = !0) {
  let n = t.state.doc.lineAt(e.from).number, i = t.state.doc.lineAt(e.to).number;
  return ue.announce.of(`${t.state.phrase(r ? "Folded lines" : "Unfolded lines")} ${n} ${t.state.phrase("to")} ${i}.`);
}
const lU = (t) => {
  let { state: e } = t, r = [];
  for (let n = 0; n < e.doc.length; ) {
    let i = t.lineBlockAt(n), s = Wh(e, i.from, i.to);
    s && r.push(ud.of(s)), n = (s ? t.lineBlockAt(s.to) : i).to + 1;
  }
  return r.length && t.dispatch({ effects: hT(t.state, r) }), !!r.length;
}, uU = (t) => {
  let e = t.state.field(oa, !1);
  if (!e || !e.size)
    return !1;
  let r = [];
  return e.between(0, t.state.doc.length, (n, i) => {
    r.push(qu.of({ from: n, to: i }));
  }), t.dispatch({ effects: r }), !0;
}, cU = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: aU },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: oU },
  { key: "Ctrl-Alt-[", run: lU },
  { key: "Ctrl-Alt-]", run: uU }
], hU = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
}, L0 = /* @__PURE__ */ me.define({
  combine(t) {
    return di(t, hU);
  }
});
function dT(t) {
  let e = [oa, mU];
  return t && e.push(L0.of(t)), e;
}
function fT(t, e) {
  let { state: r } = t, n = r.facet(L0), i = (a) => {
    let o = t.lineBlockAt(t.posAtDOM(a.target)), u = qh(t.state, o.from, o.to);
    u && t.dispatch({ effects: qu.of(u) }), a.preventDefault();
  };
  if (n.placeholderDOM)
    return n.placeholderDOM(t, i, e);
  let s = document.createElement("span");
  return s.textContent = n.placeholderText, s.setAttribute("aria-label", r.phrase("folded code")), s.title = r.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = i, s;
}
const Qb = /* @__PURE__ */ be.replace({ widget: /* @__PURE__ */ new class extends fi {
  toDOM(t) {
    return fT(t, null);
  }
}() });
class pU extends fi {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return fT(e, this.value);
  }
}
const dU = {
  openText: "",
  closedText: "",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Df extends Pi {
  constructor(e, r) {
    super(), this.config = e, this.open = r;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let r = document.createElement("span");
    return r.textContent = this.open ? this.config.openText : this.config.closedText, r.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), r;
  }
}
function fU(t = {}) {
  let e = Object.assign(Object.assign({}, dU), t), r = new Df(e, !0), n = new Df(e, !1), i = wt.fromClass(class {
    constructor(a) {
      this.from = a.viewport.from, this.markers = this.buildMarkers(a);
    }
    update(a) {
      (a.docChanged || a.viewportChanged || a.startState.facet(vs) != a.state.facet(vs) || a.startState.field(oa, !1) != a.state.field(oa, !1) || bt(a.startState) != bt(a.state) || e.foldingChanged(a)) && (this.markers = this.buildMarkers(a.view));
    }
    buildMarkers(a) {
      let o = new ys();
      for (let u of a.viewportLineBlocks) {
        let c = qh(a.state, u.from, u.to) ? n : Wh(a.state, u.from, u.to) ? r : null;
        c && o.add(u.from, u.from, c);
      }
      return o.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    i,
    hY({
      class: "cm-foldGutter",
      markers(a) {
        var o;
        return ((o = a.plugin(i)) === null || o === void 0 ? void 0 : o.markers) || We.empty;
      },
      initialSpacer() {
        return new Df(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, s), { click: (a, o, u) => {
        if (s.click && s.click(a, o, u))
          return !0;
        let c = qh(a.state, o.from, o.to);
        if (c)
          return a.dispatch({ effects: qu.of(c) }), !0;
        let h = Wh(a.state, o.from, o.to);
        return h ? (a.dispatch({ effects: ud.of(h) }), !0) : !1;
      } })
    }),
    dT()
  ];
}
const mU = /* @__PURE__ */ ue.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Xu {
  constructor(e, r) {
    this.specs = e;
    let n;
    function i(o) {
      let u = Os.newName();
      return (n || (n = /* @__PURE__ */ Object.create(null)))["." + u] = o, u;
    }
    const s = typeof r.all == "string" ? r.all : r.all ? i(r.all) : void 0, a = r.scope;
    this.scope = a instanceof $n ? (o) => o.prop(Va) == a.data : a ? (o) => o == a : void 0, this.style = iT(e.map((o) => ({
      tag: o.tag,
      class: o.class || i(Object.assign({}, o, { tag: null }))
    })), {
      all: s
    }).style, this.module = n ? new Os(n) : null, this.themeType = r.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, r) {
    return new Xu(e, r || {});
  }
}
const gg = /* @__PURE__ */ me.define(), mT = /* @__PURE__ */ me.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function vf(t) {
  let e = t.facet(gg);
  return e.length ? e : t.facet(mT);
}
function gT(t, e) {
  let r = [yU], n;
  return t instanceof Xu && (t.module && r.push(ue.styleModule.of(t.module)), n = t.themeType), e != null && e.fallback ? r.push(mT.of(t)) : n ? r.push(gg.computeN([ue.darkTheme], (i) => i.facet(ue.darkTheme) == (n == "dark") ? [t] : [])) : r.push(gg.of(t)), r;
}
class gU {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = bt(e.state), this.decorations = this.buildDeco(e, vf(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let r = bt(e.state), n = vf(e.state), i = n != vf(e.startState), { viewport: s } = e.view, a = e.changes.mapPos(this.decoratedTo, 1);
    r.length < s.to && !i && r.type == this.tree.type && a >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = a) : (r != this.tree || e.viewportChanged || i) && (this.tree = r, this.decorations = this.buildDeco(e.view, n), this.decoratedTo = s.to);
  }
  buildDeco(e, r) {
    if (!r || !this.tree.length)
      return be.none;
    let n = new ys();
    for (let { from: i, to: s } of e.visibleRanges)
      RY(this.tree, r, (a, o, u) => {
        n.add(a, o, this.markCache[u] || (this.markCache[u] = be.mark({ class: u })));
      }, i, s);
    return n.finish();
  }
}
const yU = /* @__PURE__ */ va.high(/* @__PURE__ */ wt.fromClass(gU, {
  decorations: (t) => t.decorations
})), OU = /* @__PURE__ */ Xu.define([
  {
    tag: Q.meta,
    color: "#404740"
  },
  {
    tag: Q.link,
    textDecoration: "underline"
  },
  {
    tag: Q.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: Q.emphasis,
    fontStyle: "italic"
  },
  {
    tag: Q.strong,
    fontWeight: "bold"
  },
  {
    tag: Q.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: Q.keyword,
    color: "#708"
  },
  {
    tag: [Q.atom, Q.bool, Q.url, Q.contentSeparator, Q.labelName],
    color: "#219"
  },
  {
    tag: [Q.literal, Q.inserted],
    color: "#164"
  },
  {
    tag: [Q.string, Q.deleted],
    color: "#a11"
  },
  {
    tag: [Q.regexp, Q.escape, /* @__PURE__ */ Q.special(Q.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ Q.definition(Q.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ Q.local(Q.variableName),
    color: "#30a"
  },
  {
    tag: [Q.typeName, Q.namespace],
    color: "#085"
  },
  {
    tag: Q.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ Q.special(Q.variableName), Q.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ Q.definition(Q.propertyName),
    color: "#00c"
  },
  {
    tag: Q.comment,
    color: "#940"
  },
  {
    tag: Q.invalid,
    color: "#f00"
  }
]), xU = /* @__PURE__ */ ue.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), yT = 1e4, OT = "()[]{}", xT = /* @__PURE__ */ me.define({
  combine(t) {
    return di(t, {
      afterCursor: !0,
      brackets: OT,
      maxScanDistance: yT,
      renderMatch: vU
    });
  }
}), bU = /* @__PURE__ */ be.mark({ class: "cm-matchingBracket" }), DU = /* @__PURE__ */ be.mark({ class: "cm-nonmatchingBracket" });
function vU(t) {
  let e = [], r = t.matched ? bU : DU;
  return e.push(r.range(t.start.from, t.start.to)), t.end && e.push(r.range(t.end.from, t.end.to)), e;
}
const SU = /* @__PURE__ */ Rt.define({
  create() {
    return be.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let r = [], n = e.state.facet(xT);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let s = Kn(e.state, i.head, -1, n) || i.head > 0 && Kn(e.state, i.head - 1, 1, n) || n.afterCursor && (Kn(e.state, i.head, 1, n) || i.head < e.state.doc.length && Kn(e.state, i.head + 1, -1, n));
      s && (r = r.concat(n.renderMatch(s, e.state)));
    }
    return be.set(r, !0);
  },
  provide: (t) => ue.decorations.from(t)
}), wU = [
  SU,
  xU
];
function CU(t = {}) {
  return [xT.of(t), wU];
}
const bT = /* @__PURE__ */ new $e();
function yg(t, e, r) {
  let n = t.prop(e < 0 ? $e.openedBy : $e.closedBy);
  if (n)
    return n;
  if (t.name.length == 1) {
    let i = r.indexOf(t.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [r[i + e]];
  }
  return null;
}
function Og(t) {
  let e = t.type.prop(bT);
  return e ? e(t.node) : t;
}
function Kn(t, e, r, n = {}) {
  let i = n.maxScanDistance || yT, s = n.brackets || OT, a = bt(t), o = a.resolveInner(e, r);
  for (let u = o; u; u = u.parent) {
    let c = yg(u.type, r, s);
    if (c && u.from < u.to) {
      let h = Og(u);
      if (h && (r > 0 ? e >= h.from && e < h.to : e > h.from && e <= h.to))
        return EU(t, e, r, u, h, c, s);
    }
  }
  return AU(t, e, r, a, o.type, i, s);
}
function EU(t, e, r, n, i, s, a) {
  let o = n.parent, u = { from: i.from, to: i.to }, c = 0, h = o == null ? void 0 : o.cursor();
  if (h && (r < 0 ? h.childBefore(n.from) : h.childAfter(n.to)))
    do
      if (r < 0 ? h.to <= n.from : h.from >= n.to) {
        if (c == 0 && s.indexOf(h.type.name) > -1 && h.from < h.to) {
          let p = Og(h);
          return { start: u, end: p ? { from: p.from, to: p.to } : void 0, matched: !0 };
        } else if (yg(h.type, r, a))
          c++;
        else if (yg(h.type, -r, a)) {
          if (c == 0) {
            let p = Og(h);
            return {
              start: u,
              end: p && p.from < p.to ? { from: p.from, to: p.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (r < 0 ? h.prevSibling() : h.nextSibling());
  return { start: u, matched: !1 };
}
function AU(t, e, r, n, i, s, a) {
  let o = r < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), u = a.indexOf(o);
  if (u < 0 || u % 2 == 0 != r > 0)
    return null;
  let c = { from: r < 0 ? e - 1 : e, to: r > 0 ? e + 1 : e }, h = t.doc.iterRange(e, r > 0 ? t.doc.length : 0), p = 0;
  for (let m = 0; !h.next().done && m <= s; ) {
    let g = h.value;
    r < 0 && (m += g.length);
    let O = e + m * r;
    for (let b = r > 0 ? 0 : g.length - 1, D = r > 0 ? g.length : -1; b != D; b += r) {
      let S = a.indexOf(g[b]);
      if (!(S < 0 || n.resolveInner(O + b, 1).type != i))
        if (S % 2 == 0 == r > 0)
          p++;
        else {
          if (p == 1)
            return { start: c, end: { from: O + b, to: O + b + 1 }, matched: S >> 1 == u >> 1 };
          p--;
        }
    }
    r > 0 && (m += g.length);
  }
  return h.done ? { start: c, matched: !1 } : null;
}
const TU = /* @__PURE__ */ Object.create(null), Mb = [xr.none], Lb = [], Rb = /* @__PURE__ */ Object.create(null), kU = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  kU[t] = /* @__PURE__ */ PU(TU, e);
function Sf(t, e) {
  Lb.indexOf(t) > -1 || (Lb.push(t), console.warn(e));
}
function PU(t, e) {
  let r = [];
  for (let o of e.split(" ")) {
    let u = [];
    for (let c of o.split(".")) {
      let h = t[c] || Q[c];
      h ? typeof h == "function" ? u.length ? u = u.map(h) : Sf(c, `Modifier ${c} used at start of tag`) : u.length ? Sf(c, `Tag ${c} used as modifier`) : u = Array.isArray(h) ? h : [h] : Sf(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of u)
      r.push(c);
  }
  if (!r.length)
    return 0;
  let n = e.replace(/ /g, "_"), i = n + " " + r.map((o) => o.id), s = Rb[i];
  if (s)
    return s.id;
  let a = Rb[i] = xr.define({
    id: Mb.length,
    name: n,
    props: [Ru({ [n]: r })]
  });
  return Mb.push(a), a.id;
}
ct.RTL, ct.LTR;
const FU = (t) => {
  let { state: e } = t, r = e.doc.lineAt(e.selection.main.from), n = j0(t.state, r.from);
  return n.line ? $U(t) : n.block ? IU(t) : !1;
};
function R0(t, e) {
  return ({ state: r, dispatch: n }) => {
    if (r.readOnly)
      return !1;
    let i = t(e, r);
    return i ? (n(r.update(i)), !0) : !1;
  };
}
const $U = /* @__PURE__ */ R0(
  QU,
  0
  /* CommentOption.Toggle */
), BU = /* @__PURE__ */ R0(
  DT,
  0
  /* CommentOption.Toggle */
), IU = /* @__PURE__ */ R0(
  (t, e) => DT(t, e, _U(e)),
  0
  /* CommentOption.Toggle */
);
function j0(t, e) {
  let r = t.languageDataAt("commentTokens", e);
  return r.length ? r[0] : {};
}
const al = 50;
function NU(t, { open: e, close: r }, n, i) {
  let s = t.sliceDoc(n - al, n), a = t.sliceDoc(i, i + al), o = /\s*$/.exec(s)[0].length, u = /^\s*/.exec(a)[0].length, c = s.length - o;
  if (s.slice(c - e.length, c) == e && a.slice(u, u + r.length) == r)
    return {
      open: { pos: n - o, margin: o && 1 },
      close: { pos: i + u, margin: u && 1 }
    };
  let h, p;
  i - n <= 2 * al ? h = p = t.sliceDoc(n, i) : (h = t.sliceDoc(n, n + al), p = t.sliceDoc(i - al, i));
  let m = /^\s*/.exec(h)[0].length, g = /\s*$/.exec(p)[0].length, O = p.length - g - r.length;
  return h.slice(m, m + e.length) == e && p.slice(O, O + r.length) == r ? {
    open: {
      pos: n + m + e.length,
      margin: /\s/.test(h.charAt(m + e.length)) ? 1 : 0
    },
    close: {
      pos: i - g - r.length,
      margin: /\s/.test(p.charAt(O - 1)) ? 1 : 0
    }
  } : null;
}
function _U(t) {
  let e = [];
  for (let r of t.selection.ranges) {
    let n = t.doc.lineAt(r.from), i = r.to <= n.to ? n : t.doc.lineAt(r.to), s = e.length - 1;
    s >= 0 && e[s].to > n.from ? e[s].to = i.to : e.push({ from: n.from + /^\s*/.exec(n.text)[0].length, to: i.to });
  }
  return e;
}
function DT(t, e, r = e.selection.ranges) {
  let n = r.map((s) => j0(e, s.from).block);
  if (!n.every((s) => s))
    return null;
  let i = r.map((s, a) => NU(e, n[a], s.from, s.to));
  if (t != 2 && !i.every((s) => s))
    return { changes: e.changes(r.map((s, a) => i[a] ? [] : [{ from: s.from, insert: n[a].open + " " }, { from: s.to, insert: " " + n[a].close }])) };
  if (t != 1 && i.some((s) => s)) {
    let s = [];
    for (let a = 0, o; a < i.length; a++)
      if (o = i[a]) {
        let u = n[a], { open: c, close: h } = o;
        s.push({ from: c.pos - u.open.length, to: c.pos + c.margin }, { from: h.pos - h.margin, to: h.pos + u.close.length });
      }
    return { changes: s };
  }
  return null;
}
function QU(t, e, r = e.selection.ranges) {
  let n = [], i = -1;
  for (let { from: s, to: a } of r) {
    let o = n.length, u = 1e9, c = j0(e, s).line;
    if (c) {
      for (let h = s; h <= a; ) {
        let p = e.doc.lineAt(h);
        if (p.from > i && (s == a || a > p.from)) {
          i = p.from;
          let m = /^\s*/.exec(p.text)[0].length, g = m == p.length, O = p.text.slice(m, m + c.length) == c ? m : -1;
          m < p.text.length && m < u && (u = m), n.push({ line: p, comment: O, token: c, indent: m, empty: g, single: !1 });
        }
        h = p.to + 1;
      }
      if (u < 1e9)
        for (let h = o; h < n.length; h++)
          n[h].indent < n[h].line.text.length && (n[h].indent = u);
      n.length == o + 1 && (n[o].single = !0);
    }
  }
  if (t != 2 && n.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: o, token: u, indent: c, empty: h, single: p } of n)
      (p || !h) && s.push({ from: o.from + c, insert: u + " " });
    let a = e.changes(s);
    return { changes: a, selection: e.selection.map(a, 1) };
  } else if (t != 1 && n.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: a, comment: o, token: u } of n)
      if (o >= 0) {
        let c = a.from + o, h = c + u.length;
        a.text[h - a.from] == " " && h++, s.push({ from: c, to: h });
      }
    return { changes: s };
  }
  return null;
}
const xg = /* @__PURE__ */ pi.define(), MU = /* @__PURE__ */ pi.define(), LU = /* @__PURE__ */ me.define(), vT = /* @__PURE__ */ me.define({
  combine(t) {
    return di(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, r) => r
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, r) => (n, i) => e(n, i) || r(n, i)
    });
  }
}), ST = /* @__PURE__ */ Rt.define({
  create() {
    return ei.empty;
  },
  update(t, e) {
    let r = e.state.facet(vT), n = e.annotation(xg);
    if (n) {
      let u = Er.fromTransaction(e, n.selection), c = n.side, h = c == 0 ? t.undone : t.done;
      return u ? h = Xh(h, h.length, r.minDepth, u) : h = ET(h, e.startState.selection), new ei(c == 0 ? n.rest : h, c == 0 ? h : n.rest);
    }
    let i = e.annotation(MU);
    if ((i == "full" || i == "before") && (t = t.isolate()), e.annotation(Tt.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let s = Er.fromTransaction(e), a = e.annotation(Tt.time), o = e.annotation(Tt.userEvent);
    return s ? t = t.addChanges(s, a, o, r, e) : e.selection && (t = t.addSelection(e.startState.selection, a, o, r.newGroupDelay)), (i == "full" || i == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new ei(t.done.map(Er.fromJSON), t.undone.map(Er.fromJSON));
  }
});
function RU(t = {}) {
  return [
    ST,
    vT.of(t),
    ue.domEventHandlers({
      beforeinput(e, r) {
        let n = e.inputType == "historyUndo" ? wT : e.inputType == "historyRedo" ? bg : null;
        return n ? (e.preventDefault(), n(r)) : !1;
      }
    })
  ];
}
function cd(t, e) {
  return function({ state: r, dispatch: n }) {
    if (!e && r.readOnly)
      return !1;
    let i = r.field(ST, !1);
    if (!i)
      return !1;
    let s = i.pop(t, r, e);
    return s ? (n(s), !0) : !1;
  };
}
const wT = /* @__PURE__ */ cd(0, !1), bg = /* @__PURE__ */ cd(1, !1), jU = /* @__PURE__ */ cd(0, !0), ZU = /* @__PURE__ */ cd(1, !0);
class Er {
  constructor(e, r, n, i, s) {
    this.changes = e, this.effects = r, this.mapped = n, this.startSelection = i, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new Er(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, r, n;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (r = this.mapped) === null || r === void 0 ? void 0 : r.toJSON(),
      startSelection: (n = this.startSelection) === null || n === void 0 ? void 0 : n.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new Er(e.changes && Bt.fromJSON(e.changes), [], e.mapped && ni.fromJSON(e.mapped), e.startSelection && G.fromJSON(e.startSelection), e.selectionsAfter.map(G.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, r) {
    let n = cn;
    for (let i of e.startState.facet(LU)) {
      let s = i(e);
      s.length && (n = n.concat(s));
    }
    return !n.length && e.changes.empty ? null : new Er(e.changes.invert(e.startState.doc), n, void 0, r || e.startState.selection, cn);
  }
  static selection(e) {
    return new Er(void 0, cn, void 0, void 0, e);
  }
}
function Xh(t, e, r, n) {
  let i = e + 1 > r + 20 ? e - r - 1 : 0, s = t.slice(i, e);
  return s.push(n), s;
}
function WU(t, e) {
  let r = [], n = !1;
  return t.iterChangedRanges((i, s) => r.push(i, s)), e.iterChangedRanges((i, s, a, o) => {
    for (let u = 0; u < r.length; ) {
      let c = r[u++], h = r[u++];
      o >= c && a <= h && (n = !0);
    }
  }), n;
}
function qU(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((r, n) => r.empty != e.ranges[n].empty).length === 0;
}
function CT(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const cn = [], XU = 200;
function ET(t, e) {
  if (t.length) {
    let r = t[t.length - 1], n = r.selectionsAfter.slice(Math.max(0, r.selectionsAfter.length - XU));
    return n.length && n[n.length - 1].eq(e) ? t : (n.push(e), Xh(t, t.length - 1, 1e9, r.setSelAfter(n)));
  } else
    return [Er.selection([e])];
}
function VU(t) {
  let e = t[t.length - 1], r = t.slice();
  return r[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), r;
}
function wf(t, e) {
  if (!t.length)
    return t;
  let r = t.length, n = cn;
  for (; r; ) {
    let i = YU(t[r - 1], e, n);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let s = t.slice(0, r);
      return s[r - 1] = i, s;
    } else
      e = i.mapped, r--, n = i.selectionsAfter;
  }
  return n.length ? [Er.selection(n)] : cn;
}
function YU(t, e, r) {
  let n = CT(t.selectionsAfter.length ? t.selectionsAfter.map((o) => o.map(e)) : cn, r);
  if (!t.changes)
    return Er.selection(n);
  let i = t.changes.map(e), s = e.mapDesc(t.changes, !0), a = t.mapped ? t.mapped.composeDesc(s) : s;
  return new Er(i, Ae.mapEffects(t.effects, e), a, t.startSelection.map(s), n);
}
const UU = /^(input\.type|delete)($|\.)/;
class ei {
  constructor(e, r, n = 0, i = void 0) {
    this.done = e, this.undone = r, this.prevTime = n, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new ei(this.done, this.undone) : this;
  }
  addChanges(e, r, n, i, s) {
    let a = this.done, o = a[a.length - 1];
    return o && o.changes && !o.changes.empty && e.changes && (!n || UU.test(n)) && (!o.selectionsAfter.length && r - this.prevTime < i.newGroupDelay && i.joinToEvent(s, WU(o.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    n == "input.type.compose") ? a = Xh(a, a.length - 1, i.minDepth, new Er(e.changes.compose(o.changes), CT(e.effects, o.effects), o.mapped, o.startSelection, cn)) : a = Xh(a, a.length, i.minDepth, e), new ei(a, cn, r, n);
  }
  addSelection(e, r, n, i) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : cn;
    return s.length > 0 && r - this.prevTime < i && n == this.prevUserEvent && n && /^select($|\.)/.test(n) && qU(s[s.length - 1], e) ? this : new ei(ET(this.done, e), this.undone, r, n);
  }
  addMapping(e) {
    return new ei(wf(this.done, e), wf(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, r, n) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let s = i[i.length - 1], a = s.selectionsAfter[0] || r.selection;
    if (n && s.selectionsAfter.length)
      return r.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: xg.of({ side: e, rest: VU(i), selection: a }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let o = i.length == 1 ? cn : i.slice(0, i.length - 1);
      return s.mapped && (o = wf(o, s.mapped)), r.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: xg.of({ side: e, rest: o, selection: a }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
ei.empty = /* @__PURE__ */ new ei(cn, cn);
const zU = [
  { key: "Mod-z", run: wT, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: bg, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: bg, preventDefault: !0 },
  { key: "Mod-u", run: jU, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: ZU, preventDefault: !0 }
];
function Mo(t, e) {
  return G.create(t.ranges.map(e), t.mainIndex);
}
function mi(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Ln({ state: t, dispatch: e }, r) {
  let n = Mo(t.selection, r);
  return n.eq(t.selection, !0) ? !1 : (e(mi(t, n)), !0);
}
function hd(t, e) {
  return G.cursor(e ? t.to : t.from);
}
function AT(t, e) {
  return Ln(t, (r) => r.empty ? t.moveByChar(r, e) : hd(r, e));
}
function hr(t) {
  return t.textDirectionAt(t.state.selection.main.head) == ct.LTR;
}
const TT = (t) => AT(t, !hr(t)), kT = (t) => AT(t, hr(t));
function PT(t, e) {
  return Ln(t, (r) => r.empty ? t.moveByGroup(r, e) : hd(r, e));
}
const GU = (t) => PT(t, !hr(t)), HU = (t) => PT(t, hr(t));
function JU(t, e, r) {
  if (e.type.prop(r))
    return !0;
  let n = e.to - e.from;
  return n && (n > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function pd(t, e, r) {
  let n = bt(t).resolveInner(e.head), i = r ? $e.closedBy : $e.openedBy;
  for (let u = e.head; ; ) {
    let c = r ? n.childAfter(u) : n.childBefore(u);
    if (!c)
      break;
    JU(t, c, i) ? n = c : u = r ? c.to : c.from;
  }
  let s = n.type.prop(i), a, o;
  return s && (a = r ? Kn(t, n.from, 1) : Kn(t, n.to, -1)) && a.matched ? o = r ? a.end.to : a.end.from : o = r ? n.to : n.from, G.cursor(o, r ? -1 : 1);
}
const KU = (t) => Ln(t, (e) => pd(t.state, e, !hr(t))), ez = (t) => Ln(t, (e) => pd(t.state, e, hr(t)));
function FT(t, e) {
  return Ln(t, (r) => {
    if (!r.empty)
      return hd(r, e);
    let n = t.moveVertically(r, e);
    return n.head != r.head ? n : t.moveToLineBoundary(r, e);
  });
}
const $T = (t) => FT(t, !1), BT = (t) => FT(t, !0);
function IT(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, r = 0, n = 0, i;
  if (e) {
    for (let s of t.state.facet(ue.scrollMargins)) {
      let a = s(t);
      a != null && a.top && (r = Math.max(a == null ? void 0 : a.top, r)), a != null && a.bottom && (n = Math.max(a == null ? void 0 : a.bottom, n));
    }
    i = t.scrollDOM.clientHeight - r - n;
  } else
    i = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: r,
    marginBottom: n,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, i - 5)
  };
}
function NT(t, e) {
  let r = IT(t), { state: n } = t, i = Mo(n.selection, (a) => a.empty ? t.moveVertically(a, e, r.height) : hd(a, e));
  if (i.eq(n.selection))
    return !1;
  let s;
  if (r.selfScroll) {
    let a = t.coordsAtPos(n.selection.main.head), o = t.scrollDOM.getBoundingClientRect(), u = o.top + r.marginTop, c = o.bottom - r.marginBottom;
    a && a.top > u && a.bottom < c && (s = ue.scrollIntoView(i.main.head, { y: "start", yMargin: a.top - u }));
  }
  return t.dispatch(mi(n, i), { effects: s }), !0;
}
const jb = (t) => NT(t, !1), Dg = (t) => NT(t, !0);
function ks(t, e, r) {
  let n = t.lineBlockAt(e.head), i = t.moveToLineBoundary(e, r);
  if (i.head == e.head && i.head != (r ? n.to : n.from) && (i = t.moveToLineBoundary(e, r, !1)), !r && i.head == n.from && n.length) {
    let s = /^\s*/.exec(t.state.sliceDoc(n.from, Math.min(n.from + 100, n.to)))[0].length;
    s && e.head != n.from + s && (i = G.cursor(n.from + s));
  }
  return i;
}
const tz = (t) => Ln(t, (e) => ks(t, e, !0)), rz = (t) => Ln(t, (e) => ks(t, e, !1)), nz = (t) => Ln(t, (e) => ks(t, e, !hr(t))), iz = (t) => Ln(t, (e) => ks(t, e, hr(t))), sz = (t) => Ln(t, (e) => G.cursor(t.lineBlockAt(e.head).from, 1)), az = (t) => Ln(t, (e) => G.cursor(t.lineBlockAt(e.head).to, -1));
function oz(t, e, r) {
  let n = !1, i = Mo(t.selection, (s) => {
    let a = Kn(t, s.head, -1) || Kn(t, s.head, 1) || s.head > 0 && Kn(t, s.head - 1, 1) || s.head < t.doc.length && Kn(t, s.head + 1, -1);
    if (!a || !a.end)
      return s;
    n = !0;
    let o = a.start.from == s.head ? a.end.to : a.end.from;
    return r ? G.range(s.anchor, o) : G.cursor(o);
  });
  return n ? (e(mi(t, i)), !0) : !1;
}
const lz = ({ state: t, dispatch: e }) => oz(t, e, !1);
function bn(t, e) {
  let r = Mo(t.state.selection, (n) => {
    let i = e(n);
    return G.range(n.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return r.eq(t.state.selection) ? !1 : (t.dispatch(mi(t.state, r)), !0);
}
function _T(t, e) {
  return bn(t, (r) => t.moveByChar(r, e));
}
const QT = (t) => _T(t, !hr(t)), MT = (t) => _T(t, hr(t));
function LT(t, e) {
  return bn(t, (r) => t.moveByGroup(r, e));
}
const uz = (t) => LT(t, !hr(t)), cz = (t) => LT(t, hr(t)), hz = (t) => bn(t, (e) => pd(t.state, e, !hr(t))), pz = (t) => bn(t, (e) => pd(t.state, e, hr(t)));
function RT(t, e) {
  return bn(t, (r) => t.moveVertically(r, e));
}
const jT = (t) => RT(t, !1), ZT = (t) => RT(t, !0);
function WT(t, e) {
  return bn(t, (r) => t.moveVertically(r, e, IT(t).height));
}
const Zb = (t) => WT(t, !1), Wb = (t) => WT(t, !0), dz = (t) => bn(t, (e) => ks(t, e, !0)), fz = (t) => bn(t, (e) => ks(t, e, !1)), mz = (t) => bn(t, (e) => ks(t, e, !hr(t))), gz = (t) => bn(t, (e) => ks(t, e, hr(t))), yz = (t) => bn(t, (e) => G.cursor(t.lineBlockAt(e.head).from)), Oz = (t) => bn(t, (e) => G.cursor(t.lineBlockAt(e.head).to)), qb = ({ state: t, dispatch: e }) => (e(mi(t, { anchor: 0 })), !0), Xb = ({ state: t, dispatch: e }) => (e(mi(t, { anchor: t.doc.length })), !0), Vb = ({ state: t, dispatch: e }) => (e(mi(t, { anchor: t.selection.main.anchor, head: 0 })), !0), Yb = ({ state: t, dispatch: e }) => (e(mi(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), xz = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), bz = ({ state: t, dispatch: e }) => {
  let r = dd(t).map(({ from: n, to: i }) => G.range(n, Math.min(i + 1, t.doc.length)));
  return e(t.update({ selection: G.create(r), userEvent: "select" })), !0;
}, Dz = ({ state: t, dispatch: e }) => {
  let r = Mo(t.selection, (n) => {
    var i;
    let s = bt(t).resolveStack(n.from, 1);
    for (let a = s; a; a = a.next) {
      let { node: o } = a;
      if ((o.from < n.from && o.to >= n.to || o.to > n.to && o.from <= n.from) && (!((i = o.parent) === null || i === void 0) && i.parent))
        return G.range(o.to, o.from);
    }
    return n;
  });
  return e(mi(t, r)), !0;
}, vz = ({ state: t, dispatch: e }) => {
  let r = t.selection, n = null;
  return r.ranges.length > 1 ? n = G.create([r.main]) : r.main.empty || (n = G.create([G.cursor(r.main.head)])), n ? (e(mi(t, n)), !0) : !1;
};
function Vu(t, e) {
  if (t.state.readOnly)
    return !1;
  let r = "delete.selection", { state: n } = t, i = n.changeByRange((s) => {
    let { from: a, to: o } = s;
    if (a == o) {
      let u = e(s);
      u < a ? (r = "delete.backward", u = Lc(t, u, !1)) : u > a && (r = "delete.forward", u = Lc(t, u, !0)), a = Math.min(a, u), o = Math.max(o, u);
    } else
      a = Lc(t, a, !1), o = Lc(t, o, !0);
    return a == o ? { range: s } : { changes: { from: a, to: o }, range: G.cursor(a, a < s.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (t.dispatch(n.update(i, {
    scrollIntoView: !0,
    userEvent: r,
    effects: r == "delete.selection" ? ue.announce.of(n.phrase("Selection deleted")) : void 0
  })), !0);
}
function Lc(t, e, r) {
  if (t instanceof ue)
    for (let n of t.state.facet(ue.atomicRanges).map((i) => i(t)))
      n.between(e, e, (i, s) => {
        i < e && s > e && (e = r ? s : i);
      });
  return e;
}
const qT = (t, e) => Vu(t, (r) => {
  let n = r.from, { state: i } = t, s = i.doc.lineAt(n), a, o;
  if (!e && n > s.from && n < s.from + 200 && !/[^ \t]/.test(a = s.text.slice(0, n - s.from))) {
    if (a[a.length - 1] == "	")
      return n - 1;
    let u = Qo(a, i.tabSize), c = u % Zh(i) || Zh(i);
    for (let h = 0; h < c && a[a.length - 1 - h] == " "; h++)
      n--;
    o = n;
  } else
    o = Ut(s.text, n - s.from, e, e) + s.from, o == n && s.number != (e ? i.doc.lines : 1) ? o += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(o - s.from, n - s.from)) && (o = Ut(s.text, o - s.from, !1, !1) + s.from);
  return o;
}), vg = (t) => qT(t, !1), XT = (t) => qT(t, !0), VT = (t, e) => Vu(t, (r) => {
  let n = r.head, { state: i } = t, s = i.doc.lineAt(n), a = i.charCategorizer(n);
  for (let o = null; ; ) {
    if (n == (e ? s.to : s.from)) {
      n == r.head && s.number != (e ? i.doc.lines : 1) && (n += e ? 1 : -1);
      break;
    }
    let u = Ut(s.text, n - s.from, e) + s.from, c = s.text.slice(Math.min(n, u) - s.from, Math.max(n, u) - s.from), h = a(c);
    if (o != null && h != o)
      break;
    (c != " " || n != r.head) && (o = h), n = u;
  }
  return n;
}), YT = (t) => VT(t, !1), Sz = (t) => VT(t, !0), wz = (t) => Vu(t, (e) => {
  let r = t.lineBlockAt(e.head).to;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), Cz = (t) => Vu(t, (e) => {
  let r = t.moveToLineBoundary(e, !1).head;
  return e.head > r ? r : Math.max(0, e.head - 1);
}), Ez = (t) => Vu(t, (e) => {
  let r = t.moveToLineBoundary(e, !0).head;
  return e.head < r ? r : Math.min(t.state.doc.length, e.head + 1);
}), Az = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((n) => ({
    changes: { from: n.from, to: n.to, insert: Xe.of(["", ""]) },
    range: G.cursor(n.from)
  }));
  return e(t.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
}, Tz = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = t.changeByRange((n) => {
    if (!n.empty || n.from == 0 || n.from == t.doc.length)
      return { range: n };
    let i = n.from, s = t.doc.lineAt(i), a = i == s.from ? i - 1 : Ut(s.text, i - s.from, !1) + s.from, o = i == s.to ? i + 1 : Ut(s.text, i - s.from, !0) + s.from;
    return {
      changes: { from: a, to: o, insert: t.doc.slice(i, o).append(t.doc.slice(a, i)) },
      range: G.cursor(o)
    };
  });
  return r.changes.empty ? !1 : (e(t.update(r, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function dd(t) {
  let e = [], r = -1;
  for (let n of t.selection.ranges) {
    let i = t.doc.lineAt(n.from), s = t.doc.lineAt(n.to);
    if (!n.empty && n.to == s.from && (s = t.doc.lineAt(n.to - 1)), r >= i.number) {
      let a = e[e.length - 1];
      a.to = s.to, a.ranges.push(n);
    } else
      e.push({ from: i.from, to: s.to, ranges: [n] });
    r = s.number + 1;
  }
  return e;
}
function UT(t, e, r) {
  if (t.readOnly)
    return !1;
  let n = [], i = [];
  for (let s of dd(t)) {
    if (r ? s.to == t.doc.length : s.from == 0)
      continue;
    let a = t.doc.lineAt(r ? s.to + 1 : s.from - 1), o = a.length + 1;
    if (r) {
      n.push({ from: s.to, to: a.to }, { from: s.from, insert: a.text + t.lineBreak });
      for (let u of s.ranges)
        i.push(G.range(Math.min(t.doc.length, u.anchor + o), Math.min(t.doc.length, u.head + o)));
    } else {
      n.push({ from: a.from, to: s.from }, { from: s.to, insert: t.lineBreak + a.text });
      for (let u of s.ranges)
        i.push(G.range(u.anchor - o, u.head - o));
    }
  }
  return n.length ? (e(t.update({
    changes: n,
    scrollIntoView: !0,
    selection: G.create(i, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const kz = ({ state: t, dispatch: e }) => UT(t, e, !1), Pz = ({ state: t, dispatch: e }) => UT(t, e, !0);
function zT(t, e, r) {
  if (t.readOnly)
    return !1;
  let n = [];
  for (let i of dd(t))
    r ? n.push({ from: i.from, insert: t.doc.slice(i.from, i.to) + t.lineBreak }) : n.push({ from: i.to, insert: t.lineBreak + t.doc.slice(i.from, i.to) });
  return e(t.update({ changes: n, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const Fz = ({ state: t, dispatch: e }) => zT(t, e, !1), $z = ({ state: t, dispatch: e }) => zT(t, e, !0), Bz = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, r = e.changes(dd(e).map(({ from: i, to: s }) => (i > 0 ? i-- : s < e.doc.length && s++, { from: i, to: s }))), n = Mo(e.selection, (i) => t.moveVertically(i, !0)).map(r);
  return t.dispatch({ changes: r, selection: n, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function Iz(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let r = bt(t).resolveInner(e), n = r.childBefore(e), i = r.childAfter(e), s;
  return n && i && n.to <= e && i.from >= e && (s = n.type.prop($e.closedBy)) && s.indexOf(i.name) > -1 && t.doc.lineAt(n.to).from == t.doc.lineAt(i.from).from && !/\S/.test(t.sliceDoc(n.to, i.from)) ? { from: n.to, to: i.from } : null;
}
const Nz = /* @__PURE__ */ GT(!1), _z = /* @__PURE__ */ GT(!0);
function GT(t) {
  return ({ state: e, dispatch: r }) => {
    if (e.readOnly)
      return !1;
    let n = e.changeByRange((i) => {
      let { from: s, to: a } = i, o = e.doc.lineAt(s), u = !t && s == a && Iz(e, s);
      t && (s = a = (a <= o.to ? o : e.doc.lineAt(a)).to);
      let c = new ld(e, { simulateBreak: s, simulateDoubleBreak: !!u }), h = _0(c, s);
      for (h == null && (h = Qo(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); a < o.to && /\s/.test(o.text[a - o.from]); )
        a++;
      u ? { from: s, to: a } = u : s > o.from && s < o.from + 100 && !/\S/.test(o.text.slice(0, s)) && (s = o.from);
      let p = ["", lu(e, h)];
      return u && p.push(lu(e, c.lineIndent(o.from, -1))), {
        changes: { from: s, to: a, insert: Xe.of(p) },
        range: G.cursor(s + 1 + p[1].length)
      };
    });
    return r(e.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Z0(t, e) {
  let r = -1;
  return t.changeByRange((n) => {
    let i = [];
    for (let a = n.from; a <= n.to; ) {
      let o = t.doc.lineAt(a);
      o.number > r && (n.empty || n.to > o.from) && (e(o, i, n), r = o.number), a = o.to + 1;
    }
    let s = t.changes(i);
    return {
      changes: i,
      range: G.range(s.mapPos(n.anchor, 1), s.mapPos(n.head, 1))
    };
  });
}
const Qz = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = /* @__PURE__ */ Object.create(null), n = new ld(t, { overrideIndentation: (s) => {
    let a = r[s];
    return a ?? -1;
  } }), i = Z0(t, (s, a, o) => {
    let u = _0(n, s.from);
    if (u == null)
      return;
    /\S/.test(s.text) || (u = 0);
    let c = /^\s*/.exec(s.text)[0], h = lu(t, u);
    (c != h || o.from < s.from + c.length) && (r[s.from] = u, a.push({ from: s.from, to: s.from + c.length, insert: h }));
  });
  return i.changes.empty || e(t.update(i, { userEvent: "indent" })), !0;
}, HT = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Z0(t, (r, n) => {
  n.push({ from: r.from, insert: t.facet(ju) });
}), { userEvent: "input.indent" })), !0), JT = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Z0(t, (r, n) => {
  let i = /^\s*/.exec(r.text)[0];
  if (!i)
    return;
  let s = Qo(i, t.tabSize), a = 0, o = lu(t, Math.max(0, s - Zh(t)));
  for (; a < i.length && a < o.length && i.charCodeAt(a) == o.charCodeAt(a); )
    a++;
  n.push({ from: r.from + a, to: r.from + i.length, insert: o.slice(a) });
}), { userEvent: "delete.dedent" })), !0), Mz = [
  { key: "Ctrl-b", run: TT, shift: QT, preventDefault: !0 },
  { key: "Ctrl-f", run: kT, shift: MT },
  { key: "Ctrl-p", run: $T, shift: jT },
  { key: "Ctrl-n", run: BT, shift: ZT },
  { key: "Ctrl-a", run: sz, shift: yz },
  { key: "Ctrl-e", run: az, shift: Oz },
  { key: "Ctrl-d", run: XT },
  { key: "Ctrl-h", run: vg },
  { key: "Ctrl-k", run: wz },
  { key: "Ctrl-Alt-h", run: YT },
  { key: "Ctrl-o", run: Az },
  { key: "Ctrl-t", run: Tz },
  { key: "Ctrl-v", run: Dg }
], Lz = /* @__PURE__ */ [
  { key: "ArrowLeft", run: TT, shift: QT, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: GU, shift: uz, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: nz, shift: mz, preventDefault: !0 },
  { key: "ArrowRight", run: kT, shift: MT, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: HU, shift: cz, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: iz, shift: gz, preventDefault: !0 },
  { key: "ArrowUp", run: $T, shift: jT, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: qb, shift: Vb },
  { mac: "Ctrl-ArrowUp", run: jb, shift: Zb },
  { key: "ArrowDown", run: BT, shift: ZT, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: Xb, shift: Yb },
  { mac: "Ctrl-ArrowDown", run: Dg, shift: Wb },
  { key: "PageUp", run: jb, shift: Zb },
  { key: "PageDown", run: Dg, shift: Wb },
  { key: "Home", run: rz, shift: fz, preventDefault: !0 },
  { key: "Mod-Home", run: qb, shift: Vb },
  { key: "End", run: tz, shift: dz, preventDefault: !0 },
  { key: "Mod-End", run: Xb, shift: Yb },
  { key: "Enter", run: Nz },
  { key: "Mod-a", run: xz },
  { key: "Backspace", run: vg, shift: vg },
  { key: "Delete", run: XT },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: YT },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Sz },
  { mac: "Mod-Backspace", run: Cz },
  { mac: "Mod-Delete", run: Ez }
].concat(/* @__PURE__ */ Mz.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), Rz = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: KU, shift: hz },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: ez, shift: pz },
  { key: "Alt-ArrowUp", run: kz },
  { key: "Shift-Alt-ArrowUp", run: Fz },
  { key: "Alt-ArrowDown", run: Pz },
  { key: "Shift-Alt-ArrowDown", run: $z },
  { key: "Escape", run: vz },
  { key: "Mod-Enter", run: _z },
  { key: "Alt-l", mac: "Ctrl-l", run: bz },
  { key: "Mod-i", run: Dz, preventDefault: !0 },
  { key: "Mod-[", run: JT },
  { key: "Mod-]", run: HT },
  { key: "Mod-Alt-\\", run: Qz },
  { key: "Shift-Mod-k", run: Bz },
  { key: "Shift-Mod-\\", run: lz },
  { key: "Mod-/", run: FU },
  { key: "Alt-A", run: BU }
].concat(Lz), jz = { key: "Tab", run: HT, shift: JT };
function at() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, r = arguments[1];
  if (r && typeof r == "object" && r.nodeType == null && !Array.isArray(r)) {
    for (var n in r)
      if (Object.prototype.hasOwnProperty.call(r, n)) {
        var i = r[n];
        typeof i == "string" ? t.setAttribute(n, i) : i != null && (t[n] = i);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    KT(t, arguments[e]);
  return t;
}
function KT(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      t.appendChild(e);
    else if (Array.isArray(e))
      for (var r = 0; r < e.length; r++)
        KT(t, e[r]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const Ub = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class go {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, r, n = 0, i = e.length, s, a) {
    this.test = a, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(n, i), this.bufferStart = n, this.normalize = s ? (o) => s(Ub(o)) : Ub, this.query = this.normalize(r);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Wt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let r = x0(e), n = this.bufferStart + this.bufferPos;
      this.bufferPos += ln(e);
      let i = this.normalize(r);
      for (let s = 0, a = n; ; s++) {
        let o = i.charCodeAt(s), u = this.match(o, a, this.bufferPos + this.bufferStart);
        if (s == i.length - 1) {
          if (u)
            return this.value = u, this;
          break;
        }
        a == n && s < r.length && r.charCodeAt(s) == o && a++;
      }
    }
  }
  match(e, r, n) {
    let i = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let a = this.matches[s], o = !1;
      this.query.charCodeAt(a) == e && (a == this.query.length - 1 ? i = { from: this.matches[s + 1], to: n } : (this.matches[s]++, o = !0)), o || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: r, to: n } : this.matches.push(1, r)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (go.prototype[Symbol.iterator] = function() {
  return this;
});
const ek = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, W0 = "gm" + (/x/.unicode == null ? "" : "u");
class tk {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, r, n, i = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = ek, /\\[sWDnr]|\n|\r|\[\^/.test(r))
      return new rk(e, r, n, i, s);
    this.re = new RegExp(r, W0 + (n != null && n.ignoreCase ? "i" : "")), this.test = n == null ? void 0 : n.test, this.iter = e.iter();
    let a = e.lineAt(i);
    this.curLineStart = a.from, this.matchPos = Vh(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let r = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (r) {
        let n = this.curLineStart + r.index, i = n + r[0].length;
        if (this.matchPos = Vh(this.text, i + (n == i ? 1 : 0)), n == this.curLineStart + this.curLine.length && this.nextLine(), (n < i || n > this.value.to) && (!this.test || this.test(n, i, r)))
          return this.value = { from: n, to: i, match: r }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Cf = /* @__PURE__ */ new WeakMap();
class to {
  constructor(e, r) {
    this.from = e, this.text = r;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, r, n) {
    let i = Cf.get(e);
    if (!i || i.from >= n || i.to <= r) {
      let o = new to(r, e.sliceString(r, n));
      return Cf.set(e, o), o;
    }
    if (i.from == r && i.to == n)
      return i;
    let { text: s, from: a } = i;
    return a > r && (s = e.sliceString(r, a) + s, a = r), i.to < n && (s += e.sliceString(i.to, n)), Cf.set(e, new to(a, s)), new to(r, s.slice(r - a, n - a));
  }
}
class rk {
  constructor(e, r, n, i, s) {
    this.text = e, this.to = s, this.done = !1, this.value = ek, this.matchPos = Vh(e, i), this.re = new RegExp(r, W0 + (n != null && n.ignoreCase ? "i" : "")), this.test = n == null ? void 0 : n.test, this.flat = to.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, r = this.re.exec(this.flat.text);
      if (r && !r[0] && r.index == e && (this.re.lastIndex = e + 1, r = this.re.exec(this.flat.text)), r) {
        let n = this.flat.from + r.index, i = n + r[0].length;
        if ((this.flat.to >= this.to || r.index + r[0].length <= this.flat.text.length - 10) && (!this.test || this.test(n, i, r)))
          return this.value = { from: n, to: i, match: r }, this.matchPos = Vh(this.text, i + (n == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = to.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (tk.prototype[Symbol.iterator] = rk.prototype[Symbol.iterator] = function() {
  return this;
});
function Zz(t) {
  try {
    return new RegExp(t, W0), !0;
  } catch {
    return !1;
  }
}
function Vh(t, e) {
  if (e >= t.length)
    return e;
  let r = t.lineAt(e), n;
  for (; e < r.to && (n = r.text.charCodeAt(e - r.from)) >= 56320 && n < 57344; )
    e++;
  return e;
}
function Sg(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), r = at("input", { class: "cm-textfield", name: "line", value: e }), n = at("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), t.dispatch({ effects: Yh.of(!1) }), t.focus()) : s.keyCode == 13 && (s.preventDefault(), i());
    },
    onsubmit: (s) => {
      s.preventDefault(), i();
    }
  }, at("label", t.state.phrase("Go to line"), ": ", r), " ", at("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")));
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(r.value);
    if (!s)
      return;
    let { state: a } = t, o = a.doc.lineAt(a.selection.main.head), [, u, c, h, p] = s, m = h ? +h.slice(1) : 0, g = c ? +c : o.number;
    if (c && p) {
      let D = g / 100;
      u && (D = D * (u == "-" ? -1 : 1) + o.number / a.doc.lines), g = Math.round(a.doc.lines * D);
    } else
      c && u && (g = g * (u == "-" ? -1 : 1) + o.number);
    let O = a.doc.line(Math.max(1, Math.min(a.doc.lines, g))), b = G.cursor(O.from + Math.max(0, Math.min(m, O.length)));
    t.dispatch({
      effects: [Yh.of(!1), ue.scrollIntoView(b.from, { y: "center" })],
      selection: b
    }), t.focus();
  }
  return { dom: n };
}
const Yh = /* @__PURE__ */ Ae.define(), zb = /* @__PURE__ */ Rt.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(Yh) && (t = r.value);
    return t;
  },
  provide: (t) => su.from(t, (e) => e ? Sg : null)
}), Wz = (t) => {
  let e = iu(t, Sg);
  if (!e) {
    let r = [Yh.of(!0)];
    t.state.field(zb, !1) == null && r.push(Ae.appendConfig.of([zb, qz])), t.dispatch({ effects: r }), e = iu(t, Sg);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, qz = /* @__PURE__ */ ue.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), Xz = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, nk = /* @__PURE__ */ me.define({
  combine(t) {
    return di(t, Xz, {
      highlightWordAroundCursor: (e, r) => e || r,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function Vz(t) {
  let e = [Hz, Gz];
  return t && e.push(nk.of(t)), e;
}
const Yz = /* @__PURE__ */ be.mark({ class: "cm-selectionMatch" }), Uz = /* @__PURE__ */ be.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function Gb(t, e, r, n) {
  return (r == 0 || t(e.sliceDoc(r - 1, r)) != dt.Word) && (n == e.doc.length || t(e.sliceDoc(n, n + 1)) != dt.Word);
}
function zz(t, e, r, n) {
  return t(e.sliceDoc(r, r + 1)) == dt.Word && t(e.sliceDoc(n - 1, n)) == dt.Word;
}
const Gz = /* @__PURE__ */ wt.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(nk), { state: r } = t, n = r.selection;
    if (n.ranges.length > 1)
      return be.none;
    let i = n.main, s, a = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return be.none;
      let u = r.wordAt(i.head);
      if (!u)
        return be.none;
      a = r.charCategorizer(i.head), s = r.sliceDoc(u.from, u.to);
    } else {
      let u = i.to - i.from;
      if (u < e.minSelectionLength || u > 200)
        return be.none;
      if (e.wholeWords) {
        if (s = r.sliceDoc(i.from, i.to), a = r.charCategorizer(i.head), !(Gb(a, r, i.from, i.to) && zz(a, r, i.from, i.to)))
          return be.none;
      } else if (s = r.sliceDoc(i.from, i.to), !s)
        return be.none;
    }
    let o = [];
    for (let u of t.visibleRanges) {
      let c = new go(r.doc, s, u.from, u.to);
      for (; !c.next().done; ) {
        let { from: h, to: p } = c.value;
        if ((!a || Gb(a, r, h, p)) && (i.empty && h <= i.from && p >= i.to ? o.push(Uz.range(h, p)) : (h >= i.to || p <= i.from) && o.push(Yz.range(h, p)), o.length > e.maxMatches))
          return be.none;
      }
    }
    return be.set(o);
  }
}, {
  decorations: (t) => t.decorations
}), Hz = /* @__PURE__ */ ue.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), Jz = ({ state: t, dispatch: e }) => {
  let { selection: r } = t, n = G.create(r.ranges.map((i) => t.wordAt(i.head) || G.cursor(i.head)), r.mainIndex);
  return n.eq(r) ? !1 : (e(t.update({ selection: n })), !0);
};
function Kz(t, e) {
  let { main: r, ranges: n } = t.selection, i = t.wordAt(r.head), s = i && i.from == r.from && i.to == r.to;
  for (let a = !1, o = new go(t.doc, e, n[n.length - 1].to); ; )
    if (o.next(), o.done) {
      if (a)
        return null;
      o = new go(t.doc, e, 0, Math.max(0, n[n.length - 1].from - 1)), a = !0;
    } else {
      if (a && n.some((u) => u.from == o.value.from))
        continue;
      if (s) {
        let u = t.wordAt(o.value.from);
        if (!u || u.from != o.value.from || u.to != o.value.to)
          continue;
      }
      return o.value;
    }
}
const eG = ({ state: t, dispatch: e }) => {
  let { ranges: r } = t.selection;
  if (r.some((s) => s.from === s.to))
    return Jz({ state: t, dispatch: e });
  let n = t.sliceDoc(r[0].from, r[0].to);
  if (t.selection.ranges.some((s) => t.sliceDoc(s.from, s.to) != n))
    return !1;
  let i = Kz(t, n);
  return i ? (e(t.update({
    selection: t.selection.addRange(G.range(i.from, i.to), !1),
    effects: ue.scrollIntoView(i.to)
  })), !0) : !1;
}, Lo = /* @__PURE__ */ me.define({
  combine(t) {
    return di(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new pG(e),
      scrollToMatch: (e) => ue.scrollIntoView(e)
    });
  }
});
class ik {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || Zz(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (r, n) => n == "n" ? `
` : n == "r" ? "\r" : n == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new iG(this) : new rG(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, r = 0, n) {
    let i = e.doc ? e : Le.create({ doc: e });
    return n == null && (n = i.doc.length), this.regexp ? Ra(this, i, r, n) : La(this, i, r, n);
  }
}
class sk {
  constructor(e) {
    this.spec = e;
  }
}
function La(t, e, r, n) {
  return new go(e.doc, t.unquoted, r, n, t.caseSensitive ? void 0 : (i) => i.toLowerCase(), t.wholeWord ? tG(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function tG(t, e) {
  return (r, n, i, s) => ((s > r || s + i.length < n) && (s = Math.max(0, r - 2), i = t.sliceString(s, Math.min(t.length, n + 2))), (e(Uh(i, r - s)) != dt.Word || e(zh(i, r - s)) != dt.Word) && (e(zh(i, n - s)) != dt.Word || e(Uh(i, n - s)) != dt.Word));
}
class rG extends sk {
  constructor(e) {
    super(e);
  }
  nextMatch(e, r, n) {
    let i = La(this.spec, e, n, e.doc.length).nextOverlapping();
    return i.done && (i = La(this.spec, e, 0, r).nextOverlapping()), i.done ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, r, n) {
    for (let i = n; ; ) {
      let s = Math.max(r, i - 1e4 - this.spec.unquoted.length), a = La(this.spec, e, s, i), o = null;
      for (; !a.nextOverlapping().done; )
        o = a.value;
      if (o)
        return o;
      if (s == r)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, r, n) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, r) {
    let n = La(this.spec, e, 0, e.doc.length), i = [];
    for (; !n.next().done; ) {
      if (i.length >= r)
        return null;
      i.push(n.value);
    }
    return i;
  }
  highlight(e, r, n, i) {
    let s = La(this.spec, e, Math.max(0, r - this.spec.unquoted.length), Math.min(n + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
function Ra(t, e, r, n) {
  return new tk(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? nG(e.charCategorizer(e.selection.main.head)) : void 0
  }, r, n);
}
function Uh(t, e) {
  return t.slice(Ut(t, e, !1), e);
}
function zh(t, e) {
  return t.slice(e, Ut(t, e));
}
function nG(t) {
  return (e, r, n) => !n[0].length || (t(Uh(n.input, n.index)) != dt.Word || t(zh(n.input, n.index)) != dt.Word) && (t(zh(n.input, n.index + n[0].length)) != dt.Word || t(Uh(n.input, n.index + n[0].length)) != dt.Word);
}
class iG extends sk {
  nextMatch(e, r, n) {
    let i = Ra(this.spec, e, n, e.doc.length).next();
    return i.done && (i = Ra(this.spec, e, 0, r).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, r, n) {
    for (let i = 1; ; i++) {
      let s = Math.max(
        r,
        n - i * 1e4
        /* FindPrev.ChunkSize */
      ), a = Ra(this.spec, e, s, n), o = null;
      for (; !a.next().done; )
        o = a.value;
      if (o && (s == r || o.from > s + 10))
        return o;
      if (s == r)
        return null;
    }
  }
  prevMatch(e, r, n) {
    return this.prevMatchInRange(e, 0, r) || this.prevMatchInRange(e, n, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (r, n) => n == "$" ? "$" : n == "&" ? e.match[0] : n != "0" && +n < e.match.length ? e.match[n] : r);
  }
  matchAll(e, r) {
    let n = Ra(this.spec, e, 0, e.doc.length), i = [];
    for (; !n.next().done; ) {
      if (i.length >= r)
        return null;
      i.push(n.value);
    }
    return i;
  }
  highlight(e, r, n, i) {
    let s = Ra(this.spec, e, Math.max(
      0,
      r - 250
      /* RegExp.HighlightMargin */
    ), Math.min(n + 250, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
const uu = /* @__PURE__ */ Ae.define(), q0 = /* @__PURE__ */ Ae.define(), us = /* @__PURE__ */ Rt.define({
  create(t) {
    return new Ef(wg(t).create(), null);
  },
  update(t, e) {
    for (let r of e.effects)
      r.is(uu) ? t = new Ef(r.value.create(), t.panel) : r.is(q0) && (t = new Ef(t.query, r.value ? X0 : null));
    return t;
  },
  provide: (t) => su.from(t, (e) => e.panel)
});
class Ef {
  constructor(e, r) {
    this.query = e, this.panel = r;
  }
}
const sG = /* @__PURE__ */ be.mark({ class: "cm-searchMatch" }), aG = /* @__PURE__ */ be.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), oG = /* @__PURE__ */ wt.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(us));
  }
  update(t) {
    let e = t.state.field(us);
    (e != t.startState.field(us) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return be.none;
    let { view: r } = this, n = new ys();
    for (let i = 0, s = r.visibleRanges, a = s.length; i < a; i++) {
      let { from: o, to: u } = s[i];
      for (; i < a - 1 && u > s[i + 1].from - 2 * 250; )
        u = s[++i].to;
      t.highlight(r.state, o, u, (c, h) => {
        let p = r.state.selection.ranges.some((m) => m.from == c && m.to == h);
        n.add(c, h, p ? aG : sG);
      });
    }
    return n.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function Yu(t) {
  return (e) => {
    let r = e.state.field(us, !1);
    return r && r.query.spec.valid ? t(e, r) : lk(e);
  };
}
const Gh = /* @__PURE__ */ Yu((t, { query: e }) => {
  let { to: r } = t.state.selection.main, n = e.nextMatch(t.state, r, r);
  if (!n)
    return !1;
  let i = G.single(n.from, n.to), s = t.state.facet(Lo);
  return t.dispatch({
    selection: i,
    effects: [V0(t, n), s.scrollToMatch(i.main, t)],
    userEvent: "select.search"
  }), ok(t), !0;
}), Hh = /* @__PURE__ */ Yu((t, { query: e }) => {
  let { state: r } = t, { from: n } = r.selection.main, i = e.prevMatch(r, n, n);
  if (!i)
    return !1;
  let s = G.single(i.from, i.to), a = t.state.facet(Lo);
  return t.dispatch({
    selection: s,
    effects: [V0(t, i), a.scrollToMatch(s.main, t)],
    userEvent: "select.search"
  }), ok(t), !0;
}), lG = /* @__PURE__ */ Yu((t, { query: e }) => {
  let r = e.matchAll(t.state, 1e3);
  return !r || !r.length ? !1 : (t.dispatch({
    selection: G.create(r.map((n) => G.range(n.from, n.to))),
    userEvent: "select.search.matches"
  }), !0);
}), uG = ({ state: t, dispatch: e }) => {
  let r = t.selection;
  if (r.ranges.length > 1 || r.main.empty)
    return !1;
  let { from: n, to: i } = r.main, s = [], a = 0;
  for (let o = new go(t.doc, t.sliceDoc(n, i)); !o.next().done; ) {
    if (s.length > 1e3)
      return !1;
    o.value.from == n && (a = s.length), s.push(G.range(o.value.from, o.value.to));
  }
  return e(t.update({
    selection: G.create(s, a),
    userEvent: "select.search.matches"
  })), !0;
}, Hb = /* @__PURE__ */ Yu((t, { query: e }) => {
  let { state: r } = t, { from: n, to: i } = r.selection.main;
  if (r.readOnly)
    return !1;
  let s = e.nextMatch(r, n, n);
  if (!s)
    return !1;
  let a = [], o, u, c = [];
  if (s.from == n && s.to == i && (u = r.toText(e.getReplacement(s)), a.push({ from: s.from, to: s.to, insert: u }), s = e.nextMatch(r, s.from, s.to), c.push(ue.announce.of(r.phrase("replaced match on line $", r.doc.lineAt(n).number) + "."))), s) {
    let h = a.length == 0 || a[0].from >= s.to ? 0 : s.to - s.from - u.length;
    o = G.single(s.from - h, s.to - h), c.push(V0(t, s)), c.push(r.facet(Lo).scrollToMatch(o.main, t));
  }
  return t.dispatch({
    changes: a,
    selection: o,
    effects: c,
    userEvent: "input.replace"
  }), !0;
}), cG = /* @__PURE__ */ Yu((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let r = e.matchAll(t.state, 1e9).map((i) => {
    let { from: s, to: a } = i;
    return { from: s, to: a, insert: e.getReplacement(i) };
  });
  if (!r.length)
    return !1;
  let n = t.state.phrase("replaced $ matches", r.length) + ".";
  return t.dispatch({
    changes: r,
    effects: ue.announce.of(n),
    userEvent: "input.replace.all"
  }), !0;
});
function X0(t) {
  return t.state.facet(Lo).createPanel(t);
}
function wg(t, e) {
  var r, n, i, s, a;
  let o = t.selection.main, u = o.empty || o.to > o.from + 100 ? "" : t.sliceDoc(o.from, o.to);
  if (e && !u)
    return e;
  let c = t.facet(Lo);
  return new ik({
    search: ((r = e == null ? void 0 : e.literal) !== null && r !== void 0 ? r : c.literal) ? u : u.replace(/\n/g, "\\n"),
    caseSensitive: (n = e == null ? void 0 : e.caseSensitive) !== null && n !== void 0 ? n : c.caseSensitive,
    literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : c.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : c.regexp,
    wholeWord: (a = e == null ? void 0 : e.wholeWord) !== null && a !== void 0 ? a : c.wholeWord
  });
}
function ak(t) {
  let e = iu(t, X0);
  return e && e.dom.querySelector("[main-field]");
}
function ok(t) {
  let e = ak(t);
  e && e == t.root.activeElement && e.select();
}
const lk = (t) => {
  let e = t.state.field(us, !1);
  if (e && e.panel) {
    let r = ak(t);
    if (r && r != t.root.activeElement) {
      let n = wg(t.state, e.query.spec);
      n.valid && t.dispatch({ effects: uu.of(n) }), r.focus(), r.select();
    }
  } else
    t.dispatch({ effects: [
      q0.of(!0),
      e ? uu.of(wg(t.state, e.query.spec)) : Ae.appendConfig.of(fG)
    ] });
  return !0;
}, uk = (t) => {
  let e = t.state.field(us, !1);
  if (!e || !e.panel)
    return !1;
  let r = iu(t, X0);
  return r && r.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: q0.of(!1) }), !0;
}, hG = [
  { key: "Mod-f", run: lk, scope: "editor search-panel" },
  { key: "F3", run: Gh, shift: Hh, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Gh, shift: Hh, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: uk, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: uG },
  { key: "Mod-Alt-g", run: Wz },
  { key: "Mod-d", run: eG, preventDefault: !0 }
];
class pG {
  constructor(e) {
    this.view = e;
    let r = this.query = e.state.field(us).query.spec;
    this.commit = this.commit.bind(this), this.searchField = at("input", {
      value: r.search,
      placeholder: Mr(e, "Find"),
      "aria-label": Mr(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = at("input", {
      value: r.replace,
      placeholder: Mr(e, "Replace"),
      "aria-label": Mr(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = at("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: r.caseSensitive,
      onchange: this.commit
    }), this.reField = at("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: r.regexp,
      onchange: this.commit
    }), this.wordField = at("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: r.wholeWord,
      onchange: this.commit
    });
    function n(i, s, a) {
      return at("button", { class: "cm-button", name: i, onclick: s, type: "button" }, a);
    }
    this.dom = at("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      n("next", () => Gh(e), [Mr(e, "next")]),
      n("prev", () => Hh(e), [Mr(e, "previous")]),
      n("select", () => lG(e), [Mr(e, "all")]),
      at("label", null, [this.caseField, Mr(e, "match case")]),
      at("label", null, [this.reField, Mr(e, "regexp")]),
      at("label", null, [this.wordField, Mr(e, "by word")]),
      ...e.state.readOnly ? [] : [
        at("br"),
        this.replaceField,
        n("replace", () => Hb(e), [Mr(e, "replace")]),
        n("replaceAll", () => cG(e), [Mr(e, "replace all")])
      ],
      at("button", {
        name: "close",
        onclick: () => uk(e),
        "aria-label": Mr(e, "close"),
        type: "button"
      }, [""])
    ]);
  }
  commit() {
    let e = new ik({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: uu.of(e) }));
  }
  keydown(e) {
    bV(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Hh : Gh)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Hb(this.view));
  }
  update(e) {
    for (let r of e.transactions)
      for (let n of r.effects)
        n.is(uu) && !n.value.eq(this.query) && this.setQuery(n.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Lo).top;
  }
}
function Mr(t, e) {
  return t.state.phrase(e);
}
const Rc = 30, jc = /[\s\.,:;?!]/;
function V0(t, { from: e, to: r }) {
  let n = t.state.doc.lineAt(e), i = t.state.doc.lineAt(r).to, s = Math.max(n.from, e - Rc), a = Math.min(i, r + Rc), o = t.state.sliceDoc(s, a);
  if (s != n.from) {
    for (let u = 0; u < Rc; u++)
      if (!jc.test(o[u + 1]) && jc.test(o[u])) {
        o = o.slice(u);
        break;
      }
  }
  if (a != i) {
    for (let u = o.length - 1; u > o.length - Rc; u--)
      if (!jc.test(o[u - 1]) && jc.test(o[u])) {
        o = o.slice(0, u);
        break;
      }
  }
  return ue.announce.of(`${t.state.phrase("current match")}. ${o} ${t.state.phrase("on line")} ${n.number}.`);
}
const dG = /* @__PURE__ */ ue.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), fG = [
  us,
  /* @__PURE__ */ va.low(oG),
  dG
];
class ck {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(e, r, n) {
    this.state = e, this.pos = r, this.explicit = n, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let r = bt(this.state).resolveInner(this.pos, -1);
    for (; r && e.indexOf(r.name) < 0; )
      r = r.parent;
    return r ? {
      from: r.from,
      to: this.pos,
      text: this.state.sliceDoc(r.from, this.pos),
      type: r.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let r = this.state.doc.lineAt(this.pos), n = Math.max(r.from, this.pos - 250), i = r.text.slice(n - r.from, this.pos - r.from), s = i.search(pk(e, !1));
    return s < 0 ? null : { from: n + s, to: this.pos, text: i.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, r) {
    e == "abort" && this.abortListeners && this.abortListeners.push(r);
  }
}
function Jb(t) {
  let e = Object.keys(t).join(""), r = /\w/.test(e);
  return r && (e = e.replace(/\w/g, "")), `[${r ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function mG(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of t) {
    e[i[0]] = !0;
    for (let s = 1; s < i.length; s++)
      r[i[s]] = !0;
  }
  let n = Jb(e) + Jb(r) + "*$";
  return [new RegExp("^" + n), new RegExp(n)];
}
function hk(t) {
  let e = t.map((i) => typeof i == "string" ? { label: i } : i), [r, n] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : mG(e);
  return (i) => {
    let s = i.matchBefore(n);
    return s || i.explicit ? { from: s ? s.from : i.pos, options: e, validFor: r } : null;
  };
}
function gG(t, e) {
  return (r) => {
    for (let n = bt(r.state).resolveInner(r.pos, -1); n; n = n.parent) {
      if (t.indexOf(n.name) > -1)
        return null;
      if (n.type.isTop)
        break;
    }
    return e(r);
  };
}
class Kb {
  constructor(e, r, n, i) {
    this.completion = e, this.source = r, this.match = n, this.score = i;
  }
}
function cs(t) {
  return t.selection.main.from;
}
function pk(t, e) {
  var r;
  let { source: n } = t, i = e && n[0] != "^", s = n[n.length - 1] != "$";
  return !i && !s ? t : new RegExp(`${i ? "^" : ""}(?:${n})${s ? "$" : ""}`, (r = t.flags) !== null && r !== void 0 ? r : t.ignoreCase ? "i" : "");
}
const dk = /* @__PURE__ */ pi.define();
function yG(t, e, r, n) {
  let { main: i } = t.selection, s = r - i.from, a = n - i.from;
  return Object.assign(Object.assign({}, t.changeByRange((o) => o != i && r != n && t.sliceDoc(o.from + s, o.from + a) != t.sliceDoc(r, n) ? { range: o } : {
    changes: { from: o.from + s, to: n == i.from ? o.to : o.from + a, insert: e },
    range: G.cursor(o.from + s + e.length)
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const eD = /* @__PURE__ */ new WeakMap();
function OG(t) {
  if (!Array.isArray(t))
    return t;
  let e = eD.get(t);
  return e || eD.set(t, e = hk(t)), e;
}
const Jh = /* @__PURE__ */ Ae.define(), cu = /* @__PURE__ */ Ae.define();
class xG {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let r = 0; r < e.length; ) {
      let n = Wt(e, r), i = ln(n);
      this.chars.push(n);
      let s = e.slice(r, r + i), a = s.toUpperCase();
      this.folded.push(Wt(a == s ? s.toLowerCase() : a, 0)), r += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, r) {
    return this.score = e, this.matched = r, !0;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return !1;
    let { chars: r, folded: n, any: i, precise: s, byWord: a } = this;
    if (r.length == 1) {
      let x = Wt(e, 0), w = ln(x), T = w == e.length ? 0 : -100;
      if (x != r[0])
        if (x == n[0])
          T += -200;
        else
          return !1;
      return this.ret(T, [0, w]);
    }
    let o = e.indexOf(this.pattern);
    if (o == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let u = r.length, c = 0;
    if (o < 0) {
      for (let x = 0, w = Math.min(e.length, 200); x < w && c < u; ) {
        let T = Wt(e, x);
        (T == r[c] || T == n[c]) && (i[c++] = x), x += ln(T);
      }
      if (c < u)
        return !1;
    }
    let h = 0, p = 0, m = !1, g = 0, O = -1, b = -1, D = /[a-z]/.test(e), S = !0;
    for (let x = 0, w = Math.min(e.length, 200), T = 0; x < w && p < u; ) {
      let C = Wt(e, x);
      o < 0 && (h < u && C == r[h] && (s[h++] = x), g < u && (C == r[g] || C == n[g] ? (g == 0 && (O = x), b = x + 1, g++) : g = 0));
      let A, P = C < 255 ? C >= 48 && C <= 57 || C >= 97 && C <= 122 ? 2 : C >= 65 && C <= 90 ? 1 : 0 : (A = x0(C)) != A.toLowerCase() ? 1 : A != A.toUpperCase() ? 2 : 0;
      (!x || P == 1 && D || T == 0 && P != 0) && (r[p] == C || n[p] == C && (m = !0) ? a[p++] = x : a.length && (S = !1)), T = P, x += ln(C);
    }
    return p == u && a[0] == 0 && S ? this.result(-100 + (m ? -200 : 0), a, e) : g == u && O == 0 ? this.ret(-200 - e.length + (b == e.length ? 0 : -100), [0, b]) : o > -1 ? this.ret(-700 - e.length, [o, o + this.pattern.length]) : g == u ? this.ret(-900 - e.length, [O, b]) : p == u ? this.result(-100 + (m ? -200 : 0) + -700 + (S ? 0 : -1100), a, e) : r.length == 2 ? !1 : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, r, n) {
    let i = [], s = 0;
    for (let a of r) {
      let o = a + (this.astral ? ln(Wt(n, a)) : 1);
      s && i[s - 1] == a ? i[s - 1] = o : (i[s++] = a, i[s++] = o);
    }
    return this.ret(e - n.length, i);
  }
}
const Yt = /* @__PURE__ */ me.define({
  combine(t) {
    return di(t, {
      activateOnTyping: !0,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: bG,
      compareCompletions: (e, r) => e.label.localeCompare(r.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, r) => e && r,
      closeOnBlur: (e, r) => e && r,
      icons: (e, r) => e && r,
      tooltipClass: (e, r) => (n) => tD(e(n), r(n)),
      optionClass: (e, r) => (n) => tD(e(n), r(n)),
      addToOptions: (e, r) => e.concat(r)
    });
  }
});
function tD(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function bG(t, e, r, n, i, s) {
  let a = t.textDirection == ct.RTL, o = a, u = !1, c = "top", h, p, m = e.left - i.left, g = i.right - e.right, O = n.right - n.left, b = n.bottom - n.top;
  if (o && m < Math.min(O, g) ? o = !1 : !o && g < Math.min(O, m) && (o = !0), O <= (o ? m : g))
    h = Math.max(i.top, Math.min(r.top, i.bottom - b)) - e.top, p = Math.min(400, o ? m : g);
  else {
    u = !0, p = Math.min(
      400,
      (a ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let x = i.bottom - e.bottom;
    x >= b || x > e.top ? h = r.bottom - e.top : (c = "bottom", h = e.bottom - r.top);
  }
  let D = (e.bottom - e.top) / s.offsetHeight, S = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${c}: ${h / D}px; max-width: ${p / S}px`,
    class: "cm-completionInfo-" + (u ? a ? "left-narrow" : "right-narrow" : o ? "left" : "right")
  };
}
function DG(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(r) {
      let n = document.createElement("div");
      return n.classList.add("cm-completionIcon"), r.type && n.classList.add(...r.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), n.setAttribute("aria-hidden", "true"), n;
    },
    position: 20
  }), e.push({
    render(r, n, i, s) {
      let a = document.createElement("span");
      a.className = "cm-completionLabel";
      let o = r.displayLabel || r.label, u = 0;
      for (let c = 0; c < s.length; ) {
        let h = s[c++], p = s[c++];
        h > u && a.appendChild(document.createTextNode(o.slice(u, h)));
        let m = a.appendChild(document.createElement("span"));
        m.appendChild(document.createTextNode(o.slice(h, p))), m.className = "cm-completionMatchedText", u = p;
      }
      return u < o.length && a.appendChild(document.createTextNode(o.slice(u))), a;
    },
    position: 50
  }, {
    render(r) {
      if (!r.detail)
        return null;
      let n = document.createElement("span");
      return n.className = "cm-completionDetail", n.textContent = r.detail, n;
    },
    position: 80
  }), e.sort((r, n) => r.position - n.position).map((r) => r.render);
}
function Af(t, e, r) {
  if (t <= r)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let i = Math.floor(e / r);
    return { from: i * r, to: (i + 1) * r };
  }
  let n = Math.floor((t - e) / r);
  return { from: t - (n + 1) * r, to: t - n * r };
}
class vG {
  constructor(e, r, n) {
    this.view = e, this.stateField = r, this.applyCompletion = n, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (u) => this.placeInfo(u),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(r), { options: s, selected: a } = i.open, o = e.state.facet(Yt);
    this.optionContent = DG(o), this.optionClass = o.optionClass, this.tooltipClass = o.tooltipClass, this.range = Af(s.length, a, o.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (u) => {
      let { options: c } = e.state.field(r).open;
      for (let h = u.target, p; h && h != this.dom; h = h.parentNode)
        if (h.nodeName == "LI" && (p = /-(\d+)$/.exec(h.id)) && +p[1] < c.length) {
          this.applyCompletion(e, c[+p[1]]), u.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (u) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(Yt).closeOnBlur && u.relatedTarget != e.contentDOM && e.dispatch({ effects: cu.of(null) });
    }), this.showOptions(s, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, r) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, r, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var r;
    let n = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), n != i) {
      let { options: s, selected: a, disabled: o } = n.open;
      (!i.open || i.open.options != s) && (this.range = Af(s.length, a, e.state.facet(Yt).maxRenderedOptions), this.showOptions(s, n.id)), this.updateSel(), o != ((r = i.open) === null || r === void 0 ? void 0 : r.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!o);
    }
  }
  updateTooltipClass(e) {
    let r = this.tooltipClass(e);
    if (r != this.currentClass) {
      for (let n of this.currentClass.split(" "))
        n && this.dom.classList.remove(n);
      for (let n of r.split(" "))
        n && this.dom.classList.add(n);
      this.currentClass = r;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), r = e.open;
    if ((r.selected > -1 && r.selected < this.range.from || r.selected >= this.range.to) && (this.range = Af(r.options.length, r.selected, this.view.state.facet(Yt).maxRenderedOptions), this.showOptions(r.options, e.id)), this.updateSelectedOption(r.selected)) {
      this.destroyInfo();
      let { completion: n } = r.options[r.selected], { info: i } = n;
      if (!i)
        return;
      let s = typeof i == "string" ? document.createTextNode(i) : i(n);
      if (!s)
        return;
      "then" in s ? s.then((a) => {
        a && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(a, n);
      }).catch((a) => hn(this.view.state, a, "completion info")) : this.addInfoPane(s, n);
    }
  }
  addInfoPane(e, r) {
    this.destroyInfo();
    let n = this.info = document.createElement("div");
    if (n.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      n.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: s } = e;
      n.appendChild(i), this.infoDestroy = s || null;
    }
    this.dom.appendChild(n), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let r = null;
    for (let n = this.list.firstChild, i = this.range.from; n; n = n.nextSibling, i++)
      n.nodeName != "LI" || !n.id ? i-- : i == e ? n.hasAttribute("aria-selected") || (n.setAttribute("aria-selected", "true"), r = n) : n.hasAttribute("aria-selected") && n.removeAttribute("aria-selected");
    return r && wG(this.list, r), r;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let r = this.dom.getBoundingClientRect(), n = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let a = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: a.innerWidth, bottom: a.innerHeight };
    }
    return i.top > Math.min(s.bottom, r.bottom) - 10 || i.bottom < Math.max(s.top, r.top) + 10 ? null : this.view.state.facet(Yt).positionInfo(this.view, r, i, n, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, r, n) {
    const i = document.createElement("ul");
    i.id = r, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let s = null;
    for (let a = n.from; a < n.to; a++) {
      let { completion: o, match: u } = e[a], { section: c } = o;
      if (c) {
        let m = typeof c == "string" ? c : c.name;
        if (m != s && (a > n.from || n.from == 0))
          if (s = m, typeof c != "string" && c.header)
            i.appendChild(c.header(c));
          else {
            let g = i.appendChild(document.createElement("completion-section"));
            g.textContent = m;
          }
      }
      const h = i.appendChild(document.createElement("li"));
      h.id = r + "-" + a, h.setAttribute("role", "option");
      let p = this.optionClass(o);
      p && (h.className = p);
      for (let m of this.optionContent) {
        let g = m(o, this.view.state, this.view, u);
        g && h.appendChild(g);
      }
    }
    return n.from && i.classList.add("cm-completionListIncompleteTop"), n.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function SG(t, e) {
  return (r) => new vG(r, t, e);
}
function wG(t, e) {
  let r = t.getBoundingClientRect(), n = e.getBoundingClientRect(), i = r.height / t.offsetHeight;
  n.top < r.top ? t.scrollTop -= (r.top - n.top) / i : n.bottom > r.bottom && (t.scrollTop += (n.bottom - r.bottom) / i);
}
function rD(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function CG(t, e) {
  let r = [], n = null, i = (u) => {
    r.push(u);
    let { section: c } = u.completion;
    if (c) {
      n || (n = []);
      let h = typeof c == "string" ? c : c.name;
      n.some((p) => p.name == h) || n.push(typeof c == "string" ? { name: h } : c);
    }
  };
  for (let u of t)
    if (u.hasResult()) {
      let c = u.result.getMatch;
      if (u.result.filter === !1)
        for (let h of u.result.options)
          i(new Kb(h, u.source, c ? c(h) : [], 1e9 - r.length));
      else {
        let h = new xG(e.sliceDoc(u.from, u.to));
        for (let p of u.result.options)
          if (h.match(p.label)) {
            let m = p.displayLabel ? c ? c(p, h.matched) : [] : h.matched;
            i(new Kb(p, u.source, m, h.score + (p.boost || 0)));
          }
      }
    }
  if (n) {
    let u = /* @__PURE__ */ Object.create(null), c = 0, h = (p, m) => {
      var g, O;
      return ((g = p.rank) !== null && g !== void 0 ? g : 1e9) - ((O = m.rank) !== null && O !== void 0 ? O : 1e9) || (p.name < m.name ? -1 : 1);
    };
    for (let p of n.sort(h))
      c -= 1e5, u[p.name] = c;
    for (let p of r) {
      let { section: m } = p.completion;
      m && (p.score += u[typeof m == "string" ? m : m.name]);
    }
  }
  let s = [], a = null, o = e.facet(Yt).compareCompletions;
  for (let u of r.sort((c, h) => h.score - c.score || o(c.completion, h.completion))) {
    let c = u.completion;
    !a || a.label != c.label || a.detail != c.detail || a.type != null && c.type != null && a.type != c.type || a.apply != c.apply || a.boost != c.boost ? s.push(u) : rD(u.completion) > rD(a) && (s[s.length - 1] = u), a = u.completion;
  }
  return s;
}
class Ya {
  constructor(e, r, n, i, s, a) {
    this.options = e, this.attrs = r, this.tooltip = n, this.timestamp = i, this.selected = s, this.disabled = a;
  }
  setSelected(e, r) {
    return e == this.selected || e >= this.options.length ? this : new Ya(this.options, nD(r, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, r, n, i, s) {
    let a = CG(e, r);
    if (!a.length)
      return i && e.some(
        (u) => u.state == 1
        /* State.Pending */
      ) ? new Ya(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, !0) : null;
    let o = r.facet(Yt).selectOnOpen ? 0 : -1;
    if (i && i.selected != o && i.selected != -1) {
      let u = i.options[i.selected].completion;
      for (let c = 0; c < a.length; c++)
        if (a[c].completion == u) {
          o = c;
          break;
        }
    }
    return new Ya(a, nD(n, o), {
      pos: e.reduce((u, c) => c.hasResult() ? Math.min(u, c.from) : u, 1e8),
      create: PG,
      above: s.aboveCursor
    }, i ? i.timestamp : Date.now(), o, !1);
  }
  map(e) {
    return new Ya(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class Kh {
  constructor(e, r, n) {
    this.active = e, this.id = r, this.open = n;
  }
  static start() {
    return new Kh(TG, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: r } = e, n = r.facet(Yt), s = (n.override || r.languageDataAt("autocomplete", cs(r)).map(OG)).map((o) => (this.active.find((c) => c.source == o) || new Cr(
      o,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, n));
    s.length == this.active.length && s.every((o, u) => o == this.active[u]) && (s = this.active);
    let a = this.open;
    a && e.docChanged && (a = a.map(e.changes)), e.selection || s.some((o) => o.hasResult() && e.changes.touchesRange(o.from, o.to)) || !EG(s, this.active) ? a = Ya.build(s, r, this.id, a, n) : a && a.disabled && !s.some(
      (o) => o.state == 1
      /* State.Pending */
    ) && (a = null), !a && s.every(
      (o) => o.state != 1
      /* State.Pending */
    ) && s.some((o) => o.hasResult()) && (s = s.map((o) => o.hasResult() ? new Cr(
      o.source,
      0
      /* State.Inactive */
    ) : o));
    for (let o of e.effects)
      o.is(mk) && (a = a && a.setSelected(o.value, this.id));
    return s == this.active && a == this.open ? this : new Kh(s, this.id, a);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : AG;
  }
}
function EG(t, e) {
  if (t == e)
    return !0;
  for (let r = 0, n = 0; ; ) {
    for (; r < t.length && !t[r].hasResult; )
      r++;
    for (; n < e.length && !e[n].hasResult; )
      n++;
    let i = r == t.length, s = n == e.length;
    if (i || s)
      return i == s;
    if (t[r++].result != e[n++].result)
      return !1;
  }
}
const AG = {
  "aria-autocomplete": "list"
};
function nD(t, e) {
  let r = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (r["aria-activedescendant"] = t + "-" + e), r;
}
const TG = [];
function Cg(t) {
  return t.isUserEvent("input.type") ? "input" : t.isUserEvent("delete.backward") ? "delete" : null;
}
class Cr {
  constructor(e, r, n = -1) {
    this.source = e, this.state = r, this.explicitPos = n;
  }
  hasResult() {
    return !1;
  }
  update(e, r) {
    let n = Cg(e), i = this;
    n ? i = i.handleUserEvent(e, n, r) : e.docChanged ? i = i.handleChange(e) : e.selection && i.state != 0 && (i = new Cr(
      i.source,
      0
      /* State.Inactive */
    ));
    for (let s of e.effects)
      if (s.is(Jh))
        i = new Cr(i.source, 1, s.value ? cs(e.state) : -1);
      else if (s.is(cu))
        i = new Cr(
          i.source,
          0
          /* State.Inactive */
        );
      else if (s.is(fk))
        for (let a of s.value)
          a.source == i.source && (i = a);
    return i;
  }
  handleUserEvent(e, r, n) {
    return r == "delete" || !n.activateOnTyping ? this.map(e.changes) : new Cr(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(cs(e.startState)) ? new Cr(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new Cr(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class ro extends Cr {
  constructor(e, r, n, i, s) {
    super(e, 2, r), this.result = n, this.from = i, this.to = s;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, r, n) {
    var i;
    let s = e.changes.mapPos(this.from), a = e.changes.mapPos(this.to, 1), o = cs(e.state);
    if ((this.explicitPos < 0 ? o <= s : o < this.from) || o > a || r == "delete" && cs(e.startState) == this.from)
      return new Cr(
        this.source,
        r == "input" && n.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let u = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), c;
    return kG(this.result.validFor, e.state, s, a) ? new ro(this.source, u, this.result, s, a) : this.result.update && (c = this.result.update(this.result, s, a, new ck(e.state, o, u >= 0))) ? new ro(this.source, u, c, c.from, (i = c.to) !== null && i !== void 0 ? i : cs(e.state)) : new Cr(this.source, 1, u);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new Cr(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new ro(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function kG(t, e, r, n) {
  if (!t)
    return !1;
  let i = e.sliceDoc(r, n);
  return typeof t == "function" ? t(i, r, n, e) : pk(t, !0).test(i);
}
const fk = /* @__PURE__ */ Ae.define({
  map(t, e) {
    return t.map((r) => r.map(e));
  }
}), mk = /* @__PURE__ */ Ae.define(), Wr = /* @__PURE__ */ Rt.define({
  create() {
    return Kh.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    P0.from(t, (e) => e.tooltip),
    ue.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function gk(t, e) {
  const r = e.completion.apply || e.completion.label;
  let n = t.state.field(Wr).active.find((i) => i.source == e.source);
  return n instanceof ro ? (typeof r == "string" ? t.dispatch(Object.assign(Object.assign({}, yG(t.state, r, n.from, n.to)), { annotations: dk.of(e.completion) })) : r(t, e.completion, n.from, n.to), !0) : !1;
}
const PG = /* @__PURE__ */ SG(Wr, gk);
function Zc(t, e = "option") {
  return (r) => {
    let n = r.state.field(Wr, !1);
    if (!n || !n.open || n.open.disabled || Date.now() - n.open.timestamp < r.state.facet(Yt).interactionDelay)
      return !1;
    let i = 1, s;
    e == "page" && (s = YA(r, n.open.tooltip)) && (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: a } = n.open.options, o = n.open.selected > -1 ? n.open.selected + i * (t ? 1 : -1) : t ? 0 : a - 1;
    return o < 0 ? o = e == "page" ? 0 : a - 1 : o >= a && (o = e == "page" ? a - 1 : 0), r.dispatch({ effects: mk.of(o) }), !0;
  };
}
const FG = (t) => {
  let e = t.state.field(Wr, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(Yt).interactionDelay ? !1 : gk(t, e.open.options[e.open.selected]);
}, $G = (t) => t.state.field(Wr, !1) ? (t.dispatch({ effects: Jh.of(!0) }), !0) : !1, BG = (t) => {
  let e = t.state.field(Wr, !1);
  return !e || !e.active.some(
    (r) => r.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: cu.of(null) }), !0);
};
class IG {
  constructor(e, r) {
    this.active = e, this.context = r, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const NG = 50, _G = 1e3, QG = /* @__PURE__ */ wt.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(Wr).active)
      e.state == 1 && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(Wr);
    if (!t.selectionSet && !t.docChanged && t.startState.field(Wr) == e)
      return;
    let r = t.transactions.some((i) => (i.selection || i.docChanged) && !Cg(i));
    for (let i = 0; i < this.running.length; i++) {
      let s = this.running[i];
      if (r || s.updates.length + t.transactions.length > NG && Date.now() - s.time > _G) {
        for (let a of s.context.abortListeners)
          try {
            a();
          } catch (o) {
            hn(this.view.state, o);
          }
        s.context.abortListeners = null, this.running.splice(i--, 1);
      } else
        s.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((i) => i.effects.some((s) => s.is(Jh))) && (this.pendingStart = !0);
    let n = this.pendingStart ? 50 : t.state.facet(Yt).activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((i) => i.state == 1 && !this.running.some((s) => s.active.source == i.source)) ? setTimeout(() => this.startUpdate(), n) : -1, this.composing != 0)
      for (let i of t.transactions)
        Cg(i) == "input" ? this.composing = 2 : this.composing == 2 && i.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(Wr);
    for (let r of e.active)
      r.state == 1 && !this.running.some((n) => n.active.source == r.source) && this.startQuery(r);
  }
  startQuery(t) {
    let { state: e } = this.view, r = cs(e), n = new ck(e, r, t.explicitPos == r), i = new IG(t, n);
    this.running.push(i), Promise.resolve(t.source(n)).then((s) => {
      i.context.aborted || (i.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: cu.of(null) }), hn(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Yt).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], r = this.view.state.facet(Yt);
    for (let n = 0; n < this.running.length; n++) {
      let i = this.running[n];
      if (i.done === void 0)
        continue;
      if (this.running.splice(n--, 1), i.done) {
        let a = new ro(i.active.source, i.active.explicitPos, i.done, i.done.from, (t = i.done.to) !== null && t !== void 0 ? t : cs(i.updates.length ? i.updates[0].startState : this.view.state));
        for (let o of i.updates)
          a = a.update(o, r);
        if (a.hasResult()) {
          e.push(a);
          continue;
        }
      }
      let s = this.view.state.field(Wr).active.find((a) => a.source == i.active.source);
      if (s && s.state == 1)
        if (i.done == null) {
          let a = new Cr(
            i.active.source,
            0
            /* State.Inactive */
          );
          for (let o of i.updates)
            a = a.update(o, r);
          a.state != 1 && e.push(a);
        } else
          this.startQuery(s);
    }
    e.length && this.view.dispatch({ effects: fk.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(Wr, !1);
      if (e && e.tooltip && this.view.state.facet(Yt).closeOnBlur) {
        let r = e.open && YA(this.view, e.open.tooltip);
        (!r || !r.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: cu.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Jh.of(!1) }), 20), this.composing = 0;
    }
  }
}), yk = /* @__PURE__ */ ue.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class MG {
  constructor(e, r, n, i) {
    this.field = e, this.line = r, this.from = n, this.to = i;
  }
}
class Y0 {
  constructor(e, r, n) {
    this.field = e, this.from = r, this.to = n;
  }
  map(e) {
    let r = e.mapPos(this.from, -1, Vt.TrackDel), n = e.mapPos(this.to, 1, Vt.TrackDel);
    return r == null || n == null ? null : new Y0(this.field, r, n);
  }
}
class U0 {
  constructor(e, r) {
    this.lines = e, this.fieldPositions = r;
  }
  instantiate(e, r) {
    let n = [], i = [r], s = e.doc.lineAt(r), a = /^\s*/.exec(s.text)[0];
    for (let u of this.lines) {
      if (n.length) {
        let c = a, h = /^\t*/.exec(u)[0].length;
        for (let p = 0; p < h; p++)
          c += e.facet(ju);
        i.push(r + c.length - h), u = c + u.slice(h);
      }
      n.push(u), r += u.length + 1;
    }
    let o = this.fieldPositions.map((u) => new Y0(u.field, i[u.line] + u.from, i[u.line] + u.to));
    return { text: n, ranges: o };
  }
  static parse(e) {
    let r = [], n = [], i = [], s;
    for (let a of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(a); ) {
        let o = s[1] ? +s[1] : null, u = s[2] || s[3] || "", c = -1;
        for (let h = 0; h < r.length; h++)
          (o != null ? r[h].seq == o : u && r[h].name == u) && (c = h);
        if (c < 0) {
          let h = 0;
          for (; h < r.length && (o == null || r[h].seq != null && r[h].seq < o); )
            h++;
          r.splice(h, 0, { seq: o, name: u }), c = h;
          for (let p of i)
            p.field >= c && p.field++;
        }
        i.push(new MG(c, n.length, s.index, s.index + u.length)), a = a.slice(0, s.index) + u + a.slice(s.index + s[0].length);
      }
      for (let o; o = /\\([{}])/.exec(a); ) {
        a = a.slice(0, o.index) + o[1] + a.slice(o.index + o[0].length);
        for (let u of i)
          u.line == n.length && u.from > o.index && (u.from--, u.to--);
      }
      n.push(a);
    }
    return new U0(n, i);
  }
}
let LG = /* @__PURE__ */ be.widget({ widget: /* @__PURE__ */ new class extends fi {
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-snippetFieldPosition", t;
  }
  ignoreEvent() {
    return !1;
  }
}() }), RG = /* @__PURE__ */ be.mark({ class: "cm-snippetField" });
class Ro {
  constructor(e, r) {
    this.ranges = e, this.active = r, this.deco = be.set(e.map((n) => (n.from == n.to ? LG : RG).range(n.from, n.to)));
  }
  map(e) {
    let r = [];
    for (let n of this.ranges) {
      let i = n.map(e);
      if (!i)
        return null;
      r.push(i);
    }
    return new Ro(r, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((r) => this.ranges.some((n) => n.field == this.active && n.from <= r.from && n.to >= r.to));
  }
}
const Uu = /* @__PURE__ */ Ae.define({
  map(t, e) {
    return t && t.map(e);
  }
}), jG = /* @__PURE__ */ Ae.define(), hu = /* @__PURE__ */ Rt.define({
  create() {
    return null;
  },
  update(t, e) {
    for (let r of e.effects) {
      if (r.is(Uu))
        return r.value;
      if (r.is(jG) && t)
        return new Ro(t.ranges, r.value);
    }
    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
  },
  provide: (t) => ue.decorations.from(t, (e) => e ? e.deco : be.none)
});
function z0(t, e) {
  return G.create(t.filter((r) => r.field == e).map((r) => G.range(r.from, r.to)));
}
function ZG(t) {
  let e = U0.parse(t);
  return (r, n, i, s) => {
    let { text: a, ranges: o } = e.instantiate(r.state, i), u = {
      changes: { from: i, to: s, insert: Xe.of(a) },
      scrollIntoView: !0,
      annotations: n ? [dk.of(n), Tt.userEvent.of("input.complete")] : void 0
    };
    if (o.length && (u.selection = z0(o, 0)), o.some((c) => c.field > 0)) {
      let c = new Ro(o, 0), h = u.effects = [Uu.of(c)];
      r.state.field(hu, !1) === void 0 && h.push(Ae.appendConfig.of([hu, YG, UG, yk]));
    }
    r.dispatch(r.state.update(u));
  };
}
function Ok(t) {
  return ({ state: e, dispatch: r }) => {
    let n = e.field(hu, !1);
    if (!n || t < 0 && n.active == 0)
      return !1;
    let i = n.active + t, s = t > 0 && !n.ranges.some((a) => a.field == i + t);
    return r(e.update({
      selection: z0(n.ranges, i),
      effects: Uu.of(s ? null : new Ro(n.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const WG = ({ state: t, dispatch: e }) => t.field(hu, !1) ? (e(t.update({ effects: Uu.of(null) })), !0) : !1, qG = /* @__PURE__ */ Ok(1), XG = /* @__PURE__ */ Ok(-1), VG = [
  { key: "Tab", run: qG, shift: XG },
  { key: "Escape", run: WG }
], iD = /* @__PURE__ */ me.define({
  combine(t) {
    return t.length ? t[0] : VG;
  }
}), YG = /* @__PURE__ */ va.highest(/* @__PURE__ */ Mu.compute([iD], (t) => t.facet(iD)));
function vr(t, e) {
  return Object.assign(Object.assign({}, e), { apply: ZG(t) });
}
const UG = /* @__PURE__ */ ue.domEventHandlers({
  mousedown(t, e) {
    let r = e.state.field(hu, !1), n;
    if (!r || (n = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)
      return !1;
    let i = r.ranges.find((s) => s.from <= n && s.to >= n);
    return !i || i.field == r.active ? !1 : (e.dispatch({
      selection: z0(r.ranges, i.field),
      effects: Uu.of(r.ranges.some((s) => s.field > i.field) ? new Ro(r.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), pu = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Xs = /* @__PURE__ */ Ae.define({
  map(t, e) {
    let r = e.mapPos(t, -1, Vt.TrackAfter);
    return r ?? void 0;
  }
}), G0 = /* @__PURE__ */ new class extends na {
}();
G0.startSide = 1;
G0.endSide = -1;
const xk = /* @__PURE__ */ Rt.define({
  create() {
    return We.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let r = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (n) => n >= r.from && n <= r.to });
    }
    for (let r of e.effects)
      r.is(Xs) && (t = t.update({ add: [G0.range(r.value, r.value + 1)] }));
    return t;
  }
});
function zG() {
  return [HG, xk];
}
const Tf = "()[]{}<>";
function bk(t) {
  for (let e = 0; e < Tf.length; e += 2)
    if (Tf.charCodeAt(e) == t)
      return Tf.charAt(e + 1);
  return x0(t < 128 ? t : t + 1);
}
function Dk(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || pu;
}
const GG = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), HG = /* @__PURE__ */ ue.inputHandler.of((t, e, r, n) => {
  if ((GG ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let i = t.state.selection.main;
  if (n.length > 2 || n.length == 2 && ln(Wt(n, 0)) == 1 || e != i.from || r != i.to)
    return !1;
  let s = eH(t.state, n);
  return s ? (t.dispatch(s), !0) : !1;
}), JG = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = Dk(t, t.selection.main.head).brackets || pu.brackets, i = null, s = t.changeByRange((a) => {
    if (a.empty) {
      let o = tH(t.doc, a.head);
      for (let u of n)
        if (u == o && fd(t.doc, a.head) == bk(Wt(u, 0)))
          return {
            changes: { from: a.head - u.length, to: a.head + u.length },
            range: G.cursor(a.head - u.length)
          };
    }
    return { range: i = a };
  });
  return i || e(t.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, KG = [
  { key: "Backspace", run: JG }
];
function eH(t, e) {
  let r = Dk(t, t.selection.main.head), n = r.brackets || pu.brackets;
  for (let i of n) {
    let s = bk(Wt(i, 0));
    if (e == i)
      return s == i ? iH(t, i, n.indexOf(i + i + i) > -1, r) : rH(t, i, s, r.before || pu.before);
    if (e == s && vk(t, t.selection.main.from))
      return nH(t, i, s);
  }
  return null;
}
function vk(t, e) {
  let r = !1;
  return t.field(xk).between(0, t.doc.length, (n) => {
    n == e && (r = !0);
  }), r;
}
function fd(t, e) {
  let r = t.sliceString(e, e + 2);
  return r.slice(0, ln(Wt(r, 0)));
}
function tH(t, e) {
  let r = t.sliceString(e - 2, e);
  return ln(Wt(r, 0)) == r.length ? r : r.slice(1);
}
function rH(t, e, r, n) {
  let i = null, s = t.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: r, from: a.to }],
        effects: Xs.of(a.to + e.length),
        range: G.range(a.anchor + e.length, a.head + e.length)
      };
    let o = fd(t.doc, a.head);
    return !o || /\s/.test(o) || n.indexOf(o) > -1 ? {
      changes: { insert: e + r, from: a.head },
      effects: Xs.of(a.head + e.length),
      range: G.cursor(a.head + e.length)
    } : { range: i = a };
  });
  return i ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function nH(t, e, r) {
  let n = null, i = t.changeByRange((s) => s.empty && fd(t.doc, s.head) == r ? {
    changes: { from: s.head, to: s.head + r.length, insert: r },
    range: G.cursor(s.head + r.length)
  } : n = { range: s });
  return n ? null : t.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function iH(t, e, r, n) {
  let i = n.stringPrefixes || pu.stringPrefixes, s = null, a = t.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: e, from: o.to }],
        effects: Xs.of(o.to + e.length),
        range: G.range(o.anchor + e.length, o.head + e.length)
      };
    let u = o.head, c = fd(t.doc, u), h;
    if (c == e) {
      if (sD(t, u))
        return {
          changes: { insert: e + e, from: u },
          effects: Xs.of(u + e.length),
          range: G.cursor(u + e.length)
        };
      if (vk(t, u)) {
        let m = r && t.sliceDoc(u, u + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: u, to: u + m.length, insert: m },
          range: G.cursor(u + m.length)
        };
      }
    } else {
      if (r && t.sliceDoc(u - 2 * e.length, u) == e + e && (h = aD(t, u - 2 * e.length, i)) > -1 && sD(t, h))
        return {
          changes: { insert: e + e + e + e, from: u },
          effects: Xs.of(u + e.length),
          range: G.cursor(u + e.length)
        };
      if (t.charCategorizer(u)(c) != dt.Word && aD(t, u, i) > -1 && !sH(t, u, e, i))
        return {
          changes: { insert: e + e, from: u },
          effects: Xs.of(u + e.length),
          range: G.cursor(u + e.length)
        };
    }
    return { range: s = o };
  });
  return s ? null : t.update(a, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function sD(t, e) {
  let r = bt(t).resolveInner(e + 1);
  return r.parent && r.from == e;
}
function sH(t, e, r, n) {
  let i = bt(t).resolveInner(e, -1), s = n.reduce((a, o) => Math.max(a, o.length), 0);
  for (let a = 0; a < 5; a++) {
    let o = t.sliceDoc(i.from, Math.min(i.to, i.from + r.length + s)), u = o.indexOf(r);
    if (!u || u > -1 && n.indexOf(o.slice(0, u)) > -1) {
      let h = i.firstChild;
      for (; h && h.from == i.from && h.to - h.from > r.length + u; ) {
        if (t.sliceDoc(h.to - r.length, h.to) == r)
          return !1;
        h = h.firstChild;
      }
      return !0;
    }
    let c = i.to == e && i.parent;
    if (!c)
      break;
    i = c;
  }
  return !1;
}
function aD(t, e, r) {
  let n = t.charCategorizer(e);
  if (n(t.sliceDoc(e - 1, e)) != dt.Word)
    return e;
  for (let i of r) {
    let s = e - i.length;
    if (t.sliceDoc(s, e) == i && n(t.sliceDoc(s - 1, s)) != dt.Word)
      return s;
  }
  return -1;
}
function aH(t = {}) {
  return [
    Wr,
    Yt.of(t),
    QG,
    oH,
    yk
  ];
}
const Sk = [
  { key: "Ctrl-Space", run: $G },
  { key: "Escape", run: BG },
  { key: "ArrowDown", run: /* @__PURE__ */ Zc(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Zc(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Zc(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Zc(!1, "page") },
  { key: "Enter", run: FG }
], oH = /* @__PURE__ */ va.highest(/* @__PURE__ */ Mu.computeN([Yt], (t) => t.facet(Yt).defaultKeymap ? [Sk] : []));
class lH {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.diagnostic = n;
  }
}
class Rs {
  constructor(e, r, n) {
    this.diagnostics = e, this.panel = r, this.selected = n;
  }
  static init(e, r, n) {
    let i = e, s = n.facet(Ek).markerFilter;
    s && (i = s(i, n));
    let a = be.set(i.map((o) => o.from == o.to || o.from == o.to - 1 && n.doc.lineAt(o.from).to == o.from ? be.widget({
      widget: new yH(o),
      diagnostic: o
    }).range(o.from) : be.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + o.severity + (o.markClass ? " " + o.markClass : "") },
      diagnostic: o,
      inclusive: !0
    }).range(o.from, o.to)), !0);
    return new Rs(a, r, yo(a));
  }
}
function yo(t, e = null, r = 0) {
  let n = null;
  return t.between(r, 1e9, (i, s, { spec: a }) => {
    if (!(e && a.diagnostic != e))
      return n = new lH(i, s, a.diagnostic), !1;
  }), n;
}
function uH(t, e) {
  let r = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((n) => n.is(wk)) || t.changes.touchesRange(r.from, r.to));
}
function cH(t, e) {
  return t.field(Ur, !1) ? e : e.concat(Ae.appendConfig.of(bH));
}
const wk = /* @__PURE__ */ Ae.define(), H0 = /* @__PURE__ */ Ae.define(), Ck = /* @__PURE__ */ Ae.define(), Ur = /* @__PURE__ */ Rt.define({
  create() {
    return new Rs(be.none, null, null);
  },
  update(t, e) {
    if (e.docChanged) {
      let r = t.diagnostics.map(e.changes), n = null;
      if (t.selected) {
        let i = e.changes.mapPos(t.selected.from, 1);
        n = yo(r, t.selected.diagnostic, i) || yo(r, null, i);
      }
      t = new Rs(r, t.panel, n);
    }
    for (let r of e.effects)
      r.is(wk) ? t = Rs.init(r.value, t.panel, e.state) : r.is(H0) ? t = new Rs(t.diagnostics, r.value ? md.open : null, t.selected) : r.is(Ck) && (t = new Rs(t.diagnostics, t.panel, r.value));
    return t;
  },
  provide: (t) => [
    su.from(t, (e) => e.panel),
    ue.decorations.from(t, (e) => e.diagnostics)
  ]
}), hH = /* @__PURE__ */ be.mark({ class: "cm-lintRange cm-lintRange-active", inclusive: !0 });
function pH(t, e, r) {
  let { diagnostics: n } = t.state.field(Ur), i = [], s = 2e8, a = 0;
  n.between(e - (r < 0 ? 1 : 0), e + (r > 0 ? 1 : 0), (u, c, { spec: h }) => {
    e >= u && e <= c && (u == c || (e > u || r > 0) && (e < c || r < 0)) && (i.push(h.diagnostic), s = Math.min(u, s), a = Math.max(c, a));
  });
  let o = t.state.facet(Ek).tooltipFilter;
  return o && (i = o(i, t.state)), i.length ? {
    pos: s,
    end: a,
    above: t.state.doc.lineAt(s).to < a,
    create() {
      return { dom: dH(t, i) };
    }
  } : null;
}
function dH(t, e) {
  return at("ul", { class: "cm-tooltip-lint" }, e.map((r) => Tk(t, r, !1)));
}
const fH = (t) => {
  let e = t.state.field(Ur, !1);
  (!e || !e.panel) && t.dispatch({ effects: cH(t.state, [H0.of(!0)]) });
  let r = iu(t, md.open);
  return r && r.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, oD = (t) => {
  let e = t.state.field(Ur, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: H0.of(!1) }), !0);
}, mH = (t) => {
  let e = t.state.field(Ur, !1);
  if (!e)
    return !1;
  let r = t.state.selection.main, n = e.diagnostics.iter(r.to + 1);
  return !n.value && (n = e.diagnostics.iter(0), !n.value || n.from == r.from && n.to == r.to) ? !1 : (t.dispatch({ selection: { anchor: n.from, head: n.to }, scrollIntoView: !0 }), !0);
}, gH = [
  { key: "Mod-Shift-m", run: fH, preventDefault: !0 },
  { key: "F8", run: mH }
], Ek = /* @__PURE__ */ me.define({
  combine(t) {
    return Object.assign({ sources: t.map((e) => e.source).filter((e) => e != null) }, di(t.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (e, r) => e ? r ? (n) => e(n) || r(n) : e : r
    }));
  }
});
function Ak(t) {
  let e = [];
  if (t)
    e:
      for (let { name: r } of t) {
        for (let n = 0; n < r.length; n++) {
          let i = r[n];
          if (/[a-zA-Z]/.test(i) && !e.some((s) => s.toLowerCase() == i.toLowerCase())) {
            e.push(i);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function Tk(t, e, r) {
  var n;
  let i = r ? Ak(e.actions) : [];
  return at("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, at("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (n = e.actions) === null || n === void 0 ? void 0 : n.map((s, a) => {
    let o = !1, u = (m) => {
      if (m.preventDefault(), o)
        return;
      o = !0;
      let g = yo(t.state.field(Ur).diagnostics, e);
      g && s.apply(t, g.from, g.to);
    }, { name: c } = s, h = i[a] ? c.indexOf(i[a]) : -1, p = h < 0 ? c : [
      c.slice(0, h),
      at("u", c.slice(h, h + 1)),
      c.slice(h + 1)
    ];
    return at("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: u,
      onmousedown: u,
      "aria-label": ` Action: ${c}${h < 0 ? "" : ` (access key "${i[a]})"`}.`
    }, p);
  }), e.source && at("div", { class: "cm-diagnosticSource" }, e.source));
}
class yH extends fi {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return at("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class lD {
  constructor(e, r) {
    this.diagnostic = r, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = Tk(e, r, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class md {
  constructor(e) {
    this.view = e, this.items = [];
    let r = (i) => {
      if (i.keyCode == 27)
        oD(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], a = Ak(s.actions);
        for (let o = 0; o < a.length; o++)
          if (a[o].toUpperCase().charCodeAt(0) == i.keyCode) {
            let u = yo(this.view.state.field(Ur).diagnostics, s);
            u && s.actions[o].apply(e, u.from, u.to);
          }
      } else
        return;
      i.preventDefault();
    }, n = (i) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(i.target) && this.moveSelection(s);
    };
    this.list = at("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: r,
      onclick: n
    }), this.dom = at("div", { class: "cm-panel-lint" }, this.list, at("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => oD(this.view)
    }, "")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Ur).selected;
    if (!e)
      return -1;
    for (let r = 0; r < this.items.length; r++)
      if (this.items[r].diagnostic == e.diagnostic)
        return r;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: r } = this.view.state.field(Ur), n = 0, i = !1, s = null;
    for (e.between(0, this.view.state.doc.length, (a, o, { spec: u }) => {
      let c = -1, h;
      for (let p = n; p < this.items.length; p++)
        if (this.items[p].diagnostic == u.diagnostic) {
          c = p;
          break;
        }
      c < 0 ? (h = new lD(this.view, u.diagnostic), this.items.splice(n, 0, h), i = !0) : (h = this.items[c], c > n && (this.items.splice(n, c - n), i = !0)), r && h.diagnostic == r.diagnostic ? h.dom.hasAttribute("aria-selected") || (h.dom.setAttribute("aria-selected", "true"), s = h) : h.dom.hasAttribute("aria-selected") && h.dom.removeAttribute("aria-selected"), n++;
    }); n < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new lD(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: a, panel: o }) => {
        let u = o.height / this.list.offsetHeight;
        a.top < o.top ? this.list.scrollTop -= (o.top - a.top) / u : a.bottom > o.bottom && (this.list.scrollTop += (a.bottom - o.bottom) / u);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function r() {
      let n = e;
      e = n.nextSibling, n.remove();
    }
    for (let n of this.items)
      if (n.dom.parentNode == this.list) {
        for (; e != n.dom; )
          r();
        e = n.dom.nextSibling;
      } else
        this.list.insertBefore(n.dom, e);
    for (; e; )
      r();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let r = this.view.state.field(Ur), n = yo(r.diagnostics, this.items[e].diagnostic);
    n && this.view.dispatch({
      selection: { anchor: n.from, head: n.to },
      scrollIntoView: !0,
      effects: Ck.of(n)
    });
  }
  static open(e) {
    return new md(e);
  }
}
function OH(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function Wc(t) {
  return OH(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const xH = /* @__PURE__ */ ue.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Wc("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Wc("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Wc("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Wc("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), bH = [
  Ur,
  /* @__PURE__ */ ue.decorations.compute([Ur], (t) => {
    let { selected: e, panel: r } = t.field(Ur);
    return !e || !r || e.from == e.to ? be.none : be.set([
      hH.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ lY(pH, { hideOn: uH }),
  xH
];
var uD = function(e) {
  e === void 0 && (e = {});
  var {
    crosshairCursor: r = !1
  } = e, n = [];
  e.closeBracketsKeymap !== !1 && (n = n.concat(KG)), e.defaultKeymap !== !1 && (n = n.concat(Rz)), e.searchKeymap !== !1 && (n = n.concat(hG)), e.historyKeymap !== !1 && (n = n.concat(zU)), e.foldKeymap !== !1 && (n = n.concat(cU)), e.completionKeymap !== !1 && (n = n.concat(Sk)), e.lintKeymap !== !1 && (n = n.concat(gH));
  var i = [];
  return e.lineNumbers !== !1 && i.push(yY()), e.highlightActiveLineGutter !== !1 && i.push(bY()), e.highlightSpecialChars !== !1 && i.push(QV()), e.history !== !1 && i.push(RU()), e.foldGutter !== !1 && i.push(fU()), e.drawSelection !== !1 && i.push(EV()), e.dropCursor !== !1 && i.push(FV()), e.allowMultipleSelections !== !1 && i.push(Le.allowMultipleSelections.of(!0)), e.indentOnInput !== !1 && i.push(tU()), e.syntaxHighlighting !== !1 && i.push(gT(OU, {
    fallback: !0
  })), e.bracketMatching !== !1 && i.push(CU()), e.closeBrackets !== !1 && i.push(zG()), e.autocompletion !== !1 && i.push(aH()), e.rectangularSelection !== !1 && i.push(HV()), r !== !1 && i.push(eY()), e.highlightActiveLine !== !1 && i.push(WV()), e.highlightSelectionMatches !== !1 && i.push(Vz()), e.tabSize && typeof e.tabSize == "number" && i.push(ju.of(" ".repeat(e.tabSize))), i.concat([Mu.of(n.flat())]).filter(Boolean);
};
const DH = "#e5c07b", cD = "#e06c75", vH = "#56b6c2", SH = "#ffffff", ch = "#abb2bf", Eg = "#7d8799", wH = "#61afef", CH = "#98c379", hD = "#d19a66", EH = "#c678dd", AH = "#21252b", pD = "#2c313a", dD = "#282c34", kf = "#353a42", TH = "#3E4451", fD = "#528bff", kH = /* @__PURE__ */ ue.theme({
  "&": {
    color: ch,
    backgroundColor: dD
  },
  ".cm-content": {
    caretColor: fD
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: fD },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: TH },
  ".cm-panels": { backgroundColor: AH, color: ch },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: dD,
    color: Eg,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: pD
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: kf
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: kf,
    borderBottomColor: kf
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: pD,
      color: ch
    }
  }
}, { dark: !0 }), PH = /* @__PURE__ */ Xu.define([
  {
    tag: Q.keyword,
    color: EH
  },
  {
    tag: [Q.name, Q.deleted, Q.character, Q.propertyName, Q.macroName],
    color: cD
  },
  {
    tag: [/* @__PURE__ */ Q.function(Q.variableName), Q.labelName],
    color: wH
  },
  {
    tag: [Q.color, /* @__PURE__ */ Q.constant(Q.name), /* @__PURE__ */ Q.standard(Q.name)],
    color: hD
  },
  {
    tag: [/* @__PURE__ */ Q.definition(Q.name), Q.separator],
    color: ch
  },
  {
    tag: [Q.typeName, Q.className, Q.number, Q.changed, Q.annotation, Q.modifier, Q.self, Q.namespace],
    color: DH
  },
  {
    tag: [Q.operator, Q.operatorKeyword, Q.url, Q.escape, Q.regexp, Q.link, /* @__PURE__ */ Q.special(Q.string)],
    color: vH
  },
  {
    tag: [Q.meta, Q.comment],
    color: Eg
  },
  {
    tag: Q.strong,
    fontWeight: "bold"
  },
  {
    tag: Q.emphasis,
    fontStyle: "italic"
  },
  {
    tag: Q.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: Q.link,
    color: Eg,
    textDecoration: "underline"
  },
  {
    tag: Q.heading,
    fontWeight: "bold",
    color: cD
  },
  {
    tag: [Q.atom, Q.bool, /* @__PURE__ */ Q.special(Q.variableName)],
    color: hD
  },
  {
    tag: [Q.processingInstruction, Q.string, Q.inserted],
    color: CH
  },
  {
    tag: Q.invalid,
    color: SH
  }
]), FH = [kH, /* @__PURE__ */ gT(PH)];
var $H = ue.theme({
  "&": {
    backgroundColor: "#fff"
  }
}, {
  dark: !1
}), BH = function(e) {
  e === void 0 && (e = {});
  var {
    indentWithTab: r = !0,
    editable: n = !0,
    readOnly: i = !1,
    theme: s = "light",
    placeholder: a = "",
    basicSetup: o = !0
  } = e, u = [];
  switch (r && u.unshift(Mu.of([jz])), o && (typeof o == "boolean" ? u.unshift(uD()) : u.unshift(uD(o))), a && u.unshift(YV(a)), s) {
    case "light":
      u.push($H);
      break;
    case "dark":
      u.push(FH);
      break;
    case "none":
      break;
    default:
      u.push(s);
      break;
  }
  return n === !1 && u.push(ue.editable.of(!1)), i && u.push(Le.readOnly.of(!0)), [...u];
}, IH = (t) => ({
  line: t.state.doc.lineAt(t.state.selection.main.from),
  lineCount: t.state.doc.lines,
  lineBreak: t.state.lineBreak,
  length: t.state.doc.length,
  readOnly: t.state.readOnly,
  tabSize: t.state.tabSize,
  selection: t.state.selection,
  selectionAsSingle: t.state.selection.asSingle().main,
  ranges: t.state.selection.ranges,
  selectionCode: t.state.sliceDoc(t.state.selection.main.from, t.state.selection.main.to),
  selections: t.state.selection.ranges.map((e) => t.state.sliceDoc(e.from, e.to)),
  selectedText: t.state.selection.ranges.some((e) => !e.empty)
}), mD = pi.define(), NH = [];
function _H(t) {
  var {
    value: e,
    selection: r,
    onChange: n,
    onStatistics: i,
    onCreateEditor: s,
    onUpdate: a,
    extensions: o = NH,
    autoFocus: u,
    theme: c = "light",
    height: h = null,
    minHeight: p = null,
    maxHeight: m = null,
    width: g = null,
    minWidth: O = null,
    maxWidth: b = null,
    placeholder: D = "",
    editable: S = !0,
    readOnly: x = !1,
    indentWithTab: w = !0,
    basicSetup: T = !0,
    root: C,
    initialState: A
  } = t, [P, $] = At(), [B, _] = At(), [M, Y] = At(), J = ue.theme({
    "&": {
      height: h,
      minHeight: p,
      maxHeight: m,
      width: g,
      minWidth: O,
      maxWidth: b
    },
    "& .cm-scroller": {
      height: "100% !important"
    }
  }), R = ue.updateListener.of((H) => {
    if (H.docChanged && typeof n == "function" && // Fix echoing of the remote changes:
    // If transaction is market as remote we don't have to call `onChange` handler again
    !H.transactions.some((Se) => Se.annotation(mD))) {
      var ye = H.state.doc, Ce = ye.toString();
      n(Ce, H);
    }
    i && i(IH(H));
  }), q = BH({
    theme: c,
    editable: S,
    readOnly: x,
    placeholder: D,
    indentWithTab: w,
    basicSetup: T
  }), X = [R, J, ...q];
  return a && typeof a == "function" && X.push(ue.updateListener.of(a)), X = X.concat(o), Qe(() => {
    if (P && !M) {
      var H = {
        doc: e,
        selection: r,
        extensions: X
      }, ye = A ? Le.fromJSON(A.json, H, A.fields) : Le.create(H);
      if (Y(ye), !B) {
        var Ce = new ue({
          state: ye,
          parent: P,
          root: C
        });
        _(Ce), s && s(Ce, ye);
      }
    }
    return () => {
      B && (Y(void 0), _(void 0));
    };
  }, [P, M]), Qe(() => $(t.container), [t.container]), Qe(() => () => {
    B && (B.destroy(), _(void 0));
  }, [B]), Qe(() => {
    u && B && B.focus();
  }, [u, B]), Qe(() => {
    B && B.dispatch({
      effects: Ae.reconfigure.of(X)
    });
  }, [c, o, h, p, m, g, O, b, D, S, x, w, T, n, a]), Qe(() => {
    if (e !== void 0) {
      var H = B ? B.state.doc.toString() : "";
      B && e !== H && B.dispatch({
        changes: {
          from: 0,
          to: H.length,
          insert: e || ""
        },
        annotations: [mD.of(!0)]
      });
    }
  }, [e, B]), {
    state: M,
    setState: Y,
    view: B,
    setView: _,
    container: P,
    setContainer: $
  };
}
var QH = ["className", "value", "selection", "extensions", "onChange", "onStatistics", "onCreateEditor", "onUpdate", "autoFocus", "theme", "height", "minHeight", "maxHeight", "width", "minWidth", "maxWidth", "basicSetup", "placeholder", "indentWithTab", "editable", "readOnly", "root", "initialState"], kk = /* @__PURE__ */ OF((t, e) => {
  var {
    className: r,
    value: n = "",
    selection: i,
    extensions: s = [],
    onChange: a,
    onStatistics: o,
    onCreateEditor: u,
    onUpdate: c,
    autoFocus: h,
    theme: p = "light",
    height: m,
    minHeight: g,
    maxHeight: O,
    width: b,
    minWidth: D,
    maxWidth: S,
    basicSetup: x,
    placeholder: w,
    indentWithTab: T,
    editable: C,
    readOnly: A,
    root: P,
    initialState: $
  } = t, B = Eq(t, QH), _ = et(null), {
    state: M,
    view: Y,
    container: J
  } = _H({
    container: _.current,
    root: P,
    value: n,
    autoFocus: h,
    theme: p,
    height: m,
    minHeight: g,
    maxHeight: O,
    width: b,
    minWidth: D,
    maxWidth: S,
    basicSetup: x,
    placeholder: w,
    indentWithTab: T,
    editable: C,
    readOnly: A,
    selection: i,
    onChange: a,
    onStatistics: o,
    onCreateEditor: u,
    onUpdate: c,
    extensions: s,
    initialState: $
  });
  if (xF(e, () => ({
    editor: _.current,
    state: M,
    view: Y
  }), [_, J, M, Y]), typeof n != "string")
    throw new Error("value must be typeof string but got " + typeof n);
  var R = typeof p == "string" ? "cm-theme-" + p : "cm-theme";
  return /* @__PURE__ */ z.jsx("div", Pm({
    ref: _,
    className: "" + R + (r ? " " + r : "")
  }, B));
});
kk.displayName = "CodeMirror";
class ep {
  /**
  @internal
  */
  constructor(e, r, n, i, s, a, o, u, c, h = 0, p) {
    this.p = e, this.stack = r, this.state = n, this.reducePos = i, this.pos = s, this.score = a, this.buffer = o, this.bufferBase = u, this.curContext = c, this.lookAhead = h, this.parent = p;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, r) => r % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, r, n = 0) {
    let i = e.parser.context;
    return new ep(e, [], r, n, n, 0, [], 0, i ? new gD(i, i.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, r) {
    this.stack.push(this.state, r, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var r;
    let n = e >> 19, i = e & 65535, { parser: s } = this.p, a = s.dynamicPrecedence(i);
    if (a && (this.score += a), n == 0) {
      this.pushState(s.getGoto(this.state, i, !0), this.reducePos), i < s.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0), this.reduceContext(i, this.reducePos);
      return;
    }
    let o = this.stack.length - (n - 1) * 3 - (e & 262144 ? 6 : 0), u = o ? this.stack[o - 2] : this.p.ranges[0].from, c = this.reducePos - u;
    c >= 2e3 && !(!((r = this.p.parser.nodeSet.types[i]) === null || r === void 0) && r.isAnonymous) && (u == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = c) : this.p.lastBigReductionSize < c && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = u, this.p.lastBigReductionSize = c));
    let h = o ? this.stack[o - 1] : 0, p = this.bufferBase + this.buffer.length - h;
    if (i < s.minRepeatTerm || e & 131072) {
      let m = s.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(i, u, m, p + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[o];
    else {
      let m = this.stack[o - 3];
      this.state = s.getGoto(m, i, !0);
    }
    for (; this.stack.length > o; )
      this.stack.pop();
    this.reduceContext(i, u);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, r, n, i = 4, s = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let a = this, o = this.buffer.length;
      if (o == 0 && a.parent && (o = a.bufferBase - a.parent.bufferBase, a = a.parent), o > 0 && a.buffer[o - 4] == 0 && a.buffer[o - 1] > -1) {
        if (r == n)
          return;
        if (a.buffer[o - 2] >= r) {
          a.buffer[o - 2] = n;
          return;
        }
      }
    }
    if (!s || this.pos == n)
      this.buffer.push(e, r, n, i);
    else {
      let a = this.buffer.length;
      if (a > 0 && this.buffer[a - 4] != 0)
        for (; a > 0 && this.buffer[a - 2] > n; )
          this.buffer[a] = this.buffer[a - 4], this.buffer[a + 1] = this.buffer[a - 3], this.buffer[a + 2] = this.buffer[a - 2], this.buffer[a + 3] = this.buffer[a - 1], a -= 4, i > 4 && (i -= 4);
      this.buffer[a] = e, this.buffer[a + 1] = r, this.buffer[a + 2] = n, this.buffer[a + 3] = i;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, r, n, i) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = i, this.shiftContext(r, n), r <= this.p.parser.maxNode && this.buffer.push(r, n, i, 4);
    else {
      let s = e, { parser: a } = this.p;
      (i > this.pos || r <= a.maxNode) && (this.pos = i, a.stateFlag(
        s,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(s, n), this.shiftContext(r, n), r <= a.maxNode && this.buffer.push(r, n, i, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, r, n, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, r, n, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, r) {
    let n = this.p.reused.length - 1;
    (n < 0 || this.p.reused[n] != e) && (this.p.reused.push(e), n++);
    let i = this.pos;
    this.reducePos = this.pos = i + e.length, this.pushState(r, i), this.buffer.push(
      n,
      i,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, r = e.buffer.length;
    for (; r > 0 && e.buffer[r - 2] > e.reducePos; )
      r -= 4;
    let n = e.buffer.slice(r), i = e.bufferBase + r;
    for (; e && i == e.bufferBase; )
      e = e.parent;
    return new ep(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, n, i, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, r) {
    let n = e <= this.p.parser.maxNode;
    n && this.storeNode(e, this.pos, r, 4), this.storeNode(0, this.pos, r, n ? 8 : 4), this.pos = this.reducePos = r, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let r = new MH(this); ; ) {
      let n = this.p.parser.stateSlot(
        r.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(r.state, e);
      if (n == 0)
        return !1;
      if (!(n & 65536))
        return !0;
      r.reduce(n);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let r = this.p.parser.nextStates(this.state);
    if (r.length > 8 || this.stack.length >= 120) {
      let i = [];
      for (let s = 0, a; s < r.length; s += 2)
        (a = r[s + 1]) != this.state && this.p.parser.hasAction(a, e) && i.push(r[s], a);
      if (this.stack.length < 120)
        for (let s = 0; i.length < 8 && s < r.length; s += 2) {
          let a = r[s + 1];
          i.some((o, u) => u & 1 && o == a) || i.push(r[s], a);
        }
      r = i;
    }
    let n = [];
    for (let i = 0; i < r.length && n.length < 4; i += 2) {
      let s = r[i + 1];
      if (s == this.state)
        continue;
      let a = this.split();
      a.pushState(s, this.pos), a.storeNode(0, a.pos, a.pos, 4, !0), a.shiftContext(r[i], this.pos), a.reducePos = this.pos, a.score -= 200, n.push(a);
    }
    return n;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, r = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(r & 65536))
      return !1;
    if (!e.validAction(this.state, r)) {
      let n = r >> 19, i = r & 65535, s = this.stack.length - n * 3;
      if (s < 0 || e.getGoto(this.stack[s], i, !1) < 0) {
        let a = this.findForcedReduction();
        if (a == null)
          return !1;
        r = a;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(r), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, r = [], n = (i, s) => {
      if (!r.includes(i))
        return r.push(i), e.allActions(i, (a) => {
          if (!(a & 393216))
            if (a & 65536) {
              let o = (a >> 19) - s;
              if (o > 1) {
                let u = a & 65535, c = this.stack.length - o * 3;
                if (c >= 0 && e.getGoto(this.stack[c], u, !1) >= 0)
                  return o << 19 | 65536 | u;
              }
            } else {
              let o = n(a, s + 1);
              if (o != null)
                return o;
            }
        });
    };
    return n(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let r = 0; r < this.stack.length; r += 3)
      if (this.stack[r] != e.stack[r])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, r) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  reduceContext(e, r) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let r = new gD(this.curContext.tracker, e);
      r.hash != this.curContext.hash && this.emitContext(), this.curContext = r;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class gD {
  constructor(e, r) {
    this.tracker = e, this.context = r, this.hash = e.strict ? e.hash(r) : 0;
  }
}
class MH {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let r = e & 65535, n = e >> 19;
    n == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (n - 1) * 3;
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], r, !0);
    this.state = i;
  }
}
class tp {
  constructor(e, r, n) {
    this.stack = e, this.pos = r, this.index = n, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, r = e.bufferBase + e.buffer.length) {
    return new tp(e, r, r - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new tp(this.stack, this.pos, this.index);
  }
}
function Ol(t, e = Uint16Array) {
  if (typeof t != "string")
    return t;
  let r = null;
  for (let n = 0, i = 0; n < t.length; ) {
    let s = 0;
    for (; ; ) {
      let a = t.charCodeAt(n++), o = !1;
      if (a == 126) {
        s = 65535;
        break;
      }
      a >= 92 && a--, a >= 34 && a--;
      let u = a - 32;
      if (u >= 46 && (u -= 46, o = !0), s += u, o)
        break;
      s *= 46;
    }
    r ? r[i++] = s : r = new e(s);
  }
  return r;
}
class hh {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const yD = new hh();
class LH {
  /**
  @internal
  */
  constructor(e, r) {
    this.input = e, this.ranges = r, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = yD, this.rangeIndex = 0, this.pos = this.chunkPos = r[0].from, this.range = r[0], this.end = r[r.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, r) {
    let n = this.range, i = this.rangeIndex, s = this.pos + e;
    for (; s < n.from; ) {
      if (!i)
        return null;
      let a = this.ranges[--i];
      s -= n.from - a.to, n = a;
    }
    for (; r < 0 ? s > n.to : s >= n.to; ) {
      if (i == this.ranges.length - 1)
        return null;
      let a = this.ranges[++i];
      s += a.from - n.to, n = a;
    }
    return s;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let r of this.ranges)
      if (r.to > e)
        return Math.max(e, r.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingwhen looking forwardor even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let r = this.chunkOff + e, n, i;
    if (r >= 0 && r < this.chunk.length)
      n = this.pos + e, i = this.chunk.charCodeAt(r);
    else {
      let s = this.resolveOffset(e, 1);
      if (s == null)
        return -1;
      if (n = s, n >= this.chunk2Pos && n < this.chunk2Pos + this.chunk2.length)
        i = this.chunk2.charCodeAt(n - this.chunk2Pos);
      else {
        let a = this.rangeIndex, o = this.range;
        for (; o.to <= n; )
          o = this.ranges[++a];
        this.chunk2 = this.input.chunk(this.chunk2Pos = n), n + this.chunk2.length > o.to && (this.chunk2 = this.chunk2.slice(0, o.to - n)), i = this.chunk2.charCodeAt(0);
      }
    }
    return n >= this.token.lookAhead && (this.token.lookAhead = n + 1), i;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, r = 0) {
    let n = r ? this.resolveOffset(r, -1) : this.pos;
    if (n == null || n < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = n;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, r) {
    this.token.value = e, this.token.end = r;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: r } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = r, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), r = this.pos + e.length;
      this.chunk = r > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, r) {
    if (r ? (this.token = r, r.start = e, r.lookAhead = e + 1, r.value = r.extended = -1) : this.token = yD, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, r) {
    if (e >= this.chunkPos && r <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, r - this.chunkPos);
    if (e >= this.chunk2Pos && r <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, r - this.chunk2Pos);
    if (e >= this.range.from && r <= this.range.to)
      return this.input.read(e, r);
    let n = "";
    for (let i of this.ranges) {
      if (i.from >= r)
        break;
      i.to > e && (n += this.input.read(Math.max(i.from, e), Math.min(i.to, r)));
    }
    return n;
  }
}
class no {
  constructor(e, r) {
    this.data = e, this.id = r;
  }
  token(e, r) {
    let { parser: n } = r.p;
    Pk(this.data, e, r, this.id, n.data, n.tokenPrecTable);
  }
}
no.prototype.contextual = no.prototype.fallback = no.prototype.extend = !1;
class rp {
  constructor(e, r, n) {
    this.precTable = r, this.elseToken = n, this.data = typeof e == "string" ? Ol(e) : e;
  }
  token(e, r) {
    let n = e.pos, i = 0;
    for (; ; ) {
      let s = e.next < 0, a = e.resolveOffset(1, 1);
      if (Pk(this.data, e, r, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (s || i++, a == null)
        break;
      e.reset(a, e.token);
    }
    i && (e.reset(n, e.token), e.acceptToken(this.elseToken, i));
  }
}
rp.prototype.contextual = no.prototype.fallback = no.prototype.extend = !1;
class Rn {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, r = {}) {
    this.token = e, this.contextual = !!r.contextual, this.fallback = !!r.fallback, this.extend = !!r.extend;
  }
}
function Pk(t, e, r, n, i, s) {
  let a = 0, o = 1 << n, { dialect: u } = r.p.parser;
  e:
    for (; o & t[a]; ) {
      let c = t[a + 1];
      for (let g = a + 3; g < c; g += 2)
        if ((t[g + 1] & o) > 0) {
          let O = t[g];
          if (u.allows(O) && (e.token.value == -1 || e.token.value == O || RH(O, e.token.value, i, s))) {
            e.acceptToken(O);
            break;
          }
        }
      let h = e.next, p = 0, m = t[a + 2];
      if (e.next < 0 && m > p && t[c + m * 3 - 3] == 65535) {
        a = t[c + m * 3 - 1];
        continue e;
      }
      for (; p < m; ) {
        let g = p + m >> 1, O = c + g + (g << 1), b = t[O], D = t[O + 1] || 65536;
        if (h < b)
          m = g;
        else if (h >= D)
          p = g + 1;
        else {
          a = t[O + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function OD(t, e, r) {
  for (let n = e, i; (i = t[n]) != 65535; n++)
    if (i == r)
      return n - e;
  return -1;
}
function RH(t, e, r, n) {
  let i = OD(r, n, e);
  return i < 0 || OD(r, n, t) < i;
}
const Lr = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let Pf = null;
function xD(t, e, r) {
  let n = t.cursor(ot.IncludeAnonymous);
  for (n.moveTo(e); ; )
    if (!(r < 0 ? n.childBefore(e) : n.childAfter(e)))
      for (; ; ) {
        if ((r < 0 ? n.to < e : n.from > e) && !n.type.isError)
          return r < 0 ? Math.max(0, Math.min(
            n.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(t.length, Math.max(
            n.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (r < 0 ? n.prevSibling() : n.nextSibling())
          break;
        if (!n.parent())
          return r < 0 ? 0 : t.length;
      }
}
class jH {
  constructor(e, r) {
    this.fragments = e, this.nodeSet = r, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? xD(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? xD(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let r = this.trees.length - 1;
      if (r < 0)
        return this.nextFragment(), null;
      let n = this.trees[r], i = this.index[r];
      if (i == n.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = n.children[i], a = this.start[r] + n.positions[i];
      if (a > e)
        return this.nextStart = a, null;
      if (s instanceof Ot) {
        if (a == e) {
          if (a < this.safeFrom)
            return null;
          let o = a + s.length;
          if (o <= this.safeTo) {
            let u = s.prop($e.lookAhead);
            if (!u || o + u < this.fragment.to)
              return s;
          }
        }
        this.index[r]++, a + s.length >= Math.max(this.safeFrom, e) && (this.trees.push(s), this.start.push(a), this.index.push(0));
      } else
        this.index[r]++, this.nextStart = a + s.length;
    }
  }
}
class ZH {
  constructor(e, r) {
    this.stream = r, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((n) => new hh());
  }
  getActions(e) {
    let r = 0, n = null, { parser: i } = e.p, { tokenizers: s } = i, a = i.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), o = e.curContext ? e.curContext.hash : 0, u = 0;
    for (let c = 0; c < s.length; c++) {
      if (!(1 << c & a))
        continue;
      let h = s[c], p = this.tokens[c];
      if (!(n && !h.fallback) && ((h.contextual || p.start != e.pos || p.mask != a || p.context != o) && (this.updateCachedToken(p, h, e), p.mask = a, p.context = o), p.lookAhead > p.end + 25 && (u = Math.max(p.lookAhead, u)), p.value != 0)) {
        let m = r;
        if (p.extended > -1 && (r = this.addActions(e, p.extended, p.end, r)), r = this.addActions(e, p.value, p.end, r), !h.extend && (n = p, r > m))
          break;
      }
    }
    for (; this.actions.length > r; )
      this.actions.pop();
    return u && e.setLookAhead(u), !n && e.pos == this.stream.end && (n = new hh(), n.value = e.p.parser.eofTerm, n.start = n.end = e.pos, r = this.addActions(e, n.value, n.end, r)), this.mainToken = n, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let r = new hh(), { pos: n, p: i } = e;
    return r.start = n, r.end = Math.min(n + 1, i.stream.end), r.value = n == i.stream.end ? i.parser.eofTerm : 0, r;
  }
  updateCachedToken(e, r, n) {
    let i = this.stream.clipPos(n.pos);
    if (r.token(this.stream.reset(i, e), n), e.value > -1) {
      let { parser: s } = n.p;
      for (let a = 0; a < s.specialized.length; a++)
        if (s.specialized[a] == e.value) {
          let o = s.specializers[a](this.stream.read(e.start, e.end), n);
          if (o >= 0 && n.p.parser.dialect.allows(o >> 1)) {
            o & 1 ? e.extended = o >> 1 : e.value = o >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(i + 1);
  }
  putAction(e, r, n, i) {
    for (let s = 0; s < i; s += 3)
      if (this.actions[s] == e)
        return i;
    return this.actions[i++] = e, this.actions[i++] = r, this.actions[i++] = n, i;
  }
  addActions(e, r, n, i) {
    let { state: s } = e, { parser: a } = e.p, { data: o } = a;
    for (let u = 0; u < 2; u++)
      for (let c = a.stateSlot(
        s,
        u ? 2 : 1
        /* ParseState.Actions */
      ); ; c += 3) {
        if (o[c] == 65535)
          if (o[c + 1] == 1)
            c = Di(o, c + 2);
          else {
            i == 0 && o[c + 1] == 2 && (i = this.putAction(Di(o, c + 2), r, n, i));
            break;
          }
        o[c] == r && (i = this.putAction(Di(o, c + 1), r, n, i));
      }
    return i;
  }
}
class WH {
  constructor(e, r, n, i) {
    this.parser = e, this.input = r, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new LH(r, i), this.tokens = new ZH(e, this.stream), this.topTerm = e.top[1];
    let { from: s } = i[0];
    this.stacks = [ep.start(this, e.top[0], s)], this.fragments = n.length && this.stream.end - s > e.bufferLength * 4 ? new jH(n, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, r = this.minStackPos, n = this.stacks = [], i, s;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [a] = e;
      for (; a.forceReduce() && a.stack.length && a.stack[a.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let a = 0; a < e.length; a++) {
      let o = e[a];
      for (; ; ) {
        if (this.tokens.mainToken = null, o.pos > r)
          n.push(o);
        else {
          if (this.advanceStack(o, n, e))
            continue;
          {
            i || (i = [], s = []), i.push(o);
            let u = this.tokens.getMainToken(o);
            s.push(u.value, u.end);
          }
        }
        break;
      }
    }
    if (!n.length) {
      let a = i && XH(i);
      if (a)
        return Lr && console.log("Finish with " + this.stackID(a)), this.stackToTree(a);
      if (this.parser.strict)
        throw Lr && i && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + r);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let a = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, s, n);
      if (a)
        return Lr && console.log("Force-finish " + this.stackID(a)), this.stackToTree(a.forceAll());
    }
    if (this.recovering) {
      let a = this.recovering == 1 ? 1 : this.recovering * 3;
      if (n.length > a)
        for (n.sort((o, u) => u.score - o.score); n.length > a; )
          n.pop();
      n.some((o) => o.reducePos > r) && this.recovering--;
    } else if (n.length > 1) {
      e:
        for (let a = 0; a < n.length - 1; a++) {
          let o = n[a];
          for (let u = a + 1; u < n.length; u++) {
            let c = n[u];
            if (o.sameState(c) || o.buffer.length > 500 && c.buffer.length > 500)
              if ((o.score - c.score || o.buffer.length - c.buffer.length) > 0)
                n.splice(u--, 1);
              else {
                n.splice(a--, 1);
                continue e;
              }
          }
        }
      n.length > 12 && n.splice(
        12,
        n.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = n[0].pos;
    for (let a = 1; a < n.length; a++)
      n[a].pos < this.minStackPos && (this.minStackPos = n[a].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, r, n) {
    let i = e.pos, { parser: s } = this, a = Lr ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict, h = c ? e.curContext.hash : 0;
      for (let p = this.fragments.nodeAt(i); p; ) {
        let m = this.parser.nodeSet.types[p.type.id] == p.type ? s.getGoto(e.state, p.type.id) : -1;
        if (m > -1 && p.length && (!c || (p.prop($e.contextHash) || 0) == h))
          return e.useNode(p, m), Lr && console.log(a + this.stackID(e) + ` (via reuse of ${s.getName(p.type.id)})`), !0;
        if (!(p instanceof Ot) || p.children.length == 0 || p.positions[0] > 0)
          break;
        let g = p.children[0];
        if (g instanceof Ot && p.positions[0] == 0)
          p = g;
        else
          break;
      }
    }
    let o = s.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (o > 0)
      return e.reduce(o), Lr && console.log(a + this.stackID(e) + ` (via always-reduce ${s.getName(
        o & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let u = this.tokens.getActions(e);
    for (let c = 0; c < u.length; ) {
      let h = u[c++], p = u[c++], m = u[c++], g = c == u.length || !n, O = g ? e : e.split(), b = this.tokens.mainToken;
      if (O.apply(h, p, b ? b.start : O.pos, m), Lr && console.log(a + this.stackID(O) + ` (via ${h & 65536 ? `reduce of ${s.getName(
        h & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${s.getName(p)} @ ${i}${O == e ? "" : ", split"})`), g)
        return !0;
      O.pos > i ? r.push(O) : n.push(O);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, r) {
    let n = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > n)
        return bD(e, r), !0;
    }
  }
  runRecovery(e, r, n) {
    let i = null, s = !1;
    for (let a = 0; a < e.length; a++) {
      let o = e[a], u = r[a << 1], c = r[(a << 1) + 1], h = Lr ? this.stackID(o) + " -> " : "";
      if (o.deadEnd && (s || (s = !0, o.restart(), Lr && console.log(h + this.stackID(o) + " (restarted)"), this.advanceFully(o, n))))
        continue;
      let p = o.split(), m = h;
      for (let g = 0; p.forceReduce() && g < 10 && (Lr && console.log(m + this.stackID(p) + " (via force-reduce)"), !this.advanceFully(p, n)); g++)
        Lr && (m = this.stackID(p) + " -> ");
      for (let g of o.recoverByInsert(u))
        Lr && console.log(h + this.stackID(g) + " (via recover-insert)"), this.advanceFully(g, n);
      this.stream.end > o.pos ? (c == o.pos && (c++, u = 0), o.recoverByDelete(u, c), Lr && console.log(h + this.stackID(o) + ` (via recover-delete ${this.parser.getName(u)})`), bD(o, n)) : (!i || i.score < o.score) && (i = o);
    }
    return i;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), Ot.build({
      buffer: tp.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let r = (Pf || (Pf = /* @__PURE__ */ new WeakMap())).get(e);
    return r || Pf.set(e, r = String.fromCodePoint(this.nextStackID++)), r + e;
  }
}
function bD(t, e) {
  for (let r = 0; r < e.length; r++) {
    let n = e[r];
    if (n.pos == t.pos && n.sameState(t)) {
      e[r].score < t.score && (e[r] = t);
      return;
    }
  }
  e.push(t);
}
class qH {
  constructor(e, r, n) {
    this.source = e, this.flags = r, this.disabled = n;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const Ff = (t) => t;
class Fk {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || Ff, this.reduce = e.reduce || Ff, this.reuse = e.reuse || Ff, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class la extends rT {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let r = e.nodeNames.split(" ");
    this.minRepeatTerm = r.length;
    for (let o = 0; o < e.repeatNodeCount; o++)
      r.push("");
    let n = Object.keys(e.topRules).map((o) => e.topRules[o][1]), i = [];
    for (let o = 0; o < r.length; o++)
      i.push([]);
    function s(o, u, c) {
      i[o].push([u, u.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let o of e.nodeProps) {
        let u = o[0];
        typeof u == "string" && (u = $e[u]);
        for (let c = 1; c < o.length; ) {
          let h = o[c++];
          if (h >= 0)
            s(h, u, o[c++]);
          else {
            let p = o[c + -h];
            for (let m = -h; m > 0; m--)
              s(o[c++], u, p);
            c++;
          }
        }
      }
    this.nodeSet = new F0(r.map((o, u) => xr.define({
      name: u >= this.minRepeatTerm ? void 0 : o,
      id: u,
      props: i[u],
      top: n.indexOf(u) > -1,
      error: u == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(u) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = HA;
    let a = Ol(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let o = 0; o < this.specializerSpecs.length; o++)
      this.specialized[o] = this.specializerSpecs[o].term;
    this.specializers = this.specializerSpecs.map(DD), this.states = Ol(e.states, Uint32Array), this.data = Ol(e.stateData), this.goto = Ol(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((o) => typeof o == "number" ? new no(a, o) : o), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, r, n) {
    let i = new WH(this, e, r, n);
    for (let s of this.wrappers)
      i = s(i, e, r, n);
    return i;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, r, n = !1) {
    let i = this.goto;
    if (r >= i[0])
      return -1;
    for (let s = i[r + 1]; ; ) {
      let a = i[s++], o = a & 1, u = i[s++];
      if (o && n)
        return u;
      for (let c = s + (a >> 1); s < c; s++)
        if (i[s] == e)
          return u;
      if (o)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, r) {
    let n = this.data;
    for (let i = 0; i < 2; i++)
      for (let s = this.stateSlot(
        e,
        i ? 2 : 1
        /* ParseState.Actions */
      ), a; ; s += 3) {
        if ((a = n[s]) == 65535)
          if (n[s + 1] == 1)
            a = n[s = Di(n, s + 2)];
          else {
            if (n[s + 1] == 2)
              return Di(n, s + 2);
            break;
          }
        if (a == r || a == 0)
          return Di(n, s + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, r) {
    return this.states[e * 6 + r];
  }
  /**
  @internal
  */
  stateFlag(e, r) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & r) > 0;
  }
  /**
  @internal
  */
  validAction(e, r) {
    return !!this.allActions(e, (n) => n == r ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, r) {
    let n = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), i = n ? r(n) : void 0;
    for (let s = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); i == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1)
          s = Di(this.data, s + 2);
        else
          break;
      i = r(Di(this.data, s + 1));
    }
    return i;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let r = [];
    for (let n = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; n += 3) {
      if (this.data[n] == 65535)
        if (this.data[n + 1] == 1)
          n = Di(this.data, n + 2);
        else
          break;
      if (!(this.data[n + 2] & 1)) {
        let i = this.data[n + 1];
        r.some((s, a) => a & 1 && s == i) || r.push(this.data[n], i);
      }
    }
    return r;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let r = Object.assign(Object.create(la.prototype), this);
    if (e.props && (r.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let n = this.topRules[e.top];
      if (!n)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      r.top = n;
    }
    return e.tokenizers && (r.tokenizers = this.tokenizers.map((n) => {
      let i = e.tokenizers.find((s) => s.from == n);
      return i ? i.to : n;
    })), e.specializers && (r.specializers = this.specializers.slice(), r.specializerSpecs = this.specializerSpecs.map((n, i) => {
      let s = e.specializers.find((o) => o.from == n.external);
      if (!s)
        return n;
      let a = Object.assign(Object.assign({}, n), { external: s.to });
      return r.specializers[i] = DD(a), a;
    })), e.contextTracker && (r.context = e.contextTracker), e.dialect && (r.dialect = this.parseDialect(e.dialect)), e.strict != null && (r.strict = e.strict), e.wrap && (r.wrappers = r.wrappers.concat(e.wrap)), e.bufferLength != null && (r.bufferLength = e.bufferLength), r;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let r = this.dynamicPrecedences;
    return r == null ? 0 : r[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let r = Object.keys(this.dialects), n = r.map(() => !1);
    if (e)
      for (let s of e.split(" ")) {
        let a = r.indexOf(s);
        a >= 0 && (n[a] = !0);
      }
    let i = null;
    for (let s = 0; s < r.length; s++)
      if (!n[s])
        for (let a = this.dialects[r[s]], o; (o = this.data[a++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[o] = 1;
    return new qH(e, n, i);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new la(e);
  }
}
function Di(t, e) {
  return t[e] | t[e + 1] << 16;
}
function XH(t) {
  let e = null;
  for (let r of t) {
    let n = r.p.stoppedAt;
    (r.pos == r.p.stream.end || n != null && r.pos > n) && r.p.parser.stateFlag(
      r.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < r.score) && (e = r);
  }
  return e;
}
function DD(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (r, n) => t.external(r, n) << 1 | e;
  }
  return t.get;
}
const VH = 54, YH = 1, UH = 55, zH = 2, GH = 56, HH = 3, vD = 4, JH = 5, np = 6, $k = 7, Bk = 8, Ik = 9, Nk = 10, KH = 11, eJ = 12, tJ = 13, $f = 57, rJ = 14, SD = 58, _k = 20, nJ = 22, Qk = 23, iJ = 24, Ag = 26, Mk = 27, sJ = 28, aJ = 31, oJ = 34, lJ = 36, uJ = 37, cJ = 0, hJ = 1, pJ = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, dJ = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, wD = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function fJ(t) {
  return t == 45 || t == 46 || t == 58 || t >= 65 && t <= 90 || t == 95 || t >= 97 && t <= 122 || t >= 161;
}
function Lk(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
let CD = null, ED = null, AD = 0;
function Tg(t, e) {
  let r = t.pos + e;
  if (AD == r && ED == t)
    return CD;
  let n = t.peek(e);
  for (; Lk(n); )
    n = t.peek(++e);
  let i = "";
  for (; fJ(n); )
    i += String.fromCharCode(n), n = t.peek(++e);
  return ED = t, AD = r, CD = i ? i.toLowerCase() : n == mJ || n == gJ ? void 0 : null;
}
const Rk = 60, ip = 62, J0 = 47, mJ = 63, gJ = 33, yJ = 45;
function TD(t, e) {
  this.name = t, this.parent = e, this.hash = e ? e.hash : 0;
  for (let r = 0; r < t.length; r++)
    this.hash += (this.hash << 4) + t.charCodeAt(r) + (t.charCodeAt(r) << 8);
}
const OJ = [np, Nk, $k, Bk, Ik], xJ = new Fk({
  start: null,
  shift(t, e, r, n) {
    return OJ.indexOf(e) > -1 ? new TD(Tg(n, 1) || "", t) : t;
  },
  reduce(t, e) {
    return e == _k && t ? t.parent : t;
  },
  reuse(t, e, r, n) {
    let i = e.type.id;
    return i == np || i == lJ ? new TD(Tg(n, 1) || "", t) : t;
  },
  hash(t) {
    return t ? t.hash : 0;
  },
  strict: !1
}), bJ = new Rn((t, e) => {
  if (t.next != Rk) {
    t.next < 0 && e.context && t.acceptToken($f);
    return;
  }
  t.advance();
  let r = t.next == J0;
  r && t.advance();
  let n = Tg(t, 0);
  if (n === void 0)
    return;
  if (!n)
    return t.acceptToken(r ? rJ : np);
  let i = e.context ? e.context.name : null;
  if (r) {
    if (n == i)
      return t.acceptToken(KH);
    if (i && dJ[i])
      return t.acceptToken($f, -2);
    if (e.dialectEnabled(cJ))
      return t.acceptToken(eJ);
    for (let s = e.context; s; s = s.parent)
      if (s.name == n)
        return;
    t.acceptToken(tJ);
  } else {
    if (n == "script")
      return t.acceptToken($k);
    if (n == "style")
      return t.acceptToken(Bk);
    if (n == "textarea")
      return t.acceptToken(Ik);
    if (pJ.hasOwnProperty(n))
      return t.acceptToken(Nk);
    i && wD[i] && wD[i][n] ? t.acceptToken($f, -1) : t.acceptToken(np);
  }
}, { contextual: !0 }), DJ = new Rn((t) => {
  for (let e = 0, r = 0; ; r++) {
    if (t.next < 0) {
      r && t.acceptToken(SD);
      break;
    }
    if (t.next == yJ)
      e++;
    else if (t.next == ip && e >= 2) {
      r >= 3 && t.acceptToken(SD, -2);
      break;
    } else
      e = 0;
    t.advance();
  }
});
function vJ(t) {
  for (; t; t = t.parent)
    if (t.name == "svg" || t.name == "math")
      return !0;
  return !1;
}
const SJ = new Rn((t, e) => {
  if (t.next == J0 && t.peek(1) == ip) {
    let r = e.dialectEnabled(hJ) || vJ(e.context);
    t.acceptToken(r ? JH : vD, 2);
  } else
    t.next == ip && t.acceptToken(vD, 1);
});
function K0(t, e, r) {
  let n = 2 + t.length;
  return new Rn((i) => {
    for (let s = 0, a = 0, o = 0; ; o++) {
      if (i.next < 0) {
        o && i.acceptToken(e);
        break;
      }
      if (s == 0 && i.next == Rk || s == 1 && i.next == J0 || s >= 2 && s < n && i.next == t.charCodeAt(s - 2))
        s++, a++;
      else if ((s == 2 || s == n) && Lk(i.next))
        a++;
      else if (s == n && i.next == ip) {
        o > a ? i.acceptToken(e, -a) : i.acceptToken(r, -(a - 2));
        break;
      } else if ((i.next == 10 || i.next == 13) && o) {
        i.acceptToken(e, 1);
        break;
      } else
        s = a = 0;
      i.advance();
    }
  });
}
const wJ = K0("script", VH, YH), CJ = K0("style", UH, zH), EJ = K0("textarea", GH, HH), AJ = Ru({
  "Text RawText": Q.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": Q.angleBracket,
  TagName: Q.tagName,
  "MismatchedCloseTag/TagName": [Q.tagName, Q.invalid],
  AttributeName: Q.attributeName,
  "AttributeValue UnquotedAttributeValue": Q.attributeValue,
  Is: Q.definitionOperator,
  "EntityReference CharacterReference": Q.character,
  Comment: Q.blockComment,
  ProcessingInst: Q.processingInstruction,
  DoctypeDecl: Q.documentMeta
}), TJ = la.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%WQ&rO,59fO%`Q&rO,59iO%hQ&rO,59lO%sQ&rO,59nOOOa'#D^'#D^O%{OaO'#CxO&WOaO,59[OOOb'#D_'#D_O&`ObO'#C{O&kObO,59[OOOd'#D`'#D`O&sOdO'#DOO'OOdO,59[OOO`'#Da'#DaO'WO!rO,59[O'_Q#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'dO$fO,59oOOO`,59o,59oO'lQ#|O,59qO'qQ#|O,59rOOO`-E7W-E7WO'vQ&rO'#CsOOQW'#DZ'#DZO(UQ&rO1G.wOOOa1G.w1G.wO(^Q&rO1G/QOOOb1G/Q1G/QO(fQ&rO1G/TOOOd1G/T1G/TO(nQ&rO1G/WOOO`1G/W1G/WOOO`1G/Y1G/YO(yQ&rO1G/YOOOa-E7[-E7[O)RQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)WQ#tO'#C|OOOd-E7^-E7^O)]Q#tO'#DPOOO`-E7_-E7_O)bQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O)gQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rOOO`7+$t7+$tO)rQ#|O,59eO)wQ#|O,59hO)|Q#|O,59kOOO`1G/X1G/XO*RO7[O'#CvO*dOMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O*uO7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+WOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: "+s~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OhyO~OS!OOhyO~OS!QOhyO~OS!SOT!TOhyO~OS!TOhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXhgXTgX~OS!fOhyO~OS!gOhyO~OS!hOhyO~OS!iOT!jOhyO~OS!jOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: " StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: xJ,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [AJ],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [wJ, CJ, EJ, SJ, bJ, DJ, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 485 },
  tokenPrec: 487
});
function jk(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let n of t.getChildren(Qk)) {
    let i = n.getChild(iJ), s = n.getChild(Ag) || n.getChild(Mk);
    i && (r[e.read(i.from, i.to)] = s ? s.type.id == Ag ? e.read(s.from + 1, s.to - 1) : e.read(s.from, s.to) : "");
  }
  return r;
}
function kD(t, e) {
  let r = t.getChild(nJ);
  return r ? e.read(r.from, r.to) : " ";
}
function Bf(t, e, r) {
  let n;
  for (let i of r)
    if (!i.attrs || i.attrs(n || (n = jk(t.node.parent.firstChild, e))))
      return { parser: i.parser };
  return null;
}
function Zk(t = [], e = []) {
  let r = [], n = [], i = [], s = [];
  for (let o of t)
    (o.tag == "script" ? r : o.tag == "style" ? n : o.tag == "textarea" ? i : s).push(o);
  let a = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let o of e)
    (a[o.name] || (a[o.name] = [])).push(o);
  return TY((o, u) => {
    let c = o.type.id;
    if (c == sJ)
      return Bf(o, u, r);
    if (c == aJ)
      return Bf(o, u, n);
    if (c == oJ)
      return Bf(o, u, i);
    if (c == _k && s.length) {
      let h = o.node, p = h.firstChild, m = p && kD(p, u), g;
      if (m) {
        for (let O of s)
          if (O.tag == m && (!O.attrs || O.attrs(g || (g = jk(h, u))))) {
            let b = h.lastChild, D = b.type.id == uJ ? b.from : h.to;
            if (D > p.to)
              return { parser: O.parser, overlay: [{ from: p.to, to: D }] };
          }
      }
    }
    if (a && c == Qk) {
      let h = o.node, p;
      if (p = h.firstChild) {
        let m = a[u.read(p.from, p.to)];
        if (m)
          for (let g of m) {
            if (g.tagName && g.tagName != kD(h.parent, u))
              continue;
            let O = h.lastChild;
            if (O.type.id == Ag) {
              let b = O.from + 1, D = O.lastChild, S = O.to - (D && D.isError ? 0 : 1);
              if (S > b)
                return { parser: g.parser, overlay: [{ from: b, to: S }] };
            } else if (O.type.id == Mk)
              return { parser: g.parser, overlay: [{ from: O.from, to: O.to }] };
          }
      }
    }
    return null;
  });
}
const kJ = 99, PD = 1, PJ = 100, FJ = 101, FD = 2, Wk = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], $J = 58, BJ = 40, qk = 95, IJ = 91, ph = 45, NJ = 46, _J = 35, QJ = 37, MJ = 38, LJ = 92, RJ = 10;
function du(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 161;
}
function jJ(t) {
  return t >= 48 && t <= 57;
}
const ZJ = new Rn((t, e) => {
  for (let r = !1, n = 0, i = 0; ; i++) {
    let { next: s } = t;
    if (du(s) || s == ph || s == qk || r && jJ(s))
      !r && (s != ph || i > 0) && (r = !0), n === i && s == ph && n++, t.advance();
    else if (s == LJ && t.peek(1) != RJ)
      t.advance(), t.next > -1 && t.advance(), r = !0;
    else {
      r && t.acceptToken(s == BJ ? PJ : n == 2 && e.canShift(FD) ? FD : FJ);
      break;
    }
  }
}), WJ = new Rn((t) => {
  if (Wk.includes(t.peek(-1))) {
    let { next: e } = t;
    (du(e) || e == qk || e == _J || e == NJ || e == IJ || e == $J && du(t.peek(1)) || e == ph || e == MJ) && t.acceptToken(kJ);
  }
}), qJ = new Rn((t) => {
  if (!Wk.includes(t.peek(-1))) {
    let { next: e } = t;
    if (e == QJ && (t.advance(), t.acceptToken(PD)), du(e)) {
      do
        t.advance();
      while (du(t.next));
      t.acceptToken(PD);
    }
  }
}), XJ = Ru({
  "AtKeyword import charset namespace keyframes media supports": Q.definitionKeyword,
  "from to selector": Q.keyword,
  NamespaceName: Q.namespace,
  KeyframeName: Q.labelName,
  KeyframeRangeName: Q.operatorKeyword,
  TagName: Q.tagName,
  ClassName: Q.className,
  PseudoClassName: Q.constant(Q.className),
  IdName: Q.labelName,
  "FeatureName PropertyName": Q.propertyName,
  AttributeName: Q.attributeName,
  NumberLiteral: Q.number,
  KeywordQuery: Q.keyword,
  UnaryQueryOp: Q.operatorKeyword,
  "CallTag ValueName": Q.atom,
  VariableName: Q.variableName,
  Callee: Q.operatorKeyword,
  Unit: Q.unit,
  "UniversalSelector NestingSelector": Q.definitionOperator,
  MatchOp: Q.compareOperator,
  "ChildOp SiblingOp, LogicOp": Q.logicOperator,
  BinOp: Q.arithmeticOperator,
  Important: Q.modifier,
  Comment: Q.blockComment,
  ColorLiteral: Q.color,
  "ParenthesizedContent StringLiteral": Q.string,
  ":": Q.punctuation,
  "PseudoOp #": Q.derefOperator,
  "; ,": Q.separator,
  "( )": Q.paren,
  "[ ]": Q.squareBracket,
  "{ }": Q.brace
}), VJ = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 138 }, YJ = { __proto__: null, "@import": 118, "@media": 142, "@charset": 146, "@namespace": 150, "@keyframes": 156, "@supports": 168 }, UJ = { __proto__: null, not: 132, only: 132 }, zJ = la.deserialize({
  version: 14,
  states: ":^QYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO${QdO,59}O-kQ[O'#E^O-xQWO,5;_O-xQWO,5;_POOO'#EV'#EVP.TO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.zQXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/XQ`O1G/^O/rQXO1G/aO0YQXO1G/cO0pQXO1G/dO1WQWO,59|O1]Q[O'#DSO1dQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1kQpO,59]OOQS,59_,59_O${QdO,59aO1sQWO1G/mOOQS,59c,59cO1xQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2QQ[O,59jOOQS,59j,59jO2YQWO'#DjO2eQWO,5:VO2jQWO,5:]O&`Q[O,5:XO&`Q[O'#E_O2rQWO,5;`O2}QWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3`QWO1G0OO3eQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO3pQtO1G/iOOQO,5:x,5:xO4WQ[O,5:xOOQO-E8[-E8[O4eQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO4pQXO'#ErO4wQWO,59nO4|QtO'#EXO5tQdO'#EoO6OQWO,59ZO6TQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XO6]QWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6bQWO,5:yOOQO-E8]-E8]O6pQXO1G/xOOQS7+%j7+%jO6wQYO'#CsOOQO'#EQ'#EQO7SQ`O'#EPOOQO'#EP'#EPO7_QWO'#E`O7gQdO,5:jOOQS,5:j,5:jO7rQtO'#E]O${QdO'#E]O8sQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9WQpO<<HdO9`QWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9hQWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO9pQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3hQdO'#EaO7_QWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO9wQtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO:xQdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
  stateData: ";[~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#wO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.`Op#yO|#zO~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/aOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/aOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/aO!S#{O~Oa#fP~P(aOa#cP~P${Oa$SOj#XO~O!Y$UO~Oh$VOo$VO~Op$XO#X#]O~O]!`Xa!^X!b!^X~O]$YO~Oa$ZO!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$`O~O!S$gO#X$bO#e$aO~Oj#XOt$iO!X$kO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$oO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$qOa#cX~P${Oa$sO~Oj#XOp$tO~Oa$uO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$wO~P.`OP#WOtgX!TgX~O#e$aOt!sX!T!sX~Ot$yO!TwO~O!S$}O#X$bO#e$aO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$iO!X%QO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%RO~OtoOa#fa~Ot$qOa#ca~Oa%UO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
  goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#skYOPdhotuvw!n#R#h#skSOPdhotuvw!n#R#h#sQmTR!tnQ{VR!xqQ!x}Q#Z!XR#x!zq![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SU$d#m$f$yR$x$cq!XZ]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#x!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ${$eR%X$zSgPwQ!phQ#r!nR$l#sZfPhw!n#sa!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$e#m$fR%V$yV$c#m$f$yQ!rjR#v!rQdOShPwU!ldh#sR#s!nQ$P#SU$p$P$v%SQ$v$YR%S$qQ#_!ZR$W#_Q$r$PR%T$rQpUS!vp$nR$n#|Q$j#qR%P$jQ!ogS#t!o#uR#u!pQ#f!_R$^#fQ$f#mR$|$fQ$z$eR%W$z_cOPdhw!n#s^UOPdhw!n#sQ!uoQ!}tQ#OuQ#PvQ#|#RR$_#hR$Q#SQ!VZQ!d]Q#V!TQ#q!m[$O#S$P$Y$q$v%SQ$R#UQ$T#XS$h#q$jQ$m#zR%O$iR#}#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$[#dR$]#e",
  nodeNames: " Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 117,
  nodeProps: [
    ["isolate", -2, 3, 24, ""],
    ["openedBy", 17, "(", 32, "[", 50, "{"],
    ["closedBy", 18, ")", 33, "]", 51, "}"]
  ],
  propSources: [XJ],
  skippedNodes: [0, 3, 87],
  repeatNodeCount: 11,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [WJ, qJ, ZJ, 1, 2, 3, 4, new rp("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~", 28, 105)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 86] },
  specialized: [{ term: 100, get: (t) => VJ[t] || -1 }, { term: 58, get: (t) => YJ[t] || -1 }, { term: 101, get: (t) => UJ[t] || -1 }],
  tokenPrec: 1200
});
let If = null;
function Nf() {
  if (!If && typeof document == "object" && document.body) {
    let { style: t } = document.body, e = [], r = /* @__PURE__ */ new Set();
    for (let n in t)
      n != "cssText" && n != "cssFloat" && typeof t[n] == "string" && (/[A-Z]/.test(n) && (n = n.replace(/[A-Z]/g, (i) => "-" + i.toLowerCase())), r.has(n) || (e.push(n), r.add(n)));
    If = e.sort().map((n) => ({ type: "property", label: n }));
  }
  return If || [];
}
const $D = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((t) => ({ type: "class", label: t })), BD = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((t) => ({ type: "keyword", label: t })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((t) => ({ type: "constant", label: t }))), GJ = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((t) => ({ type: "type", label: t })), zi = /^(\w[\w-]*|-\w[\w-]*|)$/, HJ = /^-(-[\w-]*)?$/;
function JJ(t, e) {
  var r;
  if ((t.name == "(" || t.type.isError) && (t = t.parent || t), t.name != "ArgList")
    return !1;
  let n = (r = t.parent) === null || r === void 0 ? void 0 : r.firstChild;
  return (n == null ? void 0 : n.name) != "Callee" ? !1 : e.sliceString(n.from, n.to) == "var";
}
const ID = /* @__PURE__ */ new tT(), KJ = ["Declaration"];
function eK(t) {
  for (let e = t; ; ) {
    if (e.type.isTop)
      return e;
    if (!(e = e.parent))
      return t;
  }
}
function Xk(t, e, r) {
  if (e.to - e.from > 4096) {
    let n = ID.get(e);
    if (n)
      return n;
    let i = [], s = /* @__PURE__ */ new Set(), a = e.cursor(ot.IncludeAnonymous);
    if (a.firstChild())
      do
        for (let o of Xk(t, a.node, r))
          s.has(o.label) || (s.add(o.label), i.push(o));
      while (a.nextSibling());
    return ID.set(e, i), i;
  } else {
    let n = [], i = /* @__PURE__ */ new Set();
    return e.cursor().iterate((s) => {
      var a;
      if (r(s) && s.matchContext(KJ) && ((a = s.node.nextSibling) === null || a === void 0 ? void 0 : a.name) == ":") {
        let o = t.sliceString(s.from, s.to);
        i.has(o) || (i.add(o), n.push({ label: o, type: "variable" }));
      }
    }), n;
  }
}
const tK = (t) => (e) => {
  let { state: r, pos: n } = e, i = bt(r).resolveInner(n, -1), s = i.type.isError && i.from == i.to - 1 && r.doc.sliceString(i.from, i.to) == "-";
  if (i.name == "PropertyName" || (s || i.name == "TagName") && /^(Block|Styles)$/.test(i.resolve(i.to).name))
    return { from: i.from, options: Nf(), validFor: zi };
  if (i.name == "ValueName")
    return { from: i.from, options: BD, validFor: zi };
  if (i.name == "PseudoClassName")
    return { from: i.from, options: $D, validFor: zi };
  if (t(i) || (e.explicit || s) && JJ(i, r.doc))
    return {
      from: t(i) || s ? i.from : n,
      options: Xk(r.doc, eK(i), t),
      validFor: HJ
    };
  if (i.name == "TagName") {
    for (let { parent: u } = i; u; u = u.parent)
      if (u.name == "Block")
        return { from: i.from, options: Nf(), validFor: zi };
    return { from: i.from, options: GJ, validFor: zi };
  }
  if (!e.explicit)
    return null;
  let a = i.resolve(n), o = a.childBefore(n);
  return o && o.name == ":" && a.name == "PseudoClassSelector" ? { from: n, options: $D, validFor: zi } : o && o.name == ":" && a.name == "Declaration" || a.name == "ArgList" ? { from: n, options: BD, validFor: zi } : a.name == "Block" || a.name == "Styles" ? { from: n, options: Nf(), validFor: zi } : null;
}, rK = /* @__PURE__ */ tK((t) => t.name == "VariableName"), sp = /* @__PURE__ */ aa.define({
  name: "css",
  parser: /* @__PURE__ */ zJ.configure({
    props: [
      /* @__PURE__ */ Zu.add({
        Declaration: /* @__PURE__ */ eo()
      }),
      /* @__PURE__ */ Wu.add({
        "Block KeyframeList": M0
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function Vk() {
  return new od(sp, sp.data.of({ autocomplete: rK }));
}
const nK = 309, ND = 1, iK = 2, sK = 3, aK = 310, oK = 312, lK = 313, uK = 4, cK = 5, hK = 0, kg = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], Yk = 125, pK = 59, Pg = 47, dK = 42, fK = 43, mK = 45, gK = 60, yK = 44, OK = new Fk({
  start: !1,
  shift(t, e) {
    return e == uK || e == cK || e == oK ? t : e == lK;
  },
  strict: !1
}), xK = new Rn((t, e) => {
  let { next: r } = t;
  (r == Yk || r == -1 || e.context) && t.acceptToken(aK);
}, { contextual: !0, fallback: !0 }), bK = new Rn((t, e) => {
  let { next: r } = t, n;
  kg.indexOf(r) > -1 || r == Pg && ((n = t.peek(1)) == Pg || n == dK) || r != Yk && r != pK && r != -1 && !e.context && t.acceptToken(nK);
}, { contextual: !0 }), DK = new Rn((t, e) => {
  let { next: r } = t;
  if ((r == fK || r == mK) && (t.advance(), r == t.next)) {
    t.advance();
    let n = !e.context && e.canShift(ND);
    t.acceptToken(n ? ND : iK);
  }
}, { contextual: !0 });
function _f(t, e) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t == 95 || t >= 192 || !e && t >= 48 && t <= 57;
}
const vK = new Rn((t, e) => {
  if (t.next != gK || !e.dialectEnabled(hK) || (t.advance(), t.next == Pg))
    return;
  let r = 0;
  for (; kg.indexOf(t.next) > -1; )
    t.advance(), r++;
  if (_f(t.next, !0)) {
    for (t.advance(), r++; _f(t.next, !1); )
      t.advance(), r++;
    for (; kg.indexOf(t.next) > -1; )
      t.advance(), r++;
    if (t.next == yK)
      return;
    for (let n = 0; ; n++) {
      if (n == 7) {
        if (!_f(t.next, !0))
          return;
        break;
      }
      if (t.next != "extends".charCodeAt(n))
        break;
      t.advance(), r++;
    }
  }
  t.acceptToken(sK, -r);
}), SK = Ru({
  "get set async static": Q.modifier,
  "for while do if else switch try catch finally return throw break continue default case": Q.controlKeyword,
  "in of await yield void typeof delete instanceof": Q.operatorKeyword,
  "let var const using function class extends": Q.definitionKeyword,
  "import export from": Q.moduleKeyword,
  "with debugger as new": Q.keyword,
  TemplateString: Q.special(Q.string),
  super: Q.atom,
  BooleanLiteral: Q.bool,
  this: Q.self,
  null: Q.null,
  Star: Q.modifier,
  VariableName: Q.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": Q.function(Q.variableName),
  VariableDefinition: Q.definition(Q.variableName),
  Label: Q.labelName,
  PropertyName: Q.propertyName,
  PrivatePropertyName: Q.special(Q.propertyName),
  "CallExpression/MemberExpression/PropertyName": Q.function(Q.propertyName),
  "FunctionDeclaration/VariableDefinition": Q.function(Q.definition(Q.variableName)),
  "ClassDeclaration/VariableDefinition": Q.definition(Q.className),
  PropertyDefinition: Q.definition(Q.propertyName),
  PrivatePropertyDefinition: Q.definition(Q.special(Q.propertyName)),
  UpdateOp: Q.updateOperator,
  "LineComment Hashbang": Q.lineComment,
  BlockComment: Q.blockComment,
  Number: Q.number,
  String: Q.string,
  Escape: Q.escape,
  ArithOp: Q.arithmeticOperator,
  LogicOp: Q.logicOperator,
  BitOp: Q.bitwiseOperator,
  CompareOp: Q.compareOperator,
  RegExp: Q.regexp,
  Equals: Q.definitionOperator,
  Arrow: Q.function(Q.punctuation),
  ": Spread": Q.punctuation,
  "( )": Q.paren,
  "[ ]": Q.squareBracket,
  "{ }": Q.brace,
  "InterpolationStart InterpolationEnd": Q.special(Q.brace),
  ".": Q.derefOperator,
  ", ;": Q.separator,
  "@": Q.meta,
  TypeName: Q.typeName,
  TypeDefinition: Q.definition(Q.typeName),
  "type enum interface implements namespace module declare": Q.definitionKeyword,
  "abstract global Privacy readonly override": Q.modifier,
  "is keyof unique infer": Q.operatorKeyword,
  JSXAttributeValue: Q.attributeValue,
  JSXText: Q.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": Q.angleBracket,
  "JSXIdentifier JSXNameSpacedName": Q.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": Q.attributeName,
  "JSXBuiltin/JSXIdentifier": Q.standard(Q.tagName)
}), wK = { __proto__: null, export: 18, as: 23, from: 31, default: 34, async: 39, function: 40, extends: 52, this: 56, true: 64, false: 64, null: 76, void: 80, typeof: 84, super: 102, new: 136, delete: 152, yield: 161, await: 165, class: 170, public: 227, private: 227, protected: 227, readonly: 229, instanceof: 248, satisfies: 251, in: 252, const: 254, import: 286, keyof: 339, unique: 343, infer: 349, is: 385, abstract: 405, implements: 407, type: 409, let: 412, var: 414, using: 417, interface: 423, enum: 427, namespace: 433, module: 435, declare: 439, global: 443, for: 462, of: 471, while: 474, with: 478, do: 482, if: 486, else: 488, switch: 492, case: 498, try: 504, catch: 508, finally: 512, return: 516, throw: 520, break: 524, continue: 528, debugger: 532 }, CK = { __proto__: null, async: 123, get: 125, set: 127, declare: 187, public: 189, private: 189, protected: 189, static: 191, abstract: 193, override: 195, readonly: 201, accessor: 203, new: 389 }, EK = { __proto__: null, "<": 143 }, AK = la.deserialize({
  version: 14,
  states: "$<UO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ08SO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO?MpO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DyO0fQ^O'#EROOQ07b'#EZ'#EZO1PQWO'#EWOOQO'#El'#ElOOQO'#Ie'#IeO1XQWO'#GmO1dQWO'#EkO1iQWO'#EkO3kQ08SO'#JiO6[Q08SO'#JjO6xQWO'#FZO6}Q&jO'#FqOOQ07b'#Fc'#FcO7YO,YO'#FcO7hQ7[O'#FxO9UQWO'#FwOOQ07b'#Jj'#JjOOQ07`'#Ji'#JiO9ZQWO'#GqOOQU'#KU'#KUO9fQWO'#IRO9kQ07hO'#ISOOQU'#JW'#JWOOQU'#IW'#IWQ`Q^OOO`Q^OOO%[Q^O'#DqO9sQ^O'#D}O9zQ^O'#EPO9aQWO'#GmO:RQ7[O'#CnO:aQWO'#EjO:lQWO'#EuO:qQ7[O'#FbO;`QWO'#GmOOQO'#KV'#KVO;eQWO'#KVO;sQWO'#GuO;sQWO'#GvO;sQWO'#GxO9aQWO'#G{O<jQWO'#HOO>RQWO'#CdO>cQWO'#H[O>kQWO'#HbO>kQWO'#HdO`Q^O'#HfO>kQWO'#HhO>kQWO'#HkO>pQWO'#HqO>uQ07iO'#HwO%[Q^O'#HyO?QQ07iO'#H{O?]Q07iO'#H}O9kQ07hO'#IPO?hQ08SO'#ChO@jQ`O'#DiQOQWOOO%[Q^O'#EPOAQQWO'#ESO:RQ7[O'#EjOA]QWO'#EjOAhQpO'#FbOOQU'#Cf'#CfOOQ07`'#Dn'#DnOOQ07`'#Jm'#JmO%[Q^O'#JmOOQO'#Jq'#JqOOQO'#Ib'#IbOBhQ`O'#EcOOQ07`'#Eb'#EbOCdQ07pO'#EcOCnQ`O'#EVOOQO'#Jp'#JpODSQ`O'#JqOEaQ`O'#EVOCnQ`O'#EcPEnO!0LbO'#CaPOOO)CDu)CDuOOOO'#IX'#IXOEyO!bO,59TOOQ07b,59T,59TOOOO'#IY'#IYOFXO#tO,59TO%[Q^O'#D`OOOO'#I['#I[OFgO?MpO,59xOOQ07b,59x,59xOFuQ^O'#I]OGYQWO'#JkOI[QrO'#JkO+}Q^O'#JkOIcQWO,5:OOIyQWO'#ElOJWQWO'#JyOJcQWO'#JxOJcQWO'#JxOJkQWO,5;YOJpQWO'#JwOOQ07f,5:Z,5:ZOJwQ^O,5:ZOLxQ08SO,5:eOMiQWO,5:mONSQ07hO'#JvONZQWO'#JuO9ZQWO'#JuONoQWO'#JuONwQWO,5;XON|QWO'#JuO!#UQrO'#JjOOQ07b'#Ch'#ChO%[Q^O'#ERO!#tQpO,5:rOOQO'#Jr'#JrOOQO-E<c-E<cO9aQWO,5=XO!$[QWO,5=XO!$aQ^O,5;VO!&dQ7[O'#EgO!'}QWO,5;VO!)mQ7[O'#DsO!)tQ^O'#DxO!*OQ`O,5;`O!*WQ`O,5;`O%[Q^O,5;`OOQU'#FR'#FROOQU'#FT'#FTO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aOOQU'#FX'#FXO!*fQ^O,5;rOOQ07b,5;w,5;wOOQ07b,5;x,5;xO!,iQWO,5;xOOQ07b,5;y,5;yO%[Q^O'#IiO!,qQ07hO,5<eO!&dQ7[O,5;aO!-`Q7[O,5;aO%[Q^O,5;uO!-gQ&jO'#FgO!.dQ&jO'#J}O!.OQ&jO'#J}O!.kQ&jO'#J}OOQO'#J}'#J}O!/PQ&jO,5<POOOS,5<],5<]O!/bQ^O'#FsOOOS'#Ih'#IhO7YO,YO,5;}O!/iQ&jO'#FuOOQ07b,5;},5;}O!0YQMhO'#CuOOQ07b'#Cy'#CyO!0mQWO'#CyO!0rO?MpO'#C}O!1`Q7[O,5<bO!1gQWO,5<dO!3SQ!LQO'#GSO!3aQWO'#GTO!3fQWO'#GTO!3kQ!LQO'#GXO!4jQ`O'#G]OOQO'#Gh'#GhO!(SQ7[O'#GgOOQO'#Gj'#GjO!(SQ7[O'#GiO!5]QMhO'#JdOOQ07b'#Jd'#JdO!5gQWO'#JcO!5uQWO'#JbO!5}QWO'#CtOOQ07b'#Cw'#CwOOQ07b'#DR'#DROOQ07b'#DT'#DTO1SQWO'#DVO!(SQ7[O'#FzO!(SQ7[O'#F|O!6VQWO'#GOO!6[QWO'#GPO!3fQWO'#GVO!(SQ7[O'#G[O!6aQWO'#EmO!7OQWO,5<cOOQ07`'#Cq'#CqO!7WQWO'#EnO!8QQ`O'#EoOOQ07`'#Jw'#JwO!8XQ07hO'#KWO9kQ07hO,5=]O`Q^O,5>mOOQU'#J`'#J`OOQU,5>n,5>nOOQU-E<U-E<UO!:ZQ08SO,5:]O!<wQ08SO,5:iO%[Q^O,5:iO!?bQ08SO,5:kOOQO,5@q,5@qO!@RQ7[O,5=XO!@aQ07hO'#JaO9UQWO'#JaO!@rQ07hO,59YO!@}Q`O,59YO!AVQ7[O,59YO:RQ7[O,59YO!AbQWO,5;VO!AjQWO'#HZO!BOQWO'#KZO%[Q^O,5;zO!7{Q`O,5;|O!BWQWO,5=tO!B]QWO,5=tO!BbQWO,5=tO9kQ07hO,5=tO;sQWO,5=dOOQO'#Cu'#CuO!BpQ`O,5=aO!BxQ7[O,5=bO!CTQWO,5=dO!CYQpO,5=gO!CbQWO'#KVO>pQWO'#HQO9aQWO'#HSO!CgQWO'#HSO:RQ7[O'#HUO!ClQWO'#HUOOQU,5=j,5=jO!CqQWO'#HVO!DSQWO'#CnO!DXQWO,59OO!DcQWO,59OO!FhQ^O,59OOOQU,59O,59OO!FxQ07hO,59OO%[Q^O,59OO!ITQ^O'#H^OOQU'#H_'#H_OOQU'#H`'#H`O`Q^O,5=vO!IkQWO,5=vO`Q^O,5=|O`Q^O,5>OO!IpQWO,5>QO`Q^O,5>SO!IuQWO,5>VO!IzQ^O,5>]OOQU,5>c,5>cO%[Q^O,5>cO9kQ07hO,5>eOOQU,5>g,5>gO!NUQWO,5>gOOQU,5>i,5>iO!NUQWO,5>iOOQU,5>k,5>kO!NZQ`O'#D[O%[Q^O'#JmO!NxQ`O'#JmO# gQ`O'#DjO# xQ`O'#DjO#$ZQ^O'#DjO#$bQWO'#JlO#$jQWO,5:TO#$oQWO'#EpO#$}QWO'#JzO#%VQWO,5;ZO#%[Q`O'#DjO#%iQ`O'#EUOOQ07b,5:n,5:nO%[Q^O,5:nO#%pQWO,5:nO>pQWO,5;UO!@}Q`O,5;UO!AVQ7[O,5;UO:RQ7[O,5;UO#%xQWO,5@XO#%}Q$ISO,5:rOOQO-E<`-E<`O#'TQ07pO,5:}OCnQ`O,5:qO#'_Q`O,5:qOCnQ`O,5:}O!@rQ07hO,5:qOOQ07`'#Ef'#EfOOQO,5:},5:}O%[Q^O,5:}O#'lQ07hO,5:}O#'wQ07hO,5:}O!@}Q`O,5:qOOQO,5;T,5;TO#(VQ07hO,5:}POOO'#IV'#IVP#(kO!0LbO,58{POOO,58{,58{OOOO-E<V-E<VOOQ07b1G.o1G.oOOOO-E<W-E<WO#(vQpO,59zOOOO-E<Y-E<YOOQ07b1G/d1G/dO#({QrO,5>wO+}Q^O,5>wOOQO,5>},5>}O#)VQ^O'#I]OOQO-E<Z-E<ZO#)dQWO,5@VO#)lQrO,5@VO#)sQWO,5@dOOQ07b1G/j1G/jO%[Q^O,5@eO#){QWO'#IcOOQO-E<a-E<aO#)sQWO,5@dOOQ07`1G0t1G0tOOQ07f1G/u1G/uOOQ07f1G0X1G0XO%[Q^O,5@bO#*aQ07hO,5@bO#*rQ07hO,5@bO#*yQWO,5@aO9ZQWO,5@aO#+RQWO,5@aO#+aQWO'#IfO#*yQWO,5@aOOQ07`1G0s1G0sO!*OQ`O,5:tO!*ZQ`O,5:tOOQO,5:v,5:vO#,RQWO,5:vO#,ZQ7[O1G2sO9aQWO1G2sOOQ07b1G0q1G0qO#,iQ08SO1G0qO#-nQ08QO,5;ROOQ07b'#GR'#GRO#.[Q08SO'#JdO!$aQ^O1G0qO#0dQ7[O'#JnO#0nQWO,5:_O#0sQrO'#JoO%[Q^O'#JoO#0}QWO,5:dOOQ07b'#D['#D[OOQ07b1G0z1G0zO%[Q^O1G0zOOQ07b1G1d1G1dO#1SQWO1G0zO#3kQ08SO1G0{O#3rQ08SO1G0{O#6]Q08SO1G0{O#6dQ08SO1G0{O#8nQ08SO1G0{O#9UQ08SO1G0{O#<OQ08SO1G0{O#<VQ08SO1G0{O#>jQ08SO1G0{O#>wQ08SO1G0{O#@uQ08SO1G0{O#CuQ(CYO'#ChO#EsQ(CYO1G1^O#EzQ(CYO'#JjO!,lQWO1G1dO#F[Q08SO,5?TOOQ07`-E<g-E<gO#GOQ08SO1G0{OOQ07b1G0{1G0{O#IZQ08SO1G1aO#I}Q&jO,5<TO#JVQ&jO,5<UO#J_Q&jO'#FlO#JvQWO'#FkOOQO'#KO'#KOOOQO'#Ig'#IgO#J{Q&jO1G1kOOQ07b1G1k1G1kOOOS1G1v1G1vO#K^Q(CYO'#JiO#KhQWO,5<_O!*fQ^O,5<_OOOS-E<f-E<fOOQ07b1G1i1G1iO#KmQ`O'#J}OOQ07b,5<a,5<aO#KuQ`O,5<aOOQ07b,59e,59eO!&dQ7[O'#DPOOOO'#IZ'#IZO#KzO?MpO,59iOOQ07b,59i,59iO%[Q^O1G1|O!6[QWO'#IkO#LVQ7[O,5<uOOQ07b,5<r,5<rO!(SQ7[O'#InO#LuQ7[O,5=RO!(SQ7[O'#IpO#MhQ7[O,5=TO!&dQ7[O,5=VOOQO1G2O1G2OO#MrQpO'#CqO#NVQpO,5<nO#N^QWO'#KRO9aQWO'#KRO#NlQWO,5<pO!(SQ7[O,5<oO#NqQWO'#GUO#N|QWO,5<oO$ RQpO'#GRO$ `QpO'#KSO$ jQWO'#KSO!&dQ7[O'#KSO$ oQWO,5<sO$ tQ`O'#G^O!4eQ`O'#G^O$!VQWO'#G`O$![QWO'#GbO!3fQWO'#GeO$!aQ07hO'#ImO$!lQ`O,5<wOOQ07f,5<w,5<wO$!sQ`O'#G^O$#RQ`O'#G_O$#ZQ`O'#G_O$#`Q7[O,5=RO$#pQ7[O,5=TOOQ07b,5=W,5=WO!(SQ7[O,5?}O!(SQ7[O,5?}O$$QQWO'#IrO$$]QWO,5?|O$$eQWO,59`O$%UQ7[O,59qOOQ07b,59q,59qO$%wQ7[O,5<fO$&jQ7[O,5<hO@bQWO,5<jOOQ07b,5<k,5<kO$&tQWO,5<qO$&yQ7[O,5<vO$'ZQWO'#JuO!$aQ^O1G1}O$'`QWO1G1}O9ZQWO'#JxO9ZQWO'#EpO%[Q^O'#EpO9ZQWO'#ItO$'eQ07hO,5@rOOQU1G2w1G2wOOQU1G4X1G4XOOQ07b1G/w1G/wO!,iQWO1G/wO$)jQ08SO1G0TOOQU1G2s1G2sO!&dQ7[O1G2sO%[Q^O1G2sO#,^QWO1G2sO$+nQ7[O'#EgOOQ07`,5?{,5?{O$+xQ07hO,5?{OOQU1G.t1G.tO!@rQ07hO1G.tO!@}Q`O1G.tO!AVQ7[O1G.tO$,ZQWO1G0qO$,`QWO'#ChO$,kQWO'#K[O$,sQWO,5=uO$,xQWO'#K[O$,}QWO'#K[O$-]QWO'#IzO$-kQWO,5@uO$-sQrO1G1fOOQ07b1G1h1G1hO9aQWO1G3`O@bQWO1G3`O$-zQWO1G3`O$.PQWO1G3`OOQU1G3`1G3`O!CTQWO1G3OO!&dQ7[O1G2{O$.UQWO1G2{OOQU1G2|1G2|O!&dQ7[O1G2|O$.ZQWO1G2|O$.cQ`O'#GzOOQU1G3O1G3OO!4eQ`O'#IvO!CYQpO1G3ROOQU1G3R1G3ROOQU,5=l,5=lO$.kQ7[O,5=nO9aQWO,5=nO$![QWO,5=pO9UQWO,5=pO!@}Q`O,5=pO!AVQ7[O,5=pO:RQ7[O,5=pO$.yQWO'#KYO$/UQWO,5=qOOQU1G.j1G.jO$/ZQ07hO1G.jO@bQWO1G.jO$/fQWO1G.jO9kQ07hO1G.jO$1kQrO,5@wO$1{QWO,5@wO9ZQWO,5@wO$2WQ^O,5=xO$2_QWO,5=xOOQU1G3b1G3bO`Q^O1G3bOOQU1G3h1G3hOOQU1G3j1G3jO>kQWO1G3lO$2dQ^O1G3nO$6hQ^O'#HmOOQU1G3q1G3qO$6uQWO'#HsO>pQWO'#HuOOQU1G3w1G3wO$6}Q^O1G3wO9kQ07hO1G3}OOQU1G4P1G4POOQ07`'#GY'#GYO9kQ07hO1G4RO9kQ07hO1G4TO$;UQWO,5@XO!*fQ^O,5;[O9ZQWO,5;[O>pQWO,5:UO!*fQ^O,5:UO!@}Q`O,5:UO$;ZQ(CYO,5:UOOQO,5;[,5;[O$;eQ`O'#I^O$;{QWO,5@WOOQ07b1G/o1G/oO$<TQ`O'#IdO$<_QWO,5@fOOQ07`1G0u1G0uO# xQ`O,5:UOOQO'#Ia'#IaO$<gQ`O,5:pOOQ07f,5:p,5:pO#%sQWO1G0YOOQ07b1G0Y1G0YO%[Q^O1G0YOOQ07b1G0p1G0pO>pQWO1G0pO!@}Q`O1G0pO!AVQ7[O1G0pOOQ07`1G5s1G5sO!@rQ07hO1G0]OOQO1G0i1G0iO%[Q^O1G0iO$<nQ07hO1G0iO$<yQ07hO1G0iO!@}Q`O1G0]OCnQ`O1G0]O$=XQ07hO1G0iOOQO1G0]1G0]O$=mQ08SO1G0iPOOO-E<T-E<TPOOO1G.g1G.gOOOO1G/f1G/fO$=wQpO,5<eO$>PQrO1G4cOOQO1G4i1G4iO%[Q^O,5>wO$>ZQWO1G5qO$>cQWO1G6OO$>kQrO1G6PO9ZQWO,5>}O$>uQ08SO1G5|O%[Q^O1G5|O$?VQ07hO1G5|O$?hQWO1G5{O$?hQWO1G5{O9ZQWO1G5{O$?pQWO,5?QO9ZQWO,5?QOOQO,5?Q,5?QO$@UQWO,5?QO$'ZQWO,5?QOOQO-E<d-E<dOOQO1G0`1G0`OOQO1G0b1G0bO!,lQWO1G0bOOQU7+(_7+(_O!&dQ7[O7+(_O%[Q^O7+(_O$@dQWO7+(_O$@oQ7[O7+(_O$@}Q08SO,5=RO$CYQ08SO,5=TO$EeQ08SO,5=RO$GvQ08SO,5=TO$JXQ08SO,59qO$LaQ08SO,5<fO$NlQ08SO,5<hO%!wQ08SO,5<vOOQ07b7+&]7+&]O%%YQ08SO7+&]O%%|Q7[O'#I_O%&WQWO,5@YOOQ07b1G/y1G/yO%&`Q^O'#I`O%&mQWO,5@ZO%&uQrO,5@ZOOQ07b1G0O1G0OO%'PQWO7+&fOOQ07b7+&f7+&fO%'UQ(CYO,5:eO%[Q^O7+&xO%'`Q(CYO,5:]O%'mQ(CYO,5:iO%'wQ(CYO,5:kOOQ07b7+'O7+'OOOQO1G1o1G1oOOQO1G1p1G1pO%(RQtO,5<WO!*fQ^O,5<VOOQO-E<e-E<eOOQ07b7+'V7+'VOOOS7+'b7+'bOOOS1G1y1G1yO%(^QWO1G1yOOQ07b1G1{1G1{O%(cQpO,59kOOOO-E<X-E<XOOQ07b1G/T1G/TO%(jQ08SO7+'hOOQ07b,5?V,5?VO%)^QpO,5?VOOQ07b1G2a1G2aP!&dQ7[O'#IkPOQ07b-E<i-E<iO%)|Q7[O,5?YOOQ07b-E<l-E<lO%*oQ7[O,5?[OOQ07b-E<n-E<nO%*yQpO1G2qOOQ07b1G2Y1G2YO%+QQWO'#IjO%+`QWO,5@mO%+`QWO,5@mO%+hQWO,5@mO%+sQWO,5@mOOQO1G2[1G2[O%,RQ7[O1G2ZO!(SQ7[O1G2ZO%,cQ!LQO'#IlO%,sQWO,5@nO!&dQ7[O,5@nO%,{QpO,5@nOOQ07b1G2_1G2_OOQ07`,5<x,5<xOOQ07`,5<y,5<yO$'ZQWO,5<yOC_QWO,5<yO!@}Q`O,5<xOOQO'#Ga'#GaO%-VQWO,5<zOOQ07`,5<|,5<|O$'ZQWO,5=POOQO,5?X,5?XOOQO-E<k-E<kOOQ07f1G2c1G2cO!4eQ`O,5<xO%-_QWO,5<yO$!VQWO,5<zO!4eQ`O,5<yO!(SQ7[O'#InO%.RQ7[O1G2mO!(SQ7[O'#IpO%.tQ7[O1G2oO%/OQ7[O1G5iO%/YQ7[O1G5iOOQO,5?^,5?^OOQO-E<p-E<pOOQO1G.z1G.zO!7{Q`O,59sO%[Q^O,59sO%/gQWO1G2UO!(SQ7[O1G2]O%/lQ08SO7+'iOOQ07b7+'i7+'iO!$aQ^O7+'iO%0`QWO,5;[OOQ07`,5?`,5?`OOQ07`-E<r-E<rOOQ07b7+%c7+%cO%0eQpO'#KTO#%sQWO7+(_O%0oQrO7+(_O$@gQWO7+(_O%0vQ08QO'#ChO%1ZQ08QO,5<}O%1{QWO,5<}OOQ07`1G5g1G5gOOQU7+$`7+$`O!@rQ07hO7+$`O!@}Q`O7+$`O!$aQ^O7+&]O%2QQWO'#IyO%2iQWO,5@vOOQO1G3a1G3aO9aQWO,5@vO%2iQWO,5@vO%2qQWO,5@vOOQO,5?f,5?fOOQO-E<x-E<xOOQ07b7+'Q7+'QO%2vQWO7+(zO9kQ07hO7+(zO9aQWO7+(zO@bQWO7+(zOOQU7+(j7+(jO%2{Q08QO7+(gO!&dQ7[O7+(gO%3VQpO7+(hOOQU7+(h7+(hO!&dQ7[O7+(hO%3^QWO'#KXO%3iQWO,5=fOOQO,5?b,5?bOOQO-E<t-E<tOOQU7+(m7+(mO%4xQ`O'#HTOOQU1G3Y1G3YO!&dQ7[O1G3YO%[Q^O1G3YO%5PQWO1G3YO%5[Q7[O1G3YO9kQ07hO1G3[O$![QWO1G3[O9UQWO1G3[O!@}Q`O1G3[O!AVQ7[O1G3[O%5jQWO'#IxO%6OQWO,5@tO%6WQ`O,5@tOOQ07`1G3]1G3]OOQU7+$U7+$UO@bQWO7+$UO9kQ07hO7+$UO%6cQWO7+$UO%[Q^O1G6cO%[Q^O1G6dO%6hQ07hO1G6cO%6rQ^O1G3dO%6yQWO1G3dO%7OQ^O1G3dOOQU7+(|7+(|O9kQ07hO7+)WO`Q^O7+)YOOQU'#K_'#K_OOQU'#I{'#I{O%7VQ^O,5>XOOQU,5>X,5>XO%[Q^O'#HnO%7dQWO'#HpOOQU,5>_,5>_O9ZQWO,5>_OOQU,5>a,5>aOOQU7+)c7+)cOOQU7+)i7+)iOOQU7+)m7+)mOOQU7+)o7+)oO%7iQ`O1G5sO%7}Q(CYO1G0vO%8XQWO1G0vOOQO1G/p1G/pO%8dQ(CYO1G/pO>pQWO1G/pO!*fQ^O'#DjOOQO,5>x,5>xOOQO-E<[-E<[OOQO,5?O,5?OOOQO-E<b-E<bO!@}Q`O1G/pOOQO-E<_-E<_OOQ07f1G0[1G0[OOQ07b7+%t7+%tO#%sQWO7+%tOOQ07b7+&[7+&[O>pQWO7+&[O!@}Q`O7+&[OOQO7+%w7+%wO$=mQ08SO7+&TOOQO7+&T7+&TO%[Q^O7+&TO%8nQ07hO7+&TO!@rQ07hO7+%wO!@}Q`O7+%wO%8yQ07hO7+&TO%9XQ08SO7++hO%[Q^O7++hO%9iQWO7++gO%9iQWO7++gOOQO1G4l1G4lO9ZQWO1G4lO%9qQWO1G4lOOQO7+%|7+%|O#%sQWO<<KyO%0oQrO<<KyO%:PQWO<<KyOOQU<<Ky<<KyO!&dQ7[O<<KyO%[Q^O<<KyO%:XQWO<<KyO%:dQ08SO,5?YO%<oQ08SO,5?[O%>zQ08SO1G2ZO%A]Q08SO1G2mO%ChQ08SO1G2oO%EsQ7[O,5>yOOQO-E<]-E<]O%E}QrO,5>zO%[Q^O,5>zOOQO-E<^-E<^O%FXQWO1G5uOOQ07b<<JQ<<JQO%FaQ(CYO1G0qO%HkQ(CYO1G0{O%HrQ(CYO1G0{O%JvQ(CYO1G0{O%J}Q(CYO1G0{O%LrQ(CYO1G0{O%MYQ(CYO1G0{O& mQ(CYO1G0{O& tQ(CYO1G0{O&#rQ(CYO1G0{O&$PQ(CYO1G0{O&%}Q(CYO1G0{O&&bQ08SO<<JdO&'gQ(CYO1G0{O&)]Q(CYO'#JdO&+`Q(CYO1G1aO&+mQ(CYO1G0TO!*fQ^O'#FnOOQO'#KP'#KPOOQO1G1r1G1rO&+wQWO1G1qO&+|Q(CYO,5?TOOOS7+'e7+'eOOOO1G/V1G/VOOQ07b1G4q1G4qO!(SQ7[O7+(]O&,WQWO,5?UO9aQWO,5?UOOQO-E<h-E<hO&,fQWO1G6XO&,fQWO1G6XO&,nQWO1G6XO&,yQ7[O7+'uO&-ZQpO,5?WO&-eQWO,5?WO!&dQ7[O,5?WOOQO-E<j-E<jO&-jQpO1G6YO&-tQWO1G6YOOQ07`1G2e1G2eO$'ZQWO1G2eOOQ07`1G2d1G2dO&-|QWO1G2fO!&dQ7[O1G2fOOQ07`1G2k1G2kO!@}Q`O1G2dOC_QWO1G2eO&.RQWO1G2fO&.ZQWO1G2eO&.}Q7[O,5?YOOQ07b-E<m-E<mO&/pQ7[O,5?[OOQ07b-E<o-E<oO!(SQ7[O7++TOOQ07b1G/_1G/_O&/zQWO1G/_OOQ07b7+'p7+'pO&0PQ7[O7+'wO&0aQ08SO<<KTOOQ07b<<KT<<KTO&1TQWO1G0vO!&dQ7[O'#IsO&1YQWO,5@oO!&dQ7[O1G2iOOQU<<Gz<<GzO!@rQ07hO<<GzO&1bQ08SO<<IwOOQ07b<<Iw<<IwOOQO,5?e,5?eO&2UQWO,5?eO&2ZQWO,5?eOOQO-E<w-E<wO&2iQWO1G6bO&2iQWO1G6bO9aQWO1G6bO@bQWO<<LfOOQU<<Lf<<LfO&2qQWO<<LfO9kQ07hO<<LfOOQU<<LR<<LRO%2{Q08QO<<LROOQU<<LS<<LSO%3VQpO<<LSO&2vQ`O'#IuO&3RQWO,5@sO!*fQ^O,5@sOOQU1G3Q1G3QO&3ZQ^O'#JmOOQO'#Iw'#IwO9kQ07hO'#IwO&3eQ`O,5=oOOQU,5=o,5=oO&3lQ`O'#EcO&4QQWO7+(tO&4VQWO7+(tOOQU7+(t7+(tO!&dQ7[O7+(tO%[Q^O7+(tO&4_QWO7+(tOOQU7+(v7+(vO9kQ07hO7+(vO$![QWO7+(vO9UQWO7+(vO!@}Q`O7+(vO&4jQWO,5?dOOQO-E<v-E<vOOQO'#HW'#HWO&4uQWO1G6`O9kQ07hO<<GpOOQU<<Gp<<GpO@bQWO<<GpO&4}QWO7++}O&5SQWO7+,OO%[Q^O7++}O%[Q^O7+,OOOQU7+)O7+)OO&5XQWO7+)OO&5^Q^O7+)OO&5eQWO7+)OOOQU<<Lr<<LrOOQU<<Lt<<LtOOQU-E<y-E<yOOQU1G3s1G3sO&5jQWO,5>YOOQU,5>[,5>[O&5oQWO1G3yO9ZQWO7+&bO!*fQ^O7+&bOOQO7+%[7+%[O&5tQ(CYO1G6PO>pQWO7+%[OOQ07b<<I`<<I`OOQ07b<<Iv<<IvO>pQWO<<IvOOQO<<Io<<IoO$=mQ08SO<<IoO%[Q^O<<IoOOQO<<Ic<<IcO!@rQ07hO<<IcO&6OQ07hO<<IoO&6ZQ08SO<= SO&6kQWO<= ROOQO7+*W7+*WO9ZQWO7+*WOOQUANAeANAeO&6sQWOANAeO!&dQ7[OANAeO#%sQWOANAeO%0oQrOANAeO%[Q^OANAeO&6{Q08SO7+'uO&9^Q08SO,5?YO&;iQ08SO,5?[O&=tQ08SO7+'wO&@VQrO1G4fO&@aQ(CYO7+&]O&BeQ(CYO,5=RO&DlQ(CYO,5=TO&D|Q(CYO,5=RO&E^Q(CYO,5=TO&EnQ(CYO,59qO&GqQ(CYO,5<fO&ItQ(CYO,5<hO&KwQ(CYO,5<vO&MmQ(CYO7+'hO&MzQ(CYO7+'iO&NXQWO,5<YOOQO7+']7+']O&N^Q7[O<<KwOOQO1G4p1G4pO&NeQWO1G4pO&NpQWO1G4pO' OQWO7++sO' OQWO7++sO!&dQ7[O1G4rO' WQpO1G4rO' bQWO7++tOOQ07`7+(P7+(PO$'ZQWO7+(QO' jQpO7+(QOOQ07`7+(O7+(OO$'ZQWO7+(PO' qQWO7+(QO!&dQ7[O7+(QOC_QWO7+(PO' vQ7[O<<NoOOQ07b7+$y7+$yO'!QQpO,5?_OOQO-E<q-E<qO'![Q08QO7+(TOOQUAN=fAN=fO9aQWO1G5POOQO1G5P1G5PO'!lQWO1G5PO'!qQWO7++|O'!qQWO7++|O9kQ07hOANBQO@bQWOANBQOOQUANBQANBQOOQUANAmANAmOOQUANAnANAnO'!yQWO,5?aOOQO-E<s-E<sO'#UQ(CYO1G6_O'%fQrO'#ChOOQO,5?c,5?cOOQO-E<u-E<uOOQU1G3Z1G3ZO&3ZQ^O,5<zOOQU<<L`<<L`O!&dQ7[O<<L`O&4QQWO<<L`O'%pQWO<<L`O%[Q^O<<L`OOQU<<Lb<<LbO9kQ07hO<<LbO$![QWO<<LbO9UQWO<<LbO'%xQ`O1G5OO'&TQWO7++zOOQUAN=[AN=[O9kQ07hOAN=[OOQU<= i<= iOOQU<= j<= jO'&]QWO<= iO'&bQWO<= jOOQU<<Lj<<LjO'&gQWO<<LjO'&lQ^O<<LjOOQU1G3t1G3tO>pQWO7+)eO'&sQWO<<I|O''OQ(CYO<<I|OOQO<<Hv<<HvOOQ07bAN?bAN?bOOQOAN?ZAN?ZO$=mQ08SOAN?ZOOQOAN>}AN>}O%[Q^OAN?ZOOQO<<Mr<<MrOOQUG27PG27PO!&dQ7[OG27PO#%sQWOG27PO''YQWOG27PO%0oQrOG27PO''bQ(CYO<<JdO''oQ(CYO1G2ZO')eQ(CYO,5?YO'+hQ(CYO,5?[O'-kQ(CYO1G2mO'/nQ(CYO1G2oO'1qQ(CYO<<KTO'2OQ(CYO<<IwOOQO1G1t1G1tO!(SQ7[OANAcOOQO7+*[7+*[O'2]QWO7+*[O'2hQWO<= _O'2pQpO7+*^OOQ07`<<Kl<<KlO$'ZQWO<<KlOOQ07`<<Kk<<KkO'2zQpO<<KlO$'ZQWO<<KkOOQO7+*k7+*kO9aQWO7+*kO'3RQWO<= hOOQUG27lG27lO9kQ07hOG27lO!*fQ^O1G4{O'3ZQWO7++yO&4QQWOANAzOOQUANAzANAzO!&dQ7[OANAzO'3cQWOANAzOOQUANA|ANA|O9kQ07hOANA|O$![QWOANA|OOQO'#HX'#HXOOQO7+*j7+*jOOQUG22vG22vOOQUANETANETOOQUANEUANEUOOQUANBUANBUO'3kQWOANBUOOQU<<MP<<MPO!*fQ^OAN?hOOQOG24uG24uO$=mQ08SOG24uO#%sQWOLD,kOOQULD,kLD,kO!&dQ7[OLD,kO'3pQWOLD,kO'3xQ(CYO7+'uO'5nQ(CYO,5?YO'7qQ(CYO,5?[O'9tQ(CYO7+'wO';jQ7[OG26}OOQO<<Mv<<MvOOQ07`ANAWANAWO$'ZQWOANAWOOQ07`ANAVANAVOOQO<<NV<<NVOOQULD-WLD-WO';zQ(CYO7+*gOOQUG27fG27fO&4QQWOG27fO!&dQ7[OG27fOOQUG27hG27hO9kQ07hOG27hOOQUG27pG27pO'<UQ(CYOG25SOOQOLD*aLD*aOOQU!$(!V!$(!VO#%sQWO!$(!VO!&dQ7[O!$(!VO'<`Q08SOG26}OOQ07`G26rG26rOOQULD-QLD-QO&4QQWOLD-QOOQULD-SLD-SOOQU!)9Eq!)9EqO#%sQWO!)9EqOOQU!$(!l!$(!lOOQU!.K;]!.K;]O'>qQ(CYOG26}O!*fQ^O'#DyO1PQWO'#EWO'@gQrO'#JiO!*fQ^O'#DqO'@nQ^O'#D}O'@uQrO'#ChO'C]QrO'#ChO!*fQ^O'#EPO'CmQ^O,5;VO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O'#IiO'EpQWO,5<eO'ExQ7[O,5;aO'GcQ7[O,5;aO!*fQ^O,5;uO!&dQ7[O'#GgO'ExQ7[O'#GgO!&dQ7[O'#GiO'ExQ7[O'#GiO1SQWO'#DVO1SQWO'#DVO!&dQ7[O'#FzO'ExQ7[O'#FzO!&dQ7[O'#F|O'ExQ7[O'#F|O!&dQ7[O'#G[O'ExQ7[O'#G[O!*fQ^O,5:iO!*fQ^O,5@eO'CmQ^O1G0qO'GjQ(CYO'#ChO!*fQ^O1G1|O!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O,5<oO'ExQ7[O,5<oO'CmQ^O1G1}O!*fQ^O7+&xO!&dQ7[O1G2ZO'ExQ7[O1G2ZO!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O1G2]O'ExQ7[O1G2]O'CmQ^O7+'iO'CmQ^O7+&]O!&dQ7[OANAcO'ExQ7[OANAcO'GtQWO'#EkO'GyQWO'#EkO'HRQWO'#FZO'HWQWO'#EuO'H]QWO'#JyO'HhQWO'#JwO'HsQWO,5;VO'HxQ7[O,5<bO'IPQWO'#GTO'IUQWO'#GTO'IZQWO,5<cO'IcQWO,5;VO'IkQ(CYO1G1^O'IrQWO,5<oO'IwQWO,5<oO'I|QWO,5<qO'JRQWO,5<qO'JWQWO1G1}O'J]QWO1G0qO'JbQ7[O<<KwO'JiQ7[O<<KwO7hQ7[O'#FxO9UQWO'#FwOA]QWO'#EjO!*fQ^O,5;rO!3fQWO'#GTO!3fQWO'#GTO!3fQWO'#GVO!3fQWO'#GVO!(SQ7[O7+(]O!(SQ7[O7+(]O%*yQpO1G2qO%*yQpO1G2qO!&dQ7[O,5=VO!&dQ7[O,5=V",
  stateData: "'Km~O'tOS'uOSSOS'vRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!twO!wxO!{]O#s!PO$T|O%b}O%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO&P!WO&V!XO&X!YO&Z!ZO&]![O&`!]O&f!^O&l!_O&n!`O&p!aO&r!bO&t!cO'{SO'}TO(QUO(XVO(g[O(tiO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`!vOo!nO!P!oO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!wO#S!pO#T!pO#W!yO#X!yO'|!lO'}TO(QUO([!mO(g!sO~O'v!zO~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X'r[X(X[X(h[X(o[X(p[X~O!d$|X~P(qO^!|O'}#OO(O!|O(P#OO~O^#PO(P#OO(Q#OO(R#PO~Ot#RO!R#SO(Y#SO(Z#UO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{:hO'}TO(QUO(XVO(g[O(tiO~O!X#YO!Y#VO!V(_P!V(lP~P+}O!Z#bO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'}TO(QUO(XVO(g[O(tiO~Ol#lO!X#hO!{]O#e#kO#f#hO'{:iO!j(iP~P.iO!k#nO'{#mO~O!w#rO!{]O%b#sO~O#g#tO~O!d#uO#g#tO~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y$aO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`(]X'r(]X'p(]X!j(]X!V(]X![(]X%c(]X!d(]X~P1qO#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X![(^X%c(^X~O`(^X!i(^X'r(^X'p(^X!V(^X!j(^Xr(^X!d(^X~P4XO#[$eO~O$Y$gO$[$fO$c$lO~ORfO![$mO$f$nO$h$pO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{$rO'}TO(QUO(X$uO(o$}O(p%POf(UP~O!k%bO~O!P%eO![%fO'{%dO~O!d%jO~O`%kO'r%kO~O'|!lO~P%[O%h%rO~P%[Og%VO!k%bO'{%dO'|!lO~Od%yO!k%bO'{%dO~O#r$SO~O|&OO![%{O!k%}O%d&RO'{%dO'|!lO'}TO(QUO_(}P~O!w#rO~O%m&TO!P(yX![(yX'{(yX~O'{&UO~O!t&ZO#s!PO%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO~Oc&`Od&_O!w&]O%b&^O%u&[O~P;xOc&cOdyO![&bO!t&ZO!wxO!{]O#s!PO%b}O%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO~Oa&fO#[&iO%d&dO'|!lO~P<}O!k&jO!t&nO~O!k#nO~O![XO~O`%kO'q&vO'r%kO~O`%kO'q&yO'r%kO~O`%kO'q&{O'r%kO~O'p[X!V[Xr[X!j[X&T[X![[X%c[X!d[X~P(qO!_'YO!`'RO!a'RO'|!lO'}TO(QUO~Oo'PO!P'OO!X'SO([&}O!Z(`P!Z(nP~P@UOj']O!['ZO'{%dO~Od'bO!k%bO'{%dO~O|&OO!k%}O~Oo!nO!P!oO!{:dO#P!pO#Q!pO#S!pO#T!pO'|!lO'}TO(QUO([!mO(g!sO~O!_'hO!`'gO!a'gO#R!pO#W'iO#X'iO~PApO`%kOg%VO!d#uO!k%bO'r%kO(h'kO~O!o'oO#['mO~PCOOo!nO!P!oO'}TO(QUO([!mO(g!sO~O![XOo(eX!P(eX!_(eX!`(eX!a(eX!{(eX#P(eX#Q(eX#R(eX#S(eX#T(eX#W(eX#X(eX'|(eX'}(eX(Q(eX([(eX(g(eX~O!`'gO!a'gO'|!lO~PCnO'w'sO'x'sO'y'uO~O^!|O'}'wO(O!|O(P'wO~O^#PO(P'wO(Q'wO(R#PO~Ot#RO!R#SO(Y#SO(Z'{O~O!X'}O!V'PX!V'VX!Y'PX!Y'VX~P+}O!Y(PO!V(_X~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y(PO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O!V(_X~PGbO!V(UO~O!V(kX!Y(kX!d(kX!j(kX(h(kX~O#[(kX#g#`X!Z(kX~PIhO#[(VO!V(mX!Y(mX~O!Y(WO!V(lX~O!V(ZO~O#[$eO~PIhO!Z([O~P`O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!maZ!man!ma!Y!ma!h!ma!o!ma#j!ma#k!ma#l!ma#m!ma#n!ma#o!ma#p!ma#q!ma#r!ma#t!ma#v!ma#x!ma#y!ma(h!ma(o!ma(p!ma~O`!ma'r!ma'p!ma!V!ma!j!mar!ma![!ma%c!ma!d!ma~PKOO!j(]O~O!d#uO#[(^O(h'kO!Y(jX`(jX'r(jX~O!j(jX~PMnO!P%eO![%fO!{]O#e(cO#f(bO'{%dO~O!Y(dO!j(iX~O!j(fO~O!P%eO![%fO#f(bO'{%dO~OP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!i(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O!d#uO!j(^X~P! [O|(gO}(hO!i#wO!k#xO!{!za!P!za~O!w!za%b!za![!za#e!za#f!za'{!za~P!#`O!w(lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#g(rO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~Of(bP~P!(SO!X(vO!j(cP~P%[O([(xO(g[O~O!P(zO!k#xO([(xO(g[O~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O})]O!k#xO~O!Y$aO`$ma'r$ma'p$ma!j$ma!V$ma![$ma%c$ma!d$ma~O#s)aO~P!&dO|)dO!d)cO![$ZX$W$ZX$Y$ZX$[$ZX$c$ZX~O!d)cO![(qX$W(qX$Y(qX$[(qX$c(qX~O|)dO~P!.OO|)dO![(qX$W(qX$Y(qX$[(qX$c(qX~O![)fO$W)jO$Y)eO$[)eO$c)kO~O!X)nO~P!*fO$Y$gO$[$fO$c)rO~Oj$uX|$uX!P$uX!i$uX(o$uX(p$uX~OfiXf$uXjiX!YiX#[iX~P!/tOo)tO~Ot)uO(Y)vO(Z)xO~Oj*RO|)zO!P){O(o$}O(p%PO~Of)yO~P!0}Of*SO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~O!X*WO'{*TO!j(uP~P!1lO#g*YO~O!k*ZO~O!X*`O'{*]O!V(vP~P!1lOn*lO!P*dO!_*jO!`*cO!a*cO!k*ZO#W*kO%Y*fO'|!lO([!mO~O!Z*iO~P!3xO!i#wOj(WX|(WX!P(WX(o(WX(p(WX!Y(WX#[(WX~Of(WX#|(WX~P!4qOj*qO#[*pOf(VX!Y(VX~O!Y*rOf(UX~O'{&UOf(UP~O!k*yO~O'{(pO~Ol*}O!P%eO!X#hO![%fO!{]O#e#kO#f#hO'{%dO!j(iP~O!d#uO#g+OO~O!P%eO!X+QO!Y(WO![%fO'{%dO!V(lP~Oo'VO!P+SO!X+RO'}TO(QUO([(xO~O!Z(nP~P!7lO!Y+TO`(zX'r(zX~OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`!ea!Y!ea'r!ea'p!ea!V!ea!j!ear!ea![!ea%c!ea!d!ea~P!8dO|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qaZ!qan!qa!Y!qa!h!qa!o!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#t!qa#v!qa#x!qa#y!qa(h!qa(o!qa(p!qa~O`!qa'r!qa'p!qa!V!qa!j!qar!qa![!qa%c!qa!d!qa~P!:}O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!saZ!san!sa!Y!sa!h!sa!o!sa#j!sa#k!sa#l!sa#m!sa#n!sa#o!sa#p!sa#q!sa#r!sa#t!sa#v!sa#x!sa#y!sa(h!sa(o!sa(p!sa~O`!sa'r!sa'p!sa!V!sa!j!sar!sa![!sa%c!sa!d!sa~P!=hOg%VOj+^O!['ZO%c+]O~O!d+`O`(TX![(TX'r(TX!Y(TX~O`%kO![XO'r%kO~Og%VO!k%bO~Og%VO!k%bO'{%dO~O!d#uO#g(rO~Oa+kO%d+lO'{+hO'}TO(QUO!Z)OP~O!Y+mO_(}X~OZ+qO~O_+rO~O![%{O'{%dO'|!lO_(}P~Og%VO#[+wO~Og%VOj+zO![$|O~O![+|O~O|,OO![XO~O%h%rO~O!w,TO~Od,YO~Oa,ZO'{#mO'}TO(QUO!Z(|P~Od%yO~O%d!QO'{&UO~P<}OZ,`O_,_O~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!kZO!nYO!oYO!pYO!rvO!wxO!{]O%b}O'}TO(QUO(XVO(g[O(tiO~O![!eO!t!gO$T!kO'{!dO~P!DkO_,_O`%kO'r%kO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`,eO!twO#s!OO%f!OO%g!OO%h!OO~P!GTO!k&jO~O&V,kO~O![,mO~O&h,oO&j,pOP&eaQ&eaR&eaX&ea`&eac&ead&eal&ean&eao&eap&eav&eax&eaz&ea!P&ea!T&ea!U&ea![&ea!f&ea!k&ea!n&ea!o&ea!p&ea!r&ea!t&ea!w&ea!{&ea#s&ea$T&ea%b&ea%d&ea%f&ea%g&ea%h&ea%k&ea%m&ea%p&ea%q&ea%s&ea&P&ea&V&ea&X&ea&Z&ea&]&ea&`&ea&f&ea&l&ea&n&ea&p&ea&r&ea&t&ea'p&ea'{&ea'}&ea(Q&ea(X&ea(g&ea(t&ea!Z&ea&^&eaa&ea&c&ea~O'{,uO~Og!bX!Y!OX!Y!bX!Z!OX!Z!bX!d!OX!d!bX!k!bX#[!OX~O!d,zO#[,yOg(aX!Y#dX!Y(aX!Z#dX!Z(aX!d(aX!k(aX~Og%VO!d,|O!k%bO!Y!^X!Z!^X~Oo!nO!P!oO'}TO(QUO([!mO~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'}TO(QUO(XVO(g[O(t<YO~O'{;]O~P#!ZO!Y-QO!Z(`X~O!Z-SO~O!d,zO#[,yO!Y#dX!Z#dX~O!Y-TO!Z(nX~O!Z-VO~O!`-WO!a-WO'|!lO~P# xO!Z-ZO~P'_Oj-^O!['ZO~O!V-cO~Oo!za!_!za!`!za!a!za#P!za#Q!za#R!za#S!za#T!za#W!za#X!za'|!za'}!za(Q!za([!za(g!za~P!#`O!o-hO#[-fO~PCOO!`-jO!a-jO'|!lO~PCnO`%kO#[-fO'r%kO~O`%kO!d#uO#[-fO'r%kO~O`%kO!d#uO!o-hO#[-fO'r%kO(h'kO~O'w'sO'x'sO'y-oO~Or-pO~O!V'Pa!Y'Pa~P!8dO!X-tO!V'PX!Y'PX~P%[O!Y(PO!V(_a~O!V(_a~PGbO!Y(WO!V(la~O!P%eO!X-xO![%fO'{%dO!V'VX!Y'VX~O#[-zO!Y(ja!j(ja`(ja'r(ja~O!d#uO~P#*aO!Y(dO!j(ia~O!P%eO![%fO#f.OO'{%dO~Ol.TO!P%eO!X.QO![%fO!{]O#e.SO#f.QO'{%dO!Y'YX!j'YX~O}.XO!k#xO~Og%VOj.[O!['ZO%c.ZO~O`#_i!Y#_i'r#_i'p#_i!V#_i!j#_ir#_i![#_i%c#_i!d#_i~P!8dOj<fO|)zO!P){O(o$}O(p%PO~O#g#Za`#Za#[#Za'r#Za!Y#Za!j#Za![#Za!V#Za~P#-]O#g(WXP(WXZ(WX`(WXn(WX}(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX'r(WX(X(WX(h(WX!j(WX!V(WX'p(WXr(WX![(WX%c(WX!d(WX~P!4qO!Y.iOf(bX~P!0}Of.kO~O!Y.lO!j(cX~P!8dO!j.oO~O!V.qO~OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#ii`#iin#ii!Y#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#j#ii~P#1XO#j$OO~P#1XOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO(XVOZ#ii`#ii!Y#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~On#ii~P#3yOn$QO~P#3yOP$]On$QO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO(XVO`#ii!Y#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P#6kOZ$dO!h$SO#o$SO#p$SO#q$cO#r$SO~P#6kOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO(p#}O`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii(o#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v$VO~P#9lO#v#ii~P#9lOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v#ii(o#ii(p#ii~P#<^O#v$VO(o#|O(p#}O~P#<^OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO(XVO(o#|O(p#}O~O`#ii!Y#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#?UOP[XZ[Xn[X|[X}[X!P[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X!Y[X!Z[X~O#|[X~P#AoOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO#y:vO(XVO(h$ZO(o#|O(p#}O~O#|.sO~P#C|O#[:{O$O:{O#|(^X!Z(^X~P! [O`']a!Y']a'r']a'p']a!j']a!V']ar']a![']a%c']a!d']a~P!8dOP#iiZ#ii`#iin#ii}#ii!Y#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(X#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#-]O`#}i!Y#}i'r#}i'p#}i!V#}i!j#}ir#}i![#}i%c#}i!d#}i~P!8dO$Y.xO$[.xO~O$Y.yO$[.yO~O!d)cO#[.zO![$`X$W$`X$Y$`X$[$`X$c$`X~O!X.{O~O![)fO$W.}O$Y)eO$[)eO$c/OO~O!Y:wO!Z(]X~P#C|O!Z/PO~O!d)cO$c(qX~O$c/RO~Ot)uO(Y)vO(Z/UO~O!V/YO~P!&dO(o$}Oj%Za|%Za!P%Za(p%Za!Y%Za#[%Za~Of%Za#|%Za~P#L^O(p%POj%]a|%]a!P%]a(o%]a!Y%]a#[%]a~Of%]a#|%]a~P#MPO!YeX!deX!jeX!j$uX(heX~P!/tO!j/bO~P#-]O!Y/cO!d#uO(h'kO!j(uX~O!j/hO~O!X*WO'{%dO!j(uP~O#g/jO~O!V$uX!Y$uX!d$|X~P!/tO!Y/kO!V(vX~P#-]O!d/mO~O!V/oO~Og%VOn/sO!d#uO!k%bO(h'kO~O'{/uO~O!d+`O~O`%kO!Y/yO'r%kO~O!Z/{O~P!3xO!`/|O!a/|O'|!lO([!mO~O!P0OO([!mO~O#W0PO~Of%Za!Y%Za#[%Za#|%Za~P!0}Of%]a!Y%]a#[%]a#|%]a~P!0}O'{&UOf'fX!Y'fX~O!Y*rOf(Ua~Of0YO~O|0ZO}0ZO!P0[Ojya(oya(pya!Yya#[ya~Ofya#|ya~P$$jO|)zO!P){Oj$na(o$na(p$na!Y$na#[$na~Of$na#|$na~P$%`O|)zO!P){Oj$pa(o$pa(p$pa!Y$pa#[$pa~Of$pa#|$pa~P$&RO#g0^O~Of%Oa!Y%Oa#[%Oa#|%Oa~P!0}O!d#uO~O#g0aO~O!Y+TO`(za'r(za~O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qiZ!qin!qi!Y!qi!h!qi!o!qi#j!qi#k!qi#l!qi#m!qi#n!qi#o!qi#p!qi#q!qi#r!qi#t!qi#v!qi#x!qi#y!qi(h!qi(o!qi(p!qi~O`!qi'r!qi'p!qi!V!qi!j!qir!qi![!qi%c!qi!d!qi~P$'pOg%VOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~Ol0kO'{0jO~P$*ZO!d+`O`(Ta![(Ta'r(Ta!Y(Ta~O#g0qO~OZ[X!YeX!ZeX~O!Y0rO!Z)OX~O!Z0tO~OZ0uO~Oa0wO'{+hO'}TO(QUO~O![%{O'{%dO_'nX!Y'nX~O!Y+mO_(}a~O!j0zO~P!8dOZ0}O~O_1OO~O#[1RO~Oj1UO![$|O~O([(xO!Z({P~Og%VOj1_O![1[O%c1^O~OZ1iO!Y1gO!Z(|X~O!Z1jO~O_1lO`%kO'r%kO~O'{#mO'}TO(QUO~O#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O#r1oO&T1pO`(^X!i(^X~P$/qO#[$eO#r1oO&T1pO~O`1rO~P%[O`1tO~O&^1wOP&[iQ&[iR&[iX&[i`&[ic&[id&[il&[in&[io&[ip&[iv&[ix&[iz&[i!P&[i!T&[i!U&[i![&[i!f&[i!k&[i!n&[i!o&[i!p&[i!r&[i!t&[i!w&[i!{&[i#s&[i$T&[i%b&[i%d&[i%f&[i%g&[i%h&[i%k&[i%m&[i%p&[i%q&[i%s&[i&P&[i&V&[i&X&[i&Z&[i&]&[i&`&[i&f&[i&l&[i&n&[i&p&[i&r&[i&t&[i'p&[i'{&[i'}&[i(Q&[i(X&[i(g&[i(t&[i!Z&[ia&[i&c&[i~Oa1}O!Z1{O&c1|O~P`O![XO!k2PO~O&j,pOP&eiQ&eiR&eiX&ei`&eic&eid&eil&ein&eio&eip&eiv&eix&eiz&ei!P&ei!T&ei!U&ei![&ei!f&ei!k&ei!n&ei!o&ei!p&ei!r&ei!t&ei!w&ei!{&ei#s&ei$T&ei%b&ei%d&ei%f&ei%g&ei%h&ei%k&ei%m&ei%p&ei%q&ei%s&ei&P&ei&V&ei&X&ei&Z&ei&]&ei&`&ei&f&ei&l&ei&n&ei&p&ei&r&ei&t&ei'p&ei'{&ei'}&ei(Q&ei(X&ei(g&ei(t&ei!Z&ei&^&eia&ei&c&ei~O!V2VO~O!Y!^a!Z!^a~P#C|Oo!nO!P!oO!X2]O([!mO!Y'QX!Z'QX~P@UO!Y-QO!Z(`a~O!Y'WX!Z'WX~P!7lO!Y-TO!Z(na~O!Z2dO~P'_O`%kO#[2mO'r%kO~O`%kO!d#uO#[2mO'r%kO~O`%kO!d#uO!o2qO#[2mO'r%kO(h'kO~O`%kO'r%kO~P!8dO!Y$aOr$ma~O!V'Pi!Y'Pi~P!8dO!Y(PO!V(_i~O!Y(WO!V(li~O!V(mi!Y(mi~P!8dO!Y(ji!j(ji`(ji'r(ji~P!8dO#[2sO!Y(ji!j(ji`(ji'r(ji~O!Y(dO!j(ii~O!P%eO![%fO!{]O#e2xO#f2wO'{%dO~O!P%eO![%fO#f2wO'{%dO~Oj3PO!['ZO%c3OO~Og%VOj3PO!['ZO%c3OO~O#g%ZaP%ZaZ%Za`%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Zar%Za![%Za%c%Za!d%Za~P#L^O#g%]aP%]aZ%]a`%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]ar%]a![%]a%c%]a!d%]a~P#MPO#g%ZaP%ZaZ%Za`%Zan%Za}%Za!Y%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Za#[%Zar%Za![%Za%c%Za!d%Za~P#-]O#g%]aP%]aZ%]a`%]an%]a}%]a!Y%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]a#[%]ar%]a![%]a%c%]a!d%]a~P#-]O#gyaPyaZya`yanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya'rya(Xya(hya!jya!Vya'pyarya![ya%cya!dya~P$$jO#g$naP$naZ$na`$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na'r$na(X$na(h$na!j$na!V$na'p$nar$na![$na%c$na!d$na~P$%`O#g$paP$paZ$pa`$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa'r$pa(X$pa(h$pa!j$pa!V$pa'p$par$pa![$pa%c$pa!d$pa~P$&RO#g%OaP%OaZ%Oa`%Oan%Oa}%Oa!Y%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa'r%Oa(X%Oa(h%Oa!j%Oa!V%Oa'p%Oa#[%Oar%Oa![%Oa%c%Oa!d%Oa~P#-]O`#_q!Y#_q'r#_q'p#_q!V#_q!j#_qr#_q![#_q%c#_q!d#_q~P!8dOf'RX!Y'RX~P!(SO!Y.iOf(ba~O!X3ZO!Y'SX!j'SX~P%[O!Y.lO!j(ca~O!Y.lO!j(ca~P!8dO!V3^O~O#|!ma!Z!ma~PKOO#|!ea!Y!ea!Z!ea~P#C|O#|!qa!Z!qa~P!:}O#|!sa!Z!sa~P!=hORfO![3pO$a3qO~O!Z3uO~Or3vO~P#-]O`$jq!Y$jq'r$jq'p$jq!V$jq!j$jqr$jq![$jq%c$jq!d$jq~P!8dO!V3wO~P#-]O|)zO!P){O(p%POj'ba(o'ba!Y'ba#['ba~Of'ba#|'ba~P%)eO|)zO!P){Oj'da(o'da(p'da!Y'da#['da~Of'da#|'da~P%*WO(h$ZO~P#-]O!X3zO'{%dO!Y'^X!j'^X~O!Y/cO!j(ua~O!Y/cO!d#uO!j(ua~O!Y/cO!d#uO(h'kO!j(ua~Of$wi!Y$wi#[$wi#|$wi~P!0}O!X4SO'{*]O!V'`X!Y'`X~P!1lO!Y/kO!V(va~O!Y/kO!V(va~P#-]O!d#uO#r4[O~On4_O!d#uO(h'kO~O(o$}Oj%Zi|%Zi!P%Zi(p%Zi!Y%Zi#[%Zi~Of%Zi#|%Zi~P%-jO(p%POj%]i|%]i!P%]i(o%]i!Y%]i#[%]i~Of%]i#|%]i~P%.]Of(Vi!Y(Vi~P!0}O#[4fOf(Vi!Y(Vi~P!0}O!j4iO~O`$kq!Y$kq'r$kq'p$kq!V$kq!j$kqr$kq![$kq%c$kq!d$kq~P!8dO!V4mO~O!Y4nO![(wX~P#-]O!i#wO~P4XO`$uX![$uX%W[X'r$uX!Y$uX~P!/tO%W4pO`kXjkX|kX!PkX![kX'rkX(okX(pkX!YkX~O%W4pO~Oa4vO%d4wO'{+hO'}TO(QUO!Y'mX!Z'mX~O!Y0rO!Z)Oa~OZ4{O~O_4|O~O`%kO'r%kO~P#-]O![$|O~P#-]O!Y5UO#[5WO!Z({X~O!Z5XO~Oo!nO!P5YO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!pO#S!pO#T!pO#W5_O#X!yO'|!lO'}TO(QUO([!mO(g!sO~O!Z5^O~P%3nOj5dO![1[O%c5cO~Og%VOj5dO![1[O%c5cO~Oa5kO'{#mO'}TO(QUO!Y'lX!Z'lX~O!Y1gO!Z(|a~O'}TO(QUO([5mO~O_5qO~O#r5tO&T5uO~PMnO!j5vO~P%[O`5xO~O`5xO~P%[Oa1}O!Z5}O&c1|O~P`O!d6PO~O!d6ROg(ai!Y(ai!Z(ai!d(ai!k(ai~O!Y#di!Z#di~P#C|O#[6SO!Y#di!Z#di~O!Y!^i!Z!^i~P#C|O`%kO#[6]O'r%kO~O`%kO!d#uO#[6]O'r%kO~O!Y(jq!j(jq`(jq'r(jq~P!8dO!Y(dO!j(iq~O!P%eO![%fO#f6dO'{%dO~O!['ZO%c6gO~Oj6jO!['ZO%c6gO~O#g'baP'baZ'ba`'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba'r'ba(X'ba(h'ba!j'ba!V'ba'p'bar'ba!['ba%c'ba!d'ba~P%)eO#g'daP'daZ'da`'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da'r'da(X'da(h'da!j'da!V'da'p'dar'da!['da%c'da!d'da~P%*WO#g$wiP$wiZ$wi`$win$wi}$wi!Y$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi'r$wi(X$wi(h$wi!j$wi!V$wi'p$wi#[$wir$wi![$wi%c$wi!d$wi~P#-]O#g%ZiP%ZiZ%Zi`%Zin%Zi}%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi'r%Zi(X%Zi(h%Zi!j%Zi!V%Zi'p%Zir%Zi![%Zi%c%Zi!d%Zi~P%-jO#g%]iP%]iZ%]i`%]in%]i}%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i'r%]i(X%]i(h%]i!j%]i!V%]i'p%]ir%]i![%]i%c%]i!d%]i~P%.]Of'Ra!Y'Ra~P!0}O!Y'Sa!j'Sa~P!8dO!Y.lO!j(ci~O#|#_i!Y#_i!Z#_i~P#C|OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#iin#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~O#j#ii~P%FnO#j:lO~P%FnOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO(XVOZ#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~On#ii~P%HyOn:nO~P%HyOP$]On:nO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO(XVO#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P%KUOZ:zO!h:pO#o:pO#p:pO#q:yO#r:pO~P%KUOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO(p#}O#x#ii#y#ii#|#ii(h#ii(o#ii!Y#ii!Z#ii~O#v:sO~P%MpO#v#ii~P%MpOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO#x#ii#y#ii#|#ii(h#ii!Y#ii!Z#ii~O#v#ii(o#ii(p#ii~P& {O#v:sO(o#|O(p#}O~P& {OP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO(XVO(o#|O(p#}O~O#y#ii#|#ii(h#ii!Y#ii!Z#ii~P&$^O`#zy!Y#zy'r#zy'p#zy!V#zy!j#zyr#zy![#zy%c#zy!d#zy~P!8dOj<gO|)zO!P){O(o$}O(p%PO~OP#iiZ#iin#ii}#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(X#ii(h#ii!Y#ii!Z#ii~P&'UO!i#wOP(WXZ(WXj(WXn(WX|(WX}(WX!P(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX#|(WX(X(WX(h(WX(o(WX(p(WX!Y(WX!Z(WX~O#|#}i!Y#}i!Z#}i~P#C|O#|!qi!Z!qi~P$'pO!Z6|O~O!Y']a!Z']a~P#C|O!d#uO(h'kO!Y'^a!j'^a~O!Y/cO!j(ui~O!Y/cO!d#uO!j(ui~Of$wq!Y$wq#[$wq#|$wq~P!0}O!V'`a!Y'`a~P#-]O!d7TO~O!Y/kO!V(vi~P#-]O!Y/kO!V(vi~O!V7XO~O!d#uO#r7^O~On7_O!d#uO(h'kO~O|)zO!P){O(p%POj'ca(o'ca!Y'ca#['ca~Of'ca#|'ca~P&.fO|)zO!P){Oj'ea(o'ea(p'ea!Y'ea#['ea~Of'ea#|'ea~P&/XO!V7aO~Of$yq!Y$yq#[$yq#|$yq~P!0}O`$ky!Y$ky'r$ky'p$ky!V$ky!j$kyr$ky![$ky%c$ky!d$ky~P!8dO!d6RO~O!Y4nO![(wa~O`#_y!Y#_y'r#_y'p#_y!V#_y!j#_yr#_y![#_y%c#_y!d#_y~P!8dOZ7fO~Oa7hO'{+hO'}TO(QUO~O!Y0rO!Z)Oi~O_7lO~O([(xO!Y'iX!Z'iX~O!Y5UO!Z({a~OlkO'{7sO~P.iO!Z7vO~P%3nOo!nO!P7wO'}TO(QUO([!mO(g!sO~O![1[O~O![1[O%c7yO~Oj7|O![1[O%c7yO~OZ8RO!Y'la!Z'la~O!Y1gO!Z(|i~O!j8VO~O!j8WO~O!j8ZO~O!j8ZO~P%[O`8]O~O!d8^O~O!j8_O~O!Y(mi!Z(mi~P#C|O`%kO#[8gO'r%kO~O!Y(jy!j(jy`(jy'r(jy~P!8dO!Y(dO!j(iy~O!['ZO%c8jO~O#g$wqP$wqZ$wq`$wqn$wq}$wq!Y$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq'r$wq(X$wq(h$wq!j$wq!V$wq'p$wq#[$wqr$wq![$wq%c$wq!d$wq~P#-]O#g'caP'caZ'ca`'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca'r'ca(X'ca(h'ca!j'ca!V'ca'p'car'ca!['ca%c'ca!d'ca~P&.fO#g'eaP'eaZ'ea`'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea'r'ea(X'ea(h'ea!j'ea!V'ea'p'ear'ea!['ea%c'ea!d'ea~P&/XO#g$yqP$yqZ$yq`$yqn$yq}$yq!Y$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq'r$yq(X$yq(h$yq!j$yq!V$yq'p$yq#[$yqr$yq![$yq%c$yq!d$yq~P#-]O!Y'Si!j'Si~P!8dO#|#_q!Y#_q!Z#_q~P#C|O(o$}OP%ZaZ%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za#|%Za(X%Za(h%Za!Y%Za!Z%Za~Oj%Za|%Za!P%Za(p%Za~P&@nO(p%POP%]aZ%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a#|%]a(X%]a(h%]a!Y%]a!Z%]a~Oj%]a|%]a!P%]a(o%]a~P&BuOj<gO|)zO!P){O(p%PO~P&@nOj<gO|)zO!P){O(o$}O~P&BuO|0ZO}0ZO!P0[OPyaZyajyanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya#|ya(Xya(hya(oya(pya!Yya!Zya~O|)zO!P){OP$naZ$naj$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na#|$na(X$na(h$na(o$na(p$na!Y$na!Z$na~O|)zO!P){OP$paZ$paj$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa#|$pa(X$pa(h$pa(o$pa(p$pa!Y$pa!Z$pa~OP%OaZ%Oan%Oa}%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa#|%Oa(X%Oa(h%Oa!Y%Oa!Z%Oa~P&'UO#|$jq!Y$jq!Z$jq~P#C|O#|$kq!Y$kq!Z$kq~P#C|O!Z8vO~O#|8wO~P!0}O!d#uO!Y'^i!j'^i~O!d#uO(h'kO!Y'^i!j'^i~O!Y/cO!j(uq~O!V'`i!Y'`i~P#-]O!Y/kO!V(vq~O!V8}O~P#-]O!V8}O~Of(Vy!Y(Vy~P!0}O!Y'ga!['ga~P#-]O`%Vq![%Vq'r%Vq!Y%Vq~P#-]OZ9SO~O!Y0rO!Z)Oq~O#[9WO!Y'ia!Z'ia~O!Y5UO!Z({i~P#C|OP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!d%TX#r%TX~P'#`O![1[O%c9[O~O'}TO(QUO([9aO~O!Y1gO!Z(|q~O!j9dO~O!j9eO~O!j9fO~O!j9fO~P%[O#[9iO!Y#dy!Z#dy~O!Y#dy!Z#dy~P#C|O!['ZO%c9nO~O#|#zy!Y#zy!Z#zy~P#C|OP$wiZ$win$wi}$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi#|$wi(X$wi(h$wi!Y$wi!Z$wi~P&'UO|)zO!P){O(p%POP'baZ'baj'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba#|'ba(X'ba(h'ba(o'ba!Y'ba!Z'ba~O|)zO!P){OP'daZ'daj'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da#|'da(X'da(h'da(o'da(p'da!Y'da!Z'da~O(o$}OP%ZiZ%Zij%Zin%Zi|%Zi}%Zi!P%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi#|%Zi(X%Zi(h%Zi(p%Zi!Y%Zi!Z%Zi~O(p%POP%]iZ%]ij%]in%]i|%]i}%]i!P%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i#|%]i(X%]i(h%]i(o%]i!Y%]i!Z%]i~O#|$ky!Y$ky!Z$ky~P#C|O#|#_y!Y#_y!Z#_y~P#C|O!d#uO!Y'^q!j'^q~O!Y/cO!j(uy~O!V'`q!Y'`q~P#-]O!V9wO~P#-]O!Y0rO!Z)Oy~O!Y5UO!Z({q~O![1[O%c:OO~O!j:RO~O!['ZO%c:WO~OP$wqZ$wqn$wq}$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq#|$wq(X$wq(h$wq!Y$wq!Z$wq~P&'UO|)zO!P){O(p%POP'caZ'caj'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca#|'ca(X'ca(h'ca(o'ca!Y'ca!Z'ca~O|)zO!P){OP'eaZ'eaj'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea#|'ea(X'ea(h'ea(o'ea(p'ea!Y'ea!Z'ea~OP$yqZ$yqn$yq}$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq#|$yq(X$yq(h$yq!Y$yq!Z$yq~P&'UOf%_!Z!Y%_!Z#[%_!Z#|%_!Z~P!0}O!Y'iq!Z'iq~P#C|O!Y#d!Z!Z#d!Z~P#C|O#g%_!ZP%_!ZZ%_!Z`%_!Zn%_!Z}%_!Z!Y%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z'r%_!Z(X%_!Z(h%_!Z!j%_!Z!V%_!Z'p%_!Z#[%_!Zr%_!Z![%_!Z%c%_!Z!d%_!Z~P#-]OP%_!ZZ%_!Zn%_!Z}%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z#|%_!Z(X%_!Z(h%_!Z!Y%_!Z!Z%_!Z~P&'UOr(]X~P1qO'|!lO~P!*fO!VeX!YeX#[eX~P'#`OP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!h[X!i[X!k[X!o[X#[[X#[eX#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!deX!j[X!jeX(heX~P'ASOP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![XO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O!Y:wO!Z$ma~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;RO!P${O![$|O!f<aO!k$xO#f;XO$T%^O$o;TO$q;VO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#s)aO~P'ExO!Z[X!ZeX~P'ASO#g:kO~O!d#uO#g:kO~O#[:{O~O#r:pO~O#[;ZO!Y(mX!Z(mX~O#[:{O!Y(kX!Z(kX~O#g;[O~Of;^O~P!0}O#g;cO~O#g;dO~O!d#uO#g;eO~O!d#uO#g;[O~O#|;fO~P#C|O#g;gO~O#g;hO~O#g;mO~O#g;nO~O#g;oO~O#g;pO~O#|;qO~P!0}O#|;rO~P!0}O!i#P#Q#S#T#W#e#f#q(t$o$q$t%W%b%c%d%k%m%p%q%s%u~'vS#k!U't'|#lo#j#mn|'u$Y'u'{$[([~",
  goto: "$2p)SPPPPP)TPP)WP)iP*x.|PPPP5pPP6WPP<S?gP?zP?zPPP?zPAxP?zP?zP?zPA|PPBRPBlPGdPPPGhPPPPGhJiPPPJoKjPGhPMxPPPP!!WGhPPPGhPGhP!$fGhP!'z!(|!)VP!)y!)}!)yPPPPP!-Y!(|PP!-v!.pP!1dGhGh!1i!4s!9Y!9Y!=OPPP!=VGhPPPPPPPPPPP!@dP!AqPPGh!CSPGhPGhGhGhGhPGh!DfP!GnP!JrP!Jv!KQ!KU!KUP!GkP!KY!KYP!N^P!NbGhGh!Nh##k?zP?zP?z?zP#$v?z?z#'O?z#)k?z#+m?z?z#,[#.f#.f#.j#.r#.f#.zP#.fP?z#/d?z#3R?z?z5pPPP#6vPPP#7a#7aP#7aP#7w#7aPP#7}P#7tP#7t#8b#7t#8|#9S5m)W#9V)WP#9^#9^#9^P)WP)WP)WP)WPP)WP#9d#9gP#9g)WP#9kP#9nP)WP)WP)WP)WP)WP)W)WPP#9t#9z#:V#:]#:c#:i#:o#:}#;T#;Z#;e#;k#;u#<U#<[#<|#=`#=f#=l#=z#>a#@O#@^#@d#Ax#BW#Cr#DQ#DW#D^#Dd#Dn#Dt#Dz#EU#Eh#EnPPPPPPPPPP#EtPPPPPPP#Fi#Ip#KP#KW#K`PPPP$!d$%Z$+r$+u$+x$,q$,t$,w$-O$-WPP$-^$-b$.Y$/X$/]$/qPP$/u$/{$0PP$0S$0W$0Z$1P$1h$2P$2T$2W$2Z$2a$2d$2h$2lR!{RoqOXst!Z#c%j&m&o&p&r,h,m1w1zY!uQ'Z-Y1[5]Q%pvQ%xyQ&P|Q&e!VS'R!e-QQ'a!iS'g!r!xS*c$|*hQ+f%yQ+s&RQ,X&_Q-W'YQ-b'bQ-j'hQ/|*jQ1f,YR;Y:g%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8gS#p]:d!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q*u%ZQ+k%{Q,Z&bQ,b&jQ.c;QQ0h+^Q0l+`Q0w+lQ1n,`Q2{.[Q4v0rQ5k1gQ6i3PQ6u;RQ7h4wR8m6j&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]t!nQ!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_$v$si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ&S|Q'P!eS'V%f-TQ+k%{Q,Z&bQ0]*yQ0w+lQ0|+rQ1m,_Q1n,`Q4v0rQ5P1OQ5k1gQ5n1iQ5o1lQ7h4wQ7k4|Q8U5qQ9V7lR9b8RrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR,]&f&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O']'m(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<[<][#[WZ#V#Y'S'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ%sxQ%wyS%||&RQ&Y!TQ'^!hQ'`!iQ(k#rS*V$x*ZS+e%x%yQ+i%{Q,S&]Q,W&_S-a'a'bQ.^(lQ/g*WQ0p+fQ0v+lQ0x+mQ0{+qQ1a,TS1e,X,YQ2i-bQ3y/cQ4u0rQ4y0uQ5O0}Q5j1fQ7Q3zQ7g4wQ7j4{Q9R7fR9y9S!O$zi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c!S%uy!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^Q+_%sQ+x&VQ+{&WQ,V&_Q.](kQ1`,SU1d,W,X,YQ3Q.^Q5e1aS5i1e1fQ8Q5j#W<^#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go<_:y:z:};P;T;V;X;`;b;d;h;j;l;n;rW%Ti%V*r<YS&V!Q&dQ&W!RQ&X!SR+v&T$w%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gT)v$u)wV*v%Z;Q;RU'V!e%f-TS(y#y#zQ+p&OS.V(g(hQ1V+|Q4g0ZR7p5U&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]$i$`c#X#d%n%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.t.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q'T!eR2^-Qv!nQ!e!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_S*b$|*hS/t*c*jQ/}*kQ1X,OQ4^/|R4a0PnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&t!^Q'q!wS(m#t:kQ+c%vQ,Q&YQ,R&[Q-_'_Q-l'jS.g(r;[S0`+O;eQ0n+dQ1Z,PQ2O,oQ2Q,pQ2Y,{Q2g-`Q2j-dS4l0a;oQ4q0oS4t0q;pQ6T2[Q6X2hQ6^2oQ7e4rQ8b6VQ8c6YQ8f6_R9h8_$d$_c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(j#o'dU*o%R(q3mS+Y%n.tQ2|0hQ6f2{Q8l6iR9o8m$d$^c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(i#o'dS({#z$_S+X%n.tS.W(h(jQ.w)]Q0e+YR2y.X&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S#p]:dQ&o!XQ&p!YQ&r![Q&s!]R1v,kQ'[!hQ+[%sQ-]'^S.Y(k+_Q2e-[W2}.].^0g0iQ6W2fU6e2z2|3QS8i6f6hS9m8k8lS:U9l9oQ:^:VR:a:_U!vQ'Z-YT5Z1[5]!Q_OXZ`st!V!Z#c#g%b%j&d&f&m&o&p&r(d,h,m.P1w1z]!pQ!r'Z-Y1[5]T#p]:d%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS(y#y#zS.V(g(h!s;v$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Y!tQ'Z-Y1[5]Q'f!rS'p!u!xS'r!y5_S-i'g'hQ-k'iR2p-jQ'o!tS(`#f1qS-h'f'rQ/f*VQ/r*bQ2q-kQ4O/gS4X/s/}Q7P3yS7[4_4aQ8y7QR9Q7_Q#vbQ'n!tS(_#f1qS(a#l*}Q+P%cQ+a%tQ+g%zU-g'f'o'rQ-{(`Q/e*VQ/q*bQ/w*eQ0m+bQ1b,US2n-h-kQ2v.TS3}/f/gS4W/r/}Q4Z/vQ4]/xQ5g1cQ6`2qQ7O3yQ7S4OS7W4X4aQ7]4`Q8O5hS8x7P7QQ8|7XQ9O7[Q9_8PQ9u8yQ9v8}Q9x9QQ:Q9`Q:Y9wQ;y;tQ<U;}R<V<OV!vQ'Z-Y%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS#vz!j!r;s$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;y<[%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gQ%cj!S%ty!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^S%zz!jQ+b%uQ,U&_W1c,V,W,X,YU5h1d1e1fS8P5i5jQ9`8Q!r;t$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q;}<ZR<O<[$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gY#aWZ#V#Y'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ,c&j!p;u$[$m)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;x'SS'W!e%fR2`-T%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8g!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q,b&jQ0h+^Q2{.[Q6i3PR8m6j!b$Uc#X%n'|(S(n(u)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!P:r)Z)l-O.t2W2Z3_3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!f$Wc#X%n'|(S(n(u)T)U)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!T:t)Z)l-O.t2W2Z3_3f3g3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!^$[c#X%n'|(S(n(u)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:eQ3x/az<])Z)l-O.t2W2Z3_3n3t6U6p6y6z7r8a8n8t8u9{:S<PQ<b<dR<c<e&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S$nh$oR3q.z'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$jf$pQ$hfS)e$k)iR)q$pT$if$pT)g$k)i'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$nh$oQ$qhR)p$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8g!s<Z$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]#clOPXZst!Z!`!o#R#c#n#{$m%j&f&i&j&m&o&p&r&v'O'](z)n+S+^,e,h,m-^.[.{0[1_1o1p1r1t1w1z1|3P3p5Y5d5t5u5x6j7w7|8]!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gQ*z%_Q/W)zo3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!O$yi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cQ*[$zS*e$|*hQ*{%`Q/x*f#W;{#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;|:y:z:};P;T;V;X;`;b;d;h;j;l;n;rQ<Q<^Q<R<_Q<S<`R<T<a!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;rnoOXst!Z#c%j&m&o&p&r,h,m1w1zQ*_${Q,v&yQ,w&{R4R/k$v%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ+y&WQ1T+{Q5S1SR7o5TT*g$|*hS*g$|*hT5[1[5]S/v*d5YT4`0O7wQ+a%tQ/w*eQ0m+bQ1b,UQ5g1cQ8O5hQ9_8PR:Q9`!O%Oi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cr)}$v(s*O*n*|/i0U0V3W4P4j6}7`9t;z<W<XS0Q*m0R#W:|#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn:}:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!^;_(o)`*U*^._.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<e`;`3l6q6t6x8o9p9s:bS;i.a3UT;j6s8r!O%Qi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cv*P$v(s*Q*m*|/]/i0U0V3W4P4b4j6}7`9t;z<W<XS0S*n0T#W;O#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;P:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!b;a(o)`*U*^.`.a.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<ed;b3l6r6s6x8o8p9p9q9s:bS;k.b3VT;l6t8srnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ&a!UR,e&jrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR&a!UQ+}&XR1P+vsnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ1],SS5b1`1aU7x5`5a5eS9Z7z7{S9|9Y9]Q:Z9}R:`:[Q&h!VR,^&dR5n1iS%||&RR0x+mQ&m!WR,h&nR,n&sT1x,m1zR,r&tQ,q&tR2R,rQ't!zR-n'tSsOtQ#cXT%ms#cQ!}TR'v!}Q#QUR'x#QQ)w$uR/T)wQ#TVR'z#TQ#WWU(Q#W(R-uQ(R#XR-u(SQ-R'TR2_-RQ.j(sR3X.jQ.m(uS3[.m3]R3].nQ-Y'ZR2c-YY!rQ'Z-Y1[5]R'e!rS#^W%eU(X#^(Y-vQ(Y#_R-v(TQ-U'WR2a-Ut`OXst!V!Z#c%j&d&f&m&o&p&r,h,m1w1zS#gZ%bU#q`#g.PR.P(dQ(e#iQ-|(aW.U(e-|2t6bQ2t-}R6b2uQ)i$kR.|)iQ$ohR)o$oQ$bcU)_$b-q:xQ-q:eR:x)lQ/d*VW3{/d3|7R8zU3|/e/f/gS7R3}4OR8z7S$X)|$v(o(s)`*U*^*m*n*w*x*|.a.b.d.e.f/S/X/]/_/a/i/n0U0V0f1Q1S3R3S3T3W3l4P4Q4U4b4d4j5R5T6k6l6m6n6s6t6v6w6x6}7U7Y7`7b7d8o8p8q8{9P9p9q9r9s9t:X:b;z<W<X<d<eQ/l*^U4T/l4V7VQ4V/nR7V4UQ*h$|R/z*hr*O$v(s*m*n*|/i0U0V3W4P4j6}7`9t;z<W<X!^._(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<eU/^*O._6qa6q3l6s6t6x8o9p9s:bQ0R*mQ3U.aU4c0R3U8rR8r6sv*Q$v(s*m*n*|/]/i0U0V3W4P4b4j6}7`9t;z<W<X!b.`(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<eU/`*Q.`6re6r3l6s6t6x8o8p9p9q9s:bQ0T*nQ3V.bU4e0T3V8sR8s6tQ*s%UR0X*sQ4o0fR7c4oQ+U%hR0d+UQ5V1VS7q5V9XR9X7rQ,P&YR1Y,PQ5]1[R7u5]Q1h,ZS5l1h8SR8S5nQ0s+iW4x0s4z7i9TQ4z0vQ7i4yR9T7jQ+n%|R0y+nQ1z,mR5|1zYrOXst#cQ&q!ZQ+W%jQ,g&mQ,i&oQ,j&pQ,l&rQ1u,hS1x,m1zR5{1wQ%lpQ&u!_Q&x!aQ&z!bQ&|!cQ'l!tQ+V%iQ+c%vQ+u&SQ,]&hQ,t&wW-e'f'n'o'rQ-l'jQ/y*gQ0n+dS1k,^,aQ2S,sQ2T,vQ2U,wQ2j-dW2l-g-h-k-mQ4q0oQ4}0|Q5Q1QQ5f1bQ5p1mQ5z1vU6Z2k2n2qQ6^2oQ7e4rQ7m5PQ7n5RQ7t5[Q7}5gQ8T5oS8d6[6`Q8f6_Q9U7kQ9^8OQ9c8UQ9j8eQ9z9VQ:P9_Q:T9kR:]:QQ%vyQ'_!iQ'j!tU+d%w%x%yQ,{'QU-`'`'a'bS-d'f'pQ/p*bS0o+e+fQ2[,}S2h-a-bQ2o-iQ4Y/tQ4r0pQ6V2bQ6Y2iQ6_2pR7Z4^S$wi<YR*t%VU%Ui%V<YR0W*rQ$viS(o#u+`Q(s#wS)`$c$dQ*U$xQ*^${Q*m%OQ*n%QQ*w%[Q*x%]Q*|%aQ.a:|Q.b;OQ.d;SQ.e;UQ.f;WQ/S)uS/X){/ZQ/])}Q/_*PQ/a*RQ/i*YQ/n*`Q0U*pQ0V*qh0f+].Z1^3O5c6g7y8j9[9n:O:WQ1Q+wQ1S+zQ3R;_Q3S;aQ3T;cQ3W.iS3l:y:zQ4P/jQ4Q/kQ4U/mQ4b0QQ4d0SQ4j0^Q5R1RQ5T1UQ6k;gQ6l;iQ6m;kQ6n;mQ6s:}Q6t;PQ6v;TQ6w;VQ6x;XQ6}3xQ7U4SQ7Y4[Q7`4fQ7b4nQ7d4pQ8o;dQ8p;`Q8q;bQ8{7TQ9P7^Q9p;hQ9q;jQ9r;lQ9s;nQ9t8wQ:X;qQ:b;rQ;z<YQ<W<bQ<X<cQ<d<fR<e<gnpOXst!Z#c%j&m&o&p&r,h,m1w1zQ!fPS#eZ#nQ&w!`U'c!o5Y7wQ'y#RQ(|#{Q)m$mS,a&f&iQ,f&jQ,s&vQ,x'OQ-[']Q.p(zQ/Q)nQ0b+SQ0i+^Q1s,eQ2f-^Q2|.[Q3s.{Q4h0[Q5a1_Q5r1oQ5s1pQ5w1rQ5y1tQ6O1|Q6f3PQ6{3pQ7{5dQ8X5tQ8Y5uQ8[5xQ8l6jQ9]7|R9g8]#WcOPXZst!Z!`!o#c#n#{%j&f&i&j&m&o&p&r&v'O'](z+S+^,e,h,m-^.[0[1_1o1p1r1t1w1z1|3P5Y5d5t5u5x6j7w7|8]Q#XWQ#dYQ%nuQ%ovS%qw!gS'|#V(PQ(S#YQ(n#tQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)X$YQ)Z$[Q)^$aQ)b$eW)l$m)n.{3pQ+Z%pQ+o%}S-O'S2]Q-m'mS-r'}-tQ-w(VQ-y(^Q.h(rQ.n(vQ.r:cQ.t:fQ.u:gQ.v:jQ/V)yQ0_+OQ2W,yQ2Z,|Q2k-fQ2r-zQ3Y.lQ3_:kQ3`:lQ3a:mQ3b:nQ3c:oQ3d:pQ3e:qQ3f:rQ3g:sQ3h:tQ3i:uQ3j:vQ3k.sQ3n:{Q3o;YQ3t:wQ4k0aQ4s0qQ6U;ZQ6[2mQ6a2sQ6o3ZQ6p;[Q6y;^Q6z;eQ7r5WQ8a6SQ8e6]Q8n;fQ8t;oQ8u;pQ9k8gQ9{9WQ:S9iQ:e#RR<P<]R#ZWR'U!eY!tQ'Z-Y1[5]S'Q!e-QQ'f!rS'p!u!xS'r!y5_S,}'R'YS-i'g'hQ-k'iQ2b-WR2p-jR(t#wR(w#xQ!fQT-X'Z-Y]!qQ!r'Z-Y1[5]Q#o]R'd:dT#jZ%bS#iZ%bS%hm,dU(a#g#h#kS-}(b(cQ.R(dQ0c+TQ2u.OU2v.P.Q.SS6c2w2xR8h6d`#]W#V#Y%e'}(W+Q-xr#fZm#g#h#k%b(b(c(d+T.O.P.Q.S2w2x6dQ1q,dQ2X,zQ6Q2PQ8`6RT;w'S+RT#`W%eS#_W%eS(O#V(WS(T#Y+QS-P'S+RT-s'}-xT'X!e%fQ$kfR)s$pT)h$k)iR3r.zT*X$x*ZR*a${Q0g+]Q2z.ZQ5`1^Q6h3OQ7z5cQ8k6gQ9Y7yQ9l8jQ9}9[Q:V9nQ:[:OR:_:WnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&g!VR,]&dtmOXst!U!V!Z#c%j&d&m&o&p&r,h,m1w1zR,d&jT%im,dR1W+|R,[&bQ&Q|R+t&RR+j%{T&k!W&nT&l!W&nT1y,m1z",
  nodeNames: " ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 371,
  context: OK,
  nodeProps: [
    ["isolate", -8, 4, 5, 13, 33, 35, 48, 50, 52, ""],
    ["group", -26, 8, 16, 18, 65, 201, 205, 209, 210, 212, 215, 218, 228, 230, 236, 238, 240, 242, 245, 251, 257, 259, 261, 263, 265, 267, 268, "Statement", -32, 12, 13, 28, 31, 32, 38, 48, 51, 52, 54, 59, 67, 75, 79, 81, 83, 84, 106, 107, 116, 117, 134, 137, 139, 140, 141, 142, 144, 145, 164, 165, 167, "Expression", -23, 27, 29, 33, 37, 39, 41, 168, 170, 172, 173, 175, 176, 177, 179, 180, 181, 183, 184, 185, 195, 197, 199, 200, "Type", -3, 87, 99, 105, "ClassItem"],
    ["openedBy", 22, "<", 34, "InterpolationStart", 53, "[", 57, "{", 72, "(", 157, "JSXStartCloseTag"],
    ["closedBy", 23, ">", 36, "InterpolationEnd", 47, "]", 58, "}", 73, ")", 162, "JSXEndTag"]
  ],
  propSources: [SK],
  skippedNodes: [0, 4, 5, 271],
  repeatNodeCount: 37,
  tokenData: "$Fj(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Ns!`!a$#_!a!b$(l!b!c$,k!c!}Er!}#O$-u#O#P$/P#P#Q$4h#Q#R$5r#R#SEr#S#T$7P#T#o$8Z#o#p$<k#p#q$=a#q#r$>q#r#s$?}#s$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$I|Er$I|$I}$Dd$I}$JO$Dd$JO$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(n%d_$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$f&j(Op(R!b't(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST(P#S$f&j'u(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$f&j(Op(R!b'u(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$f&j!o$Ip(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|3l_'}$(n$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$f&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$a`$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$a``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$a`$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(R!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$a`(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k#%|:hh$f&j(Op(R!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$f&j(Op(R!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$f&j(R!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$f&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(R!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$f&j(OpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(OpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Op(R!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$f&j(g!L^(Op(R!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$f&j(Op(R!b$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$f&j(Op(R!b$Y#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$f&j(Op(R!b#l$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$f&j$O$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&COLva(p&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$f&j#x$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|! c_(Q$)`$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$f&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$a`$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(OpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$a`(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b(*Q!'t_!k(!b$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!jM|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$f&j(Op(R!b'|#)d#m$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$f&j(Op(R!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$f&j(Op(R!bn&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!Y&;l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$f&j(Op(R!b|'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!XMt$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$f&j(Op(R!b#k$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$f&j(R!b!USOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$f&j!USOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$f&j!USO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!USOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!US#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$f&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$f&j(R!b!USOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ(R!b!USOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb(R!b!USOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX(R!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$f&j(R!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$f&j(Op!USOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$f&j(Op!USOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ(Op!USOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb(Op!USOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX(OpOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$f&j(OpOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$f&j(Op(R!b!USOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d](Op(R!b!USOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe(Op(R!b!USOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ(Op(R!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$f&j(Op(R!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$f&j(Op(R!b'v(;d!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$f&j(Op(R!bS(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$f&j(R!bS(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$f&jS(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSS(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW(R!bS(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$f&j(OpS(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW(OpS(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY(Op(R!bS(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$f&j$O$Id(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$W#t$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!d$b$f&j#|%<f(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I__`l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^#Jk^g!*v!h'.r(Op(R!b(tSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Kg!Q!^*g!^!_#L]!_!`#M}!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KpX$h&j(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LfZ#n$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MX!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MbX$O$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NWX#o$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Oa#[%?x$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!T!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!`_#g$Ih$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#nafBf#o$Id$c#|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$s!`!a$%}!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%O_#o$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&Ya#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'_!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'j`#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(wc(h$Ip$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*S!P!^%Z!^!_*g!_!a%Z!a!b$+^!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*__}'#p$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+i`$f&j#y$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,v_!{!Ln$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.Q_!P(8n$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/UZ$f&jO!^$/w!^!_$0_!_#i$/w#i#j$0d#j#l$/w#l#m$2V#m#o$/w#o#p$0_#p;'S$/w;'S;=`$4b<%lO$/w(n$0OT^#S$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0dO^#S(n$0i[$f&jO!Q&c!Q![$1_![!^&c!_!c&c!c!i$1_!i#T&c#T#Z$1_#Z#o&c#o#p$3u#p;'S&c;'S;=`&w<%lO&c(n$1dZ$f&jO!Q&c!Q![$2V![!^&c!_!c&c!c!i$2V!i#T&c#T#Z$2V#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2[Z$f&jO!Q&c!Q![$2}![!^&c!_!c&c!c!i$2}!i#T&c#T#Z$2}#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3SZ$f&jO!Q&c!Q![$/w![!^&c!_!c&c!c!i$/w!i#T&c#T#Z$/w#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3xR!Q![$4R!c!i$4R#T#Z$4R#S$4US!Q![$4R!c!i$4R#T#Z$4R#q#r$0_(n$4eP;=`<%l$/w!2r$4s_!V!+S$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$5}`#v$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7[_$f&j(Op(R!b(X&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8jk$f&j(Op(R!b'{&;d$[#t([!LYOY%ZYZ&cZr%Zrs&}st%Ztu$8Zuw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$8Z![!^%Z!^!_*g!_!c%Z!c!}$8Z!}#O%Z#O#P&c#P#R%Z#R#S$8Z#S#T%Z#T#o$8Z#o#p*g#p$g%Z$g;'S$8Z;'S;=`$<e<%lO$8Z+d$:jk$f&j(Op(R!b$[#tOY%ZYZ&cZr%Zrs&}st%Ztu$:_uw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$:_![!^%Z!^!_*g!_!c%Z!c!}$:_!}#O%Z#O#P&c#P#R%Z#R#S$:_#S#T%Z#T#o$:_#o#p*g#p$g%Z$g;'S$:_;'S;=`$<_<%lO$:_+d$<bP;=`<%l$:_(CS$<hP;=`<%l$8Z!5p$<tX![!3l(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g&CO$=la(o&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+^#q;'S%Z;'S;=`+a<%lO%Z%#`$?O_!Z$I`r`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@Y_!pS$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Aj|$f&j(Op(R!b't(;d$Y#t'{&;d([!LYOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(CS$Duk$f&j(Op(R!b'u(;d$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [bK, DK, vK, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, xK, new rp("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(Z~~", 141, 332), new rp("j~RQYZXz{^~^O'x~~aP!P!Qd~iO'y~~", 25, 315)],
  topRules: { Script: [0, 6], SingleExpression: [1, 269], SingleClassItem: [2, 270] },
  dialects: { jsx: 0, ts: 14614 },
  dynamicPrecedences: { 69: 1, 79: 1, 81: 1, 165: 1, 193: 1 },
  specialized: [{ term: 319, get: (t) => wK[t] || -1 }, { term: 334, get: (t) => CK[t] || -1 }, { term: 70, get: (t) => EK[t] || -1 }],
  tokenPrec: 14638
}), Uk = [
  /* @__PURE__ */ vr("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ vr("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ vr("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ vr("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ vr("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ vr(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ vr("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ vr(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ vr(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ vr('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ vr('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], TK = /* @__PURE__ */ Uk.concat([
  /* @__PURE__ */ vr("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ vr("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ vr("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), _D = /* @__PURE__ */ new tT(), zk = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function ol(t) {
  return (e, r) => {
    let n = e.node.getChild("VariableDefinition");
    return n && r(n, t), !0;
  };
}
const kK = ["FunctionDeclaration"], PK = {
  FunctionDeclaration: /* @__PURE__ */ ol("function"),
  ClassDeclaration: /* @__PURE__ */ ol("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ ol("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ ol("type"),
  NamespaceDeclaration: /* @__PURE__ */ ol("namespace"),
  VariableDefinition(t, e) {
    t.matchContext(kK) || e(t, "variable");
  },
  TypeDefinition(t, e) {
    e(t, "type");
  },
  __proto__: null
};
function Gk(t, e) {
  let r = _D.get(e);
  if (r)
    return r;
  let n = [], i = !0;
  function s(a, o) {
    let u = t.sliceString(a.from, a.to);
    n.push({ label: u, type: o });
  }
  return e.cursor(ot.IncludeAnonymous).iterate((a) => {
    if (i)
      i = !1;
    else if (a.name) {
      let o = PK[a.name];
      if (o && o(a, s) || zk.has(a.name))
        return !1;
    } else if (a.to - a.from > 8192) {
      for (let o of Gk(t, a.node))
        n.push(o);
      return !1;
    }
  }), _D.set(e, n), n;
}
const QD = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, Hk = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function FK(t) {
  let e = bt(t.state).resolveInner(t.pos, -1);
  if (Hk.indexOf(e.name) > -1)
    return null;
  let r = e.name == "VariableName" || e.to - e.from < 20 && QD.test(t.state.sliceDoc(e.from, e.to));
  if (!r && !t.explicit)
    return null;
  let n = [];
  for (let i = e; i; i = i.parent)
    zk.has(i.name) && (n = n.concat(Gk(t.state.doc, i)));
  return {
    options: n,
    from: r ? e.from : t.pos,
    validFor: QD
  };
}
const ii = /* @__PURE__ */ aa.define({
  name: "javascript",
  parser: /* @__PURE__ */ AK.configure({
    props: [
      /* @__PURE__ */ Zu.add({
        IfStatement: /* @__PURE__ */ eo({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ eo({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: KY,
        SwitchBody: (t) => {
          let e = t.textAfter, r = /^\s*\}/.test(e), n = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (r ? 0 : n ? 1 : 2) * t.unit;
        },
        Block: /* @__PURE__ */ JY({ closing: "}" }),
        ArrowFunction: (t) => t.baseIndent + t.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ eo({ except: /^{/ }),
        JSXElement(t) {
          let e = /^\s*<\//.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        JSXEscape(t) {
          let e = /\s*\}/.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        }
      }),
      /* @__PURE__ */ Wu.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": M0,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), Jk = {
  test: (t) => /^JSX/.test(t.name),
  facet: /* @__PURE__ */ sT({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, Kk = /* @__PURE__ */ ii.configure({ dialect: "ts" }, "typescript"), eP = /* @__PURE__ */ ii.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ N0.add((t) => t.isTop ? [Jk] : void 0)]
}), tP = /* @__PURE__ */ ii.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ N0.add((t) => t.isTop ? [Jk] : void 0)]
}, "typescript");
let rP = (t) => ({ label: t, type: "keyword" });
const nP = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(rP), $K = /* @__PURE__ */ nP.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(rP));
function iP(t = {}) {
  let e = t.jsx ? t.typescript ? tP : eP : t.typescript ? Kk : ii, r = t.typescript ? TK.concat($K) : Uk.concat(nP);
  return new od(e, [
    ii.data.of({
      autocomplete: gG(Hk, hk(r))
    }),
    ii.data.of({
      autocomplete: FK
    }),
    t.jsx ? NK : []
  ]);
}
function BK(t) {
  for (; ; ) {
    if (t.name == "JSXOpenTag" || t.name == "JSXSelfClosingTag" || t.name == "JSXFragmentTag")
      return t;
    if (t.name == "JSXEscape" || !t.parent)
      return null;
    t = t.parent;
  }
}
function MD(t, e, r = t.length) {
  for (let n = e == null ? void 0 : e.firstChild; n; n = n.nextSibling)
    if (n.name == "JSXIdentifier" || n.name == "JSXBuiltin" || n.name == "JSXNamespacedName" || n.name == "JSXMemberExpression")
      return t.sliceString(n.from, Math.min(n.to, r));
  return "";
}
const IK = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), NK = /* @__PURE__ */ ue.inputHandler.of((t, e, r, n, i) => {
  if ((IK ? t.composing : t.compositionStarted) || t.state.readOnly || e != r || n != ">" && n != "/" || !ii.isActiveAt(t.state, e, -1))
    return !1;
  let s = i(), { state: a } = s, o = a.changeByRange((u) => {
    var c;
    let { head: h } = u, p = bt(a).resolveInner(h - 1, -1), m;
    if (p.name == "JSXStartTag" && (p = p.parent), !(a.doc.sliceString(h - 1, h) != n || p.name == "JSXAttributeValue" && p.to > h)) {
      if (n == ">" && p.name == "JSXFragmentTag")
        return { range: u, changes: { from: h, insert: "</>" } };
      if (n == "/" && p.name == "JSXStartCloseTag") {
        let g = p.parent, O = g.parent;
        if (O && g.from == h - 2 && ((m = MD(a.doc, O.firstChild, h)) || ((c = O.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")) {
          let b = `${m}>`;
          return { range: G.cursor(h + b.length, -1), changes: { from: h, insert: b } };
        }
      } else if (n == ">") {
        let g = BK(p);
        if (g && !/^\/?>|^<\//.test(a.doc.sliceString(h, h + 2)) && (m = MD(a.doc, g, h)))
          return { range: u, changes: { from: h, insert: `</${m}>` } };
      }
    }
    return { range: u };
  });
  return o.changes.empty ? !1 : (t.dispatch([
    s,
    a.update(o, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
}), ll = ["_blank", "_self", "_top", "_parent"], Qf = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], Mf = ["get", "post", "put", "delete"], Lf = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Rr = ["true", "false"], xe = {}, _K = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: ll,
      hreflang: null
    }
  },
  abbr: xe,
  address: xe,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: xe,
  aside: xe,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: xe,
  base: { attrs: { href: null, target: ll } },
  bdi: xe,
  bdo: xe,
  blockquote: { attrs: { cite: null } },
  body: xe,
  br: xe,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: Lf,
      formmethod: Mf,
      formnovalidate: ["novalidate"],
      formtarget: ll,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: xe,
  center: xe,
  cite: xe,
  code: xe,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: xe,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: xe,
  div: xe,
  dl: xe,
  dt: xe,
  em: xe,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: xe,
  figure: xe,
  footer: xe,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Qf,
      autocomplete: ["on", "off"],
      enctype: Lf,
      method: Mf,
      novalidate: ["novalidate"],
      target: ll
    }
  },
  h1: xe,
  h2: xe,
  h3: xe,
  h4: xe,
  h5: xe,
  h6: xe,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: xe,
  hgroup: xe,
  hr: xe,
  html: {
    attrs: { manifest: null }
  },
  i: xe,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: Lf,
      formmethod: Mf,
      formnovalidate: ["novalidate"],
      formtarget: ll,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: xe,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: xe,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: xe,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Qf,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: xe,
  noscript: xe,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: xe,
  param: { attrs: { name: null, value: null } },
  pre: xe,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: xe,
  rt: xe,
  ruby: xe,
  samp: xe,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Qf
    }
  },
  section: xe,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: xe,
  source: { attrs: { src: null, type: null, media: null } },
  span: xe,
  strong: xe,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: xe,
  summary: xe,
  sup: xe,
  table: xe,
  tbody: xe,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: xe,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: xe,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: xe,
  time: { attrs: { datetime: null } },
  title: xe,
  tr: xe,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: xe,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: xe
}, sP = {
  accesskey: null,
  class: null,
  contenteditable: Rr,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Rr,
  autocorrect: Rr,
  autocapitalize: Rr,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Rr,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Rr,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Rr,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Rr,
  "aria-hidden": Rr,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Rr,
  "aria-multiselectable": Rr,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Rr,
  "aria-relevant": null,
  "aria-required": Rr,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, aP = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((t) => "on" + t);
for (let t of aP)
  sP[t] = null;
class ap {
  constructor(e, r) {
    this.tags = Object.assign(Object.assign({}, _K), e), this.globalAttrs = Object.assign(Object.assign({}, sP), r), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
ap.default = /* @__PURE__ */ new ap();
function Oo(t, e, r = t.length) {
  if (!e)
    return "";
  let n = e.firstChild, i = n && n.getChild("TagName");
  return i ? t.sliceString(i.from, Math.min(i.to, r)) : "";
}
function xo(t, e = !1) {
  for (; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = !1;
      else
        return t;
  return null;
}
function oP(t, e, r) {
  let n = r.tags[Oo(t, xo(e))];
  return (n == null ? void 0 : n.children) || r.allTags;
}
function eO(t, e) {
  let r = [];
  for (let n = xo(e); n && !n.type.isTop; n = xo(n.parent)) {
    let i = Oo(t, n);
    if (i && n.lastChild.name == "CloseTag")
      break;
    i && r.indexOf(i) < 0 && (e.name == "EndTag" || e.from >= n.firstChild.to) && r.push(i);
  }
  return r;
}
const lP = /^[:\-\.\w\u00b7-\uffff]*$/;
function LD(t, e, r, n, i) {
  let s = /\s*>/.test(t.sliceDoc(i, i + 5)) ? "" : ">", a = xo(r, !0);
  return {
    from: n,
    to: i,
    options: oP(t.doc, a, e).map((o) => ({ label: o, type: "type" })).concat(eO(t.doc, r).map((o, u) => ({
      label: "/" + o,
      apply: "/" + o + s,
      type: "type",
      boost: 99 - u
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function RD(t, e, r, n) {
  let i = /\s*>/.test(t.sliceDoc(n, n + 5)) ? "" : ">";
  return {
    from: r,
    to: n,
    options: eO(t.doc, e).map((s, a) => ({ label: s, apply: s + i, type: "type", boost: 99 - a })),
    validFor: lP
  };
}
function QK(t, e, r, n) {
  let i = [], s = 0;
  for (let a of oP(t.doc, r, e))
    i.push({ label: "<" + a, type: "type" });
  for (let a of eO(t.doc, r))
    i.push({ label: "</" + a + ">", type: "type", boost: 99 - s++ });
  return { from: n, to: n, options: i, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function MK(t, e, r, n, i) {
  let s = xo(r), a = s ? e.tags[Oo(t.doc, s)] : null, o = a && a.attrs ? Object.keys(a.attrs) : [], u = a && a.globalAttrs === !1 ? o : o.length ? o.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: n,
    to: i,
    options: u.map((c) => ({ label: c, type: "property" })),
    validFor: lP
  };
}
function LK(t, e, r, n, i) {
  var s;
  let a = (s = r.parent) === null || s === void 0 ? void 0 : s.getChild("AttributeName"), o = [], u;
  if (a) {
    let c = t.sliceDoc(a.from, a.to), h = e.globalAttrs[c];
    if (!h) {
      let p = xo(r), m = p ? e.tags[Oo(t.doc, p)] : null;
      h = (m == null ? void 0 : m.attrs) && m.attrs[c];
    }
    if (h) {
      let p = t.sliceDoc(n, i).toLowerCase(), m = '"', g = '"';
      /^['"]/.test(p) ? (u = p[0] == '"' ? /^[^"]*$/ : /^[^']*$/, m = "", g = t.sliceDoc(i, i + 1) == p[0] ? "" : p[0], p = p.slice(1), n++) : u = /^[^\s<>='"]*$/;
      for (let O of h)
        o.push({ label: O, apply: m + O + g, type: "constant" });
    }
  }
  return { from: n, to: i, options: o, validFor: u };
}
function RK(t, e) {
  let { state: r, pos: n } = e, i = bt(r).resolveInner(n, -1), s = i.resolve(n);
  for (let a = n, o; s == i && (o = i.childBefore(a)); ) {
    let u = o.lastChild;
    if (!u || !u.type.isError || u.from < u.to)
      break;
    s = i = o, a = u.from;
  }
  return i.name == "TagName" ? i.parent && /CloseTag$/.test(i.parent.name) ? RD(r, i, i.from, n) : LD(r, t, i, i.from, n) : i.name == "StartTag" ? LD(r, t, i, n, n) : i.name == "StartCloseTag" || i.name == "IncompleteCloseTag" ? RD(r, i, n, n) : i.name == "OpenTag" || i.name == "SelfClosingTag" || i.name == "AttributeName" ? MK(r, t, i, i.name == "AttributeName" ? i.from : n, n) : i.name == "Is" || i.name == "AttributeValue" || i.name == "UnquotedAttributeValue" ? LK(r, t, i, i.name == "Is" ? n : i.from, n) : e.explicit && (s.name == "Element" || s.name == "Text" || s.name == "Document") ? QK(r, t, i, n) : null;
}
function jK(t) {
  let { extraTags: e, extraGlobalAttributes: r } = t, n = r || e ? new ap(e, r) : ap.default;
  return (i) => RK(n, i);
}
const ZK = /* @__PURE__ */ ii.parser.configure({ top: "SingleExpression" }), uP = [
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript" || t.lang == "ts",
    parser: Kk.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/babel" || t.type == "text/jsx",
    parser: eP.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript-jsx",
    parser: tP.parser
  },
  {
    tag: "script",
    attrs(t) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(t.type);
    },
    parser: ZK
  },
  {
    tag: "script",
    attrs(t) {
      return !t.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t.type);
    },
    parser: ii.parser
  },
  {
    tag: "style",
    attrs(t) {
      return (!t.lang || t.lang == "css") && (!t.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t.type));
    },
    parser: sp.parser
  }
], cP = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ sp.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ aP.map((t) => ({ name: t, parser: ii.parser }))), hP = /* @__PURE__ */ aa.define({
  name: "html",
  parser: /* @__PURE__ */ TJ.configure({
    props: [
      /* @__PURE__ */ Zu.add({
        Element(t) {
          let e = /^(\s*)(<\/)?/.exec(t.textAfter);
          return t.node.to <= t.pos + e[0].length ? t.continue() : t.lineIndent(t.node.from) + (e[2] ? 0 : t.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        },
        Document(t) {
          if (t.pos + /\s*/.exec(t.textAfter)[0].length < t.node.to)
            return t.continue();
          let e = null, r;
          for (let n = t.node; ; ) {
            let i = n.lastChild;
            if (!i || i.name != "Element" || i.to != n.to)
              break;
            e = n = i;
          }
          return e && !((r = e.lastChild) && (r.name == "CloseTag" || r.name == "SelfClosingTag")) ? t.lineIndent(e.from) + t.unit : null;
        }
      }),
      /* @__PURE__ */ Wu.add({
        Element(t) {
          let e = t.firstChild, r = t.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: r.name == "CloseTag" ? r.from : t.to };
        }
      }),
      /* @__PURE__ */ bT.add({
        "OpenTag CloseTag": (t) => t.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), dh = /* @__PURE__ */ hP.configure({
  wrap: /* @__PURE__ */ Zk(uP, cP)
});
function WK(t = {}) {
  let e = "", r;
  t.matchClosingTags === !1 && (e = "noMatch"), t.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"), (t.nestedLanguages && t.nestedLanguages.length || t.nestedAttributes && t.nestedAttributes.length) && (r = Zk((t.nestedLanguages || []).concat(uP), (t.nestedAttributes || []).concat(cP)));
  let n = r ? hP.configure({ wrap: r, dialect: e }) : e ? dh.configure({ dialect: e }) : dh;
  return new od(n, [
    dh.data.of({ autocomplete: jK(t) }),
    t.autoCloseTags !== !1 ? qK : [],
    iP().support,
    Vk().support
  ]);
}
const jD = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), qK = /* @__PURE__ */ ue.inputHandler.of((t, e, r, n, i) => {
  if (t.composing || t.state.readOnly || e != r || n != ">" && n != "/" || !dh.isActiveAt(t.state, e, -1))
    return !1;
  let s = i(), { state: a } = s, o = a.changeByRange((u) => {
    var c, h, p;
    let m = a.doc.sliceString(u.from - 1, u.to) == n, { head: g } = u, O = bt(a).resolveInner(g - 1, -1), b;
    if ((O.name == "TagName" || O.name == "StartTag") && (O = O.parent), m && n == ">" && O.name == "OpenTag") {
      if (((h = (c = O.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || h === void 0 ? void 0 : h.name) != "CloseTag" && (b = Oo(a.doc, O.parent, g)) && !jD.has(b)) {
        let D = g + (a.doc.sliceString(g, g + 1) === ">" ? 1 : 0), S = `</${b}>`;
        return { range: u, changes: { from: g, to: D, insert: S } };
      }
    } else if (m && n == "/" && O.name == "IncompleteCloseTag") {
      let D = O.parent;
      if (O.from == g - 2 && ((p = D.lastChild) === null || p === void 0 ? void 0 : p.name) != "CloseTag" && (b = Oo(a.doc, D, g)) && !jD.has(b)) {
        let S = g + (a.doc.sliceString(g, g + 1) === ">" ? 1 : 0), x = `${b}>`;
        return {
          range: G.cursor(g + x.length, -1),
          changes: { from: g, to: S, insert: x }
        };
      }
    }
    return { range: u };
  });
  return o.changes.empty ? !1 : (t.dispatch([
    s,
    a.update(o, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), XK = Ru({
  String: Q.string,
  Number: Q.number,
  "True False": Q.bool,
  PropertyName: Q.propertyName,
  Null: Q.null,
  ",": Q.separator,
  "[ ]": Q.squareBracket,
  "{ }": Q.brace
}), VK = la.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: " JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [XK],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), YK = /* @__PURE__ */ aa.define({
  name: "json",
  parser: /* @__PURE__ */ VK.configure({
    props: [
      /* @__PURE__ */ Zu.add({
        Object: /* @__PURE__ */ eo({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ eo({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ Wu.add({
        "Object Array": M0
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function UK() {
  return new od(YK);
}
const zK = () => {
  const { config: t } = kr();
  return kF(t);
}, GK = {
  html: WK(),
  css: Vk(),
  js: iP(),
  json: UK()
}, HK = () => {
  var h;
  const {
    project: t,
    saveFile: e,
    config: { editableFileTypes: r, defaultTheme: n = "light" }
  } = kr(), [i, s] = At(n), a = zK(), o = (h = Object.values(t.files).filter((p) => p.active)) == null ? void 0 : h[0], u = Ht(
    (p) => {
      e(o.id, p);
    },
    [e, o]
  ), c = async () => {
    try {
      const p = await bZ(o.contents, o.language);
      e(o.id, p);
    } catch (p) {
      console.log("FAILURE : ", p);
    }
  };
  return o ? XD(o.language, r) ? /* @__PURE__ */ z.jsxs("div", { className: "editor-container", children: [
    /* @__PURE__ */ z.jsxs("div", { className: "button-bar", children: [
      /* @__PURE__ */ z.jsx("button", { onClick: () => c(), children: "Format" }),
      /* @__PURE__ */ z.jsxs(
        "select",
        {
          onChange: (p) => s(p.target.value),
          value: i,
          children: [
            /* @__PURE__ */ z.jsx("option", { value: "light", children: "light theme" }),
            /* @__PURE__ */ z.jsx("option", { value: "dark", children: "dark theme" })
          ]
        }
      )
    ] }),
    o && /* @__PURE__ */ z.jsx(
      kk,
      {
        value: o.contents,
        width: "100%",
        height: "100%",
        extensions: [GK[o.language]],
        onChange: u,
        theme: i
      }
    )
  ] }) : /* @__PURE__ */ z.jsxs("div", { children: [
    "Can only edit html, css, or javascript files. Cannot edit",
    " ",
    o.language,
    " files."
  ] }) : /* @__PURE__ */ z.jsx(a, {});
}, JK = () => {
  const { config: t } = kr(), e = t.EditorComponent || HK;
  return /* @__PURE__ */ z.jsxs("div", { className: "center-pane", children: [
    /* @__PURE__ */ z.jsx("div", { className: "center-nav", children: /* @__PURE__ */ z.jsx(Cq, {}) }),
    /* @__PURE__ */ z.jsx("div", { className: "center-main", children: /* @__PURE__ */ z.jsx(e, {}) })
  ] });
}, KK = ({ file: t }) => {
  const e = et(null), {
    project: { files: r, folders: n }
  } = kr(), i = Ke(() => t ? t.contents.replace(
    new RegExp('<link rel="stylesheet" href="([^"]+)"\\s*/>', "g"),
    (a, o) => {
      const u = o.split("/"), c = u.pop(), h = VD(u, {
        folders: Object.values(n)
      }), p = Object.values(r).find(
        (m) => m.name === c && m.folderId === h
      );
      return `
          <style>
            ${p == null ? void 0 : p.contents}
          </style>
      `;
    }
  ) : "", [r, t]);
  return /* @__PURE__ */ z.jsx(z.Fragment, { children: t && /* @__PURE__ */ z.jsx(
    "iframe",
    {
      sandbox: "",
      allow: "self",
      title: "Web Preview",
      ref: e,
      id: "preview",
      style: { width: "100%", height: "100%", backgroundColor: "white" },
      srcDoc: i
    }
  ) });
};
var pP = { exports: {} };
(function(t, e) {
  (function(n, i) {
    t.exports = i();
  })(DF, function() {
    return (
      /******/
      function(r) {
        var n = {};
        function i(s) {
          if (n[s])
            return n[s].exports;
          var a = n[s] = {
            /******/
            i: s,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return r[s].call(a.exports, a, a.exports, i), a.l = !0, a.exports;
        }
        return i.m = r, i.c = n, i.i = function(s) {
          return s;
        }, i.d = function(s, a, o) {
          i.o(s, a) || Object.defineProperty(s, a, {
            /******/
            configurable: !1,
            /******/
            enumerable: !0,
            /******/
            get: o
            /******/
          });
        }, i.n = function(s) {
          var a = s && s.__esModule ? (
            /******/
            function() {
              return s.default;
            }
          ) : (
            /******/
            function() {
              return s;
            }
          );
          return i.d(a, "a", a), a;
        }, i.o = function(s, a) {
          return Object.prototype.hasOwnProperty.call(s, a);
        }, i.p = "", i(i.s = 3);
      }([
        /* 0 */
        /***/
        function(r, n, i) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          });
          var s = Object.assign || function(D) {
            for (var S = 1; S < arguments.length; S++) {
              var x = arguments[S];
              for (var w in x)
                Object.prototype.hasOwnProperty.call(x, w) && (D[w] = x[w]);
            }
            return D;
          }, a = /* @__PURE__ */ function() {
            function D(S, x) {
              for (var w = 0; w < x.length; w++) {
                var T = x[w];
                T.enumerable = T.enumerable || !1, T.configurable = !0, "value" in T && (T.writable = !0), Object.defineProperty(S, T.key, T);
              }
            }
            return function(S, x, w) {
              return x && D(S.prototype, x), w && D(S, w), S;
            };
          }();
          function o(D) {
            if (Array.isArray(D)) {
              for (var S = 0, x = Array(D.length); S < D.length; S++)
                x[S] = D[S];
              return x;
            } else
              return Array.from(D);
          }
          function u(D, S) {
            if (!(D instanceof S))
              throw new TypeError("Cannot call a class as a function");
          }
          var c = n.TYPE_MESSAGE = "message", h = n.TYPE_RESPONSE = "response", p = n.TYPE_SET_INTERFACE = "set-interface", m = n.TYPE_SERVICE_MESSAGE = "service-message", g = !!window.MSInputMethodContext && !!document.documentMode, O = {
            //Will not affect IE11 because there sandboxed iframe has not 'null' origin
            //but base URL of iframe's src
            allowedSenderOrigin: void 0
          }, b = function() {
            function D(S, x, w) {
              var T = this;
              u(this, D), this.options = s({}, O, w), this.incrementalID = Math.floor(Math.random() * 1e5), this.postMessage = S, this.remote = {}, this.callbacks = {}, this.remoteMethodsWaitPromise = new Promise(function(C) {
                T._resolveRemoteMethodsPromise = C;
              }), x(function() {
                return T.onMessageListener.apply(T, arguments);
              });
            }
            return a(D, [{
              key: "onMessageListener",
              value: function(x) {
                var w = this, T = x.data, C = this.options.allowedSenderOrigin;
                C && x.origin !== C && !g || (T.type === h ? this.popCallback(T.callId, T.success, T.result) : T.type === c ? this.callLocalApi(T.methodName, T.arguments).then(function(A) {
                  return w.responseOtherSide(T.callId, A);
                }).catch(function(A) {
                  return w.responseOtherSide(T.callId, A, !1);
                }) : T.type === p ? (this.setInterface(T.apiMethods), this.responseOtherSide(T.callId)) : T.type === m && this.callLocalServiceMethod(T.methodName, T.arguments).then(function(A) {
                  return w.responseOtherSide(T.callId, A);
                }).catch(function(A) {
                  return w.responseOtherSide(T.callId, A, !1);
                }));
              }
            }, {
              key: "postMessageToOtherSide",
              value: function(x) {
                this.postMessage(x, "*");
              }
              /**
                 * Sets remote interface methods
                 * @param remote - hash with keys of remote API methods. Values is ignored
                 */
            }, {
              key: "setInterface",
              value: function(x) {
                var w = this;
                this.remote = {}, x.forEach(function(T) {
                  return w.remote[T] = w.createMethodWrapper(T);
                }), this._resolveRemoteMethodsPromise();
              }
            }, {
              key: "setLocalApi",
              value: function(x) {
                var w = this;
                return new Promise(function(T, C) {
                  var A = w.registerCallback(T, C);
                  w.postMessageToOtherSide({
                    callId: A,
                    apiMethods: Object.keys(x),
                    type: p
                  });
                }).then(function() {
                  return w.localApi = x;
                });
              }
            }, {
              key: "setServiceMethods",
              value: function(x) {
                this.serviceMethods = x;
              }
              /**
                 * Calls local method
                 * @param methodName
                 * @param args
                 * @returns {Promise.<*>|string}
                 */
            }, {
              key: "callLocalApi",
              value: function(x, w) {
                var T;
                return Promise.resolve((T = this.localApi)[x].apply(T, o(w)));
              }
              /**
                 * Calls local method registered as "service method"
                 * @param methodName
                 * @param args
                 * @returns {Promise.<*>}
                 */
            }, {
              key: "callLocalServiceMethod",
              value: function(x, w) {
                var T;
                if (!this.serviceMethods[x])
                  throw new Error("Serivce method " + x + " is not registered");
                return Promise.resolve((T = this.serviceMethods)[x].apply(T, o(w)));
              }
              /**
                 * Wraps remote method with callback storing code
                 * @param methodName - method to wrap
                 * @returns {Function} - function to call as remote API interface
                 */
            }, {
              key: "createMethodWrapper",
              value: function(x) {
                var w = this;
                return function() {
                  for (var T = arguments.length, C = Array(T), A = 0; A < T; A++)
                    C[A] = arguments[A];
                  return w.callRemoteMethod.apply(w, [x].concat(C));
                };
              }
              /**
                 * Calls other side with arguments provided
                 * @param id
                 * @param methodName
                 * @param args
                 */
            }, {
              key: "callRemoteMethod",
              value: function(x) {
                for (var w = this, T = arguments.length, C = Array(T > 1 ? T - 1 : 0), A = 1; A < T; A++)
                  C[A - 1] = arguments[A];
                return new Promise(function(P, $) {
                  var B = w.registerCallback(P, $);
                  w.postMessageToOtherSide({
                    callId: B,
                    methodName: x,
                    type: c,
                    arguments: C
                  });
                });
              }
              /**
                 * Calls remote service method
                 * @param methodName
                 * @param args
                 * @returns {*}
                 */
            }, {
              key: "callRemoteServiceMethod",
              value: function(x) {
                for (var w = this, T = arguments.length, C = Array(T > 1 ? T - 1 : 0), A = 1; A < T; A++)
                  C[A - 1] = arguments[A];
                return new Promise(function(P, $) {
                  var B = w.registerCallback(P, $);
                  w.postMessageToOtherSide({
                    callId: B,
                    methodName: x,
                    type: m,
                    arguments: C
                  });
                });
              }
              /**
                 * Respond to remote call
                 * @param id - remote call ID
                 * @param result - result to pass to calling function
                 */
            }, {
              key: "responseOtherSide",
              value: function(x, w) {
                var T = this, C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
                w instanceof Error && (w = [].concat(o(Object.keys(w)), ["message"]).reduce(function(P, $) {
                  return P[$] = w[$], P;
                }, {}));
                var A = function() {
                  return T.postMessage({
                    callId: x,
                    type: h,
                    success: C,
                    result: w
                  }, "*");
                };
                try {
                  A();
                } catch (P) {
                  console.error("Failed to post response, recovering...", P), P instanceof DOMException && (w = JSON.parse(JSON.stringify(w)), A());
                }
              }
              /**
                 * Stores callbacks to call later when remote call will be answered
                 * @param successCallback
                 * @param failureCallback
                 */
            }, {
              key: "registerCallback",
              value: function(x, w) {
                var T = (++this.incrementalID).toString();
                return this.callbacks[T] = { successCallback: x, failureCallback: w }, T;
              }
              /**
                 * Calls and delete stored callback
                 * @param id - call id
                 * @param success - was call successful
                 * @param result - result of remote call
                 */
            }, {
              key: "popCallback",
              value: function(x, w, T) {
                w ? this.callbacks[x].successCallback(T) : this.callbacks[x].failureCallback(T), delete this.callbacks[x];
              }
            }]), D;
          }();
          n.default = b;
        },
        /* 1 */
        /***/
        function(r, n) {
          r.exports = `/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TYPE_MESSAGE = exports.TYPE_MESSAGE = 'message';
var TYPE_RESPONSE = exports.TYPE_RESPONSE = 'response';
var TYPE_SET_INTERFACE = exports.TYPE_SET_INTERFACE = 'set-interface';
var TYPE_SERVICE_MESSAGE = exports.TYPE_SERVICE_MESSAGE = 'service-message';

var isIE11 = !!window.MSInputMethodContext && !!document.documentMode;

var defaultOptions = {
  //Will not affect IE11 because there sandboxed iframe has not 'null' origin
  //but base URL of iframe's src
  allowedSenderOrigin: undefined
};

var Connection = function () {
  function Connection(postMessage, registerOnMessageListener, options) {
    var _this = this;

    _classCallCheck(this, Connection);

    this.options = _extends({}, defaultOptions, options);
    //Random number between 0 and 100000
    this.incrementalID = Math.floor(Math.random() * 100000);

    this.postMessage = postMessage;
    this.remote = {};
    this.callbacks = {};

    this.remoteMethodsWaitPromise = new Promise(function (resolve) {
      _this._resolveRemoteMethodsPromise = resolve;
    });

    registerOnMessageListener(function () {
      return _this.onMessageListener.apply(_this, arguments);
    });
  }

  /**
     * Listens to remote messages. Calls local method if it is called outside or call stored callback if it is response.
     * @param e - onMessage event
     */


  _createClass(Connection, [{
    key: 'onMessageListener',
    value: function onMessageListener(e) {
      var _this2 = this;

      var data = e.data;

      var allowedSenderOrigin = this.options.allowedSenderOrigin;

      if (allowedSenderOrigin && e.origin !== allowedSenderOrigin && !isIE11) {
        return;
      }

      if (data.type === TYPE_RESPONSE) {
        this.popCallback(data.callId, data.success, data.result);
      } else if (data.type === TYPE_MESSAGE) {
        this.callLocalApi(data.methodName, data.arguments).then(function (res) {
          return _this2.responseOtherSide(data.callId, res);
        }).catch(function (err) {
          return _this2.responseOtherSide(data.callId, err, false);
        });
      } else if (data.type === TYPE_SET_INTERFACE) {
        this.setInterface(data.apiMethods);
        this.responseOtherSide(data.callId);
      } else if (data.type === TYPE_SERVICE_MESSAGE) {
        this.callLocalServiceMethod(data.methodName, data.arguments).then(function (res) {
          return _this2.responseOtherSide(data.callId, res);
        }).catch(function (err) {
          return _this2.responseOtherSide(data.callId, err, false);
        });
      }
    }
  }, {
    key: 'postMessageToOtherSide',
    value: function postMessageToOtherSide(dataToPost) {
      this.postMessage(dataToPost, '*');
    }

    /**
       * Sets remote interface methods
       * @param remote - hash with keys of remote API methods. Values is ignored
       */

  }, {
    key: 'setInterface',
    value: function setInterface(remoteMethods) {
      var _this3 = this;

      this.remote = {};

      remoteMethods.forEach(function (key) {
        return _this3.remote[key] = _this3.createMethodWrapper(key);
      });

      this._resolveRemoteMethodsPromise();
    }
  }, {
    key: 'setLocalApi',
    value: function setLocalApi(api) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        var id = _this4.registerCallback(resolve, reject);
        _this4.postMessageToOtherSide({
          callId: id,
          apiMethods: Object.keys(api),
          type: TYPE_SET_INTERFACE
        });
      }).then(function () {
        return _this4.localApi = api;
      });
    }
  }, {
    key: 'setServiceMethods',
    value: function setServiceMethods(api) {
      this.serviceMethods = api;
    }

    /**
       * Calls local method
       * @param methodName
       * @param args
       * @returns {Promise.<*>|string}
       */

  }, {
    key: 'callLocalApi',
    value: function callLocalApi(methodName, args) {
      var _localApi;

      return Promise.resolve((_localApi = this.localApi)[methodName].apply(_localApi, _toConsumableArray(args)));
    }

    /**
       * Calls local method registered as "service method"
       * @param methodName
       * @param args
       * @returns {Promise.<*>}
       */

  }, {
    key: 'callLocalServiceMethod',
    value: function callLocalServiceMethod(methodName, args) {
      var _serviceMethods;

      if (!this.serviceMethods[methodName]) {
        throw new Error('Serivce method ' + methodName + ' is not registered');
      }
      return Promise.resolve((_serviceMethods = this.serviceMethods)[methodName].apply(_serviceMethods, _toConsumableArray(args)));
    }

    /**
       * Wraps remote method with callback storing code
       * @param methodName - method to wrap
       * @returns {Function} - function to call as remote API interface
       */

  }, {
    key: 'createMethodWrapper',
    value: function createMethodWrapper(methodName) {
      var _this5 = this;

      return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return _this5.callRemoteMethod.apply(_this5, [methodName].concat(args));
      };
    }

    /**
       * Calls other side with arguments provided
       * @param id
       * @param methodName
       * @param args
       */

  }, {
    key: 'callRemoteMethod',
    value: function callRemoteMethod(methodName) {
      var _this6 = this;

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return new Promise(function (resolve, reject) {
        var id = _this6.registerCallback(resolve, reject);
        _this6.postMessageToOtherSide({
          callId: id,
          methodName: methodName,
          type: TYPE_MESSAGE,
          arguments: args
        });
      });
    }

    /**
       * Calls remote service method
       * @param methodName
       * @param args
       * @returns {*}
       */

  }, {
    key: 'callRemoteServiceMethod',
    value: function callRemoteServiceMethod(methodName) {
      var _this7 = this;

      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return new Promise(function (resolve, reject) {
        var id = _this7.registerCallback(resolve, reject);
        _this7.postMessageToOtherSide({
          callId: id,
          methodName: methodName,
          type: TYPE_SERVICE_MESSAGE,
          arguments: args
        });
      });
    }

    /**
       * Respond to remote call
       * @param id - remote call ID
       * @param result - result to pass to calling function
       */

  }, {
    key: 'responseOtherSide',
    value: function responseOtherSide(id, result) {
      var _this8 = this;

      var success = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (result instanceof Error) {
        // Error could be non-serializable, so we copy properties manually
        result = [].concat(_toConsumableArray(Object.keys(result)), ['message']).reduce(function (acc, it) {
          acc[it] = result[it];
          return acc;
        }, {});
      }

      var doPost = function doPost() {
        return _this8.postMessage({
          callId: id,
          type: TYPE_RESPONSE,
          success: success,
          result: result
        }, '*');
      };

      try {
        doPost();
      } catch (err) {
        console.error('Failed to post response, recovering...', err); // eslint-disable-line no-console
        if (err instanceof DOMException) {
          result = JSON.parse(JSON.stringify(result));
          doPost();
        }
      }
    }

    /**
       * Stores callbacks to call later when remote call will be answered
       * @param successCallback
       * @param failureCallback
       */

  }, {
    key: 'registerCallback',
    value: function registerCallback(successCallback, failureCallback) {
      var id = (++this.incrementalID).toString();
      this.callbacks[id] = { successCallback: successCallback, failureCallback: failureCallback };
      return id;
    }

    /**
       * Calls and delete stored callback
       * @param id - call id
       * @param success - was call successful
       * @param result - result of remote call
       */

  }, {
    key: 'popCallback',
    value: function popCallback(id, success, result) {
      if (success) {
        this.callbacks[id].successCallback(result);
      } else {
        this.callbacks[id].failureCallback(result);
      }
      delete this.callbacks[id];
    }
  }]);

  return Connection;
}();

exports.default = Connection;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _connection = __webpack_require__(0);

var _connection2 = _interopRequireDefault(_connection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Frame = function () {
  function Frame() {
    var _this = this;

    _classCallCheck(this, Frame);

    this.connection = new _connection2.default(window.parent.postMessage.bind(window.parent), function (listener) {
      window.addEventListener('message', listener);
    });

    this.connection.setServiceMethods({
      runCode: function runCode(code) {
        return _this.runCode(code);
      },
      importScript: function importScript(path) {
        return _this.importScript(path);
      },
      injectStyle: function injectStyle(style) {
        return _this.injectStyle(style);
      },
      importStyle: function importStyle(path) {
        return _this.importStyle(path);
      }
    });

    this.connection.callRemoteServiceMethod('iframeInitialized');
  }

  /**
     * Creates script tag with passed code and attaches it. Runs synchronous
     * @param code
     */


  _createClass(Frame, [{
    key: 'runCode',
    value: function runCode(code) {
      var scriptTag = document.createElement('script');
      scriptTag.innerHTML = code;
      document.getElementsByTagName('head')[0].appendChild(scriptTag);
    }
  }, {
    key: 'importScript',
    value: function importScript(scriptUrl) {
      var scriptTag = document.createElement('script');
      scriptTag.src = scriptUrl;
      document.getElementsByTagName('head')[0].appendChild(scriptTag);
      return new Promise(function (resolve) {
        return scriptTag.onload = function () {
          return resolve();
        };
      });
    }
  }, {
    key: 'injectStyle',
    value: function injectStyle(style) {
      var styleTag = document.createElement('style');
      styleTag.innerHTML = style;
      document.getElementsByTagName('head')[0].appendChild(styleTag);
    }
  }, {
    key: 'importStyle',
    value: function importStyle(styleUrl) {
      var linkTag = document.createElement('link');
      linkTag.rel = 'stylesheet';
      linkTag.href = styleUrl;
      document.getElementsByTagName('head')[0].appendChild(linkTag);
    }
  }]);

  return Frame;
}();

var Websandbox = new Frame();
window.Websandbox = window.Websandbox || Websandbox;
module.exports = Websandbox; // eslint-disable-line

/***/ })
/******/ ]);
//# sourceMappingURL=compile-loader-file-name.js.map`;
        },
        ,
        /* 3 */
        /***/
        function(r, n, i) {
          Object.defineProperty(n, "__esModule", {
            value: !0
          }), n.BaseOptions = void 0;
          var s = Object.assign || function(b) {
            for (var D = 1; D < arguments.length; D++) {
              var S = arguments[D];
              for (var x in S)
                Object.prototype.hasOwnProperty.call(S, x) && (b[x] = S[x]);
            }
            return b;
          }, a = /* @__PURE__ */ function() {
            function b(D, S) {
              for (var x = 0; x < S.length; x++) {
                var w = S[x];
                w.enumerable = w.enumerable || !1, w.configurable = !0, "value" in w && (w.writable = !0), Object.defineProperty(D, w.key, w);
              }
            }
            return function(D, S, x) {
              return S && b(D.prototype, S), x && b(D, x), D;
            };
          }(), o = i(0), u = p(o), c = i(1), h = p(c);
          function p(b) {
            return b && b.__esModule ? b : { default: b };
          }
          function m(b, D) {
            if (!(b instanceof D))
              throw new TypeError("Cannot call a class as a function");
          }
          var g = n.BaseOptions = {
            frameContainer: "body",
            frameClassName: "websandbox__frame",
            frameSrc: null,
            frameContent: `
<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"></head>
<body></body>
</html>
  `,
            codeToRunBeforeInit: null,
            initialStyles: null,
            baseUrl: null,
            allowPointerLock: !1,
            allowFullScreen: !1,
            sandboxAdditionalAttributes: ""
          }, O = function() {
            a(b, null, [{
              key: "create",
              /**
               * Creates sandbox instancea
               * @param {?Object} localApi Api of this side. Will be available for sandboxed code as remoteApi
               * @param {?SandboxOptions} options Options of created sandbox
               */
              value: function(S) {
                var x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                return new b(S, s(g, x));
              }
              /**
               * {Constructor}
               * @param {?Object} localApi
               * @param {?SandboxOptions} options
               */
            }]);
            function b(D, S) {
              var x = this;
              m(this, b), this.options = S, this.iframe = this.createIframe(), this.promise = new Promise(function(w) {
                x.connection = new u.default(x.iframe.contentWindow.postMessage.bind(x.iframe.contentWindow), function(T) {
                  var C = function(P) {
                    if (P.source === x.iframe.contentWindow)
                      return T(P);
                  };
                  window.addEventListener("message", C), x.removeMessageListener = function() {
                    return window.removeEventListener("message", C);
                  };
                }, { allowedSenderOrigin: "null" }), x.connection.setServiceMethods({
                  iframeInitialized: function() {
                    return x.connection.setLocalApi(D).then(function() {
                      return w(x);
                    });
                  }
                });
              });
            }
            return a(b, [{
              key: "_prepareFrameContent",
              value: function(S) {
                var x = S.frameContent.replace("</head>", "<script>" + h.default + `<\/script>
</head>`);
                return S.initialStyles && (x = x.replace("</head>", "<style>" + S.initialStyles + `</style>
</head>`)), S.baseUrl && (x = x.replace("<head>", `<head>
<base href="` + S.baseUrl + '"/>')), S.codeToRunBeforeInit && (x = x.replace("<head>", `<head>
<script>` + S.codeToRunBeforeInit + "<\/script>")), x;
              }
            }, {
              key: "createIframe",
              value: function() {
                var S = this.options.frameContainer, x = typeof S == "string" ? document.querySelector(S) : S;
                if (!x)
                  throw new Error("Websandbox: Cannot find container for sandbox " + x);
                var w = document.createElement("iframe");
                if (w.sandbox = "allow-scripts " + this.options.sandboxAdditionalAttributes, w.className = this.options.frameClassName, this.options.allowFullScreen && (w.allowfullscreen = "true"), this.options.frameSrc)
                  return w.src = this.options.frameSrc, x.appendChild(w), w;
                if (this.options.frameContent.indexOf("<head>") < 0)
                  throw new Error('Websandbox: iFrame content must have "<head>" tag.');
                return w.setAttribute("srcdoc", this._prepareFrameContent(this.options)), x.appendChild(w), w;
              }
            }, {
              key: "destroy",
              value: function() {
                this.iframe.remove(), this.removeMessageListener();
              }
            }, {
              key: "_runCode",
              value: function(S) {
                return this.connection.callRemoteServiceMethod("runCode", S);
              }
            }, {
              key: "_runFunction",
              value: function(S) {
                return this._runCode("(" + S.toString() + ")()");
              }
            }, {
              key: "run",
              value: function(S) {
                return S.name ? this._runFunction(S) : this._runCode(S);
              }
            }, {
              key: "importScript",
              value: function(S) {
                return this.connection.callRemoteServiceMethod("importScript", S);
              }
            }, {
              key: "injectStyle",
              value: function(S) {
                return this.connection.callRemoteServiceMethod("injectStyle", S);
              }
            }]), b;
          }();
          n.default = O;
        }
        /******/
      ])
    );
  });
})(pP);
var eee = pP.exports;
const tee = /* @__PURE__ */ vF(eee), ree = ({ output: t }) => {
  const [e, r] = At(t);
  return Qe(() => r(t), [t]), /* @__PURE__ */ z.jsxs("div", { className: "debugger-pane", children: [
    /* @__PURE__ */ z.jsxs("div", { className: "debugger-title-bar", children: [
      /* @__PURE__ */ z.jsx("div", { className: "debugger-title", children: "Console" }),
      /* @__PURE__ */ z.jsx("button", { type: "button", onClick: () => r(void 0), children: "Clear console" })
    ] }),
    /* @__PURE__ */ z.jsx("div", { className: "debugger-view", children: e == null ? void 0 : e.map((n) => n.join(", ")).join(`
`) })
  ] });
}, nee = ({
  contentFrameHeight: t = "1fr",
  debuggerOutput: e,
  children: r
}) => {
  const { config: n } = kr();
  return /* @__PURE__ */ z.jsxs(
    "div",
    {
      className: "debugger-wrapper",
      style: {
        gridTemplateRows: n.showDebug ? `${t} 1fr` : "auto"
      },
      children: [
        /* @__PURE__ */ z.jsx("div", { className: "debugger-wrapper-child", children: r }),
        /* @__PURE__ */ z.jsx(ree, { output: e })
      ]
    }
  );
}, ZD = () => window.alert("Not implemented"), dP = ({ run: t = ZD, finish: e = ZD }) => /* @__PURE__ */ z.jsxs("div", { className: "run-bar", children: [
  /* @__PURE__ */ z.jsx("div", { children: /* @__PURE__ */ z.jsx("button", { type: "button", onClick: t, children: "Run" }) }),
  /* @__PURE__ */ z.jsx("div", { children: /* @__PURE__ */ z.jsx("button", { type: "button", onClick: e, children: "Finish" }) })
] }), iee = ({ file: t }) => {
  const [e, r] = At([]), n = () => {
    const i = {
      consoleLog: (...s) => (r((a) => [...a, s]), Promise.resolve("messaged"))
    };
    for (let s of document.getElementsByClassName("js-preview-output"))
      s.innerHTML = "";
    tee.create(i, {
      frameContainer: ".js-preview-output"
    }).promise.then(function(s) {
      r([]), s.run(
        `
        console.log = Websandbox.connection.remote.consoleLog;
        ${t.contents}
      `
      );
    });
  };
  return /* @__PURE__ */ z.jsxs("div", { className: "js-preview-wrapper", children: [
    /* @__PURE__ */ z.jsx(nee, { contentFrameHeight: "1fr", debuggerOutput: e, children: /* @__PURE__ */ z.jsx("div", { className: "js-preview-container", children: /* @__PURE__ */ z.jsx("div", { className: "js-preview-output", children: "pending..." }) }) }),
    /* @__PURE__ */ z.jsx(dP, { run: n })
  ] });
}, see = ({ file: t }) => {
  let e = "";
  try {
    e = JSON.stringify(JSON.parse(t.contents), void 0, 2);
  } catch (r) {
    const n = YD(r);
    return /* @__PURE__ */ z.jsxs("div", { className: "json-preview", children: [
      "Cannot display json: invalid format.",
      n
    ] });
  }
  return /* @__PURE__ */ z.jsx("div", { className: "json-preview", children: e });
}, WD = {
  html: KK,
  js: iee,
  json: see
}, aee = (t, e = {}) => t ? e[t == null ? void 0 : t.language] ? e[t == null ? void 0 : t.language] : WD[t == null ? void 0 : t.language] ? WD[t == null ? void 0 : t.language] : () => /* @__PURE__ */ z.jsxs("div", { children: [
  "Cannot preview files of type ",
  t == null ? void 0 : t.language
] }) : () => "", oee = () => {
  const {
    project: { files: t },
    config: { previewFileTypes: e, PreviewComponents: r }
  } = kr(), [n, i] = At(
    Object.values(t).find((o) => o.name === "index.html" && !o.folderId)
  ), s = Object.values(t).find(
    (o) => o.active && nc(o.language)
  );
  Qe(() => {
    nc(s == null ? void 0 : s.language, e) && i(s);
  }, [s]), Qe(() => {
    n && !t[n.id] && i(
      Object.values(t).find(
        (o) => nc(o.language, e)
      )
    );
  }, [n, t]);
  const a = aee(n, r);
  return /* @__PURE__ */ z.jsxs("div", { className: "right-pane", children: [
    /* @__PURE__ */ z.jsx(
      "select",
      {
        onChange: (o) => {
          const u = Object.values(t).find(
            (c) => c.id === o.target.value
          );
          i(u);
        },
        value: n == null ? void 0 : n.id,
        children: Object.values(t).sort().filter((o) => nc(o.language, e)).map((o) => /* @__PURE__ */ z.jsx("option", { value: o.id, children: o.name }, o.id))
      }
    ),
    n && /* @__PURE__ */ z.jsx(a, { file: n })
  ] });
}, lee = {
  showPreview: !0,
  showEditor: !0,
  showLeftNav: !0,
  showRunBar: !1
}, Ia = (t, e) => e[t] ?? lee[t] ?? !1, uee = [
  { key: "showLeftNav", width: "1fr" },
  { key: "showPreview", width: "2fr" },
  { key: "showEditor", width: "2fr" }
], cee = [
  { key: "showRunBar", height: "40px" }
], ute = ({
  project: t,
  config: e,
  setProject: r,
  setConfig: n
}) => {
  const i = et(!0), [s, a] = op(EZ, t), o = CZ(a);
  Qe(() => {
    i.current && r(s), i.current = !0;
  }, [s]), Qe(() => {
    o.replaceProject(t, i);
  }, [t, o.replaceProject]);
  const u = ["auto"];
  cee.forEach((h) => {
    Ia(h.key, e) && u.push(h.height);
  });
  const c = [];
  return uee.forEach((h) => {
    Ia(h.key, e) && c.push(h.width);
  }), /* @__PURE__ */ z.jsx(
    CF,
    {
      value: {
        project: s,
        config: e,
        setProject: r,
        setConfig: n,
        ...o
      },
      children: /* @__PURE__ */ z.jsxs(
        "div",
        {
          className: "cdo-ide-outer",
          style: { gridTemplateRows: u.join(" ") },
          children: [
            /* @__PURE__ */ z.jsxs(
              "div",
              {
                className: "cdo-ide-inner",
                style: {
                  gridTemplateColumns: c.join(" ")
                },
                children: [
                  Ia("showLeftNav", e) && /* @__PURE__ */ z.jsx("div", { className: "cdo-ide-area", children: /* @__PURE__ */ z.jsx(BZ, {}) }),
                  Ia("showEditor", e) && /* @__PURE__ */ z.jsx("div", { className: "cdo-ide-area", children: /* @__PURE__ */ z.jsx(JK, {}) }),
                  Ia("showPreview", e) && /* @__PURE__ */ z.jsx(oee, {})
                ]
              }
            ),
            Ia("showRunBar", e) && /* @__PURE__ */ z.jsx(dP, {})
          ]
        }
      )
    }
  );
};
export {
  ute as CDOIDE,
  qD as CDOIDEContext,
  CF as CDOIDEContextProvider,
  XD as editableFileType,
  wZ as findFiles,
  VD as findFolder,
  u0 as findSubFolders,
  kF as getEmptyEditor,
  fee as getEmptyProject,
  YD as getErrorMessage,
  vZ as getNextFileId,
  SZ as getNextFolderId,
  bZ as prettify,
  nc as previewFileType,
  EZ as projectReducer,
  rE as sortFilesByName,
  kr as useCDOIDEContext,
  CZ as useProjectUtilities
};
//# sourceMappingURL=cdo-ide-poc.js.map
